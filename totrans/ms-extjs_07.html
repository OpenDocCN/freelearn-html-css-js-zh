<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Static Data Management</h1></div></div></div><p>So far, we have implemented capabilities related to basic features of the application. From now on, we will start implementing the application's core features, starting with static data management. What exactly is this? Every application has information that is not directly related to the core business, but this information is used by the core business logic somehow.</p><p>There are two types of data in every application: static data<a id="id569" class="indexterm"/> and dynamic data. For example, the types of categories, languages, cities, and countries can exist independently of the core business and can be used by the core business information as well; this is what we call static data because it does not change very often. And there is the <a id="id570" class="indexterm"/>dynamic data, which is the information that changes in the application, what we call core business data. Clients, orders, and sales would be examples of dynamic or core business data.</p><p>We can treat this<a id="id571" class="indexterm"/> static information as though they are independent MySQL tables (since we are using MySQL as the database server), and we can perform all the actions we can do on a MySQL table. So in this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new system module called static data</li><li class="listitem" style="list-style-type: disc">Listing all information as a MySQL table</li><li class="listitem" style="list-style-type: disc">Creating new records on the tables</li><li class="listitem" style="list-style-type: disc">Live search on the table</li><li class="listitem" style="list-style-type: disc">Filtering information</li><li class="listitem" style="list-style-type: disc">Editing and deleting a record</li><li class="listitem" style="list-style-type: disc">Creating an abstract component for reuse in all tables</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec32"/>Presenting the tables</h1></div></div></div><p>If we open <a id="id572" class="indexterm"/>and analyze the <strong>Entity Relationship</strong> (<strong>ER</strong>) diagram<a id="id573" class="indexterm"/> that comes with the Sakila installation, we will notice the following tables:</p><div><img src="img/0457OT_07_01.jpg" alt="Presenting the tables"/></div><div><div><h3 class="title"><a id="note66"/>Note</h3><p>As a reminder, the Sakila database<a id="id574" class="indexterm"/> can be downloaded at <a class="ulink" href="http://dev.mysql.com/doc/index-other.html">http://dev.mysql.com/doc/index-other.html</a>, and its documentation with installation instructions can be found at <a class="ulink" href="http://dev.mysql.com/doc/sakila/en/">http://dev.mysql.com/doc/sakila/en/</a>.</p></div></div><p>These tables can exist independently of the other tables, and we are going to work with them in this chapter.</p><p>When we open <a id="id575" class="indexterm"/>SQL editor in MySQL Workbench (version 6 ) (<a class="ulink" href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a>), we can select a table, right-click on it, and select <strong>Select Rows – Limit 1000</strong>. When we choose this option, a new tab will be opened, and it looks as follows:</p><div><img src="img/0457OT_07_02.jpg" alt="Presenting the tables"/></div><p>The table shown <a id="id576" class="indexterm"/>previously is the <code class="literal">actor</code> table. The idea is to implement screens that look similar to the preceding screenshot for each of the tables that we selected: <strong>Actors</strong>, <strong>Categories</strong>, <strong>Languages</strong>, <strong>Cities</strong>, and <strong>Countries</strong> as displayed in the following screenshot (which is the final result of the code that we will be implementing in this chapter):</p><div><img src="img/0457OT_07_03.jpg" alt="Presenting the tables"/></div><p>Our goal in this chapter is to minimize the amount of code to implement these five screens. This means<a id="id577" class="indexterm"/> we want to create the most generic code as possible and will facilitate future code fixes and enhancements and also make it easier to create new screens with these same features if needed.</p><p>So let's go ahead and start the development.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec33"/>Creating a Model</h1></div></div></div><p>As usual, we <a id="id578" class="indexterm"/>are going to start by creating<a id="id579" class="indexterm"/> the models. First, let's list the tables we will be working with and their columns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Actor</code>: <code class="literal">actor_id</code>, <code class="literal">first_name</code>, <code class="literal">last_name</code>, <code class="literal">last_update</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Category</code>: <code class="literal">category_id</code>, <code class="literal">name</code>, <code class="literal">last_update</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Language</code>: <code class="literal">language_id</code>, <code class="literal">name</code>, <code class="literal">last_update</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">City</code>: <code class="literal">city_id</code>, <code class="literal">city</code>, <code class="literal">country_id</code>, <code class="literal">last_update</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Country</code>: <code class="literal">country_id</code>, <code class="literal">country</code>, <code class="literal">last_update</code></li></ul></div><p>We could create one Model for each of these entities with no problem at all; however, we want to reuse as much code as possible. Take another look at the list of tables and their columns. Notice that all tables have one column in common—the <code class="literal">last_update</code> column.</p><p>All the previous tables have the <code class="literal">last_update</code> column in common. That being said, we can create a super model that contains this field. When we implement the <code class="literal">actor</code> and <code class="literal">category</code> models, we can extend the super Model, in which case we do not need to declare the column. Don't you think?</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec64"/>Abstract Model</h2></div></div></div><p>In OOP, there <a id="id580" class="indexterm"/>is a concept called inheritance, which is a way to reuse the code of existing objects. Ext JS uses an OOP approach, so we <a id="id581" class="indexterm"/>can apply the same concept in Ext JS applications. If you take a look back at the code we already implemented, you will notice that we are already applying inheritance in most of our classes (with the exception of the <code class="literal">util</code> package), but we are creating classes that inherit from Ext JS classes. Now, we will start creating our own super classes.</p><p>As all the models that we will be working with have the <code class="literal">last_update</code> column in common (if you take a look, all the Sakila tables have this column), we can create a super Model with this field. So, we will create a new file under <code class="literal">app/model/staticData</code> named <code class="literal">Base.js</code>:</p><div><pre class="programlisting">Ext.define('Packt.model.staticData.Base', {
    extend: 'Packt.model.Base', //#1

    fields: [
        {
            name: 'last_update',
            type: 'date',
            dateFormat: 'Y-m-j H:i:s'
        }
    ]
});</pre></div><p>This Model has<a id="id582" class="indexterm"/> only one column, that is, <code class="literal">last_update</code>. On the tables, the <code class="literal">last_update</code> column has the type <code class="literal">timestamp</code>, so the <code class="literal">type</code> of the field needs to be <code class="literal">date</code>, and we will also apply <code class="literal">date format: </code>'<code class="literal">Y-m-j H:i:s</code>', which is years, months, days, hours, minutes, and seconds, following the same format as we have in the database (<code class="literal">2006-02-15 04:34:33</code>).</p><p>When we can<a id="id583" class="indexterm"/> create each Model representing the tables, we will not need to declare the <code class="literal">last_update</code> field again.</p><p>Look again at the code at line <code class="literal">#1</code>. We are not extending the default <code class="literal">Ext.data.Model</code> class, but another <code class="literal">Base</code> class. Remember the <code class="literal">security.Base</code> Model we created in the preceding chapter? We are going to move its code to the model package and make some changes.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec37"/>Adapting the Base Model schema</h3></div></div></div><p>Create a file <a id="id584" class="indexterm"/>named <code class="literal">Base.js</code> inside<a id="id585" class="indexterm"/> the <code class="literal">app/model</code> folder with the following content in it:</p><div><pre class="programlisting">Ext.define('Packt.model.Base', {
    extend: 'Ext.data.Model',

    requires: [
        'Packt.util.Util'
    ],

    schema: {
        namespace: 'Packt.model', //#1
        urlPrefix: 'php',
        proxy: {
            type: 'ajax',
            api :{
                read : '{prefix}/{entityName:lowercase}/list.php',
                create: 
                    '{prefix}/{entityName:lowercase}/create.php',
                update: 
                    '{prefix}/{entityName:lowercase}/update.php',
                destroy: 
                    '{prefix}/{entityName:lowercase}/destroy.php'
            },
            reader: {
                type: 'json',
                rootProperty: 'data'
            },
            writer: {
                type: 'json',
                writeAllFields: true,
                encode: true,
                rootProperty: 'data',
                allowSingle: false
            },
            listeners: {
                exception: function(proxy, response, operation){
              Packt.util.Util.showErrorMsg(response.responseText);
                }
            }
        }
    }
});</pre></div><p>The only<a id="id586" class="indexterm"/> difference <a id="id587" class="indexterm"/>between this code and the code we implemented in the preceding chapter is <code class="literal">namespace</code> (<code class="literal">#1</code>). Instead of using <code class="literal">Packt.model.security</code>, we are going to use only <code class="literal">Packt.model</code>.</p><p>The <code class="literal">Packt.model.security.Base</code> class we created in the preceding chapter will look simpler now as follows:</p><div><pre class="programlisting">Ext.define('Packt.model.security.Base', {
    extend: 'Packt.model.Base',

    idProperty: 'id',

    fields: [
        { name: 'id', type: 'int' }
    ]
});</pre></div><p>It is very similar to the <code class="literal">staticData.Base</code> Model we are creating for this chapter. The difference is in the field that is common for the <code class="literal">staticData</code> package (<code class="literal">last_update</code>) and <code class="literal">security</code> package (<code class="literal">id</code>).</p><p>Having a single<a id="id588" class="indexterm"/> schema for the application now means <code class="literal">entityName</code> of the models will be created based on their name after <code class="literal">'Packt.model'</code>. This means that the <code class="literal">User</code> and <code class="literal">Group</code> models we created in the preceding chapter will have <code class="literal">entityName</code> <code class="literal">security.User</code>, and <code class="literal">security.Group</code> respectively. However, we do not want to break the code we have implemented already, and for this reason we want the <code class="literal">User</code> and <code class="literal">Group</code> Model classes to have the entity name as <code class="literal">User</code> and <code class="literal">Group</code>. We can do this by adding <code class="literal">entityName: 'User'</code> to the <code class="literal">User</code> Model and <code class="literal">entityName: 'Group'</code> to the <code class="literal">Group</code> Model. We will do the same for the specific models we will be creating next.</p><p>Having a super <code class="literal">Base</code> Model <a id="id589" class="indexterm"/>for all models within the application means our models will follow a pattern. The proxy template is also common for all models, and this means our server-side code will also follow a pattern. This is good to organize the application and for future maintenance.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec65"/>Specific models</h2></div></div></div><p>Now<a id="id590" class="indexterm"/> we can create all the models representing each table. Let's start with the Actor Model. We will create a new class named <code class="literal">Packt.model.staticData.Actor</code>; therefore, we need to create a new file name <code class="literal">Actor.js</code> under <code class="literal">app/model/staticData</code>, as follows:</p><div><pre class="programlisting">Ext.define('Packt.model.staticData.Actor', {
    extend: 'Packt.model.staticData.Base', //#1

    entityName: 'Actor', //#2

    idProperty: 'actor_id', //#3

    fields: [
        { name: 'actor_id' },
        { name: 'first_name'},
        { name: 'last_name'}
    ]
});</pre></div><p>There are three important things we need to note in the preceding code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This Model is extending (<code class="literal">#1</code>) from the <code class="literal">Packt.model.staticData.Base</code> class, which extends from the <code class="literal">Packt.model.Base</code> class, which in turn extends from the <code class="literal">Ext.data.Model</code> class. This means this Model inherits all the attributes and behavior from the classes <code class="literal">Packt.model.staticData.Base</code>, <code class="literal">Packt.model.Base</code>, and <code class="literal">Ext.data.Model</code>.</li><li class="listitem" style="list-style-type: disc">As we created a super Model with the schema <code class="literal">Packt.model</code>, the default <code class="literal">entityName</code> created for this Model would be <code class="literal">staticData.Actor</code>. We are using <code class="literal">entityName</code> to help the proxy compile the <code class="literal">url</code> template with <code class="literal">entityName</code>. To make our life easier we are going to overwrite <code class="literal">entityName</code> as well (<code class="literal">#2</code>).</li><li class="listitem" style="list-style-type: disc">The third point is <code class="literal">idProperty</code> (<code class="literal">#3</code>). By default, <code class="literal">idProperty</code> has the value "<code class="literal">id</code>". This means that when we declare a Model with a field named "<code class="literal">id</code>", Ext JS already knows that this is the unique field of this Model. When it is different from "<code class="literal">id</code>", we need to specify it using the <code class="literal">idProperty</code> configuration. As all Sakila tables do not have a unique field called "<code class="literal">id</code>"—it is always the <em>name of the entity</em> + "<em>_id</em>"—we will need to declare this configuration in all models.</li></ul></div><p>Now we can do the same for the other models. We need to create four more classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.model.staticData.Category</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.model.staticData.Language</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.model.staticData.City</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.model.staticData.Country</code></li></ul></div><p>At the end, we <a id="id591" class="indexterm"/>will have six Model classes (one super Model and five specific models) created inside the <code class="literal">app/model/staticData</code> package. If we create a UML-class diagram for the Model classes, we will have the following diagram:</p><div><img src="img/0457OT_07_04.jpg" alt="Specific models"/></div><p>The <strong>Actor</strong>, <strong>Category</strong>, <strong>Language</strong>, <strong>City</strong>, and <strong>Country</strong> models <a id="id592" class="indexterm"/>extend the <code class="literal">Packt.model.staticData</code> Base Model, which extends from <code class="literal">Packt.model.Base</code>, which in turn extends the <code class="literal">Ext.data.Model</code> class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Creating a Store</h1></div></div></div><p>The next <a id="id593" class="indexterm"/>step is to create the stores for each Model. As<a id="id594" class="indexterm"/> we did with the Model, we will try to create a generic Store as well (in this chapter, will create a generic code for all screens, so creating a super Model, Store, and View is part of the capability). Although the common configurations are not in the Store, but in the Proxy (which we declared inside the schema in the <code class="literal">Packt.model.Base</code> class), having a super Store class can help us to listen to events that are common for all the static data stores.</p><p>We will create a super Store named <code class="literal">Packt.store.staticData.Base</code>.</p><p>As we need a Store for each Model, we will create the following stores:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.store.staticData.Actors</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.store.staticData.Categories</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.store.staticData.Languages</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.store.staticData.Cities</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.store.staticData.Countries</code></li></ul></div><p>At the end of <a id="id595" class="indexterm"/>this topic, we will have created all the previous <a id="id596" class="indexterm"/>classes. If we create a UML diagram for them, we will have something like the following diagram:</p><div><img src="img/0457OT_07_05.jpg" alt="Creating a Store"/></div><p>All the Store classes extend from the <code class="literal">Base</code> Store.</p><p>Now that we know what we need to create, let's get our hands dirty!</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec66"/>Abstract Store</h2></div></div></div><p>The<a id="id597" class="indexterm"/> first class we need to create is the <code class="literal">Packt.store.staticData.Base</code> class. Inside this class, we will only declare <code class="literal">autoLoad</code> as <code class="literal">true</code> so that all the subclasses of this Store can be loaded when the application launches:</p><div><pre class="programlisting">Ext.define('Packt.store.staticData.Base', {
    extend: 'Ext.data.Store',

    autoLoad: true
});</pre></div><p>All the specific stores that we will create will extend this Store. Creating a super Store like this can feel pointless; however, we do not know that during future maintenance, we will need to add some common Store configuration.</p><p>As we will use MVC for this module, another reason is that inside the Controller, we can also listen to Store events (available since Ext JS 4.2). If we want to listen to the same event of a set of stores and we execute exactly the same method, having a super Store will save us some lines of code.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Specific Store</h2></div></div></div><p>Our <a id="id598" class="indexterm"/>next step is to implement the <code class="literal">Actors</code>, <code class="literal">Categories</code>, <code class="literal">Languages</code>, <code class="literal">Cities</code>, and <code class="literal">Countries</code> stores.</p><p>So let's start with the <code class="literal">Actors</code> Store:</p><div><pre class="programlisting">Ext.define('Packt.store.staticData.Actors', {
    extend: 'Packt.store.staticData.Base', //#1

    model: 'Packt.model.staticData.Actor' //#2
});</pre></div><p>After the definition of the Store, we need to extend from the Ext JS <code class="literal">Store</code> class. As we are using a super Store, we can extend directly from the super Store (<code class="literal">#1</code>), which means extending from the <code class="literal">Packt.store.staticData.Base</code> class.</p><p>Next, we need to declare the <code class="literal">fields</code> or the <code class="literal">model</code> that this Store is going to represent. In our case, we always declare the Model (<code class="literal">#2</code>).</p><div><div><h3 class="title"><a id="note67"/>Note</h3><p>Using a <code class="literal">model</code> inside the Store is good for reuse purposes. The <code class="literal">fields</code> configuration is recommended just in case we need to create a very specific Store with specific data that we are not planning to reuse throughout the application, as in a chart or a report.</p></div></div><p>For the other stores, the only thing that is going to be different is the name of the Store and the Model.</p><div><div><h3 class="title"><a id="note68"/>Note</h3><p>As models and stores are very similar, we are not going to list their code in this chapter. However, if you need the code to compare with yours or simply want to get the complete source code, you can download the code bundle from this book or get it at <a class="ulink" href="https://github.com/loiane/masteringextjs">https://github.com/loiane/masteringextjs</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Creating an abstract GridPanel for reuse</h1></div></div></div><p>Now is the <a id="id599" class="indexterm"/>time to implement the views. We <a id="id600" class="indexterm"/>have to implement five views: one to perform the CRUD operations for Actor, one for Category, one for Language, one for City, and one for Country.</p><p>The following screenshot represents the final result we want to achieve after implementing the <strong>Actors</strong> screen:</p><div><img src="img/0457OT_07_06.jpg" alt="Creating an abstract GridPanel for reuse"/></div><p>And the<a id="id601" class="indexterm"/> following screenshot represents the final result we want to achieve after implementing the <strong>Categories</strong> screen:</p><div><img src="img/0457OT_07_07.jpg" alt="Creating an abstract GridPanel for reuse"/></div><p>Did you <a id="id602" class="indexterm"/>notice anything similar between these two screens? Let's take a look again:</p><div><img src="img/0457OT_07_08.jpg" alt="Creating an abstract GridPanel for reuse"/></div><p>The top toolbar is the same (<strong>1</strong>); there is a Live Search capability (<strong>2</strong>); there is a filter plugin (<strong>4</strong>), and the <strong>Last Update</strong> and widget columns are also common (<strong>3</strong>). Going a little bit further, both <a id="id603" class="indexterm"/>GridPanels can be edited using a cell editor (similar to MS Excel capabilities, where you can edit a single cell by clicking on it). The only things different between these two screens are the columns that are specific to each screen (<strong>5</strong>). Does this mean we can reuse a good part of the code if we use inheritance by creating a super GridPanel with all these common capabilities? Yes!</p><p>So this is what we are going to do. So let's create a new class named <code class="literal">Packt.view.staticData.BaseGrid</code>, as follows:</p><div><pre class="programlisting">Ext.define('Packt.view.staticData.BaseGrid', {
    extend: 'Ext.ux.LiveSearchGridPanel', //#1
    xtype: 'staticdatagrid',

    requires: [
        'Packt.util.Glyphs' //#2
    ],

    columnLines: true,    //#3
    viewConfig: {
        stripeRows: true //#4
    },

    //more code here
});    </pre></div><p>We will extend the <code class="literal">Ext.ux.LiveSearchGridPanel</code> class instead of <code class="literal">Ext.grid.Panel</code>. The <code class="literal">Ext.ux.LiveSearchGridPanel</code> class already extends the <code class="literal">Ext.grid.Panel</code> class and also adds the Live Search toolbar (<strong>2</strong>). The <code class="literal">LiveSearchGridPanel</code> class is a plugin that is distributed with the Ext JS SDK. So, we do not need to worry about adding it manually to our project (you will learn how to add third-party plugins to the project later in this book).</p><p>As we will also add a toolbar with the <strong>Add</strong>, <strong>Save Changes</strong>, <strong>Cancel Changes</strong> buttons, we need to require the <code class="literal">util.Glyphs</code> class we created (<code class="literal">#2</code>).</p><p>The configurations <code class="literal">#3</code> and <code class="literal">#4</code> show the border of each cell of the grid and to alternate between a white background and a light gray background.</p><p>Likewise, any other component that is responsible for displaying information in Ext JS, such as the "Panel" piece is only the shell. The View is responsible for displaying the columns in a GridPanel. We can customize it using the <code class="literal">viewConfig</code> (<code class="literal">#4</code>).</p><p>The next step is to create an <code class="literal">initComponent</code> method.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>To initComponent or not?</h2></div></div></div><p>While browsing other developers' code, we might see some using the <code class="literal">initComponent</code> when declaring an Ext JS class and some who do not (as we have done until now). So what is the difference between using it and not using it?</p><p>When <a id="id604" class="indexterm"/>declaring an Ext JS class, we usually configure it according to the application needs. They might become either a parent class for other classes or not. If they become a parent class, some of the configurations will be overridden, while some will not. Usually, we declare the ones that we expect to override in the class as configurations. We declare inside the <code class="literal">initComponent</code> method the ones we do not want to be overridden.</p><p>As there are a few configurations we do not want to be overridden, we will declare them inside the <code class="literal">initComponent</code>, as follows:</p><div><pre class="programlisting">initComponent: function() {
    var me = this;

    me.selModel = {
        selType: 'cellmodel' //#5
    };

    me.plugins = [
        {
            ptype: 'cellediting',  //#6
            clicksToEdit: 1,
            pluginId: 'cellplugin'
        },
        {
            ptype: 'gridfilters'  //#7
        }
    ];

    //docked items

    //columns

    me.callParent(arguments); //#8
}</pre></div><p>We can define how the user can select information from the GridPanel: the default configuration is the <code class="literal">Selection RowModel</code> class. As we want the user to be able to edit cell by cell, we will use the <code class="literal">Selection CellModel</code> class (<code class="literal">#5</code>) and also the <code class="literal">CellEditing</code> plugin (<code class="literal">#6</code>), which is part of the Ext JS SDK. For the <code class="literal">CellEditing</code> plugin, we configure the cell to be available to edit when the user clicks on the cell (if we need the user to double-click, we can change to <code class="literal">clicksToEdit: 2</code>). To help us later in the Controller, we also assign an ID to this plugin.</p><p>To be able to<a id="id605" class="indexterm"/> filter the information (the Live Search will only highlight the matching records), we will use the <strong>Filters</strong> plugin (<code class="literal">#7</code>). The <strong>Filters</strong> plugin is also part of the Ext JS SDK.</p><p>The <code class="literal">callParent</code> method (<code class="literal">#8</code>) will call <code class="literal">initConfig</code> from the superclass <code class="literal">Ext.ux.LiveSearchGridPanel</code> passing the arguments we defined.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>It is a common mistake to forget to include the <code class="literal">callParent</code> call when overriding the <code class="literal">initComponent</code> method. If the component does not work, make sure you are calling the <code class="literal">callParent</code> method!</p></div></div><p>Next, we are going to declare <code class="literal">dockedItems</code>. As all GridPanels will have the same toolbar, we can declare <code class="literal">dockedItems</code> in the super class we are creating, as follows:</p><div><pre class="programlisting">me.dockedItems = [
    {
        xtype: 'toolbar',
        dock: 'top',
        itemId: 'topToolbar', //#9
        items: [
            {
                xtype: 'button',
                itemId: 'add', //#10
                text: 'Add',
                glyph: Packt.util.Glyphs.getGlyph('add')
            },
            {
                xtype: 'tbseparator'
            },
            {
                xtype: 'button',
                itemId: 'save', 
                text: 'Save Changes',
                glyph: Packt.util.Glyphs.getGlyph('saveAll')
            },
            {
                xtype: 'button',
                itemId: 'cancel',
                text: 'Cancel Changes',
                glyph: Packt.util.Glyphs.getGlyph('cancel')
            },
            {
                xtype: 'tbseparator'
            },
            {
                xtype: 'button',
                itemId: 'clearFilter',
                text: 'Clear Filters',
                glyph: Packt.util.Glyphs.getGlyph('clearFilter')
            }
        ]
    }
];</pre></div><p>We will <a id="id606" class="indexterm"/>have <strong>Add</strong>, <strong>Save Changes</strong>, <strong>Cancel Changes</strong>, and <strong>Clear Filters</strong> buttons. Note that the toolbar (<code class="literal">#9</code>) and each of the buttons (<code class="literal">#10</code>) has <code class="literal">itemId</code> declared. As we are going to use the MVC approach in this example, we will declare a Controller. The <code class="literal">itemId</code> configuration has a responsibility similar to the reference that we declare when working with a ViewController. We will discuss the importance of <code class="literal">itemId</code> more when we declare the Controller later in this chapter.</p><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>When declaring buttons inside a toolbar, we can omit the <code class="literal">xtype: 'button'</code> configuration since the button is the default component for toolbars.</p></div></div><p>Inside the <code class="literal">Glyphs</code> class, we need to add the following attributes inside its <code class="literal">config</code>:</p><div><pre class="programlisting">saveAll: 'xf0c7',
clearFilter: 'xf0b0'</pre></div><p>And finally, we will add the two columns that are common for all the screens (<code class="literal">Last Update</code> column and Widget Column <code class="literal">delete</code> (<code class="literal">#13</code>)) along with the columns already declared in each specific GridPanel:</p><div><pre class="programlisting">me.columns = Ext.Array.merge( //#11
    me.columns,               //#12
    [{
        xtype    : 'datecolumn',
        text     : 'Last Update',
        width    : 150,
        dataIndex: 'last_update',
        format: 'Y-m-j H:i:s',
        filter: true
    },
    {
        xtype: 'widgetcolumn', //#13
        width: 45,
        sortable: false,       //#14
        menuDisabled: true,    //#15
        itemId: 'delete',
        widget: {
            xtype: 'button',   //#16
            glyph: Packt.util.Glyphs.getGlyph('destroy'),
            tooltip: 'Delete',
            scope: me,                //#17
            handler: function(btn) {  //#18
                me.fireEvent('widgetclick', me, btn);
            }
        }
    }]
);</pre></div><p>In the<a id="id607" class="indexterm"/> preceding code we merge (<code class="literal">#11</code>) <code class="literal">me.columns</code> (<code class="literal">#12</code>) with two other <code class="literal">columns</code> and assign this value to <code class="literal">me.columns</code> again. We want all child grids to have these two columns plus the specific columns for each child grid. If the columns configuration from the <code class="literal">BaseGrid</code> class were outside <code class="literal">initConfig</code>, then when a child class declared its own columns configuration the value would be overridden. If we declare the <code class="literal">columns</code> configuration inside <code class="literal">initComponent</code>, a child class would not be able to add its own <code class="literal">columns</code> configuration, so we need to merge these two configurations (the columns from the child class <code class="literal">#12</code> with the two columns we want each child class to have).</p><p>For the delete button, we are going to use a Widget Column (<code class="literal">#13</code>) (introduced in Ext JS 5). Until Ext JS 4, the only way to have a button inside a Grid Column was using an Action Column. We are going to use a button (<code class="literal">#16</code>) to represent a Widget Column. Because it is a Widget Column, there is no reason to make this column <code class="literal">sortable</code> (<code class="literal">#14</code>), and we can also disable its menu (<code class="literal">#15</code>).</p><p>We are going to discuss lines <code class="literal">#17</code> and <code class="literal">#18</code> in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Handling the Widget Column in the MVC architecture</h2></div></div></div><p>Let's take a<a id="id608" class="indexterm"/> look again at the Widget Column declared in the super GridPanel, especially in the <code class="literal">handler</code> configuration:</p><div><pre class="programlisting">scope: me,                //#17
handler: function(btn) {  //#18
    me.fireEvent('widgetclick', me, btn);
}</pre></div><p>Even though the Widget Column is a widget and contains <code class="literal">xtype</code>, it is not possible to listen to its events in the MVC Controller, so we need a workaround to make it work in the MVC architecture. The reason is that the items that can be declared inside a Widget Column are subclasses of the <code class="literal">Ext.Widget</code> class, which is a subclass of the <code class="literal">Ext.Evented</code> class. MVC Controllers can only listen to events fired by a component subclass (panel, button, grid, tree, chart, and so on).</p><p>That is why we are firing a custom event (<code class="literal">#18</code>) passing the parameters we need, so we can catch this event in this Controller and handle the programming logic needed to delete a record.</p><p>In this example, we<a id="id609" class="indexterm"/> are setting <code class="literal">scope</code> of the handler as <code class="literal">me</code> (<code class="literal">#17</code>), which refers to <code class="literal">this</code> of the GridPanel. This means it will be the GridPanel that will be firing the <code class="literal">widgetclick</code> event, passing the grid itself and the widget button. The <code class="literal">btn</code> parameter contains a method named <code class="literal">getWidgetRecord</code>, which is used to retrieve the Model represented by the GridPanel row where the user clicked on the <strong>Delete</strong> button.</p><p>If we were using an Action Column (a very popular choice until Ext JS 4) we would handle it in the MVC architecture in the same way (firing a custom event). An example can be found at: <a class="ulink" href="http://goo.gl/pxdU4i">http://goo.gl/pxdU4i</a>.</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>Handling Widget Column handlers in the MVVM approach is easier. Instead of firing a custom event, we can simply refer to the method used in the ViewController as follows: <code class="literal">handler: 'onWidgetClick'</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Live Search plugin versus Filter plugin</h2></div></div></div><p>Both plugins<a id="id610" class="indexterm"/> have the objective of helping the user to search for information quickly. In our project, we are using both.</p><p>The<a id="id611" class="indexterm"/> Live Search plugin<a id="id612" class="indexterm"/> will search for any matching result in all the columns of the GridPanel. The search is also performed locally, which means that if we use the paging toolbar, this plugin will not work as expected. When using the paging toolbar, the grid only displays one page at a time, which means it is a limited number of rows. The remaining information is not kept locally, the paging toolbar only fetches the requested information, and this is the reason the search will not work when using paging. In our case, we display all the records from the database at once, so the plugin works as expected. For example, if we search for "<code class="literal">ada</code>", we will get the following output:</p><div><img src="img/0457OT_07_09.jpg" alt="Live Search plugin versus Filter plugin"/></div><p>And the <a id="id613" class="indexterm"/>Filter plugin will apply the filters on the Store as well, so it will only display to the user the matching results, as follows:</p><div><img src="img/0457OT_07_10.jpg" alt="Live Search plugin versus Filter plugin"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Specific GridPanels for each table</h2></div></div></div><p>Our last stop<a id="id614" class="indexterm"/> before we implement the Controller is the specific GridPanels. We have already created the super GridPanel that contains most of the capabilities that we need. Now we just need to declare the specific configurations for each GridPanel.</p><p>We will create five GridPanels that will extend from the <code class="literal">Packt.view.staticData.BaseGrid</code> class, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.view.staticData.Actors</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.view.staticData.Categories</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.view.staticData.Languages</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.view.staticData.Cities</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Packt.view.staticData.Countries</code></li></ul></div><p>Let's start with the <code class="literal">Actors</code> GridPanel, as follows:</p><div><pre class="programlisting">Ext.define('Packt.view.staticData.Actors', {
    extend: 'Packt.view.staticData.BaseGrid',
    xtype: 'actorsgrid',        //#1

    store: 'staticData.Actors', //#2

    columns: [
        {
            text: 'Actor Id',
            width: 100,
            dataIndex: 'actor_id',
            filter: {
                type: 'numeric'   //#3
            }
        },
        {
            text: 'First Name',
            flex: 1,
            dataIndex: 'first_name',
            editor: {
                allowBlank: false, //#4
                maxLength: 45      //#5
            },
            filter: {
                type: 'string'     //#6
            }
        },
        {
            text: 'Last Name',
            width: 200,
            dataIndex: 'last_name',
            editor: {
                allowBlank: false, //#7
                maxLength: 45      //#8
            },
            filter: {
                type: 'string'     //#9
            }
        }
    ]
});</pre></div><p>Each specific<a id="id615" class="indexterm"/> class has its own <code class="literal">xtype</code> (<code class="literal">#1</code>). We also need to execute an <code class="literal">UPDATE</code> query in the database to update the menu table with the new xtypes we are creating:</p><div><pre class="programlisting">UPDATE `sakila`.`menu` SET `className`='actorsgrid' WHERE `id`='5';
UPDATE `sakila`.`menu` SET `className`='categoriesgrid' WHERE `id`='6';
UPDATE `sakila`.`menu` SET `className`='languagesgrid' WHERE `id`='7';
UPDATE `sakila`.`menu` SET `className`='citiesgrid' WHERE `id`='8';
UPDATE `sakila`.`menu` SET `className`='countriesgrid' WHERE `id`='9';</pre></div><p>The first declaration that is specific to the <code class="literal">Actors</code> GridPanel is the Store (<code class="literal">#2</code>). We are going to use the <code class="literal">Actors</code> Store. Because the <code class="literal">Actors</code> Store is inside the <code class="literal">staticData</code> folder (<code class="literal">store/staticData</code>), we also need to pass the name of the subfolder; otherwise, Ext JS will think that this Store file is inside the <code class="literal">app/store</code> folder, which is not true.</p><p>Then we need to declare the <code class="literal">columns</code> specific to the <code class="literal">Actors</code> GridPanel (we do not need to declare the <code class="literal">Last Update</code> and the <code class="literal">Delete</code> Action Column because they are already in the super GridPanel).</p><p>What you need to pay attention to now are the <code class="literal">editor</code> and <code class="literal">filter</code> configurations for each column. The <code class="literal">editor</code> is for editing (<code class="literal">cellediting</code> plugin). We will only apply this configuration to the columns we want the user to be able to edit, and the <code class="literal">filter</code> (<code class="literal">filters</code> plugin) is the configuration that we will apply to the <code class="literal">columns</code> we want the user to be able to <code class="literal">filter</code> information from.</p><p>For example, for the <code class="literal">id</code> column, we do not want the user to be able to edit it as it is a sequence provided by the MySQL database auto increment, so we will not apply the <code class="literal">editor</code> configuration to it. However, the user can filter the information based on the ID, so we will apply the <code class="literal">filter</code> configuration (<code class="literal">#3</code>).</p><p>We want the <a id="id616" class="indexterm"/>user to be able to edit the other two columns: <code class="literal">first_name</code> and <code class="literal">last_name</code>, so we will add the <code class="literal">editor</code> configuration. We can perform client validations as we can do on a field of a form too. For example, we want both fields to be mandatory (<code class="literal">#4</code> and <code class="literal">#7</code>) and the maximum number of characters the user can enter is <code class="literal">45</code> (<code class="literal">#5</code> and <code class="literal">#8</code>).</p><p>And at last, as both columns are rendering text values (<code class="literal">string</code>), we will also apply <code class="literal">filter</code> (<code class="literal">#6</code> and <code class="literal">#9</code>).</p><p>For other filter types, please refer to the Ext JS documentation as shown in the following screenshot. The documentation provides an example and more configuration options that we can use:</p><div><img src="img/0457OT_07_11.jpg" alt="Specific GridPanels for each table"/></div><p>And that is it! The super GridPanel will provide all the other capabilities.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Adding the Live Search CSS</h2></div></div></div><p>When we <a id="id617" class="indexterm"/>navigate to the <a id="id618" class="indexterm"/>Live Search Grid example (<a class="ulink" href="http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html">http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html</a>) and we go through its source code, we can see that the example imports two CSS files: the <code class="literal">LiveSearchGridPanel.css</code> and <code class="literal">statusbar.css</code> (because the Live Search plugin has a dependency on the <code class="literal">statusbar</code> plugin). We also need to add this CSS to our application.</p><p>We are going<a id="id619" class="indexterm"/> to copy these two CSS files and rename the extension to <code class="literal">scss</code>. The Live Search CSS can be copied from <code class="literal">ext/src/ux/css</code>, and the <code class="literal">statusbar</code> CSS can be copied from <code class="literal">ext/src/ux/statusbar</code>. We need to place these two files inside our application custom CSS, which is located in the <code class="literal">sass/etc</code> directory. Create a new folder named <code class="literal">ux</code> and paste these files. Inside <code class="literal">all.scss</code>, we are going to import these two Sass files:</p><div><pre class="programlisting">@import "ux/statusbar";
@import "ux/LiveSearchGridPanel";</pre></div><p>The <code class="literal">statusbar</code> plugin displays an icon, and we need to fix the path to the <code class="literal">statusbar</code> images as well. Inside the <code class="literal">statusbar.scss</code> file, replace all matches "<code class="literal">../images</code>" by "<code class="literal">images/statusbar</code>". Go to <code class="literal">ext/src/ux/statusbar</code>, copy the <code class="literal">images</code> folder, and paste it inside <code class="literal">resources/images</code>. Rename <code class="literal">resources/images/images</code> to <code class="literal">resources/images/statusbar</code>. If you have <code class="literal">Sencha app watch</code> being executed in the terminal, Sencha Cmd will rebuild the app CSS file and the plugin will work 100 percent.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Generic Controller for all tables</h1></div></div></div><p>Now it is time<a id="id620" class="indexterm"/> to implement the last piece of the static data module. The goal is to implement a Controller that has the most generic code that <a id="id621" class="indexterm"/>will provide the functionalities for all the screens, without us having to create any specific method for any screens.</p><p>So let's start with the base of the Controller. We are going to create a new class named <code class="literal">Packt.controller.StaticData</code>, as follows:</p><div><pre class="programlisting">Ext.define('Packt.controller.StaticData', {
    extend: 'Ext.app.Controller',

    requires: [
        'Packt.util.Util', //#1
        'Packt.util.Glyphs'
    ],

    stores: [  //#2
        'staticData.Actors',
        'staticData.Categories',
        'staticData.Cities',
        'staticData.Countries',
        'staticData.Languages'
    ],

    views: [ //#3
        'staticData.BaseGrid',
        'staticData.Actors',
        'staticData.Categories',
        'staticData.Cities',
        'staticData.Countries',
        'staticData.Languages'
    ],

    init: function(application) {
        var me = this;
        me.control({
            //event listeners here
        });   
    }
});</pre></div><p>For now, we are <a id="id622" class="indexterm"/>going to declare the <code class="literal">requires</code> ((<code class="literal">#1</code>)—we are going to use the <code class="literal">Util</code> class in some methods and also the <code class="literal">Glyphs</code> class), the <code class="literal">stores</code> ((<code class="literal">#2</code>)—where we can list all the stores of this module), and also the <code class="literal">views</code> ((<code class="literal">#3</code>)—where we can list all views of this module).</p><p>As we are instantiating the views by their <code class="literal">xtype</code>, we need to declare them somewhere (<code class="literal">#2</code>). This can be inside the <code class="literal">requires</code> configuration in the <code class="literal">Application.js</code> file or inside a Controller. This is needed because Ext JS does not know the xtypes we are creating, so the names of the classes need to be listed somewhere.</p><p>The <code class="literal">stores</code> declaration (<code class="literal">#2</code>) that we are listing in this Controller will be instantiated when the Controller is instantiated as well. As this is a Controller from the MVC architecture, its scope is global, and it will be created when the application launches. Using the MVC approach for this case is interesting; after all, we are constructing the static data module that refers to common data used by other entities of the application. In this case, this information will be live throughout the life cycle of the application. This is unlike the Views, ViewModels, ViewControllers, and stores declared inside ViewModels, which are alive as long as the View is alive (tab opened). As we set <code class="literal">autoLoad:true</code> in the <code class="literal">Base</code> Store, when the application launches, the stores listed in this Controller will be instantiated and loaded.</p><p>We also have the <code class="literal">init</code> function and <code class="literal">this.control</code> where we are going to listen to all the events that we are interested in.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Finding the correct selector</h2></div></div></div><p>On the toolbar from<a id="id623" class="indexterm"/> each static data grid panel, we have a button with the text <strong>Add</strong>. When we click on this button, we want to add a new Model entry to the Store (and consequently, add a new record on the GridPanel) and enable editing so that the user can fill in the values to save them later (when they click on the <strong>Save Changes</strong> button).</p><p>When listening to an event in a Controller, first we need to pass the selector that is going to be used by the <code class="literal">Ext.ComponentQuery</code> class to find the component. Then we need to list the event that we want to listen to. And then, we need to declare the function that is going to be executed when the event we are listening to is fired, or declare the name of the Controller method that is going to be executed when the event is fired. In our case, we are going to declare the method only for code organization purposes.</p><p>Now let's focus on finding the correct selector for the <strong>Add</strong> button (the other buttons will be similar as well). According to the <code class="literal">Ext.ComponentQuery</code> API documentation, we can retrieve components by using their <code class="literal">xtype</code> (if you are already familiar with JQuery, you will notice that <code class="literal">Ext.ComponentQuery</code> selector behavior is very similar to JQuery selector behavior). Well, we are trying to retrieve two buttons, and their <code class="literal">xtype</code> is <code class="literal">button</code>. We can then try the selector <code class="literal">'button'</code>. But before we start coding, let's make sure that this is the correct selector to avoid changing the code all the time trying to figure out the correct selector. There is one very useful tip we can try: open the browser console—Command Editor—and type the following command and click on Run:</p><div><pre class="programlisting">Ext.ComponentQuery.query('button');</pre></div><p>As we can see in the following screenshot, it returned an array of the buttons that were found by the selector we used, and the array contains several buttons! Too many buttons is not what we want. We want to narrow down to the <strong>Add</strong> button from the <strong>Actors</strong> screen, as shown in the following screenshot:</p><div><img src="img/0457OT_07_12.jpg" alt="Finding the correct selector"/></div><p>Let's try to draw<a id="id624" class="indexterm"/> a path of the <strong>Actors</strong> screen using the components <code class="literal">xtype</code> we used. We have the <strong>Actors</strong> screen (<code class="literal">xtype: actorsgrid</code>); inside the screen, we have a toolbar (<code class="literal">xtype: toolbar</code>); and inside the toolbar, we have some buttons (<code class="literal">xtype: button</code>). Therefore, we have <code class="literal">actorsgrid</code> | <code class="literal">toolbar</code> | <code class="literal">button</code>. So we can try the following command:</p><div><pre class="programlisting">Ext.ComponentQuery.query('actorsgrid toolbar button');</pre></div><p>So let's try this last selector on the <strong>Console</strong>, as follows:</p><div><img src="img/0457OT_07_13.jpg" alt="Finding the correct selector"/></div><p>Now the result is <a id="id625" class="indexterm"/>an array of six buttons, and these are the buttons that we are looking for! There is still one detail missing: if we use the <code class="literal">'actorsgrid toolbar button'</code> selector, it will listen to the click event (which is the event we want to listen to) of all the six buttons.</p><p>However, when we click on the <strong>Cancel</strong> button, an action should happen; when we click on the <strong>Save</strong> button, a different action should happen because it is a different button. So we still want to narrow down the selector even more until it returns the <strong>Add</strong> button that we are looking for.</p><p>Going back to the Base Grid panel code, notice that we declared a configuration named <code class="literal">itemId</code> for all buttons. We can use these <code class="literal">itemId</code> configurations to identify the buttons in a unique way. And according to the <code class="literal">Ext.ComponentQuery</code> API documentation, we can use <code class="literal">#</code> as a prefix of <code class="literal">itemId</code>. So let's try the following command on the <strong>Console</strong> to get the <strong>Add</strong> button reference:</p><div><pre class="programlisting">Ext.ComponentQuery.query('actorsgrid toolbar button#add');</pre></div><p>And the output will be only one button as we expect:</p><div><img src="img/0457OT_07_14.jpg" alt="Finding the correct selector"/></div><p>So now we have the<a id="id626" class="indexterm"/> selectors that we were looking for! Using the <strong>Console</strong> is a great tool and can save us a lot of time when trying to find the exact selector that we want instead of coding, testing, not getting the selector we want, coding again, testing again, and so on.</p><div><div><h3 class="title"><a id="note70"/>Note</h3><p>Could we use only <code class="literal">button#add</code> as selector? Yes, we could use a shorter selector. However, it would work perfectly for now. As the application grows and we declare more classes and more buttons, the event would be fired for all buttons that have the <code class="literal">itemId</code> with <code class="literal">add</code> value, and this could lead to an error of the application. We always need to remember that <code class="literal">itemId</code> is scoped locally to its container. Using the <code class="literal">actorsgrid toolbar button</code> or <code class="literal">actorsgrid button</code> as selector, we make sure that the event will come from the button from the <strong>Actors</strong> screen.</p></div></div><p>Now's the time for one last detail. The selector we found is specific to the <strong>Actors</strong> screen. We want some generic code—code that can be used for all screens from the static data module. The good news is that we created a super class (<code class="literal">Packt.view.staticData.BaseGrid</code>) with <code class="literal">xtype staticdatagrid</code>.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec38"/>Using itemId versus id – Ext.Cmp is bad!</h3></div></div></div><p>Whenever we can, we <a id="id627" class="indexterm"/>will always try to use the <code class="literal">itemId</code> configuration instead of <code class="literal">id</code> to uniquely identify a component. And here comes the question: Why?</p><p>When using <code class="literal">id</code>, we need to make sure that <code class="literal">id</code> is unique and none of all the other components of the application can have the same <code class="literal">id</code> property. Now, imagine the situation where you are working with other developers on the same team and it is a big application. How can you make sure that <code class="literal">id</code> is going to be unique? It will be pretty difficult. Don't you think? And this can be a hard task to achieve.</p><p>Components created with <code class="literal">id</code> can be accessed globally using <code class="literal">Ext.getCmp</code>, which is shorthand for <code class="literal">Ext.ComponentManager.get</code>.</p><p>Just to mention one example, when using <code class="literal">Ext.getCmp</code> to retrieve a component by its <code class="literal">id</code>, it is going to return the last component declared with the given <code class="literal">id</code>. And if <code class="literal">id</code> is not unique, it can return the component that you are not expecting, and this can lead to an error in the application, as shown in the following figure:</p><div><img src="img/0457OT_07_20.jpg" alt="Using itemId versus id – Ext.Cmp is bad!"/></div><p>Do not panic! There is an elegant solution: using <code class="literal">itemId</code> instead of <code class="literal">id</code>.</p><p>The <code class="literal">itemId</code> can be used as an alternative way to get a reference of a component. The <code class="literal">itemId</code> is an index to the container's internal <code class="literal">MixedCollection</code>, and that is why <code class="literal">itemId</code> is scoped locally to the container. This is the biggest advantage of <code class="literal">itemId</code>.</p><p>For example, we can have a class named <code class="literal">MyWindow1</code> extending from <code class="literal">Window</code>, and inside this class, we can have a button with <code class="literal">itemId</code> containing the <code class="literal">submit</code> value. Then, we can have another class named <code class="literal">MyWindow2</code>, also extending from <code class="literal">Window</code>, and inside the class, we can also have a button with the <code class="literal">itemId</code> as <code class="literal">submit</code>.</p><p>Having two <code class="literal">itemIds</code> with<a id="id628" class="indexterm"/> the same value is not an issue. We only need to be careful when we use <code class="literal">Ext.ComponentQuery</code> to retrieve the component we want. For example, if we have a <strong>Login</strong> window whose alias is <code class="literal">login</code> and another screen called <strong>Registration</strong> window whose alias is <code class="literal">registration</code> and both windows have a button <strong>Save</strong>, whose <code class="literal">itemId</code> is <code class="literal">save</code>, if we simply use <code class="literal">Ext.ComponentQuery.query('button#save')</code>, the result will be an array with two results. However, if we narrow down the selector even more—let's say we want the <strong>Login Save</strong> button, and not the <strong>Registration Save</strong> button, we need to use <code class="literal">Ext.ComponentQuery.query('login button#save')</code>, and the result will be only one, which is exactly what we expect. The contents of this paragraph are aptly encapsulated in the following image:</p><div><img src="img/0457OT_07_21.jpg" alt="Using itemId versus id – Ext.Cmp is bad!"/></div><p>You will notice that we will not use <code class="literal">Ext.getCmp</code> in the code of our project as it is not a good practice because of the reasons listed previously. Until Ext JS 3, this was the way that we had to use to retrieve components. But from Ext JS 4 onwards, and with the introduction of the MVC architecture and MVVM, this is not needed anymore.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>Adding a new record on the GridPanel</h2></div></div></div><p>Now that<a id="id629" class="indexterm"/> we know how to find the correct selector to use in the Controller, let's go ahead and declare the selector for the <strong>Add</strong> button:</p><div><pre class="programlisting">'staticdatagrid button#add': {
    click: me.onButtonClickAdd
}</pre></div><p>Then, we need<a id="id630" class="indexterm"/> to implement the method <code class="literal">onButtonClickAdd</code>:</p><div><pre class="programlisting">onButtonClickAdd: function (button, e, options) {
    var grid = button.up('staticdatagrid'), //#1
        store = grid.getStore(),            //#2
        modelName = store.getModel().getName(), //#3
        cellEditing = grid.getPlugin('cellplugin');  //#4

    store.insert(0, Ext.create(modelName, { //#5
        last_update: new Date()             //#6
    }));

    cellEditing.startEditByPosition({row: 0, column: 1}); //#7
}</pre></div><p>From the parameters, we only have the <code class="literal">button</code> reference. We need to get the GridPanel reference. So, we are going to use the <code class="literal">up</code> method to get it (<code class="literal">#1</code>). Again, we are going to use the super GridPanel <code class="literal">xtype</code> as selector (<code class="literal">staticdatagrid</code>), because this way we have the most generic code possible.</p><p>All components in Ext JS have methods to query other components. They are listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">up</code>: This<a id="id631" class="indexterm"/> navigates up the ownership hierarchy searching for an ancestor container that matches any passed selector or component</li><li class="listitem" style="list-style-type: disc"><code class="literal">down</code>: This<a id="id632" class="indexterm"/> retrieves the first descendant of this container that matches the passed selector</li><li class="listitem" style="list-style-type: disc"><code class="literal">query</code>: This<a id="id633" class="indexterm"/> retrieves all descendant components that match the passed selector</li></ul></div><p>The method query also has some alternatives, such as <code class="literal">queryBy(function)</code> and <code class="literal">queryById</code>.</p><p>Once we have the GridPanel reference, we can get the Store reference using the <code class="literal">getStore</code> method (<code class="literal">#2</code>).</p><p>We need to have the Model name to instantiate it (<code class="literal">#5</code>) so that we can insert on the first position of the Store (this way it will be the first line of the GridPanel). So, still targeting generic code, we can get the <code class="literal">modelName</code> from the <code class="literal">store</code> (<code class="literal">#3</code>).</p><p>We can pass some configurations to the Model when we instantiate it. We want the <code class="literal">Last Update</code> column to be updated as well; we will only pass it as configuration with the most current <em>Date</em> and <em>Time</em>.</p><p>And at last, we <a id="id634" class="indexterm"/>also want to focus on a cell of the row so that the user can be aware that the cell can be edited, so we will focus on the second column of the grid (the first one is the <code class="literal">id</code>, which is not editable) of the first row (<code class="literal">#7</code>). But to do so, we need a reference to the <code class="literal">celleditor</code> plugin; we can get it by using the <code class="literal">getPlugin</code> method, passing <code class="literal">pluginId</code> as the parameter (<code class="literal">#4</code>).</p><p>Just to remember, we declared the <code class="literal">pluginId</code> for the <code class="literal">cellediting</code> plugin of the <code class="literal">Packt.view.staticData.BaseGrid</code> class, as shown in the following code snippet:</p><div><pre class="programlisting">{
    ptype: 'cellediting',
    clicksToEdit: 1,
<strong>    pluginId: 'cellplugin'</strong>
}</pre></div><div><div><h3 class="title"><a id="note71"/>Note</h3><p>Note that with only one method, we can program the necessary logic. The code is generic and provides the same capability to all static data grid panels.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>Editing an existing record</h2></div></div></div><p>The <a id="id635" class="indexterm"/>editing of a cell will be done automatically by the <code class="literal">cellediting</code> plugin. However, when the user clicks on a cell to edit and finishes the editing, we need to update the <strong>Last Update</strong> value to the current <em>Date</em> and <em>Time</em>.</p><p>The <code class="literal">cellediting</code> plugin has an event named <code class="literal">edit</code> that allows us to listen to the event we want. Unfortunately, the Controller is not able to listen to plugin events. Lucky for us, the GridPanel class also fires this event (the <code class="literal">cellediting</code> plugin forwards the event to the <code class="literal">GridPanel</code> internally), so we can listen to it. So we are going to add the following code to the Controller <code class="literal">init</code> control:</p><div><pre class="programlisting">"staticdatagrid": {
<strong>edit: me.onEdit</strong>
}</pre></div><p>Next, we need to implement the <code class="literal">onEdit</code> method, as follows:</p><div><pre class="programlisting">onEdit: function(editor, context, options) {
    context.record.set('last_update', new Date());
}</pre></div><p>The second parameter is the event (<code class="literal">context</code>). From this parameter, we can get the <strong>Model</strong> instance (<code class="literal">record</code>) that <a id="id636" class="indexterm"/>the user edited and then set the <code class="literal">last_update</code> field to the current <em>Date</em> and <em>Time</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>Deleting the handling Widget Column in the Controller</h2></div></div></div><p>Well, the read, create, and<a id="id637" class="indexterm"/> update actions have already been implemented. Now, we need to implement the delete action. We do not have a button for the delete action, but we do have an <code class="literal">item</code> of an Action Column.</p><p>In the topic <em>Handling the Widget Column in the MVC architecture</em>, you learned how to fire the event from the item of the Action Column so that we could handle it on the Controller. We cannot listen to the event fired by the Action Column itself; however, we can listen to the event fired by the Action Column that we created:</p><div><pre class="programlisting">"staticdatagrid actioncolumn": {
    itemclick: this.handleActionColumn
}</pre></div><p>Now, let's see how you can implement the <code class="literal">handleActionColumn</code> method:</p><div><pre class="programlisting">handleActionColumn: function(column, action, view, rowIndex, colIndex, item, e) {
        var store = view.up('staticdatagrid').getStore(),
        rec = store.getAt(rowIndex);

        if (action == 'delete'){
            store.remove(rec);
            Ext.Msg.alert('Delete', 'Save the changes to persist the removed record.');
        }   
    }</pre></div><p>As this is a custom event, we need to get the parameters that were passed by the item of the Action Column.</p><p>So first, we need to get the Store and also the <code class="literal">record</code> that the user clicked to delete. Then, using the second parameter, which is the name of the <code class="literal">action</code> of the Action Column item, we have a way to know which item fired the event. So if the <code class="literal">action</code> value is <code class="literal">delete</code>, we are going to remove the <code class="literal">record</code> from the Store and ask the user to commit the changes by pressing the button <strong>Save Changes</strong>, which is going to synchronize the models from the Store with the information we have on the server.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec77"/>Saving the changes</h2></div></div></div><p>After the<a id="id638" class="indexterm"/> user performs an update, delete, or create action, the cells that were updated will have a mark (the dirty mark so that the Store knows what models were modified) as shown in the following screenshot:</p><div><img src="img/0457OT_07_15.jpg" alt="Saving the changes"/></div><p>In the same way that we can perform changes on the MySQL table, we need to save the changes (commit). That is why we created the <strong>Save Changes</strong> button; this way, we will synchronize all the changes at once to the server.</p><p>So first, we need to add a listener to <code class="literal">me.control</code>, as follows:</p><div><pre class="programlisting">'staticdatagrid button#save': {
    click: me.onButtonClickSave
}</pre></div><p>Then, we need to implement the <code class="literal">onButtonClickSave</code> method:</p><div><pre class="programlisting">onButtonClickSave: function (button, e, options) {
    var grid = button.up('staticdatagrid'), //#1
        store = grid.getStore(),            //#2
        errors = grid.validate();           //#3

    if (errors === undefined){  //#4
        store.sync();           //#5
    } else {
        Ext.Msg.alert(errors);  //#6
    }
}</pre></div><p>The implementation <a id="id639" class="indexterm"/>of the method is pretty straightforward: we simply need to get the Store (<code class="literal">#2</code>) from the GridPanel (<code class="literal">#1</code>) and call the method <code class="literal">sync</code> (<code class="literal">#5</code>).</p><p>However, we are going to validate that the information entered in the cells of the Grid contain valid information. To do so, we are going to call the method <code class="literal">validate</code> from the grid (<code class="literal">#3</code>) and get the <code class="literal">errors</code>. If no errors were found (<code class="literal">#4</code>), then we <code class="literal">sync</code> the Store with the server (<code class="literal">#5</code>); otherwise, we display the <code class="literal">errors</code> (<code class="literal">#6</code>).</p><p>The Grid Panel does not have a validate method by default. We are going to add this method to the <code class="literal">Base</code> Grid Panel.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec39"/>Validating cellediting in GridPanel</h3></div></div></div><p>Going back to <a id="id640" class="indexterm"/>the class <code class="literal">Packt.view.staticData.BaseGrid</code>, we are going to add the logic to validate a row from the grid and also the entire grid before saving. In this example, you will learn that we can also add useful methods to the classes we create; we do not need to develop all the code inside the Controller.</p><p>The first method we are going to implement is <code class="literal">validateRow</code>. Given a record, we are going to validate it using Model validators, and if there are any errors, we will add the same form icon that Ext JS displays in the forms in case of validation errors in the cell that contains the error, and we will also add a tooltip in this cell (similar behavior from the form validation). The code for the method is as follows (we need to add it inside the <code class="literal">initComponent</code> method):</p><div><pre class="programlisting">me.validateRow = function(record, rowIndex){

    var me = this,
        view = me.getView(),
        errors = record.validate(); //#1

    if (errors.isValid()) {         //#2
        return true;
    }

    var columnIndexes = me.getColumnIndexes(); //#3

    Ext.each(columnIndexes, function (columnIndex, col) { //#4
        var cellErrors, cell, messages;

        cellErrors = errors.getByField(columnIndex);      //#5
        if (!Ext.isEmpty(cellErrors)) {
            cell = view.getCellByPosition({
            row: rowIndex, column: col
   });
            messages = [];
            Ext.each(cellErrors, function (cellError) { //#6
                messages.push(cellError.message);
            });

            cell.addCls('x-form-error-msg x-form-invalid-icon x-form-invalid-icon-default'); //#7
            
            cell.set({ //#8
                'data-errorqtip': Ext.String.format('&lt;ul&gt;&lt;li class="last"&gt;{0}&lt;/li&gt;&lt;/ul&gt;',
                    messages.join('&lt;br/&gt;'))
            });
        }
    });

    return false;
};</pre></div><p>Given a<a id="id641" class="indexterm"/> <code class="literal">record</code> Model (<code class="literal">#1</code>), we are going to use its method <code class="literal">validate</code>. This method verifies that the information contained in the Model is valid according to the Model validators (we need to go back to the models we defined for this chapter and add the validators). This method returns an object with all the errors found in the record.</p><p>Using the <code class="literal">isValid</code> method (<code class="literal">#2</code>), we can easily find out whether the Model is valid or not. If it is valid, we return <code class="literal">true</code> (we will use this information later).</p><p>The <code class="literal">columnIndexes</code> (<code class="literal">#3</code>) is in an array that contains <code class="literal">dataIndex</code> of each column of the grid. This method was present in the grid panel class back in Ext JS 4.1, but in Ext JS 4.2, it was removed, and it is not present in Ext JS 5. We are going to implement this method as well, but with the difference being that in this case, we are only interested in the columns that have the editor enabled (since we want to validate it).</p><p>Then, for each <code class="literal">column</code> of the grid that has the editor enabled (<code class="literal">#4</code>), we are going to retrieve the <code class="literal">errors</code> specific for that column from the Model (<code class="literal">#5</code>). We are going to add each error <code class="literal">message</code> (<code class="literal">#6</code>) to an array of messages. After that, we are going to add the same error icon from an invalid form field to the grid cell (<code class="literal">#7</code>). And, at last, we are also going to add a tooltip to the cell with error (<code class="literal">#8</code>).</p><p>Next, we are going to implement the <code class="literal">getColumnIndexes</code> function, as follows:</p><div><pre class="programlisting">me.getColumnIndexes = function() {
    var me = this,
        columnIndexes = [];

    Ext.Array.each(me.columns, function (column) { //#9
        if (Ext.isDefined(column.getEditor())) {   //#10
            columnIndexes.push(column.dataIndex);  //#11
        } else {
            columnIndexes.push(undefined);
        }
    });

    return columnIndexes; //#12
};</pre></div><p>For each <a id="id642" class="indexterm"/>column of the grid (<code class="literal">#9</code>), we are going to verify that the editor is enabled (<code class="literal">#10</code>), and if yes, we are going to add <code class="literal">dataIndex</code> to the <code class="literal">columnIndexes</code> array (<code class="literal">#11</code>). In the end, we return this array (<code class="literal">#12</code>).</p><p>The <code class="literal">validateRow</code> method will only work for a single row. When we click on the <strong>Save Changes</strong> button, we want to validate the entire grid. To do so, we are going to implement one more method inside the <code class="literal">initComponent</code>, which is called <code class="literal">validate</code> (the method we called in the Controller):</p><div><pre class="programlisting">me.validate = function(){

    var me = this,
        isValid = true,
        view = me.getView(),
        error,
        record;

    Ext.each(view.getNodes(), function (row, col) { //#13
        record = view.getRecord(row);

        isValid = (me.validateRow(record, col) &amp;&amp; isValid); //#14
    });

    error = isValid ? undefined : { //#15
        title: "Invalid Records",
        message: "Please fix errors before saving."
    };

    return error; //#16
};</pre></div><p>For the <code class="literal">validate</code> method, we<a id="id643" class="indexterm"/> are going to retrieve all the rows from the grid, and for each one (<code class="literal">#13</code>), we are going to call the <code class="literal">validateRow</code> method (<code class="literal">#14</code>). In line <code class="literal">#14</code>, we are also keeping track of whether any previous row <code class="literal">is valid</code> or not.</p><p>In the end, we return (<code class="literal">#16</code>) <code class="literal">undefined</code> if no error was found or we return an object with a title and message (<code class="literal">#15</code>) that we can use in the Controller to display an alert.</p><p>If we add an empty row or edit a cell with invalid information, the grid will display an error icon on the cell and also a tooltip when we mouse over it. The output will be similar to the following screenshot:</p><div><img src="img/0457OT_07_16.jpg" alt="Validating cellediting in GridPanel"/></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec18"/>Model validators</h4></div></div></div><p>To make this<a id="id644" class="indexterm"/> code work, we need to add the Model validators to <code class="literal">staticData</code> model. For example, for the <code class="literal">Actors</code> model, we can add the following code based on the database validations for the <code class="literal">actor</code> table:</p><div><pre class="programlisting">validators: {
        first_name: [
            { type: 'presence', message: 'This field is mandatory'},
            { type: 'length', min: 2, max: 45}
        ],
        last_name: [
            { type: 'presence', message: 'This field is mandatory'},
            { type: 'length', min: 2, max: 45}
        ]
    }</pre></div><p>And in the <code class="literal">Packt.model.staticData.Base</code> class, we can add the <code class="literal">last_update</code> validator that is going to be common to all <code class="literal">staticData</code> models:</p><div><pre class="programlisting">validators: {
    last_update: 'presence'
}</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec40"/>The autoSync configuration</h3></div></div></div><p>The Store <a id="id645" class="indexterm"/>has a configuration named <code class="literal">autoSync</code>. The default value is <code class="literal">false</code>, but if we set it to <code class="literal">true</code>, the Store will automatically synchronize with the server whenever a change is detected. This can be good, but it also can be bad—it depends on how we are going to use it.</p><p>For example, if we did not have the validations, the user could create an empty row and try to send it to the server. The server code would fail (some columns cannot be <code class="literal">null</code>), and this would be bad for the application. With <code class="literal">autoSync</code> set to <code class="literal">false</code>, the user can also choose when to save the information and the information can be sent in bulk instead of sending one request per action (create, update, or destroy)—<code class="literal">allowSingle</code> has to be set to <code class="literal">false</code> in the proxy writer as well.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec78"/>Canceling the changes</h2></div></div></div><p>As the <a id="id646" class="indexterm"/>user can save the changes (commit), the user can also cancel them (rollback). All you have to do is to reload the Store so that you get the most updated information from the server, and the changes made by the user will be lost.</p><p>So we need to listen to the event, as follows:</p><div><pre class="programlisting">staticdatagrid button#cancel"' {
    click: this.onButtonClickCancel
}</pre></div><p>And we need<a id="id647" class="indexterm"/> to implement the method:</p><div><pre class="programlisting">onButtonClickCancel: function (button, e, options) {
button.up('staticdatagrid').getStore().reload();
}</pre></div><p>If you want, you can add a message asking whether the user really wants to roll back the changes. Calling the <code class="literal">reload</code> method from the Store is what we need to do to make it work.</p><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>As an alternative to the <code class="literal">reload</code> method of the Store, we could also call the method <code class="literal">rejectChanges</code> instead; however, the <code class="literal">reload</code> method is more failsafe, since we are getting the information from the server again.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec79"/>Clearing the filter</h2></div></div></div><p>When<a id="id648" class="indexterm"/> using the <code class="literal">filter</code> plugin on the GridPanel, it will do everything that we need (when used locally). But there is one thing that it doesn't provide to the user: the option to clear all the filters at once. So that is why we implemented a <strong>Clear Filters</strong> button.</p><p>So first, let's listen to the event:</p><div><pre class="programlisting">'staticdatagrid button#clearFilter {
    click: this.onButtonClickClearFilter
}</pre></div><p>And then we can implement the method:</p><div><pre class="programlisting">onButtonClickClearFilter: function (button, e, options) {
button.up('staticdatagrid').filters.clearFilters();
}</pre></div><p>When using the <code class="literal">filter</code> plugin, we are able to get a property named <code class="literal">filters</code> from the GridPanel. Then, all we need to do it is to call the <code class="literal">clearFilters</code> method. This will clear the filter values from each column that was filtered and will also clear the filters from the Store.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec80"/>Listening to Store events in the Controller</h2></div></div></div><p>And the <a id="id649" class="indexterm"/>last event we will be listening to is the <code class="literal">write</code> event from the Store. We already added an <code class="literal">exception</code> listener to the Proxy (in Ext JS 3, the Store had an exception listener, while in Ext JS 4 and 5 this listener was moved to the Proxy). Now we need to add a listener in case of success.</p><p>The first step is to listen to the event from the Store in the Controller. This feature was introduced in Ext JS 4.2.x.</p><p>Inside the <code class="literal">init</code> function of the Controller, we will add the following code:</p><div><pre class="programlisting">me.listen({
    store: {
        '#staticData.Actors': {
            write: this.onStoreSync
        }
    }
});</pre></div><p>We can listen to <a id="id650" class="indexterm"/>Store events inside the store option. The previous code will work for the <strong>Actors</strong> screen. If we want to do the same for the other screen, we need to add the same code as the preceding one. For example, the following code needs to be added for the <strong>Categories</strong> screen:</p><div><pre class="programlisting">'#staticData.Categories': {
    write: this.onStoreSync
}</pre></div><p>We cannot use the Base Store <code class="literal">storeId</code> here because each child Store will have its own <code class="literal">storeId</code>.</p><p>The write event is fired whenever the Store receives the response from the server. So let's implement the method:</p><div><pre class="programlisting">onStoreSync: function(store, operation, options){
Packt.util.Util.showToast('Success! Your changes have been saved.');
}</pre></div><p>We will simply display a message saying the changes have been saved. Notice that the message is also generic; this way we can use it for all the static data modules. A screenshot of the output is as follows:</p><div><img src="img/0457OT_07_17.jpg" alt="Listening to Store events in the Controller"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Debug tip – Sencha extension for Chrome</h1></div></div></div><p>Sometimes we need<a id="id651" class="indexterm"/> to inspect a particular Ext JS component we have instantiated for debugging purposes. Finding <a id="id652" class="indexterm"/>which methods are available and the current attributes and configurations that are set in the object can be a little tricky. When working in MVC, we might need to find the Store ID created and the stores that are alive in the application. Using <code class="literal">console.log</code> to output a particular object to inspect it is a lot of work!</p><p>The Sencha Labs team released a free extension for Chrome called<a id="id653" class="indexterm"/> <strong>Sencha App Inspector</strong>. When working with Ext JS (or Sencha Touch), it is recommended that you use this extension to help debug the application. In the following screenshot, we can see the extension in action—stores that have been instantiated by the application and the data that has been loaded into it:</p><div><img src="img/0457OT_07_18.jpg" alt="Debug tip – Sencha extension for Chrome"/></div><div><div><h3 class="title"><a id="note72"/>Note</h3><p>For more information about<a id="id654" class="indexterm"/> Sencha App Inspector and the download link please visit <a class="ulink" href="https://github.com/senchalabs/AppInspector/">https://github.com/senchalabs/AppInspector/</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Firefox extension – Illuminations for Developers</h2></div></div></div><p>If your<a id="id655" class="indexterm"/> favorite<a id="id656" class="indexterm"/> browser for development is not Chrome, there is also a Sencha extension for Firefox (which can be used within Firebug) called Illuminations for Developers.</p><p>It is not a free extension (but it is possible to try it for free for a limited period of time), and its cost has a good cost-benefit.</p><p>In the following screenshot, we can see the extension in action (stores that have been instantiated by the application and its properties):</p><div><img src="img/0457OT_07_19.jpg" alt="Firefox extension – Illuminations for Developers"/></div><div><div><h3 class="title"><a id="note73"/>Note</h3><p>For more information about Illuminations for Developers<a id="id657" class="indexterm"/> and the download link, please visit <a class="ulink" href="http://www.illuminations-for-developers.com/">http://www.illuminations-for-developers.com/</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we covered how to implement screens that look very similar to the MySQL Table Editor. The most important concept we covered in this chapter is implementing abstract classes, using the inheritance concept from OOP. We are used to using these concepts on server-side languages, such as PHP, Java, .NET, and so on. This chapter demonstrated that it is also important to use these concepts on the Ext JS side; this way, we can reuse a lot of code and also implement generic code that provides the same capability for more than one screen.</p><p>We created a Base Model, Store, View and a Controller. We used the following plugins: <code class="literal">celleditor</code> for the GridPanel and Live Search grid and <code class="literal">filter</code> plugin for the GridPanel as well. You learned how to perform CRUD operations using the Store capabilities. You also learned how to create custom events and handle Widget Column events on the Controller. We also explored many of the MVC Controller capabilities in this chapter.</p><div><div><h3 class="title"><a id="note74"/>Note</h3><p>Reminder: you can get the complete source code for this chapter (with extra capabilities and server-side code) by downloading the code bundle from this book or from the GitHub repository <a class="ulink" href="https://github.com/loiane/masteringextjs">https://github.com/loiane/masteringextjs</a>.</p></div></div><p>In the next chapter, you will learn how to implement the Content Management module, which goes further than just managing one single table as we did on this chapter. We will manage information from other tables (related to the business of the application) and all its relations within the database.</p></div></body></html>