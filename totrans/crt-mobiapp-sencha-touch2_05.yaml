- en: 'Chapter 5. On Deck: Using Sencha.io'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous chapters we have typically used local storage for maintaining
    our data. This offers a number of advantages with its ease of use and simplicity.
    The store and the model do all of the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a number of disadvantages to local storage as well. First
    and foremost, it is very much local to the device. This means that if your user
    has more than one device (a phone, desktop, and a tablet computer), then they
    will have a separate set of data for each device.
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing to the user and it negates the advantage of having a single
    application that is accessible from multiple devices. Additionally, the data can
    be deleted by the user when they clear the local browser data. This can make local
    storage a bit problematic for a robust application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to look at solving this issue with an external
    API called Sench.io. Here''s what we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the basic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Sencha.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the basic application to work with Sencha.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our basic application is designed to present a set of flash cards to the user
    in a random order. Each set of flash cards comprises a deck. The user can add
    new decks and new cards to each deck. The decks and the cards will reside in a
    remote storage service called **Sencha.io**. Using this service, the user will
    also be able to log in from any number of devices and access their cards and decks.
  prefs: []
  type: TYPE_NORMAL
- en: '![The basic application](img/8901OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will start off our application with the models and stores.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the models and stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model for our deck is very simple and only needs two pieces of information.
    We will use an ID to link cards to a specific deck and a name for display purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The card model needs an ID of its own so that we can uniquely identify it and
    a `deckID` value so that we know which deck it''s a part of. We will also need
    the question and answer for each card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the two stores, we will initially use a local storage `proxy` as we have
    in previous chapters. This will let us test our application before we start using
    the Sencha.io service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our deck store looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you have worked your way through the first chapter, this basic setup should
    look pretty familiar to you. We extend the basic store, require our `model` file,
    and then set up our configuration. The configuration sets the store to load when
    it is created, tells it which model to use, sets up our local storage `proxy`,
    and tells it which `fields` to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our card store is almost an exact duplicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we have just changed the name from `Deck` to `Card`, and specified our
    card fields in place of our deck fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you configure your store with a model, you don't actually have to specify
    the fields. We are doing so here just for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, we will be revisiting these stores once we get things set
    up with `Sencha.io`, but first we need to get our display together for our lists,
    cards, and editing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our main view, we will be using a tab panel with two containers, one for
    our decks and one for our cards. We will use sheets for editing and adding new
    decks and cards. Our initial `main.js` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to add this file into your `app.js` file and set the launch function
    to create a copy of the component when the application starts (if you are using
    Sencha Architect, then this should happen automatically). Your `app.js` file should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add the two containers to our `main.js` view. In the empty
    items section, add the following container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will be the list for our decks. The overall container has a `fit` layout
    so the items will fill the entire width and height of the container. We have given
    the container a title and an `iconCls` value, which will be used to label the
    tab in our `Main` tab panel.
  prefs: []
  type: TYPE_NORMAL
- en: The container has a `list` view that uses our `DeckStore` store and a simple
    `itemTpl` template that displays the name of each deck in a separate `div` tag.
  prefs: []
  type: TYPE_NORMAL
- en: We have also added a title bar where we can display a button for adding new
    decks and a title to let the user know what they are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second container follows the same pattern as our first, but instead of
    a list, we have a separate container with a `carousel` layout, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This container has a `titlebar` control that will be set to display the name
    of the current deck at the top and pull the cards into our `carousel` layout.
    We also have a second button that will shuffle the current deck of cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to set up the two sheets for adding cards and decks. The deck
    sheet is a simple sheet with a `textfield` element for naming the deck, a `button`
    element for saving, and another `button` element for canceling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We also add a listener for the `Cancel` button that will hide the sheet without
    saving the values. The listener delegates the `tap` event to our `cancelDeckButton`
    delegate and calls the `hideDeckSheet` function when the `tap` event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `hideDeckSheet` function receives the `button` element as part of its arguments.
    We can then travel up the DOM structure from the button, find the sheet, and hide
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A note about using up and down**'
  prefs: []
  type: TYPE_NORMAL
- en: The `up` and `down` functions in Sencha Touch are extremely useful when you
    have a component and you need to get to either a sub component or a parent component.
    However, it should be noted that both `up` and `down` only return the first component
    that matches. For example, if a `button` element is inside of a `container` element,
    which is itself inside another `container` element, then `button.up('container')`
    would return the first container and not the second, outer container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our card sheet is a duplicate of the deck sheet, but with text fields for `question`
    and `answer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As before, we have our **Save** and **Cancel** buttons, with the **Cancel**
    button hiding the sheet when tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to start the application and test the different views
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the views](img/8901OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we can get things working further in the application, we need to get
    set up with Sencha.io.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Sencha.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sencha.io service will allow us to store our data using Sencha's cloud service.
    We will need to register a new account, add our application and user groups using
    the Sencha.io dashboard, and then configure our application to use the service.
  prefs: []
  type: TYPE_NORMAL
- en: The sign-up process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register a new account, go to [https://manage.sencha.io](https://manage.sencha.io)
    and click on the **Register** link at the bottom of the page. Fill out the forms
    with your information and submit. Once your account is created, log in to the
    Sencha.io dashboard at the same address you used for registration, and you will
    see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sign-up process](img/8901OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Downloading and installing the Sencha.io SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have an account you can download and install the Sencha.io SDK.
    There is a download link in the first part of the **Getting Started** page (which
    should be where you first start when you log in).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the SDK to your computer and unzip the file. Move it into your web
    directory (someplace where you can easily reference it from your application).
    Next we need to add these files to our application. You can begin by opening your
    main `app.html` file and adding the following lines in the `head` section of the
    file (with your other script includes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we have copied all of the Sencha.io files into a folder called
    `io` in the `lib` directory of our application. If your path is different, you
    will need to adjust the lines above to fit your setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have included the two main files we need for Sencha.io, we also
    need to set some options in `app.js` so that the autoloader picks up these files
    as well. At the top of the `app.js` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once we have this information set, our application should be able to pick up
    all the files it needs to work with Sencha.io, but we still need to register our
    application before we can continue building.
  prefs: []
  type: TYPE_NORMAL
- en: Registering your application and Auth group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Registering your application and Auth group with Sencha.io provisions the application
    with its own data storage and an authorized user base. As with most API services,
    your application needs a way to uniquely identify itself to the remote system
    so that it will know where to store your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Sencha.io, we will get two pieces of information when we register our
    application: an `appID` value and an `appSecret` value. These two pieces of information
    will be added to `app.js` to identify our application to the Sencha.io system.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding an Auth group. The Auth group sets up a group where users
    can register to use your application. If you have multiple applications, you can
    set up one Auth group for each application or set up a single Auth group to be
    shared across multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Dashboard** section of your Sencha.io account ([http://manage.sencha.io](http://manage.sencha.io)),
    click on the **Auth Groups** link at the top of the page and choose **Create Auth
    Group**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter a name for your Auth group and click on **Save**. The name is arbitrary,
    but if you are using the group for a single application, it's probably best to
    name it something like `myAppNameUsers` so that you can keep track of which application
    this is for.
  prefs: []
  type: TYPE_NORMAL
- en: The Auth group also controls how the users authenticate in your application.
    Once you have saved the Auth group, you can edit it and change the way users log
    in to your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can choose to have users authenticate before the application fully downloads
    or afterwards. You can also choose to let users log in with a valid Facebook,
    Twitter, or Sencha.io account.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the **Sencha.io** login option, then the SDK will automatically
    handle both user registration and authentication within your application, no extra
    coding required.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the **Facebook** or **Twitter** login option, Sencha.io will handle
    the authentication automatically. Users will have to be registered with either
    service before they can access the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a set of users for the application, we need to register the
    application itself. From the Sencha.io dashboard, click on **Apps** and then click
    on **Create App**. As before, we only need to enter a name for the application.
    For this application we chose the name **OnDeck** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we need to select our **Authentication Group** name from the drop-down
    menu. This tells Sencha.io to authenticate and assign users from this group to
    our application. There is an optional **CNAME** field for setting the domain your
    application will reside on, as well as a field for the path to the `index.html`
    file. This should be set if you are using the `app.html` file instead of `index.html`,
    or if you have your application hosted inside a sub directory on your server.
  prefs: []
  type: TYPE_NORMAL
- en: We can also set an application icon here. This is the icon that will be used
    if the user saves our web application to their home screen. Click on **Save**
    when you are finished.
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the page application page, you should now see a listing for your application's
    ID (mentioned in the **ID** field) and secret (mentioned in the **Secret** field).
    Make note of these, as we will need to add them into `app.js` once we are finished
    with registration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the **ID** and **Secret** values in the preceding example screenshot
    are example data only. You will need to generate your own information on the Sencha.io
    site to make your application work. You will also need to generate your own ID
    and secret to make the example code from the chapter work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed this part of the registration, you will need to add
    the ID and secret values into your `app.js` file. Open the file and add the following
    code at the top of the `Ext.application({` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Substitute your information for the `appId` and `appSecret` placeholders shown.
    Once you have added the information into `app.js`, we can get back to updating
    our stores and creating our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application for Sencha.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our application is registered, we need to set up the stores to use
    Sencha.io. We will also set up our controller for the application and show you
    how to override the `Carousel` component to make it work with a data store.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our original stores were simple local storage for testing. We are going to
    edit these now to use Sencha.io to store our data. Most of these changes will
    be in the `proxy` section. For example, the `DeckStore` code should be updated
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we now use a new type of proxy called `syncstorage`. This is the
    special Sencha.io proxy that works much the same as a local store, but it stores
    the data remotely on the Sencha.io servers.
  prefs: []
  type: TYPE_NORMAL
- en: We also have new configurations for `owner` and `access`. The `owner` and `access`
    field must both be set for `syncstorage` to work correctly. As of this writing,
    the only `owner` option is `user`. This is the currently authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: The `access` configuration determines if the store is **private**, available
    only to the currently authenticated user, or **public**, available to all members
    of the group of users. This is the user group we set up in the Sencha.io dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we added a configuration of `autoLoad: true`. This will load any local
    data if the connection is lost while the user is still logged in. We then set
    `autosync: false` to prevent the store from automatically syncing when the application
    starts. We should to wait until the user logs into the application before we load
    the store. We will do this manually as part of the application controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make the exact same changes to the `CardStore.js` file to get it working
    with Sencha.io, but it requires one additional setting for `remoteFilter: false`.
    We will be loading all of the user''s cards when they log in, and filtering them
    by deck once a deck is selected.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `remoteFilter` configuration is part of the store, not the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our stores configured we can move on to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our controller has a few things it needs to handle for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for Sencha.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling anything that needs to happen at login and logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cards and decks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a deck for display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing between the local application and Sencha.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start by setting up our basic controller with the models, views, stores,
    and references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first section defines our controller and then lists the `models`, `stores`,
    and `views` values we previously created. We also add an empty configuration for
    `selectedDeck`. We will be using this as a placeholder for storing the record
    of the currently selected deck. This will allow us to easily get and set the value
    anywhere in our controller functions using `getSelectedDeck` and `setSelectedDeck`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Getters and setters**'
  prefs: []
  type: TYPE_NORMAL
- en: Sencha Touch automatically creates `get` and `set` functions for configuration
    settings as well as references (see the following section). These functions take
    the form of `getWhateverYouCalledIt` and `setWhateverYouCalledIt`. It is important
    to remember that even if you lowercase the first letter of the `config` option
    or reference, the `get` and `set` functions will uppercase the first letter.
  prefs: []
  type: TYPE_NORMAL
- en: The `refs` section allows us to create a reference to a component either by
    `id` (such as `#addCardSheet`) or a component query, such as (`#addCardSheet button[text="Save"]`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding component query will look for a component with an `id` value of
    `addCardSheet` and then find the button within the component that has a `text`
    configuration of `"Save"`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now reference anything in our `refs` list with `this.getReferenceName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the `refs` section we need to add a `control` section. This
    section uses our references and defines a set of listeners and functions for some
    of our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each member of our `control` section has a reference, an event to listen for
    and a function to fire when the event occurs. We will create each of these functions
    later in the controller, but first we need to add our `init` function to set up
    Sencha.io and the other functions for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'When our application first starts, it needs to listen to the Sencha.io controller
    for authentication and messaging. We handle this in our `init` function (this
    goes right after the `config` section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code tells our controller three events from the Sencha.io controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authorized`: The user has successfully logged in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: The user has logged out of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usermessage`: The user has received a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have assigned a function to each one of these events and now we need to add
    them below our `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is our `onAuth` function, which syncs all of the user''s stores once
    they have logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `onLogout` function does the reverse and clears out any locally stored
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our message function is a bit more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Sencha.io allows an application to send messages to the user. These can be system
    messages (for example, the data in a store has updated) or even direct messages
    between users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have set up the following function to simply sync our stores when a message
    has been received (we will set up the function to send the message a bit later).
    This means if the user has the program open on one device and makes a change to
    the data, any other device that user has logged in will update and receive the
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have also added a number of console logs, which you can use to take a look
    at the messages being sent and the data that is potentially available to your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to pull up your console when testing the application and examine the
    different message elements available to you. We will delve deeper into messaging
    in the final chapter, but you can also check out the *Overview Guide* available
    at [http://docs.sencha.io](http://docs.sencha.io) for more information about messaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to add the functions that will save our new cards and decks. Both
    functions are tied to their respective save buttons. They need to grab the data
    from the sheet, add it to the store, and then sync the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use our references here to grab the `addCardSheet` value using `this.getAddCardSheet()`
    and then we add the data as a new record to our card store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then sync the store and *bind* a function called `syncCallback`. This is
    the function that will send out our message telling the application that data
    has been updated. The `syncCallback` function can go right below our `addCards`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The console logs have been left in to provide an inside view of the data being
    passed inside the function. The first part of the code, `this.getApplication().sio.getUser`,
    grabs the currently authenticated user and runs a function. The function checks
    to see if we got back a user and, if so, we send the user a message that simply
    says, `updated`.
  prefs: []
  type: TYPE_NORMAL
- en: This message gets processed by our `onUserMessage` function, which causes our
    stores to update their data. You can change this message and use the console logs
    to see how the data is passed between the two functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `addDeck` function is a virtual duplicate of our `addCard` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we only need to get one `textfield` value before we sync the store and
    do our `syncCallback` function. As before, we also clear the field values before
    hiding the sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will need to leave our controller for a bit and take a look at how our
    cards will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the Carousel component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a flash card application, `Carousel` seems like an ideal component to use
    because it allows the user to quickly flip from one card to the next. This would
    allow us to present a question and have the user swipe to get to the answer. The
    user can then swipe again to get to the next question and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is that `Carousel` is actually a collection of panels and what
    we really need is something that will pull records from our data store the way
    a list view does. In order to do this we need to override the `Carousel` component
    and add some additional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with our basic component that extends `Carousel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out setting our `store` configuration to `null` by default. We will
    set this when we declare the component in the `Main.js` file. In our `Main.js`
    file, locate the section that says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace that line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This sets the container to our new `flashcards` carousel and sets the `store`
    configuration to `CardStore`.
  prefs: []
  type: TYPE_NORMAL
- en: If we had hardcoded the store for the component in our `CardView.js` file, it
    would be more difficult to re-use. When you override a component to extend functionality,
    it is always a good idea to write it with an eye towards re-using it somewhere
    else, later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `CardView.js`, we need to add a pair of strings to use as xTemplates
    for our question and answer cards. These go in the `config` section of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These will control how to display the question and answer cards. Since we will
    be using these same templates multiple times, it''s a good idea to compile them
    in our `constructor` function. Otherwise, the xTemplate will be compiled and recompiled
    each time a new flashcard is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `constructor` function also sets up the store we passed in `Main.js`. This
    one is a bit complex and requires a bit of explaining. Let''s start from the inside
    and work our way out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.getStore()`: This grabs the string value we passed in `Main.js` (`store:
    ''CardStore''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ext.getStore()`: This grabs the store with a `storeId` value of `''CardStore''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.setStore()`: This applies the store to our `CardView` component, replacing
    the original string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we call `this.getStore()` on the next line to set `listeners`, it now returns
    an actual store instead of the string value from before.
  prefs: []
  type: TYPE_NORMAL
- en: Then we assign a single function to the store events for `load`, `refresh`,
    and `addrecords`. We need to add that function next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have broken this function into two parts. The first part is the `createCards`
    function, which gets our store and removes any existing panels from our custom
    carousel. It then checks to see if we have any cards in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If not, we give the user a message that there are no cards in the deck and they
    can click on **Add** to create new cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the second part of our function comes into play. If we have records,
    we pass each one along to a second function called `createFlashCard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function is run on each record in `CardStore`. The first line creates our
    initial data array and sets values for the `total` (the number of cards in the
    deck), `number` (the sequential number of the current card), and `data` records
    from the store (which contains both our question and answer for the card).
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `panel` component and set `html` to our compiled question
    template with the applied data.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same thing for our answer template, so we end up with two new panels
    for each record in the store; a question panel, followed by an answer panel.
  prefs: []
  type: TYPE_NORMAL
- en: Since `CardStore` contains all of the records for every deck, we need to filter
    these down by deck before our `CardsView` carousel loads. We'll handle that back
    in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the user selects a deck from our list, we need to filter `CardStore` so
    that only the cards for that deck are available. We do this in our `onDeckSelected`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function is triggered by the select event in our `deckList` component and
    passes us the list and the record that was selected. Once we grab `CardStore`,
    we set the `selectedDeck` function to the record that was passed to us when the
    deck in the list was selected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we clear any existing filters on `CardStore` and sort it by its `id` value.
    We then filter the cards to only display the ones for the current deck. Finally,
    we enable `cardsPanel` and set it to be the active item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `control` function that fires when `cardPanel` is shown. This
    function sets the title bar of the card panel to the name of the deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our initial load of the card store presents them in order by `id`, it
    might be a good idea to let the user shuffle the cards. We do this with our final
    controller function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function grabs `CardStore` and sorts it using JavaScript's `Math.random`
    function to assign a random sort order to each card.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more complete understanding of how sorting works in JavaScript (and Sencha
    Touch), consult the excellent Mozilla Developer Network's JavaScript Reference
    for sorting at [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to add decks and cards to the application. When you
    select a deck, the card stack will appear. You can advance from one card to the
    next by swiping from right to left as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back in the controller](img/8901OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use the CSS files to style the answer and question to fit your own personal
    tastes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you will need to register with the application before you can start
    creating decks and cards. Once you are registered, you can log in from any Sencha
    Touch Compatible browser and access the same information across multiple devices.
    Fortunately, since we are using Sencha.io, all of this is taken care of automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '![Back in the controller](img/8901OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sencha.io automatically creates these login and registration forms for our application.
    If the user clicks the **register** button, they will be offered the opportunity
    to register and use your application. Sencha.io handles all of the forms, data
    storage, and interactions, which include password recovery without the need for
    any additional code.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sencha.io also offers you the option of deploying your application to the Sencha.io
    cloud service.
  prefs: []
  type: TYPE_NORMAL
- en: From the Sencha.io dashboard, you can click on your application in the list
    on the right-hand side of the page. When the main page for the application appears,
    click on **New Version** and you will be able to upload a zipped file containing
    all of your code to the Sencha.io website.
  prefs: []
  type: TYPE_NORMAL
- en: When the upload completes, you will be presented with a public URL you can use
    to access the application. You can also specify if the release is for development
    or production.
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to deploy your application to your own web server if you
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few things that can be added to the application to make it more
    complete:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ability to edit/delete cards and decks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the deck list template to show the number of cards in the deck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a more detailed layout and CSS styling for the questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch the login method in the Sencha dashboard to allow login with Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the messaging system to present an alert to the user when new cards or decks
    are available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opportunities offered by Sencha.io are huge. With its integrated messaging
    system, you have the potential to communicate with a single user or every user
    of the application. This opens up possibilities such as publishing and sharing
    decks between users.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, take a look at the documentation available at [http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction](http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we used a simple Flash card application to explore some of
    the uses and possibilities of Sencha.io. We covered the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic application including the stores, models, and views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Sencha.io, signing up, downloading, installing, and configuring
    the basic application to communicating with the Sencha.io service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a controller for the application and updating the stores to connect
    to the Sencha.io service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the carousel so that it can read from a data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application to Sencha.io
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will explore creating your own API for use with Sencha
    Touch.
  prefs: []
  type: TYPE_NORMAL
