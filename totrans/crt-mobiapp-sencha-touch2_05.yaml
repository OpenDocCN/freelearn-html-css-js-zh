- en: 'Chapter 5. On Deck: Using Sencha.io'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。在牌组中：使用Sencha.io
- en: In our previous chapters we have typically used local storage for maintaining
    our data. This offers a number of advantages with its ease of use and simplicity.
    The store and the model do all of the heavy lifting for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们通常使用本地存储来维护我们的数据。这以其易用性和简单性提供了许多优势。存储和模型为我们做了所有繁重的工作。
- en: However, there are a number of disadvantages to local storage as well. First
    and foremost, it is very much local to the device. This means that if your user
    has more than one device (a phone, desktop, and a tablet computer), then they
    will have a separate set of data for each device.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本地存储也有一些缺点。首先，它非常本地化。这意味着如果你的用户有多个设备（一部手机、桌面和一台平板电脑），那么他们将为每个设备有一组独立的数据。
- en: This can be confusing to the user and it negates the advantage of having a single
    application that is accessible from multiple devices. Additionally, the data can
    be deleted by the user when they clear the local browser data. This can make local
    storage a bit problematic for a robust application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使用户感到困惑，并抵消了拥有一个可以从多个设备访问的单个应用程序的优势。此外，用户在清除本地浏览器数据时可以删除数据。这可能会使本地存储对健壮的应用程序有些问题。
- en: 'In this chapter we are going to look at solving this issue with an external
    API called Sench.io. Here''s what we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用名为Sench.io的外部API来解决此问题。以下是我们将要涵盖的内容：
- en: Setting up the basic application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: Getting started with Sencha.io
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Sencha.io
- en: Updating the basic application to work with Sencha.io
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本应用程序更新为与Sencha.io一起工作
- en: The basic application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本应用程序
- en: Our basic application is designed to present a set of flash cards to the user
    in a random order. Each set of flash cards comprises a deck. The user can add
    new decks and new cards to each deck. The decks and the cards will reside in a
    remote storage service called **Sencha.io**. Using this service, the user will
    also be able to log in from any number of devices and access their cards and decks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用程序旨在以随机顺序向用户展示一组闪卡。每一组闪卡包含一副牌。用户可以为每副牌添加新的牌。这些牌和牌组将存储在一个名为**Sencha.io**的远程存储服务中。使用此服务，用户还可以从任何数量的设备登录并访问他们的牌和牌组。
- en: '![The basic application](img/8901OS_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![基本应用程序](img/8901OS_05_01.jpg)'
- en: We will start off our application with the models and stores.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始我们的应用程序，从模型和存储开始。
- en: Creating the models and stores
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型和存储
- en: 'The model for our deck is very simple and only needs two pieces of information.
    We will use an ID to link cards to a specific deck and a name for display purposes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌组模型非常简单，只需要两块信息。我们将使用一个ID将牌链接到特定的牌组，并使用名称进行显示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The card model needs an ID of its own so that we can uniquely identify it and
    a `deckID` value so that we know which deck it''s a part of. We will also need
    the question and answer for each card:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 牌模型需要它自己的ID，以便我们可以唯一地识别它，以及一个`deckID`值，以便我们知道它是哪个牌组的一部分。我们还需要为每张牌提供问题和答案：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the two stores, we will initially use a local storage `proxy` as we have
    in previous chapters. This will let us test our application before we start using
    the Sencha.io service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个存储，我们最初将使用与之前章节中相同的本地存储`proxy`。这将让我们在开始使用Sencha.io服务之前测试我们的应用程序。
- en: 'Our deck store looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌组存储看起来是这样的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have worked your way through the first chapter, this basic setup should
    look pretty familiar to you. We extend the basic store, require our `model` file,
    and then set up our configuration. The configuration sets the store to load when
    it is created, tells it which model to use, sets up our local storage `proxy`,
    and tells it which `fields` to expect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了第一章，这个基本设置应该对你来说相当熟悉。我们扩展了基本存储，需要我们的`model`文件，然后设置我们的配置。配置设置在创建时加载存储，告诉它使用哪个模型，设置我们的本地存储`proxy`，并告诉它期望哪些`fields`。
- en: 'Our card store is almost an exact duplicate:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牌存储几乎是一个完全的副本：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have just changed the name from `Deck` to `Card`, and specified our
    card fields in place of our deck fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将名称从`Deck`更改为`Card`，并用我们的牌字段替换了牌组字段。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you configure your store with a model, you don't actually have to specify
    the fields. We are doing so here just for the sake of completeness.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用模型配置存储，实际上你不必指定字段。我们在这里这样做只是为了完整性。
- en: As mentioned before, we will be revisiting these stores once we get things set
    up with `Sencha.io`, but first we need to get our display together for our lists,
    cards, and editing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our main view, we will be using a tab panel with two containers, one for
    our decks and one for our cards. We will use sheets for editing and adding new
    decks and cards. Our initial `main.js` file looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remember to add this file into your `app.js` file and set the launch function
    to create a copy of the component when the application starts (if you are using
    Sencha Architect, then this should happen automatically). Your `app.js` file should
    look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we need to add the two containers to our `main.js` view. In the empty
    items section, add the following container:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will be the list for our decks. The overall container has a `fit` layout
    so the items will fill the entire width and height of the container. We have given
    the container a title and an `iconCls` value, which will be used to label the
    tab in our `Main` tab panel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The container has a `list` view that uses our `DeckStore` store and a simple
    `itemTpl` template that displays the name of each deck in a separate `div` tag.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We have also added a title bar where we can display a button for adding new
    decks and a title to let the user know what they are looking at.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second container follows the same pattern as our first, but instead of
    a list, we have a separate container with a `carousel` layout, as shown in the
    following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This container has a `titlebar` control that will be set to display the name
    of the current deck at the top and pull the cards into our `carousel` layout.
    We also have a second button that will shuffle the current deck of cards.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to set up the two sheets for adding cards and decks. The deck
    sheet is a simple sheet with a `textfield` element for naming the deck, a `button`
    element for saving, and another `button` element for canceling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We also add a listener for the `Cancel` button that will hide the sheet without
    saving the values. The listener delegates the `tap` event to our `cancelDeckButton`
    delegate and calls the `hideDeckSheet` function when the `tap` event occurs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The `hideDeckSheet` function receives the `button` element as part of its arguments.
    We can then travel up the DOM structure from the button, find the sheet, and hide
    it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A note about using up and down**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `up` and `down` functions in Sencha Touch are extremely useful when you
    have a component and you need to get to either a sub component or a parent component.
    However, it should be noted that both `up` and `down` only return the first component
    that matches. For example, if a `button` element is inside of a `container` element,
    which is itself inside another `container` element, then `button.up('container')`
    would return the first container and not the second, outer container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Our card sheet is a duplicate of the deck sheet, but with text fields for `question`
    and `answer`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As before, we have our **Save** and **Cancel** buttons, with the **Cancel**
    button hiding the sheet when tapped.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to start the application and test the different views
    as shown:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the views](img/8901OS_05_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Before we can get things working further in the application, we need to get
    set up with Sencha.io.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Sencha.io
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sencha.io service will allow us to store our data using Sencha's cloud service.
    We will need to register a new account, add our application and user groups using
    the Sencha.io dashboard, and then configure our application to use the service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The sign-up process
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To register a new account, go to [https://manage.sencha.io](https://manage.sencha.io)
    and click on the **Register** link at the bottom of the page. Fill out the forms
    with your information and submit. Once your account is created, log in to the
    Sencha.io dashboard at the same address you used for registration, and you will
    see something similar to the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![The sign-up process](img/8901OS_05_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Downloading and installing the Sencha.io SDK
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have an account you can download and install the Sencha.io SDK.
    There is a download link in the first part of the **Getting Started** page (which
    should be where you first start when you log in).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the SDK to your computer and unzip the file. Move it into your web
    directory (someplace where you can easily reference it from your application).
    Next we need to add these files to our application. You can begin by opening your
    main `app.html` file and adding the following lines in the `head` section of the
    file (with your other script includes):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we have copied all of the Sencha.io files into a folder called
    `io` in the `lib` directory of our application. If your path is different, you
    will need to adjust the lines above to fit your setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have included the two main files we need for Sencha.io, we also
    need to set some options in `app.js` so that the autoloader picks up these files
    as well. At the top of the `app.js` file, add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once we have this information set, our application should be able to pick up
    all the files it needs to work with Sencha.io, but we still need to register our
    application before we can continue building.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Registering your application and Auth group
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Registering your application and Auth group with Sencha.io provisions the application
    with its own data storage and an authorized user base. As with most API services,
    your application needs a way to uniquely identify itself to the remote system
    so that it will know where to store your data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'With Sencha.io, we will get two pieces of information when we register our
    application: an `appID` value and an `appSecret` value. These two pieces of information
    will be added to `app.js` to identify our application to the Sencha.io system.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding an Auth group. The Auth group sets up a group where users
    can register to use your application. If you have multiple applications, you can
    set up one Auth group for each application or set up a single Auth group to be
    shared across multiple applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: From the **Dashboard** section of your Sencha.io account ([http://manage.sencha.io](http://manage.sencha.io)),
    click on the **Auth Groups** link at the top of the page and choose **Create Auth
    Group**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Enter a name for your Auth group and click on **Save**. The name is arbitrary,
    but if you are using the group for a single application, it's probably best to
    name it something like `myAppNameUsers` so that you can keep track of which application
    this is for.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The Auth group also controls how the users authenticate in your application.
    Once you have saved the Auth group, you can edit it and change the way users log
    in to your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: You can choose to have users authenticate before the application fully downloads
    or afterwards. You can also choose to let users log in with a valid Facebook,
    Twitter, or Sencha.io account.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the **Sencha.io** login option, then the SDK will automatically
    handle both user registration and authentication within your application, no extra
    coding required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the **Facebook** or **Twitter** login option, Sencha.io will handle
    the authentication automatically. Users will have to be registered with either
    service before they can access the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a set of users for the application, we need to register the
    application itself. From the Sencha.io dashboard, click on **Apps** and then click
    on **Create App**. As before, we only need to enter a name for the application.
    For this application we chose the name **OnDeck** as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Next we need to select our **Authentication Group** name from the drop-down
    menu. This tells Sencha.io to authenticate and assign users from this group to
    our application. There is an optional **CNAME** field for setting the domain your
    application will reside on, as well as a field for the path to the `index.html`
    file. This should be set if you are using the `app.html` file instead of `index.html`,
    or if you have your application hosted inside a sub directory on your server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We can also set an application icon here. This is the icon that will be used
    if the user saves our web application to their home screen. Click on **Save**
    when you are finished.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering your application and Auth group](img/8901OS_05_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: On the page application page, you should now see a listing for your application's
    ID (mentioned in the **ID** field) and secret (mentioned in the **Secret** field).
    Make note of these, as we will need to add them into `app.js` once we are finished
    with registration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the **ID** and **Secret** values in the preceding example screenshot
    are example data only. You will need to generate your own information on the Sencha.io
    site to make your application work. You will also need to generate your own ID
    and secret to make the example code from the chapter work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed this part of the registration, you will need to add
    the ID and secret values into your `app.js` file. Open the file and add the following
    code at the top of the `Ext.application({` section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Substitute your information for the `appId` and `appSecret` placeholders shown.
    Once you have added the information into `app.js`, we can get back to updating
    our stores and creating our controller.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application for Sencha.io
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our application is registered, we need to set up the stores to use
    Sencha.io. We will also set up our controller for the application and show you
    how to override the `Carousel` component to make it work with a data store.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Updating the stores
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our original stores were simple local storage for testing. We are going to
    edit these now to use Sencha.io to store our data. Most of these changes will
    be in the `proxy` section. For example, the `DeckStore` code should be updated
    to look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we now use a new type of proxy called `syncstorage`. This is the
    special Sencha.io proxy that works much the same as a local store, but it stores
    the data remotely on the Sencha.io servers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We also have new configurations for `owner` and `access`. The `owner` and `access`
    field must both be set for `syncstorage` to work correctly. As of this writing,
    the only `owner` option is `user`. This is the currently authenticated user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `access` configuration determines if the store is **private**, available
    only to the currently authenticated user, or **public**, available to all members
    of the group of users. This is the user group we set up in the Sencha.io dashboard.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we added a configuration of `autoLoad: true`. This will load any local
    data if the connection is lost while the user is still logged in. We then set
    `autosync: false` to prevent the store from automatically syncing when the application
    starts. We should to wait until the user logs into the application before we load
    the store. We will do this manually as part of the application controller.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make the exact same changes to the `CardStore.js` file to get it working
    with Sencha.io, but it requires one additional setting for `remoteFilter: false`.
    We will be loading all of the user''s cards when they log in, and filtering them
    by deck once a deck is selected.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `remoteFilter` configuration is part of the store, not the proxy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our stores configured we can move on to the controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了存储，我们可以继续到控制器部分。
- en: Creating the controller
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'Our controller has a few things it needs to handle for us:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器需要为我们处理一些事情：
- en: Setting up for Sencha.io
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Sencha.io设置
- en: Handling anything that needs to happen at login and logout
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理登录和登出时需要发生的任何事情
- en: Adding cards and decks
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加卡片和牌组
- en: Selecting a deck for display
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择用于显示的牌组
- en: Syncing between the local application and Sencha.io
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地应用程序和Sencha.io之间同步
- en: 'We will start by setting up our basic controller with the models, views, stores,
    and references:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置基本控制器，包括模型、视图、存储和引用：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first section defines our controller and then lists the `models`, `stores`,
    and `views` values we previously created. We also add an empty configuration for
    `selectedDeck`. We will be using this as a placeholder for storing the record
    of the currently selected deck. This will allow us to easily get and set the value
    anywhere in our controller functions using `getSelectedDeck` and `setSelectedDeck`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分定义了我们的控制器，并列出了之前创建的`models`、`stores`和`views`值。我们还为`selectedDeck`添加了一个空配置。我们将使用这个作为存储当前所选牌组记录的占位符。这将允许我们在控制器的任何地方使用`getSelectedDeck`和`setSelectedDeck`轻松地获取和设置值。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Getters and setters**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取器和设置器**'
- en: Sencha Touch automatically creates `get` and `set` functions for configuration
    settings as well as references (see the following section). These functions take
    the form of `getWhateverYouCalledIt` and `setWhateverYouCalledIt`. It is important
    to remember that even if you lowercase the first letter of the `config` option
    or reference, the `get` and `set` functions will uppercase the first letter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Touch会自动为配置设置以及引用创建`get`和`set`函数（见下一节）。这些函数的形式为`getWhateverYouCalledIt`和`setWhateverYouCalledIt`。重要的是要记住，即使你将`config`选项或引用的第一个字母小写，`get`和`set`函数也会将第一个字母大写。
- en: The `refs` section allows us to create a reference to a component either by
    `id` (such as `#addCardSheet`) or a component query, such as (`#addCardSheet button[text="Save"]`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`refs`部分允许我们通过`id`（例如`#addCardSheet`）或组件查询（例如`#addCardSheet button[text="Save"]`）创建对组件的引用。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding component query will look for a component with an `id` value of
    `addCardSheet` and then find the button within the component that has a `text`
    configuration of `"Save"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个组件查询将寻找一个`id`值为`addCardSheet`的组件，然后在该组件中找到配置为`"Save"`的按钮。
- en: We can now reference anything in our `refs` list with `this.getReferenceName`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`this.getReferenceName`引用我们的`refs`列表中的任何内容。
- en: 'Immediately after the `refs` section we need to add a `control` section. This
    section uses our references and defines a set of listeners and functions for some
    of our components:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refs`部分之后，我们需要添加一个`control`部分。此部分使用我们的引用，并为一些组件定义了一组监听器和函数：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each member of our `control` section has a reference, an event to listen for
    and a function to fire when the event occurs. We will create each of these functions
    later in the controller, but first we need to add our `init` function to set up
    Sencha.io and the other functions for authentication.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`control`部分的每个成员都有一个引用，一个要监听的事件，以及当事件发生时要触发的函数。我们将在控制器中稍后创建这些函数，但首先我们需要添加我们的`init`函数来设置Sencha.io和其他认证函数。
- en: 'When our application first starts, it needs to listen to the Sencha.io controller
    for authentication and messaging. We handle this in our `init` function (this
    goes right after the `config` section):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序首次启动时，它需要监听Sencha.io控制器进行认证和消息处理。我们在`init`函数中处理这个问题（紧接在`config`部分之后）：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code tells our controller three events from the Sencha.io controller:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉我们的控制器来自Sencha.io控制器的三个事件：
- en: '`authorized`: The user has successfully logged in'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorized`：用户已成功登录'
- en: '`logout`: The user has logged out of the system'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout`：用户已从系统中登出'
- en: '`usermessage`: The user has received a message'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usermessage`：用户已收到消息'
- en: We have assigned a function to each one of these events and now we need to add
    them below our `init` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个这些事件分配了一个函数，现在我们需要在`init`函数下方添加它们。
- en: 'The first is our `onAuth` function, which syncs all of the user''s stores once
    they have logged in:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是我们的`onAuth`函数，它在用户登录后同步所有用户的存储：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `onLogout` function does the reverse and clears out any locally stored
    data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`onLogout`函数执行相反的操作，并清除任何本地存储的数据：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our message function is a bit more interesting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息功能有点更有趣。
- en: Sencha.io allows an application to send messages to the user. These can be system
    messages (for example, the data in a store has updated) or even direct messages
    between users.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io允许应用程序向用户发送消息。这些可以是系统消息（例如，存储中的数据已更新）或甚至用户之间的直接消息。
- en: 'We have set up the following function to simply sync our stores when a message
    has been received (we will set up the function to send the message a bit later).
    This means if the user has the program open on one device and makes a change to
    the data, any other device that user has logged in will update and receive the
    change:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个函数，当收到消息时简单地同步我们的存储（我们将在稍后设置函数以发送消息）。这意味着如果用户在一个设备上打开了程序并更改了数据，任何其他登录了该用户的设备都将更新并接收更改：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have also added a number of console logs, which you can use to take a look
    at the messages being sent and the data that is potentially available to your
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些控制台日志，你可以使用它们来查看发送的消息和可能可用于应用程序的数据。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to pull up your console when testing the application and examine the
    different message elements available to you. We will delve deeper into messaging
    in the final chapter, but you can also check out the *Overview Guide* available
    at [http://docs.sencha.io](http://docs.sencha.io) for more information about messaging.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序时，请确保打开控制台并检查可用的不同消息元素。我们将在最后一章深入探讨消息传递，但你也可以查看[http://docs.sencha.io](http://docs.sencha.io)上提供的*概述指南*以获取有关消息传递的更多信息。
- en: 'Next we need to add the functions that will save our new cards and decks. Both
    functions are tied to their respective save buttons. They need to grab the data
    from the sheet, add it to the store, and then sync the store:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加将保存我们新卡片和牌组的函数。这两个函数都与它们各自的保存按钮相关联。它们需要从表格中获取数据，将其添加到存储中，然后同步存储：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use our references here to grab the `addCardSheet` value using `this.getAddCardSheet()`
    and then we add the data as a new record to our card store.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用我们的引用来通过`this.getAddCardSheet()`获取`addCardSheet`值，然后将数据作为一条新记录添加到我们的卡片存储中。
- en: 'We then sync the store and *bind* a function called `syncCallback`. This is
    the function that will send out our message telling the application that data
    has been updated. The `syncCallback` function can go right below our `addCards`
    function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们同步存储并将一个名为`syncCallback`的函数绑定。这是将发送消息告知应用程序数据已更新的函数。`syncCallback`函数可以直接放在`addCards`函数下面：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The console logs have been left in to provide an inside view of the data being
    passed inside the function. The first part of the code, `this.getApplication().sio.getUser`,
    grabs the currently authenticated user and runs a function. The function checks
    to see if we got back a user and, if so, we send the user a message that simply
    says, `updated`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志被保留以提供函数内部传递数据的内部视角。代码的第一部分`this.getApplication().sio.getUser`获取当前认证的用户并运行一个函数。该函数检查是否收到了用户，如果是，我们向用户发送一条简单的消息，内容为`updated`。
- en: This message gets processed by our `onUserMessage` function, which causes our
    stores to update their data. You can change this message and use the console logs
    to see how the data is passed between the two functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息由我们的`onUserMessage`函数处理，这会导致我们的存储更新其数据。你可以更改这条消息并使用控制台日志来查看两个函数之间数据是如何传递的。
- en: 'Our `addDeck` function is a virtual duplicate of our `addCard` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`addDeck`函数是`addCard`函数的虚拟副本：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we only need to get one `textfield` value before we sync the store and
    do our `syncCallback` function. As before, we also clear the field values before
    hiding the sheet.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步存储并执行`syncCallback`函数之前，我们只需要获取一个`textfield`值。与之前一样，在隐藏表格之前，我们也会清除字段值。
- en: Next we will need to leave our controller for a bit and take a look at how our
    cards will be displayed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要暂时离开控制器，看看我们的卡片是如何显示的。
- en: Overriding the Carousel component
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖Carousel组件
- en: For a flash card application, `Carousel` seems like an ideal component to use
    because it allows the user to quickly flip from one card to the next. This would
    allow us to present a question and have the user swipe to get to the answer. The
    user can then swipe again to get to the next question and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个闪卡应用来说，`Carousel`组件似乎是一个理想的选择，因为它允许用户快速翻转到下一张卡片。这将使我们能够展示一个问题，并让用户滑动以获取答案。用户可以再次滑动以获取下一个问题，依此类推。
- en: This problem is that `Carousel` is actually a collection of panels and what
    we really need is something that will pull records from our data store the way
    a list view does. In order to do this we need to override the `Carousel` component
    and add some additional behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于`Carousel`实际上是一个面板集合，而我们真正需要的是能够像列表视图那样从我们的数据存储中提取记录的东西。为了做到这一点，我们需要覆盖`Carousel`组件并添加一些额外的行为。
- en: 'We will start with our basic component that extends `Carousel`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从扩展`Carousel`的基本组件开始：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We start out setting our `store` configuration to `null` by default. We will
    set this when we declare the component in the `Main.js` file. In our `Main.js`
    file, locate the section that says:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初将`store`配置设置为默认的`null`。我们将在`Main.js`文件中声明组件时设置它。在我们的`Main.js`文件中，找到以下部分：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Replace that line with the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将该行替换为以下内容：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sets the container to our new `flashcards` carousel and sets the `store`
    configuration to `CardStore`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将容器设置为我们的新`flashcards`轮播图，并将`store`配置设置为`CardStore`。
- en: If we had hardcoded the store for the component in our `CardView.js` file, it
    would be more difficult to re-use. When you override a component to extend functionality,
    it is always a good idea to write it with an eye towards re-using it somewhere
    else, later on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`CardView.js`文件中硬编码了组件的存储，那么它将更难重用。当你覆盖一个组件以扩展功能时，始终是一个好主意，编写时考虑到将来在其他地方重用的可能性。
- en: 'Back in `CardView.js`, we need to add a pair of strings to use as xTemplates
    for our question and answer cards. These go in the `config` section of our component:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CardView.js`，我们需要添加一对字符串，用作问题和答案卡片的xTemplates。这些放在我们的组件的`config`部分：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These will control how to display the question and answer cards. Since we will
    be using these same templates multiple times, it''s a good idea to compile them
    in our `constructor` function. Otherwise, the xTemplate will be compiled and recompiled
    each time a new flashcard is created:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将控制如何显示问题和答案卡片。由于我们将多次使用这些相同的模板，所以在`constructor`函数中编译它们是个好主意。否则，xTemplate将在每次创建新的闪存卡时被编译和重新编译：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our `constructor` function also sets up the store we passed in `Main.js`. This
    one is a bit complex and requires a bit of explaining. Let''s start from the inside
    and work our way out:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`constructor`函数还设置了在`Main.js`中传递的存储。这个函数有点复杂，需要一些解释。让我们从内部开始，逐步向外解释：
- en: '`this.getStore()`: This grabs the string value we passed in `Main.js` (`store:
    ''CardStore''`)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.getStore()`: 这获取我们在`Main.js`中传递的字符串值（`store: ''CardStore''`）'
- en: '`Ext.getStore()`: This grabs the store with a `storeId` value of `''CardStore''`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext.getStore()`: 这通过`storeId`值为`''CardStore''`获取存储'
- en: '`this.setStore()`: This applies the store to our `CardView` component, replacing
    the original string value'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.setStore()`: 这将存储应用于我们的`CardView`组件，替换原始字符串值'
- en: When we call `this.getStore()` on the next line to set `listeners`, it now returns
    an actual store instead of the string value from before.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行调用`this.getStore()`来设置`listeners`时，现在它返回一个实际的存储，而不是之前的字符串值。
- en: Then we assign a single function to the store events for `load`, `refresh`,
    and `addrecords`. We need to add that function next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为存储的`load`、`refresh`和`addrecords`事件分配一个单一的功能。我们需要在下一个步骤中添加该函数。
- en: 'We have broken this function into two parts. The first part is the `createCards`
    function, which gets our store and removes any existing panels from our custom
    carousel. It then checks to see if we have any cards in the store:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数分为两部分。第一部分是`createCards`函数，它获取我们的存储并从我们的自定义轮播图中删除任何现有的面板。然后它检查存储中是否有任何卡片：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If not, we give the user a message that there are no cards in the deck and they
    can click on **Add** to create new cards.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，我们给用户显示一条消息，说明牌组中没有卡片，并且他们可以点击**添加**来创建新的卡片。
- en: 'This is where the second part of our function comes into play. If we have records,
    we pass each one along to a second function called `createFlashCard`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的函数的第二部分发挥作用的地方。如果我们有记录，我们将每个记录传递给一个名为`createFlashCard`的第二个函数：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function is run on each record in `CardStore`. The first line creates our
    initial data array and sets values for the `total` (the number of cards in the
    deck), `number` (the sequential number of the current card), and `data` records
    from the store (which contains both our question and answer for the card).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在`CardStore`中的每一条记录上运行。第一行创建我们的初始数据数组，并设置`total`（牌组中的卡片数量）、`number`（当前卡片的顺序号）和从存储中获取的`data`记录（其中包含我们的问题和答案）的值。
- en: We then create a new `panel` component and set `html` to our compiled question
    template with the applied data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We do the same thing for our answer template, so we end up with two new panels
    for each record in the store; a question panel, followed by an answer panel.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Since `CardStore` contains all of the records for every deck, we need to filter
    these down by deck before our `CardsView` carousel loads. We'll handle that back
    in the controller.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Back in the controller
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the user selects a deck from our list, we need to filter `CardStore` so
    that only the cards for that deck are available. We do this in our `onDeckSelected`
    function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is triggered by the select event in our `deckList` component and
    passes us the list and the record that was selected. Once we grab `CardStore`,
    we set the `selectedDeck` function to the record that was passed to us when the
    deck in the list was selected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Next, we clear any existing filters on `CardStore` and sort it by its `id` value.
    We then filter the cards to only display the ones for the current deck. Finally,
    we enable `cardsPanel` and set it to be the active item.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `control` function that fires when `cardPanel` is shown. This
    function sets the title bar of the card panel to the name of the deck:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since our initial load of the card store presents them in order by `id`, it
    might be a good idea to let the user shuffle the cards. We do this with our final
    controller function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function grabs `CardStore` and sorts it using JavaScript's `Math.random`
    function to assign a random sort order to each card.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more complete understanding of how sorting works in JavaScript (and Sencha
    Touch), consult the excellent Mozilla Developer Network's JavaScript Reference
    for sorting at [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to add decks and cards to the application. When you
    select a deck, the card stack will appear. You can advance from one card to the
    next by swiping from right to left as shown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Back in the controller](img/8901OS_05_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: You can use the CSS files to style the answer and question to fit your own personal
    tastes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you will need to register with the application before you can start
    creating decks and cards. Once you are registered, you can log in from any Sencha
    Touch Compatible browser and access the same information across multiple devices.
    Fortunately, since we are using Sencha.io, all of this is taken care of automatically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Back in the controller](img/8901OS_05_10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Sencha.io automatically creates these login and registration forms for our application.
    If the user clicks the **register** button, they will be offered the opportunity
    to register and use your application. Sencha.io handles all of the forms, data
    storage, and interactions, which include password recovery without the need for
    any additional code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的部署
- en: Sencha.io also offers you the option of deploying your application to the Sencha.io
    cloud service.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io 还提供了将您的应用程序部署到 Sencha.io 云服务的选项。
- en: From the Sencha.io dashboard, you can click on your application in the list
    on the right-hand side of the page. When the main page for the application appears,
    click on **New Version** and you will be able to upload a zipped file containing
    all of your code to the Sencha.io website.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Sencha.io 仪表板中，您可以在页面右侧的列表中点击您的应用程序。当应用程序的主页出现时，点击**新版本**，您将能够上传一个包含所有代码的压缩文件到
    Sencha.io 网站。
- en: When the upload completes, you will be presented with a public URL you can use
    to access the application. You can also specify if the release is for development
    or production.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上传完成后，您将看到一个可以用来访问应用程序的公共 URL。您还可以指定发布是针对开发还是生产。
- en: You can also choose to deploy your application to your own web server if you
    prefer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择将应用程序部署到您自己的 Web 服务器。
- en: Homework
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'There are a few things that can be added to the application to make it more
    complete:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加一些内容到应用程序中使其更加完整：
- en: Add the ability to edit/delete cards and decks
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加编辑/删除卡片和牌组的功能
- en: Update the deck list template to show the number of cards in the deck
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新牌组列表模板以显示牌组中的卡片数量
- en: Provide a more detailed layout and CSS styling for the questions and answers
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题和答案提供更详细的布局和 CSS 样式
- en: Switch the login method in the Sencha dashboard to allow login with Facebook
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sencha 仪表板中的登录方法切换为允许使用 Facebook 登录
- en: Use the messaging system to present an alert to the user when new cards or decks
    are available
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息系统在用户有新卡片或牌组可用时向用户显示警报
- en: The opportunities offered by Sencha.io are huge. With its integrated messaging
    system, you have the potential to communicate with a single user or every user
    of the application. This opens up possibilities such as publishing and sharing
    decks between users.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha.io 提供的机会是巨大的。凭借其集成的消息系统，您有可能与单个用户或应用程序的每个用户进行通信。这为用户之间发布和共享牌组等可能性打开了大门。
- en: For more information, take a look at the documentation available at [http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction](http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看[http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction](http://docs.sencha.io/0.3.3/index.html#!/guide/overview_introduction)提供的文档。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter we used a simple Flash card application to explore some of
    the uses and possibilities of Sencha.io. We covered the following points:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了一个简单的闪卡应用程序来探索 Sencha.io 的一些用途和可能性。我们涵盖了以下内容：
- en: Building the basic application including the stores, models, and views
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本应用程序，包括存储、模型和视图
- en: Getting started with Sencha.io, signing up, downloading, installing, and configuring
    the basic application to communicating with the Sencha.io service
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Sencha.io，注册、下载、安装和配置基本应用程序以与 Sencha.io 服务通信
- en: Creating a controller for the application and updating the stores to connect
    to the Sencha.io service
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建控制器并更新存储以连接到 Sencha.io 服务
- en: Overriding the carousel so that it can read from a data store
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖轮播图，使其能够从数据存储中读取
- en: Deploying the application to Sencha.io
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Sencha.io
- en: In the next chapter we will explore creating your own API for use with Sencha
    Touch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨创建用于 Sencha Touch 的自定义 API。
