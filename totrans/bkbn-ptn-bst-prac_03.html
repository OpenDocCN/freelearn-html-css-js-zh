<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Models</h1></div></div></div><p>JavaScript models <a id="id133" class="indexterm"/>are an essential part of client-side data management. In stateful JavaScript applications, local or remote data is stored in models and the model provides a number of functions to work with this data such as conversions, validations, data persistence, and so on. Backbone models<a id="id134" class="indexterm"/> are no different than these and provide similar functionalities such as set/get data, validate, save to or fetch from the server, delete an attribute, and sync with the server.</p><p>In this chapter, we will discuss some basic problems with models that Backbone developers usually face, and will then propose some possible solutions to them. Also, we will cover a few interesting plugins and extensions for models that will help reduce boilerplate in your code. The main points to be covered are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Basic usage of models</strong>: Learn the basics of Backbone models, such as important methods, properties, and data operations.</li><li class="listitem" style="list-style-type: disc"><strong>Validating the data</strong>: We will see how basic data validations are done with Backbone models. Also, we will analyze an important plugin, <code class="literal">Backbone.Validation</code> that helps us reduce lots of boilerplate validation code.</li><li class="listitem" style="list-style-type: disc"><strong>Serializing models</strong>: The data sent to the server or received from the server can be of different format than the format the model expects it to be. In this section, we will see how overriding the <code class="literal">parse</code>() and <code class="literal">toJSON()</code> methods help the model directly communicate with the server.</li><li class="listitem" style="list-style-type: disc"><strong>Understanding relational data model</strong>: We will read an analysis of nested models and collections with the help of the Backbone relational plugin.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Basic usage of models</h1></div></div></div><p>Models <a id="id135" class="indexterm"/>are one of the most important components of Backbone. Starting from storing data, they provide a lot of functionality, including logic around the data, validations, data interactions, and so on. A model can be defined by extending the <code class="literal">Backbone.Model</code> class, shown as follows:</p><div><pre class="programlisting">var User = Backbone.Model.extend({});</pre></div><p>A model consists of an <code class="literal">attributes</code> property that stores the data within it. You can get the model data using a <code class="literal">get()</code> method and set the data in <code class="literal">attributes</code> by using the <code class="literal">set()</code> method:</p><div><pre class="programlisting">var newUser  =  new User({
  name : 'Jayanti De',     
  age : 40
});

var name = newUser.get('name');  // Jayanti De
newUser.set('age', 42);

console.log(newUser.toJSON()); 
// Output =&gt; {"name": "Jayanti De", "age": 42}</pre></div><p>The <code class="literal">toJSON()</code> method<a id="id136" class="indexterm"/> of a model returns a copy of the model attributes as a JSON object. Note that the output has <code class="literal">age</code> now <a id="id137" class="indexterm"/>set to the new value. Whenever you change any attribute via the <code class="literal">set()</code> method, a <code class="literal">change</code> event gets fired on the model:</p><div><pre class="programlisting">newUser.on('change' , function(model, options){
  console.log(model.changed);  // Output =&gt; {"age" : 42}
});</pre></div><p>The <code class="literal">change</code> event for each changed attribute also gets fired:</p><div><pre class="programlisting">newUser.on('age:change' , function(model, newAge){
  console.log(newAge);  // Output =&gt; 42
});</pre></div><p>This is quite beneficial when you want to update your views partially, because both the <code class="literal">change</code> and <code class="literal">change:age</code> events get fired in this case. You can listen only to a particular attribute change and act accordingly.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Using the defaults property</h2></div></div></div><p>In some <a id="id138" class="indexterm"/>cases, you may want your model to have a set of default values until new data is added to it. Backbone provides a <code class="literal">defaults</code> property where you can specify the initial data, as shown in the following code snippet:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  defaults: {
    name: 'John Doe',
    age: 20
  }
});

console.log(new User().get('name')); 
// Output =&gt; John Doe</pre></div><p>When added for every instance of the model, any unspecified attribute will automatically be set to the default value.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Avoiding object references in the defaults property</h3></div></div></div><p>Make sure<a id="id139" class="indexterm"/> that you never use any object or array directly in the <code class="literal">defaults</code> property. This is because the objects are shared by reference in JavaScript, and if added into <code class="literal">defaults</code>, the objects will get shared among all the instances of the model. An example follows to explain the case:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
    defaults : {
        hobbies : []
    }
});

var user1 = new User(),
user2 = new User();

user1.get('hobbies').push('photography');
user2.get('hobbies').push('biking');

console.log(user1.get('hobbies'));
// Output =&gt; ["photography", "biking"]</pre></div><p>You will see that the <code class="literal">hobbies</code> array now becomes a shared property between both the instances of the model. This is not a desired case and you should always avoid putting objects as default attributes. The solution to this problem can be achieved by using a function for the <code class="literal">defaults</code> property instead of an object:</p><div><pre class="programlisting">defaults: function() {
  return {
    hobbies: []
  }
}</pre></div><div><pre class="programlisting">console.log(user1.get('hobbies'));
// Output =&gt; ["photography"]</pre></div><p>This function will get executed every time a model instance is created, and thus will always send a new object for <code class="literal">defaults</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Data interaction with the server</h2></div></div></div><p>The<a id="id140" class="indexterm"/> Backbone model has made data operations with the server quite easy by providing a set of interesting methods such as <code class="literal">fetch()</code>, <code class="literal">save()</code>, <code class="literal">sync()</code>, and <code class="literal">destroy()</code>. Let's look into each of these methods one by one. We will use the same user model as we did earlier.</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  url: '/users'
});</pre></div><div><div><div><div><h3 class="title"><a id="ch03lvl4sec01"/>Creating a model</h3></div></div></div><p>In general, if you set new values to the model and call the <code class="literal">save()</code> method on it, your server should create a new model in the database. Next time onwards, the model will carry this <code class="literal">id</code> attribute and calling the <code class="literal">save()</code> method again should only update the model and not create a new one:</p><div><pre class="programlisting">var user = new User({
  name : 'Ashim De',
  age : 55
});

user.save({
  success : function(){},
  error : function(){}
});  </pre></div><p>As no <code class="literal">id</code> attribute<a id="id141" class="indexterm"/> is present there yet, a POST request is sent to the <code class="literal">/users</code> URL and the server sends a response with the new ID.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl4sec02"/>Updating a model</h3></div></div></div><p>Updating<a id="id142" class="indexterm"/> a model is also similar. If there is an <code class="literal">id</code> attribute present, the same <code class="literal">save()</code> method<a id="id143" class="indexterm"/> sends a PUT request to the server with new attributes:</p><div><pre class="programlisting">var user = new User({
  id: 23,
  name: 'Shankha De',
  age: 14
});

// Send PUT request to the server
user.save();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl4sec03"/>Fetching a model</h3></div></div></div><p>If the <code class="literal">id</code> attribute<a id="id144" class="indexterm"/> is present, the <code class="literal">fetch()</code> method<a id="id145" class="indexterm"/> of the model sends a GET request to retrieve and populate the model:</p><div><pre class="programlisting">var user = new User({
  id: 23
});

// Sends GET request to /users/23
user.fetch();</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl4sec04"/>Deleting a model</h3></div></div></div><p>Use the <code class="literal">destroy()</code> method<a id="id146" class="indexterm"/> to <a id="id147" class="indexterm"/>delete a model. This method sends a DELETE request to the server with the model ID:</p><div><pre class="programlisting">var user = new User({
  id: 23
});

user.destroy({
  success: function () {}
});</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Validating the data</h1></div></div></div><p>In Backbone, validation <a id="id148" class="indexterm"/>is taken care of by the <code class="literal">model.validate()</code> method. <a id="id149" class="indexterm"/>By default, the <code class="literal">Backbone.Model</code> class doesn't have a <code class="literal">validate()</code> method<a id="id150" class="indexterm"/> on its own. However, the developers are encouraged to add a <code class="literal">validate()</code> method that gets called by the model every time an attribute is saved or set with <code class="literal">validate: true</code> passed. A copy of the attributes is sent to the <code class="literal">validate()</code> method with all the changed values. Let's look at a simple data validation:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  validation: {    emailRegEx: /^\s*[\w\-\+_]+(\.[\w\-\+_]+)*\@[\w\-\+_]+\.[\w\-\+_]+(\.[\w\-\+_]+)*\s*$/
},

  defaults: {
    name: '',
    email: ''
  },

  validate: function (attr) {
    if (attr.name.length === 0) {
      return 'Name is required';
    }

    if (attr.email.length === 0) {
      return 'Email is required';
    }

    if (!this.validation.emailRegEx.test(attr.email)) {
      return 'Please provide a valid email';
    }
  }
});

// Define the user view
var UserView = Backbone.View.extend({
  initialize: function () {
    this.model.on('invalid', this.handleError, this);
  },

  handleError: function (model, error, options) {
    alert(error);
  }
});

var user = new User();

var userView = new UserView({
  model: user
});

// Set new attributes 
user.set({
  name: '',
  email: 'johndoe#www.com'
}, {
  validate: true
});</pre></div><p>Here we created a model with the two attributes <code class="literal">name</code> and <code class="literal">email</code>, added a <code class="literal">validate()</code> method to<a id="id151" class="indexterm"/> test the values of these attributes, and defined a view that will handle the validation errors, if any.</p><p>As we are setting both the values in a single <code class="literal">set()</code> method, the <code class="literal">validate()</code> method will be called only once. However, it will return an error as soon as it finds an invalid attribute. What if we want to display all the errors together on our form? In that case, we must return an array or an object with all the error messages as shown in the following code snippet:</p><div><pre class="programlisting">validate: function (attr) {
  var errors = {};

  if (attr.name.length === 0) {
    errors['name'] = 'Name is required';
  }

  if (attr.email.length === 0) {
    errors['email'] = 'Email is required';
  }

  if (!this.validation.emailRegEx.test(attr.email)) {
    // If already there is an error for email, 
    // then skip other errors for email
    errors['email'] = errors['email'] || 'Please provide a valid email';
  }

  return errors;
}

// Set both empty values
user.set({
  name: '',
  email: 'johndoe#www.com'
}, { validate: true });</pre></div><p>Now, we<a id="id152" class="indexterm"/> will receive an object with all the errors. <a id="id153" class="indexterm"/>This is useful while you need to show data individually even when they are set one by one. For example, this will be handy while we want to validate a field on blur event.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Using the Backbone.Validation plugin</h2></div></div></div><p>So, <a id="id154" class="indexterm"/>we just saw a simple<a id="id155" class="indexterm"/> implementation of data validation. However, when there are lots of form fields with multiple validation criteria, the <code class="literal">validate()</code> method becomes too large with several nested if-else conditions. Creating the complete validation logic from scratch may make it more complicated and time-consuming. Fortunately, there is a wonderful plugin called <code class="literal">Backbone.Validation</code> (<a class="ulink" href="http://thedersen.com/projects/backbone-validation/">http://thedersen.com/projects/backbone-validation/</a>), which makes things a lot easier by providing multiple built-in validation methods and simplifying the validation binding with views. Let's reimplement the previous validation with this plugin.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Configuring validation rules</h3></div></div></div><p>There are <a id="id156" class="indexterm"/>a number of built-in validators, such as <code class="literal">required</code>, <code class="literal">maxLength</code>, <code class="literal">minLength</code>, <code class="literal">max</code>, <code class="literal">min</code>, <code class="literal">length</code>, and <code class="literal">pattern</code>. They are used as shown in the following code:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  validation: {
    name: {
      required: true
    },

    email: {
      required: true,
      pattern: 'email'
    }
  },

  defaults: {
    name: '',
    email: ''
  }
});</pre></div><p>There are some existing validation patterns such as e-mail, number, and URL. Alternatively, you can <a id="id157" class="indexterm"/>use a regular expression as a pattern. Similarly, you may need to define the complete validation functionality for an attribute rather than just a regular expression. In that case, you can add custom method validators to an attribute. Check the following example:</p><div><pre class="programlisting">var User = Backbone.Model.extend({
  validation: {
    // Do not return anything if validation is passed
    name: function (value, attr, computedState) {
      if (!value) {
        return 'Name is required';
      }
    },
   
    // the method will be called on model's scope
    email: 'validateEmail'
  },

  validateEmail: function (value, attr, computedState) {
    if (!value) {
      return 'Email is required';
    }
  }
});</pre></div><p>You can add the custom method to an attribute directly as a function or you can add the method name as a string, just like we did here. Every attribute can have one error message for each validation rule, or it can have a single one for all its validation rules. For example, in the following code, we provide separate messages for the <code class="literal">required</code> and <code class="literal">format</code> validations of <code class="literal">email</code>:</p><div><pre class="programlisting">{
  name: {
    required: true,
    msg: 'Name is required'
  },

  email: [{
    required: true,
    msg: 'Email is required'
  }, {
    pattern: 'email',
    msg: 'Please provide a valid email'
  }]
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Prevalidating a model with the preValidate() method</h3></div></div></div><p>This plugin<a id="id158" class="indexterm"/> provides another<a id="id159" class="indexterm"/> important functionality to prevalidate an attribute of the model without touching the model itself, shown as follows:</p><div><pre class="programlisting">var errorMessage = model.preValidate('attributeName', 'Value');</pre></div><p>So, the attribute will be validated against the set of validators assigned to it, and the return value will be an error message if validation fails.</p><p>The <code class="literal">Backbone.Validation</code> plugin is very effective if your application needs several form validations. It removes a lot of boilerplate from your code base and provides a simple yet robust validation mechanism.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Serializing models</h1></div></div></div><p>So far, <a id="id160" class="indexterm"/>the model data we used in our examples in the previous chapters are all simple data objects with attributes. However, there might be a case where the server is sending a different data format and you need to extract the essential part from it and apply it to the related model. For example, consider the following data:</p><div><pre class="programlisting">{
  "name": "John Doe",
  "email": "johndoe@example.com"
}</pre></div><p>Instead of sending the preceding data, the server returns the following data:</p><div><pre class="programlisting">{
  "user": {
    "name": "John Doe",
    "email": "johndoe@example.com"
  }
}</pre></div><p>This data cannot be applied directly to a model with the attributes <code class="literal">name</code> and <code class="literal">email</code>. If we call the <code class="literal">fetch()</code> method <a id="id161" class="indexterm"/>on the model now, it will just add another attribute named <code class="literal">user</code> to the model. The method that can help us overcome this issue is called <code class="literal">parse()</code>. By default, this method just passes the server response and the model applies whatever it receives from the <code class="literal">parse()</code> method. Here is how it is defined in <code class="literal">Backbone.js</code>:</p><div><pre class="programlisting">parse: function (resp, options) {
  return resp;
}</pre></div><p>However, we can override the <code class="literal">parse()</code> method to modify the raw server response and send back only the attribute <code class="literal">hash</code>. For this case, an object with the <code class="literal">name</code> and <code class="literal">email</code> attributes should be returned from the <code class="literal">parse()</code> method, as shown in the following code snippet:</p><div><pre class="programlisting"> var User = Backbone.Model.extend({
  url: 'server.json',
  defaults: {
    name: '',
    email: ''
  },

  // Returns the attribute hash 
  parse: function (response) {
    return response.user;
  }
});

var user = new User();
user.fetch({
  success: function () {
    console.log(user.get('name')); // John Doe
  }
});</pre></div><p>Here, the <code class="literal">server.json</code> file consists of the newly formatted data. In the <code class="literal">parse()</code> method, we are parsing the response and returning data that the Backbone model can accept.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Remember that the <code class="literal">fetch()</code> method will not clear your model, but will extend the attributes only. So if in our case, the server sends only an e-mail in the response, the previous e-mail will get updated, but the name will still be what it was.</p></div></div><p>Similar to fetching data from the server, sending data to it can also face the same problem, that is, the server may expect the exact format in which it sends data to the model. Now, if we call the <code class="literal">save()</code> method<a id="id162" class="indexterm"/> on the model, it will send the data in the following format:</p><div><pre class="programlisting">{ 
      name : 'Swarnendu De',
      email: 'swarnendu@email.com'
}</pre></div><p>So, if the server expects the data in the same format as it is sending now, we need to override the <code class="literal">toJSON()</code> method, which is pretty straightforward. In the following code, we create a new object with the <code class="literal">user</code> property and return that object from the <code class="literal">toJSON()</code> method:</p><div><pre class="programlisting">// Add this method to model
toJSON: function () {
  return {
    user: _.clone(this.attributes)
  }
}

// Let's set new data and send that to the server
user.set({
  name: 'Swarnendu',
  email: 'swarnendu@email.com'
});

user.save();</pre></div><p>The request will be sent to the server with the following data, which is exactly what we were looking for:</p><div><pre class="programlisting">{
  "user": {
    "name": "Swarnendu",
    "email": "swarnendu@email.com"
  }
}</pre></div><p>However, this process has a downside. In most cases, we use the <code class="literal">toJSON()</code> method to get the model attributes hash directly. As we are overriding this method here, the data returned will differ from the expected data. So, you need to decide whether you will follow this approach to serialize the model or implement server-side interaction separately. If you go for this process, remember to apply the model data accordingly in your views when using the <code class="literal">toJSON()</code> method. Or alternatively, you can clone the <code class="literal">model.attributes</code> property to get the <code class="literal">hash</code> attribute:</p><div><pre class="programlisting">var jsonData = _.clone(this.attributes);</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>It is better not to use the <code class="literal">model.attributes</code> property directly. Manipulating the <code class="literal">hash</code> attribute directly can potentially cause some unexpected consequences, as the object will be passed by reference.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Understanding the relational data model</h1></div></div></div><p>All the examples we <a id="id163" class="indexterm"/>have gone through so far have used simple models to represent data. However, in any nontrivial application, the data structure is much more complex, and the relationships among entities are multi-relational. For any medium- or large-level application, there will be lots of one-to-one, one-to-many, and many-to-one relations. Keeping these relations synced with the server often becomes a tedious job, especially while saving or fetching data with multiple requests.</p><p>While researching for this book, I found that most Backbone developers, at some point of their learning phase, have faced issues with nested models and collections. Fortunately, there is a great plugin<a id="id164" class="indexterm"/> known as <a id="id165" class="indexterm"/>Backbone-relational (<a class="ulink" href="http://backbonerelational.org/">http://backbonerelational.org/</a>), developed by Paul Uithol, which minimizes the Backbone model hand-holding by syncing the model and all its related models with a single <code class="literal">save()</code> or <code class="literal">fetch()</code> method. It provides some great features<a id="id166" class="indexterm"/> that include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Bidirectional relations that notify related models of changes through events</li><li class="listitem" style="list-style-type: disc">Control over how relations are serialized</li><li class="listitem" style="list-style-type: disc">Automatic conversion of nested objects in a model's attributes into model instances</li><li class="listitem" style="list-style-type: disc">Easy retrieval of a set of related models</li><li class="listitem" style="list-style-type: disc">Determining the type of <code class="literal">HasMany</code> collections</li></ul></div><p>We will look into <a id="id167" class="indexterm"/>a simple example with company-employee relationship to explain the concept of the Backbone-relational plugin:</p><div><pre class="programlisting">var Company = Backbone.RelationalModel.extend({
  defaults: {
    name: ''
  },
  relations: [{
    // 'type' can be HasOne or HasMany 
    // or a direct reference to a relation
    type: Backbone.HasMany,

    // 'key' refer to an attribute name of the related model
    key: 'employees',
    relatedModel: 'Employee',

    // a collection of the related models
    collectionType: 'Employees',

    // defines the reverse relation with this model
    reverseRelation: {
      key: 'worksIn',
      includeInJSON: 'id'
      // 'relatedModel' is automatically set to 'Company'; 
      // the 'relationType' to 'HasOne'.
    }
  }]
});

var Employee = Backbone.RelationalModel.extend({
  defaults: {
    name: '',
    worksIn: null
  }
});

var Employees = Backbone.Collection.extend({
  model: Employee
});</pre></div><p>Here we created a company-employees one-to-many relationship. In the company model configuration, you need<a id="id168" class="indexterm"/> to define the relation type that is used to create a <code class="literal">Backbone.Relation</code> instance at first. The <code class="literal">type</code> relation property can be <code class="literal">Backbone.HasMany</code>, <code class="literal">Backbone.HasOne</code>, or a direct reference to a particular relation instance. You also need to specify the attribute of the company model that holds all the employee models. Once the basic configuration is done, we will define the <code class="literal">Employee</code> model and <code class="literal">Employees</code> collection. Let's test the relationship with some dummy data now:</p><div><pre class="programlisting">var innofied = new Company({
  name: 'Innofied'
});

var john = new Employee({
  name: 'John Doe',
  worksIn: innofied
});

var swarnendu = new Employee({
  name: 'Swarnendu De',
  worksIn: innofied
});

// 'employees' in 'innofied' now contains 
// 'John Doe and Swarnendu De'
alert(innofied.get('employees').pluck('name'));</pre></div><p>We've now created a fully-managed relation. When you add or remove models from <code class="literal">innofied.employees</code> or update <code class="literal">employee.worksIn</code>, the other side of the relation automatically gets updated.</p><p>The previous mentioned code is just an elementary example of the Backbone-relational model. Once you go through their complete documentation, you will find that the plugin provides many features that can enhance application development process to a great extent.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>This chapter discussed some basic problems around Backbone models that lots of developers face, and described how we can approach these issues in our projects. We learned about basic data validation as well as getting all the error messages together from our validate method. Also, we saw how using the Backbone validation plugin can reduce our efforts when performing data validation by providing lots of inbuilt features.</p><p>If the data sent from the server has a different format from what a model expects, we now know how to override the <code class="literal">parse()</code> method to overcome this issue. Similarly, we override the <code class="literal">toJSON()</code> method to change the format of data that will be passed to the server.</p><p>For most nontrivial applications, a nested model relationship is an essential requirement, and the Backbone-relational plugin can provide a ready-made solution for that. The plugin is widely accepted by the Backbone community and a lot of projects are currently using it successfully.</p><p>There are some important topics to cover when working with models, such as collections, events, and sync. We are going to cover each of these points separately in the following chapters. The events and sync functionality is discussed in detail in <a class="link" href="ch06.html" title="Chapter 6. Working with Events, Sync, and Storage">Chapter 6</a>, <em>Working with Events, Sync, and Storage</em>. In the next chapter, we will discuss the different functionalities of Backbone collections, basic and multiple sorting, filtering mechanisms, and collections with multiple model types.</p></div></body></html>