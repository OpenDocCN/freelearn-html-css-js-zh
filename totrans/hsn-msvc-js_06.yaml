- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implemented our first microservice in the previous chapter, but to demonstrate
    microservice communication, we need to run at least one more service. To understand
    the beauty of JavaScript in microservice development, we will use a different
    Node.js framework called NestJS for the current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, microservice architecture consists of multiple services,
    and one of the complexities that this approach brings with it is communication.
    We already know that microservices, while offering advantages in scalability and
    development, introduce a layer of complexity in communication compared to monolithic
    applications. Unlike monolithic applications, where everything runs together,
    microservices communicate over a network. This introduces challenges in *latency*
    (the time it takes for a request to be processed and a response to be received),
    *reliability* (since network issues can disrupt communication), and *security*
    (since you need to secure communication between services).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into details of synchronous communication between
    microservices in practice and learn the use cases of synchronous communication
    between services.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements for the transaction microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to develop the transaction microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on transaction microservice development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing synchronous communication with the account microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop and test the second microservice, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IDE (we prefer **Visual Studio Code** (**VS Code**))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to download our repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)
    and open the `Ch06` folder to easily follow our code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements for the transaction microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything starts from the requirements. Software requirements are basically
    instructions that tell programmers exactly what a software program needs to do.
    They’re like a recipe for the program, outlining the ingredients (features) and
    steps (functions) needed. Before starting our development, we need to understand
    our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system consists of two main microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction microservice**: This microservice will be responsible for processing
    transactions. It will receive transaction information, validate the account associated
    with the transaction, and process the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Account microservice**: This microservice will provide account information
    and validation functionality. We implemented this service in [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074).
    It is responsible for verifying if an account exists and is in good standing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transaction microservice will communicate with the account microservice
    to validate the provided `accountId` value. The account microservice will verify
    if the `accountId` value exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transaction should be successful only if the account exists and is in an
    *active* or a *new* state. For other states, we should add a new row to the transaction
    service with the *FAILED* state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Communication between transaction and account microservices](img/B09148_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Communication between transaction and account microservices'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to develop our transaction microservice. After having a proper
    working microservice, we will create synchronous communication between transactions
    and the previously built account microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Tools to develop the transaction microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build our second microservice, we plan to use completely different tools
    to show that we don’t depend on concrete tools and technologies even in JavaScript.
    You can develop the same microservice using different technologies, and having
    multiple ones in your arsenal allows you to select the optimal stack tools for
    your development.
  prefs: []
  type: TYPE_NORMAL
- en: NestJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a Node.js framework, we plan to use NestJS. The official page describes it
    as “*A progressive Node.js framework for building efficient, reliable and scalable
    server-side applications*.” Although Express.js has been the de facto standard
    for building web applications with a combination of Node.js, it doesn’t force
    you to use Express.js for all types of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first – NestJS is another Node.js framework. Check out [*Chapter
    4*](B09148_04.xhtml#_idTextAnchor056)’s *Node.js frameworks* section to learn
    more about NestJS. Here’s a summary of what it offers:'
  prefs: []
  type: TYPE_NORMAL
- en: It promotes a **modular architecture** that allows you to build scalable and
    easily organizable applications. You can easily organize your application into
    modules, components, controllers, and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NestJS is built on top of **TypeScript** and uses TypeScript at its core. If
    you are a big fan of **strongly typed** tools/languages like me, then it is for
    you. Strongly typed languages enforce type safety, meaning compiler checks for
    operations. This can prevent unexpected crashes and incorrect results later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NestJS supports **validation** out of the box. It validates incoming data, which
    may be helpful when building APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing all the required applications directly to your computer is not always
    the best choice. That is why we use Docker. While directly installing applications
    isn’t inherently wrong, Docker provides a more efficient and manageable approach
    for certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker helps developers build things such as software programs more easily.
    Imagine a box that holds all the tools and parts a program needed to run. This
    box is like a Docker container. Docker lets you put your program and all its bits
    and pieces in this box so that it works the same way on any computer.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056) to learn more about
    how to set up Docker on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Prisma ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prisma is a next-generation **Object-Relational Mapper** (**ORM**). In the
    world of programming, an ORM acts as a bridge between two different ways of handling
    data: **object-oriented programming** (**OOP**) and relational databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prisma, as an open source ORM, that simplifies database interactions in Node.js
    applications. It’s like a set of helpful tools that take care of a lot of the
    complex stuff for you. The good news is, you don’t need to deal with pure SQL
    queries. Here’s what it offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prisma Client**: This tool automatically builds code to access your database,
    making it safe and straightforward. It even checks your code for errors as you
    write it (if you’re using TypeScript).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prisma Migrate**: This tool helps you define how your database is structured
    and keeps it up to date as your application changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prisma Studio**: This is a visual tool that lets you see and edit the information
    stored in your database directly, like a user-friendly dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, you can use PostgreSQL, MySQL, SQL Server, SQLite, MongoDB,
    and more. When your application requires migrating from one database to another
    that Prisma supports, it will not affect your project source code because Prisma
    abstracts your code from internal details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prisma Client works well with many different ways of building Node.js applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern GraphQL APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient gRPC APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any Node.js project that needs to use a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, Prisma simplifies interacting with databases in Node.js, saving you
    time and effort. It offers a variety of features to fit your project’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to develop our transaction service, and starting from the
    next section, we will dive into the details of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on transaction microservice development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way of learning from a technical book is by following its instructions.
    For all practical chapters, it is preferable to follow us along the journey and
    type every command with us. Downloading source code from the Git repository and
    investigating source code is also a good way of learning things in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting started with NestJS is easier than Express.js. It has code generation
    steps and easy-to-use packages that help you to do a fast development. If you’re
    looking for a better, modern template to get started, NestJS is one way of achieving
    it. NestJS provides a built-in command-line tool called the *Nest CLI*. It acts
    as a powerful assistant throughout your NestJS application’s lifecycle. If offers
    interesting and useful functionalities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project initialization**: Quickly set up a new NestJS project with a well-structured
    directory layout following best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development support**: Run your application in development mode for hot reloading
    and streamlined debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production build**: Bundle your application for deployment in production
    environments, optimizing it for efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code generation**: Generate various components such as controllers, services,
    modules, and more using schematics, saving you time and ensuring consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin the development process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for your project (it is `Ch06` in our Git repo).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open VS Code and open your folder from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Terminal** menu, then select **New Terminal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `npm i -g @nestjs/cli` and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the NestJS CLI is installed, we can create our project template with a
    single command. Just type `nest new transactionservice` and press *Enter* again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you encounter a `Cannot Be Loaded Because Running Scripts is Disabled on
    This System` error message while trying to run a script in Windows, follow these
    steps to resolve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Windows PowerShell**: Press *Win* + *X* and select **Windows PowerShell
    (Admin)** to open it with administrator privileges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set the execution policy**: In the PowerShell window, type the following
    command and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Run your script again**: Try running your script once more. The issue should
    now be resolved.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get a prompt that asks you to select package manager during project
    setup (*Figure 6**.2*). We have the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yarn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pnpm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our choice is `npm` for this project. It is a strong contender in the world
    of package managers, particularly for Node.js projects. It has a massive package
    registry, is the default for Node.js, and has a large community (*Figure 6**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: NestJS offers to select a package manager](img/B09148_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: NestJS offers to select a package manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve made your selection, the CLI will generate a project template
    for us (*Figure 6**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: CLI-generated folder structure for NestJS](img/B09148_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: CLI-generated folder structure for NestJS'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src` and `test` folders are not empty and contain the initial project
    skeleton (*Figure 6**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: CLI-generated src and test folders](img/B09148_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: CLI-generated src and test folders'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the generated template successfully, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `transactionservice` folder from the terminal using the `cd
    transactionservice` command. For all types of commands, we need to navigate to
    this folder to run them properly. You can simply open the `transactionservice`
    folder directly from VS Code if you do not want to type the `cd` command every
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `npm` `run start:dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command starts a special server that helps you see changes quickly. It
    watches your files closely, and if it sees anything different, it automatically
    fixes things up and refreshes the server. This means you can see your updates
    right away without needing to restart everything yourself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open your favorite browser and navigate to `http://localhost:3000` (*Figure
    6**.5*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5: Successful NestJS project run result](img/B09148_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Successful NestJS project run result'
  prefs: []
  type: TYPE_NORMAL
- en: The next subsections will help us to understand how to prepare our environment
    and build our microservice easily.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing your PostgreSQL instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PostgreSQL** is one of the best choices when it comes to storing data in
    the database. We will use Docker to containerize our database, isolating it from
    other environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your root project folder (it is `transactionservice` for us)
    and add a `docker-compose.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this empty file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We used `docker-compose.yml` in [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056)
    when we talked about installing Apache Kafka. We have a separate chapter about
    containerization, but let’s explain the file itself here for more clarity.
  prefs: []
  type: TYPE_NORMAL
- en: A `docker-compose.yml` file is a YAML configuration file used to define and
    manage multi-container Docker applications. Docker Compose is a tool that allows
    you to define services, networks, and volumes required for your application in
    a single file, making it easier to manage complex setups.
  prefs: []
  type: TYPE_NORMAL
- en: Each service represents a containerized application component.
  prefs: []
  type: TYPE_NORMAL
- en: You can define custom networks for your services to communicate with each other.
    By default, Docker Compose creates a default network for your application, but
    you can define custom networks to control communication between specific services.
  prefs: []
  type: TYPE_NORMAL
- en: You can also define named volumes or mount host directories into containers
    to persist data or share files between containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose allows you to start all your services together with a single
    command, instead of running services one by one, `docker-compose` helps you to
    spin up your entire infrastructure with a single command (`docker-compose up`)
    and manage it consistently across different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `docker-compose.yml` file defines a Docker Compose configuration for setting
    up two services: `postgres` and `pgadmin`. Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`networks`: This section within your Docker Compose YAML file defines named
    networks that can be used by your application’s services. These networks provide
    a way for containers to communicate with each other in a controlled and isolated
    manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services`: This section defines the services to be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgres`: This service uses the official PostgreSQL Docker image. It sets
    up a PostgreSQL database container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image: postgres`: Specifies the Docker image to be used for this service.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env_file`: Specifies a file from which to read environment variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment`: Sets environment variables for the PostgreSQL container, including
    username, password, and database name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Maps the container’s PostgreSQL port to a port on the host machine,
    allowing external access.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: Mounts a volume to persist PostgreSQL data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pgadmin`: This service uses the `pgAdmin` 4 Docker image to set up a web-based
    administration interface for PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image: dpage/pgadmin4`: Specifies the Docker image for `pgAdmin` 4.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env_file`: Similar to the `postgres` service, this specifies a file from which
    to read environment variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment`: Sets environment variables for `pgAdmin`, including default
    email, password, and PostgreSQL connection details.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Maps the container’s port `80` to a port on the host machine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`: Specifies that this service depends on the `postgres` service,
    ensuring that the PostgreSQL database is available before starting `pgAdmin`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user: root`: Specifies that the container should run as the root user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: Mounts a volume to persist `pgAdmin` data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: This section defines a named volume `postgres_data`, which is used
    by both services to persist data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, this Docker Compose configuration sets up a PostgreSQL database
    container and a `pgAdmin` container, providing a convenient way to manage and
    interact with the PostgreSQL database using a web-based interface. To run your
    `docker-compose` file, just navigate to the folder of it and type `docker-compose
    up -d` from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of directly adding credentials/values to the `docker-compose` file,
    we can specify it from a `.env` file (we have already talked about this file),
    and Docker can read the required data from environment variables. Just create
    a `.env` file inside your main folder (it is the `transactionservice` folder for
    us) and add the missing configuration for Docker to run successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now have our PostgreSQL database up and running. In most cases, developers
    prefer not to directly interact with databases using SQL queries. Not all developers
    have a solid understanding of SQL, and even so, using pure SQL queries to manipulate
    to database in most cases is not a good choice nowadays. Instead, we have various
    packages available that abstract away the complexity of raw SQL, enabling us to
    create beautiful applications without needing deep expertise in SQL. One of these
    packages is Prisma. As we mentioned before, Prisma is an open source ORM that
    automates and abstracts most of the operations you need to do when you deal with
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: To start work with Prisma, we need a *CLI*. Prisma CLI is a combination of tools
    that help us migrate, seed, and do additional database-oriented operations easily.
    You just need to run the `npm install prisma -D` command from the terminal. After
    executing the command, `npm` should successfully install Prisma CLI as a dev dependency.
    You can check `package.json`’s `devDependencies` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Prisma CLI, it is time to install Prisma itself. The `npx prisma init`
    command handles the initialization of the Prisma package. It will create an additional
    folder called `prisma` with a `schema.prisma` file and a `.env` file. In our case,
    we already have a `.env` file, so running the preceding command will end up updating
    our existing `.env` file. Open your `.env` file, and at the end of the file, update
    the value of `DATABASE_URL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the heart of your Prisma setup lies the `schema.prisma` file. This file
    uses **Prisma Schema Language** (**PSL**), a declarative approach to defining
    your database structure. It acts as the central configuration for Prisma, specifying
    both your database connection and the generation of the Prisma Client API. The
    following code demonstrates how to define a simple schema file for Prisma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `schema.prisma` file, written in PSL, acts as your database blueprint with
    three key sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generator`: This section configures the Prisma Client generator. The Prisma
    Client, a powerful API, is then generated to help you access your database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datasource`: Here, you define the database connection details. This includes
    the database provider and the connection string, often leveraging the `DATABASE_URL`
    environment variable for convenience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model:` This is where the heart of your database schema lies. You define the
    structure of your data by specifying tables and their corresponding fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section describes how to model your data inside the `schema.prisma`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `schema.prisma` file is the main place where we need to add our models.
    Modeling is a special language over SQL. It isolates you from the internals of
    SQL and provides data in a more human-readable language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `schema.prisma` file under the `prisma` folder and add the following
    model structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The provided code defines a Prisma model named `Transaction` and an `enum` named
    `Status` within your NestJS application schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of each section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This field represents the unique identifier for each transaction. It’s
    of type `Int` and is automatically marked as the primary key with the `@id` directive.
    Additionally, `@default(autoincrement())` ensures a new, unique ID is generated
    for each transaction automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: This field defines the current state of the transaction. It’s of
    type `Status`, which will reference `Status` `Enumeration(enum Status)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accountId`: This field stores the identifier for the associated account involved
    in the transaction. It’s of type `String` and uses `@default(uuid())` to generate
    a **universally unique identifier** (**UUID**) by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This optional field allows for storing a brief description of
    the transaction. It’s of type `String?`, indicating it can be `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createdAt`: This field captures the timestamp of when the transaction was
    created. It’s of type `DateTime` and uses `@default(now())` to automatically set
    the creation time to the current moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updatedAt`: This field is automatically updated whenever the transaction record
    is modified. It’s of type `DateTime` and uses the `@updatedAt` directive to achieve
    this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK – but how to generate SQL based on the model we defined in `schema.prisma`?
  prefs: []
  type: TYPE_NORMAL
- en: Run `npx prisma migrate dev --name init` from the command line (VS Code terminal)
    to start the migration journey. In the context of NestJS and Prisma, **migration**
    refers to a process that manages changes to your database schema over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npx prisma migrate dev`: This command invokes the Prisma migration tool in
    development mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--name init`: This option specifies the name of the new migration. Here, it’s
    set to `init`, likely signifying the initial setup of your database schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By running this command, you’re essentially creating a starting point for managing
    your database schema changes using Prisma migrations. As you make modifications
    to your `schema.prisma` file, Prisma will automatically generate new migrations
    to reflect those changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will end up creating a `migrations` folder with a `migration.sql`
    file (*Figure 6**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Automatically generated migration structure](img/B09148_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Automatically generated migration structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the generated `migration.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should have tables with the name `Transaction` and `_prisma_migrations`
    in your database. It may take a few seconds for Docker to set up the services,
    so a brief wait might be necessary. To check this, let’s do the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Docker Desktop and ensure all services are running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `postgres` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `172.26.0.2`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:5050/browser/` from your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Servers**, then select **Register** | **Server** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the `localhost` for its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `172.26.0.2` for us)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`5432`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tservice_db`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`postgres`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`postgres`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7: Server registration window for postgres](img/B09148_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Server registration window for postgres'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Save** button, and your server connection should be successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, expand `localhost` (or your name) | `tservice_db` | **Schemas** | **Public**
    | **Tables** (*Figure 6**.8*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8: postgres tables after migration via Prisma](img/B09148_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: postgres tables after migration via Prisma'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have locally installed `pgAdmin`, to connect to your Docker `postgres`
    instance, just enter the following to the server registration window for `postgres`
    (*Figure 6**.7*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`localhost`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5438`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tservice_db`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgres`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgres`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the **Save** button, and your server connection should be successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `_prisma_migrations` table you see when using NestJS and Prisma ORM plays
    a crucial role in managing database schema changes. It has the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracks applied database migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures migrations are applied only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintains consistency between your Prisma schema and the actual database structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time you run a Prisma migration, a new entry is added to the `_prisma_migrations`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: When Prisma needs to apply migrations, it checks the `_prisma_migrations` table
    to see which migrations have already been run based on the unique hash.
  prefs: []
  type: TYPE_NORMAL
- en: This prevents applying the same migration multiple times, potentially corrupting
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the `_prisma_migrations` table manually can lead to inconsistencies
    and errors. Don’t edit, delete, or modify it. This table is essential for Prisma
    to manage migrations effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, the `_prisma_migrations` table acts as a logbook for your
    database schema changes, ensuring a smooth and controlled migration process.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding test data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seeding data involves populating your database with an initial set of data.
    If you want your database to have initial data before running your application,
    you may apply seeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `seed.ts` file under the `prisma` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to `package.json` and add the following after `devDependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the terminal window and type the `npx prisma db seed` command. You
    should see a message that indicates a successful operation (*Figure 6**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Executing seed](img/B09148_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Executing seed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Transaction` table using `PgAdmin`, and you’ll see your first successfully
    inserted row (*Figure 6**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Transaction table after seed](img/B09148_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Transaction table after seed'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to explain what we have inserted into our `seed.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrismaClient from @prisma/client`: This line imports the necessary class to
    interact with our database schema using Prisma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const prismaClient = new PrismaClient()`: Here, we create an instance of the
    `PrismaClient` class, which will be used to perform database operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async function seedData() { ... }`: This function is the heart of the script
    and is marked `async` because it includes asynchronous operations that involve
    interacting with the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const first_transaction = await prismaClient.transaction.upsert({ ... })`:
    This line performs the core seeding operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prismaClient.transaction`: This part accesses the transaction model of your
    Prisma schema through the initialized client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.upsert({ ... }):` The `upsert` method is a convenient way to create or update
    a record in the database. It checks for existing data based on the provided `where`
    clause and performs the appropriate action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a record with `id: 1` (assuming your schema has an ID field) already exists,
    the following happens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` object (empty here) would be used to update the existing record
    (but since it’s empty, no update happens) if a record with `id:` `1` exists.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create` object defines the data for the new transaction record if a record
    with an ID doesn’t exist.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create Object (Seed Data)`: This object defines the details of the dummy transaction
    to be created.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id: 1`: Sets the ID of the transaction to 1 (replace with a unique value if
    needed).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status: ''CREATED''`: Sets the initial status of the transaction to `CREATED`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accountId: ''662c081370bd2ba6b5f04e94''`: Assigns an account ID to the transaction
    (you can use any ID).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description: ''simple transaction''`: Provides a descriptive text for the
    transaction.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To apply business rules to our application, we need to add an extra layer over
    a database, and it is going to be our service layer. The next section will introduce
    a service layer for the transaction database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the transaction service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are done with the database. As a classical development style, it is time
    to create a service over our database. Creating a service layer is simple with
    NestJS, especially if you deal with Prisma ORM.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create our module using the `npx nest generate module` `prisma`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This Prisma CLI command should generate a new folder called `prisma` and should
    generate a `prisma.module.ts` file under this folder. This command also will affect
    your `app.module.js` file under the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more command to run to generate our service files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command will create `prisma.service.ts,prisma.service.spec.ts` files under
    `src/prisma` and update the `prisma.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you can remove all files that have `.spec.ts` extensions
    from the project. These files contain unit tests for the application’s components,
    typically services and controllers. We have a separate chapter to work with unit
    tests; for the chapter’s simplicity, we don’t need them. For now, replace the
    content of `prisma.service.ts` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have a straightforward implementation for the `prisma` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Injectable } from ''@nestjs/common'';`: This line imports the `Injectable`
    decorator from the `@nestjs/common` module. This decorator marks the class as
    a NestJS injectable service, making it available for **dependency injection**
    (**DI**) in other parts of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import { PrismaClient } from ''@prisma/client'';`: This line imports the `PrismaClient`
    class from the `@prisma/client` package. This class provides an interface for
    interacting with your database using Prisma queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Injectable()`: This decorator applied to the class declaration marks it as
    a NestJS injectable service. NestJS will manage the lifecycle of this service
    and provide it to other components that require database access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export class PrismaService extends PrismaClient {}`: This line defines the
    `PrismaService` class. It inherits from the `PrismaClient` class, giving it access
    to all the database interaction methods provided by Prisma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, this code creates a service specifically for interacting with our
    database through Prisma. This service can then be injected into other parts of
    our application (such as controllers) to perform database operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `prisma.service.ts` file acts as a wrapper over the Prisma client. It is
    an injectable element that we can use to inject it into modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our `prisma.module.ts` file to have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To make the Prisma service accessible throughout your NestJS application, you’ll
    need to create a dedicated module. This module will import the `PrismaService`
    class and provide it for injection into other modules or components. That is the
    reason why we have a `prisma.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it is popular to use a UI for APIs, and it allows us to document and
    easily use endpoints. One of the packages that allows us to do it is Swagger.
    The next section explains how to integrate Swagger for our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To have visible documentation and visual usage for our APIs, we will configure
    Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `src/main.ts` and update its content with the following to integrate Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand this code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NestFactory` from `@nestjs/core`: This import provides the core functionality
    for creating a NestJS application instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppModule` from `./app.module`: This imports your main application module,
    where all the necessary components and services of your NestJS application are
    defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwaggerModule` and `DocumentBuilder` from `@nestjs/swagger`: These imports
    are used for integrating Swagger documentation with your NestJS application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bootstrap function (`async`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is marked as `async` because it involves asynchronous operations
    such as creating an application instance and listening for incoming requests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as the entry point for your NestJS application and is typically called
    at the bottom of your `main.ts` file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const app = await NestFactory.create(AppModule);`: This line creates a new
    NestJS application instance using the `AppModule` class. The `await` keyword signifies
    that the function will wait for the application creation to complete before proceeding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const config = new DocumentBuilder()...`: Here, you’re configuring the Swagger
    documentation using the `DocumentBuilder` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.setTitle(''Transaction API'')`: Sets the title of your API documentation
    to `Transaction API`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.setDescription(''Transaction API description'')`: Provides a brief description
    of your API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.setVersion(''1.0'')`: Sets the version of your API to `1.0`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.build()`: Builds the Swagger document based on the provided configuration
    options.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const document = SwaggerModule.createDocument(app, config);`: This line generates
    the actual Swagger document using the `SwaggerModule` class. It takes the NestJS
    application instance (`app`) and the built configuration (`config`) as arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwaggerModule.setup(''api'', app, document);`: This code integrates the Swagger
    documentation with your application. It sets the path prefix for the documentation
    to `api` (for example, `http://localhost:3000/api`) and associates the generated
    document (`document`) with the application (`app`). This allows developers to
    access the interactive Swagger documentation at the specified URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`await app.listen(3000);`: This line starts the NestJS application and makes
    it listen for incoming requests on port `3000`. You can change this port number
    to your desired option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall, this `main.ts` file performs two crucial tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppModule` class and starts the server listening for requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrates Swagger documentation**: It configures and provides Swagger documentation
    for your API, allowing developers to explore your API endpoints, understand data
    models, and interact with your API using the interactive interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigate to `localhost:3000/api`, and you should see the Swagger page (*Figure
    6**.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Swagger UI](img/B09148_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Swagger UI'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll realize, we don’t have any endpoints yet; the next section talks about
    creating them.
  prefs: []
  type: TYPE_NORMAL
- en: Working on transaction implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start to work with transactions, first, we need to generate resources. To
    implement **create, read, update, and delete** (**CRUD**) operations for transactions,
    we’ll first generate REST resources, creating boilerplate code for the module,
    controller, service, and **Data Transfer** **Object** (**DTO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `npx nest generate resource transaction` command to generate resources
    for a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Selecting a transport layer](img/B09148_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Selecting a transport layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will ask you which transport layer to choose (*Figure 6**.12*). Select `REST
    API` and hit *Enter*. As the next question, you will be asked `Would you like
    to generate CRUD entry points?.` Select `Y`, and the following files should be
    generated (*Figure 6**.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: CRUD generation for transaction](img/B09148_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: CRUD generation for transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `npm run start:dev` and navigate to `localhost:3000/api`. You should get
    a page that stores transaction boilerplate endpoints (*Figure 6**.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: Swagger UI for transaction](img/B09148_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Swagger UI for transaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we don’t need to implement all these CRUD endpoints. We need the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all transactions (`GET /transaction`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get transaction by ID (`GET /``transaction/{id}` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create transaction (`POST /transaction`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s remove the rest of the unused code blocks and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transaction/transaction.controller.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transaction/dto/update-transaction.dto.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transaction/transaction.service.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the following code blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove` and `update` functions from `transaction.service.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` and `update` functions from `transaction.controller.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you haven’t removed them yet, remove the following files too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.controller.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.module.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.service.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update `main.ts` to work with `TransactionModule`, not `AppModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll end up with three endpoints (*Figure 6**.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Final transaction endpoints](img/B09148_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Final transaction endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: 'After having generated REST resources, we’re ready to integrate our `PrismaClient`
    class. Having this client will help us to interact with the database easily. First,
    let’s update our `transaction.module.ts` file to have `PrismaModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Having `PrismaModule` in the `imports` array will make `PrismaService` available
    to `TransactionService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `transaction.service.ts` file and make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The transaction controller file (`transaction.controller.ts`) already has `transactionservice`
    as an injected service. It has all the required contracts to request the transaction
    service and retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `transaction.controller.ts` and have a look at the `findAll()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to `POST` and the single `GET` request. The only thing we
    need to do is to call Prisma to provide all the data when we call `transactionservice`’s
    `findAll()` method. For that reason, open `transaction.service.ts` and update
    the `findAll()` method content (*Figure 6**.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using `findMany()`, we’re able to call all transaction data from the transaction
    table via Prisma. Let’s run our application (run `npm run start:dev`) and run
    our endpoint from Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GET /transaction` from Swagger UI, click the **Try it out** button, and
    click the **Execute** button. Now, you should see only the data we migrated to
    our database when we talked about seeding data (*Figure 6**.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: Response for “Get all transactions”](img/B09148_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Response for “Get all transactions”'
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify your `GET` request by ID endpoint for it to work properly, open `transaction.service.ts`
    and replace the `findOne()` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Everything is really simple when it comes to retrieving data, but how about
    creating it?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a `POST` endpoint in `transaction.controller.ts` that was automatically
    generated when we generated the file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When our resources were created, `CreateTransactionDTO` was also generated;
    you can find it inside the `src/transaction/dto` folder. Surprisingly, it has
    only one class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should manually add the required properties into the class. Our DTOs just
    transfer data from the source to the destination. DTOs are used in various programming
    languages and frameworks, not specific to NestJS. They act as a way to efficiently
    transfer data between different layers of an application. We also have a validation
    possibility before getting data from the user and creating DTOs based on this
    data. That is why we will use the `class-validator` package to validate our data.
    To install it, run the following command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `create-transaction.dto.ts` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Update your `POST` method (`transaction.controller.ts`) to accept `CreateTransactionDTO`
    and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run our application. From Swagger UI, open `POST/ transaction` and
    provide the following JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the **Execute** button, and here we are (*Figure 6**.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: Successful transaction creation](img/B09148_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Successful transaction creation'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the next section, we will explore how to establish communication
    between the transaction and account microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing synchronous communication with the account microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re done with the transaction service, but the only thing missing is our
    account service. The transaction service allows us to specify an `accountId` value
    and status from the payload. We need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify if the provided `accountId` exists and is in a valid state (new or active)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `accountId` is valid, then create a transaction with the `Created` status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `accountId` is invalid, then create a transaction with the `Failed` status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose here is not to fully implement the transaction domain. Of course,
    the current domain has more requirements than the previous one, but our focus
    is to practice and establish synchronous communication between the transaction
    and account services.
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked about the pros and cons of synchronous communication
    between microservices. While asynchronous communication offers many benefits for
    microservices, there are situations where synchronous communication might be a
    better fit. If the interaction between microservices requires straightforward
    logic and an immediate response, synchronous communication can be easier to implement.
    Also, it is beneficial to use it for user interactions where you need to display
    information or confirm an action right away. It creates tight coupling, but in
    some cases, microservices might be tightly coupled and rely heavily on each other’s
    results to complete a task. Synchronous communication allows for a more controlled
    flow, ensuring one service doesn’t proceed until the other provides the necessary
    information. Synchronous communication can be easier to debug at times. Since
    the entire interaction happens in one go, tracing errors and understanding the
    flow of data is more straightforward. This can be helpful during development or
    troubleshooting specific issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To communicate with the account service, we need an HTTP client package. One
    of the most used packages is `axios`. Let’s install it using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to import `HttpModule` from `axios` and import it from `transaction.module.ts`.
    Here is the final code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing `HttpModule` from `transaction.module.ts`, we’re able to use
    `HttpService` from `axios` in `transaction.service.ts`. Let’s import and inject
    it as a service for the transaction service. Open `transaction.service.ts` and
    change the code to have the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As our business requires, we need to remove the status property from `createTransactionDto`
    because, depending on the account service, we should internally define the status
    of the transaction. That is why we’re going to remove the status from `src/transaction/dto/create-transaction.dto`.
    The following is the final version of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, let’s open our `transaction.service.ts` file again and change our
    *create* functionality. After injecting `httpService`, we should be able to make
    a request to any service and get a response back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we plan to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a request to the account service’s `http://url/v1/accounts/{account_id}`
    endpoint and account information based on the provided ID from the endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the given account by `accountId` doesn’t exist, we throw an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the account exists, and its status is either `'new'` or `'active'`, then
    the transaction should be created with a `'``CREATED'` status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the account exists, and its status is neither `'new'` nor `'active'`, we
    should create a transaction with a `'``FAILED'` status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is simply it. Open `transaction.service.ts` and update it with the following
    code lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is to configure **cross-origin resource sharing**
    (**CORS**) in the account service. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your account service from VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select **Terminal** | **New Terminal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install cors` to install the `cors` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `app.js` and add the following code after the `app` object is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final code in `app.js` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running our application, make sure of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your account service lives in `localhost:3001`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The account service has at least one piece of valid account information in your
    table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that Docker is running and the `postgres` container is active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go to our account service and run it (for more details, check [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074)).
    Run our newly created transaction service using `npm run start:dev`. Open your
    favorite browser, and navigate to `http://localhost:3000/api`. Open `POST /transaction`
    and add the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accountId` value you provided from the payload should exist in the account
    service to have a successful operation. In the case of a successful request, you
    will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the service is not available and the account doesn’t exist, you will get
    errors. We didn’t cover exception handling in this chapter, but we’ll learn about
    it in our upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another microservice journey ends here. The main points in this chapter were
    creating a second microservice and establishing synchronous communication between
    microservices. We started our chapter with business requirements. After getting
    a clear understanding of what we should do, we started to introduce main stack
    tools to develop our transaction microservice. We didn’t use the tools we used
    before to develop our account service. JavaScript has really rich tools and frameworks
    to use when it comes to developing microservices. To demonstrate the beauty of
    having multiple tools, we used NestJS with some popular packages such as Prisma
    and Axios. In the end, we established communication with an already existing microservice
    (the account microservice) using a synchronous communication model. Of course,
    we still missed out a lot. We didn’t cover exception handling, resiliency, and
    a lot of other interesting topics that we plan to introduce in our upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B09148_07.xhtml#_idTextAnchor121) explores how to implement asynchronous
    communication in JavaScript microservices using Apache Kafka and NestJS, focusing
    on building scalable systems, configuring Kafka, and adapting services like transaction
    and account services for asynchronous messaging.'
  prefs: []
  type: TYPE_NORMAL
