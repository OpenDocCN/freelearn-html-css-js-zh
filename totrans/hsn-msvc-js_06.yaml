- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Synchronous Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步微服务
- en: We implemented our first microservice in the previous chapter, but to demonstrate
    microservice communication, we need to run at least one more service. To understand
    the beauty of JavaScript in microservice development, we will use a different
    Node.js framework called NestJS for the current chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章实现了我们的第一个微服务，但为了演示微服务通信，我们需要运行至少一个额外的服务。为了展示JavaScript在微服务开发中的美感，我们将使用不同的Node.js框架NestJS来完成本章。
- en: As we discussed earlier, microservice architecture consists of multiple services,
    and one of the complexities that this approach brings with it is communication.
    We already know that microservices, while offering advantages in scalability and
    development, introduce a layer of complexity in communication compared to monolithic
    applications. Unlike monolithic applications, where everything runs together,
    microservices communicate over a network. This introduces challenges in *latency*
    (the time it takes for a request to be processed and a response to be received),
    *reliability* (since network issues can disrupt communication), and *security*
    (since you need to secure communication between services).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，微服务架构由多个服务组成，这种方法带来的复杂性之一是通信。我们已经知道，虽然微服务在可扩展性和开发方面提供了优势，但与单体应用相比，它们在通信方面引入了额外的复杂性。与所有内容都在一起运行的单体应用不同，微服务通过网络进行通信。这引入了*延迟*（请求处理和响应接收所需的时间）、*可靠性*（因为网络问题可能会中断通信）和*安全性*（因为您需要确保服务之间的通信安全）的挑战。
- en: In this chapter, we will delve into details of synchronous communication between
    microservices in practice and learn the use cases of synchronous communication
    between services.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解实践中微服务之间的同步通信的细节，并学习服务之间同步通信的用例。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding the requirements for the transaction microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事务微服务的要求
- en: Tools to develop the transaction microservice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发事务微服务的工具
- en: Hands-on transaction microservice development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践事务微服务开发
- en: Establishing synchronous communication with the account microservice
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立与账户微服务的同步通信
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: 'To develop and test the second microservice, we need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发和测试第二个微服务，我们需要以下内容：
- en: IDE (we prefer **Visual Studio Code** (**VS Code**))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE（我们更喜欢**Visual Studio Code**（**VS Code**））
- en: Postman
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman
- en: Browser of your choice
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您选择的浏览器
- en: It is recommended to download our repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)
    and open the `Ch06` folder to easily follow our code snippets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您从[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)下载我们的仓库，并打开`Ch06`文件夹，以便轻松跟随我们的代码片段。
- en: Understanding the requirements for the transaction microservice
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事务微服务的要求
- en: Everything starts from the requirements. Software requirements are basically
    instructions that tell programmers exactly what a software program needs to do.
    They’re like a recipe for the program, outlining the ingredients (features) and
    steps (functions) needed. Before starting our development, we need to understand
    our requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都从需求开始。软件需求基本上是告诉程序员软件程序需要做什么的指令。它们就像程序的食谱，概述了所需的成分（功能）和步骤（功能）。在我们开始开发之前，我们需要了解我们的需求。
- en: 'The system consists of two main microservices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由两个主要微服务组成：
- en: '**Transaction microservice**: This microservice will be responsible for processing
    transactions. It will receive transaction information, validate the account associated
    with the transaction, and process the transaction.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务微服务**：这个微服务将负责处理事务。它将接收事务信息，验证与事务关联的账户，并处理事务。'
- en: '**Account microservice**: This microservice will provide account information
    and validation functionality. We implemented this service in [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074).
    It is responsible for verifying if an account exists and is in good standing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户微服务**：这个微服务将提供账户信息和验证功能。我们在[*第五章*](B09148_05.xhtml#_idTextAnchor074)中实现了这个服务。它负责验证账户是否存在且状态良好。'
- en: The transaction microservice will communicate with the account microservice
    to validate the provided `accountId` value. The account microservice will verify
    if the `accountId` value exists.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 交易微服务将与账户微服务通信，以验证提供的 `accountId` 值。账户微服务将验证 `accountId` 值是否存在。
- en: 'The transaction should be successful only if the account exists and is in an
    *active* or a *new* state. For other states, we should add a new row to the transaction
    service with the *FAILED* state:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当账户存在并且处于 *活动* 或 *新* 状态时，交易才应该是成功的。对于其他状态，我们应该在交易服务中添加一个新的条目，带有 *失败* 状态：
- en: '![Figure 6.1: Communication between transaction and account microservices](img/B09148_06_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：交易微服务和账户微服务之间的通信](img/B09148_06_001.jpg)'
- en: 'Figure 6.1: Communication between transaction and account microservices'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：交易微服务和账户微服务之间的通信
- en: First, we need to develop our transaction microservice. After having a proper
    working microservice, we will create synchronous communication between transactions
    and the previously built account microservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要开发我们的交易微服务。在拥有一个正常工作的微服务之后，我们将创建交易和之前构建的账户微服务之间的同步通信。
- en: Tools to develop the transaction microservice
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发交易微服务的工具
- en: To build our second microservice, we plan to use completely different tools
    to show that we don’t depend on concrete tools and technologies even in JavaScript.
    You can develop the same microservice using different technologies, and having
    multiple ones in your arsenal allows you to select the optimal stack tools for
    your development.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的第二个微服务，我们计划使用完全不同的工具来展示我们即使在 JavaScript 中也不依赖于具体的工具和技术。你可以使用不同的技术来开发相同的微服务，拥有多个技术选项允许你为开发选择最佳的堆栈工具。
- en: NestJS
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NestJS
- en: As a Node.js framework, we plan to use NestJS. The official page describes it
    as “*A progressive Node.js framework for building efficient, reliable and scalable
    server-side applications*.” Although Express.js has been the de facto standard
    for building web applications with a combination of Node.js, it doesn’t force
    you to use Express.js for all types of web applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Node.js 框架，我们计划使用 NestJS。官方页面将其描述为“*一个用于构建高效、可靠和可扩展的服务器端应用的渐进式 Node.js 框架*。”尽管
    Express.js 已经成为使用 Node.js 构建网络应用的既定标准，但它并不强迫你在所有类型的网络应用中使用 Express.js。
- en: 'First things first – NestJS is another Node.js framework. Check out [*Chapter
    4*](B09148_04.xhtml#_idTextAnchor056)’s *Node.js frameworks* section to learn
    more about NestJS. Here’s a summary of what it offers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先——NestJS 是另一个 Node.js 框架。查看 [*第 4 章*](B09148_04.xhtml#_idTextAnchor056) 的
    *Node.js 框架* 部分，了解更多关于 NestJS 的信息。以下是它提供的一些总结：
- en: It promotes a **modular architecture** that allows you to build scalable and
    easily organizable applications. You can easily organize your application into
    modules, components, controllers, and services.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它推广了一种 **模块化架构**，允许你构建可扩展且易于组织的应用程序。你可以轻松地将你的应用程序组织成模块、组件、控制器和服务。
- en: NestJS is built on top of **TypeScript** and uses TypeScript at its core. If
    you are a big fan of **strongly typed** tools/languages like me, then it is for
    you. Strongly typed languages enforce type safety, meaning compiler checks for
    operations. This can prevent unexpected crashes and incorrect results later.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NestJS 是基于 **TypeScript** 构建的，并且在其核心使用 TypeScript。如果你像我一样是 **强类型** 工具/语言的忠实粉丝，那么它非常适合你。强类型语言强制执行类型安全，这意味着编译器会检查操作。这可以防止意外的崩溃和后续的不正确结果。
- en: NestJS supports **validation** out of the box. It validates incoming data, which
    may be helpful when building APIs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NestJS 默认支持 **验证**。它验证传入的数据，这在构建 API 时可能很有帮助。
- en: Installing all the required applications directly to your computer is not always
    the best choice. That is why we use Docker. While directly installing applications
    isn’t inherently wrong, Docker provides a more efficient and manageable approach
    for certain situations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将所有必需的应用程序安装到您的计算机上并不总是最佳选择。这就是为什么我们使用 Docker。虽然直接安装应用程序本身并没有错误，但 Docker 为某些情况提供了一种更高效和可管理的解决方案。
- en: Docker
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: Docker helps developers build things such as software programs more easily.
    Imagine a box that holds all the tools and parts a program needed to run. This
    box is like a Docker container. Docker lets you put your program and all its bits
    and pieces in this box so that it works the same way on any computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 帮助开发者更轻松地构建诸如软件程序之类的东西。想象一个包含程序运行所需的所有工具和部件的盒子。这个盒子就像一个 Docker 容器。Docker
    允许你将你的程序及其所有组成部分放入这个盒子中，这样它就可以在任何计算机上以相同的方式运行。
- en: Check out [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056) to learn more about
    how to set up Docker on your computer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[*第 4 章*](B09148_04.xhtml#_idTextAnchor056)以了解如何在你的计算机上设置 Docker 的更多信息。
- en: Prisma ORM
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prisma ORM
- en: 'Prisma is a next-generation **Object-Relational Mapper** (**ORM**). In the
    world of programming, an ORM acts as a bridge between two different ways of handling
    data: **object-oriented programming** (**OOP**) and relational databases.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Prisma 是下一代 **对象关系映射器**（**ORM**）。在编程的世界里，ORM 作为两种不同数据处理方式之间的桥梁：**面向对象编程**（**OOP**）和关系数据库。
- en: 'Prisma, as an open source ORM, that simplifies database interactions in Node.js
    applications. It’s like a set of helpful tools that take care of a lot of the
    complex stuff for you. The good news is, you don’t need to deal with pure SQL
    queries. Here’s what it offers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Prisma，作为一个开源的 ORM，简化了 Node.js 应用程序中的数据库交互。它就像一套有用的工具，为你处理很多复杂的任务。好消息是，你不需要处理纯
    SQL 查询。以下是它提供的内容：
- en: '**Prisma Client**: This tool automatically builds code to access your database,
    making it safe and straightforward. It even checks your code for errors as you
    write it (if you’re using TypeScript).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prisma 客户端**：这个工具自动构建代码以访问你的数据库，使其安全且简单。它甚至在你编写代码时检查错误（如果你使用 TypeScript）。'
- en: '**Prisma Migrate**: This tool helps you define how your database is structured
    and keeps it up to date as your application changes.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prisma Migrate**：这个工具帮助你定义数据库的结构，并随着应用程序的变化保持其最新状态。'
- en: '**Prisma Studio**: This is a visual tool that lets you see and edit the information
    stored in your database directly, like a user-friendly dashboard.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prisma Studio**：这是一个可视化工具，让你可以直接查看和编辑存储在数据库中的信息，就像一个用户友好的仪表板。'
- en: Under the hood, you can use PostgreSQL, MySQL, SQL Server, SQLite, MongoDB,
    and more. When your application requires migrating from one database to another
    that Prisma supports, it will not affect your project source code because Prisma
    abstracts your code from internal details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，你可以使用 PostgreSQL、MySQL、SQL Server、SQLite、MongoDB 以及更多。当你的应用程序需要从 Prisma
    支持的数据库迁移到另一个数据库时，它不会影响你的项目源代码，因为 Prisma 将你的代码从内部细节中抽象出来。
- en: 'Prisma Client works well with many different ways of building Node.js applications:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Prisma 客户端与多种构建 Node.js 应用程序的方式兼容：
- en: Traditional REST APIs
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的 REST API
- en: Modern GraphQL APIs
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代GraphQL API
- en: Efficient gRPC APIs
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的 gRPC API
- en: Any Node.js project that needs to use a database
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何需要使用数据库的 Node.js 项目
- en: In short, Prisma simplifies interacting with databases in Node.js, saving you
    time and effort. It offers a variety of features to fit your project’s needs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Prisma 简化了 Node.js 中与数据库的交互，节省了你的时间和精力。它提供各种功能以满足你项目的需求。
- en: Now, we are ready to develop our transaction service, and starting from the
    next section, we will dive into the details of the development process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开发我们的事务服务，从下一节开始，我们将深入了解开发过程的细节。
- en: Hands-on transaction microservice development
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践事务微服务开发
- en: The best way of learning from a technical book is by following its instructions.
    For all practical chapters, it is preferable to follow us along the journey and
    type every command with us. Downloading source code from the Git repository and
    investigating source code is also a good way of learning things in practice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术书籍中学习的最佳方式是遵循其指示。对于所有实践章节，最好是跟随我们一起经历这个过程，并和我们一起输入每个命令。从 Git 仓库下载源代码并调查源代码也是实践中学习事物的好方法。
- en: 'Getting started with NestJS is easier than Express.js. It has code generation
    steps and easy-to-use packages that help you to do a fast development. If you’re
    looking for a better, modern template to get started, NestJS is one way of achieving
    it. NestJS provides a built-in command-line tool called the *Nest CLI*. It acts
    as a powerful assistant throughout your NestJS application’s lifecycle. If offers
    interesting and useful functionalities such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NestJS 开始比 Express.js 更容易。它具有代码生成步骤和易于使用的包，帮助你快速开发。如果你在寻找一个更好的、现代的模板来开始，NestJS
    是实现这一目标的一种方式。NestJS 提供了一个内置的命令行工具，称为 *Nest CLI*。它在你的 NestJS 应用程序的生命周期中充当一个强大的助手。它提供了以下有趣和有用的功能：
- en: '**Project initialization**: Quickly set up a new NestJS project with a well-structured
    directory layout following best practices.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目初始化**：快速使用遵循最佳实践的目录布局设置新的 NestJS 项目。'
- en: '**Development support**: Run your application in development mode for hot reloading
    and streamlined debugging.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发支持**：以开发模式运行你的应用程序以实现热重载和简化调试。'
- en: '**Production build**: Bundle your application for deployment in production
    environments, optimizing it for efficiency.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产构建**：将应用程序捆绑以部署到生产环境，优化其效率。'
- en: '**Code generation**: Generate various components such as controllers, services,
    modules, and more using schematics, saving you time and ensuring consistency.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码生成**：使用脚本来生成各种组件，如控制器、服务、模块等，这样可以节省您的时间并确保一致性。'
- en: 'Let’s begin the development process:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始开发过程：
- en: Create a folder for your project (it is `Ch06` in our Git repo).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的项目创建一个文件夹（在我们的 Git 仓库中是 `Ch06`）。
- en: Open VS Code and open your folder from it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 并从其中打开您的文件夹。
- en: Go to the **Terminal** menu, then select **New Terminal**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **终端** 菜单，然后选择 **新建终端**。
- en: Type `npm i -g @nestjs/cli` and hit *Enter*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm i -g @nestjs/cli` 并按 *Enter* 键。
- en: After the NestJS CLI is installed, we can create our project template with a
    single command. Just type `nest new transactionservice` and press *Enter* again.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 NestJS CLI 后，我们可以使用单个命令创建我们的项目模板。只需输入 `nest new transactionservice` 并再次按
    *Enter* 键。
- en: 'If you encounter a `Cannot Be Loaded Because Running Scripts is Disabled on
    This System` error message while trying to run a script in Windows, follow these
    steps to resolve it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试在 Windows 中运行脚本时遇到 `Cannot Be Loaded Because Running Scripts is Disabled
    on This System` 错误消息，请按照以下步骤解决：
- en: '**Open Windows PowerShell**: Press *Win* + *X* and select **Windows PowerShell
    (Admin)** to open it with administrator privileges.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打开 Windows PowerShell**：按 *Win* + *X* 并选择 **Windows PowerShell (管理员)** 以具有管理员权限打开它。'
- en: '**Set the execution policy**: In the PowerShell window, type the following
    command and press *Enter*:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置执行策略**：在 PowerShell 窗口中，输入以下命令并按 *Enter* 键：'
- en: '[PRE0]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Run your script again**: Try running your script once more. The issue should
    now be resolved.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**再次运行您的脚本**：再次尝试运行您的脚本。问题现在应该已经解决。'
- en: 'You will get a prompt that asks you to select package manager during project
    setup (*Figure 6**.2*). We have the following options:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置期间，您将得到一个提示，要求您选择包管理器（*图 6.2*）。我们有以下选项：
- en: '`npm`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm`'
- en: Yarn
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yarn
- en: Pnpm
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pnpm
- en: 'Our choice is `npm` for this project. It is a strong contender in the world
    of package managers, particularly for Node.js projects. It has a massive package
    registry, is the default for Node.js, and has a large community (*Figure 6**.2*):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 `npm` 作为这个项目的包管理器。它在包管理器世界中是一个强有力的竞争者，尤其是对于 Node.js 项目。它拥有庞大的包注册库，是 Node.js
    的默认选择，并且拥有庞大的社区（*图 6.2*）：
- en: '![Figure 6.2: NestJS offers to select a package manager](img/B09148_06_002.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：NestJS 提供选择包管理器](img/B09148_06_002.jpg)'
- en: 'Figure 6.2: NestJS offers to select a package manager'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：NestJS 提供选择包管理器
- en: 'After you’ve made your selection, the CLI will generate a project template
    for us (*Figure 6**.3*):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您做出选择后，CLI 将为我们生成一个项目模板（*图 6.3*）：
- en: '![Figure 6.3: CLI-generated folder structure for NestJS](img/B09148_06_003.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：NestJS 的 CLI 生成的文件夹结构](img/B09148_06_003.jpg)'
- en: 'Figure 6.3: CLI-generated folder structure for NestJS'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：NestJS 的 CLI 生成的文件夹结构
- en: 'The `src` and `test` folders are not empty and contain the initial project
    skeleton (*Figure 6**.4*):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 和 `test` 文件夹不为空，并包含初始项目骨架（*图 6.4*）：'
- en: '![Figure 6.4: CLI-generated src and test folders](img/B09148_06_004.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：NestJS 的 CLI 生成的 src 和 test 文件夹](img/B09148_06_004.jpg)'
- en: 'Figure 6.4: CLI-generated src and test folders'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：NestJS 的 CLI 生成的 src 和 test 文件夹
- en: 'To run the generated template successfully, take the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行生成的模板，请按照以下步骤操作：
- en: Navigate to the `transactionservice` folder from the terminal using the `cd
    transactionservice` command. For all types of commands, we need to navigate to
    this folder to run them properly. You can simply open the `transactionservice`
    folder directly from VS Code if you do not want to type the `cd` command every
    time.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cd transactionservice` 命令从终端导航到 `transactionservice` 文件夹。对于所有类型的命令，我们都需要导航到这个文件夹才能正确运行它们。如果您不想每次都输入
    `cd` 命令，可以直接从 VS Code 中打开 `transactionservice` 文件夹。
- en: Type `npm` `run start:dev`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `npm run start:dev`。
- en: This command starts a special server that helps you see changes quickly. It
    watches your files closely, and if it sees anything different, it automatically
    fixes things up and refreshes the server. This means you can see your updates
    right away without needing to restart everything yourself.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令启动一个特殊的服务器，它可以帮助您快速查看更改。它密切监视您的文件，如果它看到任何不同，它会自动修复并刷新服务器。这意味着您可以直接看到更新，而无需自己重新启动一切。
- en: 'Open your favorite browser and navigate to `http://localhost:3000` (*Figure
    6**.5*):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器并导航到 `http://localhost:3000`（*图 6.5*）：
- en: '![Figure 6.5: Successful NestJS project run result](img/B09148_06_005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：成功的 NestJS 项目运行结果](img/B09148_06_005.jpg)'
- en: 'Figure 6.5: Successful NestJS project run result'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：成功的 NestJS 项目运行结果
- en: The next subsections will help us to understand how to prepare our environment
    and build our microservice easily.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将帮助我们了解如何准备我们的环境，并轻松构建我们的微服务。
- en: Dockerizing your PostgreSQL instance
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 化你的 PostgreSQL 实例
- en: '**PostgreSQL** is one of the best choices when it comes to storing data in
    the database. We will use Docker to containerize our database, isolating it from
    other environments.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**PostgreSQL** 是在数据库中存储数据时最佳选择之一。我们将使用 Docker 来容器化我们的数据库，将其与其他环境隔离开来。'
- en: Right-click on your root project folder (it is `transactionservice` for us)
    and add a `docker-compose.yml` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击你的根项目文件夹（对于我们来说是 `transactionservice`），并添加一个 `docker-compose.yml` 文件。
- en: 'Open this empty file and add the following lines:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个空文件并添加以下行：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We used `docker-compose.yml` in [*Chapter 4*](B09148_04.xhtml#_idTextAnchor056)
    when we talked about installing Apache Kafka. We have a separate chapter about
    containerization, but let’s explain the file itself here for more clarity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论安装 Apache Kafka 时，我们使用了 `docker-compose.yml` 在 [*第 4 章*](B09148_04.xhtml#_idTextAnchor056)。我们有一个关于容器化的单独章节，但让我们在这里解释这个文件本身，以便更清晰。
- en: A `docker-compose.yml` file is a YAML configuration file used to define and
    manage multi-container Docker applications. Docker Compose is a tool that allows
    you to define services, networks, and volumes required for your application in
    a single file, making it easier to manage complex setups.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml` 文件是一个 YAML 配置文件，用于定义和管理多容器 Docker 应用程序。Docker Compose
    是一个工具，允许你在一个文件中定义应用程序所需的服务、网络和卷，这使得管理复杂的设置更加容易。'
- en: Each service represents a containerized application component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务代表一个容器化的应用程序组件。
- en: You can define custom networks for your services to communicate with each other.
    By default, Docker Compose creates a default network for your application, but
    you can define custom networks to control communication between specific services.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的服务定义自定义网络，以便它们之间进行通信。默认情况下，Docker Compose 为你的应用程序创建一个默认网络，但你也可以定义自定义网络来控制特定服务之间的通信。
- en: You can also define named volumes or mount host directories into containers
    to persist data or share files between containers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义命名卷或将主机目录挂载到容器中，以持久化数据或在不同容器之间共享文件。
- en: Docker Compose allows you to start all your services together with a single
    command, instead of running services one by one, `docker-compose` helps you to
    spin up your entire infrastructure with a single command (`docker-compose up`)
    and manage it consistently across different environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 允许你通过单个命令启动所有服务，而不是逐个运行服务，`docker-compose` 帮助你通过单个命令 (`docker-compose
    up`) 启动整个基础设施，并在不同的环境中一致地管理它。
- en: 'This `docker-compose.yml` file defines a Docker Compose configuration for setting
    up two services: `postgres` and `pgadmin`. Let’s break it down:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `docker-compose.yml` 文件定义了一个 Docker Compose 配置，用于设置两个服务：`postgres` 和 `pgadmin`。让我们来分解一下：
- en: '`networks`: This section within your Docker Compose YAML file defines named
    networks that can be used by your application’s services. These networks provide
    a way for containers to communicate with each other in a controlled and isolated
    manner.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networks`：在你的 Docker Compose YAML 文件中的此部分定义了命名网络，这些网络可以被应用程序的服务使用。这些网络提供了一种容器之间以受控和隔离的方式相互通信的方法。'
- en: '`services`: This section defines the services to be created.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`services`：此部分定义要创建的服务。'
- en: '`postgres`: This service uses the official PostgreSQL Docker image. It sets
    up a PostgreSQL database container.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres`：此服务使用官方的 PostgreSQL Docker 镜像。它设置了一个 PostgreSQL 数据库容器。'
- en: '`image: postgres`: Specifies the Docker image to be used for this service.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: postgres`：指定用于此服务要使用的 Docker 镜像。'
- en: '`env_file`: Specifies a file from which to read environment variables.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_file`：指定一个文件，从中读取环境变量。'
- en: '`environment`: Sets environment variables for the PostgreSQL container, including
    username, password, and database name.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：为 PostgreSQL 容器设置环境变量，包括用户名、密码和数据库名。'
- en: '`ports`: Maps the container’s PostgreSQL port to a port on the host machine,
    allowing external access.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：将容器的 PostgreSQL 端口映射到主机上的端口，允许外部访问。'
- en: '`volumes`: Mounts a volume to persist PostgreSQL data.'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：挂载一个卷以持久化 PostgreSQL 数据。'
- en: '`pgadmin`: This service uses the `pgAdmin` 4 Docker image to set up a web-based
    administration interface for PostgreSQL.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pgadmin`：此服务使用 `pgAdmin` 4 Docker 镜像来为 PostgreSQL 设置基于 Web 的管理界面。'
- en: '`image: dpage/pgadmin4`: Specifies the Docker image for `pgAdmin` 4.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image: dpage/pgadmin4`：指定 `pgAdmin` 4 的 Docker 镜像。'
- en: '`env_file`: Similar to the `postgres` service, this specifies a file from which
    to read environment variables.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_file`：类似于 `postgres` 服务，这指定了一个用于读取环境变量的文件。'
- en: '`environment`: Sets environment variables for `pgAdmin`, including default
    email, password, and PostgreSQL connection details.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：为 `pgAdmin` 设置环境变量，包括默认电子邮件、密码和 PostgreSQL 连接详情。'
- en: '`ports`: Maps the container’s port `80` to a port on the host machine.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：将容器的端口 `80` 映射到主机上的一个端口。'
- en: '`depends_on`: Specifies that this service depends on the `postgres` service,
    ensuring that the PostgreSQL database is available before starting `pgAdmin`.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`：指定此服务依赖于 `postgres` 服务，确保在启动 `pgAdmin` 之前 PostgreSQL 数据库可用。'
- en: '`user: root`: Specifies that the container should run as the root user.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user: root`：指定容器应以 root 用户运行。'
- en: '`volumes`: Mounts a volume to persist `pgAdmin` data.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：将卷挂载以持久化 `pgAdmin` 数据。'
- en: '`volumes`: This section defines a named volume `postgres_data`, which is used
    by both services to persist data.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：此部分定义了一个名为 `postgres_data` 的命名卷，它被两个服务用于持久化数据。'
- en: In the end, this Docker Compose configuration sets up a PostgreSQL database
    container and a `pgAdmin` container, providing a convenient way to manage and
    interact with the PostgreSQL database using a web-based interface. To run your
    `docker-compose` file, just navigate to the folder of it and type `docker-compose
    up -d` from the terminal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个 Docker Compose 配置设置了一个 PostgreSQL 数据库容器和一个 `pgAdmin` 容器，提供了一个方便的方式来使用基于
    Web 的界面管理和交互 PostgreSQL 数据库。要运行你的 `docker-compose` 文件，只需导航到该文件的文件夹，并在终端中输入 `docker-compose
    up -d`。
- en: 'Instead of directly adding credentials/values to the `docker-compose` file,
    we can specify it from a `.env` file (we have already talked about this file),
    and Docker can read the required data from environment variables. Just create
    a `.env` file inside your main folder (it is the `transactionservice` folder for
    us) and add the missing configuration for Docker to run successfully:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接在 `docker-compose` 文件中添加凭据/值，而是可以从一个 `.env` 文件中指定（我们之前已经讨论过这个文件），Docker
    可以从环境变量中读取所需的数据。只需在你的主文件夹内（对我们来说就是 `transactionservice` 文件夹）创建一个 `.env` 文件，并添加
    Docker 运行成功所需的缺失配置：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now have our PostgreSQL database up and running. In most cases, developers
    prefer not to directly interact with databases using SQL queries. Not all developers
    have a solid understanding of SQL, and even so, using pure SQL queries to manipulate
    to database in most cases is not a good choice nowadays. Instead, we have various
    packages available that abstract away the complexity of raw SQL, enabling us to
    create beautiful applications without needing deep expertise in SQL. One of these
    packages is Prisma. As we mentioned before, Prisma is an open source ORM that
    automates and abstracts most of the operations you need to do when you deal with
    a database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了我们的 PostgreSQL 数据库。在大多数情况下，开发者更喜欢不直接使用 SQL 查询与数据库交互。并非所有开发者都对 SQL
    有坚实的理解，即使如此，在大多数情况下，使用纯 SQL 查询来操作数据库也不是一个好的选择。相反，我们有各种可用的包，它们抽象了原始 SQL 的复杂性，使我们能够在不需要深入
    SQL 知识的情况下创建美观的应用程序。其中之一就是 Prisma。正如我们之前提到的，Prisma 是一个开源的 ORM，它自动化并抽象了你处理数据库时需要执行的大多数操作。
- en: To start work with Prisma, we need a *CLI*. Prisma CLI is a combination of tools
    that help us migrate, seed, and do additional database-oriented operations easily.
    You just need to run the `npm install prisma -D` command from the terminal. After
    executing the command, `npm` should successfully install Prisma CLI as a dev dependency.
    You can check `package.json`’s `devDependencies` section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Prisma 的工作，我们需要一个 *CLI*。Prisma CLI 是一系列工具的组合，帮助我们轻松地进行迁移、种子和执行其他数据库相关操作。你只需从终端运行
    `npm install prisma -D` 命令。执行命令后，`npm` 应该成功地将 Prisma CLI 作为开发依赖项安装。你可以在 `package.json`
    的 `devDependencies` 部分进行检查。
- en: 'After Prisma CLI, it is time to install Prisma itself. The `npx prisma init`
    command handles the initialization of the Prisma package. It will create an additional
    folder called `prisma` with a `schema.prisma` file and a `.env` file. In our case,
    we already have a `.env` file, so running the preceding command will end up updating
    our existing `.env` file. Open your `.env` file, and at the end of the file, update
    the value of `DATABASE_URL`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prisma CLI 之后，现在是时候安装 Prisma 本身了。`npx prisma init` 命令处理 Prisma 包的初始化。它将创建一个名为
    `prisma` 的额外文件夹，其中包含一个 `schema.prisma` 文件和一个 `.env` 文件。在我们的情况下，我们已经有了一个 `.env`
    文件，所以运行前面的命令将更新我们现有的 `.env` 文件。打开你的 `.env` 文件，并在文件末尾更新 `DATABASE_URL` 的值：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the heart of your Prisma setup lies the `schema.prisma` file. This file
    uses **Prisma Schema Language** (**PSL**), a declarative approach to defining
    your database structure. It acts as the central configuration for Prisma, specifying
    both your database connection and the generation of the Prisma Client API. The
    following code demonstrates how to define a simple schema file for Prisma:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Prisma 设置的核心是 `schema.prisma` 文件。这个文件使用 **Prisma 模式语言**（**PSL**），这是一种定义数据库结构的声明式方法。它作为
    Prisma 的中心配置，指定了数据库连接和 Prisma 客户端 API 的生成。以下代码演示了如何为 Prisma 定义一个简单的模式文件：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `schema.prisma` file, written in PSL, acts as your database blueprint with
    three key sections:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用 PSL 编写的 `schema.prisma` 文件充当你的数据库蓝图，有三个关键部分：
- en: '`generator`: This section configures the Prisma Client generator. The Prisma
    Client, a powerful API, is then generated to help you access your database.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generator`: 这个部分配置了 Prisma 客户端生成器。然后生成强大的 API Prisma 客户端，以帮助你访问数据库。'
- en: '`datasource`: Here, you define the database connection details. This includes
    the database provider and the connection string, often leveraging the `DATABASE_URL`
    environment variable for convenience.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datasource`: 在这里，你定义数据库连接的详细信息。这包括数据库提供者和连接字符串，通常利用 `DATABASE_URL` 环境变量以提高便利性。'
- en: '`Model:` This is where the heart of your database schema lies. You define the
    structure of your data by specifying tables and their corresponding fields.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model:` 这里是数据库模式的核心所在。你通过指定表及其对应的字段来定义你的数据结构。'
- en: The next section describes how to model your data inside the `schema.prisma`
    file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分描述了如何在 `schema.prisma` 文件中建模你的数据。
- en: Modeling the data
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据建模
- en: The `schema.prisma` file is the main place where we need to add our models.
    Modeling is a special language over SQL. It isolates you from the internals of
    SQL and provides data in a more human-readable language.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema.prisma` 文件是我们需要添加模型的主要地方。建模是一种特殊的语言，在 SQL 之上。它将你与 SQL 的内部细节隔离开来，并以更易于阅读的语言提供数据。'
- en: 'Open the `schema.prisma` file under the `prisma` folder and add the following
    model structure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `prisma` 文件夹下的 `schema.prisma` 文件，并添加以下模型结构：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The provided code defines a Prisma model named `Transaction` and an `enum` named
    `Status` within your NestJS application schema.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码定义了一个名为 `Transaction` 的 Prisma 模型以及在你 NestJS 应用程序模式中的一个名为 `Status` 的枚举。
- en: 'Here’s a breakdown of each section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个部分的分解：
- en: '`id`: This field represents the unique identifier for each transaction. It’s
    of type `Int` and is automatically marked as the primary key with the `@id` directive.
    Additionally, `@default(autoincrement())` ensures a new, unique ID is generated
    for each transaction automatically.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 这个字段代表每个交易的唯一标识符。它的类型是 `Int`，并自动标记为使用 `@id` 指令的主键。此外，`@default(autoincrement())`
    确保每个交易自动生成一个新且唯一的 ID。'
- en: '`status`: This field defines the current state of the transaction. It’s of
    type `Status`, which will reference `Status` `Enumeration(enum Status)`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`: 这个字段定义了交易的当前状态。它的类型是 `Status`，将引用 `Status` 枚举（`Enumeration(enum Status)`）。'
- en: '`accountId`: This field stores the identifier for the associated account involved
    in the transaction. It’s of type `String` and uses `@default(uuid())` to generate
    a **universally unique identifier** (**UUID**) by default.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accountId`: 这个字段存储参与交易的关联账户的标识符。它的类型是 `String`，并使用 `@default(uuid())` 默认生成一个
    **全局唯一标识符**（**UUID**）。'
- en: '`description`: This optional field allows for storing a brief description of
    the transaction. It’s of type `String?`, indicating it can be `null`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 这个可选字段允许存储交易的简要描述。它的类型是 `String?`，表示它可以 `null`。'
- en: '`createdAt`: This field captures the timestamp of when the transaction was
    created. It’s of type `DateTime` and uses `@default(now())` to automatically set
    the creation time to the current moment.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createdAt`: 这个字段捕获了交易创建的时间戳。它的类型是 `DateTime`，并使用 `@default(now())` 自动将创建时间设置为当前时刻。'
- en: '`updatedAt`: This field is automatically updated whenever the transaction record
    is modified. It’s of type `DateTime` and uses the `@updatedAt` directive to achieve
    this behavior.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatedAt`: 这个字段在交易记录被修改时自动更新。它的类型是 `DateTime`，并使用 `@updatedAt` 指令来实现这种行为。'
- en: OK – but how to generate SQL based on the model we defined in `schema.prisma`?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——但是如何根据我们在 `schema.prisma` 中定义的模式生成 SQL 呢？
- en: Run `npx prisma migrate dev --name init` from the command line (VS Code terminal)
    to start the migration journey. In the context of NestJS and Prisma, **migration**
    refers to a process that manages changes to your database schema over time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行（VS Code 终端）运行 `npx prisma migrate dev --name init` 以开始迁移之旅。在 NestJS 和 Prisma
    的上下文中，**迁移**指的是管理数据库模式随时间变化的过程。
- en: 'Here is a breakdown of the command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是命令的分解：
- en: '`npx prisma migrate dev`: This command invokes the Prisma migration tool in
    development mode.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npx prisma migrate dev`：此命令以开发模式调用 Prisma 迁移工具。'
- en: '`--name init`: This option specifies the name of the new migration. Here, it’s
    set to `init`, likely signifying the initial setup of your database schema.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name init`：此选项指定新迁移的名称。在这里，它设置为 `init`，可能表示数据库模式的初始设置。'
- en: By running this command, you’re essentially creating a starting point for managing
    your database schema changes using Prisma migrations. As you make modifications
    to your `schema.prisma` file, Prisma will automatically generate new migrations
    to reflect those changes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此命令，你实际上是在创建一个起点，用于使用 Prisma 迁移管理你的数据库模式变化。随着你对 `schema.prisma` 文件进行修改，Prisma
    将自动生成新的迁移来反映这些更改。
- en: 'The command will end up creating a `migrations` folder with a `migration.sql`
    file (*Figure 6**.6*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 命令最终会在 `migrations` 文件夹中创建一个 `migration.sql` 文件（*图 6**.6*）：
- en: '![Figure 6.6: Automatically generated migration structure](img/B09148_06_006.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：自动生成的迁移结构](img/B09148_06_006.jpg)'
- en: 'Figure 6.6: Automatically generated migration structure'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：自动生成的迁移结构
- en: 'Check the generated `migration.sql` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的 `migration.sql` 文件：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you should have tables with the name `Transaction` and `_prisma_migrations`
    in your database. It may take a few seconds for Docker to set up the services,
    so a brief wait might be necessary. To check this, let’s do the following operations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在你的数据库中有名为 `Transaction` 和 `_prisma_migrations` 的表格。Docker 设置服务可能需要几秒钟，所以可能需要稍等片刻。为了检查这一点，让我们执行以下操作：
- en: Open Docker Desktop and ensure all services are running.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Docker Desktop 并确保所有服务都在运行。
- en: Click on the `postgres` container.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `postgres` 容器。
- en: 'From the `172.26.0.2`):'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （从 `172.26.0.2`）：
- en: Navigate to `http://localhost:5050/browser/` from your browser.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器导航到 `http://localhost:5050/browser/`。
- en: Right-click on **Servers**, then select **Register** | **Server** from the menu.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 **服务器**，然后从菜单中选择 **注册** | **服务器**。
- en: Under the `localhost` for its value.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `localhost` 下检查其值。
- en: Go to the `172.26.0.2` for us)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `172.26.0.2`（为我们操作）
- en: '`5432`'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`5432`'
- en: '`tservice_db`'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tservice_db`'
- en: '`postgres`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`postgres`'
- en: '`postgres`'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`postgres`'
- en: '![Figure 6.7: Server registration window for postgres](img/B09148_06_007.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：postgres 服务器注册窗口](img/B09148_06_007.jpg)'
- en: 'Figure 6.7: Server registration window for postgres'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：postgres 服务器注册窗口
- en: Click the **Save** button, and your server connection should be successful.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存** 按钮，你的服务器连接应该成功。
- en: 'Now, expand `localhost` (or your name) | `tservice_db` | **Schemas** | **Public**
    | **Tables** (*Figure 6**.8*):'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，展开 `localhost`（或你的名称）| `tservice_db` | **模式** | **公共** | **表格**（*图 6**.8*）：
- en: '![Figure 6.8: postgres tables after migration via Prisma](img/B09148_06_008.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：通过 Prisma 迁移后的 postgres 表格](img/B09148_06_008.jpg)'
- en: 'Figure 6.8: postgres tables after migration via Prisma'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：通过 Prisma 迁移后的 postgres 表格
- en: 'If you have locally installed `pgAdmin`, to connect to your Docker `postgres`
    instance, just enter the following to the server registration window for `postgres`
    (*Figure 6**.7*):'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经在本地上安装了 `pgAdmin`，要连接到你的 Docker `postgres` 实例，只需将以下内容输入到 `postgres` 的服务器注册窗口（*图
    6**.7*）：
- en: '`localhost`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost`'
- en: '`5438`'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5438`'
- en: '`tservice_db`'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tservice_db`'
- en: '`postgres`'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres`'
- en: '`postgres`'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgres`'
- en: Click the **Save** button, and your server connection should be successful.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存** 按钮，你的服务器连接应该成功。
- en: 'The `_prisma_migrations` table you see when using NestJS and Prisma ORM plays
    a crucial role in managing database schema changes. It has the following responsibilities:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 NestJS 和 Prisma ORM 时，你看到的 `_prisma_migrations` 表在管理数据库模式变化中起着至关重要的作用。它有以下职责：
- en: Tracks applied database migrations
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪应用的数据库迁移
- en: Ensures migrations are applied only once
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保迁移只应用一次
- en: Maintains consistency between your Prisma schema and the actual database structure
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持 Prisma 模式和实际数据库结构之间的一致性
- en: Each time you run a Prisma migration, a new entry is added to the `_prisma_migrations`
    table.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你运行 Prisma 迁移时，都会在 `_prisma_migrations` 表中添加一个新条目。
- en: When Prisma needs to apply migrations, it checks the `_prisma_migrations` table
    to see which migrations have already been run based on the unique hash.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Prisma 需要应用迁移时，它会检查 `_prisma_migrations` 表以查看基于唯一哈希哪些迁移已经被运行。
- en: This prevents applying the same migration multiple times, potentially corrupting
    your data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这防止了多次应用相同的迁移，从而可能损坏您的数据。
- en: Modifying the `_prisma_migrations` table manually can lead to inconsistencies
    and errors. Don’t edit, delete, or modify it. This table is essential for Prisma
    to manage migrations effectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 手动修改 `_prisma_migrations` 表可能会导致不一致性和错误。不要编辑、删除或修改它。此表对于 Prisma 有效地管理迁移至关重要。
- en: Long story short, the `_prisma_migrations` table acts as a logbook for your
    database schema changes, ensuring a smooth and controlled migration process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`_prisma_migrations` 表充当您数据库模式更改的日志簿，确保迁移过程平稳且受控。
- en: Seeding test data
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种子测试数据
- en: Seeding data involves populating your database with an initial set of data.
    If you want your database to have initial data before running your application,
    you may apply seeding.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 种子数据涉及将一组初始数据填充到您的数据库中。如果您希望在运行应用程序之前数据库已有初始数据，您可以使用种子操作。
- en: 'Add a `seed.ts` file under the `prisma` folder with the following content:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `prisma` 文件夹下添加一个 `seed.ts` 文件，并包含以下内容：
- en: '[PRE7]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Go to `package.json` and add the following after `devDependencies`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `package.json` 并在 `devDependencies` 之后添加以下内容：
- en: '[PRE8]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, open the terminal window and type the `npx prisma db seed` command. You
    should see a message that indicates a successful operation (*Figure 6**.9*):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开终端窗口并输入 `npx prisma db seed` 命令。您应该会看到一个表示操作成功的消息（*图 6.9*）：
- en: '![Figure 6.9: Executing seed](img/B09148_06_009.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9：执行种子操作](img/B09148_06_009.jpg)'
- en: 'Figure 6.9: Executing seed'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：执行种子操作
- en: 'Open the `Transaction` table using `PgAdmin`, and you’ll see your first successfully
    inserted row (*Figure 6**.10*):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PgAdmin` 打开 `Transaction` 表，您将看到您成功插入的第一行数据（*图 6.10*）：
- en: '![Figure 6.10: Transaction table after seed](img/B09148_06_010.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10：种子操作后的交易表](img/B09148_06_010.jpg)'
- en: 'Figure 6.10: Transaction table after seed'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：种子操作后的交易表
- en: 'It is time to explain what we have inserted into our `seed.ts` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候解释我们已插入 `seed.ts` 文件中的内容了：
- en: '`PrismaClient from @prisma/client`: This line imports the necessary class to
    interact with our database schema using Prisma.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrismaClient from @prisma/client`: 这行代码导入必要的类，以便使用 Prisma 与我们的数据库模式进行交互。'
- en: '`const prismaClient = new PrismaClient()`: Here, we create an instance of the
    `PrismaClient` class, which will be used to perform database operations.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const prismaClient = new PrismaClient()`: 在这里，我们创建 `PrismaClient` 类的实例，该实例将用于执行数据库操作。'
- en: '`async function seedData() { ... }`: This function is the heart of the script
    and is marked `async` because it includes asynchronous operations that involve
    interacting with the database.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async function seedData() { ... }`: 这个函数是脚本的灵魂，被标记为 `async`，因为它包含涉及与数据库交互的异步操作。'
- en: '`const first_transaction = await prismaClient.transaction.upsert({ ... })`:
    This line performs the core seeding operation.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const first_transaction = await prismaClient.transaction.upsert({ ... })`:
    这行代码执行核心的种子操作。'
- en: '`prismaClient.transaction`: This part accesses the transaction model of your
    Prisma schema through the initialized client.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prismaClient.transaction`: 这部分通过初始化客户端访问 Prisma 模式中的事务模型。'
- en: '`.upsert({ ... }):` The `upsert` method is a convenient way to create or update
    a record in the database. It checks for existing data based on the provided `where`
    clause and performs the appropriate action.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.upsert({ ... }):` `upsert` 方法是一种方便的方式，用于在数据库中创建或更新记录。它根据提供的 `where` 子句检查现有数据，并执行相应的操作。'
- en: 'If a record with `id: 1` (assuming your schema has an ID field) already exists,
    the following happens:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果已存在具有 `id: 1`（假设您的模式具有 ID 字段）的记录，则会发生以下情况：'
- en: The `update` object (empty here) would be used to update the existing record
    (but since it’s empty, no update happens) if a record with `id:` `1` exists.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update` 对象（此处为空）将用于更新具有 `id:` `1` 的现有记录（但由于它是空的，因此不会发生更新）。'
- en: The `create` object defines the data for the new transaction record if a record
    with an ID doesn’t exist.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create` 对象定义了如果不存在具有 ID 的记录时新事务记录的数据。'
- en: '`create Object (Seed Data)`: This object defines the details of the dummy transaction
    to be created.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create Object (Seed Data)`: 此对象定义了要创建的虚拟事务的详细信息。'
- en: '`id: 1`: Sets the ID of the transaction to 1 (replace with a unique value if
    needed).'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: 1`: 将事务的 ID 设置为 1（如果需要，请替换为唯一值）。'
- en: '`status: ''CREATED''`: Sets the initial status of the transaction to `CREATED`.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status: ''CREATED''`：将事务的初始状态设置为`CREATED`。'
- en: '`accountId: ''662c081370bd2ba6b5f04e94''`: Assigns an account ID to the transaction
    (you can use any ID).'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accountId: ''662c081370bd2ba6b5f04e94''`：将账户ID分配给事务（你可以使用任何ID）。'
- en: '`description: ''simple transaction''`: Provides a descriptive text for the
    transaction.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description: ''simple transaction''`：为事务提供描述性文本。'
- en: To apply business rules to our application, we need to add an extra layer over
    a database, and it is going to be our service layer. The next section will introduce
    a service layer for the transaction database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要将业务规则应用到我们的应用程序中，我们需要在数据库之上添加一个额外的层，这将是我们的服务层。下一节将介绍用于事务数据库的服务层。
- en: Implementing the transaction service
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现事务服务
- en: We are done with the database. As a classical development style, it is time
    to create a service over our database. Creating a service layer is simple with
    NestJS, especially if you deal with Prisma ORM.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了数据库的工作。作为一个经典的开发风格，现在是时候在我们的数据库上创建一个服务了。使用NestJS创建服务层很简单，尤其是如果你处理Prisma
    ORM的话。
- en: First, let’s create our module using the `npx nest generate module` `prisma`
    command.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`npx nest generate module` `prisma`命令创建我们的模块。
- en: This Prisma CLI command should generate a new folder called `prisma` and should
    generate a `prisma.module.ts` file under this folder. This command also will affect
    your `app.module.js` file under the `src` folder.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Prisma CLI命令应该会生成一个名为`prisma`的新文件夹，并在该文件夹下生成一个`prisma.module.ts`文件。此命令还将影响`src`文件夹下的`app.module.js`文件。
- en: 'We need one more command to run to generate our service files:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要运行一个额外的命令来生成我们的服务文件：
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will create `prisma.service.ts,prisma.service.spec.ts` files under
    `src/prisma` and update the `prisma.module.ts` file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在`src/prisma`下创建`prisma.service.ts`、`prisma.service.spec.ts`文件，并更新`prisma.module.ts`文件。
- en: 'For this chapter, you can remove all files that have `.spec.ts` extensions
    from the project. These files contain unit tests for the application’s components,
    typically services and controllers. We have a separate chapter to work with unit
    tests; for the chapter’s simplicity, we don’t need them. For now, replace the
    content of `prisma.service.ts` with the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你可以从项目中删除所有具有`.spec.ts`扩展名的文件。这些文件包含应用程序组件的单元测试，通常是服务和控制器。我们有一个单独的章节来处理单元测试；为了章节的简洁性，我们不需要它们。现在，将`prisma.service.ts`的内容替换为以下内容：
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this code, we have a straightforward implementation for the `prisma` service:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们对`prisma`服务有一个直接的实现：
- en: '`import { Injectable } from ''@nestjs/common'';`: This line imports the `Injectable`
    decorator from the `@nestjs/common` module. This decorator marks the class as
    a NestJS injectable service, making it available for **dependency injection**
    (**DI**) in other parts of your application.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import { Injectable } from ''@nestjs/common'';`：这一行从`@nestjs/common`模块中导入了`Injectable`装饰器。这个装饰器将类标记为NestJS可注入的服务，使其在应用程序的其他部分可用，以便进行**依赖注入**（**DI**）。'
- en: '`import { PrismaClient } from ''@prisma/client'';`: This line imports the `PrismaClient`
    class from the `@prisma/client` package. This class provides an interface for
    interacting with your database using Prisma queries.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import { PrismaClient } from ''@prisma/client'';`：这一行从`@prisma/client`包中导入了`PrismaClient`类。这个类提供了一个接口，用于使用Prisma查询与数据库进行交互。'
- en: '`@Injectable()`: This decorator applied to the class declaration marks it as
    a NestJS injectable service. NestJS will manage the lifecycle of this service
    and provide it to other components that require database access.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Injectable()`: 这个应用于类声明的装饰器将类标记为NestJS可注入的服务。NestJS将管理这个服务的生命周期，并将其提供给需要数据库访问的其他组件。'
- en: '`export class PrismaService extends PrismaClient {}`: This line defines the
    `PrismaService` class. It inherits from the `PrismaClient` class, giving it access
    to all the database interaction methods provided by Prisma.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export class PrismaService extends PrismaClient {}`: 这一行定义了`PrismaService`类。它从`PrismaClient`类继承，从而获得了Prisma提供的一切数据库交互方法。'
- en: In essence, this code creates a service specifically for interacting with our
    database through Prisma. This service can then be injected into other parts of
    our application (such as controllers) to perform database operations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这段代码创建了一个专门用于通过Prisma与我们的数据库交互的服务。然后，这个服务可以被注入到我们应用程序的其他部分（如控制器）中，以执行数据库操作。
- en: The `prisma.service.ts` file acts as a wrapper over the Prisma client. It is
    an injectable element that we can use to inject it into modules.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`prisma.service.ts`文件作为Prisma客户端的包装器。它是一个可注入的元素，我们可以将其注入到模块中。'
- en: 'Let’s update our `prisma.module.ts` file to have the following content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`prisma.module.ts`文件以包含以下内容：
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To make the Prisma service accessible throughout your NestJS application, you’ll
    need to create a dedicated module. This module will import the `PrismaService`
    class and provide it for injection into other modules or components. That is the
    reason why we have a `prisma.module.ts` file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Prisma服务在您的NestJS应用程序中可用，您需要创建一个专门的模块。此模块将导入`PrismaService`类并将其提供给其他模块或组件注入。这就是为什么我们有`prisma.module.ts`文件的原因。
- en: Nowadays, it is popular to use a UI for APIs, and it allows us to document and
    easily use endpoints. One of the packages that allows us to do it is Swagger.
    The next section explains how to integrate Swagger for our endpoints.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用UI来处理API很流行，它允许我们记录和轻松使用端点。允许我们这样做的一个包是Swagger。下一节将解释如何为我们的端点集成Swagger。
- en: Configuring Swagger
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Swagger
- en: To have visible documentation and visual usage for our APIs, we will configure
    Swagger UI.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的API具有可见的文档和可视化的使用方式，我们将配置Swagger UI。
- en: 'Open the VS Code terminal and type the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 打开VS Code终端并输入以下内容：
- en: '[PRE12]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open `src/main.ts` and update its content with the following to integrate Swagger:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/main.ts`并更新其内容以集成Swagger：
- en: '[PRE13]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s understand this code here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这里的代码：
- en: '`NestFactory` from `@nestjs/core`: This import provides the core functionality
    for creating a NestJS application instance.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NestFactory`来自`@nestjs/core`: 这个导入提供了创建NestJS应用程序实例的核心功能。'
- en: '`AppModule` from `./app.module`: This imports your main application module,
    where all the necessary components and services of your NestJS application are
    defined.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppModule`来自`./app.module`: 这将导入您的主应用程序模块，其中定义了您的NestJS应用程序的所有必要组件和服务。'
- en: '`SwaggerModule` and `DocumentBuilder` from `@nestjs/swagger`: These imports
    are used for integrating Swagger documentation with your NestJS application.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwaggerModule`和`DocumentBuilder`来自`@nestjs/swagger`: 这些导入用于将Swagger文档与您的NestJS应用程序集成。'
- en: 'Bootstrap function (`async`):'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bootstrap函数（`async`）:'
- en: This function is marked as `async` because it involves asynchronous operations
    such as creating an application instance and listening for incoming requests.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数被标记为`async`，因为它涉及异步操作，例如创建应用程序实例和监听传入的请求。
- en: It serves as the entry point for your NestJS application and is typically called
    at the bottom of your `main.ts` file.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为您的NestJS应用程序的入口点，通常在`main.ts`文件的底部调用。
- en: '`const app = await NestFactory.create(AppModule);`: This line creates a new
    NestJS application instance using the `AppModule` class. The `await` keyword signifies
    that the function will wait for the application creation to complete before proceeding.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const app = await NestFactory.create(AppModule);`: 这行代码使用`AppModule`类创建一个新的NestJS应用程序实例。`await`关键字表示该函数将在应用程序创建完成后才继续执行。'
- en: 'Swagger configuration:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger配置：
- en: '`const config = new DocumentBuilder()...`: Here, you’re configuring the Swagger
    documentation using the `DocumentBuilder` class.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const config = new DocumentBuilder()...`: 这里，您正在使用`DocumentBuilder`类配置Swagger文档。'
- en: '`.setTitle(''Transaction API'')`: Sets the title of your API documentation
    to `Transaction API`.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.setTitle(''Transaction API'')`: 将您的API文档的标题设置为`Transaction API`。'
- en: '`.setDescription(''Transaction API description'')`: Provides a brief description
    of your API.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.setDescription(''Transaction API description'')`: 提供了您API的简要描述。'
- en: '`.setVersion(''1.0'')`: Sets the version of your API to `1.0`.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.setVersion(''1.0'')`: 将您的API版本设置为`1.0`。'
- en: '`.build()`: Builds the Swagger document based on the provided configuration
    options.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.build()`: 根据提供的配置选项构建Swagger文档。'
- en: '`const document = SwaggerModule.createDocument(app, config);`: This line generates
    the actual Swagger document using the `SwaggerModule` class. It takes the NestJS
    application instance (`app`) and the built configuration (`config`) as arguments.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const document = SwaggerModule.createDocument(app, config);`: 这行代码使用`SwaggerModule`类生成实际的Swagger文档。它将NestJS应用程序实例（`app`）和构建的配置（`config`）作为参数。'
- en: '`SwaggerModule.setup(''api'', app, document);`: This code integrates the Swagger
    documentation with your application. It sets the path prefix for the documentation
    to `api` (for example, `http://localhost:3000/api`) and associates the generated
    document (`document`) with the application (`app`). This allows developers to
    access the interactive Swagger documentation at the specified URL.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwaggerModule.setup(''api'', app, document);`: 这段代码将Swagger文档与您的应用程序集成。它将文档的路径前缀设置为`api`（例如，`http://localhost:3000/api`），并将生成的文档（`document`）与应用程序（`app`）关联。这使得开发人员可以在指定的URL访问交互式Swagger文档。'
- en: '`await app.listen(3000);`: This line starts the NestJS application and makes
    it listen for incoming requests on port `3000`. You can change this port number
    to your desired option.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await app.listen(3000);`：此行启动 NestJS 应用程序并使其在端口`3000`上监听传入的请求。您可以将此端口号更改为您想要的选项。'
- en: 'Overall, this `main.ts` file performs two crucial tasks:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此`main.ts`文件执行两个关键任务：
- en: '`AppModule` class and starts the server listening for requests'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppModule`类和启动服务器监听请求'
- en: '**Integrates Swagger documentation**: It configures and provides Swagger documentation
    for your API, allowing developers to explore your API endpoints, understand data
    models, and interact with your API using the interactive interface'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成 Swagger 文档**：它为您的 API 配置并提供 Swagger 文档，允许开发者通过交互式界面探索您的 API 端点、理解数据模型并与您的
    API 交互'
- en: 'Navigate to `localhost:3000/api`, and you should see the Swagger page (*Figure
    6**.11*):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`localhost:3000/api`，您应该能看到 Swagger 页面（*图6.11*）：
- en: '![Figure 6.11: Swagger UI](img/B09148_06_011.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：Swagger UI](img/B09148_06_011.jpg)'
- en: 'Figure 6.11: Swagger UI'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：Swagger UI
- en: As you’ll realize, we don’t have any endpoints yet; the next section talks about
    creating them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如您将意识到的那样，我们还没有任何端点；下一节将讨论创建它们。
- en: Working on transaction implementation
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在事务实现上工作
- en: To start to work with transactions, first, we need to generate resources. To
    implement **create, read, update, and delete** (**CRUD**) operations for transactions,
    we’ll first generate REST resources, creating boilerplate code for the module,
    controller, service, and **Data Transfer** **Object** (**DTO**).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始处理事务，首先，我们需要生成资源。为了实现事务的**创建、读取、更新和删除**（**CRUD**）操作，我们首先将生成 REST 资源，为模块、控制器、服务和**数据传输对象**（**DTO**）创建样板代码。
- en: 'Run the `npx nest generate resource transaction` command to generate resources
    for a transaction:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npx nest generate resource transaction`命令以生成事务的资源：
- en: '![Figure 6.12: Selecting a transport layer](img/B09148_06_012.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：选择传输层](img/B09148_06_012.jpg)'
- en: 'Figure 6.12: Selecting a transport layer'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：选择传输层
- en: 'It will ask you which transport layer to choose (*Figure 6**.12*). Select `REST
    API` and hit *Enter*. As the next question, you will be asked `Would you like
    to generate CRUD entry points?.` Select `Y`, and the following files should be
    generated (*Figure 6**.13*):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 它将询问您要选择哪个传输层（*图6.12*）。选择`REST API`并按*Enter*键。接下来，您将被询问`您想要生成 CRUD 入口点吗？`选择`Y`，然后应该会生成以下文件（*图6.13*）：
- en: '![Figure 6.13: CRUD generation for transaction](img/B09148_06_013.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：事务的 CRUD 生成](img/B09148_06_013.jpg)'
- en: 'Figure 6.13: CRUD generation for transaction'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：事务的 CRUD 生成
- en: 'Run `npm run start:dev` and navigate to `localhost:3000/api`. You should get
    a page that stores transaction boilerplate endpoints (*Figure 6**.14*):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run start:dev`并导航到`localhost:3000/api`。您应该会看到一个存储事务样板端点的页面（*图6.14*）：
- en: '![Figure 6.14: Swagger UI for transaction](img/B09148_06_014.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：事务的 Swagger UI](img/B09148_06_014.jpg)'
- en: 'Figure 6.14: Swagger UI for transaction'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：事务的 Swagger UI
- en: 'Of course, we don’t need to implement all these CRUD endpoints. We need the
    following functions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不需要实现所有这些 CRUD 端点。我们需要以下函数：
- en: Get all transactions (`GET /transaction`)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有事务（`GET /transaction`）
- en: Get transaction by ID (`GET /``transaction/{id}` )
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 获取事务（`GET /transaction/{id}`）
- en: Create transaction (`POST /transaction`)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事务（`POST /transaction`）
- en: Let’s remove the rest of the unused code blocks and files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除其余未使用的代码块和文件。
- en: 'Remove the following files:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 移除以下文件：
- en: '`transaction/transaction.controller.spec.ts`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction/transaction.controller.spec.ts`'
- en: '`transaction/dto/update-transaction.dto.ts`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction/dto/update-transaction.dto.ts`'
- en: '`transaction/transaction.service.spec.ts`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction/transaction.service.spec.ts`'
- en: 'Remove the following code blocks:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 移除以下代码块：
- en: '`remove` and `update` functions from `transaction.service.ts`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction.service.ts`中的`remove`和`update`函数'
- en: '`remove` and `update` functions from `transaction.controller.ts`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transaction.controller.ts`中的`remove`和`update`函数'
- en: 'If you haven’t removed them yet, remove the following files too:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有移除它们，请也移除以下文件：
- en: '`app.controller.ts`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.controller.ts`'
- en: '`app.module.ts`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.module.ts`'
- en: '`app.service.ts`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.service.ts`'
- en: 'Update `main.ts` to work with `TransactionModule`, not `AppModule`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将`main.ts`更新为与`TransactionModule`一起工作，而不是`AppModule`：
- en: '[PRE14]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll end up with three endpoints (*Figure 6**.15*):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您将拥有三个端点（*图6.15*）：
- en: '![Figure 6.15: Final transaction endpoints](img/B09148_06_015.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：最终事务端点](img/B09148_06_015.jpg)'
- en: 'Figure 6.15: Final transaction endpoints'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：最终事务端点
- en: 'After having generated REST resources, we’re ready to integrate our `PrismaClient`
    class. Having this client will help us to interact with the database easily. First,
    let’s update our `transaction.module.ts` file to have `PrismaModule`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成 REST 资源后，我们准备好集成我们的 `PrismaClient` 类。拥有这个客户端将帮助我们轻松地与数据库交互。首先，让我们更新我们的 `transaction.module.ts`
    文件以包含 `PrismaModule`：
- en: '[PRE15]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Having `PrismaModule` in the `imports` array will make `PrismaService` available
    to `TransactionService`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `imports` 数组中包含 `PrismaModule` 将使 `PrismaService` 可用于 `TransactionService`。
- en: 'Now, open the `transaction.service.ts` file and make the following changes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `transaction.service.ts` 文件并做出以下更改：
- en: '[PRE16]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The transaction controller file (`transaction.controller.ts`) already has `transactionservice`
    as an injected service. It has all the required contracts to request the transaction
    service and retrieve data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 交易控制器文件 (`transaction.controller.ts`) 已经将 `transactionservice` 作为注入的服务。它具有请求交易服务并检索数据所需的所有合约。
- en: 'Open `transaction.controller.ts` and have a look at the `findAll()` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `transaction.controller.ts` 并查看 `findAll()` 方法：
- en: '[PRE17]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The same applies to `POST` and the single `GET` request. The only thing we
    need to do is to call Prisma to provide all the data when we call `transactionservice`’s
    `findAll()` method. For that reason, open `transaction.service.ts` and update
    the `findAll()` method content (*Figure 6**.14*):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于 `POST` 和单个 `GET` 请求。我们唯一需要做的是在调用 `transactionservice` 的 `findAll()` 方法时调用
    Prisma 以提供所有数据。因此，打开 `transaction.service.ts` 并更新 `findAll()` 方法的内容 (*图 6.14*）：
- en: '[PRE18]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using `findMany()`, we’re able to call all transaction data from the transaction
    table via Prisma. Let’s run our application (run `npm run start:dev`) and run
    our endpoint from Swagger UI.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `findMany()`，我们能够通过 Prisma 从交易表调用所有交易数据。让我们运行我们的应用程序（运行 `npm run start:dev`）并从
    Swagger UI 运行我们的端点。
- en: 'Open `GET /transaction` from Swagger UI, click the **Try it out** button, and
    click the **Execute** button. Now, you should see only the data we migrated to
    our database when we talked about seeding data (*Figure 6**.16*):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swagger UI 中打开 `GET /transaction`，点击 **尝试操作** 按钮，然后点击 **执行** 按钮。现在，你应该只看到我们在讨论播种数据时迁移到我们数据库中的数据
    (*图 6.16*）：
- en: '![Figure 6.16: Response for “Get all transactions”](img/B09148_06_016.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16：获取所有交易的响应](img/B09148_06_016.jpg)'
- en: 'Figure 6.16: Response for “Get all transactions”'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：获取所有交易的响应
- en: 'To modify your `GET` request by ID endpoint for it to work properly, open `transaction.service.ts`
    and replace the `findOne()` method with the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改你的通过 ID 的 `GET` 请求端点使其正常工作，打开 `transaction.service.ts` 并将 `findOne()` 方法替换为以下内容：
- en: '[PRE19]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Everything is really simple when it comes to retrieving data, but how about
    creating it?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到检索数据时，一切都非常简单，但创建数据又是如何呢？
- en: 'We have a `POST` endpoint in `transaction.controller.ts` that was automatically
    generated when we generated the file itself:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `transaction.controller.ts` 中有一个 `POST` 端点，这是在我们生成文件本身时自动生成的：
- en: '[PRE20]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When our resources were created, `CreateTransactionDTO` was also generated;
    you can find it inside the `src/transaction/dto` folder. Surprisingly, it has
    only one class declaration:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的资源被创建时，`CreateTransactionDTO` 也被生成；你可以在 `src/transaction/dto` 文件夹中找到它。令人惊讶的是，它只有一个类声明：
- en: '[PRE21]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should manually add the required properties into the class. Our DTOs just
    transfer data from the source to the destination. DTOs are used in various programming
    languages and frameworks, not specific to NestJS. They act as a way to efficiently
    transfer data between different layers of an application. We also have a validation
    possibility before getting data from the user and creating DTOs based on this
    data. That is why we will use the `class-validator` package to validate our data.
    To install it, run the following command from the terminal:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该手动将所需的属性添加到类中。我们的 DTOs 只是从源到目的地传输数据。DTOs 在各种编程语言和框架中使用，并不特定于 NestJS。它们作为在不同应用层之间高效传输数据的方式。我们还在从用户获取数据并基于此数据创建
    DTOs 之前有验证的可能性。这就是为什么我们将使用 `class-validator` 包来验证我们的数据。要从终端安装它，请运行以下命令：
- en: '[PRE22]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open `create-transaction.dto.ts` and add the following content:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `create-transaction.dto.ts` 并添加以下内容：
- en: '[PRE23]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Update your `POST` method (`transaction.controller.ts`) to accept `CreateTransactionDTO`
    and execute it:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的 `POST` 方法 (`transaction.controller.ts`) 以接受 `CreateTransactionDTO` 并执行它：
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s run our application. From Swagger UI, open `POST/ transaction` and
    provide the following JSON payload:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的应用程序。从 Swagger UI 中，打开 `POST/ transaction` 并提供以下 JSON 负载：
- en: '[PRE25]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Click the **Execute** button, and here we are (*Figure 6**.17*):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **执行** 按钮，现在我们在这里 (*图 6.17*）：
- en: '![Figure 6.17: Successful transaction creation](img/B09148_06_017.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：成功创建交易](img/B09148_06_017.jpg)'
- en: 'Figure 6.17: Successful transaction creation'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：成功创建交易
- en: Starting from the next section, we will explore how to establish communication
    between the transaction and account microservices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将探讨如何建立交易和账户微服务之间的通信。
- en: Establishing synchronous communication with the account microservice
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立与账户微服务的同步通信
- en: 'We’re done with the transaction service, but the only thing missing is our
    account service. The transaction service allows us to specify an `accountId` value
    and status from the payload. We need to make the following changes:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了交易服务，但唯一缺少的是我们的账户服务。交易服务允许我们从有效载荷中指定`accountId`值和状态。我们需要进行以下更改：
- en: Verify if the provided `accountId` exists and is in a valid state (new or active)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证提供的`accountId`是否存在且处于有效状态（新或活动状态）
- en: If `accountId` is valid, then create a transaction with the `Created` status
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`accountId`有效，则创建一个状态为`Created`的交易
- en: If `accountId` is invalid, then create a transaction with the `Failed` status
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`accountId`无效，则创建一个状态为`Failed`的交易
- en: The purpose here is not to fully implement the transaction domain. Of course,
    the current domain has more requirements than the previous one, but our focus
    is to practice and establish synchronous communication between the transaction
    and account services.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的不是完全实现交易域。当然，当前的域比之前的域有更多的要求，但我们的重点是练习并建立交易和账户服务之间的同步通信。
- en: We have already talked about the pros and cons of synchronous communication
    between microservices. While asynchronous communication offers many benefits for
    microservices, there are situations where synchronous communication might be a
    better fit. If the interaction between microservices requires straightforward
    logic and an immediate response, synchronous communication can be easier to implement.
    Also, it is beneficial to use it for user interactions where you need to display
    information or confirm an action right away. It creates tight coupling, but in
    some cases, microservices might be tightly coupled and rely heavily on each other’s
    results to complete a task. Synchronous communication allows for a more controlled
    flow, ensuring one service doesn’t proceed until the other provides the necessary
    information. Synchronous communication can be easier to debug at times. Since
    the entire interaction happens in one go, tracing errors and understanding the
    flow of data is more straightforward. This can be helpful during development or
    troubleshooting specific issues.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经讨论了微服务之间同步通信的优缺点。虽然异步通信为微服务提供了许多好处，但在某些情况下，同步通信可能更适合。如果微服务之间的交互需要直接的逻辑和即时响应，同步通信可能更容易实现。此外，对于需要立即显示信息或确认操作的用例，使用同步通信是有益的。它创建了紧密耦合，但在某些情况下，微服务可能紧密耦合，并且高度依赖于彼此的结果来完成任务。同步通信允许更受控的流程，确保一个服务在另一个服务提供必要信息之前不继续进行。在某些时候，同步通信可能更容易调试。由于整个交互是一次性发生的，因此跟踪错误和理解数据流更为直接。这有助于开发或解决特定问题。 '
- en: 'To communicate with the account service, we need an HTTP client package. One
    of the most used packages is `axios`. Let’s install it using `npm`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与账户服务通信，我们需要一个HTTP客户端包。最常用的包之一是`axios`。让我们使用`npm`来安装它：
- en: '[PRE26]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to import `HttpModule` from `axios` and import it from `transaction.module.ts`.
    Here is the final code in this file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从`axios`导入`HttpModule`，并从`transaction.module.ts`中导入它。以下是该文件中的最终代码：
- en: '[PRE27]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After importing `HttpModule` from `transaction.module.ts`, we’re able to use
    `HttpService` from `axios` in `transaction.service.ts`. Let’s import and inject
    it as a service for the transaction service. Open `transaction.service.ts` and
    change the code to have the following lines:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`transaction.module.ts`导入`HttpModule`之后，我们能够在`transaction.service.ts`中使用`HttpService`从`axios`。让我们将其导入并注入为交易服务的一个服务。打开`transaction.service.ts`并将代码修改为以下行：
- en: '[PRE28]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As our business requires, we need to remove the status property from `createTransactionDto`
    because, depending on the account service, we should internally define the status
    of the transaction. That is why we’re going to remove the status from `src/transaction/dto/create-transaction.dto`.
    The following is the final version of this file:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的业务需求，我们需要从 `createTransactionDto` 中移除状态属性，因为根据账户服务，我们应该在内部定义交易的状态。这就是为什么我们要从
    `src/transaction/dto/create-transaction.dto` 中移除状态。以下是该文件的最终版本：
- en: '[PRE29]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Great! Now, let’s open our `transaction.service.ts` file again and change our
    *create* functionality. After injecting `httpService`, we should be able to make
    a request to any service and get a response back.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们再次打开 `transaction.service.ts` 文件并更改我们的 *创建* 功能。在注入 `httpService` 之后，我们应该能够向任何服务发送请求并获取响应。
- en: 'Here is what we plan to do:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的计划：
- en: Make a request to the account service’s `http://url/v1/accounts/{account_id}`
    endpoint and account information based on the provided ID from the endpoint
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向账户服务的 `http://url/v1/accounts/{account_id}` 端点发送请求，并根据端点提供的ID获取账户信息
- en: If the given account by `accountId` doesn’t exist, we throw an exception
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过 `accountId` 给定的账户不存在，我们将抛出异常
- en: If the account exists, and its status is either `'new'` or `'active'`, then
    the transaction should be created with a `'``CREATED'` status
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户存在，并且其状态是 `'new'` 或 `'active'`，则交易应该以 `'CREATED'` 状态创建
- en: If the account exists, and its status is neither `'new'` nor `'active'`, we
    should create a transaction with a `'``FAILED'` status
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果账户存在，并且其状态既不是 `'new'` 也不是 `'active'`，我们应该创建一个状态为 `'FAILED'` 的交易
- en: 'That is simply it. Open `transaction.service.ts` and update it with the following
    code lines:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。打开 `transaction.service.ts` 并使用以下代码行进行更新：
- en: '[PRE30]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last thing we need to do is to configure **cross-origin resource sharing**
    (**CORS**) in the account service. Follow the next steps:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是在账户服务中配置 **跨源资源共享**（**CORS**）。按照以下步骤操作：
- en: Open your account service from VS Code.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 VS Code 中打开您的账户服务。
- en: From the menu, select **Terminal** | **New Terminal**.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **终端** | **新建终端**。
- en: Navigate to the `src` folder.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `src` 文件夹。
- en: Execute `npm install cors` to install the `cors` package.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm install cors` 以安装 `cors` 包。
- en: 'Open `app.js` and add the following code after the `app` object is created:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.js` 并在创建 `app` 对象之后添加以下代码：
- en: '[PRE31]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final code in `app.js` should look like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.js` 中的最终代码应如下所示：'
- en: '[PRE32]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before running our application, make sure of the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的应用程序之前，请确保以下内容：
- en: Your account service lives in `localhost:3001`
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的账户服务位于 `localhost:3001`
- en: The account service has at least one piece of valid account information in your
    table
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户服务在您的表中至少有一条有效的账户信息
- en: Make sure that Docker is running and the `postgres` container is active
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保Docker正在运行并且 `postgres` 容器处于活动状态
- en: 'Go to our account service and run it (for more details, check [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074)).
    Run our newly created transaction service using `npm run start:dev`. Open your
    favorite browser, and navigate to `http://localhost:3000/api`. Open `POST /transaction`
    and add the following payload:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前往我们的账户服务并运行它（更多详情，请参阅[*第五章*](B09148_05.xhtml#_idTextAnchor074)）。使用 `npm run
    start:dev` 运行我们新创建的交易服务。打开您喜欢的浏览器，导航到 `http://localhost:3000/api`。打开 `POST /transaction`
    并添加以下有效载荷：
- en: '[PRE33]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `accountId` value you provided from the payload should exist in the account
    service to have a successful operation. In the case of a successful request, you
    will get the following response:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您从有效载荷中提供的 `accountId` 值应在账户服务中存在，以便成功操作。在成功请求的情况下，您将收到以下响应：
- en: '[PRE34]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the service is not available and the account doesn’t exist, you will get
    errors. We didn’t cover exception handling in this chapter, but we’ll learn about
    it in our upcoming chapters.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务不可用且账户不存在，您将收到错误。我们没有在本章中涵盖异常处理，但我们将在我们即将到来的章节中学习它。
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Another microservice journey ends here. The main points in this chapter were
    creating a second microservice and establishing synchronous communication between
    microservices. We started our chapter with business requirements. After getting
    a clear understanding of what we should do, we started to introduce main stack
    tools to develop our transaction microservice. We didn’t use the tools we used
    before to develop our account service. JavaScript has really rich tools and frameworks
    to use when it comes to developing microservices. To demonstrate the beauty of
    having multiple tools, we used NestJS with some popular packages such as Prisma
    and Axios. In the end, we established communication with an already existing microservice
    (the account microservice) using a synchronous communication model. Of course,
    we still missed out a lot. We didn’t cover exception handling, resiliency, and
    a lot of other interesting topics that we plan to introduce in our upcoming chapters.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 另一次微服务之旅在这里结束。本章的主要内容是创建第二个微服务并在微服务之间建立同步通信。我们以业务需求开始本章。在明确了解我们应该做什么之后，我们开始介绍用于开发事务微服务的主要工具栈。我们没有使用之前开发账户服务时使用的工具。当涉及到开发微服务时，JavaScript
    确实拥有丰富的工具和框架。为了展示拥有多个工具的美丽之处，我们使用了 NestJS 以及一些流行的包，如 Prisma 和 Axios。最后，我们使用同步通信模型与一个已经存在的微服务（账户微服务）建立了通信。当然，我们仍然遗漏了很多。我们没有涵盖异常处理、弹性以及我们计划在后续章节中介绍的其他许多有趣话题。
- en: '[*Chapter 7*](B09148_07.xhtml#_idTextAnchor121) explores how to implement asynchronous
    communication in JavaScript microservices using Apache Kafka and NestJS, focusing
    on building scalable systems, configuring Kafka, and adapting services like transaction
    and account services for asynchronous messaging.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B09148_07.xhtml#_idTextAnchor121) 探讨了如何使用 Apache Kafka 和 NestJS 在 JavaScript
    微服务中实现异步通信，重点关注构建可扩展的系统、配置 Kafka 以及为事务和账户等服务适配异步消息。'
