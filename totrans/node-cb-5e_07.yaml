- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persisting to Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of application development, being able to save and retrieve data
    is essential. Imagine you’re building a game where you need to keep scores or
    a social media application where users need to save their profiles and posts.
    A lot of the time, a traditional relational database is what you need for this.
    It’s like an organized filing system where everything has its place in neat tables,
    and these tables can relate to each other in specific ways. For instance, one
    table might store information about books while another stores information about
    authors, and links between the two can show which author wrote which book.
  prefs: []
  type: TYPE_NORMAL
- en: But what if your data doesn’t fit into this structured format? What if you’re
    dealing with something more flexible or unpredictable, such as posts on a social
    media feed where some posts have images, some have videos, and others have just
    text? This is where non-relational, or NoSQL, databases come in. They’re designed
    to handle a wide variety of data structures, from simple key-value pairs to more
    complex documents or graphs. This makes them a great choice for modern applications
    that require flexibility and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on interacting with these databases in Node.js. As such,
    some elementary knowledge of databases and **Structured Query Language** ( **SQL**
    ) is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with setting up a simple SQL database to understand the fundamentals
    of database operations. Then, we’ll explore the dynamic world of NoSQL databases,
    learning how to interact with them to handle more flexible data structures. By
    the end of this chapter, you’ll have a foundation in using diverse types of databases
    in your Node.js applications, giving you the flexibility to choose the right storage
    solution for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and persisting to a MySQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and persisting to a PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and persisting to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will use Docker to provision databases in containers.
    Using a database container is common when building scalable and resilient architectures
    – particularly when using a container orchestrator such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: However, the main reason why we’ll be using Docker containers throughout this
    chapter is to save us from having to manually install each of the database **command-line
    interfaces** ( **CLIs** ) and servers onto our system. In this chapter, we will
    be using Docker to provision containerized MySQL, PostgreSQL, MongoDB, and Redis
    data stores.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to install Docker Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: If you are unable to install Docker, then you can still complete the recipes,
    but you will need to manually install the specific databases for each recipe or
    connect to a remote database service.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this chapter will not cover how to enable persistent data storage
    from Docker containers, as this requires knowledge of Docker that is out of scope
    for a Node.js tutorial. Therefore, once the containers are destroyed or removed,
    the data accrued during the tutorials will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also be worthwhile cleaning up and removing your database containers
    once you’ve completed each recipe by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter **$ docker ps** in your terminal to list your Docker containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, locate the container identifier and pass this to the **$ docker
    stop <ContainerID>** command to stop the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow it up with **$ docker rm --force <ContainerID>** to remove the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the following command to remove all Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Take caution when using this command if you have other Docker containers, unrelated
    to the recipes in this book, running on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Docker refers to both the virtualization technology and the company Docker Inc.
    that created the technology. Docker allows you to build applications and services
    into packages named containers. Refer to [*Chapter 11*](B19212_11.xhtml#_idTextAnchor353)
    for more detailed information about the Docker technology.
  prefs: []
  type: TYPE_NORMAL
- en: In several of the recipes, we will also make use of the **dotenv** module (
    [https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv) ).
    The **dotenv** module loads environment variables from a **.env** file into the
    Node.js process. Where necessary, we will be storing example database credentials
    in a **.env** file and then using the **dotenv** module to parse these into our
    Node.js process.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to have Node.js installed, preferably the latest version,
    Node.js 22, and access to an editor and browser of your choice. The code samples
    produced for this chapter are available on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter07** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and persisting to a MySQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a standard for communicating with relational databases. Both MySQL (
    [https://www.mysql.com/](https://www.mysql.com/) ) and PostgreSQL ( [https://www.postgresql.org/](https://www.postgresql.org/)
    ) are popular open source **relational database management systems** ( **RDBMSs**
    ). There are many implementations of SQL databases, and each of them has its extensions
    and proprietary features. However, there is a base set of commands for storing,
    updating, and querying data implemented across all these SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to communicate with a MySQL database from Node.js
    using the **mysql2** ( [https://www.npmjs.com/package/mysql2](https://www.npmjs.com/package/mysql2)
    ) module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to get a MySQL database running locally. To do this, and for
    the other databases in this chapter, where possible, we will use Docker. MySQL
    provides a Docker official image on Docker Hub ( [https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql)
    ). This recipe assumes some, but minimal, prior knowledge of SQL and relational
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we will use the **mysql2** package from **npm** for interacting
    with MySQL databases in Node.js due to its compatibility with the latest MySQL
    features and its support for promises. The choice of **mysql2** over the previously
    used **mysql** package is driven by it being more up to date, allowing us to leverage
    newer features and capabilities such as the **Promise** and **async** / **await**
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a MySQL database using Docker and prepare your project, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal window, type the following command to start a MySQL database
    listening on port **3306** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **--publish 3306:3306** option in a Docker command maps port **3306** on
    the host machine to port **3306** on the Docker container, allowing external access
    to the container’s service running on that port.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have the images locally, then Docker will first pull down the
    image from Docker Hub. While Docker is pulling down the image, expect to see output
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **--detach** argument indicates that we wish to start the container in detached
    mode – this means that the container is running in the background. Omitting the
    **--detach** argument would mean your terminal window would be held by the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a new directory for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we will be installing modules from **npm** , we also need to initialize
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also prepare two files for use in the recipe. The first will be a script
    named **setupDb.mjs** to create the database; the second will be a script to add
    a new task to the database, named **task.mjs** . While we’re here, let’s also
    create a **.env** file ready to store our database credentials:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the example credentials for our MySQL instance to the **.** **env** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be aware these are example credentials for simplicity – you should use stronger
    credentials in your applications. Also, be sure not to accidentally commit **.env**
    files to **version control systems** ( **VCSs** , such as Git) as this can lead
    to leaking of sensitive credentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the MySQL database running and our project initialized, we’re
    ready to move on to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll be focusing on how to install the **mysql2** module from
    **npm** , connect to a MySQL database, and perform basic SQL queries. We’ll use
    a straightforward task list example to illustrate these concepts. We’ll also be
    using **ECMAScript Modules** ( **ESM** ) syntax, covered in the *Using ECMAScript
    modules* recipe of [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) .
  prefs: []
  type: TYPE_NORMAL
- en: This approach should help you understand the practical application of managing
    and manipulating data with SQL in a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the **dotenv** module, for parsing environment variable
    configuration, and the **mysql2** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll start by writing a script to set up our task list database. To do this,
    we’ll first need to import and load our credentials using the **dotenv** module
    and import the **mysql2** module. Add the following to **setupDb.mjs** to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s scaffold a **main()** function. We will add the logic to this function
    as we progress through the tutorial steps. Add the following to **setupDb.mjs**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s start adding our connection logic, and we’ll wrap this in a **try**
    / **catch** / **finally** structure where **finally** will close the database
    connection. Within the **main()** function, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run this file in our terminal to test the connection:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add our logic to create tables. To do this, we’ll use two separate
    SQL statements. The first will create a database and instruct the connection to
    use it. The second will create a **tasks** database table. Add the following to
    the **main()** function, below the **console.log(''Connected as ...** line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program in your terminal with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can implement our logic in **tasks.mjs** to input some data into our
    table, again via a SQL query. Start by copying the same connection logic we used
    in **setupDb.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we end the connection to our MySQL database using **connection.end()**
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can add some logic to receive the task details from the command line.
    Add the following logic below the **console.log(''Connected** **as** … line :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a query that will obtain the contents of the **tasks** table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time we run the program, our insert query will be executed, meaning a new
    entry will be made in the **tasks** table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **createConnection()** method exposed from the **mysql2** module establishes
    a connection to the MySQL server based on the configuration and credentials passed
    to the method. In the recipe, we passed the **createConnection()** method the
    username and password for our database using environment variables. The **mysql2**
    module defaults to looking for a MySQL database at **localhost:3306** , which
    is where the MySQL Docker container that we created in the *Getting ready* section
    of the recipe was exposed. The **mysql2** module from **npm** aims to provide
    equivalent functionality to the preceding **mysql** module from **npm** . A complete
    list of options that can be passed to the **createConnection()** method is available
    in the **mysql** module API documentation at [https://github.com/mysqljs/mysql#connection-options](https://github.com/mysqljs/mysql#connection-options)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Connection pools can also be utilized to minimize the time needed to connect
    to the MySQL server by reusing existing connections instead of closing them after
    use. This approach enhances query latency by eliminating the overhead associated
    with setting up new connections. Such a strategy is crucial for the development
    of large-scale applications. For more details, consult the API documentation at
    [https://sidorares.github.io/node-mysql2/docs#using-connection-pools](https://sidorares.github.io/node-mysql2/docs#using-connection-pools)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the recipe, we used the **query()** method to send SQL statements
    to the MySQL database. The SQL statements in the **setupDb.mjs** file created
    a **tasks** database and a **tasks** table. The **task.mjs** file included SQL
    to insert a single task into the **tasks** table. The final SQL statement we sent
    to the database using the **query()** method was a **SELECT** statement, which
    returned the contents of the **tasks** table.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the SQL statements is queued and executed asynchronously. It is possible
    to pass a callback function as a parameter to the **query()** method, but we instead
    leverage the **async** / **await** syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The **end()** method, as the name suggests, ends the connection to the database.
    The **end()** method ensures that there are no queries still queued or processing
    before ending the connection. There’s another method, **destroy()** , that will
    immediately terminate the connection to the database, ignoring the state of any
    pending or executing queries.
  prefs: []
  type: TYPE_NORMAL
- en: One of the common types of attacks on user-facing web applications that it is
    necessary to be aware of is SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: A SQL injection is where an attacker sends malicious SQL statements to your
    database. This is often achieved by inserting the malicious SQL statement into
    a web page input field. This is not a Node.js-specific problem; it also applies
    to other programming languages where the SQL query is created through string concatenation.
    The way to mitigate against any of these attacks is to sanitize or escape user
    input such that our SQL statements cannot be maliciously manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manually escape user-supplied data directly by using **connection.escape()**
    . In the recipe, however, we used the placeholder ( **?** ) syntax in our SQL
    query to achieve the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The **mysql2** module handles the sanitizing of user input for us if we pass
    our input values to the query via the second parameter of the **query** function.
    Multiple placeholders ( **?** ) are mapped to values in the SQL query in the order
    they are supplied.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building on the basics of interacting with MySQL with Node.js, this section
    introduces how to create a REST API using Fastify in conjunction with MySQL. We’ll
    walk through essential steps such as setting up the project, starting a Fastify
    server, connecting it to MySQL with the **@fastify/mysql** plugin ( [https://www.npmjs.com/package/@fastify/mysql](https://www.npmjs.com/package/@fastify/mysql)
    ), and creating routes to handle **create, read, update, delete** ( **CRUD** )
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have a MySQL database available. For this, we will reuse the database
    we created in the main recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new directory for the **fastify-mysql** project and
    initialize it with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install **fastify** and the **@fastify/mysql** plugin using **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **server.js** in your project root. This file will configure
    the Fastify server, connect to the MySQL database, and define the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by requiring Fastify – we’ll also enable logging:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can register the **@fastify/mysql** plugin we installed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the connection string contains the credentials of our MySQL database
    – ideally, this connection string should be stored in a **.env** file as covered
    in previous recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s register a route to return all tasks in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll add the logic to run the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s start the Fastify MySQL application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test your API, open a new terminal window while your server is running and
    use **curl** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tutorial provided a basic introduction to creating a REST API with Fastify
    and MySQL, covering project setup, initializing the server, connecting to the
    database, and retrieving items from the database. Fastify provides equivalent
    plugins for the other databases utilized in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Persisting data with Redis* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19212_09.xhtml#_idTextAnchor274)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and persisting to a PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostgreSQL, first introduced in 1996, is a powerful open source object-relational
    database system that has stood the test of time due to its reliability, feature
    robustness, and performance. One of PostgreSQL’s standout features is its ability
    to be utilized as both a traditional relational database, where data is stored
    in tables with relationships among them, and as a document database, such as NoSQL
    databases, where data can be stored in JSON format. This flexibility allows developers
    to choose the most appropriate data storage model based on their application’s
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this tutorial, we will explore the basics of interacting with a PostgreSQL
    database from a Node.js application. We’ll use the **pg** module, a popular and
    comprehensive PostgreSQL client for Node.js. The **pg** module simplifies connecting
    to and executing queries against a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we will need a PostgreSQL server to connect to. We will use
    Docker to provision a containerized PostgreSQL database. Refer to the *Technical
    requirements* section of this chapter for more information about using Docker
    to provision databases.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the Docker official PostgreSQL image from [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will initialize our PostgreSQL server and prepare our project
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal window, type the following to provision a **postgres** container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming you do not have a copy of the PostgreSQL image locally, expect to
    see the following output while Docker downloads the image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should now have a PostgreSQL database listening on port **5432** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll set up a directory and files ready for our PostgreSQL application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we’ll be using a third-party module, we’ll also need to use **npm** to initialize
    a project. Let’s just accept the defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’re ready to move on to the recipe, where we will be using the **pg**
    module to interact with our PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be installing the **pg** module to interact with our
    PostgreSQL database using Node.js. We will also send some simple queries to our
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the third-party **pg** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also be using the **dotenv** module in this recipe; install that with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also use the **.env** file to store our PostgreSQL database credentials
    and use the **dotenv** module to pass them to our program. Add the following credentials
    to **.env** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open **tasks.js** and import our environment variables using the **dotenv**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in **tasks.js** , we need to import the **pg** module and create a PostgreSQL
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s allow our program to handle input via a command-line argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll define the SQL queries we’re going to be using as constants. This
    will improve the readability of our code later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **SELECT * FROM tasks;** SQL query returns all tasks in the **tasks** table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll add the following code to connect to our database. Create a **tasks**
    table if it doesn’t already exist, insert a task, and finally, list all tasks
    stored in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll create our **listTasks()** function, which will use **GET_TASKS_SQL**
    . This function will also end the connection to our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run **tasks.js** , passing a task as a command-line argument. The task will
    be inserted into the database and listed out before the program ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also run the program without passing a task. When we run **tasks.js**
    with no **task** parameter, the program will output the tasks stored in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By following these steps, you’ve gained an understanding of how to integrate
    PostgreSQL with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Getting ready* section of this recipe, we provisioned a containerized
    PostgreSQL database using the Docker official image from Docker Hub. The provisioned
    PostgreSQL database was provisioned in a Docker container named **node-postgres**
    . By default, the PostgreSQL Docker image creates a user and database named **postgres**
    . The Docker command we used to provision the database instructed the container
    to make the PostgreSQL database available at **localhost:5432** with a placeholder
    password of **PASSWORD** .
  prefs: []
  type: TYPE_NORMAL
- en: The configuration information required for a connection to our PostgreSQL database
    was specified in the **.env** file. We used the **dotenv** module to load this
    configuration information as environment variables to our Node.js process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we didn’t have to directly pass any of the environment variables
    to the client. This is because the **pg** module automatically looks for specifically
    named variables ( **PGHOST** , **PGPORT** , and **PGUSER** ). However, if we wanted,
    we could specify the values when we create the client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We use the **connect()** method to connect to our PostgreSQL database. We provide
    this method with a callback function to be executed once the connection attempt
    is complete. We added error handling within our callback function so that if the
    connection attempt fails, then an error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the remainder of the program, we use the **query()** method provided
    by the **pg** module to execute SQL queries against the PostgreSQL database. Each
    of our calls to the **query()** method is supplied with a callback function to
    be executed upon completion of the query.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as storing traditional relational data, PostgreSQL also provides the
    ability to store object data. This enables the storing of relational data alongside
    document storage.
  prefs: []
  type: TYPE_NORMAL
- en: We can adapt the program we created in the *Connecting and persisting to a PostgreSQL
    database* recipe to handle both relational and object data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the **postgres-app** directory to a directory called **postgres-object-app**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll edit our SQL queries to create a new table named **task_docs** that
    stores document data. Change your SQL query constants to the following in our
    **tasks.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when we run our application, we can pass it JSON input to represent the
    task. Note that we will need to wrap the JSON input in single quotes, and then
    use double quotes for the key-value pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **doc** field was created with the **jsonb** type, which represents the
    JSON binary type. PostgreSQL provides two JSON data types: **json** and **jsonb**
    . The **json** data type is like a regular text input field but with the addition
    that it validates the JSON. The **jsonb** type is structured and facilitates queries
    and indexes within the document objects. You’d opt for the **jsonb** data type
    over the **json** data type when you require the ability to query or index the
    data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Based on this example, a **jsonb** query would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re able to query against the **task** property within the document
    object. For more information about the **jsonb** data type, refer to the official
    PostgreSQL documentation at [https://www.postgresql.org/docs/9.4/datatype-json.html](https://www.postgresql.org/docs/9.4/datatype-json.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Persisting data with Redis* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and persisting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a NoSQL database management system built around a document-oriented
    model. Data is stored in flexible, JSON-like documents called **Binary JSON**
    ( **BSON** ), which are organized into **collections** , analogous to tables in
    relational databases. Each document within a collection can have a different structure,
    allowing for dynamic schemas and easy modification of data models.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB supports powerful querying capabilities using its query language, which
    includes various operators and methods for filtering, sorting, and manipulating
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use a book/author example using the MongoDB Node.js driver
    directly. We’ll write functions to create and find authors and books within our
    MongoDB database. This script will illustrate basic CRUD operations without the
    use of a web framework, focusing purely on database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up a MongoDB database with Docker and get your project directory ready
    for the application, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other databases in this chapter, we will be using Docker to provision
    a MongoDB database using the MongoDB Docker image available at [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assuming you do not have a copy of the MongoDB image locally, expect to see
    the following output while Docker downloads the image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also create a directory for the MongoDB Node.js application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this recipe, we will need to install modules from the **npm** registry,
    so we need to initialize our project with **$** **npm init** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **index.js** ; this will contain our application code that
    interacts with MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our database running and the project initialized, we’re ready
    to move on to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be using the **mongodb** module to demonstrate how we
    can interact with our MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the **mongodb** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we’ll add the logic to the **index.js** file to establish a connection
    to our MongoDB database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will craft a function to insert an author into the **authors** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to insert a book into the **books** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to find all authors in the **authors** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to find all books and populate them with author details using
    an aggregation pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will use the **createAuthor()** , **createBook()** , **findAllAuthors()**
    , and **findAllBooksWithAuthors()** functions in the **main()** function to perform
    the operations in sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we built a Node.js script that serves as a functional interface
    to interact with a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the recipe, we begin by importing the necessary modules, notably the **MongoClient**
    class from **npm** ’s **mongodb** module. Setting up the MongoDB connection involves
    defining a URI to connect to the local MongoDB server and initializing a **MongoClient**
    instance with this URI. In our case, our database was hosted on the typical default
    host and port for MongoDB: **mongodb://localhost:27017** .'
  prefs: []
  type: TYPE_NORMAL
- en: Note that MongoDB does not enable authentication by default when using Docker,
    so no authentication parameters were needed in the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: The **connectToMongoDB()** function asynchronously attempts to establish a connection
    to the MongoDB server, logging success or failure messages accordingly and returning
    a reference to the specified database if successful.
  prefs: []
  type: TYPE_NORMAL
- en: The **mongodb** module from **npm** exposes a vast range of CRUD methods to
    interact with the MongoDB collections in your MongoDB database. The term *CRUD*
    is used to represent the basic functions for persistent storage. In this recipe,
    we used the **find()** and **insertOne()** CRUD methods. A full list of available
    methods is defined in the Node.js MongoDB driver API documentation ( [https://mongodb.github.io/node-mongodb-native/6.5/](https://mongodb.github.io/node-mongodb-native/6.5/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: We also used the **aggregate()** method in the **findAllBooksWithAuthors()**
    function. An aggregation pipeline can contain one or more stages to create a flow
    of operations that processes, transforms, and returns results.
  prefs: []
  type: TYPE_NORMAL
- en: The **main()** function orchestrates the execution flow, starting with connecting
    to the MongoDB database. Upon successful connection, it proceeds to create an
    author document for **Richard Adams** and a corresponding book document titled
    **Watership Down** , associating them together. Subsequently, it retrieves all
    authors and books with their associated author details using the defined functions.
    Error handling is implemented throughout the script using **try** / **catch**
    blocks to handle any potential errors that may arise during execution. Finally,
    the script concludes by closing the MongoDB client connection.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this script serves as a practical example of how to utilize Node.js
    and the **mongodb** package to perform CRUD operations on a MongoDB database,
    demonstrating basic functionalities such as connecting to the database, inserting
    documents, querying collections, and handling errors effectively.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Persisting data with Redis* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is an open source in-memory key-value data store. Used in the correct
    setting, Redis can be a fast-performing data store. It is often used to provide
    caching in applications but can also be used as a database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redis** , an acronym for **Remote Dictionary Server** , is an in-memory data
    structure store, often used as a database, cache, and message broker. It excels
    in scenarios requiring high speed and efficiency, such as caching, session management,
    real-time analytics, and message queuing. Redis’s ability to support various data
    structures, combined with its atomic operations and **publish/subscribe** ( **pub/sub**
    ) messaging capabilities, makes it a powerful tool for enhancing the performance
    and scalability of Node.js applications. Its in-memory nature ensures rapid access
    to data, significantly reducing latency compared to traditional disk-based databases,
    making it ideal for applications where speed is critical.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Node.js, Redis is particularly valuable for managing session
    data in web applications, enabling quick data retrieval, and improving user experience.
    It’s also widely used for implementing caching mechanisms, reducing the load on
    databases, and speeding up response times. Moreover, its pub/sub messaging system
    facilitates the development of real-time applications, such as chat applications
    or live notifications, by allowing efficient communication between clients and
    servers. Whether you’re looking to optimize your application’s performance, scale
    efficiently, or build feature-rich real-time interactions, integrating Redis with
    Node.js offers a robust solution to meet these needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into Redis module integration, it’s essential to note that we’ll
    be using ESM for compatibility. For more information on modules, refer to [*Chapter
    5*](B19212_05.xhtml#_idTextAnchor139) .
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous databases in this chapter, we will use Docker to provision
    a Redis database, based on the Docker image available at [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
    . Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, the containerized Redis database will be available at **localhost:6379**
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will also create a new folder named **redis-app** containing a file named
    **tasks.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this recipe, we will be making use of third-party **npm** modules; therefore,
    we need to initialize our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have Redis running and our project set up, we’re ready to move on
    to the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be using the **redis** module to interact with our Redis
    data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the third-party **redis** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to import and create a Redis client in **tasks.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also accept command-line input for our task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll add an **error** event handler to catch any errors that occur on
    our Redis client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to initialize the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll add a statement that will control the flow of our program. If a
    task is passed as input to our program, we will add this task and then list the
    tasks stored in Redis. If no task is supplied, then we will just list the stored
    tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below this **if** statement, we will create our **addTask()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, after the **addTask()** function, we’ll add our **listTasks()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the program with a task passed as command-line input. The task
    will be stored in Redis and subsequently printed via the **listTasks()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now persisted data in our Redis data store using the **redis** module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **createClient()** method initializes a new client connection. This method
    will default to configuration for a Redis instance at **localhost:6379** , where
    **6379** is the conventional port for Redis. In previous versions of the **redis**
    module from **npm** , the **createClient()** method would automatically connect
    to the server. However, it’s now necessary to explicitly call **client.connect()**
    to establish a connection.
  prefs: []
  type: TYPE_NORMAL
- en: Within our **addTask()** function, we generate a random string, or hash, to
    append to our task key. This ensures that each task key is unique, while still
    having a specifier indicating that it is a task to aid debugging. This is a common
    convention when using Redis.
  prefs: []
  type: TYPE_NORMAL
- en: The **hSet()** method sets the key and value in Redis; this is what stores our
    task in Redis. If we supplied a key that already existed, this method would overwrite
    the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The legacy **hmset()** method is considered deprecated in newer versions of
    Redis. The **hSet()** method used in the recipe should be used for setting hash
    values.
  prefs: []
  type: TYPE_NORMAL
- en: In the **listTasks()** function, we use the **keys()** method to search for
    all keys stored in our Redis data store that match the **Tasks:*** wildcard. We’re
    leveraging the **keys()** method to list all tasks we have stored in Redis. Note
    that the **keys()** method in real applications should be used with caution. This
    is because, in applications with many keys, searching could have negative performance
    implications.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all our task keys, we use the **hGetAll()** method to return the
    value at each key. Once obtained, we print this value to **STDOUT** using **console.log()**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The **redis** module **npm** provides a one-to-one mapping of all available
    Redis commands. Refer to [https://redis.io/commands](https://redis.io/commands)
    for a complete list of Redis commands.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Redis instance you’re interacting with may require authentication. Let’s
    look at how we can connect to a Redis instance that requires a password.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with Redis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect to a Redis client that requires authentication, we can supply the
    credentials via the **createClient()** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, again, use Docker to create a password-protected Redis instance. This
    Redis container will be available at **localhost:6380** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the **tasks.mjs** file into a new file named **tasks-auth.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to pass the new Redis instance’s configuration information to
    the **createClient()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as before, we can run the program with a task passed as command-line input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that as we’re pointing to a different Redis instance, it will not contain
    the tasks we added in the main recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions with Redis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **redis** module exposes a method named **multi()** that can be used to
    create a **transaction** . A transaction is a series of commands that are queued
    and then executed as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could use the following to update a task as a transaction by
    executing a **get()** , **set()** , **get()** sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Each of the tasks is queued until the **exec()** method is executed. If any
    command fails to be queued, none of the commands in the batch are executed. During
    the **exec()** method, all commands are executed in order.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL serves as a query language for APIs and provides a runtime environment
    for executing queries. Unlike REST, which relies on rigid endpoint structures,
    GraphQL allows clients to request exactly what they need and nothing more, making
    it efficient for fetching data. This flexibility reduces the amount of data transferred
    over the network and allows for more precise and optimized queries.
  prefs: []
  type: TYPE_NORMAL
- en: In projects where your application deals with complex, interrelated data structures,
    such as social networks, e-commerce platforms, or **content management systems**
    ( **CMSs** ), GraphQL’s ability to query deeply nested data in a single request
    makes it a perfect match with Node.js. This combination reduces the need for multiple
    REST endpoints and minimizes data over-fetching, optimizing both the network performance
    and the developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we will create a simple GraphQL API with a book and author
    relationship using Fastify and Mercurius ( [http://npmjs.com/package/mercurius](http://npmjs.com/package/mercurius)
    ), a GraphQL adapter for Fastify. This tutorial will guide you through setting
    up your Node.js project, installing dependencies, defining your GraphQL schema,
    implementing resolvers, and running your server. We’ll use a simple in-memory
    data structure to simulate a database for authors and books.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the creation of a GraphQL API using Fastify and Mercurius,
    you’ll need to set up your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new directory for your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the Node.js project with **npm** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With your environment ready and dependencies installed, let’s move on to the
    recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re now ready to build the core functionality of our Fastify GraphQL API.
    This part of the process involves defining our data models, setting up a GraphQL
    schema, writing resolvers to handle data fetching, and finally, starting our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by installing the necessary modules. Our GraphQL server will need
    a few dependencies to run. Specifically, we will be using Fastify as the web framework
    and Mercurius as the GraphQL adapter. Install these by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create some mock data to work with. This will help us test
    our GraphQL API without needing a database. In your project folder, create a file
    named **data.js** . This file will contain arrays of authors and books, establishing
    a simple relationship between them where each book is linked to an author:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following to **data.js** to populate some author and book data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create a GraphQL schema to represent our author and book relationship
    and queries. Create a file named **schema.graphql** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following GraphQL schema to **schema.graphql** :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a file named **resolvers.js** . This file will contain functions
    to handle the logic for fetching the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement our GraphQL resolvers, add the following code to **resolvers.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can create our Fastify server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **server.js** :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start your Fastify server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your browser and navigate to **http://localhost:3000/graphiql** to access
    the GraphiQL interface. You should expect to see an interface like this:![Figure
    7.1 – GraphiQL interface showing query result](img/B19212_07_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.1 – GraphiQL interface showing query result
  prefs: []
  type: TYPE_NORMAL
- en: 'Try crafting some queries in the GraphiQL interface. For example, try executing
    the following query to fetch all books with their authors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see this output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.2 – GraphiQL interface showing query result](img/B19212_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – GraphiQL interface showing query result
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial provides you with a foundation for creating a GraphQL API using
    Fastify and Mercurius. From here, you can extend your API by adding more complex
    types, queries, and mutations or by integrating a database for persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the tutorial, we explore the creation of a GraphQL API using Fastify and
    Mercurius by defining data models, establishing a GraphQL schema, implementing
    resolvers for data fetching, and setting up a Fastify server.
  prefs: []
  type: TYPE_NORMAL
- en: By creating mock data in **data.js** , we simulate a backend data store that
    contains authors and books. This approach allows us to focus on the GraphQL setup
    without the complexity of integrating an actual database. The data represents
    a basic relationship between books and their authors, serving as the foundation
    for our GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL schema defined in **schema.graphql** acts as a contract between
    the server and the client. It specifies the types of queries that can be made,
    the types of data that can be fetched, and the relationships between different
    data types. In our case, the schema outlines how to query books and authors and
    indicates that each book is linked to an author and vice versa. This structure
    allows clients to understand and predict the shape of the data returned by the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The resolvers in **resolvers.js** are functions that handle the logic for fetching
    the data for each type specified in the schema. They connect the GraphQL queries
    to the underlying data, essentially telling the server where and how to retrieve
    or modify the data. In the recipe, resolvers fetch books and authors from the
    mock data and resolve the relationships between them, such as finding an author
    for a book or listing all books written by an author.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, setting up the Fastify server and integrating Mercurius allows us to
    serve our GraphQL API over HTTP. The server listens for requests on a specified
    port and uses the schema and resolvers to process GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Upon running the server, you can navigate to the GraphiQL interface to visually
    construct and execute queries against your API. This interactive environment is
    useful for testing and debugging queries.
  prefs: []
  type: TYPE_NORMAL
- en: Whether GraphQL is the appropriate architecture for your project is a vast topic
    that goes well beyond the basics covered in this recipe. It involves deep considerations
    such as optimizing query performance, ensuring security, efficient data loading
    to avoid over- or under-fetching, and integrating with different databases or
    APIs. While we’ve laid the groundwork with Fastify and Mercurius, diving into
    these more complex aspects is essential for developing sophisticated, production-ready
    GraphQL services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19212_11.xhtml#_idTextAnchor353)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
