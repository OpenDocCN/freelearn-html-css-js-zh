- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s digital world, many applications are built from smaller, independent
    services working together. These *microservices* offer flexibility and scalability,
    but keeping them secure is crucial. Imagine a microservice as a small shop on
    a busy street. You want to ensure that only authorized customers can enter (authentication)
    and only those with permission can access specific areas (authorization). Likewise,
    you’d encrypt sensitive information such as credit card details (data encryption).
    By constantly monitoring for suspicious activity and keeping the shops updated
    (patching), you can maintain a safe and secure shopping experience. This chapter
    will guide you through securing your microservices using similar practical strategies
    and more!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Security, authentication, and authorization in microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with JSON Web Tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an Authentication Microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along in the chapter, you need to have installed an IDE (we prefer
    Visual Studio Code), Postman, Docker, and a browser of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: It is preferable to download our repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09)
    to easily follow our code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Security, authentication, and authorization in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a microservices architecture, ensuring robust security, authentication, and
    authorization is crucial due to the distributed nature of the system. Implementing
    these mechanisms properly protects microservices from unauthorized access, ensuring
    data integrity and confidentiality across the system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In microservices, **security** refers to the measures and practices used to
    protect the system’s components, data, and communication channels from unauthorized
    access, breaches, and attacks. It involves securing each service individually,
    as well as the interactions between services, ensuring data is safe both in transit
    and at rest. Security in microservices typically includes mechanisms such as encryption,
    authentication, authorization, and monitoring to safeguard the system against
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices, while offering advantages in flexibility and scalability, introduce
    unique security challenges. Unlike monolithic applications with a single attack
    surface, microservices create a distributed system with many potential entry points
    for attackers. That is why security becomes even more important compared to monolithic
    applications. A security breach in one microservice can quickly compromise the
    entire system. Before deploying our services, we should provide a properly tested
    and fully functional security layer over our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authentication** is a process of verifying a user’s or service’s identity,
    and it plays a critical role in securing microservice applications. In a world
    of distributed systems with numerous access points, authentication ensures that
    only authorized users and services can interact with your microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But why is authentication valuable in microservices? Let’s answer this question
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced security**: Microservices create a distributed attack surface. Robust
    authentication acts as a gatekeeper, preventing unauthorized access and potential
    breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Granular control**: Authentication allows you to define access levels for
    different users and services. This ensures that only authorized entities can perform
    specific actions within each microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved trust**: By implementing strong authentication, you build trust
    with users and external systems relying on your microservices. They can be confident
    their data is secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice communication security**: Authentication secures communication
    between microservices themselves. This prevents unauthorized services from impersonating
    legitimate ones and gaining access to sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying authentication is not hard thanks to the packages of Node.js but there
    are some microservice and authentication challenges you should consider before
    starting to apply it. We will discuss two of them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first challenge is choosing either a **centralized** or **decentralized**
    authentication service. Deciding on a centralized authentication service or embedding
    it within each microservice can be a challenge. There’s a trade-off between simplicity
    and potential bottlenecks. Let’s look at both of these types of services here:'
  prefs: []
  type: TYPE_NORMAL
- en: A centralized authentication service, also known as an **Identity Provider**
    (**IdP**), is a trusted third-party system that manages the authentication process
    for users across multiple applications or microservices. Instead of each microservice
    handling authentication independently, the IdP takes on this responsibility, offering
    a consistent, secure, and streamlined authentication mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A decentralized authentication service involves each microservice independently
    managing its own authentication process. Unlike a centralized system where a single
    IdP handles authentication, decentralized services allow each microservice to
    have its own embedded authentication logic, providing greater autonomy and flexibility
    to each service but introducing complexity in maintaining consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When choosing between centralized and decentralized authentication, consider
    factors such as application complexity, scalability needs, security tolerance,
    and development resources, as a centralized IdP simplifies security enforcement
    but adds complexity, while decentralized options require more development effort
    per microservice.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot pick one or the other, a *hybrid* approach might be more suited
    for your case. A hybrid approach can be a good option in some cases. A central
    IdP can handle user authentication and issue tokens, while individual microservices
    validate those tokens independently. This offers a balance between security, flexibility,
    and resilience. As we mentioned before, there’s no one-size-fits-all solution.
    Evaluate your specific requirements and choose the approach that best aligns with
    your security goals and development needs.
  prefs: []
  type: TYPE_NORMAL
- en: The second challenge can be session management. Traditional session management
    techniques might not be ideal for the stateless nature of microservices. Alternatives
    such as **JSON Web Tokens** (**JWTs**) are often preferred. We will talk about
    JWTs in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authorization** in microservices is critical for several reasons, primarily
    focusing on security, resource management, and compliance. It ensures that only
    users or services with the appropriate permissions can access or perform actions
    on specific resources or data. This prevents unauthorized access and potential
    misuse. By *enforcing* strict access controls, the potential attack surface is
    minimized. Unauthorized users are restricted from accessing sensitive parts of
    the system, reducing the risk of data breaches and other malicious activities.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices often deal with a wide range of functionalities and data. Authorization
    allows for granular control over who can access which service and what operations
    they can perform, ensuring resources are used appropriately. By *defining* clear
    access controls, resources are allocated and utilized more efficiently, preventing
    unauthorized consumption of resources that could degrade system performance.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservice architecture, each microservice is designed to perform a specific
    function. Authorization ensures that each service has access only to the data
    and operations it requires, promoting the principle of least privilege. This minimizes
    potential security risks and helps to maintain a secure, efficient system.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized authorization management can further streamline this process by
    defining and enforcing access policies uniformly across all services. This approach
    simplifies the maintenance and updating of access controls, making it easier to
    ensure consistency across the microservices ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to implement authorization, such as **Role-Based Access
    Control** (**RBAC**), **Attribute-Based Access Control** (**ABAC**), and **Policy-Based
    Access Control** (**PBAC**). While these are out of the scope of this book, by
    adopting the appropriate method, you can ensure that your system’s security policies
    are both robust and adaptable to your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Best practices are essential to ensure robust security, consistency, and efficiency
    in managing access controls and authorization across microservices. Let’s look
    at some of these best practices here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Least privilege principle**: Give only the permissions that users or services
    need to do their jobs, which helps reduce the chance of unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized authorization management**: Use a single system to manage who
    can access what across all microservices, making it easier to maintain and ensure
    security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regular audits and reviews**: Check and review who has access to what regularly
    to make sure everything is safe and up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reserve access**: Set permissions based on roles so users and services only
    have access to what matches their responsibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token expiration and revocation**: Use tokens that expire quickly and have
    a way to cancel them if needed, to lower the risk if a token is compromised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We delved into the critical importance of authorization in microservices and
    its role in maintaining security, resource management, and compliance. Now, let’s
    differentiate between authorization and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In microservices architectures, authorization plays a critical role in securing
    access to resources and data. Before diving into details, we need to understand
    and differentiate between the terms **authentication** and **authorization**.
    Authentication verifies the identity of a user or service trying to access the
    system. It typically involves checking credentials such as usernames and passwords,
    API keys, or tokens issued by an authorization server. It is similar to checking
    your ID at the entrance of a building.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, authorization determines what actions a verified user or
    service can perform within the system. It Involves enforcing predefined rules
    based on user roles, permissions, or attributes associated with the request. It
    is similar to how, once you’re verified to enter the building (authentication),
    your access card determines which floors or areas you can enter (authorization).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key differences between authentication and authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective**: Authentication answers *Who are you?*, while authorization answers
    *What can* *you do?*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timing**: Authentication typically happens first, followed by authorization
    checks on specific actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus**: Authentication deals with identity verification, while authorization
    focuses on access control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices and authorization**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In monolithic systems, authorization is often centralized. But microservices,
    with their distributed nature, require a more distributed approach to authorization.
    Here are some common strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**• Per-service authorization**: Each microservice manages authorization for
    its resources and data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**• API gateway**: A central API gateway can handle authorization checks before
    routing requests to individual services'
  prefs: []
  type: TYPE_NORMAL
- en: '**• Dedicated authorization service**: A separate service manages authorization
    policies and enforces them across all microservices'
  prefs: []
  type: TYPE_NORMAL
- en: Which one to select? Well, choosing the right approach depends on factors such
    as the complexity of your system, security requirements, and scalability needs.
    As we mentioned before, let’s learn about the JWT together. A JWT is widely used
    for authentication and authorization purposes in distributed systems such as microservices
    because it is stateless, meaning the server does not need to store session data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real world is constantly changing, and programs need to be adaptable to
    handle different situations. The elements of programs are also evaluated. The
    technique you used 10 years ago may not be valid nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, we used to use **session-based authorization**, which was simple,
    popular, easy to grasp, and easy to adapt. It is still a topic for discussion
    but we mostly prefer to use different types of authentication techniques that
    are more secure. Before switching to JWT, it is helpful to talk about session-based
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In this type of authentication, you enter your username and password. The server
    checks whether your credentials are valid. If valid, the server creates a session
    with a unique identifier (session ID). This session ID might be stored in a cookie
    on your browser. With each request to the website during that session, your browser
    sends the session ID back to the server. The server checks the session ID and
    grants access if it’s valid, allowing you to stay logged in. The session expires
    after a period of inactivity (e.g., 30 minutes) or when you log out. This invalidates
    the session ID.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **token-based authentication** offers several advantages
    over session-based authentication. Your sessions rely on the server storing information
    about each active user. This can become burdensome for applications with a large
    user base. Tokens, stored on the client side, alleviate this pressure on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The second important difference is that session-based authentication requires
    the server to maintain session data for each user. Token-based authentication
    is stateless, meaning the server only verifies the token itself, not referencing
    any stored user data. This simplifies server architecture and potentially improves
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: From the security perspective, tokens can be self-contained, including information
    such as expiry time and user roles. This reduces reliance on cookies, which can
    be vulnerable to theft. Additionally, tokens can be configured for short lifespans,
    minimizing the window of opportunity if compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important feature of tokens is flexibility. Tokens, such as JWTs, can
    embed additional data beyond just user identity. This allows for more granular
    control over access and simplifies authorization processes. Tokens can also be
    used for API calls between different services, whereas sessions are typically
    tied to a specific web application. JWTs are a compact, URL-safe means of representing
    claims to be transferred between two parties. It is commonly used for authorization
    purposes. A JWT is composed of three parts: header, payload, and signature. These
    parts are separated by dots (`.`) and encoded in Base64 URL format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **header** typically consists of two parts: the type of token (JWT) and
    the signing algorithm being used, such as *HMAC*-*SHA256* or *RSA*. Here is an
    example of a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The **payload** contains the claims. **Claims** are statements about an entity
    (typically, the user) and additional data. There are three types of claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss` (issuer), `exp` (expiration time), `sub` (subject), and `aud` (audience).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public claims**: Custom claims that can be defined by users. They should
    be collision-resistant names, such as using a URI or a namespace to avoid conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private claims**: Custom claims are created to share information between
    parties that agree to use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last element is the **signature**. To create the signature part, you have
    to take the encoded header, the encoded payload, a secret, and the algorithm specified
    in the header. The signature is used to verify that the sender of the JWT is who
    it says it is and to ensure that the message wasn’t changed along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you use the *HMAC-SHA256* algorithm, the signature will be
    created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output of the algorithm is three Base64-URL strings joined by dots that
    can be easily passed in HTML and HTTP environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of *HMAC-SHA256* output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have understood the various components of a JWT, let’s look at how
    it works in authentication with the help of the preceding example. A user logs
    in using their credentials. The server verifies the credentials and issues a JWT
    signed with a secret key. The client (usually a browser) stores the JWT (typically
    in local storage or a cookie).
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sends the JWT in the `Authorization` header of each subsequent request
    to access protected resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, it does token verification where the server verifies the token’s signature
    and checks its validity (expiration, issuer, etc.). If the token is valid, the
    server processes the request. Before moving on, it’s important to note that JWTs
    are stateless, compact, and self-contained, making them efficient for securely
    transmitting user information without server-side session storage. When using
    JWTs, ensure the secret key is secure, always transmit tokens over HTTPS, and
    use short-lived tokens with periodic refreshes to mitigate security risks. Now
    we know that JWTs are a powerful and flexible way to handle authentication and
    authorization in modern web applications, providing both security and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the theory, let’s move on to the practical part and implement
    the authentication microservice together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Authentication microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In microservices development, it’s a common practice to develop a separate
    microservice for authentication and authorization (often referred to as an Auth
    service). Here’s why it’s valuable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized security management**: Having a dedicated Auth service allows
    us to manage authentication and authorization logic in one place. This simplifies
    updates and security audits and ensures consistent rules across all microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The Auth service can be scaled independently based on its
    load, separate from other microservices with different resource requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: The Auth service can be reused by all your other microservices,
    reducing code duplication and promoting consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved maintainability**: Isolating authentication logic makes it easier
    to maintain and update the security aspects of your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Decoupling authentication and authorization from
    other microservices keeps their responsibilities focused, promoting cleaner code
    and better maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: A dedicated Auth service can be designed to support different
    authentication flows (e.g., OAuth, JWT) and authorization strategies (e.g., RBAC),
    providing a flexible foundation for your microservices architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s implement our Auth microservice together. We will use a classical approach
    to develop our new microservice via ExpressJS as we did before. Most of the things
    are the same. You should open/create a new folder anywhere you want on your computer
    and type `npm init -y` to initialize start our project. Throughout our development
    process, we will use the following libraries: `bcryptjs`, `dotenv`, `express`,
    `joi`, `jsonwebtoken`, and `mongoose`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `npm init -y` command does not automatically generate the scripts section
    in `package.json`. You’ll need to add it manually to simplify running the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bcryptjs`: This library provides secure password hashing and comparison functionalities.
    It allows you to store passwords securely in your database and verify user login
    attempts against the hashed passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotenv`: This library helps you load environment variables from a `.env` file.
    This is a secure way to store sensitive information such as API keys, database
    credentials, and your JWT secret key, keeping them out of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express`: This is a popular Node.js web framework that helps you build web
    applications and APIs. It provides a structured approach for handling requests,
    routing, middleware, and responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joi`: This library offers schema validation for data coming into your application.
    You can define validation rules for request bodies and ensure that the data received
    adheres to your expected format and structure, improving data integrity and preventing
    potential errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonwebtoken` (JWT): This library helps you work with JWTs. It allows you
    to generate tokens for authentication purposes, containing user information in
    a secure and verifiable format. You can use JWTs to authorize users for access
    to protected resources in your microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongoose`: This is an **Object Data Modeling** (**ODM**) library for MongoDB
    in Node.js. It provides a convenient way to interact with your MongoDB database
    by mapping your application data models to MongoDB documents. It simplifies data
    manipulation and retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a secure way to store user information, and a database is commonly used
    for this purpose. The `mongoose` package will help us to work with the database.
    To connect and disconnect from the database, create a new file called `index.js`
    under the `src/db` folder with the same content as we have in [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074).
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `src/models` folder, create a new file called `user.js` with the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this schema with additional information but to demo authentication
    and authorization, we need only these fields.
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked about `mongoose` in our previous chapters and that is
    why we will bypass already known details. The only new logic here is working with
    a hash password. When we create a user via API, we will provide an email and password.
    For security reasons, we need to hash passwords before storing them in our database.
  prefs: []
  type: TYPE_NORMAL
- en: The code that starts with `userSchema.pre("…")` is a `mongoose` middleware function
    that is executed before a user document is saved to the database. This middleware
    ensures that passwords are never stored in plain text in our database. It securely
    hashes passwords before saving them, making it computationally infeasible to recover
    the original password from the stored hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to provide a service layer that interacts with the database. For
    simplicity, you can bypass this layer, but to provide a full picture, we will
    have it. Under the `src/services` folder, create a new file called `user.js` with
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To make things simple, we haven’t implemented full CRUD operations. To demo
    our functionality, we only need a few of them such as `create` and `get user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s switch to our controller and see how we create a user. Under the
    `src/controllers` folder, create a new file called `user.js` with the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet defines an asynchronous function named `createUser` that
    handles user registration in your Node.js application. Here are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const createUser = async (req, res) => { ... }`: This defines an asynchronous
    function named `createUser` that takes two arguments, `req` (request object) and
    `res` (response object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const { email, password } = req.body;`: This extracts the `email` and `password`
    properties from the request body (`req.body`). These are assumed to be sent by
    the client in the registration request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const existingUser = await userService.getUserByEmail(email);`: This calls
    a function from `userService` (to check whether a user with the provided email
    already exists. It awaits the result (`existingUser`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (existingUser) { ... }`: If `existingUser` is not `null` (meaning a user
    with the email exists), it returns a `400 Bad Request` response with a message
    indicating the email conflict.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const user = await userService.createUser({ email, password });`: If the email
    is unique, it calls another function from `userService` (likely for user creation)
    with an object containing the extracted email and password. It awaits the result
    (`user`), which is the newly created user document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.status(201).json({ message: ''User created successfully'', user: user });`:
    If user creation is successful, it sends a `201 Created` response with a message
    and the newly created user object (`user`) in the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `try...catch` block: This wraps the core logic in a `try`-`catch` block to
    handle any potential errors during the registration process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status(500).json({ message: ''Server error'' });`: This sends a generic
    `500 Internal Server Error` response in case of any errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createUser`: This function provides a basic structure for user registration
    in our application. It checks for email conflicts, delegates user creation logic
    to a separate service, and handles successful and error scenarios with appropriate
    responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But creating a user is not enough. We need to implement sign-in/log-in functionality.
    In the same file, we have the following code to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines an asynchronous function named `loginUser` that handles user
    login in your Express.js application. Here’s a breakdown of what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const loginUser = async (req, res) => { ... }`: This defines an asynchronous
    function named `loginUser` that takes two arguments, `req` (request object) and
    `res` (response object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const { email, password } = req.body;`: This extracts the `email` and `password`
    properties from the request body (`req.body`). These are assumed to be sent by
    the client in the login request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const user = await userService.getUserByEmail(email);`: This calls a function
    from `userService` (likely another module) to fetch a user with the provided email.
    It awaits the result (`user`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (!user) { ... }`: If `user` is `null` (meaning no user found with the email),
    it returns a `401 Unauthorized` response with a message indicating invalid credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const isMatch = await bcrypt.compare(password, user.password);`: This uses
    `bcrypt.compare` to compare the provided password with the hashed password stored
    in the fetched user document (`user.password`). It awaits the result (`isMatch`),
    which is a boolean indicating whether the passwords match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if (!isMatch) { ... }`: If `isMatch` is `false` (meaning passwords don’t match),
    it returns a `401 Unauthorized` response with a message indicating invalid credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const configPath = path.join(__dirname, ''../../configs/.env'');`: This constructs
    the path to the environment variable file (assuming it’s located four folders
    above the current file).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const appConfig = createConfig(configPath);`: This calls a function to read
    and parse the environment variables from the `.``env` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const payload = { userId: user._id };`: This creates a payload object for
    the JWT containing the user’s ID. Include only essential user data here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const jwtSecret = appConfig.jwt.access_token;`: This retrieves the JWT access
    token secret from the parsed environment configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: ''1h''
    });`: This uses `jsonwebtoken` to sign the JWT with the payload, secret, and an
    expiration time of one hour (`expiresIn: ''1h''`). It awaits the generated token
    (`accessToken`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.status(200).json({ accessToken: accessToken });`: If login is successful,
    it sends a `200 OK` response with the generated `accessToken` in the response
    body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, the login function provides a secure login flow using JWT authentication.
    It fetches the user, validates credentials, generates a JWT with a secret key,
    and sends it back to the client for subsequent authorized access.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a fully functional login functionality, we need to provide
    the secret access token. In JWT, the secret access token plays a vital role in
    ensuring the integrity and authenticity of the token. When a JWT is created, a
    cryptographic hash algorithm (e.g., HMAC-SHA256) signs the header and payload
    (containing user information) using a secret access token. This secret key is
    like a password known only to the server that issued the JWT and the party verifying
    it. When a client sends a JWT in an authorization header to access a protected
    resource, the server receives the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server uses the same secret access token to verify the signature of the
    received JWT. This verification process ensures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The token has not been tampered with in transit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The token was indeed issued by a trusted source (the server that knows the secret).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the secret access token is compromised (e.g., leaked or stolen), anyone with
    the secret can forge valid-looking JWTs, potentially impersonating legitimate
    users and gaining unauthorized access to resources. Therefore, the secret access
    token is critical for maintaining the security of JWT-based authentication. Never
    store the secret access token in your code or within the application itself. Use
    environment variables or a dedicated secret management service to keep it confidential.
    Choose a cryptographically strong random string (ideally, at least 256 bits) for
    your secret access token to make it difficult to guess or crack. Consider rotating
    your secret access token periodically to mitigate the impact of a potential compromise.
    By following these practices, you can leverage the benefits of JWTs for secure
    authentication in your application while minimizing the risks associated with
    secret access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing access tokens, be careful to not to generate long-lived access
    tokens. Long-lived access tokens pose security risks because, if stolen, they
    allow attackers prolonged access, and revoking them is difficult. In contrast,
    refresh tokens offer better security by allowing short-lived access tokens to
    be issued, limiting potential damage. They also enable more granular control,
    as compromised tokens can be individually blacklisted without affecting other
    tokens, reducing the need for frequent authentication and lowering server load.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh tokens provide a good balance between user convenience (avoiding frequent
    logins) and security. Even though they have longer expirations compared to access
    tokens, their use is limited to obtaining new, short-lived access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing our refresh token, consider providing limited time for
    access tokens as short-lived access tokens reduce the risk of misuse if they are
    compromised, minimizing the window of opportunity for attackers. In this example,
    we set it to `5` minutes. After five minutes, the given access token will expire
    and we should send our refresh token to a new endpoint to obtain a new short-lived
    access token. First of all, let’s modify our login endpoint to return a refresh
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the same method to get both tokens. For refresh tokens, we set a bit
    longer period such as such as seven days. We will create a new endpoint to return
    new access tokens and that is why we need a new functionality in our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function lets users get a new access token (key to access resources) by
    providing a refresh token (like a spare key). It checks whether the refresh token
    is valid using a secret key. If valid, it can generate a new, short-lived access
    token (with a 5-minute expiration by default) for the user. This way, users don’t
    need to log in frequently but still maintain security with short-lived access
    tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice for storing refresh tokens involves a balance between security
    and user convenience. Here is what you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh tokens should not be stored in browser cookies due to their accessibility
    to JavaScript and potential theft through XSS attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using cookies, opt for `HttpOnly` cookies with the `Secure` flag set. This
    prevents JavaScript access and mitigates XSS attacks. However, this approach has
    limitations (e.g., not supported by all browsers in cross-site context).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, local storage is a viable option, but implement security
    measures such as encryption at rest and in transit to protect the token if compromised.
    Evaluate libraries or frameworks that provide secure local storage mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some scenarios, you might consider storing refresh tokens on the server side
    (e.g., database) for added security or centralized management. However, this is
    not always necessary and adds complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While refresh tokens have longer expirations than access tokens (e.g., days
    or weeks), avoid excessively long durations to minimize potential damage if compromised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a mechanism to blacklist refresh tokens after a period of inactivity
    (e.g., a week) or upon user logout. This prevents attackers from using stolen
    tokens indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider refresh token rotation. When a new access token is issued using a refresh
    token, generate a new refresh token and store it. This reduces the risk of a single
    refresh token being compromised for an extended period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If performance and fast access are top priorities, consider using Redis for
    its speed and automatic handling of expiration times. However, address potential
    persistence concerns if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If data durability and integration with your existing database are crucial,
    storing refresh tokens in a database can be an option. However, evaluate potential
    performance impacts compared to Redis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access our new controller functionality, let provide a route for it. Open
    the `routes/v1/users/index.js` file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That is all. Now we have endpoints to register, log in, and retrieve a new access
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store secret tokens and refresh tokens in an `.env` file. Create a `configs`
    folder on the same level as the `src` folder and add an `.env` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to generate refresh and secret tokens, do the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and type `node`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the given input window, type `require('crypto').randomBytes(64).toString('hex')`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure show how easily you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Generating secret tokens](img/B09148_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Generating secret tokens'
  prefs: []
  type: TYPE_NORMAL
- en: You will get a different generated result every time you call the last command.
    Just copy the value and paste it to the `.env` file to be paired with `SECRET_ACCESS_TOKEN`.
    Try the same comment a second time to get a completely different value and paste
    it for `SECRET_REFRESH_TOKEN`. The refresh token and secret token must have different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, we have the `src/config` folder with `config.js` that can
    read `.env` files programmatically. We add token reading functionality to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code provides an object called `jwt` to access refresh and secret tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might guess, we haven’t validated user-provided data directly. We need
    to validate the data, and that is why we plan to use the same structure that we
    used for the account microservice. Under the `src/middlewares` folder, we have
    the same `validate.js` file to validate our schema. That is the main reason why
    we haven’t implemented validation per endpoint. It is time to provide rules for
    email and password validation. Create `user.js` under the `src/validation` folder
    with the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet uses `Joi` to define a validation schema specifically for
    login requests in your application. It focuses on the request body, ensuring it
    contains a valid email address and password that meets the minimum length requirement
    (defined as six characters in this example). The schema also provides informative
    custom error messages for missing or invalid email and password, improving the
    user experience by guiding them toward proper credential format. By implementing
    this validation, you can prevent malformed login requests from reaching your backend
    logic and enhance the overall security of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly provide routing in our controllers but we will follow the same
    convention we did before when we implemented the account microservice. So, under
    the `routes/v1/users` folder, create an `index.js` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines two endpoints. One for registration (`/register`) and the
    other for the login (`/login`) functionality. The `routes/v1` folder also contains
    the `index.js` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the same code we used in our account microservice. We
    just changed the route to `users`. Now, users can access our endpoints using `v1/user/{endpoint_name}`.
    The last elements in our microservice are `app.js` and the root `index.js` file,
    which are the same as our already implemented account microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test our Auth microservice’s endpoints. Run `npm start` from the terminal
    and let’s prepare our `POST` request to create a user:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Postman application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Postman request window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **GET** to **POST**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the endpoint URL (it is `http://localhost:3006/v1/users/register` for
    us).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Body**, select **raw**, and select **JSON**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a payload and click **Send** (*Figure 9**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2: Successful registration](img/B09148_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Successful registration'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user is ready. Now, we can get a JWT. Here are the steps to get a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Postman request window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change **GET** to **POST**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the endpoint URL (it is `http://localhost:3006/v1/users/login` for us).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Body**, select **raw**, and select **JSON**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a payload and click **Send** (*Figure 9**.3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3: Successful login](img/B09148_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Successful login'
  prefs: []
  type: TYPE_NORMAL
- en: The generated access token will expire in a given time slot (*Figure 9**.4*).
    After expiration, we do not need to provide an email and password to get a new
    access token. We can simply use a refresh token to refresh and to get a new access
    token.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Message about expired token](img/B09148_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Message about expired token'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you want a new access token based on a refresh token? That is easy.
    Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new window on Postman and set the request type to `v1/users/token` endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Body** section and provide a refresh token. Click the **Send** button
    (*Figure 9**.5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5: Getting a new access token based on the refresh token](img/B09148_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Getting a new access token based on the refresh token'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use this access token to access our account microservice resources.
    Well, that is simply it. It is time to test the JWT in our account microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating token-based authentication for the account microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The microservices we implemented so far don’t have authentication and authorization
    functionalities. As homework, you can start to integrate these into them, and
    for learning purposes, we will implement JWT for the account microservice. Open
    the account microservice we developed so far. To use the same access token from
    the Auth microservice, the account microservice should use the same secret token.
    Open the `configs/.env` file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `config/config.js` file and make the following changes in order to
    read the secret token configuration field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only real functionality we need to add to the account microservice is a
    middleware to verify our token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `src/middlewares` folder, create a file called `verify.js` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a middleware function named `verifyJWT` for Express.js applications.
    It handles JWT verification for incoming requests. It checks if the authorization
    header exists in the request and starts with `Bearer`. If not, it returns a `401
    Unauthorized` response indicating a missing JWT.
  prefs: []
  type: TYPE_NORMAL
- en: If the header is present and formatted correctly, it extracts the JWT itself
    from the authorization header. Our middleware constructs the path to the environment
    variable file containing the JWT secret key. It calls a function (likely from
    a separate `config` module) to read and parse the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we use `jsonwebtoken.verify()` to verify the extracted token against
    the secret key retrieved from the configuration. If verification fails (`err`),
    it checks the error type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JsonWebTokenError`: Indicates invalid token format, returning `401` with a
    specific message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TokenExpiredError`: Indicates an expired token, returning `401` with a specific
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other errors (e.g., signature verification failure) are logged and a generic
    `500 Internal Server Error` response is sent for security reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If verification is successful (`!err`), it attaches the decoded user information
    from the JWT to the `req.user` object for further access within your application
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it calls `next()` to allow the request to proceed to the intended route
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this middleware acts as a gatekeeper, ensuring that only requests with
    valid JWTs can access protected resources in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use our middleware, we import it in our `app.js` file and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code imports our middleware and uses it. Now, let’s run the account microservice
    and try to get all account information. Do the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Ch09/accountservice` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the account microservice properly, you also need to run the `docker-compose`
    file from the root folder using the `docker-compose up -``d` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing both `docker-compose` setups, start the account microservice
    by running the `npm` `start` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Postman and send a `GET` request to `v1/accounts` (in our case, it is `http://localhost:3001/v1/accounts`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will get a message about an unauthorized request (*Figure 9**.6*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6: Unauthorized access](img/B09148_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Unauthorized access'
  prefs: []
  type: TYPE_NORMAL
- en: Now, run our Authentication microservice and do the steps we mentioned in the
    Auth microservice to get an access token (*Figure 9**.3*). For the same query
    for the account microservice, just open the **Authorization** section from Postman,
    change the type of authorization to **Bearer Token**, and paste the token you
    get from the Authentication service into the input (*Figure 9**.7*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7: Accessing the account microservice](img/B09148_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Accessing the account microservice'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the **Send** button and here we are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8: Getting account microservice resources](img/B09148_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Getting account microservice resources'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve followed the steps correctly, you should now be able to retrieve account
    data. In the next chapter, we’ll dive into observability and explore how to implement
    it using the ELK stack.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the fundamental security concepts of authentication, authorization,
    and their role in securing microservices. We clarified the importance of verifying
    user identities (authentication) and determining access permissions (authorization)
    for robust system protection.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we implemented a dedicated microservice for issuing access
    tokens (JWTs) and refresh tokens. JWTs grant temporary access, while refresh tokens
    allow users to obtain new access tokens without re-entering credentials. A practical
    demonstration showcased how this microservice interacts with another microservice,
    the account microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will explore the monitoring of microservices and its
    significance in microservice architectures. We will implement logging functionality
    within the account microservice and integrate it with the **Elasticsearch, Logstash,
    and Kibana** (**ELK**) stack. This will establish a centralized logging system,
    enabling efficient log collection, analysis, and visualization.
  prefs: []
  type: TYPE_NORMAL
