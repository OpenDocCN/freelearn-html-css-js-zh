- en: Why is This a Great Time to Learn Elm?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么现在是学习 Elm 的好时机？
- en: 'Welcome to the first chapter. This chapter is a gentle introduction to the
    Elm language. Our goal for this chapter is to understand the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第一章。本章是对 Elm 语言的温和介绍。我们本章的目标是理解以下内容：
- en: What is Elm?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Elm？
- en: What is unique about Elm in the saturated field of frontend web development
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 在竞争激烈的前端开发领域中有什么独特之处
- en: How does Elm compare to JavaScript?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm 与 JavaScript 如何比较？
- en: How to get started fast with the help of Ellie-app, Cloud9, and the Atom editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Ellie-app、Cloud9 和 Atom 编辑器的帮助下快速入门
- en: 'After completing this chapter, you will be able to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够：
- en: Compare the Elm code with the JavaScript code at a basic level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基本层面上比较 Elm 代码与 JavaScript 代码
- en: Set up and use Elm in several different ways
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以几种不同的方式设置和使用 Elm
- en: What is Elm?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Elm？
- en: 'Elm is a functional programming language aimed at frontend web development.
    In the words of Evan Czaplicki, the inventor of Elm:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 是一种面向前端网页开发的函数式编程语言。用 Elm 的发明者埃文·查普利斯基的话说：
- en: '"I wanted to do front-end stuff, but I wanted ... front-end programming to
    feel really, really pleasant."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “我想做前端工作，但我想……让前端编程感觉真的、真的愉快。”
- en: Evan is a functional programmer, and he wanted to apply, in practice, some of
    the academic concepts from functional programming, with the goal to make the whole
    experience of frontend web development a nicer one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 埃文是一位函数式程序员，他希望在实践中应用一些函数式编程的学术概念，目标是使前端网页开发的整体体验更加愉快。
- en: One important issue with the current way that frontend development works is
    the problem of accidental introduction and aggregation of small errors during
    development. While developing frontend JavaScript, errors will appear in our code,
    and very often, they will go unnoticed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当前前端开发方式的一个重要问题是开发过程中意外引入和累积小错误的问题。在开发前端 JavaScript 时，我们的代码中会出现错误，而且非常常见的是，这些错误会被忽视。
- en: At a later point in time, these errors will result in our code breaking. That
    leads to a lot of time wasted on fixing the issues that we, developers, unintentionally
    brought to our code, through a number of obscure errors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的某个时间点，这些错误将导致我们的代码出错。这会导致我们在修复我们开发者无意中通过一系列晦涩的错误引入到代码中的问题上浪费很多时间。
- en: Elm makes it virtually impossible to introduce errors into our code. Through
    a combination of non-cryptic compile-time errors and a helpful type system, introducing
    errors into our code is on the verge of being impossible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 使我们几乎无法将错误引入到我们的代码中。通过结合非晦涩的编译时错误和有用的类型系统，将错误引入我们的代码几乎变得不可能。
- en: If we needed to point out just one thing that is awesome about Elm, it is this
    lack of runtime errors. Imagine working in JavaScript and never seeing runtime
    errors, and you might begin to appreciate the time savings that can be achieved
    by using Elm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要指出 Elm 的一个令人惊叹的特点，那就是它缺乏运行时错误。想象一下在 JavaScript 中工作却从未看到运行时错误，你可能会开始欣赏使用
    Elm 可以实现的时间节省。
- en: After you have worked with Elm for some time, you start to feel as if Elm is
    constantly narrowing the window of opportunity for errors to appear in your code,
    from the way it is structured to the way you work with it. You can feel that conscious
    effort was placed on making it less probable for errors to occur.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Elm 了一段时间之后，你开始感觉 Elm 似乎不断缩小了错误出现在你代码中的机会窗口，从它的结构到你与之交互的方式。你可以感觉到，有意识的努力被放在了使错误发生的可能性降低上。
- en: For example, as Elm is built around the paradigm of functional programming,
    it works with pure functions. Pure functions are functions that have no side effects.
    In other words, pure functions have no state. They accept parameters, and they
    return a value. That is all they do!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Elm 是围绕函数式编程范式构建的，它使用纯函数。纯函数是没有副作用的功能。换句话说，纯函数没有状态。它们接受参数，并返回一个值。这就是它们所做的一切！
- en: They will not go out and make an HTTP request. They will not mutate variables.
    They will not, in any way, change the *state of the world*. They simply return
    a value. This brings us to an interesting effect—as long as we provide the same
    values to a function in Elm, it will return the same result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不会出去发起 HTTP 请求。他们不会修改变量。他们不会以任何方式改变世界的*状态*。他们只是返回一个值。这带给我们一个有趣的效果——只要我们在 Elm
    中向一个函数提供相同的值，它就会返回相同的结果。
- en: Another wonderful benefit of pure functions in Elm is that you can be certain
    that all the changes you make in your code are local. Changing a piece of code
    in your app will not cause some other piece of code in your application to stop
    working.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Elm中纯函数的另一个美妙好处是，你可以确信你在代码中做出的所有更改都是局部的。更改应用中的代码不会导致应用中的其他代码停止工作。
- en: To be fair, it is possible to write pure JavaScript applications in this restrictive
    functional style. However, there is nothing built-in in the language itself to
    throw an error if we lose our focus and start writing impure functions. Also,
    when working with third-party libraries, you cannot be sure that they have adhered
    to functional style purity. Compare that to Elm, which enforces nothing else but
    pure functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，以这种限制性的函数式风格编写纯JavaScript应用程序是可能的。然而，语言本身并没有内置的错误处理机制，如果我们失去了注意力并开始编写非纯函数，它将抛出错误。此外，当与第三方库一起工作时，你无法确定它们是否遵循了函数式风格的纯度。与Elm相比，Elm只强制执行纯函数。
- en: There is one caveat to this talk of pure functions. You are probably aware that
    a fully stateless application would be pointless. The ingenuity of Elm lies in
    the fact that it has a very strict way of dealing with updates to our application.
    The takeaway from this is that not only does Elm enforce the functional programming
    paradigm by forcing us to use pure functions, but it also narrows down ways to
    deal with the outside world.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯函数的讨论有一个需要注意的地方。你可能知道，一个完全无状态的程序是没有意义的。Elm的独创性在于它处理应用程序更新的一种非常严格的方式。从这个角度来看，Elm不仅通过强制我们使用纯函数来强制执行函数式编程范式，而且还限制了处理外部世界的方法。
- en: 'The immutability of data that Elm has naturally leads to another great benefit:
    debugging. Since you can be certain that a random piece of your code will never
    be able to affect another piece of your code, it will simply not be possible to
    have to deal with the issue of not knowing which part of your code broke the application;
    that is, which part of your code is causing the error. In JavaScript, this is
    a common issue, which is literally nonexisting in Elm.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Elm自然具有的数据不可变性带来另一个巨大的好处：调试。由于你可以确信你的代码中的任何随机部分都无法影响其他部分，因此根本不可能出现不知道代码的哪个部分破坏了应用程序的问题；也就是说，代码的哪个部分导致了错误。在JavaScript中，这是一个常见的问题，在Elm中实际上是不存在的。
- en: Another feature of Elm is that it works in a way that allows us to cater for
    events happening in our app, while still maintaining immutability. Elm is also
    a great way to start learning functional programming without having to understand
    a lot of advanced concepts (which would be the case when trying to learn other,
    more difficult functional programming languages).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Elm的另一个特点是它以允许我们应对应用中发生的事件的同时，仍然保持不可变性。Elm也是一个很好的开始学习函数式编程的方法，而不必理解很多高级概念（这在尝试学习其他更困难的函数式编程语言时是必须的）。
- en: Why is it worth learning Elm?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么学习Elm值得？
- en: In this section, we will discuss some of the reasons why Elm is such an exciting
    language to learn.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些原因，说明为什么Elm是一门如此令人兴奋的语言去学习。
- en: 'These reasons are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因如下：
- en: Blazing-fast virtual DOM
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风驰电掣的虚拟DOM
- en: Friendly compile-time errors
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 友好的编译时错误
- en: Zero runtime exceptions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零运行时异常
- en: Constraints as guarantees
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束作为保证
- en: Piped syntax
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道语法
- en: Easy refactoring
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易重构
- en: Increased productivity
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高生产力
- en: Helpful type system
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的类型系统
- en: Time-traveling debugger
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间旅行调试器
- en: Now that we have an overview of the exciting concepts that Elm brings to the
    table, let's inspect each of them in a bit more depth.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了Elm带来的令人兴奋的概念，让我们更深入地检查每一个。
- en: Blazing-fast virtual DOM
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风驰电掣的虚拟DOM
- en: In order to be able to discuss the virtual **Document Object Model** (**DOM**),
    we need to first understand what the *DOM* itself is. It is a standard that is
    proposed and maintained by the the **World Wide Web Consortium** (**W3C**).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够讨论虚拟**文档对象模型**（**DOM**），我们首先需要了解*DOM*本身是什么。它是由**万维网联盟**（**W3C**）提出并维护的一个标准。
- en: 'As defined by W3C on their website:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如W3C在其网站上定义的：
- en: '"The Document Object Model is a platform-and language-neutral interface that
    will allow programs and scripts to dynamically access and update the content,
    structure and style of documents. The document can be further processed and the
    results of that processing can be incorporated back into the presented page."'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: “文档对象模型是一个平台和语言中立的接口，它将允许程序和脚本动态地访问和更新文档的内容、结构和样式。文档可以进一步处理，处理结果可以合并回显示的页面。”
- en: 'As per the W3C''s DOM Specification Level 3 Core, the DOM is a way to access
    and manipulate documents in a tree-like structure consisting of nodes.  We can
    summarize the DOM as having the following characteristics:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 W3C 的 DOM 规范第 3 级核心，DOM 是一种以树状结构访问和操作文档的方式，该结构由节点组成。我们可以将 DOM 总结为具有以下特性：
- en: The DOM is language-agnostic, meaning that in theory, any language could be
    used to manipulate it
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 是语言无关的，这意味着在理论上，任何语言都可以用来操作它
- en: The DOM is set up in such a way so as to allow for live manipulation of itself
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 被设置为允许实时操作自身
- en: The DOM consists of a set of objects (a nested, tree-like hierarchy of objects)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 由一组对象（一个嵌套的、树状的对象层次结构）组成
- en: The DOM also has methods to manipulate this hierarchical structure; in other
    words, the DOM is an **Application Programming Interface** (**API**)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM 还有一些方法可以操作这个层次结构；换句话说，DOM 是一个**应用程序编程接口**（**API**）
- en: Before we continue the discussion about the DOM, it is very important to make
    it perfectly clear just what an API is. To explain what the API abbreviation stands
    for, we can use the analogy of switching a light bulb on and off. In order to
    switch on a light bulb, we do not have to know what material it is made of, how
    much power is needed to run it, or how bright it is. All that we need to know
    is how to make it light up the room, and how to turn it off; that is, how to control
    its behavior.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论 DOM 之前，非常重要的一点是要清楚地了解什么是 API。为了解释 API 缩写代表什么，我们可以使用开关灯泡的类比。为了开关灯泡，我们不需要知道它是由什么材料制成的，需要多少电力来运行，或者它有多亮。我们只需要知道如何让它照亮房间，以及如何关闭它；也就是说，如何控制它的行为。
- en: Of course, as we are all very well aware, to control a light bulb we need to
    use a light switch. In the preceding example, we could say that the light switch
    is the API for the light bulb. In order to *manipulate* the light bulb (to make
    it do what we want), we need to access it via its *API* (the light switch).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们非常清楚的那样，要控制灯泡，我们需要使用开关。在前面的例子中，我们可以说开关是灯泡的 API。为了*操作*灯泡（使其做我们想要的事情），我们需要通过它的*API*（开关）来访问它。
- en: In more general terms, we can think of an API as a way to access and manipulate,
    or control, in a structured manner, whatever it is that we want to work with.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更广义地说，我们可以将 API 视为一种以结构化方式访问和操作（或控制）我们想要与之工作的任何事物的途径。
- en: In the case of the DOM, its purpose is two-fold. First, the DOM is the API for
    HTML. Using the light bulb analogy, HTML would be the light bulb, the DOM would
    be the light switch, and JavaScript would be pretty much the only way to access
    the light switch.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 的情况下，它的目的是双重的。首先，DOM 是 HTML 的 API。使用灯泡类比，HTML 就是灯泡，DOM 就是开关，而 JavaScript
    几乎是访问开关的唯一方式。
- en: Secondly, the DOM is a representation of a web page. The previous sentence is
    crucial for our understanding of how the DOM works, so we will repeat it again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，DOM 是网页的一种表示。上一句话对于我们理解 DOM 的工作方式至关重要，所以我们将再次重复它。
- en: The DOM is a representation of a web page. This representation is a tree-like
    structure that consists of building blocks—node objects. In total, there are 12
    types of nodes in the DOM. However, this representation of a web page is not static,
    meaning it is not only a static representation of a hierarchical structure of
    a web page. Each node also includes all the properties and methods that enable
    us to alter the contents of this tree-like structure (the API part).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 是网页的一种表示。这种表示是一个由构建块——节点对象——组成的树状结构。在 DOM 中，总共有 12 种类型的节点。然而，这种网页的表示不是静态的，这意味着它不仅是一个静态的网页层次结构的表示。每个节点还包含所有使我们能够改变这个树状结构内容（API
    部分）的属性和方法。
- en: Practically, there is only one way to access the DOM—via JavaScript. There are
    some exceptions to this. For example, in IE 10 and lower, we could use VBScript,
    but for all practical purposes, it is safe to say that the only language that
    can work directly with the DOM is JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，访问DOM的唯一方式是通过JavaScript。对此也有一些例外。例如，在IE 10及以下版本中，我们可以使用VBScript，但就实际应用而言，可以说只有JavaScript能够直接与DOM交互。
- en: In order to understand the interplay between web pages, HTML, the DOM, JavaScript,
    and browsers better, we need to understand what happens when you point your web
    browser to a web page. What follows is a very simplified explanation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解网页、HTML、DOM、JavaScript和浏览器之间的相互作用，我们需要了解当你将你的Web浏览器指向一个网页时会发生什么。以下是一个非常简化的解释。
- en: First, the browser will make a call to the server, which will return some HTML.
    The browser's rendering engine will then parse the raw HTML into its DOM representation.
    Parsing is the process of translating from one format to another. The raw HTML
    that is served from a web page cannot be directly manipulated. Instead of directly
    manipulating the raw HTML, we must use the DOM API, and therefore, the HTML of
    a web page needs to be internally parsed by the browser's rendering engine into
    its DOM representation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，浏览器会调用服务器，服务器会返回一些HTML。然后，浏览器的渲染引擎会将原始HTML解析为其DOM表示形式。解析是将一种格式转换为另一种格式的过程。从网页上提供的原始HTML不能直接操作。而不是直接操作原始HTML，我们必须使用DOM
    API，因此，网页的HTML需要由浏览器的渲染引擎内部解析为其DOM表示形式。
- en: Once the browser's rendering engine has parsed the HTML document into its object
    representation (the DOM), it is now available to JavaScript, which can manipulate
    the DOM representation of the HTML document.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器的渲染引擎将HTML文档解析为其对象表示形式（DOM），它现在就可以供JavaScript使用，JavaScript可以操作HTML文档的DOM表示形式。
- en: Another way of looking at the relationship between HTML, the DOM, and the browser,
    is to understand that HTML is simply just text. It becomes what we see on our
    monitors only after the browser has parsed it into its DOM representation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待HTML、DOM和浏览器之间关系的方式是理解HTML仅仅是文本。只有当浏览器将其解析为其DOM表示形式后，我们才能在显示器上看到它。
- en: Several years ago, browsers were not complying to standards set forth by W3C.
    In recent years, they caught up to it, and the DOM API in all major browsers is, for
    the most part**,** standards-compliant. However, there are issues with the DOM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，浏览器并没有遵守W3C制定的标准。近年来，它们赶上了这个步伐，所有主流浏览器的DOM API基本上是符合标准的。然而，DOM存在一些问题。
- en: HTML and CSS were not intended for modern web applications, with thousands of
    nodes that sometimes have to be updated according to certain criteria. Still,
    today, this sort of behavior on modern web pages is what users expect. **Single-page
    Applications** (**SPAs**) are a good example of this. In SPAs, the DOM needs to
    be constantly updated, and yet, the way that the DOM works makes its direct manipulation
    costly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: HTML和CSS并不是为现代Web应用设计的，这些应用有数千个节点，有时需要根据某些标准进行更新。然而，今天，现代网页上的这种行为正是用户所期望的。**单页应用（SPA**）是这方面的一个很好的例子。在SPA中，DOM需要不断更新，而DOM的工作方式使得直接操作成本高昂。
- en: Several years ago, we would be using jQuery as the de facto standard of dealing
    with interactivity in our web pages. Thus, in case we'd want to update the page
    based on, say, a click event, we would tell jQuery to first find all the nodes
    in the page that need to react to that click event. Then, we would update the
    nodes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们会使用jQuery作为处理网页交互的默认标准。因此，如果我们想根据点击事件更新页面，我们会告诉jQuery首先找到所有需要对该点击事件做出反应的节点。然后，我们会更新这些节点。
- en: 'Thus, the jQuery paradigm is that we are working with the DOM directly. For
    example, to target all the `div` elements on-click, and have them perform some
    kind of a change, we have to first set up our `div` selector, and then give it
    the event handler and the action to perform, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，jQuery范式是我们直接与DOM交互。例如，为了在点击时针对所有`div`元素执行某种更改，我们首先需要设置我们的`div`选择器，然后为其提供事件处理程序和要执行的操作，如下所示：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The issue with this is that there will probably be at least half a dozen events
    to listen for in your web app. There will also probably be a lot of DOM nodes
    that will have to be updated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的问题是，在你的Web应用中可能需要监听至少六种事件。可能还会有很多DOM节点需要更新。
- en: Direct DOM changes are slow. The larger your app gets, the more resource demanding
    direct DOM manipulation becomes, as there are more layout recomputations and reflows
    to be done when the DOM changes. Piling up these changes and web page reflows
    might lead to pages not being as snappy as users would expect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改DOM很慢。你的应用程序越大，直接DOM操作的资源需求就越高，因为当DOM发生变化时，需要进行更多的布局重新计算和重排。累积这些更改和网页重排可能会导致页面不如用户期望的那样迅速。
- en: Another issue is that as our web app grows, it gets harder to avoid bugs, because
    when working with the DOM directly, it is hard to separate concerns. The idea
    of virtual DOM is amazing in its simplicity. Instead of constantly touching the
    DOM, a much better approach is to have the whole DOM structure represented virtually,
    then keep a snapshot of the DOM, represented as virtual DOM nodes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们随着Web应用程序的增长，更难避免错误，因为当直接与DOM工作的时候，很难分离关注点。虚拟DOM的想法在简单性上非常出色。而不是不断触摸DOM，一个更好的方法是将整个DOM结构以虚拟方式表示出来，然后保持DOM的快照，这些快照以虚拟DOM节点表示。
- en: When the page needs to be re-rendered as a result of an event, the previous
    DOM snapshot is compared to the new DOM structure, and then only those changes
    that are needed to achieve the end result are performed on the actual DOM.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面需要根据事件重新渲染时，会对比之前的DOM快照和新DOM结构，然后只对实际DOM执行达到最终结果所需的变化。
- en: 'To explain the distinction between the direct DOM manipulation and the virtual
    DOM better, let''s look at two programming paradigms: **imperative programming**
    and **declarative programming**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释直接DOM操作和虚拟DOM之间的区别，让我们看看两种编程范式：**命令式编程**和**声明式编程**。
- en: In imperative programming, we explain the how to get to the what. In other words,
    we need to give our program a full set of detailed instructions on exact steps
    that need to be performed in order to get to the desired result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们解释如何得到“什么”。换句话说，我们需要给我们的程序一套详细的指令，精确说明需要执行哪些步骤才能达到预期结果。
- en: 'In declarative programming, we simply ask for the what to be performed; the
    inner workings of how the program should get to the desired result is not a concern.
    An example of a declarative language is SQL. For example, we could say:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，我们只需请求要执行的内容；程序如何达到预期结果的内幕运作不是我们的关注点。SQL就是一种声明式语言的例子。例如，我们可以说：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We do not give SQL instructions on how to perform the action; we just tell it
    what result we want. In other words, we do not specify all the steps that SQL
    needs to take to search the database for customers that own a green Mercedes.
    We simply tell it what we want, but the implementation (how SQL does it behind
    the scenes) is not something that we have to know.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不给出SQL指令来执行操作；我们只是告诉它我们想要的结果。换句话说，我们不需要指定SQL需要采取的所有步骤来搜索拥有绿色梅赛德斯的车主数据库。我们只需告诉它我们想要什么，但实现方式（SQL在幕后是如何做的）不是我们必须知道的事情。
- en: This is very similar to how virtual DOM works in Elm. We specify the result
    of our change, and let the Elm Runtime decide on the most effective way to get
    there.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Elm中虚拟DOM的工作方式非常相似。我们指定我们的更改结果，然后让Elm运行时决定最有效的方式来实现。
- en: To wrap this section up, it is interesting to note that Elm has the fastest
    virtual DOM implementation of all the major JavaScript frameworks, which is quite
    an accomplishment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节内容，值得注意的是，Elm拥有所有主要JavaScript框架中最快的虚拟DOM实现，这是一项相当了不起的成就。
- en: Friendly compile-time errors
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 友好的编译时错误
- en: It is kind of interesting how there is an entire movement revolving around ideas
    like UX and UI. We web artisans strive to give our users the best possible experience
    while interacting with our websites and apps. But, besides being the construction
    workers of the web, ultimately, we are users too.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 真是挺有意思的，竟然有一个围绕用户体验（UX）和用户界面（UI）等理念的整个运动。我们这些网络工匠努力为用户提供与我们的网站和应用程序互动时可能获得的最佳体验。但是，除了作为网络的建造者之外，我们最终也是用户。
- en: 'Before we look at an example of a JavaScript message, let''s remember the only
    reason we are using JavaScript in these examples is because, as we discussed earlier
    in this chapter, it is practically the only language that works with the DOM API.
    Looking at some JavaScript error messages, it is interesting that we are still
    stuck with cryptic errors such as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看JavaScript消息的例子之前，让我们记住，我们之所以在这些例子中使用JavaScript，仅仅是因为，正如我们在本章前面讨论的那样，它实际上是唯一一种可以与DOM
    API一起工作的语言。看看一些JavaScript错误消息，我们发现我们仍然被这些难以理解的错误所困扰，例如：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why such a terse error message? Definitely not beginner-friendly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样的错误信息如此简短？显然不是面向初学者的。
- en: Let's break this error message down, starting with `Uncaught`. Obviously, our
    application failed to catch this particular error. Next, `TypeError`. It is just
    one of several kinds of errors. Others include `SyntaxError`, `URIError`, `RangeError`,
    and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个错误信息，从 `Uncaught` 开始。显然，我们的应用程序未能捕获这个特定的错误。接下来是 `TypeError`。这只是几种错误类型中的一种。其他还包括
    `SyntaxError`、`URIError`、`RangeError` 等等。
- en: Finally, the message—`undefined is not a function`. It helps to know that `undefined`
    is one of JavaScript's primitive types. Others are string, number, null, boolean,
    and symbol. When a variable has been declared, but has not been assigned a value,
    the JavaScript engine assigns it the value of `undefined`. The `undefined` value
    is the only possible value of the `undefined` type. Thus, `undefined` can never
    be a function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，信息是 `undefined is not a function`。了解 `undefined` 是 JavaScript 的原始类型之一很有帮助。其他还有字符串、数字、null、布尔值和符号。当一个变量被声明但没有分配值时，JavaScript
    引擎会将其分配为 `undefined`。`undefined` 值是 `undefined` 类型的唯一可能值。因此，`undefined` 永远不能是一个函数。
- en: In other words, your code was trying to call a value as if that value was a
    function. Obviously, you can't call a non-function, hence the `not a function`
    part of the error message. Armed with this knowledge, let's rephrase our error
    to something that is a bit more user-friendly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的代码试图调用一个值，就像这个值是一个函数一样。显然，你不能调用一个非函数，因此错误信息中的 `not a function` 部分就出现了。有了这些知识，让我们重新表述我们的错误，使其更加用户友好。
- en: 'How about this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样，这个怎么样？
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Isn't that nicer? It helps us understand the error much better. But what if
    the compiler took it a step further? What if it not only told us how the error
    occurred, but also the most probable culprit in our code?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不更好吗？这有助于我们更好地理解错误。但如果编译器能更进一步呢？如果它不仅告诉我们错误是如何发生的，还能指出我们代码中最可能的原因呢？
- en: 'That''s what Elm is aiming at. What follows is a trimmed-down example of an
    error message straight from Elm''s documentation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Elm 所追求的。以下是一个来自 Elm 文档的错误信息的简化示例：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`As I infer` feels like we have a friend in there somewhere, and he''s/she''s
    actively trying to help us. Another awesome thing about Elm''s errors is that
    as new versions of the language come out, we can see efforts being made to continuously
    improve the friendliness and usefulness of compiler errors. This idea was nicely
    summed up on Elm''s official website in one sentence:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`As I infer` 感觉好像我们在这里有一个朋友，他/她在积极地试图帮助我们。关于 Elm 错误的另一个了不起的事情是，随着语言新版本的发布，我们可以看到持续改进编译器错误友好性和有用性的努力。这个想法在
    Elm 官方网站上用一句话很好地总结了：'
- en: '"Compilers should be assistants, not adversaries."'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"编译器应该是助手，而不是对手。"'
- en: For example, in Elm 0.15.1, error messages were improved so that the errors
    list the line numbers and the actual code, just as we've seen in the previous
    example. Plus, they highlight the exact part of the code that caused the error
    (using caret symbols).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Elm 0.15.1 中，错误信息得到了改进，以便列出行号和实际代码，就像我们在前面的例子中看到的那样。此外，它们还突出显示了导致错误的代码的精确部分（使用插入符号）。
- en: Another improvement was to introduce helpful hints to error messages. Thus,
    we got error messages with pinpoint precision, and the hints and the contexts
    of these messages helped reduce the time a developer would need to spend getting
    to the root cause of the error and the most likely way to solve it. Instead, compiler
    does all this work for us.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进是向错误信息中引入有用的提示。因此，我们得到了具有精确定位的错误信息，这些提示和上下文有助于减少开发者找到错误根本原因和最可能解决问题的所需时间。相反，编译器为我们做了所有这些工作。
- en: In version 0.16, Elm introduced type `diffs`, which takes an idea from Git.
    However, instead of comparing commits, the compiler compares types. It also introduced
    helpful beginner hints, better error messages, and a number of other improvements,
    which reinforces the idea that Elm's compile-time errors are only going to get
    better as new versions of the language come out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.16 版本中，Elm 引入了类型 `diffs`，它借鉴了 Git 的一个想法。然而，编译器比较的是类型，而不是提交。它还引入了有用的初学者提示、更好的错误信息和许多其他改进，这进一步加强了
    Elm 的编译时错误只会随着语言新版本的发布而变得更好的观点。
- en: Zero runtime exceptions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零运行时异常
- en: Elm's programming paradigm is restrictive in comparison with JavaScript's. It
    forces us to think and work in a way that is a lot more robust and less error-prone.
    At compile time, Elm will catch errors and suggest, with helpful messages, how
    to correct those errors. It nips in the bud the *billion-dollar mistake* of JavaScript
    by making sure we don't have values that are null.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 相比，Elm 的编程范式更加限制性。它迫使我们以一种更加健壮且错误率更低的方式进行思考和操作。在编译时，Elm 会捕获错误，并通过有用的消息建议如何纠正这些错误。通过确保我们没有
    null 值，Elm 消除了 JavaScript 的 *十亿美元错误*。
- en: If we do in fact get errors in our program, it simply won't compile. All of
    this has lead to esteemed members of the Elm community to make bold claims of
    zero runtime exceptions. In my experience so far with Elm, this has certainly
    been true.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的程序确实出现了错误，它将无法编译。所有这些都导致 Elm 社区的资深成员大胆地宣称零运行时异常。根据我迄今为止使用 Elm 的经验，这一点确实是真的。
- en: Errors are still possible. Logical errors, that is. Logical errors occur when
    we developers write code that works, but is nonsensical. For example, having a
    user who is a negative number of years old. The important thing with zero runtime
    exceptions is that the application will always run smoothly once it compiles.
    There will not be a situation where it crashes while running.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 错误仍然可能发生。即逻辑错误。当开发者编写的代码能够运行但毫无意义时，就会发生逻辑错误。例如，有一个年龄为负数的用户。零运行时异常的重要之处在于，一旦编译成功，应用程序将始终平稳运行。不会出现运行时崩溃的情况。
- en: However, even if it turns out at a certain point in the future that it is possible
    after all, for some strange reason, to very rarely cause runtime exceptions in
    Elm, I would be happy with that too, because that would still be way better than
    what frontend web developers have to deal with day-to-day, outside of Elm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在未来某个时刻，出于某种奇怪的原因， Elm 极少出现运行时异常成为可能，我也会对此感到高兴，因为那仍然会比 Elm 开发者日常面临的状况要好得多。
- en: Constraints as guarantees
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束作为保证
- en: The simplest explanation for the functional programming approach is—functional
    programming is a programming style in which functions have no side effects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数式编程方法的最简单解释是——函数式编程是一种函数没有副作用编程风格的编程方式。
- en: Ultimately, this means that it's harder to start working with Elm if you're
    experienced working with JavaScript. Why? Simply because JavaScript will not force
    you to adhere to certain conventions, or to certain constraints. Thus, the number
    of ways to do things in JavaScript is greater, and it can feel awkward not having
    that freedom of choice when you first start working with Elm.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这意味着如果你有使用 JavaScript 的经验，开始使用 Elm 会更困难。为什么？简单来说，JavaScript 不会强迫你遵守某些约定或约束。因此，在
    JavaScript 中做事的方法更多，当你第一次开始使用 Elm 时，没有那种选择自由可能会感觉有些不自在。
- en: On the flip side, once things break, JavaScript's freedom of choice that initially
    felt like a good thing, now comes back at us, in the form of one simple question—what
    dependency broke my code? Very often, searching for this dependency in JavaScript
    can be a frustrating experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一旦出现问题，JavaScript 初始感觉良好的选择自由现在却以一个简单的问题的形式回到我们面前——是什么依赖项破坏了我的代码？在 JavaScript
    中，经常搜索这个依赖项会是一种令人沮丧的经历。
- en: Thus, having constraints in place from the get-go might feel a bit strange when
    you first start working with Elm, but you'll sure be glad you had to work with
    them when your future self comes back to revisit the code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你第一次开始使用 Elm 时，一开始可能会有一些约束感，但当你未来的自己回来重新审视代码时，你会很高兴自己不得不与它们一起工作。
- en: When you first start working with Elm, its functional programming paradigm feels
    like a constraint, but it also acts as a guarantee of things working only in a
    certain way. A limited number of possibilities to do things is a solid *guarantee*
    that there will be a limited number of ways in which we could mess things up. Simply
    put, constraints are good.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次开始使用 Elm 时，其函数式编程范式感觉像是一种约束，但它也充当了保证事情只能以特定方式工作的保证。有限的可能性去做事情是一个坚实的 *保证*，即我们可能会以有限的方式搞砸事情。简单来说，约束是好的。
- en: Piped syntax
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道语法
- en: 'Let''s define a multiplication function in JavaScript:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 JavaScript 中定义一个乘法函数：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now call it as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下代码所示调用它：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In JavaScript, mixing types like we just did would work fine because the JS
    engine will coerce the string `"10"` into the number 10.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，像我们刚才那样混合类型会正常工作，因为 JS 引擎会将字符串 `"10"` 强制转换为数字 10。
- en: 'Let''s now look at Elm. Navigate to the online Elm editor at [http://elm-lang.org/try](http://elm-lang.org/try)
    and type the following code into it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Elm。导航到在线Elm编辑器[http://elm-lang.org/try](http://elm-lang.org/try)，并将以下代码输入其中：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we import the `HTML` library. Then, we use the keyword `exposing` to
    make the `text` function available for us. The `text` function will convert Elm's
    text strings into HTML strings.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`HTML`库。然后，我们使用关键字`exposing`使`text`函数对我们可用。`text`函数将Elm的文本字符串转换为HTML字符串。
- en: Next, we define the `multiplyNumber` function. It takes two parameters, `x`
    and `y`. Then, in our app's entry point, `main`, we simply pass the result of
    `multiplyNumber` to the `toString` function since we need to convert the number
    returned from `multiplyNumber` to a string in order for the `text` function to
    be able to use it. It is the  `text` function that will print out the result of
    the converted `multiplyNumber` to the web page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`multiplyNumber`函数。它接受两个参数，`x`和`y`。然后，在我们的应用程序入口点`main`中，我们只需将`multiplyNumber`的结果传递给`toString`函数，因为我们需要将`multiplyNumber`返回的数字转换为字符串，以便`text`函数能够使用它。是`text`函数将转换后的`multiplyNumber`的结果打印到网页上。
- en: 'Let''s look at our main entry point again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的主入口点：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using parentheses here, we specify the order of operations. Contrary to JavaScript,
    Elm does not use parentheses to list the parameters to be passed to a function.
    It uses spaces. Thus, to tell the `multiplyNumber` function to multiply `8` and
    `10`, we simply write this code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用括号，我们指定了运算的顺序。与JavaScript不同，Elm不使用括号来列出要传递给函数的参数。它使用空格。因此，为了告诉`multiplyNumber`函数将`8`和`10`相乘，我们只需写下这段代码：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The only reason to use parentheses is to avoid ambiguity when we pass in the
    result of the preceding function to another function, which, in our example, is
    the `toString` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号的唯一原因是在将前一个函数的结果传递给另一个函数时避免歧义，在我们的例子中，是`toString`函数：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we did not use the parentheses, our code would look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用括号，我们的代码将看起来像这样：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Thus, the compiler would think that we are passing three parameters to the
    `toString` function—`multiplyNumber`, `8`, and `10`, which is obviously not what
    we are trying to do. Let''s look at this line of code again:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器会认为我们在向`toString`函数传递三个参数——`multiplyNumber`、`8`和`10`，这显然不是我们想要做的。让我们再次看看这一行代码：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is obvious that the expressions are evaluated from the `multiplyNumber` function.
    The result is then returned, and thus used as a parameter of the `toString` function,
    and then finally the value returned from the `toString` function is used as the
    parameter of the `text` function, which prints the number `80` on the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，表达式是从`multiplyNumber`函数评估的。然后结果被返回，因此用作`toString`函数的参数，最后，`toString`函数返回的值用作`text`函数的参数，该函数在屏幕上打印数字`80`。
- en: 'The preceding expression is still easily readable. But what if we had even
    more functions nested within other functions? What if, for the sake of seeing
    the effect of *parentheses everywhere*, we replaced the number 8 with multiples
    of 2? In other words, what if we did this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式仍然很容易阅读。但如果我们在其他函数内部嵌套更多的函数呢？如果我们为了看到“到处都是括号”的效果，将数字8替换为2的倍数呢？换句话说，如果我们这样做：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ok, so let''s go through the expressions in order of execution, that is, starting
    with the innermost parentheses first:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们按照执行顺序来分析表达式，也就是说，从最内层的括号开始：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding expression returns the value of `20`. We than pass that value
    as the second argument to the next `multiplyNumber`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式返回了`20`的值。然后我们将这个值作为下一个`multiplyNumber`函数的第二个参数传递：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time, we multiply the number 2 with the value returned from the innermost
    `multiplyNumber` (which is 20). Finally, we run the third `multiplyNumber`, then
    the `toString`, and finally the `text` function to get the final result, which
    is still 80.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将数字2与最内层的`multiplyNumber`函数返回的值相乘（该值为20）。最后，我们运行第三个`multiplyNumber`函数，然后是`toString`函数，最后是`text`函数以获取最终结果，该结果仍然是80。
- en: This is a simple example, and things are already starting to look a bit messy.
    What if we ran 20 different functions this way? Would our one line of code become
    500 characters long? Or should we use word-wrap in our text editor? Even if we
    did that, it would still look and feel clunky.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，事情已经开始变得有些杂乱。如果我们以这种方式运行20个不同的函数呢？我们的一行代码会变成500个字符长吗？或者我们应该在文本编辑器中使用自动换行？即使我们这样做，它看起来和感觉也会很笨拙。
- en: 'This is where piped syntax comes to the rescue. Instead of reasoning about
    our code as we just described in the preceding code snippet, we can simply take
    the result of the first function and pipe its result to the next function. Like
    this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是管道语法发挥作用的地方。我们不需要像前面代码片段中描述的那样推理我们的代码，我们只需简单地将第一个函数的结果传递给下一个函数。就像这样：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Feel free to take a moment and think about the reduced cognitive load of writing
    this piped syntax in Elm. Contrary to JavaScript, piped functions are just a part
    of the Elm language. To wrap up this section of our chapter, let''s rewrite the
    starting example. This time, we will be using piped syntax:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随意花点时间思考一下在 Elm 中编写这种管道语法所减轻的认知负担。与 JavaScript 相反，管道函数只是 Elm 语言的一部分。为了总结本章的这一部分，让我们重写起始示例。这次，我们将使用管道语法：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another reason to love the piping syntax is, if we had a list of 20 functions,
    each piping into the next one, and we decided to, say, remove functions number
    5, 7, and 15, we would simply erase the corresponding lines that have those pipes.
    Contrast that to messing with parentheses and making sure that they are all properly
    opened and closed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢管道语法的另一个原因是，如果我们有一个包含 20 个函数的列表，每个函数都连接到下一个函数，然后我们决定，比如说，删除第 5、7 和 15 个函数，我们只需简单地擦除那些有管道的相应行。对比一下，处理括号并确保它们都正确打开和关闭的混乱情况。
- en: Note that when we add several piping operators like we did in the preceding
    code snippet, what is actually happening is that the preceding pipe operator,
    `|>`, formally known as the *forward function application operator*, evaluates
    the expression on its left side and gives it as the last parameter to the function
    on its right side.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们添加多个管道操作符，就像前面代码片段中做的那样，实际上发生的事情是前面的管道操作符 `|>`（正式称为*前向函数应用操作符*）评估其左侧的表达式，并将其作为右侧函数的最后一个参数传递。
- en: Easy refactoring
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的重构
- en: Simply put, refactoring is a fancy word for the simple process of changing how
    your code looks without changing the result it produces. For example, say that
    you have a function in your code that is getting too long. You can replace that
    one long function in your code with two smaller functions, each of them doing
    a more specialized task. However, the external behavior of that code will not
    change. By replacing parts of your application's code, you are either making it
    easier to use, easier to understand and reason about, or easier to maintain. All
    of these things are important reasons for refactoring.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，重构是一个术语，指的是在不改变代码产生的结果的情况下改变代码外观的简单过程。例如，假设你的代码中有一个函数变得越来越长。你可以用两个较小的函数替换掉这个长函数，每个函数执行一个更专业的任务。然而，这段代码的外部行为不会改变。通过替换应用程序代码的一部分，你可以使代码更容易使用、更容易理解、更容易推理或更容易维护。所有这些因素都是重构的重要原因。
- en: Refactoring in Elm is easier because of the way the compiler works. The compiler
    will keep on reminding you of all the things you broke, until you fix them. Also,
    since Elm is a statically typed language, the type system it has in place will
    take care of a lot of quirks you would usually have to take care of yourself when
    using JavaScript. As we saw in the previous section, piping syntax is a core feature
    of the language, and this too, in some cases, can speed up refactoring.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 中的重构之所以更容易，是因为编译器的工作方式。编译器会不断地提醒你所有你破坏的地方，直到你修复它们。此外，由于 Elm 是静态类型语言，它所具有的类型系统将处理你通常在使用
    JavaScript 时必须自己处理的大多数怪癖。正如我们在上一节中看到的，管道语法是语言的核心特性，在某些情况下，这也可以加快重构的速度。
- en: Helpful type system
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的类型系统
- en: 'As mentioned earlier, Elm is statically typed. It has a concept of type annotations.
    These are not compulsory, but are preferred for the sake of clarity. If you look
    at the code that someone else wrote, it''s always good to be able to look at type
    signatures. So, let''s look at our little multiply numbers app, only this time
    with added type annotations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Elm 是静态类型语言。它有一个类型注解的概念。这些注解不是强制性的，但出于清晰起见，推荐使用。如果你查看别人写的代码，能够看到类型签名总是很好的。那么，让我们看看我们的这个小乘法数字应用，这次添加了类型注解：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compared with other languages, whose type systems have verbose type declarations
    and strange error messages, and still have runtime errors, Elm's type system is
    not only helpful, it truly adds to developer happiness. Looking at the function
    signature for `multiplyNumber`, we can see that it takes two `Int` values, and
    returns an `Int`, so a quick glance will tell us exactly what is going on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，它们的类型系统有冗长的类型声明和奇怪的错误信息，并且仍然存在运行时错误，而 Elm 的类型系统不仅有帮助，它真正增加了开发者的幸福感。查看
    `multiplyNumber` 函数的函数签名，我们可以看到它接受两个 `Int` 值，并返回一个 `Int`，所以快速浏览就能确切地知道发生了什么。
- en: Increased productivity
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高生产力
- en: This point is a logical conclusion we can derive from all the points we touched
    on in the preceding section. With super-fast virtual DOM, friendly compile-time
    errors, zero runtime exceptions, constraints as guarantees, piped syntax, and
    a helpful type system, Elm truly is a joy to work with. The compiler is your friend,
    and you'll find yourself writing code more confidently. With less of a need for unnecessary
    mental acrobatics, writing Elm code is simply more productive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点是我们从前一节提到的所有点中可以得出的逻辑结论。有了超级快速的虚拟 DOM、友好的编译时错误、零运行时异常、约束作为保证、管道语法和有帮助的类型系统，Elm
    真正是一个令人愉快的合作伙伴。编译器是你的朋友，你会发现自己在编写代码时更加自信。由于不需要进行不必要的心理体操，编写 Elm 代码的效率更高。
- en: Getting started with writing Elm code
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写 Elm 代码
- en: 'Navigate to the hello world example on the official online editor:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到官方网站上的“Hello World”示例：
- en: '[http://elm-lang.org/examples/hello-HTML](http://elm-lang.org/examples/hello-html).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://elm-lang.org/examples/hello-HTML](http://elm-lang.org/examples/hello-html).'
- en: 'The code is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code compiles to a simple `Hello, World!` output. But what is
    this output? Is it an HTML element? No. It is actually just a DOM text node. And
    since text nodes need to have an element attached to them, this text node gets
    attached to the topmost element that actually gets rendered, which is the `<body>`
    element. You can verify this by inspecting the rendered text in your browser's
    Developer Tools.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码编译为简单的 `Hello, World!` 输出。但这个输出是什么？是一个 HTML 元素吗？不是。它实际上只是一个 DOM 文本节点。由于文本节点需要附加到一个元素上，这个文本节点就附加到了实际渲染的最顶层元素上，即
    `<body>` 元素。你可以通过在浏览器开发者工具中检查渲染的文本来验证这一点。
- en: 'Let''s do something else here. Let''s render an actual HTML element on the
    page. To do this, we need to pass in a function with some attributes to our main
    variable. For example, we can do this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做些其他的事情。让我们在页面上渲染一个实际的 HTML 元素。为此，我们需要将一个带有一些属性的函数传递给我们的主变量。例如，我们可以这样做：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What did we do here? We passed in the `h1` function to `main`. The `h1` function
    takes two parameters; the first parameter is empty, and the second parameter takes
    in the `text` function as the attribute. This text function accepts a string of
    text as its own parameter, in this case, `“Hello, Elm!`”.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了什么？我们将 `h1` 函数传递给 `main`。`h1` 函数接受两个参数；第一个参数是空的，第二个参数接受 `text` 函数作为属性。这个
    `text` 函数接受一个字符串作为自己的参数，在这种情况下，是 `"Hello, Elm!"`。
- en: Let's inspect the Developer Tools after this change. We can see that the text
    node's parent is now indeed an `h1` HTML tag. Make sure to keep the Developer
    Tools open; we will being using it later.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这次更改后检查开发者工具。我们可以看到，文本节点的父节点现在确实是一个 `h1` HTML 标签。请确保保持开发者工具开启；我们稍后会使用它。
- en: 'Let''s change the function from `h1` to `h2`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将函数从 `h1` 改为 `h2`：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Press the Compile button on the online editor, and you''ll get the expected
    result—the text is now a bit smaller, with the Developer Tools showing that the
    parent of our text node is now indeed an `<h2>` HTML tag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线编辑器上按下编译按钮，你会得到预期的结果——文本现在略小，开发者工具显示我们的文本节点的父节点现在确实是一个 `<h2>` HTML 标签：
- en: '![](img/6d81a608-a550-4e11-80e9-baa39dad6ab1.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d81a608-a550-4e11-80e9-baa39dad6ab1.png)'
- en: 'Let''s try a different tag, for example, an `anchor` tag:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个不同的标签，例如，一个 `anchor` 标签：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What about an `li`? Refer to the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `li` 呢？参考以下代码片段：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Can we add it as a paragraph? Refer to the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将其添加为一个段落？参考以下代码片段：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Nesting components is easy. For example, if we want to render a `div` that
    holds two paragraphs, we will call a `div` function and inside its brackets, we''ll
    call two `p` functions, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套组件很容易。例如，如果我们想渲染一个包含两个段落的 `div`，我们将调用一个 `div` 函数，并在其括号内调用两个 `p` 函数，如下所示：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In all the examples so far, we left the first parameter empty. That parameter
    is used to add HTML attributes, for example, `class`. So, let''s now try to color
    our `div`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的例子中，我们都留空了第一个参数。这个参数用于添加HTML属性，例如，`class`。那么，现在让我们尝试给我们的`div`上色：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We gave our `div` the class of `danger`, and we''d like to give it the CSS
    declaration of `background: red`. But where do we add it?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '我们给我们的`div`添加了`danger`类，并且我们还想给它添加CSS声明`background: red`。但是我们应该在哪里添加它？'
- en: The fastest way to do this is to use a nice Elm editor available online, that
    is Ellie.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最快的方式是使用一个在线的优秀的Elm编辑器，那就是Ellie。
- en: Getting started fast with Ellie-app
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始使用Ellie-app
- en: 'Navigate to this address in your web browser: [https://ellie-app.com/new](https://ellie-app.com/new).
    In the Elm section of code, paste in the Elm code that we discussed at the end
    of the previous section, where we introduced the class of `danger` to our `div`.
    In the HTML section of our code, add the following CSS just above the already
    included closing `</style>` tag:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中导航到以下地址：[https://ellie-app.com/new](https://ellie-app.com/new)。在代码的Elm部分，粘贴我们在上一节末尾讨论的Elm代码，其中我们将`div`的类设置为`danger`。在我们的代码的HTML部分，在已经包含的关闭`</style>`标签上方添加以下CSS：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Click the Compile button, and you'll see the result in the window on the right-hand
    side inside of Ellie.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 点击编译按钮，您将在Ellie右侧的窗口中看到结果。
- en: Now that we have successfully completed and compiled this very simple app, let's
    look at why the Ellie editor is better to use than the default *Try Elm* editor
    available on the official website.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功完成并编译了这个非常简单的应用程序，让我们看看为什么Ellie编辑器比官方网站上提供的默认*Try Elm*编辑器更好用。
- en: Adding type annotations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型注解
- en: Although we are able to add CSS to our app, unfortunately, we don't have compiler
    suggestions available in Ellie.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们能够向我们的应用程序添加CSS，但不幸的是，在Ellie中没有可用的编译器建议。
- en: 'If a linter was available in Ellie, we would notice a warning on the `main` function,
    as the linter would show it as underlined. If we had the linter available, hovering
    over the warning underline would result in the following message showing in a
    popup:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Ellie中可用一个linter，我们会注意到`main`函数上的警告，因为linter会将其显示为下划线。如果我们有linter可用，将鼠标悬停在警告下划线上会弹出一个显示以下消息的提示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Interestingly, the Ellie app previously had the linter automatically enabled,
    but for some reason, it is currently not being used on the Ellie editor. Later
    on in this chapter, we'll see how to set up a more robust development environment
    for our Elm apps.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Ellie应用程序之前自动启用了linter，但出于某种原因，目前它没有在Ellie编辑器中使用。在本章的后面部分，我们将看到如何为我们的Elm应用程序设置一个更健壮的开发环境。
- en: 'Let''s pretend for a moment that we indeed do have a linter in our Ellie app,
    and include the preceding type annotation, so our code will look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们确实在我们的Ellie应用程序中有一个linter，并包含前面的类型注解，这样我们的代码将看起来像这样：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we also exposed the `class` function in the preceding code. Click
    the Compile button again. As mentioned earlier, adding type annotations, while
    not compulsory, is considered a best practice.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在前面的代码中暴露了`class`函数。再次点击编译按钮。如前所述，添加类型注解虽然不是强制性的，但被认为是最佳实践。
- en: 'At this point, just what the `main : HTML msg` means was left out on purpose.
    The goal of this chapter is to introduce you to the general ideas of how things
    work in Elm without covering all the details so that you can grasp the most important
    concepts and only then look at other, more difficult paradigms.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '到这一点，故意省略了`main : HTML msg`的含义。本章的目标是向您介绍Elm中事物工作的一般思想，而不涉及所有细节，这样您可以掌握最重要的概念，然后再查看其他更复杂的设计模式。'
- en: There are more features in Ellie that make it the best possible editor to start
    getting familiar with Elm.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Ellie还有更多功能，使其成为开始熟悉Elm的最佳编辑器。
- en: However, to make sure you get the most out of this introductory chapter, we
    will also look at setting up Elm using the wonderful `create-elm-app` npm package.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了确保您充分利用这一章的介绍，我们还将查看如何使用神奇的`create-elm-app` npm包来设置Elm。
- en: Finally, we will wrap this chapter up by seeing how to set up Elm to work with
    a code editor (Atom from GitHub) on your computer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过查看如何在您的计算机上设置Elm以与代码编辑器（GitHub的Atom）一起工作来结束这一章。
- en: Getting started fast with create-elm-app
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始使用create-elm-app
- en: To quickly make an Elm app using npm, you need to have Node and npm installed
    on your computer. The advantages of using the `elm-app` npm package is that the
    setup is very easy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速使用 npm 创建 Elm 应用程序，您需要在您的计算机上安装 Node 和 npm。使用 `elm-app` npm 包的优势在于设置非常简单。
- en: 'You simply install it through the command line, using the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需通过命令行使用以下命令进行安装：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command will install the `create-elm-app` package globally on
    your system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在您的系统上全局安装 `create-elm-app` 包。
- en: 'Next, open the folder where you would like to have your Elm app installed.
    Let''s say you want to call your app `elm-fun`. In that case, run the following
    command to install your Elm app:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开您希望安装 Elm 应用的文件夹。假设您想将您的应用命名为 `elm-fun`。在这种情况下，运行以下命令来安装您的 Elm 应用：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, to run your app, `cd` into the `elm-fun` folder, and run the following
    command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要运行您的应用程序，请切换到 `elm-fun` 文件夹，并运行以下命令：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since your app contains no code yet, you''ll just be greeted with an Elm logo.
    This is a confirmation that things are running fine. If you''d like to see your
    app do at least something else, try adding the following snippet of code in `Main.elm`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用还没有代码，您将只会看到一个 Elm 标志。这是确认一切运行正常的一个信号。如果您想看到您的应用至少做些其他事情，尝试在 `Main.elm`
    中添加以下代码片段：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With your `elm-app start` command still running in your console, it will recompile
    your project upon save and show you a simple web page.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的 `elm-app start` 命令在控制台中运行时，它会在保存时重新编译项目，并显示一个简单的网页。
- en: To find out more about this npm package, point your browser to this URL: [https://www.npmjs.com/package/create-elm-app](https://www.npmjs.com/package/create-elm-app)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此 npm 包的信息，请将您的浏览器指向此 URL：[https://www.npmjs.com/package/create-elm-app](https://www.npmjs.com/package/create-elm-app)
- en: Getting started with Elm on Windows 10
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 10 上开始使用 Elm
- en: Unfortunately, there are quite a few steps involved to get your Elm environment
    set up on Windows. Luckily, once it is set up, it is a pleasure to work with.
    In this section, we will cover all the steps that need to be taken to set up your
    Elm environment on Windows 10 as easily as possible.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，要在 Windows 上设置 Elm 开发环境需要涉及许多步骤。幸运的是，一旦设置完成，使用起来就非常愉快。在本节中，我们将介绍所有必要的步骤，以便尽可能容易地在
    Windows 10 上设置您的 Elm 开发环境。
- en: 'First, open your command prompt and run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开您的命令提示符并运行以下命令：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Download Atom from [https://atom.io](https://atom.io) and run the installer.
    Install language-elm via the Atom package manager (*CTRL* + *,*) to get to settings,
    click Install Packages, and type language-elm. Enter the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://atom.io](https://atom.io) 下载 Atom 并运行安装程序。通过 Atom 包管理器（*CTRL* + ，）安装
    language-elm 以进入设置，点击“安装包”，并输入 language-elm。输入以下命令：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In powershell, `where.exe elm-oracle` will return this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，`where.exe elm-oracle` 将返回以下内容：
- en: '`C:\Users\PC\AppData\Roaming\npm\elm-oracle`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Users\PC\AppData\Roaming\npm\elm-oracle`'
- en: '`C:\Users\PC\AppData\Roaming\npm\elm-oracle.cmd`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Users\PC\AppData\Roaming\npm\elm-oracle.cmd`'
- en: 'In Atom, type `CTRL ,` to get to the settings. Once in Settings , click Packages,
    then in Installed Packages, filter by package name: `elm`. The package language-elm window
    will open; click its Settings, and inside this package''s Settings, paste in the
    elm-oracle executable path.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Atom 中，按 `CTRL ,` 进入设置。一旦进入设置，点击“包”，然后在“已安装包”中按包名过滤：`elm`。将打开 package-language-elm
    窗口；点击其设置，并在该包的设置中粘贴 elm-oracle 可执行文件的路径。
- en: Installing apm (Atom Package Manager)
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 apm (Atom 包管理器)
- en: 'This is the location to which Atom installs apm by default:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Atom 默认安装 apm 的位置：
- en: '`C:\User\PC\AppData\Local\atom\app-1.19.7`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\User\PC\AppData\Local\atom\app-1.19.7`'
- en: '`C:\User\PC\AppData\Local\atom\app-1.19.7\resources\app\apm\bin`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\User\PC\AppData\Local\atom\app-1.19.7\resources\app\apm\bin`'
- en: 'Now, typing `apm` in powershell will get us a number of options for the `apm`
    command, which means it''s been added to the path successfully. Let''s install
    `atom-beautify` using the `apm` command in our console:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 PowerShell 中输入 `apm` 将会显示一系列 `apm` 命令选项，这意味着它已经成功添加到路径中。让我们通过控制台中的 `apm`
    命令来安装 `atom-beautify`：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Continue by installing `elm-format`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 继续安装 `elm-format`：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Get Windows installer for Elm Platform from [https://guide.elm-lang.org/install.HTML](https://guide.elm-lang.org/install.html),
    click on the Windows installer links, and it will download `Elm-Platform-0.18.exe`.
    Run it to install the Elm Platform. Once the installation is done, click the Finish
    button to close the installation window. Make sure you add it to the path at `C:\Program
    Files (x86)\Elm Platform\0.18\bin`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://guide.elm-lang.org/install.HTML](https://guide.elm-lang.org/install.html)获取Elm平台的Windows安装程序，点击Windows安装程序链接，它将下载`Elm-Platform-0.18.exe`。运行它以安装Elm平台。安装完成后，点击完成按钮关闭安装窗口。确保将其添加到`C:\Program
    Files (x86)\Elm Platform\0.18\bin`的路径中。
- en: Now's the time to download elm-format. To get `elm-format.exe` for windows,
    navigate to [https://github.com/avh4/elm-format/releases](https://github.com/avh4/elm-format/releases)
    and scroll down to the Downloads section. Click on the link that pertains to your
    OS. In our example we are using Windows (specifically Windows 10), so we will
    click on the `elm-format-0.18-0.7.0-exp-win-i386.zip` download link.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是下载elm-format的时候了。要获取Windows版本的`elm-format.exe`，请导航到[https://github.com/avh4/elm-format/releases](https://github.com/avh4/elm-format/releases)，然后滚动到下载部分。点击与你的操作系统相关的链接。在我们的例子中，我们使用的是Windows（具体是Windows
    10），因此我们将点击`elm-format-0.18-0.7.0-exp-win-i386.zip`下载链接。
- en: In order to use elm-format in Windows, we need to point to the elm-format executable
    in our PATH variable. However, since the Elm platform installer points to its
    executables automatically (during the installation process, it adds a new variable
    to the PATH), all we need to do to effectively move the elm-format executable
    to our path is to paste the unzipped executable to `C:\Program Files (x86)\Elm
    Platform\0.18\bin`. In other words, we need to unzip it to the folder that has
    the Elm installation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Windows上使用elm-format，我们需要将我们的PATH变量指向elm-format的可执行文件。然而，由于Elm平台安装程序会自动指向其可执行文件（在安装过程中，它会向PATH添加一个新的变量），我们只需将未压缩的可执行文件粘贴到`C:\Program
    Files (x86)\Elm Platform\0.18\bin`。换句话说，我们需要将其解压缩到包含Elm安装的文件夹中。
- en: If you are not sure where your Elm program is installed, run `where.exe elm`
    in Powershell.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的Elm程序安装在哪里，请在PowerShell中运行`where.exe elm`。
- en: Now open the Atom editor, go to Settings | Packages, and type `elm` in the Installed
    Packages search field.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Atom编辑器，转到设置 | 包，并在已安装包搜索字段中输入`elm`。
- en: The list of packages should include the `elm-format` package; click on its Settings.
    When the `elm-format` package settings open, in the Binary path field, paste in
    the path to your elm executable `C:\Program Files (x86)\Elm Platform\0.18\bin\elm-format.exe` and
    close the settings tab. No need to save, Atom does this automatically.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的包列表应该包括`elm-format`包；点击其设置。当`elm-format`包设置打开时，在二进制路径字段中粘贴你的elm可执行文件路径`C:\Program
    Files (x86)\Elm Platform\0.18\bin\elm-format.exe`，然后关闭设置标签。无需保存，Atom会自动完成。
- en: 'Now, you can test if `elm-format` works by running it on any Elm document.
    For the sake of argument, let''s make a new Elm document that is poorly formatted:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在任意Elm文档上运行它来测试`elm-format`是否工作。为了论证，让我们创建一个新的格式不佳的Elm文档：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s run `elm-format` on this file, from the console. First, you need to
    point your console to the folder in which the badly formatted Elm file sits, then
    run:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制台中运行`elm-format`对此文件进行格式化。首先，你需要将你的控制台指向包含格式错误的Elm文件的文件夹，然后运行：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get the following warning:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到以下警告：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Type `y` to perform the formatting, then inspect the file to see the result.
    Let''s now continue with our installation. To continue, we will install apm linter
    by running this command in our console:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`y`以执行格式化，然后检查文件以查看结果。现在让我们继续安装。为了继续，我们将在控制台中运行以下命令来安装apm linter：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Make sure to keep Atom open as it will install some dependencies right from
    the Atom interface, namely `linter-ui-default` and its default dependencies (intentions,
    busy-signal). Once it''s done, you can proceed to run this command in your console:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Atom保持开启状态，因为它将从Atom界面直接安装一些依赖项，即`linter-ui-default`及其默认依赖项（intentions, busy-signal）。一旦完成，你就可以在控制台中运行以下命令：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding command will install `linter-elm-make` to a location similar
    to this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`linter-elm-make`安装到类似以下的位置：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note: In the preceding example, `PC` is the username.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在先前的示例中，`PC`是用户名。
- en: Now, let's take our setup for a test-drive. Make a new folder, let's call it
    `elmtest`. Inside the folder, create a file. Call it `Main.elm`, and open it in
    the Atom editor.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对我们的设置进行测试。创建一个新的文件夹，让我们称它为`elmtest`。在文件夹内创建一个文件，命名为`Main.elm`，并在Atom编辑器中打开它。
- en: 'As soon as you do it, you''ll get this alert:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，你将收到以下警报：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, let''s run `elm-package install`. First, we''ll point our console to the
    `elmtest` folder, then run:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们运行`elm-package install`。首先，我们将控制台指向`elmtest`文件夹，然后执行：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The console will report: `Packages configured successfully!`. It will also
    list the installed packages.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将报告：“`Packages configured successfully!`”。它还将列出已安装的包。
- en: 'Now, let''s add some code to `Main.elm` to make sure it works:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向`Main.elm`添加一些代码以确保其正常工作：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered a number of important topics, namely:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多重要主题，具体包括：
- en: What is Elm?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Elm？
- en: What is unique about Elm in the saturated field of frontend web development?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在竞争激烈的前端Web开发领域，Elm有什么独特之处？
- en: How does Elm compare to JavaScript?
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elm与JavaScript相比如何？
- en: How to get started quickly with the help of the Ellie-app, the create-elm-app,
    and the Atom editor
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何借助Ellie-app、create-elm-app和Atom编辑器快速入门
- en: In the next chapter, we will look into using `elm-reactor`, `elm-make`, `elm-repl`,
    and `elm-package`, and we will start working with Elm code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用`elm-reactor`、`elm-make`、`elm-repl`和`elm-package`，并开始编写Elm代码。
