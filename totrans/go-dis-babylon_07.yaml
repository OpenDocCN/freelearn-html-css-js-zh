- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Processing Route Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路线数据
- en: Although we won’t be looking at the transition between route planning and route
    driving quite yet, in the big picture of where things stand, generating a route
    is an integral piece of the Space-Truckers gameplay. In this chapter, we’re going
    to stick with the previous practice of taking a brief detour into a tangential
    topic – in this case, that topic will be spiffing up the Sun rendering with some
    Particle Systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们目前不会探讨路线规划和路线驾驶之间的过渡，但从大局来看，生成路线是Space-Truckers游戏玩法的一个关键部分。在本章中，我们将继续之前的做法，简要地偏离到一个相关的话题——在这种情况下，这个话题将是使用一些粒子系统来美化太阳渲染。
- en: Following our detour into particle systems, we’ll dive straight into how to
    capture, crunch, and consolidate the data from route planning into a rich set
    of encounters based on location, which will then drive player challenges in the
    next phase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对粒子系统的偏离之后，我们将直接探讨如何从路线规划中捕获、处理和整合数据，形成一个基于位置的丰富遭遇集，这将随后驱动下一阶段的玩家挑战。
- en: What makes this all possible is a technique that has its roots in the earliest
    days of the RPG – when dark Dungeons filled with dangerous Dragons saw players
    rolling dice against encounter tables that would determine their fate. The encounter
    tables for Space-Truckers are categorized by zoneand play a similar part in determining
    a Space-Trucker's fate. Each zone has a list of potential encounters along with
    a base probability or chance of that encounter happening. Most encounters carry
    potential hazards the player must act upon to avoid or mitigate, while, more rarely,
    other encounters may have beneficial effects (if managed correctly).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切成为可能的是一种技术，其根源可以追溯到RPG的最早时期——当黑暗的地下城充满了危险的龙，玩家在遭遇表中掷骰子以决定他们的命运时。Space-Truckers的遭遇表按区域分类，并在决定Space-Trucker的命运中扮演着类似的角色。每个区域都有一系列可能的遭遇，以及该遭遇发生的基概率或机会。大多数遭遇都携带玩家必须采取行动以避免或减轻的潜在危险，而更少的情况下，其他遭遇可能会有益的效果（如果管理得当）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A Detour into Practical Systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏离到实用系统
- en: Marking Out the Route
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记路线
- en: Defining the Encounter Zone
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义遭遇区域
- en: Selecting Encounters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择遭遇
- en: Adding Encounter Visuals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加遭遇视觉效果
- en: By the end of this chapter, we’ll have prettied up the route-planning environment
    a little, but for the most part, the areas of the application being covered won’t
    have as much tangible effect on the end user experience. That’s OK – it will end
    up having a huge effect later! For this to become the case, though, we must build
    up some logic to process and prepare the route for encounters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将稍微美化一下路线规划环境，但就应用覆盖的区域而言，对最终用户体验的实质性影响不会很大。这是可以的——它最终会产生巨大的影响！然而，为了实现这一点，我们必须构建一些逻辑来处理和准备路线以供遭遇使用。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical prerequisites are not a whole lot different in this chapter, but
    there are some concepts and techniques that may have utility for the topics in
    this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术先决条件并没有太大的不同，但有一些概念和技术可能对本章的主题有用。
- en: 'Here are some topics to research if you’re feeling lost, overwhelmed by complexity,
    or having trouble with a particular area:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到迷茫、被复杂性压倒或对某个特定领域有困难，以下是一些需要研究的话题：
- en: 'Particle System: [https://doc.babylonjs.com/divingDeeper/particles](https://doc.babylonjs.com/divingDeeper/particles)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统：[https://doc.babylonjs.com/divingDeeper/particles](https://doc.babylonjs.com/divingDeeper/particles)
- en: 'Torus Set Shape: [https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus](https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲集形状：[https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus](https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus)
- en: 'Torus (maths): [https://www.mathsisfun.com/geometry/torus.xhtml](https://www.mathsisfun.com/geometry/torus.xhtml)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭曲（数学）：[https://www.mathsisfun.com/geometry/torus.xhtml](https://www.mathsisfun.com/geometry/torus.xhtml)
- en: 'More torus maths: [https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/](https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多扭曲数学：[https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/](https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/)
- en: The source code for this chapter is located at [https://github.com/jelster/space-truckers/tree/ch7](https://github.com/jelster/space-truckers/tree/ch7)
    and contains all the work in this chapter and previous ones. In addition to that,
    there are several improvements, bug fixes, and tweaks that have been introduced
    separately from what’s been covered previously in this book. While it would be
    great if we could include and discuss each of these in greater detail, that’s
    not possible in the space and time available! Where relevant, though, these changes
    will be called out. For the most part, however, the changes aren’t introducing
    any new concepts or techniques, but just refining, fixing, or enhancing what’s
    already present.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于[https://github.com/jelster/space-truckers/tree/ch7](https://github.com/jelster/space-truckers/tree/ch7)，其中包含本章以及之前章节的所有工作。此外，还有一些独立的改进、错误修复和调整，这些内容在本书之前的内容中并未涉及。虽然如果能详细讨论这些内容会很好，但在现有的时间和空间内这是不可能的！然而，在相关的地方，这些变化将会被指出。然而，大多数变化并没有引入任何新的概念或技术，而是对现有的内容进行了细化、修复或增强。
- en: A Detour into Particle Systems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统的小插曲
- en: Particle systems are an area of graphics programming that, like the topic of
    input processing, can have entire books devoted to covering particle systems from
    basic theory to concrete implementation. We’re not going to get into that level
    of detail here, because we’ve got a lot of other things to do in addition to learning
    about particle systems! Here’s what you need to know about particle systems in
    general. In a moment, we’ll look at their relationship to Babylon.js and how we
    can use them for fun and profit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是图形编程的一个领域，就像输入处理这个主题一样，可以有一整本书专门介绍粒子系统，从基本理论到具体实现。我们在这里不会深入到那个程度，因为我们还有许多其他事情要做，除了学习粒子系统！以下是你需要了解的关于粒子系统的一般知识。稍后，我们将探讨它们与
    Babylon.js 的关系，以及我们如何利用它们带来乐趣和利润。
- en: Think back to the last video game you played. If it was a text-based game, then
    think of the last game you played that wasn’t text-based. Did the game have explosions?
    Are there magic fireballs exploding? What about fireworks or campfires? Each of
    these is an example of where a particle system might be employed by a game developer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你最近玩过的最后一款视频游戏。如果是一款基于文本的游戏，那么就想想你最近玩过的非文本游戏。游戏中有没有爆炸效果？有没有爆炸的魔法火球？又或者是烟花或篝火？这些都是游戏开发者可能会使用粒子系统的例子。
- en: Let’s back up a bit. A particle is a single entity with a discrete life cycle
    of creation and death. It is usually represented not with a single mesh but with
    a texture, for most particles are 2D billboard textures or sprites. The texture
    or image has transparency properties blended into the rest of the scene in a varying
    number of ways. If “transparency properties” is confusing, it can be helpful to
    recall that transparency refers to the alpha channel, and the properties of this
    channel are the instructions to the engine on how to blend or mix that channel
    with overlapping colors. This means that often, a particle will always be oriented
    so that it is always directly facing the camera, and that it will have the ability
    to fade in and out of view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。粒子是一个具有离散生命周期（创建和死亡）的单一实体。它通常不是用一个网格表示，而是用一个纹理表示，因为大多数粒子是二维的横幅纹理或精灵。纹理或图像具有透明度属性，以不同的方式与其他场景混合。如果“透明度属性”这个词让你感到困惑，那么回忆一下透明度指的是alpha通道，这个通道的属性是向引擎发出的指令，告诉它如何将这个通道与重叠的颜色混合或混合。这意味着，通常，粒子总是以直接面向摄像机的方向排列，并且它将具有淡入淡出的能力。
- en: 'A particle system is more than just an aggregation of particles. A particle
    system is what defines and controls the entire life cycle of its constituent particles.
    It does this through a few primary mechanisms:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统不仅仅是粒子的集合。粒子系统定义并控制其组成粒子的整个生命周期。它通过几个主要机制来完成这项工作：
- en: '**Emitter(s)**: The mesh or node where a particle begins its life. Different
    properties of the emitter allow granular control over parts of the mesh and the
    shape of the emission, as well as the number of particles emitted and the rate
    of emissions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射器**：粒子开始其生命周期的网格或节点。发射器的不同属性允许对网格的一部分和发射形状进行粒度控制，以及发射的粒子数量和发射速率。'
- en: '**Particle properties**: Both visual and behavioral, these include size, scaling,
    rotation, color, and speed for the former, and lifetime for the latter.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子属性**：包括视觉和行为属性，前者包括大小、缩放、旋转、颜色和速度，后者包括寿命。'
- en: '**Animations, noise, and blending effects**: Adding noise to the system enhances
    the realism of the particle system, while animations provide a dynamic look and
    feel to it.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画、噪声和混合效果**：向系统中添加噪声可以增强粒子系统的真实感，而动画则提供了动态的外观和感觉。'
- en: If a particle system is comprised of particles, then what about a collection
    of particle systems? That is what’s called a Particle System Set, and that is
    also what we will be employing to give the Sun of Space-Truckers a bit of “flare!”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个粒子系统由粒子组成，那么粒子系统的集合又是什么呢？这被称为粒子系统集，这也是我们将要使用的东西，以给 Space-Truckers 的太阳增添一点“光辉”！
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: That last sentence may have been a pun too far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后一句话可能有点过头了。
- en: The advantage of using a Particle System Set is that we can use a single consolidated
    piece of logic to load, start, and stop all the systems at once. Although we’ll
    be using the Particle System Set in our imminent future, there are a couple of
    other different but related means of generating and managing particles in Babylon.js.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用粒子系统集的优势在于我们可以使用单一的综合逻辑来一次性加载、启动和停止所有系统。尽管我们将在不久的将来使用粒子系统集，但在 Babylon.js 中还有其他几种不同但相关的生成和管理粒子的方法。
- en: The Disparate Particle Systems of Babylon.js
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babylon.js 的不同粒子系统
- en: The family tree of BJS particle systems isn’t nearly as complex as the Greek
    pantheon, but what it does share with that fabled genealogy is a separation of
    generations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: BJS 粒子系统的家族树并不像希腊众神那样复杂，但它与那个传奇的家谱共享的是代际分离。
- en: The “Classic” CPU Particle System
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “经典”CPU 粒子系统
- en: This is what everyone knows, loves, and is familiar with. The vanilla flavor
    of the three, this offers the greatest amount of end developer (that is, you)
    programmatic control over every aspect of the particle’s behavior. Because it
    runs on the CPU every frame, it must share time in the frame budget with everything
    else the game needs to happen between frames. If the target framerate is 60 FPS,
    then the intra-frame budget is just 1/60s or just under 17 milliseconds. As any
    middle-child sibling knows, compromise is key!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是每个人都知道、喜爱和熟悉的东西。三种的原始风味，这为最终开发者（即你）提供了对粒子行为每个方面的最大程序控制。因为它每帧都在 CPU 上运行，所以它必须与其他需要在帧之间发生的事情共享帧预算中的时间。如果目标帧率为
    60 FPS，那么帧内预算仅为 1/60 秒或略低于 17 毫秒。正如任何中间的孩子兄弟所知，妥协是关键！
- en: The “New Wave” GPU Particle System
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “新浪潮”GPU 粒子系统
- en: Since graphics accelerators have become pretty much ubiquitous in today’s computing
    environment (evidenced by a certain Web-GPU JavaScript framework…), so have the
    tools needed to program them to become more powerful. Later, in [*Chapter 11*](B17266_11_Final_AM.xhtml#_idTextAnchor230),
    *Scratching the Surface of Shaders*, we’ll take a closer look at how we can easily
    and effectively leverage this power for fun (and profit!), but for the present
    moment, the relevant fact is that the same particle systems that we used to run
    on the CPU are now executed and updated directly on the GPU. The biggest effect
    of this change is that the number of particles available to use has gone up drastically.
    Instead of worrying about the effect of a few hundred particles on performance,
    the same concerns only start to appear when particles number in the tens of thousands
    – quite a large improvement!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图形加速器在今天的计算环境中几乎无处不在（由某个 Web-GPU JavaScript 框架……为证），因此用于编程它们的工具也变得更加强大。稍后，在第
    11 章[*表面下的着色器*](B17266_11_Final_AM.xhtml#_idTextAnchor230)中，我们将更详细地探讨如何轻松有效地利用这种力量来娱乐（以及盈利！）但就目前而言，相关的事实是，我们以前在
    CPU 上运行的相同粒子系统现在直接在 GPU 上执行和更新。这种变化的最大影响是可用粒子的数量急剧增加。不再需要担心几百个粒子对性能的影响，当粒子数量达到数万时，同样的担忧才开始出现——这是一个相当大的改进！
- en: The “Hard Core” Solid Particle System
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “硬核”固态粒子系统
- en: When the pedal hits the pavement and things get real, it’s time to pull out
    the big guns. A **Solid Particle System** (**SPS**) is constructed not from a
    point-like particle but from a three-dimensional mesh. Each particle instance
    must share the same material as the other SPS instances, but the other attributes
    such as position, scale, rotation, and others are all controlled by the developer.
    SPS particles can be physics-enabled, along with providing support for collisions.
    The downside of this level of control and detail is that each property must also
    be set and controlled individually – unlike a regular particle system that evolves
    according to the various attribute values associated with it. Hard-coding the
    individual values for a system is tedious, error-prone, and not very fun to maintain.
    It’s fine to do that for Playgrounds and prototypes, but for our application,
    we’re going to want to be able to represent our Particle Systems as data that
    we can manage separately from the behavior of the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当踏板触碰到路面，事情变得真实起来时，就是时候拿出杀手锏了。**固体粒子系统**（**SPS**）是由一个三维网格构成的，而不是由点状粒子构成的。每个粒子实例必须与其他SPS实例共享相同的材质，但其他属性，如位置、缩放、旋转等，都由开发者控制。SPS粒子可以启用物理效果，并提供碰撞支持。这种程度控制和细节的缺点是，每个属性都必须单独设置和控制——这与根据与之关联的各种属性值演变的常规粒子系统不同。为系统硬编码单个值是繁琐的、容易出错的，而且维护起来也不是很有趣。对于游乐场和原型来说，这样做是可以的，但对我们应用来说，我们希望能够将粒子系统表示为可以独立于应用程序行为进行管理的数据。
- en: Loading Particle Systems From Saved Data
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从保存的数据加载粒子系统
- en: When dealing with CPU or GPU Particle Systems, it can be extremely tedious and
    error-prone to type and tweak each specific property through code. The almighty
    Babylon.js Inspector (praise be its crazy good nature!) is probably the quickest
    way to iterate against different property values to see what they look like in
    real time, but how to effectively capture the current state of every property
    for every particle system in a Particle System Set may appear, at first, to be
    elusive. However, like many things in Babylon.js, there are multiple ways to accomplish
    the same goal. Fortunately, though, there are multiple ways to get the same result;
    each of them makes use of different methods of the **ParticleHelper**. All three
    are available to use in the Inspector (see *Figure 7.2*), which can be used to
    choose the most appropriate method for the requirements of the project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理CPU或GPU粒子系统时，通过代码逐个输入和调整每个特定属性可能会非常繁琐且容易出错。万能的Babylon.js检查器（赞美其疯狂的好性质！）可能是迭代不同属性值以实时查看它们的最快方式，但如何有效地捕捉粒子系统集中每个粒子的每个属性当前状态，一开始可能看起来很困难。然而，就像Babylon.js中的许多事情一样，有多种方法可以实现相同的目标。幸运的是，有多种方法可以得到相同的结果；它们都利用了**ParticleHelper**的不同方法。所有三种方法都在检查器中可用（见*图7.2*），可以根据项目需求选择最合适的方法。
- en: ExportSet/Save to File (Inspector)
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExportSet/保存到文件（检查器）
- en: First up is the purely programmatic approach of calling `ParticleHelper.ExportSet(setA,
    setB,…)`. The output of the function is a JSON string, which can then be saved
    to a file or stored somewhere else. It’s easiest to use this method in the Playground
    after putting together multiple systems. Using the Inspector, it’s possible to
    save a single system to JSON by selecting the desired system in the Scene Explorer,
    then clicking the **Save…** button under the **FILE** heading. This is useful
    for single-system setups, but for saving multiple systems to file, the **ExportSet**
    is the best option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是纯粹程序化的方法，即调用`ParticleHelper.ExportSet(setA, setB,…)`。该函数的输出是一个JSON字符串，然后可以将其保存到文件或存储在其他地方。在将多个系统组合在一起后，在游乐场中使用此方法最简单。使用检查器，可以通过在场景资源管理器中选择所需的系统，然后在**文件**标题下的**保存…**按钮处点击，将单个系统保存为JSON。这对于单个系统设置很有用，但为了将多个系统保存到文件，**ExportSet**是最佳选择。
- en: Saving a Snippet to the Snippet Server (Inspector)
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将代码片段保存到代码片段服务器（检查器）
- en: 'With the Babylon.js Playground open in a browser – here’s one for reference:
    [https://playground.babylonjs.com/#735KL4#15](https://playground.babylonjs.com/%23735KL4%2315)
    – notice how the specific Playground is identified by a unique combination of
    a hash (the #735KL4 part) and a revision (#15). Well, the idea of making Playground
    resources referenceable in that fashion worked so well that the concept has been
    extended to many other areas of Babylon.js.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 Babylon.js Playground（这里有一个参考链接：[https://playground.babylonjs.com/#735KL4#15](https://playground.babylonjs.com/%23735KL4%2315)）——注意特定的
    Playground 是通过一个唯一的组合来识别的，包括哈希（#735KL4 部分）和修订版（#15）。嗯，以这种方式使 Playground 资源可引用的想法非常成功，以至于这个概念已经扩展到
    Babylon.js 的许多其他领域。
- en: 'Want to load up a GUI setup in the `ParticleHelper.CreateFromSnippetAsync`.
    You can read more about the Snippet Server for Particle Systems in the official
    docs: [https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想在 `ParticleHelper.CreateFromSnippetAsync` 中加载 GUI 设置。您可以在官方文档中了解更多关于粒子系统片段服务器的内容：[https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets)。
- en: Using a Built-In Particle System Set
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置的粒子系统集
- en: 'Aristotle was an influential guy even during his time, and his idea that things
    are made of four “elements” – air, earth, fire, and water – was widely accepted
    as being true, mostly due to good marketing. In that spirit, Babylon.js provides
    a basic “elemental” catalog of particle system sets for you to use. Here are the
    available effects (see more about them in the docs at [https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 亚里士多德在他那个时代就已经是一位有影响力的人物，他关于事物由四种“元素”组成——空气、土地、火焰和水——的观点被广泛接受为真理，这主要归功于良好的营销。在这种精神下，Babylon.js
    为您提供了一个基本的“元素”粒子系统集目录，供您使用。以下是可用的效果（更多关于它们的信息，请参阅文档中的[https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects)）：
- en: '**Explosion**: Good for blowing stuff up.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**爆炸**：非常适合用来炸毁东西。'
- en: '**Rain**: For that extra bit of melancholy.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**雨**：为额外的忧郁感加分。'
- en: '**Smoke**: Useful to signal the selection of a new Pope, but also for a lot
    of other things. Just remember, where there’s smoke, there’s often…'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烟雾**：用于表示新教皇的选择非常有用，但也适用于许多其他事情。记住，有烟的地方，通常……'
- en: '**Fire**: Whether it’s a campfire, a torch, or a good old-fashioned house fire,
    this is the place to start.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火焰**：无论是篝火、火炬还是传统的房屋火灾，这里都是开始的地方。'
- en: '**Sun**: Jackpot! This particle set includes flares, a dynamically evolving
    surface, and the hazy glare of a coronasphere. There’s just one problem…'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**太阳**：大奖！这个粒子集包括耀斑、动态变化的面部，以及光环的模糊光芒。但有一个问题……'
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: There was another theory floating around that things are made of these tiny,
    indivisible particles called (*ἄτομος*, or *atomos*), but its main proponent,
    Democritus, wasn’t as popular as Aristotle, so nobody listened to him. Who’s got
    the last laugh now, Aristotle?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个理论认为事物由这些微小、不可分割的粒子组成，称为（*ἄτομος*，或*atomos*），但其主要支持者德谟克利特并不像亚里士多德那样受欢迎，所以没有人听他的。现在谁才是最后的赢家，亚里士多德？
- en: What’s this problem mentioned? It’s not a big one. It’s kind of – no, it’s exactly
    the opposite of a big problem. It’s a small problem, one of scale. The Sun effect
    is perfect for our needs, but it’s way, way, way too small. We need to be able
    to scale it up to match our astronomical proportions, but it’s not going to be
    precise in how or where things are scaled – that will take some experimentation.
    The Playground at [https://playground.babylonjs.com/#J9J6CG#9](https://playground.babylonjs.com/%23J9J6CG%239)
    shows the tweaks involved that were eventually incorporated into the JSON data
    committed to the Space-Truckers code repository.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的这个问题是什么？这不是一个大问题。它有点——不，它正是大问题的反面。这是一个小问题，一个是规模问题。太阳效果非常适合我们的需求，但它太小了，太小了，太小了。我们需要能够将其放大以匹配我们的天文比例，但它的缩放方式或位置不会很精确——这需要一些实验。在
    [https://playground.babylonjs.com/#J9J6CG#9](https://playground.babylonjs.com/%23J9J6CG%239)
    的 Playground 中展示了最终被纳入 Space-Truckers 代码库 JSON 数据中的调整。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Though it would be ideal to include all the various game design aspects and
    decisions involved in this book, it isn’t possible to anticipate everything ahead
    of time. There are also pragmatic limits as to how large this book can get. Therefore,
    where applicable, links will be provided to GitHub Issues that provide details
    about the feature or part of the game. Issues in GitHub can be linked to other
    Issues and to Pull Requests (among other things), which makes it easy to quickly
    assess and evaluate the code associated with a given Issue or feature. Relevant
    to our current work, this issue – *Star should have occasional flares and activity*
    ([https://github.com/jelster/space-truckers/issues/71](https://github.com/jelster/space-truckers/issues/71))
    – aggregates links from the Babylon.js docs and from Playground snippets to provide
    insight into the desired outcome. Comments and linked Pull Requests show the history
    and evolution of the issue. This isn’t to say that we’re not going to cover the
    game design or details of it – far from it! Simply put, things in software evolve
    and change at a vastly disproportionate rate to that of other goods and industries,
    such as publishing. Those wishing to see how the game has evolved can do so by
    reading through the Issues documenting that change.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本书中包含所有各种游戏设计方面和涉及的决定是理想的，但事先预知一切是不可能的。此外，本书的大小也有实际的限制。因此，在适用的情况下，将提供指向 GitHub
    Issues 的链接，这些 Issues 提供有关功能或游戏部分的详细信息。GitHub 中的 Issues 可以链接到其他 Issues 和 Pull Requests（以及其他内容），这使得快速评估和评估与特定
    Issue 或功能相关的代码变得容易。与我们当前的工作相关，这个问题 – *星系应该偶尔出现耀斑和活动* ([https://github.com/jelster/space-truckers/issues/71](https://github.com/jelster/space-truckers/issues/71))
    – 从 Babylon.js 文档和 Playground 片段中汇总链接，以提供对期望结果的见解。评论和链接的 Pull Requests 展示了问题的历史和演变。这并不是说我们不会涵盖游戏设计或其细节——远非如此！简单来说，软件中的事物以与其他商品和行业（如出版业）不成比例的速度发展和变化。希望了解游戏如何演变的人可以通过阅读记录该变化的
    Issues 来实现。
- en: Before we can get into those changes, we must figure out how to load and start
    the Particle System Set from a JSON file. There is friction in attempting this.
    The **ParticleHelper** is designed and built with the focus on removing complexity
    for developers, certain aspects of which can be obstacles to our goals.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以深入了解这些变化之前，我们必须弄清楚如何从 JSON 文件加载和启动粒子系统集。尝试这样做会有摩擦。**ParticleHelper** 是设计和构建的，重点是减少开发者的复杂性，其中某些方面可能成为我们目标的障碍。
- en: Parsing From a JSON File
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 JSON 文件解析
- en: 'One of those convenient features that ends up becoming a bit of an obstacle
    is that the `CreateAsync` method of `PracticalHelper` takes just a string representing
    the type of the system to create – that is, “rain,” “smoke,” “Sun,” and so on.
    This string is then used in conjunction with `ParticleHelper.BaseAssetsUrl` to
    construct the full URL for the JSON file. Unless explicitly overridden, `BaseAssetsUrl`
    has a value of [https://github.com/BabylonJS/Assets/tree/master/particles/](https://github.com/BabylonJS/Assets/tree/master/particles/).
    The structure of the folders places the JSON files in a `/systems` subfolder and
    textures in the `/textures` subfolder – a nice consistent convention that works
    great for most use cases, save ours. The main conflicts with our setup are as
    follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最终成为障碍的便利功能是 `PracticalHelper` 的 `CreateAsync` 方法仅接受一个字符串，表示要创建的系统的类型——即“雨”、“烟”、“太阳”等等。然后，这个字符串将与
    `ParticleHelper.BaseAssetsUrl` 结合使用，以构建 JSON 文件的完整 URL。除非明确覆盖，否则 `BaseAssetsUrl`
    的值为 [https://github.com/BabylonJS/Assets/tree/master/particles/](https://github.com/BabylonJS/Assets/tree/master/particles/)。文件夹的结构将
    JSON 文件放在 `/systems` 子文件夹中，并将纹理放在 `/textures` 子文件夹中——这是一个很好的、一致的约定，对于大多数用例都工作得很好，但不是我们的情况。与我们的设置冲突的主要问题如下：
- en: Our folder structure is different from what the convention assumes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的文件夹结构与常规假设的不同
- en: Multiple assets need to use the same textures
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个资源需要使用相同的纹理
- en: We are using webpack to bundle and manage our assets and dependencies, so our
    design-time folder structures vary slightly from that of runtime
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用 webpack 来打包和管理我们的资源和依赖项，因此我们的设计时文件夹结构略不同于运行时
- en: Relying on external sources for core game assets and data complicates and prevents
    offline/native/PWA-type scenarios
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于外部来源的核心游戏资源和数据会复杂化并阻止离线/本地/PWA类型的场景
- en: The first and last items can be mitigated, to an extent, by using relative paths
    and by overriding `BaseAssetsUrl` and making it something like `document.baseURI`.
    The middle two, however, require a bit more thinking to resolve. Examining the
    **ParticleHelper** source code (see [https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts](https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts))
    reveals that there’s no practical way to override the conventional logic that
    computes the URL of the JSON file. However, once past that step, parsing and hydrating
    the particle system set is very straightforward. The problem here isn’t that we
    can’t use the conventional approach, it’s that because of webpack, we don’t need
    to figure out how to load the JSON data – we already have it, while the **ParticleHelper**
    expects to have to retrieve the same. It’s time to start thinking like everyone’s
    favorite field engineer from the mid-1980s, MacGyver.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项和最后一项可以通过使用相对路径和覆盖`BaseAssetsUrl`并使其类似于`document.baseURI`来在一定程度上缓解。然而，中间两项需要更多的思考来解决。检查**ParticleHelper**的源代码（见[https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts](https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts)）揭示，没有实际的方法可以覆盖计算JSON文件URL的传统逻辑。然而，一旦过了这一步，解析和初始化粒子系统集就非常直接了。这里的问题并不是我们不能使用传统方法，而是由于webpack，我们不需要找出如何加载JSON数据——我们已经有它了，而**ParticleHelper**期望需要检索相同的。是时候开始像1980年代中期的每个人都喜欢的领域工程师MacGyver一样思考了。
- en: '**What would MacGyver do** (**WWMD**)? MacGyver’s greatest strength wasn’t
    that he was big and brawny, or that he could kick bad-guy butt in a fistfight.
    It wasn’t even his luxurious mane of hair that would make an Olympian God (or
    Goddess!) jealous. No, MacGyver’s greatest strength was that he could build, hack,
    or otherwise science his way out of pretty much any situation he found himself
    stuck in. By paying attention to his surroundings and then applying his (extensive)
    knowledge of subjects far and wide, he proved that a sharp eye and a clever mind
    can overcome almost any obstacle. Let’s look at this problem through a MacGyver-tinted
    lens:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**MacGyver会怎么做**（**WWMD**）？MacGyver最大的优势并不是他高大威猛，或者他能在拳击中踢坏坏蛋的屁股。甚至不是他那让奥林匹克神（或女神！）都嫉妒的华丽长发。不，MacGyver最大的优势是他能够通过建造、破解或以其他方式科学地摆脱他发现自己陷入的几乎所有困境。通过关注周围的环境，然后应用他对各个领域（广泛）的（广泛）知识，他证明了敏锐的视角和聪明的头脑可以克服几乎任何障碍。让我们用MacGyver的视角来看这个问题：'
- en: “*We need to get a ParticleSystemSet before the bomb goes off! The JSON data
    is loaded, but the ParticleHelper needs the URL string, and there’s only one minute
    left until everything goes boom… What else do we have, let’s see… ah! Pass the
    object data to ParticleSystemSet.Parse and bypass the ParticleHelper entirely
    but do it quickly – we’re running out of time!*”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “*在炸弹爆炸之前，我们需要获取一个粒子系统集！JSON数据已经加载，但ParticleHelper需要URL字符串，而且只剩下最后一分钟，然后一切都会爆炸…我们还剩下什么，看看…啊！将对象数据传递给ParticleSystemSet.Parse，完全绕过ParticleHelper，但必须快速——我们正在耗尽时间!*”
- en: So, according to MG up there, we don’t want to use the `ParticleSystemSet.Parse`,
    since that’s what the `Parse` method ([https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse](https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse)).
    Knowing that we were starting with a plain old JavaScript object deserialized
    from the correct definition file, he made the rather obvious (in hindsight, natch)
    conclusion that since the result (a `name` property. Thanks to MG, we have the
    tools we need to be able to integrate the Sun particle system set with our application!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，根据上面的MG（MG在这里），我们不想使用`ParticleSystemSet.Parse`，因为那就是`Parse`方法（[https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse](https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse)）。知道我们是从一个从正确的定义文件反序列化的普通JavaScript对象开始，他得出了一个相当明显（事后看来，自然如此）的结论：由于结果（一个`name`属性。多亏了MG，我们有了所需的工具，能够将太阳粒子系统集与我们的应用程序集成！
- en: Adapting the Sun Particle System Set
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配太阳粒子系统集
- en: 'The proof-of-concept Playground ([https://playground.babylonjs.com/#J9J6CG#9](https://playground.babylonjs.com/%23J9J6CG%239))
    gave us a general idea of where to scale things in the game, but there’s more
    to be done to get the Sun system working the way we want it to. The Playground
    only has one of the three particle systems – the flare system – while there are
    two others; that is, the Sun and glare systems. These must also be properly scaled
    and configured. The best way to get it done is by following these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 概念验证游乐场([https://playground.babylonjs.com/#J9J6CG#9](https://playground.babylonjs.com/%23J9J6CG%239))让我们对游戏中要缩放的物体有一个大致的了解，但要实现我们想要的太阳系统，还有更多工作要做。游乐场只有一个三个粒子系统中的一个
    – 焰系统 – 而还有另外两个；也就是说，太阳和眩光系统。这些也必须正确缩放和配置。完成这项工作的最佳方式是按照以下步骤进行：
- en: Go to the Babylon.js assets repository and save the needed JSON and texture
    files to the local repository. For example, the Sun set is located at [https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json](https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Babylon.js资产仓库，并将所需的JSON和纹理文件保存到本地仓库中。例如，日落位于[https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json](https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json)。
- en: Open the `sun.json` file and change the texture paths to reflect the project’s
    folder structure. Use relative paths, but make sure to consider the relative path
    of the consuming script, not the path of the JSON file. In the `Star` class, add
    the necessary code to load and start the set (see [https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26](https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26)).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`sun.json`文件，并将纹理路径更改为反映项目的文件夹结构。使用相对路径，但请确保考虑消耗脚本的相对路径，而不是JSON文件的路径。在`Star`类中，添加必要的代码来加载并启动集合（见[https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26](https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26)）。
- en: With the application running and on the appropriate screen, open the **Inspector**
    window by pressing the appropriate key combination (*Shift* + *Alt* + *I* by default).
    Modify the properties of the systems and wait for the changes to take effect.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序运行并在适当的屏幕上时，通过按适当的键组合（默认为*Shift* + *Alt* + *I*）打开**检查器**窗口。修改系统的属性，并等待更改生效。
- en: Update the properties of the various systems so that they match the desired
    values.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新各个系统的属性，使其与所需值匹配。
- en: GOTO (3).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到(3)。
- en: 'The result will be whatever you think looks the coolest, but if you want to
    start with or just go with the existing definition, you can find it at [https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json](https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是你认为看起来最酷的东西，但如果你想从现有的定义开始，或者只是跟随现有的定义，你可以在[https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json](https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json)找到它：
- en: '![Figure 7.1 – After the Sun particle system has been adapted to the scale
    of Space-Truckers. The Inspector window is crucial to being able to see the effect
    of different values in real time](img/Figure_7.01_B17266.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – Sun粒子系统适应了Space-Truckers的规模之后。检查器窗口对于实时看到不同值的效果至关重要](img/Figure_7.01_B17266.jpg)'
- en: Figure 7.1 – After the Sun particle system has been adapted to the scale of
    Space-Truckers. The Inspector window is crucial to being able to see the effect
    of different values in real time
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 在Sun粒子系统适应了Space-Truckers的规模之后。检查器窗口对于实时看到不同值的效果至关重要
- en: In general, the particle counts may need to be increased for the Sun and glare
    particles, but whatever the change, make sure to wait a few seconds for it to
    propagate to newly spawned particles, since some may have lifetimes measured in
    the low 10s of seconds!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可能需要增加太阳和眩光粒子的数量，但无论变化如何，都要确保等待几秒钟，以便它传播到新产生的粒子，因为有些粒子的寿命可能只有几秒钟！
- en: In this section, we’ve learned about the different types of particle systems
    available in Babylon.js, as well as some techniques to quickly iterate toward
    finding our desired look and feel. Hopefully, we’ve made ol’ Mac proud by channeling
    his clever knack for finding solutions to the problem of loading up and adapting
    the Sun `CargoUnit` as it traverses the system in its flight.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了Babylon.js中可用的不同类型的粒子系统，以及一些快速迭代以找到我们想要的视觉效果的技术。希望我们通过发挥老麦克的聪明才智，找到了加载和适应在飞行中穿越系统的Sun
    `CargoUnit`问题的解决方案，让他感到自豪。
- en: Marking Out the Route
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记路线
- en: 'A key aspect of the gameplay of Space-Truckers is how the path taken by `CargoUnit`
    in the route planning phase affects the challenges – and the rewards – of the
    driving phase. We’ve already tackled the ballistic flight mechanics of the route
    planning, so now, we need to capture that route and data about the environments
    it traverses. The following diagram shows the primary properties of our route
    and how they might be represented:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Space-Truckers 游戏玩法的一个关键方面是 `CargoUnit` 在路线规划阶段所采取的路径如何影响驾驶阶段的挑战——以及奖励。我们已经处理了路线规划的弹道飞行力学，所以现在，我们需要捕捉那条路线以及它穿越的环境数据。以下图表显示了我们的路线的主要属性以及它们可能如何表示：
- en: '![Figure 7.2 – Various pieces of telemetry are captured during the in-flight
    part of route planning. The Position, rotation, velocity, and a timestamp are
    all collected for each sample'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 在路线规划飞行阶段捕获了各种遥测数据。每个样本都收集了位置、旋转、速度和时间戳]'
- en: '](img/Figure_7.02_B17266.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.02_B17266.jpg)'
- en: Figure 7.2 – Various pieces of telemetry are captured during the in-flight part
    of route planning. The Position, rotation, velocity, and a timestamp are all collected
    for each sample
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 在路线规划飞行阶段捕获了各种遥测数据。每个样本都收集了位置、旋转、速度和时间戳]
- en: 'Here, the idea that `CargoUnit` is what is responsible for saving its path,
    which translates out to the `CargoUnit` class, thus gaining a new `routePath[]`
    property along with associated logic in the `reset()` and `update()` methods to
    clear and update the path, respectively. The data itself is simple, though we’ll
    get into the `encounterZone` field in a bit:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CargoUnit` 负责保存其路径的想法，这转化为 `CargoUnit` 类，从而获得一个新的 `routePath[]` 属性，以及 `reset()`
    和 `update()` 方法中的相关逻辑来清除和更新路径，分别。数据本身很简单，尽管我们很快就会涉及到 `encounterZone` 字段：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `TransformNode` is a non-rendered object in the `TransformNode` is useful
    in the *Adding Encounter Visuals* section. Because they implement everything needed
    to calculate and place the node’s position in the world of the Scene, `TransformNodes`
    are useful in a lot of different applications. This includes the ability to both
    be a parent and/or a child to other objects within the Scene. Some examples include
    a “camera dolly” made by parenting a `PhysicsImpostor`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformNode` 是 `TransformNode` 中一个非渲染对象，在 *添加遭遇视觉元素* 部分很有用。因为它们实现了计算和放置节点在世界场景中的位置所需的一切，`TransformNodes`
    在许多不同的应用中都很有用。这包括能够成为场景中其他对象的父节点和/或子节点。一些例子包括通过父化 `PhysicsImpostor` 制作的“摄像机推车”。'
- en: Since this code comes right after we’ve freshly calculated the velocity, gravity,
    and rotation properties, we’re ensuring that we have the latest and most up-to-date
    values. Why are we storing the rotation as a **Quaternion** rather than the **Vector3**
    representation we already have? The reason is that we are going to want to perform
    some mathematical transformations against mesh vertices in a **local space**,
    rather than **world space**, and having the quaternion already computed makes
    for more simple calculations, as well as being more efficient.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码紧跟在我们刚刚计算出的速度、重力和旋转属性之后，我们确保我们有最新和最准确的数据。为什么我们要将旋转存储为 **四元数** 而不是我们已有的
    **Vector3** 表示形式呢？原因是我们将想要在 **局部空间** 而不是 **世界空间** 中对网格顶点执行一些数学变换，而预先计算好的四元数使得计算更加简单，同时也更加高效。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t forget that JavaScript reference types assign by reference, not by value
    – hence the need to clone the Vector3 property values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记 JavaScript 引用类型是按引用分配的，而不是按值分配——因此需要克隆 Vector3 属性值。
- en: Although that’s all there is to capturing the path telemetry data, there’s still
    more work to do before this will start to be useful in the game. One of those
    pieces of work is to implement the concept of an **Encounter Table** and its concomitant
    **Encounter Zones**. After that, we can start to put the two together into the
    **SpaceTruckerEncounterManager**. If you want to get more in-depth into the history
    and linkages between the different components we’ll be talking about and their
    high-level design, [https://github.com/jelster/space-truckers/issues/70](https://github.com/jelster/space-truckers/issues/70)
    is a good place to start.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然捕捉路径遥测数据的工作已经完成，但在这些数据开始在游戏中变得有用之前，还有更多的工作要做。其中一项工作就是实现**遭遇表**及其相关的**遭遇区域**的概念。之后，我们就可以开始将这两个概念整合到**SpaceTruckerEncounterManager**中。如果您想深入了解我们将要讨论的不同组件及其高级设计的历史和联系，[https://github.com/jelster/space-truckers/issues/70](https://github.com/jelster/space-truckers/issues/70)是一个不错的起点。
- en: Defining the Encounter Zone
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义遭遇区域
- en: 'An **Encounter Table** is what it says on the box: it’s a tabular format of
    probabilities for certain events to occur based on a random factor. In tabletop
    and RPG-style games, the random factor is provided by rolling one or more dice
    of various numbered sides. In computer-based games, the same thing applies, except
    that instead of tossing physical dice, we’ll generate encounters based on the
    output of a random number generator.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**遭遇表**正如其名所示：它是一张基于随机因素的某些事件发生的概率表格。在桌面和RPG风格的游戏中，随机因素由掷一个或多个不同面数的骰子提供。在基于计算机的游戏中，情况相同，只是我们不会掷物理骰子，而是根据随机数生成器的输出生成遭遇。'
- en: Like much of the rest of the game objects, the **Encounter Zones** (**EZs**)
    are updateable game components, while each Encounter serves as a container for
    data defining that encounter. This allows the **EncounterManager** to choose which
    EZ should be responsible for running encounter checks, simplifying the logic required
    in the EZ. Easy, right?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏中的许多其他对象一样，**遭遇区域**（**EZs**）是可更新的游戏组件，而每个遭遇都充当定义该遭遇的数据容器。这使得**遭遇管理器**可以选择哪个EZ应该负责运行遭遇检查，从而简化了在EZ中所需的逻辑。简单，对吧？
- en: Encounters Overview
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遭遇概述
- en: The structure of an Encounter table is simple. Down each row is a specific event
    or encounter that the game designer wants to make possible. A probability column
    in the table indicates the likelihood of that event occurring in the form of a
    number between 0 (no chance whatsoever) and 1 (guaranteed). This is a good start,
    but we need to be able to further group encounters by their spatial locations
    in the world; it wouldn’t make much sense to encounter a solar flare in the dark
    reaches of the Outer System, would it? That’s where the concept of an Encounter
    Zone comes in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 遭遇表的架构很简单。每一行都是游戏设计师希望使其成为可能的具体事件或遭遇。表格中的概率列表示该事件发生的可能性，以0（完全没有机会）到1（保证发生）之间的数字形式表示。这是一个好的开始，但我们还需要能够根据它们在世界中的空间位置进一步对遭遇进行分组；在暗淡的外层系统区域遭遇太阳耀斑有什么意义吗？这就是遭遇区域概念的作用所在。
- en: Encounter Zones and Encounter Tables
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遭遇区域和遭遇表
- en: 'An Encounter Zone is an Encounter Table scoped to a specific spatial location
    in the game world, as alluded to previously. From the Inner System to the Outer
    Reaches, each Encounter Zone has a unique set of potential encounters for the
    player to deal with – or benefit from! The following is a table of encounters
    grouped by zone that was part of the Space-Truckers game design specifications.
    Incomplete and purposefully vague on specifics, it still provides a clear picture
    of how the feature should work and interoperate with other features:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 遭遇区域是针对游戏世界中特定空间位置的遭遇表，如前所述。从内系统到外层区域，每个遭遇区域都有独特的潜在遭遇供玩家应对——或者从中受益！以下是一个按区域分组的遭遇表，它是Space-Truckers游戏设计规范的一部分。虽然不完整且故意模糊具体细节，但它仍然清楚地展示了该功能应该如何工作以及与其他功能的交互：
- en: '![Figure 7.3 – Design for the Space-Truckers encounter. Source: https://github.com/jelster/space-truckers/issues/65](img/Figure_7.03_B17266.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – Space-Truckers遭遇的设计。来源：https://github.com/jelster/space-truckers/issues/65](img/Figure_7.03_B17266.jpg)'
- en: 'Figure 7.3 – Design for the Space-Truckers encounter. Source: [https://github.com/jelster/space-truckers/issues/65](https://github.com/jelster/space-truckers/issues/65)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – Space-Truckers遭遇的设计。来源：[https://github.com/jelster/space-truckers/issues/65](https://github.com/jelster/space-truckers/issues/65)
- en: When implementing encounters, there will be different needs and thus differently
    structured solutions for each type of encounter. Fortunately, we don’t need to
    define those specifics quite yet, so we’ll park it for the moment and take a step
    back to look at how the **Encounter Zone** can track **CargoUnit**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现遭遇时，将会有不同的需求，因此每种遭遇类型都会有不同结构的解决方案。幸运的是，我们目前不需要定义那些具体细节，所以我们将暂时将其搁置一边，退一步看看**遭遇区域**如何跟踪**货物单元**。
- en: Tracking Intersections
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪交集
- en: Each EZ needs to register the intersection exit and enter triggers for the `CargoUnit`
    mesh’s Action Manager, but we don’t want to have to write code to do that for
    each Zone – what if we change the number of `EncounterZones`, or want to change
    the way intersections are used? Thankfully, this problem can be solved easily.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个EZ都需要为`CargoUnit`网格的动作管理器注册交集退出和进入触发器，但我们不希望为每个区域编写代码来做这件事——如果我们改变`EncounterZones`的数量，或者想要改变交集的使用方式怎么办？幸运的是，这个问题可以很容易地解决。
- en: When the `initialize` method of `SpaceTruckerEncounterManager` is invoked, the
    list of `encounterZones` is iterated across in a `forEach` loop. Among other actions,
    each zone is passed by `cargo.mesh` as a parameter to its `registerZoneIntersectionTrigger`
    method. This function performs the intersection registration on `meshToWatch.actionManager`,
    which hooks up the corresponding `OnIntersectionExitTrigger` and `OnIntersectionEnterTrigger`
    to the EncounterZone’s `onExitObservable` and `onEnterObservable`, respectively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`SpaceTruckerEncounterManager`的`initialize`方法时，会遍历`encounterZones`列表，使用`forEach`循环。在其它动作中，每个区域都会通过`cargo.mesh`作为参数传递给其`registerZoneIntersectionTrigger`方法。这个函数在`meshToWatch.actionManager`上执行交集注册，将相应的`OnIntersectionExitTrigger`和`OnIntersectionEnterTrigger`分别连接到遭遇区域的`onExitObservable`和`onEnterObservable`。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`SpaceTruckerEncounterManager` is a member of `CargoUnit`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpaceTruckerEncounterManager`是`CargoUnit`的一个成员。'
- en: The primary purpose of `SpaceTruckerEncounterManager` is to (as the name implies)
    manage encounters in its constituent Zones but to be able to do that, it needs
    to know which EZ `cargoUnit` is currently transiting. You may initially surmise
    that because `EncounterZone` has a torus shape, nested (but not overlapping) zones
    should fire their intersection triggers only when the mesh is crossed, but that’s
    not the case in practice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpaceTruckerEncounterManager`的主要目的是（正如其名称所暗示的）管理其构成区域中的遭遇，但为了能够做到这一点，它需要知道当前正在穿越的哪个EZ
    `cargoUnit`。你可能会最初推测，由于`EncounterZone`具有环面形状，嵌套（但不重叠）的区域只有在穿过网格时才会触发它们的交集触发器，但在实践中并非如此。'
- en: Performing intersection calculations against a complex mesh is a very computationally
    expensive process, making it not very suitable for real-time processing applications.
    Instead, what Babylon.js does is use the much less expensive and computationally
    efficient bounding box intersection calculations. Though fast, they do not mimic
    the actual geometries being tested very accurately, resulting in a problem wherein
    the cargo unit appears to the application as if it is within not just the zone
    at its location but all other zones that are nested around it!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对复杂网格进行交集计算是一个非常计算密集的过程，这使得它不适合用于实时处理应用。相反，Babylon.js所做的是使用成本更低且计算效率更高的边界框交集计算。虽然速度快，但它们并不能非常准确地模拟正在测试的实际几何形状，从而导致一个问题，即货物单元似乎对应用程序来说不仅位于其位置区域，还位于其周围所有嵌套区域！
- en: 'To resolve this, `SpaceTruckerEncounterManager` keeps track of all triggered
    intersections with the `inAndOut` field. Incremented whenever a zone signals the
    entrance, and decremented for the converse, it is an integer that represents an
    index to `currentZone` that’s offset by the total number of encounter zones:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`SpaceTruckerEncounterManager`通过`inAndOut`字段跟踪所有触发的交集。每当区域发出进入信号时，该字段就会增加，对于相反的情况则减少，它是一个表示`currentZone`索引的整数，该索引偏移量为遭遇区域的总数：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This property is used in several areas, from `CargoUnit` to the Route Planning
    GUI, but the underlying zones in the encounter manager need to be populated ahead
    of time with data defining the boundaries and characteristics of each zone.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性在多个区域中使用，从`CargoUnit`到路线规划GUI，但遭遇管理器中的底层区域需要预先用定义每个区域边界和特征的数据进行填充。
- en: Encounter Zones and Game Data
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遭遇区域和游戏数据
- en: 'An **Encounter Zone** (like most software components) is defined by its behaviors
    and data. The data comes from the encounter zone’s definition and looks something
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**遭遇区域**（就像大多数软件组件一样）由其行为和数据定义。数据来自遭遇区域的定义，看起来像这样：'
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At construction time, `SpaceTruckerEncounterZone` uses this structure (passed
    as a parameter to the constructor) to initialize and configure the EZ. Some properties
    are self-explanatory, but `innerBoundary` and `outerBoundary` warrant explicit
    definitions, along with `encounterRate`. Once we’ve covered those, we’ll dive
    into the encounters array and how it works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时，`SpaceTruckerEncounterZone`使用这个结构（作为构造函数的参数传递）来初始化和配置EZ。一些属性是自解释的，但`innerBoundary`和`outerBoundary`需要明确的定义，以及`encounterRate`。一旦我们覆盖了这些，我们将深入探讨遭遇数组及其工作方式。
- en: The `innerBoundary` field is the `outerBoundary` is the radius of the outer
    circle described by the torus. Though this makes sense from a conceptual viewpoint,
    it is a bit different from how the Babylon.js `createTorus` method, the primary
    “knobs and switches” available to control the size of the mesh are the `diameter`
    and `thickness` parameters. These two values sound like they would work well if
    we were to pass `outerBoundary` and `(outerBoundary – innerBoundary)`, respectively,
    but closely reading the parameter descriptions tells us a different story.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerBoundary`字段是环面描述的外圆的半径。虽然从概念上看这是合理的，但它与Babylon.js的`createTorus`方法有所不同，该方法是控制网格大小的“旋钮和开关”，主要参数是`diameter`和`thickness`。这两个值听起来如果我们传递`outerBoundary`和`(outerBoundary
    – innerBoundary)`，应该会工作得很好，但仔细阅读参数描述告诉我们一个不同的故事。'
- en: 'The best way to picture how the various parameters all fit together is by taking
    a length of wire and forming it into a half-circle of some radius, `2 * r`. Now,
    picture taking a small paper coaster of the radius, `2 * R`. The outer boundary
    of the torus isn’t the same as the diameter parameter – it’s equal to the diameter
    plus one-half the thickness. The inner boundary is equal to half of the diameter
    minus half the thickness. That’s not the best way to picture this, but it is one
    way to describe it! Here’s something better than a description – a visualization
    for that analogy, available at the Playground link in the caption:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观的方式是通过取一段电线，将其弯曲成半径为`2 * r`的半圆来想象各种参数如何相互配合。现在，想象一下取一个半径为`2 * R`的小纸垫。环面的外边界并不等同于直径参数——它等于直径加上一半的厚度。内边界等于直径的一半减去一半的厚度。这不是最好的描述方式，但这是描述它的一种方法！这里有一个比描述更好的东西——一个用于该类比的可视化，可在标题中的游乐场链接找到：
- en: '![Figure 7.4 – The properties of a torus. The diameter is depicted by a solid
    circle with its thickness described by a second smaller circle. This Playground
    can be found at https://playground.babylonjs.com/#P2YP2E#1'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 环面（torus）的性质。直径由一个实心圆表示，其厚度由一个较小的圆圈描述。这个游乐场可以在https://playground.babylonjs.com/#P2YP2E#1找到](img/Figure_7.04_B17266.jpg)'
- en: '](img/Figure_7.04_B17266.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 7.4 – The properties of a torus. The diameter is depicted by a solid
    circle with its thickness described by a second smaller circle. This Playground
    can be found at [https://playground.babylonjs.com/#P2YP2E#1](https://playground.babylonjs.com/%23P2YP2E%231)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 环面（torus）的性质。直径由一个实心圆表示，其厚度由一个较小的圆圈描述。这个游乐场可以在[https://playground.babylonjs.com/#P2YP2E#1](https://playground.babylonjs.com/%23P2YP2E%231)找到。
- en: Why are we going through these hoops? Because by structuring it in this way,
    we can quickly and easily compare and align encounter zones with planetary orbits,
    as defined in **gameData**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要经历这些弯弯绕绕？因为以这种方式构建，我们可以快速轻松地比较和调整遭遇区域与行星轨道，正如在**gameData**中定义的那样。
- en: Finally, getting back to the EZ data, the `encounterRate` field is a percentile
    (0 – 1) number indicating how often encounters happen in general for the zone.
    Each zone independently keeps its own encounter table, which it then uses to determine
    what, if any, encounter might occur. Since we’re on the topic of encounters and
    random numbers, we might as well try to gain an understanding of exactly how to
    go about implementing the logic of picking entries from the Encounter Table. For
    that, we need to talk about something called a **Cumulative Distribution Mass
    Function**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到EZ数据，`encounterRate`字段是一个百分比（0 – 1）数字，表示该区域一般发生遭遇的频率。每个区域独立保持自己的遭遇表，然后使用该表来确定可能发生哪些遭遇。既然我们谈论到了遭遇和随机数，我们不妨尝试理解如何具体实现从遭遇表中选择条目的逻辑。为此，我们需要讨论一个叫做**累积分布质量函数**的东西。
- en: Selecting Encounters
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择遭遇
- en: 'A developer implementing this kind of functionality for the first time might
    devise a simple function, `getEncounter`, that picks a random number to serve
    as a dice roll before searching through an array of encounters for the first one
    with a probability less than or equal to the dice roll. To that developer’s chagrin,
    this simple approach would also be incorrect! Though this approach works when
    rolling to determine the chance of a singular Encounter, it won’t work when there
    are multiple potential encounters. Here’s what the Asteroid Belt **Encounter Table**
    looks like in simplified form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首次实现此类功能的开发者可能会设计一个简单的函数`getEncounter`，该函数在搜索具有小于或等于骰子点数的概率的第一个遭遇之前，先随机选择一个数字作为骰子点数。让那位开发者感到沮丧的是，这种简单的方法也是不正确的！虽然这种方法在掷骰子以确定单一遭遇的机会时是有效的，但当存在多个潜在的遭遇时，它将不起作用。以下是简化形式的**小行星带遭遇表**：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each entry in the encounter table has an associated probability factor, the
    total of which will usually (but doesn’t have to due to some code we’ll write
    shortly) equal 1 (100%). When you want to pick a random entry from the table,
    it’s necessary to consider all the potential other events that might take place.
    The fancy-pants way of referring to the process of computing an event output in
    response to a random number input is a **Cumulative (Mass) Distribution Function**
    (**CMDF**). In the **EncounterZone** source (see [https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44](https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44)),
    the CMDF is implemented in the constructor as a two-step process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 遭遇表中的每一项都有一个相关的概率因子，其总和通常（但并非必须，因为我们将很快编写一些代码）等于1（100%）。当你想要从表中随机选择一个条目时，必须考虑所有可能发生的事件。将计算事件输出响应随机数输入的过程称为**累积（质量）分布函数**（**CMDF**）。在**EncounterZone**源代码（见[https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44](https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44)）中，CMDF是通过构造函数实现的，它是一个两步过程。
- en: Summing the Probabilities
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求和概率
- en: 'In step one, we take the sum of all the individual encounters’ probabilities.
    This step is what will allow the application to handle scenarios where the individual
    probabilities don’t all add up to 1 and is used by step two. While we’re there,
    the encounter table gets populated from the definition:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们计算所有单个遭遇的概率总和。这一步将允许应用程序处理单个概率不都加到1的情况，并在第二步中使用。当我们到达那里时，遭遇表从定义中填充：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The point of this step is that while we can’t necessarily guarantee that the
    total of the probabilities will come to one, we can normalize that sum in the
    next step so that each entry in the table is correctly and proportionally represented
    in the CMDF.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的目的在于，虽然我们无法保证概率的总和一定会达到1，但我们可以在下一步中归一化这个总和，以便表中的每个条目都能在CMDF中得到正确和成比例的表示。
- en: Populating CMDF Results
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充CMDF结果
- en: 'Step two involves looping through the list of `encounters` again (after pre-baking
    the first element of the `cumulativeDistribution` array) and populating entries
    into a second array – the aforementioned `cumulativeDistribution` array. This
    collection’s entries represent the **CMDF** over its entire space and can therefore
    be used as an index to look up values for arbitrary inputs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步涉及再次遍历`encounters`列表（在预先烘焙`cumulativeDistribution`数组的第一个元素之后）并将条目填充到第二个数组中——即上述的`cumulativeDistribution`数组。这个集合的条目代表了整个空间的**CMDF**，因此可以用作索引来查找任意输入的值：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that because the loop looks backward, the first element is calculated outside
    of the loop, which then starts at the `this.cumulativeDistribution[i]`) is equal
    to the previous element’s value added to the current encounter’s share of `probability`
    toward `total`. This only needs to happen once, upon initialization. Once in place,
    it is now possible to “roll the dice” and implement a more correct form of `getEncounter`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于循环是向后的，第一个元素是在循环之外计算的，然后循环从`this.cumulativeDistribution[i]`等于前一个元素的值加上当前遭遇的`probability`份额对`total`的份额开始。这只需要在初始化时发生一次。一旦到位，现在就可以“掷骰子”并实现更正确的`getEncounter`形式。
- en: Rolling an Encounter Check
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掷遭遇检查
- en: 'Every time `update` method is called, the logic will evaluate whether an encounter
    happens before deciding which encounter is going to take place. It needs to consider
    how much time has elapsed since the last frame, as it would then tie encounters
    to a player’s frame rate – not what we want! Once that is considered, and if there
    is indeed an encounter indicated for the zone, the `getEncounter` method is called
    to retrieve a random entry from `encounterTable`. The encounter retrieved is then
    passed as the event parameter for `onEncounterObservable`, letting any subscriber
    know about `encounter`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `update` 方法时，逻辑将评估是否发生了遭遇，然后决定将要发生哪个遭遇。它需要考虑自上一帧以来经过的时间，因为它会将遭遇与玩家的帧率联系起来——这不是我们想要的！一旦考虑了这一点，并且确实有区域指示遭遇，就会调用
    `getEncounter` 方法从 `encounterTable` 中检索一个随机条目。检索到的遭遇随后作为事件参数传递给 `onEncounterObservable`，让任何订阅者都知道
    `encounter`：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That’s the update loop in its entirety. If only life could always be as elegant
    and simple as these solutions, maybe people would get along better, because the
    `getEncounter` method boils down to a single line of correct, though slightly
    esoteric, JavaScript:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个更新循环。如果生活总是像这些解决方案一样优雅和简单，也许人们会相处得更好，因为 `getEncounter` 方法简化为一条正确、尽管有些晦涩的
    JavaScript 代码：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The reason this is a bit esoteric is that, as you might have noticed, the `for`
    loop has no body! There isn’t a body in the loop because, simply put, there isn’t
    a need for any. The purpose of the loop is to find the index (`i`) that conforms
    to the `diceRoll` number. Once that condition has been fulfilled, the `i` value
    sticks around due to being declared with `var` rather than with `let`. The encounter
    itself is retrieved as an index and returned to the calling method for distribution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有点晦涩，是因为你可能已经注意到，`for` 循环没有主体！循环中没有主体，简单来说，是因为没有这个必要。循环的目的是找到符合 `diceRoll`
    数字的索引 (`i`)。一旦这个条件得到满足，`i` 值由于使用 `var` 而不是 `let` 声明而保留下来。遭遇本身作为索引被检索并返回给调用方法以进行分发。
- en: Listening for Encounters
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听遭遇
- en: Once the `SpaceTruckerEncounterManager`, which then acts as a broker and aggregator
    for distributing the news of `Encounter` throughout the application in its `onEncounter`
    observer method. The same observer is subscribed to all the zone’s `onEncounterObservable`,
    which is what gives us the aggregation of these events that we need, along with
    the `lastFlightPoint` telemetry package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `SpaceTruckerEncounterManager` 被用作经纪人并聚合器，在 `onEncounter` 观察者方法中分发 `Encounter`
    的消息，同样的观察者被订阅到所有区域的 `onEncounterObservable`，这为我们提供了所需的事件聚合，以及 `lastFlightPoint`
    遥测包。
- en: 'Both the encounter and `cargoData` are then bundled together and pushed into
    the `encounterEvents` array for future reference. The index of the newly added
    element is what is then propagated to observers of `onNewEncounterObservable`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 遭遇和 `cargoData` 然后被打包在一起并推入 `encounterEvents` 数组以供将来参考。新添加元素的下标随后被传播给 `onNewEncounterObservable`
    的观察者：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason we are passing an index (or pointer) to the `encounterEvents` collection
    is that we want to ensure that we can dispose of those objects cleanly and at
    any time; if the object were passed in the event, it might not be possible for
    the system to determine whether memory can be freed up from disposed-of objects
    – a condition known as a memory leak.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `encounterEvents` 集合传递索引（或指针）的原因是我们想确保我们可以干净利落地在任何时候处理这些对象；如果对象被传递到事件中，系统可能无法确定是否可以从已处理的对象中释放内存——这种情况称为内存泄漏。
- en: At this point, we have finished inspecting and discussing the underlying infrastructure
    needed to define, locate, and generate encounters of different types. These encounters
    will be brought to life later in this book when we get into the driving phase
    game logic for each encounter. However, while our understanding of encounters
    is fresh, let’s look at how encounters might be used and presented within the
    context of the route planning screen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经检查和讨论了定义、定位和生成不同类型遭遇所需的基础设施。这些遭遇将在本书的驾驶阶段游戏逻辑中详细介绍。然而，在我们对遭遇的理解仍然新鲜的时候，让我们看看遭遇如何在路线规划屏幕的上下文中被使用和展示。
- en: Adding Encounter Visuals
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加遭遇视觉效果
- en: This is where our previous work in the *Marking Out the Route* section comes
    into play. Recall that as our `CargoUnit` falls through its trajectory, it is
    constantly laying down a line of breadcrumbs to mark out its path. This is visualized
    by the `CargoUnit.trailMesh` component, which other than needing to be initialized
    and disposed of during scenario resets, takes care of itself without much need
    for us to intervene. We need an equivalently hands-off way to similarly render
    visualizations for encounters when and where they occur along the route, and that’s
    precisely what the work we just covered is meant to enable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在*标记路线*部分的工作发挥作用的时刻。回想一下，当我们的`CargoUnit`沿着轨迹下落时，它不断地留下一条面包屑线来标记其路径。这是通过`CargoUnit.trailMesh`组件可视化的，除了在场景重置时需要初始化和销毁，它几乎不需要我们干预。我们需要一种类似的无为而治的方式来渲染沿路径发生的遭遇的视觉效果，这正是我们刚刚介绍的工作旨在实现的。
- en: 'Important note:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: While the following section is ultimately cut from the game, the technique demonstrated
    is helpful to have in your pocket.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下部分最终被从游戏中删除，但演示的技术值得保留在口袋里。
- en: Putting 2D Labels into 3D Space
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将2D标签放入3D空间
- en: Although there is a 3D GUI system in Babylon.js, our current needs don’t require
    the use of a full 3D UI. Still, one of the advantages of a 3D GUI is that it is
    easy to position elements within the World Space – for reasons that should hopefully
    be obvious.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Babylon.js中有一个3D GUI系统，但我们的当前需求不需要使用完整的3D UI。然而，3D GUI的一个优点是，它很容易在World Space中定位元素——原因应该很清楚。
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike jokes, there’s no risk of ruining this with an explanation. The obvious
    reason is that positioning 2D elements concerning a 3D world-space point can get
    tricky because of the need to combine camera position, world position, and screen
    position transformations to get the correct coordinates as opposed to a 3D GUI
    system operating in the same coordinate space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与笑话不同，解释这个不会有风险。明显的理由是，由于需要结合相机位置、世界位置和屏幕位置变换来获得正确的坐标，而不是在相同坐标空间中运行的3D GUI系统，因此关于3D世界空间点的2D元素定位可能会变得复杂。
- en: Much of the complexity inherent in coordinate transformations is, fortunately,
    hidden away from the developer by the BJS GUI framework – `linkWithMesh` and `moveToVector`
    both allow callers to place a GUI control somewhere in the **World Space**. That’s
    good for part of the way, but we still need to have someplace to hang the visuals
    as well as provide a base for future enhancements and behaviors.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标变换固有的复杂性，幸运的是，被BJS GUI框架隐藏起来，对开发者来说——`linkWithMesh`和`moveToVector`都允许调用者将GUI控件放置在**世界空间**中的某个位置。这在某种程度上是好的，但我们仍然需要有一个地方来挂载视觉效果，并为未来的增强和行为提供基础。
- en: If you’ve come back to this section after a break, you can thank your Past Self
    for putting all the pieces into place. If you’ve been binging through this chapter
    (don’t stop – won’t stop – can’t stop!) then take a moment to pat yourself on
    the back. It’s important to take the time to properly acknowledge yourself and
    the impact of previous actions on present situations – both good and bad! This
    is going to be easy, in other words.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在休息后回到这一节的，你可以感谢过去的自己把所有这些部件都放到了合适的位置。如果你一直在快速浏览这一章（不要停下来——不会停下来——不能停下来！），那么请给自己鼓掌。花时间正确地认可自己和之前行为对当前情况的影响——无论是好是坏——都是非常重要的。换句话说，这将会很容易。
- en: Remember how we used a `TransformNode` to track our cargo’s flight path? This
    is where that decision is finally justified. Most `linkWithMesh` function, whose
    name implies that you must only pass a Mesh. This would be a wrong, though understandable,
    conclusion to make that can be remedied by studying the method’s documentation
    and seeing that while the name of the parameter is `mesh`, the expected type of
    the parameter is our old friend **Transform Node**!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们是如何使用`TransformNode`来追踪我们的货物飞行路径的吗？这就是最终证明那个决定是正确的时刻。大多数`linkWithMesh`函数，其名称暗示你只能传递一个网格。这是一个错误，尽管可以理解，但可以通过研究该方法的文档并看到参数的名称是`mesh`，而参数的预期类型是我们老朋友**变换节点**来纠正！
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation isn’t wrong, strictly speaking, because `TransformNode` type.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，文档没有错误，因为`TransformNode`类型。
- en: 'The `PlanningScreenGui` component already has access to the `encounterManager`
    property of the `planningScreen` field in its constructor, so we can subscribe
    to its `onNewEncounterObservable` to be notified when a new encounter happens.
    In the observer function, we get the image URL from the encounter itself and use
    it to create Babylon.js GUI elements that are then linked to the associated `TransformNode`
    of the flight path:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlanningScreenGui` 组件在其构造函数中已经可以访问 `planningScreen` 字段中 `encounterManager`
    属性，因此我们可以订阅其 `onNewEncounterObservable` 以在发生新的 encounter 时得到通知。在观察者函数中，我们从 encounter
    本身获取图像 URL，并使用它来创建 Babylon.js GUI 元素，然后将其链接到航线的相关 `TransformNode`：'
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That’s the visual placed in the correct spot and with the right image, so now,
    let’s think about what else is involved with displaying an encounter. First, we
    want there to be a sound effect that plays. This can be done by registering `SpaceTruckerPlanningScreen`
    to `onNewEncounterObservable`, as shown in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是放置在正确位置并带有正确图像的视觉效果，所以现在，让我们考虑显示 encounter 时还涉及哪些内容。首先，我们希望有一个声音效果播放。这可以通过将
    `SpaceTruckerPlanningScreen` 注册到 `onNewEncounterObservable` 来完成，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While we’re not currently using the actual encounter index now, this approach
    allows it to be easily extended in the future – to allow individual encounters
    to specify their own sound to play, for instance. When an encounter occurs, we
    don’t want an icon to simply appear, with no fanfare. We want to make sure the
    player’s attention is called to it, but only momentarily. One way to accomplish
    that is to initially render the panel so that it’s much larger than its eventual
    size and then animate the panel so that it’s shrinking to its final size and position.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在没有使用实际的 encounter 索引，但这种方法允许它在未来轻松扩展——例如，允许单个 encounters 指定它们自己的声音播放。当发生
    encounter 时，我们不想图标简单地出现，没有任何喧哗。我们想确保玩家的注意力被吸引到它上面，但只是短暂的一瞬间。实现这一目标的一种方法是将面板最初渲染得比最终大小大得多，然后动画化面板，使其缩小到最终大小和位置。
- en: Animating the Encounter Panel
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化 encounter 面板
- en: In [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*,
    we saw how to statically define an **Animation** that was later targeted to a
    specific object as part of an **AnimationGroup**. We will use the same technique
    here to define the animations involved in shrinking the encounter panel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B17266_04_Final_AM.xhtml#_idTextAnchor070) *创建应用程序* 中，我们看到了如何静态定义一个
    **动画**，稍后将其作为 **AnimationGroup** 的一部分针对特定对象进行定位。我们在这里将使用相同的技术来定义涉及缩小 encounter
    面板的动画。
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Even though it may not seem like it, almost any object can be the target of
    an `scaleX` and `scaleY` properties of the `GUI.Image` component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来可能不是这样，几乎任何对象都可以成为 `GUI.Image` 组件的 `scaleX` 和 `scaleY` 属性的目标。
- en: 'Note that there are two separate animations involved – one each for the *X*
    and *Y*-axes – since an `AnimationGroup` and use `addTargetedAnimation` along
    with the target `panel` and `panelShrink` Animation, after which the animation
    is started:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里涉及两个独立的动画——一个用于 *X* 轴，另一个用于 *Y* 轴——因为使用了 `AnimationGroup` 和 `addTargetedAnimation`
    方法，并指定了目标 `panel` 和 `panelShrink` 动画，之后动画开始：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This gives us a nice presentation for the encounters, leaving just one more
    use case that we have yet to cover – resetting the route planning screen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了 encounters 的良好展示，仅剩下我们尚未覆盖的一个用例——重置路线规划屏幕。
- en: Clearing Encounter Panels
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除 encounter 面板
- en: 'The list that encounters the GUI elements that are collected in anticipation
    of just this scenario is the `encounterPanels` array. Since each GUI control implements
    a `dispose` function, we reset the encounters UI by simply looping through the
    array and calling `dispose` on each element in turn. To avoid the need to anticipate
    every single place we need to do this, we can add the logic to the place it makes
    the most sense – the `onScreenStateChange` observer function. Whenever it executes
    logic to transition to the `ReadyToLaunch` state, the encounter panel is cleared
    of any elements and all children are disposed of:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到 GUI 元素的列表是为了应对这种场景而收集的，这个列表是 `encounterPanels` 数组。由于每个 GUI 控件都实现了 `dispose`
    函数，我们可以通过遍历数组并依次调用每个元素的 `dispose` 方法来重置 encounters UI。为了避免需要预测每个需要这样做的地方，我们可以在最合理的地方添加逻辑——即
    `onScreenStateChange` 观察者函数。每当它执行逻辑以过渡到 `ReadyToLaunch` 状态时，encounter 面板会清除所有元素，并且所有子元素都会被销毁：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s all there is to it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: Important note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Of course, that’s *not* all there is to it! There is much, much more that can
    be done and is being done in the context of Encounter visuals, but by and large,
    all of this is based on the same concepts presented throughout this section and
    chapter. If you haven’t already, don’t forget to remind yourself: game development
    is hard and there are a lot of moving parts!'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这还远不止这些！在遭遇视觉的背景下，还有许多许多可以做到和正在做的事情，但总的来说，所有这些都基于本节和本章中提出的相同概念。如果你还没有这样做，别忘了提醒自己：游戏开发很困难，有很多移动部件！
- en: Although we have only covered how the encounter GUI panels are cleared, this
    pattern completes the circle of creation and destruction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只介绍了如何清除遭遇界面面板，但这种模式完成了创建和销毁的循环。
- en: Registering to listen for `EncounterManager.onNewEncounterObservable` informs
    components of new encounters, while setting `SpaceTruckerPlanningScreen.onStateChangeObservable`
    to the `ReadyToLaunch` state clears any existing ones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注册监听 `EncounterManager.onNewEncounterObservable` 通知组件新的遭遇，而将 `SpaceTruckerPlanningScreen.onStateChangeObservable`
    设置为 `ReadyToLaunch` 状态则会清除任何现有的状态。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let’s take a step back and review what we’ve covered in this chapter. First,
    we took another side route to visit the various Babylon.js particle systems, making
    use of and adapting the Sun Particle System Set for our purposes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，回顾一下本章所涵盖的内容。首先，我们走了一条旁路来参观各种 Babylon.js 粒子系统，利用并调整了太阳粒子系统集来满足我们的需求。
- en: We can look at particle systems in three rough categories of distinction – the
    “Classic”, “New Wave”, and “Hard Core” monikers. Each references the always-available
    CPU-bound Particle System, the GPU-bound GPU Particle System, and the mixed **Solid
    Particle System** (**SPS**). While the first two systems are based around 2D billboards
    and sprites – characteristics that can animate via sprite sheets and the like
    – an **SPS** uses a source mesh to generate particles, which can, in turn, be
    assigned any type of Material desired (we’ll get more into **Materials**, the
    different types, their properties, and more in [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207),
    *Improving the Environment with Lighting and Materials*).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从三个大致的区别类别中观察粒子系统——“经典”、“新浪潮”和“硬核”名称。每个名称都指的是始终可用的基于 CPU 的粒子系统、基于 GPU 的
    GPU 粒子系统以及混合的 **固体粒子系统**（**SPS**）。前两种系统基于 2D 招牌和精灵——这些可以通过精灵表等动画化——而 **SPS** 使用源网格生成粒子，这些粒子可以进一步分配任何所需的材料（我们将在
    [*第 10 章*](B17266_10_Final_AM.xhtml#_idTextAnchor207)，*通过光照和材料改进环境*）。
- en: Loading a custom Particle System Set involves capturing a serialized JSON file
    containing the specific parameters for each Particle System involved in the appropriate
    structure. This can be done by calling `ParticleHelper.ExportSet(setA, setB,…)`.
    Loading saved JSON from a URL is easy but loading it from a local URL gets a bit
    more complicated. However, by falling back to the `ParticleSystemSet.Parse` function,
    we can load data for the **ParticleSystemSet** in any way we please!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加载自定义粒子系统集涉及捕获包含每个粒子系统特定参数的序列化 JSON 文件，这些参数适用于适当的结构。这可以通过调用 `ParticleHelper.ExportSet(setA,
    setB,…)` 来完成。从 URL 加载保存的 JSON 很容易，但从中加载本地 URL 则要复杂一些。然而，通过回退到 `ParticleSystemSet.Parse`
    函数，我们可以以任何我们想要的方式加载 **ParticleSystemSet** 的数据！
- en: Following our detour into Particles, we examined the telemetry data our **CargoUnit**
    captures during its flight, and how we can use **TransformNodes** to represent
    spatial locations. This proves to be crucial for making it easy to display visuals
    without writing a lot of code and provided a good on-ramp to get into how Encounter
    Zones work.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在对粒子系统的偏离之后，我们检查了 **CargoUnit** 在其飞行过程中捕获的遥测数据，以及我们如何使用 **TransformNodes** 来表示空间位置。这证明对于在不编写大量代码的情况下轻松显示视觉效果至关重要，并且为理解遭遇区域的工作原理提供了一个良好的入门途径。
- en: Each **Encounter Zone** can be thought of as a unique biome or environment in
    the world of *Space-Truckers*. From the toasty **Inner System** to the frosty
    **Outer System**, each Zone has its own set of potential Encounters players might
    face. Defined by an inner and outer Boundary, some light math is involved in converting
    those handy **gameData** figures into parameter values used to create a set of
    nested Torus meshes to represent the zones. Not rendered, these meshes’ **ActionManagers**
    are used to register **IntersectionEnter** and **IntersectionExit** triggers against
    the **CargoUnit**. As it traverses the system, the **SpaceTruckerEncounterManager**
    keeps track of which Zone the player’s **CargoUnit** is currently transiting.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**遭遇区域**可以被视为*Space-Truckers*世界中一个独特的生物群落或环境。从温暖的**内系统**到寒冷的**外系统**，每个区域都有其可能遭遇的一套潜在事件。通过内边界和外边界定义，将这些方便的**gameData**数值转换为用于创建一组嵌套的环面网格的参数值，涉及一些简单的数学计算。这些网格不进行渲染，但它们的**ActionManagers**用于注册针对**CargoUnit**的**IntersectionEnter**和**IntersectionExit**触发器。当它穿越系统时，**SpaceTruckerEncounterManager**会跟踪玩家的**CargoUnit**当前正在穿越的区域。
- en: While transiting a given zone, the Zone’s `update` method makes a weighted random
    check every frame to decide whether there should be an Encounter, selected from
    the Zone’s Encounter Table. The Encounter Zone’s constructor pre-computes the
    **Cumulative Mass Distribution Function** values for every entry in the Table,
    normalizing the probabilities so that the total adds up to 1\. If an encounter
    is “rolled,” the value of the roll (a number between 0 and 1) is used as an input
    to the function, which returns an index to the indicated event. **SpaceTruckerEncounterManager**
    listens for these Encounter Zone events.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当穿越一个特定区域时，该区域的`update`方法会在每一帧进行一次加权随机检查，以决定是否应该有一个从区域遭遇表中选择的事件发生。遭遇区域构造函数预先计算表中的每个条目的**累积质量分布函数**值，使概率归一化，以确保总和为1。如果遭遇被“掷出”，则掷出的值（介于0和1之间的数字）被用作函数的输入，该函数返回指向指定事件的索引。**SpaceTruckerEncounterManager**监听这些遭遇区域事件。
- en: Responsible for aggregating Encounter data with **CargoUnit** data and informing
    subscribers of where to find the resulting encounter data, the **onNewEncounterObservable**
    is the primary means for components such as the **PlanningScreenGui** to update
    themselves without needing to pepper appropriate logic throughout the application’s
    components. Within the **PlanningScreenGui**, techniques first perfected during
    the construction of the Splash Screen come in handy. Here, we can define some
    Animations that target the Encounter’s Image panel to give it a shrinking effect
    as an entrance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 负责聚合遭遇数据与**CargoUnit**数据，并通知订阅者如何找到生成的遭遇数据，**onNewEncounterObservable**是组件如**PlanningScreenGui**更新自己的主要方式，无需在应用程序的组件中散布适当的逻辑。在**PlanningScreenGui**中，在创建启动屏幕时首先完善的技巧派上用场。在这里，我们可以定义一些动画，这些动画针对遭遇的图像面板，使其在进入时产生缩放效果。
- en: Within the `linkWithMesh` and passing in the **TransformNode** captured from
    the flight telemetry.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`linkWithMesh`函数中，并传入从飞行遥测中捕获的**TransformNode**。
- en: As usual, the code discussed in this chapter is available at [https://github.com/jelster/space-truckers/tree/ch7](https://github.com/jelster/space-truckers/tree/ch7),
    and while the game is still incomplete at this point in its history, we can point
    to concrete and valuable progress through the course of this chapter – never forget
    to give yourself credit for progress made on a journey! The Discussions board
    at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)
    is a good place to post questions about the code, book, or application. Want to
    contribute? Navigate to the Issues at [https://github.com/jelster/space-truckers/issues](https://github.com/jelster/space-truckers/issues)
    and browse for open ones that catch your fancy, or create a new Issue to discuss
    your enhancement, bug, or new feature. In the next chapter, we’re going to make
    good use of the route and the encounters generated to build the driving mini-game.
    Along the way, we’ll learn how to shift camera perspectives to a first-person
    view, apply decals to meshes, and more!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，本章讨论的代码可在[https://github.com/jelster/space-truckers/tree/ch7](https://github.com/jelster/space-truckers/tree/ch7)找到，尽管在这个历史时刻游戏仍然不完整，但我们可以通过本章的内容指出具体和有价值的进展——永远不要忘记为自己在旅程中取得的进步给予肯定！关于代码、书籍或应用的讨论板[https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)是发布有关代码、书籍或应用的提问的好地方。想要贡献？导航到[https://github.com/jelster/space-truckers/issues](https://github.com/jelster/space-truckers/issues)并浏览吸引你的开放问题，或者创建一个新的问题来讨论你的增强、错误或新功能。在下一章中，我们将充分利用路线和生成的遭遇来构建驾驶迷你游戏。在这个过程中，我们将学习如何将摄像机视角切换到第一人称视图，将贴图应用到网格上，以及更多！
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There’s an entire category of Issues aimed at first-time contributors and people
    lacking experience or familiarity with Babylon.js and/or Space-Truckers – it’s
    called **Good First Issue**. Want to make MacGyver proud and fix Issues that nobody
    else can fix? Check out the **Help Wanted** label!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个专门针对首次贡献者以及缺乏 Babylon.js 和/或 Space-Truckers 经验或熟悉度的人的问题类别——它被称为**良好入门问题**。想要让麦格维感到自豪并修复其他人无法修复的问题吗？查看**需要帮助**标签！
- en: Extended Topics
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'There is always more content and ideas than there are time and space to implement
    them, so here are some ways that you can push yourself further with the content
    from this chapter. Before moving on to the next chapter, or at any time later,
    think of these as launch pads for you to clarify and fold the lessons learned
    here in the forge of experience:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有比时间和空间更多内容和建议，因此这里有一些方法可以帮助你利用本章的内容进一步挑战自己。在进入下一章或之后的任何时候，将这些视为你澄清和融合在这里学到的教训的经验发射台：
- en: Add a new particle system based on the Sparks particle sample that is triggered
    when the cargo collides with something during the route planning’s flight phase.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路线规划阶段的飞行阶段，当货物与某物碰撞时，基于火花粒子样本的新粒子系统将被触发。
- en: 'The world of Space-Truckers is rich and varied, and the game could display
    more of that richness. Use an animated particle system to bring these areas to
    life:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Space-Truckers 的世界丰富多彩，游戏可以展示更多的这种丰富性。使用动画粒子系统让这些区域生动起来：
- en: Orbital manufacturing might look like a series of flashing lights from maneuver
    thrusters and welding torches clustering around shadowed block structures
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨道制造可能看起来像是一系列闪烁的灯光，这些灯光来自机动推进器和焊接火炬，围绕着阴影中的块状结构聚集。
- en: Traffic in the Space-Construction and Space-Highway zones could similarly be
    approximated with clusters of flashing lights zipping around
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在太空建设和太空高速公路区域内的交通也可以用闪烁的灯光群来近似表示，这些灯光在周围快速移动
- en: Add the capability to load encounter lists from external sources other than
    the **gameData** file. The source can be a relative or remote path, with CMDFs
    being recomputed for the new list for each zone.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加从除**gameData**文件之外的外部来源加载遭遇列表的功能。源可以是相对路径或远程路径，对于每个区域，将重新计算新的列表的 CMDFs。
- en: Make an enhanced random number generator that will weigh or re-roll random values
    to avoid returning the same value more than *X* times in *Y* rolls.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个增强的随机数生成器，该生成器将权衡或重新掷骰随机值，以避免在 *Y* 掷中超过 *X* 次返回相同的值。
- en: Random numbers generated by computers tend to cluster and clump unrealistically
    – the Asteroids are a great demonstration of that. There are other ways to weigh
    and generate random series of numbers, though. Sneak to the `ch10` branch of the
    Space-Truckers source code on GitHub to see how the `randomGenerator` module implements
    `getGaussianRandom` for one example.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机生成的随机数往往会出现不切实际的聚集和簇状分布——小行星就是一个很好的例子。尽管如此，还有其他方法可以权衡和生成随机数序列。偷偷前往GitHub上Space-Truckers源代码的`ch10`分支，看看`randomGenerator`模块是如何实现`getGaussianRandom`的，以其中一个例子为例。
