<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Add Rendering Effects Using Built-in Post-processes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Add Rendering Effects Using Built-in Post-processes</h1></div></div></div><p>Remember <a class="link" href="ch04.html" title="Chapter 4. Using Materials to Customize 3D Objects Appearance">Chapter 4</a>, <span class="emphasis"><em>Using Materials to Customize 3D Objects Appearance</em></span>, about materials? Behind the materials are GPU programs called <span class="strong"><strong>shaders</strong></span>. Shaders are a combination of two linked programs: the vertex shader and the pixel shader. The vertex shader works on vertices (transforms their 3D positions to 2D positions on the screen), while the pixel shader works on pixels (determines the final color of each pixel). Here, you can see the post-processes to be only a pixel shader since the vertex shader is the same for all.</p><p>Finally, the post-processes tend to create effects only in the view space. In other words, the post-processes are never applied to objects such as meshes, they are applied only to the camera itself. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using post-processes with Babylon.js</li><li class="listitem" style="list-style-type: disc">Using post-process rendering pipelines with Babylon.js</li><li class="listitem" style="list-style-type: disc">Discussing the built-in post-processes</li></ul></div><div class="section" title="Using post-processes with Babylon.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec33"/>Using post-processes with Babylon.js</h1></div></div></div><p>Fortunately, you'll not have to create post-processes yourself, even if you can do it with Babylon.js. There are post-processes already available in Babylon.js and in most cases, available by writing only a line of code!</p><div class="section" title="Starting with your first post-process"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Starting with your first post-process</h2></div></div></div><p>With the post-processes available in Babylon.js, you can create blur, bloom, HDR, SSAO, volumetric light post-processes, and so on.</p><p>Let's start with the following scene:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_001-1024x551.png" alt="Starting with your first post-process"/></div><p>
</p><p>For the first example, let's create a vertical blur post-process using the built-in post-processes. The blur post-process is available by creating a new instance of the <code class="literal">BABYLON.BlurPostProcess</code> class, as follows:</p><pre class="programlisting">var blurV = new BABYLON.BlurPostProcess(&#13;
  "blurV", // Name of the post-process&#13;
  new BABYLON.Vector2(0, 1), // Direction of the blur (vertical)&#13;
  4, // The blur width&#13;
  0.5, // The ratio of the post-process&#13;
  camera // The camera to attach to&#13;);</pre><p>The result is as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.png" alt="Starting with your first post-process"/></div><p>
</p><p>The majority of post-processes available in Babylon.js will have the same parameters as shown in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Name</strong></span>: This is the name of the post-process.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ratio</strong></span>: This is the ratio of the post-process in the <code class="literal">[0, 1]</code> interval. The ratio is used to calculate the post-process in a lower resolution in order to save performances. In other words, with a ratio of <code class="literal">0.5</code>, the post-process will be applied to the canvas resolution divided by 2.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Camera</strong></span>: The post-processes are applied on the cameras. Then, you just have to provide the camera reference and the post-process's constructors attaches itself to the camera.</li></ul></div><p>For another example, let's create a <code class="literal">black and white</code> post-process that will make the scene entirely black and white, as follows:</p><pre class="programlisting">var bw = new BABYLON.BlackAndWhitePostProcess(&#13;
  "blackAndWhite", // name of the post-process&#13;
  1.0, // ratio of 1.0, keep the full resolution&#13;
  camera // the camera to attach to&#13;);</pre><p>The following screenshot displays the result:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_003.png" alt="Starting with your first post-process"/></div><p>
</p></div><div class="section" title="Chaining post-processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Chaining post-processes</h2></div></div></div><p>With Babylon.js, you can chain post-processes. This means that for a post-process, the previous post-process will be used as a reference. For example, two blur post-processes can be used to blur the scene horizontally and vertically; the first post-process blurs the scene horizontally and the second uses the horizontal blur post-process to blur the scene vertically.</p><p>Let's create the first post-process that is the horizontal blur post-process:</p><pre class="programlisting">var blurH = new BABYLON.BlurPostProcess(&#13;
  "blurH",&#13;
  new BABYLON.Vector2(1, 0),&#13;
  8,&#13;
  0.5,&#13;
  camera&#13;);</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_004-1024x548.png" alt="Chaining post-processes"/></div><p>
</p><p>Now, let's create the vertical blur post-process after the horizontal blur post-process, as follows:</p><pre class="programlisting">var blurV = new BABYLON.BlurPostProcess(&#13;
  "blurV",&#13;
  new BABYLON.Vector2(0, 1),&#13;
  8,&#13;
  0.5,&#13;
  camera&#13;);</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_005-1024x549.png" alt="Chaining post-processes"/></div><p>
</p><p>Finally, why not add the <code class="literal">black and white</code> post-process, as shown in the following:</p><pre class="programlisting">var bw = new BABYLON.BlackAndWhitePostProcess("bw", 1.0, camera);</pre><p>The final result is displayed in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_006-1024x549.png" alt="Chaining post-processes"/></div><p>
</p></div><div class="section" title="Removing and retrieving post-processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Removing and retrieving post-processes</h2></div></div></div><p>To remove a post-process from the camera, you can simply call the <code class="literal">.dispose</code> function on a post-process. The dispose function removes the internal resources and detaches the post-process from the camera.</p><p>For example, consider the following with the previous chained post-processes:</p><pre class="programlisting">blurH.dispose();&#13;
blurV.dispose();&#13;
bw.dispose();</pre><p>Conversely, you can detach and attach a post-process from/to a camera without removing the internal resources. Simply, call the <code class="literal">.attachPostProcess</code> or <code class="literal">.detachPostProcess</code> functions on a camera. Consider the following example:</p><pre class="programlisting">camera.detachPostProcess(blurH); // Detach&#13;
camera.attachPostProcess(blurH); // Re-attach the post-process</pre><p>To retrieve the available post-processes, you can access the <code class="literal">._postProcesses</code> property of a camera. Consider the following example:</p><pre class="programlisting">for (var i=0; i &lt; camera._postProcesses.length; i++) {&#13;
  console.log(camera._postProcesses[i].name);&#13;
}</pre></div></div></div>
<div class="section" title="Using post-process rendering pipelines with Babylon.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec34"/>Using post-process rendering pipelines with Babylon.js</h1></div></div></div><p>Now, you are able to create post-processes and attach them to a camera. The problem is that if you manage multiple cameras in your project, then you'll have to dispose or detach post-processes in order to reattach them to a new camera. To facilitate the task, you can use the rendering pipelines. In other words, you can see a rendering pipeline as a list of post-processes, which you can attach to multiple cameras.</p><div class="section" title="Create a rendering pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Create a rendering pipeline</h2></div></div></div><p>The steps consist on creating a pipeline reference, adding the pipeline to the scene, and attaching the pipeline to the cameras.</p><p>Create a rendering pipeline, as follows:</p><pre class="programlisting">var pipeline = new BABYLON.PostProcessRenderPipeline(&#13;
  engine, // The Babylon.js engine&#13;
  "renderingPipeline" // The name of the rendering pipeline&#13;);</pre><p>Once the pipeline has been created, add it to the post-process render pipeline manager of the scene (referenced by the engine that you passed as an argument to the rendering pipeline's constructor), as follows:</p><pre class="programlisting">scene.postProcessRenderPipelineManager.addPipeline(pipeline);</pre><p>Once the pipeline is added to the post-process render pipeline manager, you are able to add the effects. The process consists of adding a new 
<code class="literal">BABYLON.PostProcessRenderEffect</code> object to the pipeline by calling the <code class="literal">.addEffect</code> method to the pipeline, as shown in the following snippet:</p><pre class="programlisting">// Create the post-process (horizontal blur)&#13;
var blurH = new BABYLON.BlurPostProcess(&#13;
  "blurH",&#13;
  new BABYLON.Vector2(1, 0), 8, 0.5,&#13;
  null, // The camera is null&#13;
  null, // Keep the bilinear filter as default&#13;
  engine // Because the camera is null, we must provide the engine&#13;);&#13;
// Create the render effect&#13;
var blurHEffect = new BABYLON.PostProcessRenderEffect(&#13;
  engine, // The Babylon.js engine&#13;
  "blurHEffect", // The name of the post-process render effect&#13;
  () =&gt; { // The function that returns the wanted post-process&#13;
    return blurH;&#13;
  }&#13;);&#13;
// Add the render effect to the pipeline&#13;
pipeline.addEffect(blurHEffect);</pre><p>As you can see, the method to construct the post-processes must be changed. Now, the post-processes will not take any camera as an argument since they are not applied to a specific camera. This is the reason why we must provide all the arguments, such as the filter type (bilinear as default, then can be null) and the engine. This method is the same for all the post-processes, you can easily add post-process render effects to the pipeline, as follows:</p><pre class="programlisting">var blurH = new BABYLON.BlurPostProcess(..);&#13;
var blurV = new BABYLON.BlurPostProcess(..);&#13;
var bw = new BABYLON.BlackAndWhitePostProcess(..);&#13;
// The horizontal blur post-process render effect&#13;
var blurHEffect = new BABYLON.PostProcessRenderEffect(&#13;
  engine, // The Babylon.js engine&#13;
  "blurHEffect",&#13;
  () =&gt; {&#13;
    return blurH;&#13;
  }&#13;);&#13;
// The vertical blur post-process render effect&#13;
var blurVEffect = new BABYLON.PostProcessRenderEffect(&#13;
  engine, // The Babylon.js engine&#13;
  "blurVEffect",&#13;
  () =&gt; {&#13;
    return blurV;&#13;
  }&#13;);&#13;
// The black and white post-process render effect&#13;
var bwEffect = new BABYLON.PostProcessRenderEffect(&#13;
  engine,&#13;
  "bwEffect",&#13;
  () =&gt; {&#13;
    return bw;&#13;
  }&#13;);&#13;
// And finally add the render effects to the pipeline by&#13;
// following the desired order&#13;
pipeline.addEffect(blurHEffect);&#13;
pipeline.addEffect(blurVEffect);&#13;
pipeline.addEffect(bwEffect);</pre><p>Finally, let's attach the pipeline to a camera or a list of cameras. The post-process will now be applied to the cameras, as shown in the following snippet:</p><pre class="programlisting">scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(&#13;
  "renderingPipeline", // The name of the pipeline to attach&#13;
  camera // the camera to attach to. Can be an array of cameras&#13;);</pre><p>You can also detach the pipeline from a camera or a list of cameras, as follows:</p><pre class="programlisting">scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(&#13;
  "renderingPipeline", // The name of the pipeline to detach&#13;
  camera // the camera to detach. Can be an array of cameras&#13;);</pre><p>The result looks exactly the same; however, now it's easier to share the post-processes among your multiple cameras, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_007-1024x549.png" alt="Create a rendering pipeline"/></div><p>
</p></div><div class="section" title="Enabling and disabling effects in pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Enabling and disabling effects in pipeline</h2></div></div></div><p>Another particularity of the post-process render pipelines is the possibility of disabling and enabling effects, a useful feature that allows you to highly debug the rendering part of your project.</p><p>Consider that, in your project, you can switch between two cameras (<code class="literal">scene.activeCamera = theNewCamera</code>). The first camera is blurred and the second is blurred and <code class="literal">black and white</code>. The goal is that the two cameras can share the same post-process render pipeline reference, except that the first camera must have the <code class="literal">black and white</code> post-process disabled.</p><p>To disable an effect in a render pipeline, you can call the  <code class="literal">.disableEffectInPipeline</code> method on the post-process render pipeline manager of your scene. The only parameters needed are the pipeline's name, the effect's name, and the camera that will no longer have the post-process enabled. If we take the previous example, let's deactivate the <code class="literal">black and white</code> post-process, as follows:</p><pre class="programlisting">scene.postProcessRenderPipelineManager.disableEffectInPipeline(&#13;
  "renderingPipeline", // The name of the render pipeline&#13;
  "bwEffect", // The name of the "black and white" effect to disable&#13;
  camera // The camera attached to the pipeline&#13;);</pre><p>In other words, this method allows you to deactivate a render effect only for the camera passed as an argument.</p><p>Conversely, at any time, you can enable a render effect that is previously disabled by calling the  <code class="literal">.enableEffectInPipeline</code> method on the post-process render pipeline manager of your scene. Let's enable the <code class="literal">black and white</code> render effect, as shown in the following:</p><pre class="programlisting">scene.postProcessRenderPipelineManager.enableEffectInPipeline(&#13;
  "renderingPipeline", // The name of the render pipeline&#13;
  "bwEffect", // The name of the "black and white" effect to enable&#13;
  camera // The camera attached to the pipeline&#13;);</pre></div></div>
<div class="section" title="The built-in post-processes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec35"/>The built-in post-processes</h1></div></div></div><p>Let's start with the most interesting part of this chapter; the use of the built-in post-processes in Babylon.js. There are several post-processes that can beautify your scenes only though the use of the following elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Volumetric light scattering</strong></span>: This shows how to easily scatter the light rays of a given light source, such as a sun or a moon.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SSAO rendering pipeline</strong></span>: Screen-Space Ambient Occlusion. In other words, this rendering pipeline tends to approximate the ambient occlusion of a scene for more realism, only using a post-process.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HDR rendering pipeline</strong></span>: High Dynamic Range rendering. This rendering pipeline is directly related to the lighting in the scene and tends to simulate the way retinas work in the real world.</li></ul></div><div class="section" title="Volumetric Light Scattering post-process"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Volumetric Light Scattering post-process</h2></div></div></div><p>Let's start this fun part with the <span class="strong"><strong>Volumetric Light Scattering</strong></span> (<span class="strong"><strong>VLS</strong></span>) post-process. The VLS post-process tends to simulate the scattering of light rays from a light source according to the obstacles between the light and the camera.</p><p>Let's take the following original scene:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_008.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The VLS post-process takes a mesh that will represent the light color as an argument. In fact, the light source isn't really a light (<code class="literal">BABYLON.Light</code>), but a mesh with a material configured to simulate the light's color by a diffuse texture or color.</p><p>Let's consider, for example, a white sun represented by a billboard. With the VLS post-process, the result looks similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_009-1024x549.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The scene, without the post-process, looks similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_010.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The rounded white mesh is, in fact, a plane with a diffuse texture that contains alpha. The diffuse texture can be found in the example files and is named <code class="literal">sun.png</code>.</p><p>Let's create the VLS post-process, as follows:</p><pre class="programlisting">var vls = new BABYLON.VolumetricLightScatteringPostProcess(&#13;
  "vls", // The name of the post-process&#13;
  1.O, // The ratio of the post-process&#13;
  camera, // The camera to attach to&#13;
  null, // The mesh used as light source&#13;
  100 // Number of samples. Means the quality of the post-process&#13;);</pre><p>In the VLS constructor, if the mesh parameter is null, the post-process creates a default mesh that is a plane rendered as a billboard. At any time, if you want, you can access the method as shown in the following:</p><pre class="programlisting">BABYLON.VolumetricLightScatteringPostProcess.CreateDefaultMesh(&#13;
  "vlsMesh", // The name of the billboard plane mesh&#13;
  scene // The scene where to add the billboard plane mesh&#13;);</pre><p>For example, the mansion scene of Babylon.js used the VLS post-process to scatter the moon's light rays. The result was the following image:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_011-1024x507.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The method is pretty simple, they just got the moon's mesh reference and created the VLS post-process by passing the moon's mesh reference as parameter, as follows:</p><pre class="programlisting">var moon = scene.getMeshByName("moon");&#13;
var vls = new BABYLON.VolumetricLightScatteringPostProcess(&#13;
  "vls", // The name of the post-process&#13;
  1.O, // The ratio of the post-process&#13;
  camera, // The camera to attach to&#13;
  moon, // The mesh used as light source&#13;
  75 // Number of samples. Means the quality of the post-process&#13;);</pre><p>The number of samples is typically in the <code class="literal">[30, 100]</code> interval and defines the quality of the post-process's result. In the mansion scene of Babylon.js, the number of samples was set to <code class="literal">65</code> in order to save the performance due to the pretty large and really nice scene that was already rendered by the engine.</p><p>To save more performance, the ratio of the post-process can be more customized. In fact, the VLS post-process uses an internal pass that renders the scene in a texture (Render Target Texture) to create the scattering of light rays. You can easily configure the internal pass in order to render in a lower resolution. Simply pass an object as an argument for the ratio, as shown in the following snippet:</p><pre class="programlisting">var ratio = {&#13;
  passRatio: 0.25, // Ratio of the internal pass. Render in a texture&#13;
  // with a size divided per 4&#13;
  postProcessRatio: 1.0 // Ratio of the post-process&#13;
};&#13;
var vls = new BABYLON.VolumetricLightScatteringPostProcess(&#13;
  "vls", // The name of the post-process&#13;
  ratio, // The ratio object&#13;
  camera, // The camera to attach to&#13;
  moon, // The mesh used as light source&#13;
  100 // Number of samples. Means the quality of the post-process&#13;);</pre><p>You can also customize the parameters related to the VLS post-process itself.</p><p>The exposure controls the overall intensity of the effect (default <code class="literal">0.3</code>), as follows:</p><pre class="programlisting">vls.exposure = 0.7; // Exaggerated value</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_012-1024x548.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The decay dissipates each sample's contribution (default <code class="literal">0.96815</code>), as shown in the following code:</p><pre class="programlisting">vls.decay = 0.9;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_013-1024x548.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The weight controls the overall intensity of each sample (default <code class="literal">0.58767</code>), as shown in the following code:</p><pre class="programlisting">vls.weight = 0.8;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_014-1024x545.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>The density controls the density of each sample (default <code class="literal">0.926</code>), as shown in the following code:</p><pre class="programlisting">vls.density = 0.7;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_015-1024x549.png" alt="Volumetric Light Scattering post-process"/></div><p>
</p><p>To give you an order, the mansion scene of Babylon.js was configured as follows:</p><pre class="programlisting">var moon = scene.getMeshByName("Moon");&#13;
var vls = new BABYLON.VolumetricLightScatteringPostProcess(&#13;
  "vls",&#13;
  1.0,&#13;
  scene.activeCamera,&#13;
  moon,&#13;
  65,&#13;);&#13;
vls.exposure = 0.15;&#13;
vls.weight = 0.54;</pre></div><div class="section" title="SSAO rendering pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>SSAO rendering pipeline</h2></div></div></div><p>The SSAO effect is a rendering pipeline as it counts the following five post-processes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pass post-process (saves the scene in a texture)</li><li class="listitem" style="list-style-type: disc">SSAO post-process</li><li class="listitem" style="list-style-type: disc">Horizontal blur post-process</li><li class="listitem" style="list-style-type: disc">Vertical blur post-process</li><li class="listitem" style="list-style-type: disc">Combine post-process</li></ul></div><p>The SSAO is famous as it computes the ambient occlusion only using the screen space (post-process) in contrast with the more classical methods that require the 3D artists to calculate the ambient occlusion in their textures. Finally, the SSAO is a good way to save textures and the weight of your projects (no more textures required).</p><p>Let's see the SSAO effect in this scene, the scene without SSAO, the scene with SSAO, and finally the scene with only SSAO enabled:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_016-1024x455.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_017-1024x487.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_018-1024x489.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>The result is particularly discreet; however, it can highly add realism to your scenes. The ambient occlusion is the way to represent the capacity of the light rays to access the objects at its different points, or specifically with SSAO, the light rays that cannot access the objects at its different points.</p><p>At a various point of view, the effect can be easily perceived, as shown in the following images:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_019-1024x454.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_020-1024x453.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>The SSAO is a render pipeline and can be easily created, as follows:</p><pre class="programlisting">var ssao = new BABYLON.SSAORenderingPipeline(&#13;
  "ssao", // The name of the render pipeline&#13;
  scene, // The scene where to add the render pipeline&#13;
  1.0 // The ratio of SSAO post-process&#13;);&#13;
// Attach the render pipeline to your camera&#13;
scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(&#13;
  "ssao", // Name of the render pipeline&#13;
  camera // The camera to attach to&#13;);</pre><p>That's all. Fortunately, the SSAO, the horizontal, and the vertical blur post-processes can be done at a lower resolution than the screen size. As for the VLS post-process, you can pass an object for the ratio parameter, as follows:</p><pre class="programlisting">var ratio = {&#13;
  ssaoRatio: 0.25, // Size divided per 4, saves a lot of performances!&#13;
  combineRatio: 1.0 // The final output that mixes SSAO with the scene&#13;
};&#13;
var ssao = new BABYLON.SSAORenderingPipeline(&#13;
  "ssao", // The name of the render pipeline&#13;
  scene, // The scene where to add the render pipeline&#13;
  ratio // The ratio of SSAO post-process&#13;);</pre><p>In each scene's function, you may have to configure the SSAO to render perfectly. There are several parameters that you can customize, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The total strength: This controls the overall intensity of the effect (default <code class="literal">1.0</code>). The <code class="literal">.totalStrength</code> property is rarely or slightly modified as it can create some artifacts.</li><li class="listitem" style="list-style-type: disc">The radius: This represents the radius around the analyzed pixel by the SSAO (default <code class="literal">0.0002</code>). To calculate the A<span class="strong"><strong>mbient </strong></span>Occlusion (<span class="strong"><strong>AO</strong></span>) of the current pixel, the SSAO effect computes 16 samples around the current pixel in the specified <code class="literal">.radius</code> property.</li><li class="listitem" style="list-style-type: disc">The area: The <code class="literal">.area</code> (default <code class="literal">0.0075</code>) property is used to interpolate the SSAO samples based on the occlusion difference of each pixel. In other words, the area is used to smooth the ambient occlusion of each sample of each pixel. Take a look at the following example of a smooth function base on a line (from Wikipedia):</li></ul></div><p>
</p><div class="mediaobject"><img src="graphics/image_08_021-1024x768.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>In the example files, you can press the <span class="strong"><strong>2</strong></span> key to disable SSAO, <span class="strong"><strong>1</strong></span> to enable SSAO, and <span class="strong"><strong>3</strong></span> to only draw the SSAO pass. The results (in order) are shown in the following images:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_022-1024x500.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_023-1024x502.png" alt="SSAO rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_024-1024x505.png" alt="SSAO rendering pipeline"/></div><p>
</p></div><div class="section" title="HDR rendering pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec67"/>HDR rendering pipeline</h2></div></div></div><p>The <span class="strong"><strong>High Dynamic Range</strong></span> (<span class="strong"><strong>HDR</strong></span>) was a buzzword for a long time. This concept, particularly interesting, tends to simulate how the retinas operate in the real world. It includes the adaptation of luminosity (glaring) and the luminosity artifacts on the highlighted surfaces of an object.</p><p>To understand the effect of glare, imagine that you are in a totally dark room. Suddenly, someone turns the light on; the necessary time for your eye to adapt to the luminosity (bloomed and blurred) represents the glare effect.</p><p>Let's compare the same scene with and without the HDR render pipeline enabled (HDR will adapt the luminosity and create artifacts on the highlighted zones), as shown in the following images:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_025-1024x456.png" alt="HDR rendering pipeline"/></div><p>
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_026-1024x453.png" alt="HDR rendering pipeline"/></div><p>
</p><p>To create an HDR render pipeline, the process is the same as the SSAO render pipeline, as follows:</p><pre class="programlisting">var hdr = new BABYLON.HDRRenderingPipeline(&#13;
  "hdr", // The name of the render pipeline&#13;
  scene, // The scene where to add the render pipeline&#13;
  1.0, // ratio of the render pipeline. Here, the ratio is a number&#13;);&#13;
// Finally, attach the render pipeline to a camera&#13;
scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(&#13;
  "hdr", // The name of the render pipeline&#13;
  camera // The camera to attach to&#13;);</pre><p>The HDR rendering pipeline can be highly customized as you can customize the minimum luminosity required to create the artifacts, create the blur effect that creates the artifacts, the speed of retina adaptation of luminosity, and so on.</p><p>The exposure (<code class="literal">hdr.exposure</code>) controls the overall luminosity of the scene (default 1.0), as shown in the following:</p><pre class="programlisting">hdr.exposure = 1.8;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_027-1024x460.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The bright threshold (<code class="literal">hdr.brightThreshold</code>) controls the minimum luminance required to create the artifacts (default <code class="literal">0.8</code>), as shown in the following:</p><pre class="programlisting">hdr.brightThreshold = 0.2;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_028-1024x454.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The minimum luminance (<code class="literal">hdr.minimumLuminance</code>) represents the retina adaptation in the darker zones (default <code class="literal">1.0</code>). The smaller the value (<code class="literal">&gt;= 0.0</code>), the more highlighted the scene is, as shown in the following:</p><pre class="programlisting">hdr.minimumLuminance = 0.0;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_029-1024x455.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The luminance decrease rate (<code class="literal">hdr.luminanceDecreaseRate</code>) and luminance increase rate (<code class="literal">hdr.luminanceIncreaserate</code>) represent the speed of retina adaptation to the luminosity (default <code class="literal">0.5</code> for both). The higher the value, the quicker the adaptation. In most cases, the value is between <code class="literal">0.5</code> and <code class="literal">1.0</code>.</p><p>The Gaussian blur multiplier (<code class="literal">hdr.gaussMultiplier</code>) intensifies the blur width (default <code class="literal">4</code>). It works the <code class="literal">.blurWidth</code> property of <code class="literal">BABYLON.BlurPostProcess</code>, as shown in the following:</p><pre class="programlisting">hdr.gaussMultiplier = 8;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_030-1024x458.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The Gaussian coefficient (<code class="literal">hdr.gaussCoeff</code>) controls the overall Gaussian blur effect (default <code class="literal">0.3</code>). In fact, the output of the Gaussian blur is <span class="emphasis"><em>output * gaussCoeff</em></span>, as shown in the following:</p><pre class="programlisting">hdr.gaussCoeff = 0.8;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_031-1024x455.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The Gaussian standard deviaition (<code class="literal">hdr.gaussStandDev</code>) controls the overall blur intensity of the effect (default 0.8), as shown in the following:</p><pre class="programlisting">hdr.gaussStandDev = 0.2;</pre><p>
</p><div class="mediaobject"><img src="graphics/image_08_032-1024x456.png" alt="HDR rendering pipeline"/></div><p>
</p><p>The <code class="literal">.gausCoeff</code> and <code class="literal">.gaussStandDev</code> properties are linked together. They must be equilibrated relative to each other. To give you an order, the following scene is configured:</p><pre class="programlisting">var hdr = new BABYLON.HDRRenderingPipeline("hdr", scene, 1.0);&#13;
hdr.brightThreshold = 0.5;&#13;
hdr.gaussCoeff = 0.7;&#13;
hdr.gaussMean = 1.0;&#13;
hdr.gaussStandDev = 7.5;&#13;
hdr.minimumLuminance = 0.7;&#13;
hdr.luminanceDecreaseRate = 1.0;&#13;
hdr.luminanceIncreaserate = 1.0;&#13;
hdr.exposure = 1.3;&#13;
hdr.gaussMultiplier = 4;</pre><p>It looks like the following:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_033-1024x456.png" alt="HDR rendering pipeline"/></div><p>
</p><p>In most cases, in a highlighted scene, following the Gaussian Blur equations with the implementation of HDR in Babylon.js, the Gaussian Standard Deviation equals <span class="emphasis"><em>10.0 * Gaussian Coefficient</em></span>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec36"/>Summary</h1></div></div></div><p>
 In this chapter, you learned how to beautify your scenes using only post-processes. The Mansion demo on the Babylon.js home page showed a great usage of the Volumetric Light Scattering post-process. Unfortunately, none of the post-processes are available on phones due to hardware limitations. Even if the post-process is not supported on mobiles, your projects will still run without the post-process being rendered. The power of Babylon.js resides in the fact that it works on all devices. Even if a feature is not supported on a device, the feature will simply be disabled.
</p><p>
In the next chapter, let's end this with animations. The Babylon.js framework allows creating and managing animations. These animations will allow you to animate characters, objects, and more with the help of the framework and 3D artists!
</p></div></body></html>