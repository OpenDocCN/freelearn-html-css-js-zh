- en: Chapter 1. Getting Organized with NPM, Bower, and Grunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript was the bane of the web development industry during the early days
    of the browser-rendered Internet. It now powers hugely impactful libraries such
    as jQuery, and JavaScript-rendered (as opposed to server-side-rendered) content
    is even indexed by many search engines. What was once largely considered an annoying
    language used primarily to generate pop-up windows and alert boxes, has now become
    arguably the most popular programming language in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is JavaScript now more prevalent than ever in frontend architecture,
    but it has become a server-side language as well, thanks to the *Node.js* runtime.
    We have also seen the proliferation of document-oriented databases, such as MongoDB,
    which store and return JSON data. With JavaScript present throughout the development
    stack, the door is now open for JavaScript developers to become full-stack developers
    without the need to learn a traditional server-side language. Given the right
    tools and know-how, any JavaScript developer can create *single page applications*
    comprised entirely of the language they know best, and they can do so using an
    architecture like *MEAN* (MongoDB, Express, AngularJS, and Node.js).
  prefs: []
  type: TYPE_NORMAL
- en: Organization is key to the development of any complex **Single Page Application**
    (**SPA**). If you don't get organized from the beginning, you are sure to introduce
    an inordinate number of regressions to your app. The Node.js ecosystem will help
    you to do this with a full suite of indispensable and open-source tools, three
    of which we will discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**NPM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bower frontend package manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grunt** JavaScript task runner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these three tools can be used together to create an organized development
    environment that is ideal for creating an SPA and is essential to the MEAN stack
    architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Node Package Manager?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within any full-stack JavaScript environment, **Node Package Manager** will
    be your *go-to* tool for setting up your development environment and for managing
    server-side libraries. NPM can be used within both global and isolated environment
    contexts. We will first explore the use of NPM globally.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js and NPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NPM is a component of *Node.js*, so before you can use it you must first install
    Node.js. You can find installers for both Mac and Windows at nodejs.org. Once
    you have Node.js installed, using NPM is incredibly easy and is done from the
    **Command Line Interface** (**CLI**). Start by ensuring you have the latest version
    of NPM installed, as it is updated more often than Node.js itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When using NPM, the `-g` option will apply your changes to your global environment.
    In this case, you want your version of NPM to apply globally. As stated previously,
    NPM can be used to manage packages both globally and within isolated environments.
    In the following, we want essential development tools to be applied globally so
    that you can use them in multiple projects on the same system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Mac and some Unix-based systems, you may have to run the `npm` command
    as the superuser (prefix the command with `sudo`) in order to install packages
    globally, depending on how NPM was installed. If you run into this issue and wish
    to remove the need to prefix `npm` with `sudo`, see [docs.npmjs.com/getting-started/fixing-npm-permissions](http://docs.npmjs.com/getting-started/fixing-npm-permissions).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your package.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any project you develop, you will keep a local `package.json` file to manage
    your Node.js dependencies. This file should be stored at the root of your project
    directory and it will only pertain to that isolated environment. This allows you
    to have multiple Node.js projects with different dependency chains on the same
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When beginning a new project, you can automate the creation of the `package.json`
    file from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `npm init` will take you through a series of JSON property names to
    define through command line prompts, including your app''s `name`, `version` number,
    `description`, and more. The `name` and `version` properties are required, and
    your Node.js package will not install without them defined. Several of the properties
    will have a default value given within parentheses in the prompt so that you may
    simply hit *Enter* to continue. Other properties will simply allow you to hit
    *Enter* with a blank entry and will not be saved to the `package.json` file, or
    will be saved with a blank value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `entry point` prompt will be defined as the `main` property in `package.json`
    and is not necessary unless you are developing a Node.js application. In our case,
    we can forgo this field. The `npm init` command may in fact force you to save
    the `main` property, so you will have to edit `package.json` afterward to remove
    it; however, that field will have no effect on your web app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also choose to create the `package.json` file manually using a text
    editor, if you know the appropriate structure to employ. Whichever method you
    choose, your initial version of the `package.json` file should look similar to
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want your project to be private and want to ensure that it does not
    accidently get published to the NPM registry, you may want to add the `private`
    property to your `package.json` file, and set it to `true`. Additionally, you
    may remove some properties that only apply to a registered package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have your `package.json` file set up the way you like it, you can begin
    installing Node.js packages locally for your app. This is where the importance
    of dependencies begins to surface.
  prefs: []
  type: TYPE_NORMAL
- en: NPM dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three types of dependencies that can be defined for any Node.js project
    in your `package.json` file: `dependencies`, `devDependencies`, and `peerDependencies`.
    For the purpose of building a web-based SPA, you will only need to use the `devDependencies`
    declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '`devDependencies` are those which are required for developing your application,
    but not required for its production environment or for simply running it. If other
    developers want to contribute to your Node.js application, they will need to run
    `npm install` from the command line to set up the proper development environment.
    For information on the other types of dependencies, see docs.npmjs.com.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding `devDependencies` to your `package.json file`, the command line
    again comes to the rescue. Let''s use the installation of Browserify as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install Browserify locally and save it along with its version range
    to the `devDependencies` object in your `package.json` file. Once installed, your
    `package.json` file should look similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `devDependencies` object will store each package as a key-value pair in
    which the key is the *package name* and the value is the *version number* or *version
    range*. Node.js uses semantic versioning, where the three digits of the version
    number represent `MAJOR.MINOR.PATCH`. For more information on semantic version
    formatting, see [semver.org](http://semver.org).
  prefs: []
  type: TYPE_NORMAL
- en: Updating your development dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You will notice that the version number of the installed package is preceded
    by a **caret** (`^`) symbol by default. This means that package updates will only
    allow *patch* and *minor* updates for versions above 1.0.0\. This is meant to
    prevent major version changes from breaking your dependency chain when updating
    your packages to the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update your `devDependencies` and save the new version numbers, you can
    enter the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To update all globally installed NPM packages to their latest versions, run
    `npm update` with the `-g` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more information on semantic versioning within NPM, see [docs.npmjs.com/misc/semver](http://docs.npmjs.com/misc/semver).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have NPM set up and you know how to install your development dependencies,
    you can move on to installing Bower.
  prefs: []
  type: TYPE_NORMAL
- en: Bower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bower is a package manager for frontend web assets and libraries. You will use
    it to maintain your frontend stack and control version chains for libraries such
    as jQuery, AngularJS, and any other components necessary to your app's web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Bower
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bower is also a Node.js package, so you will install it using NPM, much like
    you did with the Browserify example installation in the previous section, but
    this time you will be installing the package globally. This will allow you to
    run `bower` from the command line anywhere on your system without having to install
    it locally for each project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can alternatively install Bower locally as a development dependency so
    that you may maintain different versions of it for different projects on the same
    system, but this is generally not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, check that Bower is properly installed by querying the version from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Bower also requires a *Git* version control system, or *VCS*, to be installed
    on your system in order to work with packages. This is because Bower communicates
    directly with GitHub for package management data. If you do not have Git installed
    on your system, you can find instructions for Linux, Mac, and Windows at [git-scm.com](http://git-scm.com).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your bower.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of setting up your `bower.json` file is comparable to that of the
    `package.json` file for NPM. It uses the same JSON format, has both `dependencies`
    and `devDependencies`, and can also be automatically created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you type `bower init` from the command line, you will be prompted to define
    several properties with some defaults given within parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These questions may vary, depending on the version of Bower you install.
  prefs: []
  type: TYPE_NORMAL
- en: Most properties in the `bower.json` file are not necessary unless you are publishing
    your project to the Bower registry, indicated in the final prompt. You will most
    likely want to mark your package as private, unless you plan to register it and
    allow others to download it as a Bower package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the `bower.json` file, you can open it in a text editor
    and change or remove any properties you wish. It should look something like the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to keep your project private, you can reduce your `bower.json`
    file to two properties before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the initial version of your `bower.json` file set up the way you
    like it, you can begin installing components for your app.
  prefs: []
  type: TYPE_NORMAL
- en: Bower components location and the .bowerrc file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bower will install components into a directory named `bower_components` by
    default. This directory will be located directly under the root of your project.
    If you wish to install your Bower components under a different directory name,
    you must create a local system file named `.bowerrc` and define the custom directory
    name there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An object with only a single `directory` property name is all that is necessary
    to define a custom location for your Bower components. There are many other properties
    that can be configured within a `.bowerrc` file. For more information on configuring
    Bower, see bower.io/docs/config/.
  prefs: []
  type: TYPE_NORMAL
- en: Bower dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bower also allows you to define both the `dependencies` and `devDependencies`
    objects like NPM. The distinction with Bower, however, is that the `dependencies`
    object will contain the components necessary for running your app, while the `devDependencies`
    object is reserved for components that you might use for testing, transpiling,
    or anything that does not need to be included in your frontend stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bower packages are managed using the `bower` command from the CLI. This is
    a user command, so it does not require super user (sudo) permissions. Let''s begin
    by installing jQuery as a frontend dependency for your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--save` option on the command line will save the package and version number
    to the `dependencies` object in `bower.json`. Alternatively, you can use the `-S`
    option as a shortcut for `--save`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s install the Mocha JavaScript testing framework as a development
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we will use `--save-dev` on the command line to save the package
    to the `devDependencies` object instead. Your `bower.json` file should now look
    similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the package version numbers are preceded by the **tilde**
    (`~`) symbol by default, in contrast to the caret (`^`) symbol as is the case
    with NPM. The tilde serves as a more stringent guard against package version updates.
    With a `MAJOR.MINOR.PATCH` version number, running `bower update` will only update
    to the latest patch version. If a version number is composed of only the major
    and minor versions, `bower update` will update the package to the latest minor
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Searching the Bower registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All registered Bower components are indexed and searchable through the command
    line. If you don't know the exact package name of a component you wish to install,
    you can perform a search to retrieve a list of matching names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most components will have a list of keywords in their `bower.json` file so
    that you can more easily find the package without knowing the exact name. For
    example, you may want to install PhantomJS for headless browser testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The list returned will include any package with `phantomjs` in the package
    name or within its keywords list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from the returned list that the correct package name for PhantomJS
    is in fact `phantom` and not `phantomjs`. You can then proceed to install the
    package now that you know the correct name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now you have Bower installed and know how to manage your frontend web components
    and development tools, but how do you integrate them into your SPA? This is where
    Grunt comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grunt is a *JavaScript task runner* for Node.js, and if you haven't used it
    before, it is perhaps the best tool you never knew you needed. You will find it
    useful for a myriad of tasks including CSS and JavaScript linting and minification,
    JavaScript template pre-compilation, LESS and SASS pre-processing, and so much
    more. There are indeed alternatives to Grunt, but none with as large an ecosystem
    of plugins (at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two components to Grunt: the *Grunt CLI*, and the *Grunt task runner*
    itself. The Grunt CLI allows you to run the Grunt task runner command from the
    command line within a directory that has Grunt installed. This allows you to have
    a different version of Grunt running for each project on your machine, making
    each app more maintainable. For more information, see [gruntjs.com](http://gruntjs.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Grunt CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will want to install the Grunt CLI globally, just as you did with Bower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the Grunt CLI is not the Grunt task runner. It simply makes the
    `grunt` command available to you from the command line. This distinction is important,
    because while the `grunt` command will be globally available from the command
    line, it will always look for a local installation in the directory from which
    you run it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Grunt task runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will install the Grunt task runner locally from the root of your app where
    your `package.json` file is located. Grunt is installed as a Node.js package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have Grunt installed locally, your `package.json` file should look
    like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You will notice a `devDependencies` object has been added to your `package.json`
    file, if it was not already there from a previous install.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Grunt installed locally, let's begin installing some plugins
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Grunt plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Grunt task plugins are Node.js packages, so they will be installed using
    NPM as well. There are thousands of Grunt plugins written by a multitude of authors,
    as Grunt is an open-source project. Every Node.js package for Grunt is prefixed
    with `grunt` in the name. The Grunt team, however, does maintain many plugins
    themselves. The officially maintained Grunt plugins are all prefixed with `grunt-contrib`,
    so this is how you can differentiate them if you wish to stick with only officially
    maintained Grunt plugins. To view and search all registered Grunt plugins, see
    gruntjs.com/plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you will be writing a JavaScript SPA, let''s begin by installing a JavaScript
    *linting* plugin for Grunt. Linting refers to running a program against your code
    to analyze it for errors and, in some cases, proper formatting. It is always a
    good idea to have a linting utility running to test your JavaScript code for valid
    syntax and formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the officially maintained Grunt plugin for `JSHint` and add
    it to the `devDependencies` object in your `package.json` file as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`JSHint` is a popular tool for detecting errors and potential problems in your
    JavaScript code. The Grunt plugin itself will allow you to automate that process
    so that you can easily check your code as you develop.'
  prefs: []
  type: TYPE_NORMAL
- en: Another invaluable Grunt plugin is `grunt-contrib-watch`. This plugin allows
    you to run a task which will automatically run other Grunt tasks when you add,
    delete, or edit files in your project that match a predefined set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the `grunt-contrib-watch plugin`, the `devDependencies` object
    in your `package.json` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a couple of Grunt plugins installed, let's begin writing some
    tasks for them. In order to do that, you will first need to create a local configuration
    file for Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Grunt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike NPM and Bower, Grunt does not provide an `init` command for initializing
    its configuration file. Instead, *scaffolding* tools can be used for this. Project
    scaffolding tools are designed to set up some basic directory structure and configuration
    files for a development project. Grunt maintains an official scaffolding tool
    called `grunt-init`, which is referenced on their website. The `grunt-init` tool
    must be installed separately from the `grunt-cli` global package and the local
    `grunt` package for any particular project. It is most useful if installed globally,
    so it can be used with any project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will not go into further detail on `grunt-init` here, but if you would like
    to learn more, you can visit [gruntjs.com/project-scaffolding](http://gruntjs.com/project-scaffolding).
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn about configuring Grunt is to write its configuration
    file by hand. The configuration for Grunt is maintained in a file called `Gruntfile.js`,
    referred to as a `Gruntfile`, located in the root directory of your project, along
    with `package.json` and `bower.json`. If you are not familiar with Node.js and
    its concept of modules and exports, the syntax for a `Gruntfile` may be a bit
    confusing at first. Since Node.js files run on the server and not in a browser,
    they do not interact in the same way that files loaded in a browser do, with respect
    to browser `globals`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Node.js modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Node.js, a module is a JavaScript object defined within a file. The module
    name is the name of the file. For instance, if you want to declare a module named
    `foo`, you will create a file named `foo.js`. In order for the `foo` module to
    be accessible to another module, it must be exported. In its most basic form,
    a module looks something like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Every module has a local `exports` variable that allows you to make the module
    accessible to others. In other words, the object `module` within a file refers
    to the current module itself, and the `exports` property of `module` makes that
    module available to any other module (or file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of defining a module is by exporting a function, which is of course
    a JavaScript object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When you call for a Node.js module from within a file, it will first look for
    a core module, all of which are compiled into Node.js itself. If the name does
    not match a core module, it will then look for a directory named `node_modules`
    beginning from the current or root directory of your project. This directory is
    where all of your local NPM packages, including Grunt plugins, will be stored.
    If you performed the installs of `grunt-contrib-jshint` and `grunt-contrib-watch`
    from earlier, you will see that this directory now exists within your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand a bit more about how Node.js modules work, let's create
    a `Gruntfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Gruntfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `Gruntfile` uses the function form of `module.exports` as shown previously.
    This is referred to as a *wrapper function*. The `grunt` module itself is passed
    to the wrapper function. The `grunt` module will be available to your `Gruntfile`
    because you installed the `grunt` NPM package locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example shows what your initial `Gruntfile` should look like. Now let's
    flesh it out some more. In order to configure Grunt and run tasks with it, you
    will need to access the `grunt` module that is passed in to your `Gruntfile`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This basic format is what you will be working with the rest of the way. You
    can see here that the `grunt.initConfig` method is called and passed a single
    configuration object as a parameter. This configuration object is where all of
    your Grunt task code will go. The `pkg` property shown in this example, which
    is assigned the value of `grunt.file.readJSON('package.json')`, allows you to
    pass in information about your project directly from your `package.json` file.
    The use of this property will be shown in later examples.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Grunt task configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most Grunt tasks expect their configuration to be defined within a property
    of the same name as the task, which is the suffix of the package name. For example,
    `jshint` is the Grunt task name for the `grunt-contrib-jshint` package we previously
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that the `jshint` property of the configuration object is defined
    and is assigned its own properties which apply to the `jshint` Grunt task itself.
    The `options` property defined within `jshint` holds the settings you wish to
    validate against when linting your JavaScript files. The `files` property defines
    a list of the files you wish to validate. For more information on the supported
    options for `JSHint` and what they mean, see jshint.com/docs/.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add an additional configuration for the `grunt-contrib-watch` plugin
    `watch` task below the `jshint` task configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we add an additional namespace of `jshint` underneath the `watch` task,
    which allows for other *targets* to be defined within the same configuration property
    and run separately if needs be. This is what is known as a *multitask*. Targets
    within a multitask can be named arbitrarily and will simply be run in the order
    which they are defined if the multitask is called alone. A target can be called
    directly as well, and doing so will ignore any of the other targets defined within
    the multitask''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This particular configuration for the target `jshint` tells the `watch` task
    that if any files matching `js/src/*.js` are changed, then to run the `jshint`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have your first two Grunt task configurations defined within your `Gruntfile`,
    but in order to use them, we must load the Grunt tasks themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Grunt plugins
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have already installed the `grunt-contrib-jshint` plugin as a Node.js module,
    but in order to execute the `jshint` task, you must load the plugin within your
    `Gruntfile`. This is done after the `grunt.initConfig` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same method call you will use to load all Grunt tasks within your
    `Gruntfile`, and any Grunt task will not be accessible without doing so. Let''s
    do the same for `grunt-contrib-watch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Your full `Gruntfile` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Running the jshint Grunt task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have the plugin loaded, you can simply run `grunt jshint` from
    the command line to execute the task with its defined configuration. You should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will run your `JSHint` linting options against the defined files, which
    as of now consist of only `Gruntfile.js`. If it looks like the example file shown
    and includes the call to `grunt.loadNpmTasks('grunt-contrib-jshint')`, then it
    should pass without errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new JavaScript file and intentionally include some code
    which will not pass the JSHint configuration so we can see how the errors are
    reported. First, create the `js/src` directory, which is defined in the `files`
    property of the `jshint` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a file named `app.js` within this directory and place the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run `grunt jshint` again from the command line. You should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that two errors are reported for `js/src/app.js` based on the
    `jshint` task configuration options. Let''s fix the errors by changing the code
    in `app.js` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run `grunt jshint` from the command line again, it will report that
    the files are lint free and have no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Running the watch Grunt task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier, when the `watch` task is run it will wait for changes
    that match the file patterns defined in its configuration and run any corresponding
    tasks. In this case, we configured it to run `jshint` when any files matching
    `js/src/*.js` are changed. Since we defined a target within the `watch` task called
    `jshint`, the `watch` task can be run in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `grunt watch` will watch for changes matching all target configurations
    defined within the `watch` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `grunt watch:jshint` with the colon (`:`) syntax runs `watch` for just
    the file patterns matching that target configuration. In our case, only one target
    is defined, so let''s just run `grunt watch` and see what happens in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the task now shows a status of `Waiting...` on the command
    line. This indicates that the task is running to watch for matching changes within
    its configuration, and if any of those changes are made, it will automatically
    run the corresponding tasks. In our example with the `jshint` task, it will allow
    your code to automatically be linted every time you make changes to your JavaScript
    files and save them. If a `JSHint` error occurs, the console will alert you and
    display the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this by opening a text editor and changing `js/src/app.js` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we removed the opening `use strict` statement and the semicolon after
    the call to `test()` at the end of the file. This should raise two `JSHint` errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s correct these errors and return the file to the way it was before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Press *Ctrl* + *C* from the command line at any time to abort the `watch` task,
    or any Grunt task, while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the default Grunt task
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grunt allows you to define a `default` task which will run when you simply
    type `grunt` on the command line with no parameters. To do this, you will use
    the `grunt.registerTask()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This example sets the default Grunt task to run the defined `jshint` task first
    and then the `watch:jshint` multitask target. You can see that the tasks passed
    to the `default` task are in an array, so you can set the `default` task for Grunt
    to run any number of tasks by simply typing `grunt` on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: From looking at the output, you can see that the `jshint` task was run once
    initially, and then `watch:jshint` was run to wait for additional changes to the
    configured file patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom tasks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Grunt allows you to define your own custom tasks, in the same way that you defined
    the default task. In this way, you can actually write your own custom tasks directly
    within the `Gruntfile`, or you can load them from an external file, just as you
    did with `grunt-contrib-jshint` and `grunt-contrib-watch`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alias tasks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of defining a custom task is to simply call one or more existing tasks
    in the order you want them to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have simply defined a task named `my-task` to serve as a
    proxy for `jshint`. The second parameter is an optional description of the task,
    which must be a string. The third parameter, which passes an array, including
    only `jshint` in this example, must always be an array. You can also forgo the
    second parameter with the description and pass in your array of tasks there instead.
    This way of defining a task is known as an *alias task*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic tasks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define custom Grunt tasks, you are not limited to only calling other
    tasks that exist within your configuration, but you can write JavaScript code
    to be called directly as a function. This is called a *basic task*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we simply write a string to the command line output for the
    task. The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s expand upon this example and pass in some arguments to our basic task
    function, as well as access the arguments from within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that there is a property available to the basic task, `this.name`,
    which is simply a reference to the name of the task. In order to call a basic
    task from the command line and pass arguments in, you will use a colon after the
    task name to define each argument in succession. This syntax is just like the
    syntax for running a multitask target; however, in this case you are passing in
    arbitrary arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not pass in the arguments to a task that is expecting them, it will
    simply resolve them as `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also call other tasks from within a custom task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a task, `foo`, that defines a custom function
    that calls the existing `jshint` and `watch` tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: For more information on creating custom tasks with Grunt, see gruntjs.com/creating-tasks.
  prefs: []
  type: TYPE_NORMAL
- en: These examples of tasks only scratch the surface of what is capable with Grunt,
    but you should be able to glean from them the power of it and begin to think about
    what might be possible with Grunt tasks when building your own SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned to set up an optimal development environment with
    NPM, supply it with frontend dependencies using Bower, and automate development
    tasks using Grunt, it's time to start learning more about building a real app.
    In the next chapter, we will dive into common SPA architecture design patterns,
    what they mean, and what is the best design pattern to choose based on the type
    of SPA you are building.
  prefs: []
  type: TYPE_NORMAL
