- en: Chapter 1. Getting Organized with NPM, Bower, and Grunt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：使用NPM、Bower和Grunt进行组织
- en: JavaScript was the bane of the web development industry during the early days
    of the browser-rendered Internet. It now powers hugely impactful libraries such
    as jQuery, and JavaScript-rendered (as opposed to server-side-rendered) content
    is even indexed by many search engines. What was once largely considered an annoying
    language used primarily to generate pop-up windows and alert boxes, has now become
    arguably the most popular programming language in the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器渲染互联网的早期阶段，JavaScript一直是网络开发行业的噩梦。现在，它为像jQuery这样具有巨大影响力的库提供动力，并且JavaScript渲染的内容（与服务器端渲染的内容相对）甚至被许多搜索引擎索引。曾经被认为主要用来生成弹出窗口和警告框的令人烦恼的语言，现在可能已成为世界上最受欢迎的编程语言。
- en: Not only is JavaScript now more prevalent than ever in frontend architecture,
    but it has become a server-side language as well, thanks to the *Node.js* runtime.
    We have also seen the proliferation of document-oriented databases, such as MongoDB,
    which store and return JSON data. With JavaScript present throughout the development
    stack, the door is now open for JavaScript developers to become full-stack developers
    without the need to learn a traditional server-side language. Given the right
    tools and know-how, any JavaScript developer can create *single page applications*
    comprised entirely of the language they know best, and they can do so using an
    architecture like *MEAN* (MongoDB, Express, AngularJS, and Node.js).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅JavaScript现在在前端架构中比以往任何时候都更普遍，而且得益于*Node.js*运行时，它也已成为一种服务器端语言。我们还看到了文档型数据库的激增，例如MongoDB，这些数据库存储并返回JSON数据。由于JavaScript贯穿整个开发栈，JavaScript开发者现在可以成为全栈开发者，而无需学习传统的服务器端语言。有了合适的工具和知识，任何JavaScript开发者都可以创建完全由他们最擅长的语言组成的*单页应用程序*，并且可以使用像*MEAN*（MongoDB、Express、AngularJS和Node.js）这样的架构来实现。
- en: Organization is key to the development of any complex **Single Page Application**
    (**SPA**). If you don't get organized from the beginning, you are sure to introduce
    an inordinate number of regressions to your app. The Node.js ecosystem will help
    you to do this with a full suite of indispensable and open-source tools, three
    of which we will discuss here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 组织对于任何复杂**单页应用程序**（**SPA**）的开发至关重要。如果您从一开始就没有组织起来，您肯定会向您的应用程序引入大量的回归。Node.js生态系统将帮助您使用一套不可或缺的开源工具来实现这一点，其中我们将讨论三个。
- en: 'In this chapter, you will learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解：
- en: '**Node Package Manager** (**NPM**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node包管理器**（**NPM**）'
- en: Bower frontend package manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bower前端包管理器
- en: '**Grunt** JavaScript task runner'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grunt** JavaScript任务运行器'
- en: How these three tools can be used together to create an organized development
    environment that is ideal for creating an SPA and is essential to the MEAN stack
    architecture.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用这三个工具共同创建一个有组织的开发环境，这对于创建SPA和MEAN堆栈架构至关重要。
- en: What is Node Package Manager?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Node包管理器？
- en: Within any full-stack JavaScript environment, **Node Package Manager** will
    be your *go-to* tool for setting up your development environment and for managing
    server-side libraries. NPM can be used within both global and isolated environment
    contexts. We will first explore the use of NPM globally.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何全栈JavaScript环境中，**Node包管理器**将是您设置开发环境和管理服务器端库的*首选*工具。NPM可以在全局和隔离环境上下文中使用。我们将首先探讨NPM的全局使用。
- en: Installing Node.js and NPM
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js和NPM
- en: 'NPM is a component of *Node.js*, so before you can use it you must first install
    Node.js. You can find installers for both Mac and Windows at nodejs.org. Once
    you have Node.js installed, using NPM is incredibly easy and is done from the
    **Command Line Interface** (**CLI**). Start by ensuring you have the latest version
    of NPM installed, as it is updated more often than Node.js itself:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NPM是*Node.js*的一个组件，因此在使用它之前，您必须首先安装Node.js。您可以在nodejs.org上找到Mac和Windows的安装程序。一旦安装了Node.js，使用NPM就非常简单，并且通过**命令行界面**（**CLI**）完成。首先确保您安装了最新版本的NPM，因为它比Node.js本身更新得更频繁：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When using NPM, the `-g` option will apply your changes to your global environment.
    In this case, you want your version of NPM to apply globally. As stated previously,
    NPM can be used to manage packages both globally and within isolated environments.
    In the following, we want essential development tools to be applied globally so
    that you can use them in multiple projects on the same system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用NPM时，`-g`选项将您的更改应用于全局环境。在这种情况下，您希望您的NPM版本应用于全局。如前所述，NPM可以用于全局和隔离环境中的包管理。在下面的例子中，我们希望将基本开发工具应用于全局，这样您就可以在同一系统上的多个项目中使用它们。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: With Mac and some Unix-based systems, you may have to run the `npm` command
    as the superuser (prefix the command with `sudo`) in order to install packages
    globally, depending on how NPM was installed. If you run into this issue and wish
    to remove the need to prefix `npm` with `sudo`, see [docs.npmjs.com/getting-started/fixing-npm-permissions](http://docs.npmjs.com/getting-started/fixing-npm-permissions).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac和一些基于Unix的系统上，您可能需要以超级用户身份运行`npm`命令（在命令前加上`sudo`）来全局安装包，这取决于NPM是如何安装的。如果您遇到这个问题并且希望不再需要在`npm`前加上`sudo`，请参阅[docs.npmjs.com/getting-started/fixing-npm-permissions](http://docs.npmjs.com/getting-started/fixing-npm-permissions)。
- en: Configuring your package.json file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置您的`package.json`文件
- en: For any project you develop, you will keep a local `package.json` file to manage
    your Node.js dependencies. This file should be stored at the root of your project
    directory and it will only pertain to that isolated environment. This allows you
    to have multiple Node.js projects with different dependency chains on the same
    system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您开发的任何项目，您将保留一个本地的`package.json`文件来管理您的Node.js依赖项。此文件应存储在项目目录的根目录中，并且它仅适用于该隔离环境。这允许您在同一系统上拥有多个具有不同依赖链的Node.js项目。
- en: 'When beginning a new project, you can automate the creation of the `package.json`
    file from the command line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新的项目时，您可以从命令行自动创建`package.json`文件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running `npm init` will take you through a series of JSON property names to
    define through command line prompts, including your app''s `name`, `version` number,
    `description`, and more. The `name` and `version` properties are required, and
    your Node.js package will not install without them defined. Several of the properties
    will have a default value given within parentheses in the prompt so that you may
    simply hit *Enter* to continue. Other properties will simply allow you to hit
    *Enter* with a blank entry and will not be saved to the `package.json` file, or
    will be saved with a blank value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm init`将引导您通过一系列JSON属性名称，通过命令行提示来定义，包括您的应用程序的`name`、`version`版本号、`description`描述等。`name`和`version`属性是必需的，并且如果没有定义它们，您的Node.js包将无法安装。在提示中，一些属性将给出括号内的默认值，这样您只需按*Enter*键即可继续。其他属性将允许您按*Enter*键并留空条目，这些条目将不会保存到`package.json`文件中，或者将保存为空值：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `entry point` prompt will be defined as the `main` property in `package.json`
    and is not necessary unless you are developing a Node.js application. In our case,
    we can forgo this field. The `npm init` command may in fact force you to save
    the `main` property, so you will have to edit `package.json` afterward to remove
    it; however, that field will have no effect on your web app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry point`提示将被定义为`package.json`中的`main`属性，除非您正在开发Node.js应用程序，否则这不是必需的。在我们的例子中，我们可以省略这个字段。实际上，`npm
    init`命令可能强制您保存`main`属性，因此您必须在之后编辑`package.json`来删除它；然而，该字段对您的Web应用程序没有任何影响。'
- en: 'You may also choose to create the `package.json` file manually using a text
    editor, if you know the appropriate structure to employ. Whichever method you
    choose, your initial version of the `package.json` file should look similar to
    the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道要使用的适当结构，您也可以选择使用文本编辑器手动创建`package.json`文件。无论您选择哪种方法，您的`package.json`文件的初始版本应类似于以下示例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want your project to be private and want to ensure that it does not
    accidently get published to the NPM registry, you may want to add the `private`
    property to your `package.json` file, and set it to `true`. Additionally, you
    may remove some properties that only apply to a registered package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的项目是私有的，并确保它不会意外地发布到NPM注册表，您可能希望将`private`属性添加到您的`package.json`文件中，并将其设置为`true`。此外，您还可以删除仅适用于已注册包的一些属性：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have your `package.json` file set up the way you like it, you can begin
    installing Node.js packages locally for your app. This is where the importance
    of dependencies begins to surface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `package.json` 文件设置成你喜欢的样子，你就可以开始为你的应用程序本地安装 Node.js 包了。这就是依赖的重要性开始显现的地方。
- en: NPM dependencies
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPM 依赖
- en: 'There are three types of dependencies that can be defined for any Node.js project
    in your `package.json` file: `dependencies`, `devDependencies`, and `peerDependencies`.
    For the purpose of building a web-based SPA, you will only need to use the `devDependencies`
    declaration.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `package.json` 文件中，可以为任何 Node.js 项目定义三种类型的依赖：`dependencies`、`devDependencies`
    和 `peerDependencies`。为了构建基于 Web 的 SPA，你将只需要使用 `devDependencies` 声明。
- en: '`devDependencies` are those which are required for developing your application,
    but not required for its production environment or for simply running it. If other
    developers want to contribute to your Node.js application, they will need to run
    `npm install` from the command line to set up the proper development environment.
    For information on the other types of dependencies, see docs.npmjs.com.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`devDependencies` 是那些在开发你的应用程序时所需的，但不是在它的生产环境或仅仅运行它时所需的。如果其他开发者想为你的 Node.js
    应用程序做出贡献，他们需要从命令行运行 `npm install` 来设置适当的发展环境。有关其他类型依赖的信息，请参阅 docs.npmjs.com。'
- en: 'When adding `devDependencies` to your `package.json file`, the command line
    again comes to the rescue. Let''s use the installation of Browserify as an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `devDependencies` 添加到你的 `package.json` 文件时，命令行再次发挥作用。让我们以安装 Browserify 为例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will install Browserify locally and save it along with its version range
    to the `devDependencies` object in your `package.json` file. Once installed, your
    `package.json` file should look similar to the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地安装 Browserify 并将其及其版本范围保存到你的 `package.json` 文件中的 `devDependencies` 对象中。一旦安装，你的
    `package.json` 文件应该类似于以下示例：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `devDependencies` object will store each package as a key-value pair in
    which the key is the *package name* and the value is the *version number* or *version
    range*. Node.js uses semantic versioning, where the three digits of the version
    number represent `MAJOR.MINOR.PATCH`. For more information on semantic version
    formatting, see [semver.org](http://semver.org).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`devDependencies` 对象将把每个包存储为一个键值对，其中键是 *包名*，值是 *版本号* 或 *版本范围*。Node.js 使用语义版本，其中版本号的三个数字代表
    `MAJOR.MINOR.PATCH`。有关语义版本格式化的更多信息，请参阅 [semver.org](http://semver.org)。'
- en: Updating your development dependencies
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新你的开发依赖
- en: You will notice that the version number of the installed package is preceded
    by a **caret** (`^`) symbol by default. This means that package updates will only
    allow *patch* and *minor* updates for versions above 1.0.0\. This is meant to
    prevent major version changes from breaking your dependency chain when updating
    your packages to the latest versions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到默认情况下安装的包的版本号前面有一个 ** caret ** (`^`) 符号。这意味着对于版本号高于 1.0.0 的包，更新只会允许 * patch
    * 和 * minor * 更新。这是为了防止在更新包到最新版本时，主要版本的变化破坏你的依赖链。
- en: 'To update your `devDependencies` and save the new version numbers, you can
    enter the following from the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新你的 `devDependencies` 并保存新的版本号，你可以在命令行中输入以下内容：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `-D` 选项作为 `--save-dev` 的快捷方式：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To update all globally installed NPM packages to their latest versions, run
    `npm update` with the `-g` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新所有全局安装的 NPM 包到它们的最新版本，运行带有 `-g` 选项的 `npm update`：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information on semantic versioning within NPM, see [docs.npmjs.com/misc/semver](http://docs.npmjs.com/misc/semver).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 NPM 中的语义版本信息的更多信息，请参阅 [docs.npmjs.com/misc/semver](http://docs.npmjs.com/misc/semver)。
- en: Now that you have NPM set up and you know how to install your development dependencies,
    you can move on to installing Bower.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了 NPM 并知道如何安装你的开发依赖，你可以继续安装 Bower。
- en: Bower
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bower
- en: Bower is a package manager for frontend web assets and libraries. You will use
    it to maintain your frontend stack and control version chains for libraries such
    as jQuery, AngularJS, and any other components necessary to your app's web interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 是一个用于前端 Web 资产和库的包管理器。你将使用它来维护你的前端堆栈并控制库如 jQuery、AngularJS 以及任何其他对你应用程序
    Web 界面必要的组件的版本链。
- en: Installing Bower
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Bower
- en: 'Bower is also a Node.js package, so you will install it using NPM, much like
    you did with the Browserify example installation in the previous section, but
    this time you will be installing the package globally. This will allow you to
    run `bower` from the command line anywhere on your system without having to install
    it locally for each project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 也是一个 Node.js 包，所以你将使用 NPM 安装它，就像你在上一节中安装 Browserify 示例时做的那样，但这次你将全局安装该包。这将允许你在系统上的任何位置运行
    `bower` 命令，而无需为每个项目本地安装它：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can alternatively install Bower locally as a development dependency so
    that you may maintain different versions of it for different projects on the same
    system, but this is generally not necessary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Bower 作为开发依赖项本地安装，这样你就可以在同一系统上为不同的项目维护不同的版本，但这通常不是必要的：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, check that Bower is properly installed by querying the version from the
    command line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过命令行查询版本来检查 Bower 是否已正确安装：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bower also requires a *Git* version control system, or *VCS*, to be installed
    on your system in order to work with packages. This is because Bower communicates
    directly with GitHub for package management data. If you do not have Git installed
    on your system, you can find instructions for Linux, Mac, and Windows at [git-scm.com](http://git-scm.com).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 还需要在你的系统上安装一个 *Git* 版本控制系统，或 *VCS*，以便与包进行交互。这是因为 Bower 直接与 GitHub 通信以获取包管理数据。如果你系统上没有安装
    Git，你可以在 [git-scm.com](http://git-scm.com) 找到 Linux、Mac 和 Windows 的安装说明。
- en: Configuring your bower.json file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置你的 bower.json 文件
- en: 'The process of setting up your `bower.json` file is comparable to that of the
    `package.json` file for NPM. It uses the same JSON format, has both `dependencies`
    and `devDependencies`, and can also be automatically created:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的 `bower.json` 文件的过程与 NPM 的 `package.json` 文件类似。它使用相同的 JSON 格式，既有 `dependencies`
    也有 `devDependencies`，并且也可以自动创建：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you type `bower init` from the command line, you will be prompted to define
    several properties with some defaults given within parentheses:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在命令行中输入 `bower init`，你将被提示定义几个属性，其中一些默认值在括号内给出：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: These questions may vary, depending on the version of Bower you install.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能因你安装的 Bower 版本而异。
- en: Most properties in the `bower.json` file are not necessary unless you are publishing
    your project to the Bower registry, indicated in the final prompt. You will most
    likely want to mark your package as private, unless you plan to register it and
    allow others to download it as a Bower package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bower.json` 文件中，大多数属性在你不打算将你的项目发布到 Bower 注册表的情况下是不必要的。你很可能会想将你的包标记为私有，除非你计划注册它并允许其他人将其作为
    Bower 包下载。
- en: 'Once you have created the `bower.json` file, you can open it in a text editor
    and change or remove any properties you wish. It should look something like the
    following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了 `bower.json` 文件，你可以在文本编辑器中打开它，更改或删除你想要的任何属性。它应该看起来像以下示例：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you wish to keep your project private, you can reduce your `bower.json`
    file to two properties before continuing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保持你的项目私有，你可以在继续之前将你的 `bower.json` 文件减少到两个属性：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you have the initial version of your `bower.json` file set up the way you
    like it, you can begin installing components for your app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你以你喜欢的样子设置了 `bower.json` 文件的初始版本，你就可以开始为你的应用程序安装组件。
- en: Bower components location and the .bowerrc file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bower 组件位置和 .bowerrc 文件
- en: 'Bower will install components into a directory named `bower_components` by
    default. This directory will be located directly under the root of your project.
    If you wish to install your Bower components under a different directory name,
    you must create a local system file named `.bowerrc` and define the custom directory
    name there:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 默认会将组件安装到名为 `bower_components` 的目录中。这个目录将直接位于你的项目根目录下。如果你希望将你的 Bower 组件安装到不同的目录名下，你必须创建一个名为
    `.bowerrc` 的本地系统文件，并在其中定义自定义目录名：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An object with only a single `directory` property name is all that is necessary
    to define a custom location for your Bower components. There are many other properties
    that can be configured within a `.bowerrc` file. For more information on configuring
    Bower, see bower.io/docs/config/.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一个具有单个 `directory` 属性名的对象，就可以定义你的 Bower 组件的自定义位置。在 `.bowerrc` 文件中可以配置许多其他属性。有关配置
    Bower 的更多信息，请参阅 bower.io/docs/config/。
- en: Bower dependencies
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bower 依赖项
- en: Bower also allows you to define both the `dependencies` and `devDependencies`
    objects like NPM. The distinction with Bower, however, is that the `dependencies`
    object will contain the components necessary for running your app, while the `devDependencies`
    object is reserved for components that you might use for testing, transpiling,
    or anything that does not need to be included in your frontend stack.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 允许您定义与 NPM 类似的 `dependencies` 和 `devDependencies` 对象。然而，与 Bower 的区别在于，`dependencies`
    对象将包含运行您的应用程序所需的组件，而 `devDependencies` 对象则保留用于测试、转译或其他不需要包含在前端堆栈中的组件。
- en: 'Bower packages are managed using the `bower` command from the CLI. This is
    a user command, so it does not require super user (sudo) permissions. Let''s begin
    by installing jQuery as a frontend dependency for your app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Bower 包使用 CLI 中的 `bower` 命令进行管理。这是一个用户命令，因此不需要超级用户（sudo）权限。让我们从将 jQuery 作为应用程序的前端依赖项安装开始：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `--save` option on the command line will save the package and version number
    to the `dependencies` object in `bower.json`. Alternatively, you can use the `-S`
    option as a shortcut for `--save`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上的 `--save` 选项会将包和版本号保存到 `bower.json` 文件中的 `dependencies` 对象中。或者，您可以使用 `-S`
    选项作为 `--save` 的快捷方式：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s install the Mocha JavaScript testing framework as a development
    dependency:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装 Mocha JavaScript 测试框架作为开发依赖项：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, we will use `--save-dev` on the command line to save the package
    to the `devDependencies` object instead. Your `bower.json` file should now look
    similar to the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用命令行上的 `--save-dev` 来将包保存到 `devDependencies` 对象中。现在，您的 `bower.json`
    文件应该类似于以下示例：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `-D` 选项作为 `--save-dev` 的快捷方式：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice that the package version numbers are preceded by the **tilde**
    (`~`) symbol by default, in contrast to the caret (`^`) symbol as is the case
    with NPM. The tilde serves as a more stringent guard against package version updates.
    With a `MAJOR.MINOR.PATCH` version number, running `bower update` will only update
    to the latest patch version. If a version number is composed of only the major
    and minor versions, `bower update` will update the package to the latest minor
    version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，默认情况下，包版本号前面带有波浪线符号 (`~`)，这与 NPM 中的 caret (`^`) 符号不同。波浪线作为对包版本更新的更严格的保护。使用
    `MAJOR.MINOR.PATCH` 版本号，运行 `bower update` 只会更新到最新的补丁版本。如果版本号仅由主版本和次要版本组成，`bower
    update` 将将包更新到最新的次要版本。
- en: Searching the Bower registry
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索 Bower 注册表
- en: All registered Bower components are indexed and searchable through the command
    line. If you don't know the exact package name of a component you wish to install,
    you can perform a search to retrieve a list of matching names.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有注册的 Bower 组件都通过命令行索引和可搜索。如果您不知道要安装的组件的确切包名，可以执行搜索以检索匹配名称的列表。
- en: 'Most components will have a list of keywords in their `bower.json` file so
    that you can more easily find the package without knowing the exact name. For
    example, you may want to install PhantomJS for headless browser testing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件在其 `bower.json` 文件中都会有一个关键词列表，这样您就可以更容易地找到包，而无需知道确切的名称。例如，您可能想安装 PhantomJS
    用于无头浏览器测试：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The list returned will include any package with `phantomjs` in the package
    name or within its keywords list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的列表将包括任何包名中包含 `phantomjs` 或在其关键词列表中的包：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can see from the returned list that the correct package name for PhantomJS
    is in fact `phantom` and not `phantomjs`. You can then proceed to install the
    package now that you know the correct name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从返回的列表中看到，PhantomJS 的正确包名实际上是 `phantom`，而不是 `phantomjs`。现在您知道了正确的名称，可以继续安装包：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now you have Bower installed and know how to manage your frontend web components
    and development tools, but how do you integrate them into your SPA? This is where
    Grunt comes in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了 Bower 并了解了如何管理您的前端 Web 组件和开发工具，但如何将它们集成到您的 SPA 中呢？这正是 Grunt 发挥作用的地方。
- en: Grunt
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grunt
- en: Grunt is a *JavaScript task runner* for Node.js, and if you haven't used it
    before, it is perhaps the best tool you never knew you needed. You will find it
    useful for a myriad of tasks including CSS and JavaScript linting and minification,
    JavaScript template pre-compilation, LESS and SASS pre-processing, and so much
    more. There are indeed alternatives to Grunt, but none with as large an ecosystem
    of plugins (at the time of writing).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 是 Node.js 的 *JavaScript 任务运行器*，如果你之前没有使用过它，那么它可能是你从未意识到需要的最佳工具。你会发现它在包括
    CSS 和 JavaScript 代码检查和压缩、JavaScript 模板预编译、LESS 和 SASS 预处理等众多任务中非常有用。确实有 Grunt
    的替代品，但它们都没有像 Grunt 那样庞大的插件生态系统（截至撰写本文时）。
- en: 'There are two components to Grunt: the *Grunt CLI*, and the *Grunt task runner*
    itself. The Grunt CLI allows you to run the Grunt task runner command from the
    command line within a directory that has Grunt installed. This allows you to have
    a different version of Grunt running for each project on your machine, making
    each app more maintainable. For more information, see [gruntjs.com](http://gruntjs.com).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 有两个组件：*Grunt CLI* 和 *Grunt 任务运行器* 本身。Grunt CLI 允许你在安装了 Grunt 的目录中从命令行运行
    Grunt 任务运行器命令。这使得你可以在机器上的每个项目中运行不同版本的 Grunt，从而使每个应用程序更容易维护。有关更多信息，请参阅 [gruntjs.com](http://gruntjs.com)。
- en: Installing the Grunt CLI
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Grunt CLI
- en: 'You will want to install the Grunt CLI globally, just as you did with Bower:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你将想要全局安装 Grunt CLI，就像你安装 Bower 一样：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that the Grunt CLI is not the Grunt task runner. It simply makes the
    `grunt` command available to you from the command line. This distinction is important,
    because while the `grunt` command will be globally available from the command
    line, it will always look for a local installation in the directory from which
    you run it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Grunt CLI 并非 Grunt 任务运行器。它只是将 `grunt` 命令从命令行提供给你。这种区别很重要，因为虽然 `grunt` 命令将在命令行中全局可用，但它始终会在你运行它的目录中寻找本地安装。
- en: Installing the Grunt task runner
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Grunt 任务运行器
- en: 'You will install the Grunt task runner locally from the root of your app where
    your `package.json` file is located. Grunt is installed as a Node.js package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从应用程序根目录（其中包含你的 `package.json` 文件）安装 Grunt 任务运行器本地版本。Grunt 作为 Node.js 包安装：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you have Grunt installed locally, your `package.json` file should look
    like the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在本地安装了 Grunt，你的 `package.json` 文件应该看起来像以下示例：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will notice a `devDependencies` object has been added to your `package.json`
    file, if it was not already there from a previous install.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，如果之前没有安装，你的 `package.json` 文件中已经添加了一个 `devDependencies` 对象。
- en: Now that you have Grunt installed locally, let's begin installing some plugins
    to work with.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在本地上安装了 Grunt，让我们开始安装一些插件来与之配合使用。
- en: Installing Grunt plugins
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Grunt 插件
- en: All Grunt task plugins are Node.js packages, so they will be installed using
    NPM as well. There are thousands of Grunt plugins written by a multitude of authors,
    as Grunt is an open-source project. Every Node.js package for Grunt is prefixed
    with `grunt` in the name. The Grunt team, however, does maintain many plugins
    themselves. The officially maintained Grunt plugins are all prefixed with `grunt-contrib`,
    so this is how you can differentiate them if you wish to stick with only officially
    maintained Grunt plugins. To view and search all registered Grunt plugins, see
    gruntjs.com/plugins.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Grunt 任务插件都是 Node.js 包，因此它们也将使用 NPM 进行安装。由于 Grunt 是一个开源项目，因此有成千上万的 Grunt
    插件由众多作者编写。每个 Grunt 的 Node.js 包名称都以 `grunt` 开头。然而，Grunt 团队也维护了许多插件。官方维护的 Grunt
    插件都以 `grunt-contrib` 开头，因此如果你只想使用官方维护的 Grunt 插件，你可以通过这种方式来区分它们。要查看和搜索所有注册的 Grunt
    插件，请参阅 gruntjs.com/plugins。
- en: 'Since you will be writing a JavaScript SPA, let''s begin by installing a JavaScript
    *linting* plugin for Grunt. Linting refers to running a program against your code
    to analyze it for errors and, in some cases, proper formatting. It is always a
    good idea to have a linting utility running to test your JavaScript code for valid
    syntax and formatting:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将编写一个 JavaScript SPA，让我们首先安装一个用于 Grunt 的 JavaScript *代码检查* 插件。代码检查是指运行一个程序来分析你的代码，以查找错误，在某些情况下，还可以检查格式。始终运行代码检查工具来测试你的
    JavaScript 代码的有效语法和格式是一个好主意：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will install the officially maintained Grunt plugin for `JSHint` and add
    it to the `devDependencies` object in your `package.json` file as shown in the
    following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装官方维护的 `JSHint` Grunt 插件，并将其添加到 `package.json` 文件中的 `devDependencies` 对象中，如下所示示例：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`JSHint` is a popular tool for detecting errors and potential problems in your
    JavaScript code. The Grunt plugin itself will allow you to automate that process
    so that you can easily check your code as you develop.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSHint`是一个流行的工具，用于检测JavaScript代码中的错误和潜在问题。Grunt插件本身将允许你自动化此过程，这样你就可以在开发过程中轻松检查你的代码。'
- en: Another invaluable Grunt plugin is `grunt-contrib-watch`. This plugin allows
    you to run a task which will automatically run other Grunt tasks when you add,
    delete, or edit files in your project that match a predefined set of rules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有价值的Grunt插件是`grunt-contrib-watch`。此插件允许你运行一个任务，当你在项目中添加、删除或编辑与预定义规则匹配的文件时，它会自动运行其他Grunt任务。
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After installing the `grunt-contrib-watch plugin`, the `devDependencies` object
    in your `package.json` file should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`grunt-contrib-watch`插件后，你的`package.json`文件中的`devDependencies`对象应如下所示：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that you have a couple of Grunt plugins installed, let's begin writing some
    tasks for them. In order to do that, you will first need to create a local configuration
    file for Grunt.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了一些Grunt插件，让我们开始为它们编写一些任务。为了做到这一点，你首先需要为Grunt创建一个本地配置文件。
- en: Configuring Grunt
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Grunt
- en: Unlike NPM and Bower, Grunt does not provide an `init` command for initializing
    its configuration file. Instead, *scaffolding* tools can be used for this. Project
    scaffolding tools are designed to set up some basic directory structure and configuration
    files for a development project. Grunt maintains an official scaffolding tool
    called `grunt-init`, which is referenced on their website. The `grunt-init` tool
    must be installed separately from the `grunt-cli` global package and the local
    `grunt` package for any particular project. It is most useful if installed globally,
    so it can be used with any project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与NPM和Bower不同，Grunt不提供用于初始化其配置文件的`init`命令。相反，可以使用*脚手架*工具来完成这项工作。项目脚手架工具旨在为开发项目设置一些基本的目录结构和配置文件。Grunt维护一个官方的脚手架工具，称为`grunt-init`，该工具在他们的网站上有所提及。`grunt-init`工具必须与`grunt-cli`全局包和特定项目的本地`grunt`包分开安装。如果全局安装，它将非常有用，因为这样就可以与任何项目一起使用。
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will not go into further detail on `grunt-init` here, but if you would like
    to learn more, you can visit [gruntjs.com/project-scaffolding](http://gruntjs.com/project-scaffolding).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会进一步详细介绍`grunt-init`，但如果你想了解更多，可以访问[gruntjs.com/project-scaffolding](http://gruntjs.com/project-scaffolding)。
- en: The best way to learn about configuring Grunt is to write its configuration
    file by hand. The configuration for Grunt is maintained in a file called `Gruntfile.js`,
    referred to as a `Gruntfile`, located in the root directory of your project, along
    with `package.json` and `bower.json`. If you are not familiar with Node.js and
    its concept of modules and exports, the syntax for a `Gruntfile` may be a bit
    confusing at first. Since Node.js files run on the server and not in a browser,
    they do not interact in the same way that files loaded in a browser do, with respect
    to browser `globals`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Grunt配置的最佳方式是手动编写其配置文件。Grunt的配置保存在一个名为`Gruntfile.js`的文件中，称为`Gruntfile`，位于项目的根目录中，与`package.json`和`bower.json`一起。如果你不熟悉Node.js及其模块和导出概念，`Gruntfile`的语法可能一开始会有些令人困惑。由于Node.js文件在服务器上运行，而不是在浏览器中，因此它们与浏览器中加载的文件在交互方式上并不相同，这与浏览器的`globals`有关。
- en: Understanding Node.js modules
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Node.js模块
- en: 'In Node.js, a module is a JavaScript object defined within a file. The module
    name is the name of the file. For instance, if you want to declare a module named
    `foo`, you will create a file named `foo.js`. In order for the `foo` module to
    be accessible to another module, it must be exported. In its most basic form,
    a module looks something like the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，模块是一个定义在文件内的JavaScript对象。模块名称是文件名。例如，如果你想声明一个名为`foo`的模块，你需要创建一个名为`foo.js`的文件。为了使`foo`模块能够被另一个模块访问，它必须被导出。在最基本的形式下，一个模块看起来像以下示例：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Every module has a local `exports` variable that allows you to make the module
    accessible to others. In other words, the object `module` within a file refers
    to the current module itself, and the `exports` property of `module` makes that
    module available to any other module (or file).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个本地的`exports`变量，它允许你使模块对他人可用。换句话说，文件内的`module`对象指的是当前模块本身，而`module`的`exports`属性使该模块对任何其他模块（或文件）可用。
- en: 'Another way of defining a module is by exporting a function, which is of course
    a JavaScript object itself:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模块的另一种方式是通过导出一个函数，这当然本身也是一个JavaScript对象：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you call for a Node.js module from within a file, it will first look for
    a core module, all of which are compiled into Node.js itself. If the name does
    not match a core module, it will then look for a directory named `node_modules`
    beginning from the current or root directory of your project. This directory is
    where all of your local NPM packages, including Grunt plugins, will be stored.
    If you performed the installs of `grunt-contrib-jshint` and `grunt-contrib-watch`
    from earlier, you will see that this directory now exists within your project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在文件内部调用 Node.js 模块时，它首先会寻找一个核心模块，所有这些模块都是编译到 Node.js 本身中的。如果名称不匹配核心模块，它将会从你的项目的当前目录或根目录开始寻找名为
    `node_modules` 的目录。这个目录就是所有你的本地 NPM 包，包括 Grunt 插件，将被存储的地方。如果你之前执行了 `grunt-contrib-jshint`
    和 `grunt-contrib-watch` 的安装，你将看到这个目录现在存在于你的项目中。
- en: Now that you understand a bit more about how Node.js modules work, let's create
    a `Gruntfile`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Node.js 模块的工作方式有了更多的了解，让我们创建一个 `Gruntfile`。
- en: Creating a Gruntfile
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 Gruntfile
- en: 'A `Gruntfile` uses the function form of `module.exports` as shown previously.
    This is referred to as a *wrapper function*. The `grunt` module itself is passed
    to the wrapper function. The `grunt` module will be available to your `Gruntfile`
    because you installed the `grunt` NPM package locally:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gruntfile` 使用了之前展示的函数形式的 `module.exports`。这被称为 *包装函数*。`grunt` 模块本身被传递给包装函数。`grunt`
    模块将可用于你的 `Gruntfile`，因为你已经在本地上安装了 `grunt` NPM 包：'
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example shows what your initial `Gruntfile` should look like. Now let's
    flesh it out some more. In order to configure Grunt and run tasks with it, you
    will need to access the `grunt` module that is passed in to your `Gruntfile`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了你的初始 `Gruntfile` 应该是什么样子。现在让我们进一步展开它。为了配置 Grunt 并使用它运行任务，你需要访问传递给 `Gruntfile`
    的 `grunt` 模块。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This basic format is what you will be working with the rest of the way. You
    can see here that the `grunt.initConfig` method is called and passed a single
    configuration object as a parameter. This configuration object is where all of
    your Grunt task code will go. The `pkg` property shown in this example, which
    is assigned the value of `grunt.file.readJSON('package.json')`, allows you to
    pass in information about your project directly from your `package.json` file.
    The use of this property will be shown in later examples.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本格式是你接下来将要使用的方式。你可以看到这里调用了 `grunt.initConfig` 方法，并传递了一个配置对象作为参数。这个配置对象就是所有你的
    Grunt 任务代码将要放置的地方。在这个例子中显示的 `pkg` 属性，它被分配了 `grunt.file.readJSON('package.json')`
    的值，允许你直接从你的 `package.json` 文件中传递关于你的项目的信息。这个属性的用法将在后面的例子中展示。
- en: Defining Grunt task configuration
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 Grunt 任务配置
- en: 'Most Grunt tasks expect their configuration to be defined within a property
    of the same name as the task, which is the suffix of the package name. For example,
    `jshint` is the Grunt task name for the `grunt-contrib-jshint` package we previously
    installed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Grunt 任务期望它们的配置定义在具有与任务相同名称的属性中，这是包名的后缀。例如，`jshint` 是我们之前安装的 `grunt-contrib-jshint`
    包的 Grunt 任务名称：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here you can see that the `jshint` property of the configuration object is defined
    and is assigned its own properties which apply to the `jshint` Grunt task itself.
    The `options` property defined within `jshint` holds the settings you wish to
    validate against when linting your JavaScript files. The `files` property defines
    a list of the files you wish to validate. For more information on the supported
    options for `JSHint` and what they mean, see jshint.com/docs/.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到配置对象的 `jshint` 属性被定义，并且被分配了自己的属性，这些属性适用于 `jshint` Grunt 任务本身。`jshint`
    中定义的 `options` 属性包含了你在检查 JavaScript 文件时希望验证的设置。`files` 属性定义了你希望验证的文件列表。有关 `JSHint`
    支持的选项及其含义的更多信息，请参阅 jshint.com/docs/。
- en: 'Let''s now add an additional configuration for the `grunt-contrib-watch` plugin
    `watch` task below the `jshint` task configuration:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 `jshint` 任务配置下方添加一个额外的配置，用于 `grunt-contrib-watch` 插件的 `watch` 任务：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here we add an additional namespace of `jshint` underneath the `watch` task,
    which allows for other *targets* to be defined within the same configuration property
    and run separately if needs be. This is what is known as a *multitask*. Targets
    within a multitask can be named arbitrarily and will simply be run in the order
    which they are defined if the multitask is called alone. A target can be called
    directly as well, and doing so will ignore any of the other targets defined within
    the multitask''s configuration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `watch` 任务下添加了一个额外的 `jshint` 命名空间，这允许在同一个配置属性中定义其他 *目标*，并在需要时单独运行。这被称为
    *多任务*。多任务中的目标可以任意命名，如果单独调用多任务，它们将按照定义的顺序运行。目标也可以直接调用，这样做将忽略多任务配置中定义的其他目标：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This particular configuration for the target `jshint` tells the `watch` task
    that if any files matching `js/src/*.js` are changed, then to run the `jshint`
    task.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 `jshint` 目标配置告诉 `watch` 任务，如果任何匹配 `js/src/*.js` 的文件被更改，则运行 `jshint` 任务。
- en: Now you have your first two Grunt task configurations defined within your `Gruntfile`,
    but in order to use them, we must load the Grunt tasks themselves.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在你的 `Gruntfile` 中定义了前两个 Grunt 任务配置，但为了使用它们，我们必须加载 Grunt 任务本身。
- en: Loading Grunt plugins
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载 Grunt 插件
- en: 'You have already installed the `grunt-contrib-jshint` plugin as a Node.js module,
    but in order to execute the `jshint` task, you must load the plugin within your
    `Gruntfile`. This is done after the `grunt.initConfig` call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将 `grunt-contrib-jshint` 插件作为 Node.js 模块安装了，但为了执行 `jshint` 任务，你必须在 `Gruntfile`
    中加载该插件。这是在 `grunt.initConfig` 调用之后完成的：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the same method call you will use to load all Grunt tasks within your
    `Gruntfile`, and any Grunt task will not be accessible without doing so. Let''s
    do the same for `grunt-contrib-watch`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在 `Gruntfile` 中加载所有 Grunt 任务的相同方法调用，并且如果不这样做，任何 Grunt 任务都将不可用。让我们为 `grunt-contrib-watch`
    也做同样的事情：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Your full `Gruntfile` should now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你的完整 `Gruntfile` 现在应该看起来像这样：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Running the jshint Grunt task
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行 jshint Grunt 任务
- en: 'Now that you have the plugin loaded, you can simply run `grunt jshint` from
    the command line to execute the task with its defined configuration. You should
    see the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经加载了插件，你可以简单地从命令行运行 `grunt jshint` 来执行带有其定义配置的任务。你应该会看到以下输出：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will run your `JSHint` linting options against the defined files, which
    as of now consist of only `Gruntfile.js`. If it looks like the example file shown
    and includes the call to `grunt.loadNpmTasks('grunt-contrib-jshint')`, then it
    should pass without errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行你的 `JSHint` 检查选项与定义的文件，目前只包括 `Gruntfile.js`。如果看起来像示例文件所示，并且包括对 `grunt.loadNpmTasks('grunt-contrib-jshint')`
    的调用，那么它应该没有错误通过。
- en: 'Now let''s create a new JavaScript file and intentionally include some code
    which will not pass the JSHint configuration so we can see how the errors are
    reported. First, create the `js/src` directory, which is defined in the `files`
    property of the `jshint` task:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的 JavaScript 文件，并故意包含一些不会通过 JSHint 配置的代码，这样我们就可以看到错误是如何报告的。首先，创建 `js/src`
    目录，该目录在 `jshint` 任务的 `files` 属性中定义：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then create a file named `app.js` within this directory and place the following
    code in it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在当前目录下创建一个名为 `app.js` 的文件，并将以下代码放入其中：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now run `grunt jshint` again from the command line. You should see the following
    output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次从命令行运行 `grunt jshint`。你应该会看到以下输出：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will notice that two errors are reported for `js/src/app.js` based on the
    `jshint` task configuration options. Let''s fix the errors by changing the code
    in `app.js` to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到根据 `jshint` 任务配置选项，`js/src/app.js` 报告了两个错误。让我们通过将 `app.js` 中的代码更改为以下内容来修复这些错误：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now if you run `grunt jshint` from the command line again, it will report that
    the files are lint free and have no errors:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次从命令行运行 `grunt jshint`，它将报告文件没有错误：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Running the watch Grunt task
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行 watch Grunt 任务
- en: 'As mentioned earlier, when the `watch` task is run it will wait for changes
    that match the file patterns defined in its configuration and run any corresponding
    tasks. In this case, we configured it to run `jshint` when any files matching
    `js/src/*.js` are changed. Since we defined a target within the `watch` task called
    `jshint`, the `watch` task can be run in two different ways:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当运行 `watch` 任务时，它将等待与配置中定义的文件模式匹配的更改，并运行任何相应的任务。在这种情况下，我们配置了当任何匹配 `js/src/*.js`
    的文件被更改时运行 `jshint`。由于我们在 `watch` 任务中定义了一个名为 `jshint` 的目标，因此 `watch` 任务可以以两种不同的方式运行：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running `grunt watch` will watch for changes matching all target configurations
    defined within the `watch` task:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `grunt watch` 将监视 `watch` 任务中定义的所有目标配置的变化：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running `grunt watch:jshint` with the colon (`:`) syntax runs `watch` for just
    the file patterns matching that target configuration. In our case, only one target
    is defined, so let''s just run `grunt watch` and see what happens in the console:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用冒号 (`:`) 语法运行 `grunt watch:jshint` 将只运行与该目标配置匹配的文件模式。在我们的例子中，只定义了一个目标，所以让我们只运行
    `grunt watch` 并看看控制台会发生什么：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You will see that the task now shows a status of `Waiting...` on the command
    line. This indicates that the task is running to watch for matching changes within
    its configuration, and if any of those changes are made, it will automatically
    run the corresponding tasks. In our example with the `jshint` task, it will allow
    your code to automatically be linted every time you make changes to your JavaScript
    files and save them. If a `JSHint` error occurs, the console will alert you and
    display the error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到现在任务在命令行上显示为 `Waiting...` 的状态。这表明任务正在运行以监视其配置中的匹配更改，如果发生任何这些更改，它将自动运行相应的任务。在我们的
    `jshint` 任务例子中，它将允许你的代码在每次你更改并保存你的 JavaScript 文件时自动进行代码检查。如果发生 `JSHint` 错误，控制台将发出警报并显示错误。
- en: 'Let''s test this by opening a text editor and changing `js/src/app.js` again:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开一个文本编辑器并再次更改 `js/src/app.js` 来测试它：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we removed the opening `use strict` statement and the semicolon after
    the call to `test()` at the end of the file. This should raise two `JSHint` errors:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了文件末尾 `test()` 调用后的 `use strict` 语句和分号。这应该会引发两个 `JSHint` 错误：
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let''s correct these errors and return the file to the way it was before:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来纠正这些错误，并将文件恢复到之前的状态：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Press *Ctrl* + *C* from the command line at any time to abort the `watch` task,
    or any Grunt task, while it is running.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间从命令行按 *Ctrl* + *C* 可以中止正在运行的 `watch` 任务，或者任何 Grunt 任务。
- en: Defining the default Grunt task
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义默认的 Grunt 任务
- en: 'Grunt allows you to define a `default` task which will run when you simply
    type `grunt` on the command line with no parameters. To do this, you will use
    the `grunt.registerTask()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 允许你定义一个 `default` 任务，当你没有参数地简单地输入 `grunt` 到命令行时，这个任务将会运行。为此，你将使用 `grunt.registerTask()`
    方法：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This example sets the default Grunt task to run the defined `jshint` task first
    and then the `watch:jshint` multitask target. You can see that the tasks passed
    to the `default` task are in an array, so you can set the `default` task for Grunt
    to run any number of tasks by simply typing `grunt` on the command line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将默认的 Grunt 任务设置为首先运行定义的 `jshint` 任务，然后运行 `watch:jshint` 多任务目标。你可以看到传递给 `default`
    任务的都是在数组中，所以你只需在命令行上简单地输入 `grunt`，就可以为 Grunt 设置运行任意数量的任务：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: From looking at the output, you can see that the `jshint` task was run once
    initially, and then `watch:jshint` was run to wait for additional changes to the
    configured file patterns.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`jshint` 任务最初运行了一次，然后运行 `watch:jshint` 来等待配置文件模式的额外更改。
- en: Defining custom tasks
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义自定义任务
- en: Grunt allows you to define your own custom tasks, in the same way that you defined
    the default task. In this way, you can actually write your own custom tasks directly
    within the `Gruntfile`, or you can load them from an external file, just as you
    did with `grunt-contrib-jshint` and `grunt-contrib-watch`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 允许你定义你自己的自定义任务，就像你定义默认任务一样。这样，你实际上可以直接在 `Gruntfile` 中编写你自己的自定义任务，或者你可以从外部文件加载它们，就像你处理
    `grunt-contrib-jshint` 和 `grunt-contrib-watch` 一样。
- en: '**Alias tasks**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名任务**'
- en: 'One way of defining a custom task is to simply call one or more existing tasks
    in the order you want them to be run:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义任务的一种方式是简单地按照你想要它们运行的顺序调用一个或多个现有任务：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we have simply defined a task named `my-task` to serve as a
    proxy for `jshint`. The second parameter is an optional description of the task,
    which must be a string. The third parameter, which passes an array, including
    only `jshint` in this example, must always be an array. You can also forgo the
    second parameter with the description and pass in your array of tasks there instead.
    This way of defining a task is known as an *alias task*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们简单地定义了一个名为 `my-task` 的任务，作为 `jshint` 的代理。第二个参数是任务的可选描述，它必须是一个字符串。第三个参数，传递一个数组，在这个例子中只包括
    `jshint`，必须始终是一个数组。你也可以省略描述参数，直接在那里传递你的任务数组。这种定义任务的方式被称为 *别名任务*。
- en: '**Basic tasks**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本任务**'
- en: 'When you define custom Grunt tasks, you are not limited to only calling other
    tasks that exist within your configuration, but you can write JavaScript code
    to be called directly as a function. This is called a *basic task*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义自定义Grunt任务时，你不仅限于调用配置中存在的其他任务，你还可以编写可以直接作为函数调用的JavaScript代码。这被称为*基本任务*：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, we simply write a string to the command line output for the
    task. The output should look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是将一个字符串写入任务的命令行输出。输出应该看起来像这样：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s expand upon this example and pass in some arguments to our basic task
    function, as well as access the arguments from within the function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在此基础上扩展这个例子，向我们的基本任务函数传递一些参数，以及从函数内部访问这些参数：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You will notice that there is a property available to the basic task, `this.name`,
    which is simply a reference to the name of the task. In order to call a basic
    task from the command line and pass arguments in, you will use a colon after the
    task name to define each argument in succession. This syntax is just like the
    syntax for running a multitask target; however, in this case you are passing in
    arbitrary arguments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到基本任务有一个属性`this.name`可用，它只是对任务名称的引用。为了从命令行调用基本任务并传递参数，你将在任务名称后使用冒号来定义每个参数的连续性。这种语法与运行多任务目标的语法类似；然而，在这种情况下，你正在传递任意参数：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running this will output the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将输出以下内容：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you do not pass in the arguments to a task that is expecting them, it will
    simply resolve them as `undefined`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有传递参数给一个期望参数的任务，它将简单地将其解析为`undefined`：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can also call other tasks from within a custom task:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在自定义任务中调用其他任务：
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this example, we have created a task, `foo`, that defines a custom function
    that calls the existing `jshint` and `watch` tasks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`foo`的任务，它定义了一个自定义函数，该函数调用现有的`jshint`和`watch`任务：
- en: '[PRE66]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For more information on creating custom tasks with Grunt, see gruntjs.com/creating-tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用Grunt创建自定义任务的信息，请访问gruntjs.com/creating-tasks。
- en: These examples of tasks only scratch the surface of what is capable with Grunt,
    but you should be able to glean from them the power of it and begin to think about
    what might be possible with Grunt tasks when building your own SPA.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务的例子只是触及了Grunt所能做到的一小部分，但你应该能够从中领悟到它的强大之处，并开始思考在构建自己的SPA时，Grunt任务可能实现的可能性。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that you have learned to set up an optimal development environment with
    NPM, supply it with frontend dependencies using Bower, and automate development
    tasks using Grunt, it's time to start learning more about building a real app.
    In the next chapter, we will dive into common SPA architecture design patterns,
    what they mean, and what is the best design pattern to choose based on the type
    of SPA you are building.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用NPM设置一个最佳的开发环境，使用Bower提供前端依赖，以及使用Grunt自动化开发任务，现在是时候开始学习更多关于构建真实应用程序的知识了。在下一章中，我们将深入探讨常见的SPA架构设计模式，它们的意义，以及根据你构建的SPA类型，最佳的设计模式是什么。
