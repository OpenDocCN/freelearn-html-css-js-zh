- en: Chapter 1. Getting Organized with NPM, Bower, and Grunt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript was the bane of the web development industry during the early days
    of the browser-rendered Internet. It now powers hugely impactful libraries such
    as jQuery, and JavaScript-rendered (as opposed to server-side-rendered) content
    is even indexed by many search engines. What was once largely considered an annoying
    language used primarily to generate pop-up windows and alert boxes, has now become
    arguably the most popular programming language in the world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Not only is JavaScript now more prevalent than ever in frontend architecture,
    but it has become a server-side language as well, thanks to the *Node.js* runtime.
    We have also seen the proliferation of document-oriented databases, such as MongoDB,
    which store and return JSON data. With JavaScript present throughout the development
    stack, the door is now open for JavaScript developers to become full-stack developers
    without the need to learn a traditional server-side language. Given the right
    tools and know-how, any JavaScript developer can create *single page applications*
    comprised entirely of the language they know best, and they can do so using an
    architecture like *MEAN* (MongoDB, Express, AngularJS, and Node.js).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Organization is key to the development of any complex **Single Page Application**
    (**SPA**). If you don't get organized from the beginning, you are sure to introduce
    an inordinate number of regressions to your app. The Node.js ecosystem will help
    you to do this with a full suite of indispensable and open-source tools, three
    of which we will discuss here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**NPM**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bower frontend package manager
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grunt** JavaScript task runner'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these three tools can be used together to create an organized development
    environment that is ideal for creating an SPA and is essential to the MEAN stack
    architecture.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Node Package Manager?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within any full-stack JavaScript environment, **Node Package Manager** will
    be your *go-to* tool for setting up your development environment and for managing
    server-side libraries. NPM can be used within both global and isolated environment
    contexts. We will first explore the use of NPM globally.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js and NPM
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NPM is a component of *Node.js*, so before you can use it you must first install
    Node.js. You can find installers for both Mac and Windows at nodejs.org. Once
    you have Node.js installed, using NPM is incredibly easy and is done from the
    **Command Line Interface** (**CLI**). Start by ensuring you have the latest version
    of NPM installed, as it is updated more often than Node.js itself:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When using NPM, the `-g` option will apply your changes to your global environment.
    In this case, you want your version of NPM to apply globally. As stated previously,
    NPM can be used to manage packages both globally and within isolated environments.
    In the following, we want essential development tools to be applied globally so
    that you can use them in multiple projects on the same system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Mac and some Unix-based systems, you may have to run the `npm` command
    as the superuser (prefix the command with `sudo`) in order to install packages
    globally, depending on how NPM was installed. If you run into this issue and wish
    to remove the need to prefix `npm` with `sudo`, see [docs.npmjs.com/getting-started/fixing-npm-permissions](http://docs.npmjs.com/getting-started/fixing-npm-permissions).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your package.json file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any project you develop, you will keep a local `package.json` file to manage
    your Node.js dependencies. This file should be stored at the root of your project
    directory and it will only pertain to that isolated environment. This allows you
    to have multiple Node.js projects with different dependency chains on the same
    system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'When beginning a new project, you can automate the creation of the `package.json`
    file from the command line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running `npm init` will take you through a series of JSON property names to
    define through command line prompts, including your app''s `name`, `version` number,
    `description`, and more. The `name` and `version` properties are required, and
    your Node.js package will not install without them defined. Several of the properties
    will have a default value given within parentheses in the prompt so that you may
    simply hit *Enter* to continue. Other properties will simply allow you to hit
    *Enter* with a blank entry and will not be saved to the `package.json` file, or
    will be saved with a blank value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `entry point` prompt will be defined as the `main` property in `package.json`
    and is not necessary unless you are developing a Node.js application. In our case,
    we can forgo this field. The `npm init` command may in fact force you to save
    the `main` property, so you will have to edit `package.json` afterward to remove
    it; however, that field will have no effect on your web app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also choose to create the `package.json` file manually using a text
    editor, if you know the appropriate structure to employ. Whichever method you
    choose, your initial version of the `package.json` file should look similar to
    the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want your project to be private and want to ensure that it does not
    accidently get published to the NPM registry, you may want to add the `private`
    property to your `package.json` file, and set it to `true`. Additionally, you
    may remove some properties that only apply to a registered package:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have your `package.json` file set up the way you like it, you can begin
    installing Node.js packages locally for your app. This is where the importance
    of dependencies begins to surface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: NPM dependencies
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three types of dependencies that can be defined for any Node.js project
    in your `package.json` file: `dependencies`, `devDependencies`, and `peerDependencies`.
    For the purpose of building a web-based SPA, you will only need to use the `devDependencies`
    declaration.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`devDependencies` are those which are required for developing your application,
    but not required for its production environment or for simply running it. If other
    developers want to contribute to your Node.js application, they will need to run
    `npm install` from the command line to set up the proper development environment.
    For information on the other types of dependencies, see docs.npmjs.com.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding `devDependencies` to your `package.json file`, the command line
    again comes to the rescue. Let''s use the installation of Browserify as an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will install Browserify locally and save it along with its version range
    to the `devDependencies` object in your `package.json` file. Once installed, your
    `package.json` file should look similar to the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `devDependencies` object will store each package as a key-value pair in
    which the key is the *package name* and the value is the *version number* or *version
    range*. Node.js uses semantic versioning, where the three digits of the version
    number represent `MAJOR.MINOR.PATCH`. For more information on semantic version
    formatting, see [semver.org](http://semver.org).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Updating your development dependencies
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You will notice that the version number of the installed package is preceded
    by a **caret** (`^`) symbol by default. This means that package updates will only
    allow *patch* and *minor* updates for versions above 1.0.0\. This is meant to
    prevent major version changes from breaking your dependency chain when updating
    your packages to the latest versions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'To update your `devDependencies` and save the new version numbers, you can
    enter the following from the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To update all globally installed NPM packages to their latest versions, run
    `npm update` with the `-g` option:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information on semantic versioning within NPM, see [docs.npmjs.com/misc/semver](http://docs.npmjs.com/misc/semver).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have NPM set up and you know how to install your development dependencies,
    you can move on to installing Bower.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Bower
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bower is a package manager for frontend web assets and libraries. You will use
    it to maintain your frontend stack and control version chains for libraries such
    as jQuery, AngularJS, and any other components necessary to your app's web interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Installing Bower
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bower is also a Node.js package, so you will install it using NPM, much like
    you did with the Browserify example installation in the previous section, but
    this time you will be installing the package globally. This will allow you to
    run `bower` from the command line anywhere on your system without having to install
    it locally for each project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can alternatively install Bower locally as a development dependency so
    that you may maintain different versions of it for different projects on the same
    system, but this is generally not necessary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, check that Bower is properly installed by querying the version from the
    command line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bower also requires a *Git* version control system, or *VCS*, to be installed
    on your system in order to work with packages. This is because Bower communicates
    directly with GitHub for package management data. If you do not have Git installed
    on your system, you can find instructions for Linux, Mac, and Windows at [git-scm.com](http://git-scm.com).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your bower.json file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of setting up your `bower.json` file is comparable to that of the
    `package.json` file for NPM. It uses the same JSON format, has both `dependencies`
    and `devDependencies`, and can also be automatically created:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you type `bower init` from the command line, you will be prompted to define
    several properties with some defaults given within parentheses:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These questions may vary, depending on the version of Bower you install.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Most properties in the `bower.json` file are not necessary unless you are publishing
    your project to the Bower registry, indicated in the final prompt. You will most
    likely want to mark your package as private, unless you plan to register it and
    allow others to download it as a Bower package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the `bower.json` file, you can open it in a text editor
    and change or remove any properties you wish. It should look something like the
    following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you wish to keep your project private, you can reduce your `bower.json`
    file to two properties before continuing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once you have the initial version of your `bower.json` file set up the way you
    like it, you can begin installing components for your app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Bower components location and the .bowerrc file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bower will install components into a directory named `bower_components` by
    default. This directory will be located directly under the root of your project.
    If you wish to install your Bower components under a different directory name,
    you must create a local system file named `.bowerrc` and define the custom directory
    name there:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An object with only a single `directory` property name is all that is necessary
    to define a custom location for your Bower components. There are many other properties
    that can be configured within a `.bowerrc` file. For more information on configuring
    Bower, see bower.io/docs/config/.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Bower dependencies
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bower also allows you to define both the `dependencies` and `devDependencies`
    objects like NPM. The distinction with Bower, however, is that the `dependencies`
    object will contain the components necessary for running your app, while the `devDependencies`
    object is reserved for components that you might use for testing, transpiling,
    or anything that does not need to be included in your frontend stack.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Bower packages are managed using the `bower` command from the CLI. This is
    a user command, so it does not require super user (sudo) permissions. Let''s begin
    by installing jQuery as a frontend dependency for your app:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `--save` option on the command line will save the package and version number
    to the `dependencies` object in `bower.json`. Alternatively, you can use the `-S`
    option as a shortcut for `--save`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let''s install the Mocha JavaScript testing framework as a development
    dependency:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, we will use `--save-dev` on the command line to save the package
    to the `devDependencies` object instead. Your `bower.json` file should now look
    similar to the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can use the `-D` option as a shortcut for `--save-dev`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice that the package version numbers are preceded by the **tilde**
    (`~`) symbol by default, in contrast to the caret (`^`) symbol as is the case
    with NPM. The tilde serves as a more stringent guard against package version updates.
    With a `MAJOR.MINOR.PATCH` version number, running `bower update` will only update
    to the latest patch version. If a version number is composed of only the major
    and minor versions, `bower update` will update the package to the latest minor
    version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Searching the Bower registry
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All registered Bower components are indexed and searchable through the command
    line. If you don't know the exact package name of a component you wish to install,
    you can perform a search to retrieve a list of matching names.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Most components will have a list of keywords in their `bower.json` file so
    that you can more easily find the package without knowing the exact name. For
    example, you may want to install PhantomJS for headless browser testing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The list returned will include any package with `phantomjs` in the package
    name or within its keywords list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can see from the returned list that the correct package name for PhantomJS
    is in fact `phantom` and not `phantomjs`. You can then proceed to install the
    package now that you know the correct name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now you have Bower installed and know how to manage your frontend web components
    and development tools, but how do you integrate them into your SPA? This is where
    Grunt comes in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Grunt
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grunt is a *JavaScript task runner* for Node.js, and if you haven't used it
    before, it is perhaps the best tool you never knew you needed. You will find it
    useful for a myriad of tasks including CSS and JavaScript linting and minification,
    JavaScript template pre-compilation, LESS and SASS pre-processing, and so much
    more. There are indeed alternatives to Grunt, but none with as large an ecosystem
    of plugins (at the time of writing).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two components to Grunt: the *Grunt CLI*, and the *Grunt task runner*
    itself. The Grunt CLI allows you to run the Grunt task runner command from the
    command line within a directory that has Grunt installed. This allows you to have
    a different version of Grunt running for each project on your machine, making
    each app more maintainable. For more information, see [gruntjs.com](http://gruntjs.com).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Grunt CLI
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will want to install the Grunt CLI globally, just as you did with Bower:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that the Grunt CLI is not the Grunt task runner. It simply makes the
    `grunt` command available to you from the command line. This distinction is important,
    because while the `grunt` command will be globally available from the command
    line, it will always look for a local installation in the directory from which
    you run it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Grunt task runner
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will install the Grunt task runner locally from the root of your app where
    your `package.json` file is located. Grunt is installed as a Node.js package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you have Grunt installed locally, your `package.json` file should look
    like the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You will notice a `devDependencies` object has been added to your `package.json`
    file, if it was not already there from a previous install.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have Grunt installed locally, let's begin installing some plugins
    to work with.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Installing Grunt plugins
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Grunt task plugins are Node.js packages, so they will be installed using
    NPM as well. There are thousands of Grunt plugins written by a multitude of authors,
    as Grunt is an open-source project. Every Node.js package for Grunt is prefixed
    with `grunt` in the name. The Grunt team, however, does maintain many plugins
    themselves. The officially maintained Grunt plugins are all prefixed with `grunt-contrib`,
    so this is how you can differentiate them if you wish to stick with only officially
    maintained Grunt plugins. To view and search all registered Grunt plugins, see
    gruntjs.com/plugins.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you will be writing a JavaScript SPA, let''s begin by installing a JavaScript
    *linting* plugin for Grunt. Linting refers to running a program against your code
    to analyze it for errors and, in some cases, proper formatting. It is always a
    good idea to have a linting utility running to test your JavaScript code for valid
    syntax and formatting:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will install the officially maintained Grunt plugin for `JSHint` and add
    it to the `devDependencies` object in your `package.json` file as shown in the
    following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`JSHint` is a popular tool for detecting errors and potential problems in your
    JavaScript code. The Grunt plugin itself will allow you to automate that process
    so that you can easily check your code as you develop.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Another invaluable Grunt plugin is `grunt-contrib-watch`. This plugin allows
    you to run a task which will automatically run other Grunt tasks when you add,
    delete, or edit files in your project that match a predefined set of rules.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After installing the `grunt-contrib-watch plugin`, the `devDependencies` object
    in your `package.json` file should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that you have a couple of Grunt plugins installed, let's begin writing some
    tasks for them. In order to do that, you will first need to create a local configuration
    file for Grunt.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Grunt
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike NPM and Bower, Grunt does not provide an `init` command for initializing
    its configuration file. Instead, *scaffolding* tools can be used for this. Project
    scaffolding tools are designed to set up some basic directory structure and configuration
    files for a development project. Grunt maintains an official scaffolding tool
    called `grunt-init`, which is referenced on their website. The `grunt-init` tool
    must be installed separately from the `grunt-cli` global package and the local
    `grunt` package for any particular project. It is most useful if installed globally,
    so it can be used with any project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will not go into further detail on `grunt-init` here, but if you would like
    to learn more, you can visit [gruntjs.com/project-scaffolding](http://gruntjs.com/project-scaffolding).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn about configuring Grunt is to write its configuration
    file by hand. The configuration for Grunt is maintained in a file called `Gruntfile.js`,
    referred to as a `Gruntfile`, located in the root directory of your project, along
    with `package.json` and `bower.json`. If you are not familiar with Node.js and
    its concept of modules and exports, the syntax for a `Gruntfile` may be a bit
    confusing at first. Since Node.js files run on the server and not in a browser,
    they do not interact in the same way that files loaded in a browser do, with respect
    to browser `globals`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Node.js modules
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Node.js, a module is a JavaScript object defined within a file. The module
    name is the name of the file. For instance, if you want to declare a module named
    `foo`, you will create a file named `foo.js`. In order for the `foo` module to
    be accessible to another module, it must be exported. In its most basic form,
    a module looks something like the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Every module has a local `exports` variable that allows you to make the module
    accessible to others. In other words, the object `module` within a file refers
    to the current module itself, and the `exports` property of `module` makes that
    module available to any other module (or file).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of defining a module is by exporting a function, which is of course
    a JavaScript object itself:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you call for a Node.js module from within a file, it will first look for
    a core module, all of which are compiled into Node.js itself. If the name does
    not match a core module, it will then look for a directory named `node_modules`
    beginning from the current or root directory of your project. This directory is
    where all of your local NPM packages, including Grunt plugins, will be stored.
    If you performed the installs of `grunt-contrib-jshint` and `grunt-contrib-watch`
    from earlier, you will see that this directory now exists within your project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand a bit more about how Node.js modules work, let's create
    a `Gruntfile`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Gruntfile
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `Gruntfile` uses the function form of `module.exports` as shown previously.
    This is referred to as a *wrapper function*. The `grunt` module itself is passed
    to the wrapper function. The `grunt` module will be available to your `Gruntfile`
    because you installed the `grunt` NPM package locally:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example shows what your initial `Gruntfile` should look like. Now let's
    flesh it out some more. In order to configure Grunt and run tasks with it, you
    will need to access the `grunt` module that is passed in to your `Gruntfile`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This basic format is what you will be working with the rest of the way. You
    can see here that the `grunt.initConfig` method is called and passed a single
    configuration object as a parameter. This configuration object is where all of
    your Grunt task code will go. The `pkg` property shown in this example, which
    is assigned the value of `grunt.file.readJSON('package.json')`, allows you to
    pass in information about your project directly from your `package.json` file.
    The use of this property will be shown in later examples.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Defining Grunt task configuration
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most Grunt tasks expect their configuration to be defined within a property
    of the same name as the task, which is the suffix of the package name. For example,
    `jshint` is the Grunt task name for the `grunt-contrib-jshint` package we previously
    installed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here you can see that the `jshint` property of the configuration object is defined
    and is assigned its own properties which apply to the `jshint` Grunt task itself.
    The `options` property defined within `jshint` holds the settings you wish to
    validate against when linting your JavaScript files. The `files` property defines
    a list of the files you wish to validate. For more information on the supported
    options for `JSHint` and what they mean, see jshint.com/docs/.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add an additional configuration for the `grunt-contrib-watch` plugin
    `watch` task below the `jshint` task configuration:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here we add an additional namespace of `jshint` underneath the `watch` task,
    which allows for other *targets* to be defined within the same configuration property
    and run separately if needs be. This is what is known as a *multitask*. Targets
    within a multitask can be named arbitrarily and will simply be run in the order
    which they are defined if the multitask is called alone. A target can be called
    directly as well, and doing so will ignore any of the other targets defined within
    the multitask''s configuration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This particular configuration for the target `jshint` tells the `watch` task
    that if any files matching `js/src/*.js` are changed, then to run the `jshint`
    task.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Now you have your first two Grunt task configurations defined within your `Gruntfile`,
    but in order to use them, we must load the Grunt tasks themselves.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Loading Grunt plugins
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You have already installed the `grunt-contrib-jshint` plugin as a Node.js module,
    but in order to execute the `jshint` task, you must load the plugin within your
    `Gruntfile`. This is done after the `grunt.initConfig` call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the same method call you will use to load all Grunt tasks within your
    `Gruntfile`, and any Grunt task will not be accessible without doing so. Let''s
    do the same for `grunt-contrib-watch`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Your full `Gruntfile` should now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Running the jshint Grunt task
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have the plugin loaded, you can simply run `grunt jshint` from
    the command line to execute the task with its defined configuration. You should
    see the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will run your `JSHint` linting options against the defined files, which
    as of now consist of only `Gruntfile.js`. If it looks like the example file shown
    and includes the call to `grunt.loadNpmTasks('grunt-contrib-jshint')`, then it
    should pass without errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new JavaScript file and intentionally include some code
    which will not pass the JSHint configuration so we can see how the errors are
    reported. First, create the `js/src` directory, which is defined in the `files`
    property of the `jshint` task:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then create a file named `app.js` within this directory and place the following
    code in it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now run `grunt jshint` again from the command line. You should see the following
    output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will notice that two errors are reported for `js/src/app.js` based on the
    `jshint` task configuration options. Let''s fix the errors by changing the code
    in `app.js` to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now if you run `grunt jshint` from the command line again, it will report that
    the files are lint free and have no errors:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Running the watch Grunt task
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier, when the `watch` task is run it will wait for changes
    that match the file patterns defined in its configuration and run any corresponding
    tasks. In this case, we configured it to run `jshint` when any files matching
    `js/src/*.js` are changed. Since we defined a target within the `watch` task called
    `jshint`, the `watch` task can be run in two different ways:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running `grunt watch` will watch for changes matching all target configurations
    defined within the `watch` task:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running `grunt watch:jshint` with the colon (`:`) syntax runs `watch` for just
    the file patterns matching that target configuration. In our case, only one target
    is defined, so let''s just run `grunt watch` and see what happens in the console:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You will see that the task now shows a status of `Waiting...` on the command
    line. This indicates that the task is running to watch for matching changes within
    its configuration, and if any of those changes are made, it will automatically
    run the corresponding tasks. In our example with the `jshint` task, it will allow
    your code to automatically be linted every time you make changes to your JavaScript
    files and save them. If a `JSHint` error occurs, the console will alert you and
    display the error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this by opening a text editor and changing `js/src/app.js` again:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we removed the opening `use strict` statement and the semicolon after
    the call to `test()` at the end of the file. This should raise two `JSHint` errors:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let''s correct these errors and return the file to the way it was before:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Press *Ctrl* + *C* from the command line at any time to abort the `watch` task,
    or any Grunt task, while it is running.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Defining the default Grunt task
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grunt allows you to define a `default` task which will run when you simply
    type `grunt` on the command line with no parameters. To do this, you will use
    the `grunt.registerTask()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This example sets the default Grunt task to run the defined `jshint` task first
    and then the `watch:jshint` multitask target. You can see that the tasks passed
    to the `default` task are in an array, so you can set the `default` task for Grunt
    to run any number of tasks by simply typing `grunt` on the command line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: From looking at the output, you can see that the `jshint` task was run once
    initially, and then `watch:jshint` was run to wait for additional changes to the
    configured file patterns.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom tasks
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Grunt allows you to define your own custom tasks, in the same way that you defined
    the default task. In this way, you can actually write your own custom tasks directly
    within the `Gruntfile`, or you can load them from an external file, just as you
    did with `grunt-contrib-jshint` and `grunt-contrib-watch`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Alias tasks**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of defining a custom task is to simply call one or more existing tasks
    in the order you want them to be run:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we have simply defined a task named `my-task` to serve as a
    proxy for `jshint`. The second parameter is an optional description of the task,
    which must be a string. The third parameter, which passes an array, including
    only `jshint` in this example, must always be an array. You can also forgo the
    second parameter with the description and pass in your array of tasks there instead.
    This way of defining a task is known as an *alias task*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic tasks**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define custom Grunt tasks, you are not limited to only calling other
    tasks that exist within your configuration, but you can write JavaScript code
    to be called directly as a function. This is called a *basic task*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义自定义Grunt任务时，你不仅限于调用配置中存在的其他任务，你还可以编写可以直接作为函数调用的JavaScript代码。这被称为*基本任务*：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this example, we simply write a string to the command line output for the
    task. The output should look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是将一个字符串写入任务的命令行输出。输出应该看起来像这样：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s expand upon this example and pass in some arguments to our basic task
    function, as well as access the arguments from within the function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在此基础上扩展这个例子，向我们的基本任务函数传递一些参数，以及从函数内部访问这些参数：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You will notice that there is a property available to the basic task, `this.name`,
    which is simply a reference to the name of the task. In order to call a basic
    task from the command line and pass arguments in, you will use a colon after the
    task name to define each argument in succession. This syntax is just like the
    syntax for running a multitask target; however, in this case you are passing in
    arbitrary arguments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到基本任务有一个属性`this.name`可用，它只是对任务名称的引用。为了从命令行调用基本任务并传递参数，你将在任务名称后使用冒号来定义每个参数的连续性。这种语法与运行多任务目标的语法类似；然而，在这种情况下，你正在传递任意参数：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running this will output the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将输出以下内容：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you do not pass in the arguments to a task that is expecting them, it will
    simply resolve them as `undefined`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有传递参数给一个期望参数的任务，它将简单地将其解析为`undefined`：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can also call other tasks from within a custom task:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在自定义任务中调用其他任务：
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this example, we have created a task, `foo`, that defines a custom function
    that calls the existing `jshint` and `watch` tasks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`foo`的任务，它定义了一个自定义函数，该函数调用现有的`jshint`和`watch`任务：
- en: '[PRE66]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For more information on creating custom tasks with Grunt, see gruntjs.com/creating-tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用Grunt创建自定义任务的信息，请访问gruntjs.com/creating-tasks。
- en: These examples of tasks only scratch the surface of what is capable with Grunt,
    but you should be able to glean from them the power of it and begin to think about
    what might be possible with Grunt tasks when building your own SPA.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务的例子只是触及了Grunt所能做到的一小部分，但你应该能够从中领悟到它的强大之处，并开始思考在构建自己的SPA时，Grunt任务可能实现的可能性。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that you have learned to set up an optimal development environment with
    NPM, supply it with frontend dependencies using Bower, and automate development
    tasks using Grunt, it's time to start learning more about building a real app.
    In the next chapter, we will dive into common SPA architecture design patterns,
    what they mean, and what is the best design pattern to choose based on the type
    of SPA you are building.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用NPM设置一个最佳的开发环境，使用Bower提供前端依赖，以及使用Grunt自动化开发任务，现在是时候开始学习更多关于构建真实应用程序的知识了。在下一章中，我们将深入探讨常见的SPA架构设计模式，它们的意义，以及根据你构建的SPA类型，最佳的设计模式是什么。
