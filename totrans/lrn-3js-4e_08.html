<html><head></head><body>
		<div id="_idContainer173">
			<h1 id="_idParaDest-133" class="chapter-number"><a id="_idTextAnchor132"/>8</h1>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>Creating and Loading Advanced Meshes and Geometries</h1>
			<p>In this chapter, we’ll look at a couple of different ways that you can create and load advanced and complex geometries and meshes. In <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Learning to Work with Geometries</em>, and <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Exploring Advanced Geometries</em>, we showed you how to create a few advanced geometries using the built-in objects from Three.js. In this chapter, we’ll use the following two approaches to create advanced geometries <span class="No-Break">and meshes:</span></p>
			<ul>
				<li>Geometry grouping <span class="No-Break">and merging</span></li>
				<li>Loading geometries from <span class="No-Break">external resources</span></li>
			</ul>
			<p>We start with the “group and merge” approach. With this approach, we use the standard Three.js grouping (<strong class="source-inline">THREE.Group</strong>) and the <strong class="source-inline">BufferGeometryUtils.mergeBufferGeometries()</strong> function to create <span class="No-Break">new objects.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Geometry grouping and merging</h1>
			<p>In this section, we’ll look at two basic features of Three.js: grouping objects together and merging multiple geometries into a single geometry. We’ll start with <span class="No-Break">grouping objects.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Grouping objects together</h2>
			<p>In some <a id="_idIndexMarker640"/>of the previous chapters, you already saw how you can group objects when working with multiple materials. When you create a mesh from a geometry using multiple materials, Three.js creates a group. Multiple copies of your geometry are added to this group, each with its own specific material. This group is returned, so it looks like a mesh that uses multiple materials. In truth, however, it is a group that contains a number <span class="No-Break">of meshes.</span></p>
			<p>Creating groups is very easy. Every mesh you create can contain child elements, which can be added using the <strong class="source-inline">add</strong> function. The effect of adding a child object to a group is that you can move, scale, rotate, and translate the parent object, and all the child objects will <a id="_idIndexMarker641"/>also be affected. When using a group, you can still refer to, modify, and position the individual geometries. The only thing you need to remember is that all positions, rotations, and translations are done relative to the <span class="No-Break">parent object.</span></p>
			<p>Let’s look at an example (<strong class="source-inline">grouping.html</strong>) in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/Figure_8.1_B18726.jpg" alt="Figure 8.1 – Using a THREE.Group object to group objects together"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Using a THREE.Group object to group objects together</p>
			<p>In this example, you see a large number of cubes, which are added to the scene as a single group. Before we look at the controls and the effect of using a group, let’s have a quick look at how we’ve created <span class="No-Break">this mesh:</span></p>
			<pre class="source-code">
  const size = 1
  const amount = 5000
  const range = 20
  const group = new THREE.Group()
  const mat = new THREE.MeshNormalMaterial()
  mat.blending = THREE.NormalBlending
  mat.opacity = 0.1
  mat.transparent = true
  for (let i = 0; i &lt; amount; i++) {
    const x = Math.random() * range - range / 2
    const y = Math.random() * range - range / 2
    const z = Math.random() * range - range / 2
    const g = new THREE.BoxGeometry(size, size, size)
    const m = new THREE.Mesh(g, mat)
    m.position.set(x, y, z)
    group.add(m)
  }</pre>
			<p>In this<a id="_idIndexMarker642"/> code snippet, you can see that we create a <strong class="source-inline">THREE.Group</strong> instance. This object is almost identical to <strong class="source-inline">THREE.Object3D</strong>, which is the base class of <strong class="source-inline">THREE.Mesh</strong> and <strong class="source-inline">THREE.Scene</strong>, but by itself, it doesn’t contain anything or cause anything to be rendered. In this example, we use the <strong class="source-inline">add</strong> function to add a large number of cubes to this scene. For this example, we’ve added the controls you can use to change the position of a mesh. Whenever you change a property using this menu, the relevant property of the <strong class="source-inline">THREE.Group</strong> object is changed. For instance, in the next example, you can see that when we scale this <strong class="source-inline">THREE.Group</strong> object, all the nested cubes get scaled <span class="No-Break">as well:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/Figure_8.2_B18726.jpg" alt="Figure 8.2 – Scaling a group"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Scaling a group</p>
			<p>If you <a id="_idIndexMarker643"/>want to experiment a bit more with the <strong class="source-inline">THREE.Group</strong> object, a good exercise would be to alter the example so that the <strong class="source-inline">THREE.Group</strong> instance itself is rotating on the <em class="italic">x</em> axis while the individual cubes are rotating on their <span class="No-Break"><em class="italic">y</em></span><span class="No-Break"> axis.</span></p>
			<p class="callout-heading">Performance impact of using THREE.Group</p>
			<p class="callout">Before we move on to the next section where we look at merging, a quick note on performance. When you<a id="_idIndexMarker644"/> use <strong class="source-inline">THREE.Group</strong>, all the individual meshes inside this group are treated as individual objects, which Three.js needs to manage and render. If you’ve got a large number of objects in the scene, you’ll see a noticeable drop in performance. If you look at the top-left corner of <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em>, you can see that with 5,000 cubes on screen, we get around 56 <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>). Not too bad, but normally we would run at around <span class="No-Break">120 FPS.</span></p>
			<p>Three.js provides <a id="_idIndexMarker645"/>an additional way where we can still control the individual meshes, but get much better performance. This is done through <strong class="source-inline">THREE.InstancedMesh</strong>. This object works great if you want to render a large number of objects with the same geometry but with different transformations (for example, rotation, scale, color, or any other <span class="No-Break">matrix transformation).</span></p>
			<p>We’ve created an example called <strong class="source-inline">instanced-mesh.html</strong>, which shows how this works. In this example, we render 250,000 cubes and still have <span class="No-Break">great performance:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/Figure_8.3_B18726.jpg" alt="Figure 8.3 – Using an InstancedMesh object for grouping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Using an InstancedMesh object for grouping</p>
			<p>To work with a <strong class="source-inline">THREE.InstancedMesh</strong> object, we create it similarly to how we created the <span class="No-Break"><strong class="source-inline">THREE.Group</strong></span><span class="No-Break"> instance:</span></p>
			<pre class="source-code">
  const size = 1
  const amount = 250000
  const range = 20
  const mat = new THREE.MeshNormalMaterial()
  mat.opacity = 0.1
  mat.transparent = true
  mat.blending = THREE.NormalBlending
  const g = new THREE.BoxGeometry(size, size, size)
  const mesh = new THREE.InstancedMesh(g, mat, amount)
  for (let i = 0; i &lt; amount; i++) {
    const x = Math.random() * range - range / 2
    const y = Math.random() * range - range / 2
    const z = Math.random() * range - range / 2
    const matrix = new THREE.Matrix4()
    matrix.makeTranslation(x, y, z)
    mesh.setMatrixAt(i, matrix)
  }</pre>
			<p>The main difference in creating a <strong class="source-inline">THREE.InstancedMesh</strong> object compared to <strong class="source-inline">THREE.Group</strong> is that we <a id="_idIndexMarker646"/>need to define beforehand which material and geometry we want to use and how many instances of this geometry we want to create. To position or rotate one of our instances, we need to provide the transformation using a <strong class="source-inline">THREE.Matrix4</strong> instance. Luckily, we don’t need to go into the math behind matrices, since Three.js provides us with a couple of helper functions on the <strong class="source-inline">THREE.Matrix4</strong> instance to define a rotation, a translation, and a couple of other transformations. In this example, we simply position each instance at a <span class="No-Break">random location.</span></p>
			<p>So, if you’re working with a small number of meshes (or meshes using different geometries), you should use a <strong class="source-inline">THREE.Group</strong> object if you want to group them together. If <a id="_idIndexMarker647"/>you’re dealing with a large number of meshes that share a geometry and material, you can use a <strong class="source-inline">THREE.InstancedMesh</strong> object or a <strong class="source-inline">THREE.InstancedBufferGeometry</strong> object for a great <span class="No-Break">performance boost.</span></p>
			<p>In the next section, we’ll look at merging, where you’ll combine multiple separate geometries and end up with a single <span class="No-Break"><strong class="source-inline">THREE.Geometry</strong></span><span class="No-Break"> object.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Merging geometries</h2>
			<p>In <a id="_idIndexMarker648"/>most cases, using groups allows you to easily manipulate and manage a large number of meshes. When you’re dealing with a very large number of objects, however, performance will become an issue since Three.js has to treat all the children of the group individually. With <strong class="source-inline">BufferGeometryUtils.mergeBufferGeometries</strong>, you can merge geometries together and create a combined one, so Three.js would only have to manage this single geometry. In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em>, you can see how this works and the effect it has on performance. If you open the <strong class="source-inline">merging.html</strong> example, you see a scene again with the same set of randomly distributed semi-transparent cubes, which we merged into a single <span class="No-Break"><strong class="source-inline">THREE.BufferGeometry</strong></span><span class="No-Break"> object:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/Figure_8.4_B18726.jpg" alt="Figure 8.4 – 500,000 geometries merged into a single geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – 500,000 geometries merged into a single geometry</p>
			<p>As you can<a id="_idIndexMarker649"/> see, we can easily render 50,000 cubes without any drop in performance. To do this, we use the following few lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
  const size = 1
  const amount = 500000
  const range = 20
  const mat = new THREE.MeshNormalMaterial()
  mat.blending = THREE.NormalBlending
  mat.opacity = 0.1
  mat.transparent = true
  const geoms = []
  for (let i = 0; i &lt; amount; i++) {
    const x = Math.random() * range - range / 2
    const y = Math.random() * range - range / 2
    const z = Math.random() * range - range / 2
    const g = new THREE.BoxGeometry(size, size, size)
    g.translate(x, y, z)
    geoms.push(g)
  }
  const merged = BufferGeometryUtils.
    mergeBufferGeometries(geoms)
  const mesh = new THREE.Mesh(merged, mat)</pre>
			<p>In this <a id="_idIndexMarker650"/>code snippet, we create a large number of <strong class="source-inline">THREE.BoxGeometry</strong> objects, which we merge together using the <strong class="source-inline">BufferGeometryUtils.mergeBufferGeometries(geoms)</strong> function. The result is a single large geometry, which we can add to the scene. The biggest drawback is that you lose control over the individual cubes since they are all merged into a single large geometry. If you want to move, rotate, or scale a single cube, you can’t (unless you search for the correct faces and vertices and position <span class="No-Break">them individually).</span></p>
			<p class="callout-heading">Creating new geometries through Constructive Solid Geometry</p>
			<p class="callout">Besides <a id="_idIndexMarker651"/>merging geometries in the way we saw in this chapter, we can also create geometries <a id="_idIndexMarker652"/>using <strong class="bold">Constructive Solid Geometry</strong> (<strong class="bold">CSG</strong>). With CSG, you<a id="_idIndexMarker653"/> can apply operations (usually addition, subtraction, difference, and intersection) to combine two geometries. These libraries would create a new geometry, based on the chosen operation. For instance, with CSG, it is very easy to create a solid cube with a sphere-like indentation on one side. Two libraries that you can use for this with Three.js are <strong class="source-inline">three-bvh-csg</strong> (<a href="https://github.com/gkjohnson/three-bvh-csg">https://github.com/gkjohnson/three-bvh-csg</a>) and <span class="No-Break"><strong class="source-inline">Three.csg</strong></span><span class="No-Break"> (</span><a href="https://github.com/looeee/threejs-csg"><span class="No-Break">https://github.com/looeee/threejs-csg</span></a><span class="No-Break">).</span></p>
			<p>With the grouping and merging approach, you can create large and complex geometries using the basic geometries provided by Three.js. If you want to create more advanced geometries, then using the programmatic approach provided by Three.js isn’t always the best and<a id="_idIndexMarker654"/> easiest option. Three.js, luckily, offers a couple of other options to create geometries. In the next section, we’ll look at how you can load geometries and meshes from <span class="No-Break">external resources.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Loading geometries from external resources</h1>
			<p>Three.js can<a id="_idIndexMarker655"/> read a large number of 3D file formats and import geometries and meshes defined in those files. A note here is that not all the features of these formats are always supported. So, sometimes there might be an issue with the textures, or materials might not be set up correctly. The new de facto standard for exchanging models and <a id="_idIndexMarker656"/>textures is <strong class="bold">glTF</strong>, so if you want to load externally created models, exporting those models to glTF format will usually give you the best results <span class="No-Break">in Three.js.</span></p>
			<p>In this section, we’ll dive a bit deeper into some of the formats that are supported by Three.js, but we won’t show you all the loaders. The following list shows an overview of the formats supported <span class="No-Break">by Three.js:</span></p>
			<ul>
				<li><strong class="bold">AMF</strong>: AMF<a id="_idIndexMarker657"/> is <a id="_idIndexMarker658"/>another 3D printing standard, but isn’t under active development anymore. The following <em class="italic">Wikipedia</em> page has <a id="_idIndexMarker659"/>additional information on this <span class="No-Break">standard: </span><a href="https://www.sculpteo.com/en/glossary/amf-definition/"><span class="No-Break">https://www.sculpteo.com/en/glossary/amf-definition/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">3DM</strong>: 3DM <a id="_idIndexMarker660"/>is the format used by Rhinoceros, which is a<a id="_idIndexMarker661"/> tool to create 3D models. More information on Rhinoceros can be found <a id="_idIndexMarker662"/><span class="No-Break">here: </span><a href="https://www.rhino3d.com/"><span class="No-Break">https://www.rhino3d.com/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">3MF</strong>: 3MF<a id="_idIndexMarker663"/> is<a id="_idIndexMarker664"/> one of the standards used in 3D printing. Information about this format can be found on the <em class="italic">3MF Consortium</em> home<a id="_idIndexMarker665"/> <span class="No-Break">page: </span><a href="https://3mf.io"><span class="No-Break">https://3mf.io</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">COLLAborative Design Activity (COLLADA</strong>): COLLADA is a format for defining <a id="_idIndexMarker666"/>digital <a id="_idIndexMarker667"/>assets in an XML-based format. This is a widely used format that is supported by pretty much all 3D applications and <span class="No-Break">rendering engines.</span></li>
				<li><strong class="bold">Draco</strong>: Draco<a id="_idIndexMarker668"/> is a file format for storing geometries <a id="_idIndexMarker669"/>and point clouds in a very efficient way. It specifies how these elements are best compressed and decompressed. Details about how Draco works can be found on its <a id="_idIndexMarker670"/>GitHub <span class="No-Break">page: </span><a href="https://github.com/google/draco"><span class="No-Break">https://github.com/google/draco</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">GCode</strong>: GCode <a id="_idIndexMarker671"/>is a <a id="_idIndexMarker672"/>standard way of talking to <a id="_idIndexMarker673"/>3D printers or <strong class="bold">CNC</strong> machines. When a model is printed, one of the ways a 3D printer can be controlled is by sending it GCode commands. The details of this standard are <a id="_idIndexMarker674"/>described in the following <span class="No-Break">paper: </span><a href="https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374"><span class="No-Break">https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">glTF</strong>: This<a id="_idIndexMarker675"/> is a specification that defines how 3D scenes <a id="_idIndexMarker676"/>and models can be exchanged and loaded by different applications and tools and is becoming the standard format for exchanging models on the web. They come in a binary format with the <strong class="source-inline">.glb</strong> extension and a text-based format with the <strong class="source-inline">.gltf</strong> extension. More information on this standard can be<a id="_idIndexMarker677"/> found <span class="No-Break">here: </span><a href="https://www.khronos.org/gltf/"><span class="No-Break">https://www.khronos.org/gltf/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Industry Foundation Classes (IFC)</strong>: This<a id="_idIndexMarker678"/> is an <a id="_idIndexMarker679"/>open file format <a id="_idIndexMarker680"/>used by <strong class="bold">building information modeling</strong> (<strong class="bold">BIM</strong>) tools. It contains a model of a building and a lot of additional information on the materials used. More information about this standard can be found <span class="No-Break">here: </span><a href="https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/"><span class="No-Break">https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">JSON</strong>: Three.js <a id="_idIndexMarker681"/>has its own JSON format that you can use<a id="_idIndexMarker682"/> to declaratively define a geometry or a scene. Even though this isn’t an official format, it’s very easy to use and comes in very handy when you want to reuse complex geometries <span class="No-Break">or scenes.</span></li>
				<li><strong class="bold">KMZ</strong>: This <a id="_idIndexMarker683"/>is the<a id="_idIndexMarker684"/> format used for 3D assets on Google Earth. More<a id="_idIndexMarker685"/> information can be found <span class="No-Break">here: </span><a href="https://developers.google.com/kml/documentation/kmzarchives"><span class="No-Break">https://developers.google.com/kml/documentation/kmzarchives</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">LDraw</strong>: LDraw <a id="_idIndexMarker686"/>is an open standard you can use to create<a id="_idIndexMarker687"/> virtual LEGO models and scenes. More information can be found on the LDraw <a id="_idIndexMarker688"/>home <span class="No-Break">page: </span><a href="https://ldraw.org"><span class="No-Break">https://ldraw.org</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">LWO</strong>: This<a id="_idIndexMarker689"/> is the file format used by LightWave 3D. More<a id="_idIndexMarker690"/> information <a id="_idIndexMarker691"/>on LightWave 3D can be found <span class="No-Break">here: </span><a href="https://www.lightwave3d.com/"><span class="No-Break">https://www.lightwave3d.com/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">NRRD</strong>: NRRD is a<a id="_idIndexMarker692"/> file format used to visualize <a id="_idIndexMarker693"/>volumetric data. It can, for instance, be used to render CT scans. A lot of information and<a id="_idIndexMarker694"/> samples can be found <span class="No-Break">here: </span><a href="http://teem.sourceforge.net/nrrd/"><span class="No-Break">http://teem.sourceforge.net/nrrd/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">OBJ</strong> and <strong class="bold">MTL</strong>: OBJ is a <a id="_idIndexMarker695"/>simple 3D format first developed <a id="_idIndexMarker696"/>by Wavefront Technologies. It’s one of the most widely adopted 3D file formats and is used to define the geometry of an object. MTL is a companion format to OBJ. In an<a id="_idIndexMarker697"/> MTL file, the material<a id="_idIndexMarker698"/> of the objects in an OBJ file is specified. Three.js also has a custom OBJ exporter, called <strong class="source-inline">OBJExporter</strong>, should you want to export your models to OBJ <span class="No-Break">from Three.js.</span></li>
				<li><strong class="bold">PCD</strong>: This <a id="_idIndexMarker699"/>is an open format for describing point clouds. More<a id="_idIndexMarker700"/> information can be found <span class="No-Break">here: </span><a href="https://pointclouds.org/documentation/tutorials/pcd_file_format.html"><span class="No-Break">https://pointclouds.org/documentation/tutorials/pcd_file_format.html</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">PDB</strong>: This <a id="_idIndexMarker701"/>is a very specialized format, created<a id="_idIndexMarker702"/> by <strong class="bold">Protein Data Bank</strong> (<strong class="bold">PDB</strong>), which is used to specify what proteins look like. Three.js can load and visualize proteins specified in <span class="No-Break">this format.</span></li>
				<li><strong class="bold">Polygon File Format (PLY)</strong>: This <a id="_idIndexMarker703"/>is <a id="_idIndexMarker704"/>most often used to store information from <span class="No-Break">3D scanners.</span></li>
				<li><strong class="bold">Packed Raw WebGL Model (PRWM)</strong>: This is another format focusing on the efficient<a id="_idIndexMarker705"/> storage <a id="_idIndexMarker706"/>and parsing of 3D geometries. More <a id="_idIndexMarker707"/>information on this standard and how you can use it is described <span class="No-Break">here: </span><a href="https://github.com/kchapelier/PRWM"><span class="No-Break">https://github.com/kchapelier/PRWM</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">STereoLithography (STL)</strong>: This<a id="_idIndexMarker708"/> is widely <a id="_idIndexMarker709"/>used for rapid prototyping. For instance, models for 3D printers are often defined as STL files. Three.js also has a custom STL exporter, called <strong class="source-inline">STLExporter.js</strong>, should you want to export your models to STL <span class="No-Break">from Three.js.</span></li>
				<li><strong class="bold">SVG</strong>: SVG is <a id="_idIndexMarker710"/>a standard way to define vector graphics. This loader <a id="_idIndexMarker711"/>allows you to load an SVG file and returns a set of <strong class="source-inline">THREE.Path</strong> elements that you can use for extruding or rendering <span class="No-Break">in 2D.</span></li>
				<li><strong class="bold">3DS</strong>: The<a id="_idIndexMarker712"/> Autodesk 3DS format. More information<a id="_idIndexMarker713"/> can be<a id="_idIndexMarker714"/> found <span class="No-Break">at </span><a href="https://www.autodesk.com/"><span class="No-Break">https://www.autodesk.com/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">TILT</strong>: TILT is<a id="_idIndexMarker715"/> the format used by Tilt Brush, a VR tool that<a id="_idIndexMarker716"/> allows you to paint in VR. More<a id="_idIndexMarker717"/> information is available <span class="No-Break">here: </span><a href="https://www.tiltbrush.com/"><span class="No-Break">https://www.tiltbrush.com/</span></a><span class="No-Break">.</span></li>
			</ul>
			<ul>
				<li><strong class="bold">VOX</strong>: The <a id="_idIndexMarker718"/>format used by MagicaVoxel, a free tool you <a id="_idIndexMarker719"/>can use to create voxel art. More information is available on the home page of <a id="_idIndexMarker720"/><span class="No-Break">MagicaVoxel: </span><a href="https://ephtracy.github.io/"><span class="No-Break">https://ephtracy.github.io/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Virtual Reality Modeling Language (VRML)</strong>: This is a text-based format that <a id="_idIndexMarker721"/>allows you to <a id="_idIndexMarker722"/>specify 3D objects and worlds. It has been superseded by the X3D file format. Three.js doesn’t support<a id="_idIndexMarker723"/> loading <strong class="bold">X3D</strong> models, but these models can be easily converted to other formats. More<a id="_idIndexMarker724"/> information can be found <span class="No-Break">at </span><a href="http://www.x3dom.org/?page_id=532#"><span class="No-Break">http://www.x3dom.org/?page_id=532#</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Visualization Toolkit (VTK)</strong>: This<a id="_idIndexMarker725"/> is the<a id="_idIndexMarker726"/> file format defined by and used to specify vertices and faces. There are two formats available: a binary one and a <a id="_idIndexMarker727"/>text-based <strong class="bold">ASCII</strong> one. Three.js only supports the <span class="No-Break">ASCII-based format.</span></li>
				<li><strong class="bold">XYZ</strong>: This<a id="_idIndexMarker728"/> is a very simple file format for describing <a id="_idIndexMarker729"/>points in 3D space. More information is available <span class="No-Break">here: </span><a href="https://people.math.sc.edu/Burkardt/data/xyz/xyz.html"><span class="No-Break">https://people.math.sc.edu/Burkardt/data/xyz/xyz.html</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>In <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Animations and Moving the Camera</em>, we’ll revisit some of these formats (and look at a number of additional ones) when we look <span class="No-Break">at animations.</span></p>
			<p>As you can see from this list, Three.js supports a very large number of 3D file formats. We won’t be describing all of them, just the most interesting ones. We’ll start with the JSON loader since that provides a nice way to store and retrieve scenes you’ve <span class="No-Break">created yourself.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>Saving and loading in Three.js JSON format</h2>
			<p>You <a id="_idIndexMarker730"/>can use the Three.js JSON format for two different scenarios in Three.js. You<a id="_idIndexMarker731"/> can use it to save and load a single <strong class="source-inline">THREE.Object3D</strong> object (which means you can also use it to export a <span class="No-Break"><strong class="source-inline">THREE.Scene</strong></span><span class="No-Break"> object).</span></p>
			<p>To demonstrate saving and loading, we created a simple example based on <strong class="source-inline">THREE.TorusKnotGeometry</strong>. With this example, you can create a torus knot, just as we did in <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">,</em> and, using the <strong class="bold">save</strong> button from the <strong class="bold">Save/load</strong> menu, you can save the current geometry. For <a id="_idIndexMarker732"/>this example, we save using the HTML5 local storage API. This <a id="_idIndexMarker733"/>API allows us to easily store persistent information in the client’s browser and retrieve it at a later time (even after the browser has been shut down <span class="No-Break">and restarted):</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/Figure_8.5_B18726.jpg" alt="Figure 8.5 – Showing the loaded and the current mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Showing the loaded and the current mesh</p>
			<p>In the previous screenshot, you can see two meshes—the red one is the one we loaded, and the yellow one is the original one. If you open this example yourself and click the <strong class="bold">save</strong> button, the current state of the mesh will be stored. Now, you can refresh the browser and click <strong class="bold">load</strong>, and the saved state will be shown <span class="No-Break">in red.</span></p>
			<p>Exporting in JSON from Three.js is very easy and doesn’t require you to include any additional libraries. The only thing you need to do is to export <strong class="source-inline">THREE.Mesh</strong> as JSON and store it in the browser’s <strong class="source-inline">localstorage</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const asJson = mesh.toJSON()
localStorage.setItem('json', JSON.stringify(asJson))</pre>
			<p>Before <a id="_idIndexMarker734"/>saving it, we first convert the result from the <strong class="source-inline">toJSON</strong> function (a JavaScript object) to a string using the <strong class="source-inline">JSON.stringify</strong> function. To <a id="_idIndexMarker735"/>save this information using the HTML5 local storage API, all we have to do is call the <strong class="source-inline">localStorage.setItem</strong> function. The first argument is the key value (json) that we can later use to retrieve the information we passed in as the <span class="No-Break">second argument.</span></p>
			<p>This JSON string looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "metadata": {
    "version": 4.5,
    "type": "Object",
    "generator": "Object3D.toJSON"
  },
  "geometries": [
    {
      "uuid": "15a98944-91a8-45e0-b974-0d505fcd12a8",
      "type": "TorusKnotGeometry",
      "radius": 1,
      "tube": 0.1,
      "tubularSegments": 200,
      "radialSegments": 10,
      "p": 6,
      "q": 7
    }
  ],
  "materials": [
    {
      "uuid": "38e11bca-36f1-4b91-b3a5-0b2104c58029",
      "type": "MeshStandardMaterial",
      "color": 16770655,
      // left out some material properties    
      "stencilFuncMask": 255,
      "stencilFail": 7680,
      "stencilZFail": 7680,
      "stencilZPass": 7680
    }
  ],
  "object": {
    "uuid": "373db2c3-496d-461d-9e7e-48f4d58a507d",
    "type": "Mesh",
    "castShadow": true,
    "layers": 1,
    "matrix": [
      0.5,
      ...
      1
    ],
    "geometry": "15a98944-91a8-45e0-b974-0d505fcd12a8",
    "material": "38e11bca-36f1-4b91-b3a5-0b2104c58029"
  }
}</pre>
			<p>As you <a id="_idIndexMarker736"/>can see, Three.js saves all the information about the <strong class="source-inline">THREE.Mesh</strong> object. Loading <strong class="source-inline">THREE.Mesh</strong> back into Three.js also requires just a <a id="_idIndexMarker737"/>few lines of code, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const fromStorage = localStorage.getItem('json')
if (fromStorage) {
  const structure = JSON.parse(fromStorage)
  const loader = new THREE.ObjectLoader()
  const mesh = loader.parse(structure)
  mesh.material.color = new THREE.Color(0xff0000)
  scene.add(mesh)
}</pre>
			<p>Here, we first get the JSON from local storage using the name we saved it with (json, in this case). For this, we use the <strong class="source-inline">localStorage.getItem</strong> function provided by the HTML5 local storage API. Next, we need to convert the string back to a JavaScript object (<strong class="source-inline">JSON.parse</strong>) and convert the JSON object back to <strong class="source-inline">THREE.Mesh</strong>. Three.js provides a helper object called <strong class="source-inline">THREE.ObjectLoader</strong>, which you can use to convert JSON to <strong class="source-inline">THREE.Mesh</strong>. In this example, we used the <strong class="source-inline">parse</strong> method on the loader to directly parse a JSON string. The loader also provides a load function, where you can pass the URL to a file containing the <span class="No-Break">JSON definition.</span></p>
			<p>As you can see here, we only saved a <strong class="source-inline">THREE.Mesh</strong> object, so we lose everything else. If you want to save the complete scene, including the lights and the cameras, you can use the same approach to export <span class="No-Break">a scene:</span></p>
			<pre class="source-code">
const asJson = scene.toJSON()
localStorage.setItem('scene', JSON.stringify(asJson))</pre>
			<p>The result of this is a complete scene description <span class="No-Break">in JSON:</span></p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/Figure_8.5_B18726.jpg" alt="Figure 8.6 – Exporting a scene to JSON"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Exporting a scene to JSON</p>
			<p>This <a id="_idIndexMarker738"/>can be<a id="_idIndexMarker739"/> loaded in the same way as we already showed for a <strong class="source-inline">THREE.Mesh</strong> object. While storing your current scene and objects in JSON comes in very handy when you’re working exclusively in Three.js, this isn’t a format that can easily be exchanged with or created by other tools and programs. In the next section, we’ll look a bit deeper into some of the 3D formats supported <span class="No-Break">by Three.js.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Importing from 3D file formats</h1>
			<p>At the <a id="_idIndexMarker740"/>beginning of this chapter, we listed a number of formats that are supported by Three.js. In this section, we’ll quickly walk through a few examples of <span class="No-Break">those formats.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>The OBJ and MTL formats</h2>
			<p>OBJ and MTL<a id="_idIndexMarker741"/> are companion formats and are often used together. An OBJ file defines the geometry, and an MTL file defines the materials that are used. Both OBJ and MTL are text-based formats. A part of an OBJ file looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
v -0.032442 0.010796    0.025935
v -0.028519 0.013697    0.026201
v -0.029086 0.014533    0.021409
usemtl Material 
s   1   
f   2731    2735 2736 2732
f   2732    2736 3043 3044</pre>
			<p>An MTL file<a id="_idIndexMarker742"/> defines materials, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
newmtl Material
Ns  56.862745   
Ka  0.000000    0.000000    0.000000
Kd  0.360725    0.227524    0.127497
Ks  0.010000    0.010000    0.010000
Ni  1.000000        
d 1.000000
illum 2</pre>
			<p>The OBJ and MTL formats are well supported by Three.js, so this is a good format to choose if you want to exchange 3D models. Three.js has two different loaders you can use. If you <a id="_idIndexMarker743"/>only want to load the geometry, you use <strong class="source-inline">OBJLoader</strong>. We used this loader for our example (<strong class="source-inline">load-obj.html</strong>). The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/Figure_8.7_B18726.jpg" alt="Figure 8.7 – OBJ model that just defines the geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – OBJ model that just defines the geometry</p>
			<p>Loading an OBJ <a id="_idIndexMarker744"/>model from an external file is done <span class="No-Break">like this:</span></p>
			<pre class="source-code">
import { OBJLoader } from 'three/examples/jsm/
  loaders/OBJLoader'
new OBJLoader().loadAsync('/assets/models/
  baymax/Bigmax_White_OBJ.obj').then((model) =&gt; {
  model.scale.set(0.05, 0.05, 0.05)
  model.translateY(-1)
  visitChildren(model, (child) =&gt; {
    child.receiveShadow = true
    child.castShadow = true
  })
  return model
})</pre>
			<p>In this<a id="_idIndexMarker745"/> code, we use <strong class="source-inline">OBJLoader</strong> to load the model from a URL asynchronously. This returns a JavaScript promise, which, when resolved, will contain the mesh. Once the<a id="_idIndexMarker746"/> model is loaded, we do some fine-tuning and make sure the model casts shadows and receives shadows as well. Besides <strong class="source-inline">loadAsync</strong>, each loader also provides a <strong class="source-inline">load</strong> function, which, instead of working with promises, works with callbacks. This same code would then look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const model = new OBJLoader().load('/assets/models/baymax
  /Bigmax_White_OBJ.obj', (model) =&gt; {
  model.scale.set(0.05, 0.05, 0.05)
  model.translateY(-1)
  visitChildren(model, (child) =&gt; {
    child.receiveShadow = true
    child.castShadow = true
  })
  // do something with the model
  scene.add(model)
})</pre>
			<p>In this chapter, we’ll use the <strong class="source-inline">Promise</strong>-based <strong class="source-inline">loadAsync</strong> approach, since that avoids having nested callbacks and makes it a bit easier to chain these kinds of calls together. The next example (<strong class="source-inline">oad-obj-mtl.html</strong>) uses <strong class="source-inline">OBJLoader</strong>, together with <strong class="source-inline">MTLLoader</strong>, to load a model and directly assign a material. The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/Figure_8.8_B18726.jpg" alt="Figure 8.8 – OBJ.MTL model with a model and materials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – OBJ.MTL model with a model and materials</p>
			<p>Using an <strong class="source-inline">MTL</strong> file<a id="_idIndexMarker747"/> besides<a id="_idIndexMarker748"/> the <strong class="source-inline">OBJ</strong> file follows the same principle we saw earlier in <span class="No-Break">this section:</span></p>
			<pre class="source-code">
const model = mtlLoader.loadAsync('/assets/models/butterfly/
  butterfly.mtl').then((materials) =&gt; {
  objLoader.setMaterials(materials)
  return objLoader.loadAsync('/assets/models/butterfly/
    butterfly.obj').then((model) =&gt; {
    model.scale.set(30, 30, 30)
    visitChildren(model, (child) =&gt; {
      // if there are already normals, we can't merge 
        vertices
      child.geometry.deleteAttribute('normal')
      child.geometry = BufferGeometryUtils.
        mergeVertices(child.geometry)
      child.geometry.computeVertexNormals()
      child.material.opacity = 0.1
      child.castShadow = true
    })
    const wing1 = model.children[4]
    const wing2 = model.children[5]
    [0, 2, 4, 6].forEach(function (i) { 
      model.children[i].rotation.z = 0.3 * Math.PI })
    [1, 3, 5, 7].forEach(function (i) { 
      model.children[i].rotation.z = -0.3 * Math.PI })
    wing1.material.opacity = 0.9
    wing1.material.transparent = true
    wing1.material.alphaTest = 0.1
    wing1.material.side = THREE.DoubleSide
    wing2.material.opacity = 0.9
    wing2.material.depthTest = false
    wing2.material.transparent = true
    wing2.material.alphaTest = 0.1
    wing2.material.side = THREE.DoubleSide
    return model
  })
})</pre>
			<p>The first thing to mention before we look at the code is that if you receive an <strong class="source-inline">OBJ</strong> file, an <strong class="source-inline">MTL</strong> file, and the required texture files, you’ll have to check how the <strong class="source-inline">MTL</strong> file references the textures. These should be referenced relative to the <strong class="source-inline">MTL</strong> file and not as an absolute path. The code itself isn’t that different than the one we saw for <strong class="source-inline">THREE.ObjLoader</strong>. The first thing we do is load the <strong class="source-inline">MTL</strong> file with a <strong class="source-inline">THREE.MTLLoader</strong> object and the loaded materials are set in <strong class="source-inline">THREE.ObjLoader</strong> through the <span class="No-Break"><strong class="source-inline">setMaterials</strong></span><span class="No-Break"> function.</span></p>
			<p>The model we’ve <a id="_idIndexMarker749"/>used <a id="_idIndexMarker750"/>as an example, in this case, is complex. So, we set some specific properties in the callback to fix a number of rendering issues, <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We needed to merge the vertices in the model so that it is rendered as a smooth model. For this, we first needed to remove the already defined <strong class="source-inline">normal</strong> vectors from the loaded model so that we could use the <strong class="source-inline">BufferGeometryUtils.mergeVertices</strong> and <strong class="source-inline">computeVertexNormals</strong> functions to provide Three.js with the information to correctly render <span class="No-Break">the model.</span></li>
				<li>The opacity in the source files was set incorrectly, which caused the wings to be invisible. So, to fix that, we set the <strong class="source-inline">opacity</strong> and <strong class="source-inline">transparent</strong> <span class="No-Break">properties ourselves.</span></li>
				<li>By default, Three.js only renders one side of an object. Since we look at the wings from two sides, we needed to set the <strong class="source-inline">side</strong> property to the <span class="No-Break"><strong class="source-inline">THREE.DoubleSide</strong></span><span class="No-Break"> value.</span></li>
				<li>The wings caused some unwanted artifacts when they needed to be rendered on top of one another. We fixed that by setting the <span class="No-Break"><strong class="source-inline">alphaTest</strong></span><span class="No-Break"> property.</span></li>
			</ul>
			<p>But as you can see, you can easily load complex models directly into Three.js and render them in real time in your browser. You might need to fine-tune various material <span class="No-Break">properties, though.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Loading a gLTF model</h2>
			<p>We<a id="_idIndexMarker751"/> already mentioned that glTF is a great format to use when importing data in Three.js. Just to show you how easy it is to import and show even complex scenes, we’ve added an example where we just took a model <span class="No-Break">from </span><a href="https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d"><span class="No-Break">https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/Figure_8.9_B18726.jpg" alt="Figure 8.9 – Complex 3D scene loaded from glTF with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Complex 3D scene loaded from glTF with Three.js</p>
			<p>As you can see from the previous screenshot, this isn’t a simple scene but a complex one, with lots of models, textures, shadows, and other elements. To get this in Three.js, all we had to do <span class="No-Break">was this:</span></p>
			<pre class="source-code">
const loader = new GLTFLoader()
return loader.loadAsync('/assets/models/sea_house/
  scene.gltf').then((structure) =&gt; {
  structure.scene.scale.setScalar(0.2, 0.2, 0.2)
  visitChildren(structure.scene, (child) =&gt; {
    if (child.material) {
      child.material.depthWrite = true
    }
  })
  scene.add(structure.scene)
})</pre>
			<p>You’re <a id="_idIndexMarker752"/>already familiar with the async loader, and the only thing we needed to fix was to make sure the <strong class="source-inline">depthWrite</strong> property of the materials was set correctly (this seems to be a common issue with some glTF models). And that’s it—it just works. glTF also allows us to define animations, which is something we’ll look at a bit closer in the <span class="No-Break">next chapter.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Showing complete LEGO models</h2>
			<p>Besides <a id="_idIndexMarker753"/>3D models, where the model defines the vertices, materials, lights, and more, there are also various file formats that don’t explicitly define the geometries but have more specific usage. The <strong class="source-inline">LDrawLoader</strong> loader, which we’ll be looking at in this section, was created to render LEGO models in 3D. Using this loader works in the same way as we’ve already seen a couple <span class="No-Break">of times:</span></p>
			<pre class="source-code">
loader.loadAsync('/assets/models/lego/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd').'/assets/models/lego/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'.then((model) =&gt; {
  model.scale.set(0.015, 0.015, 0.015)
  model.rotateZ(Math.PI)
  model.rotateY(Math.PI)
  model.translateY(1)
  visitChildren(model, (child) =&gt; {
    child.castShadow = true
    child.receiveShadow = true
  })
  scene.add(model))
})</pre>
			<p>And the<a id="_idIndexMarker754"/> results look <span class="No-Break">really great:</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/Figure_8.10_B18726.jpg" alt="Figure 8.10 – LEGO Imperial AT-ST model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – LEGO Imperial AT-ST model</p>
			<p>As you can see, it shows the complete structure of a LEGO set. There are many different models out there that you <span class="No-Break">can use:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/Figure_8.11_B18726.jpg" alt="Figure 8.11 – L﻿EGO X-Wing Fighter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – LEGO X-Wing Fighter</p>
			<p>If you <a id="_idIndexMarker755"/>want to explore more models, you can download them from the<a id="_idIndexMarker756"/> LDraw <span class="No-Break">repository: </span><a href="https://omr.ldraw.org/"><span class="No-Break">https://omr.ldraw.org/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Loading voxel-based models</h2>
			<p>Another<a id="_idIndexMarker757"/> interesting approach to creating 3D models is by using voxels. This allows you to build models using small cubes and render them using Three.js. For instance, you can create Minecraft structures outside of Minecraft using such a tool and import them <a id="_idIndexMarker758"/>into Minecraft at a later time. A free tool to experiment with voxels is <a id="_idIndexMarker759"/>MagicaVoxel (<a href="https://ephtracy.github.io/">https://ephtracy.github.io/</a>). This tool allows you to create voxel models such <span class="No-Break">as this:</span></p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/Figure_8.12_B18726.jpg" alt="Figure 8.12 – Example model created with MagicaVoxel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Example model created with MagicaVoxel</p>
			<p>The<a id="_idIndexMarker760"/> interesting part is that you can easily import these models in Three.js using the <strong class="source-inline">VOXLoader</strong> loader, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
new VOXLoader().loadAsync('/assets/models/vox/monu9.vox').then((chunks) =&gt; {
  const group = new THREE.Group()
  for (let i = 0; i &lt; chunks.length; i++) {
    const chunk = chunks[i]
    const mesh = new VOXMesh(chunk)
    mesh.castShadow = true
    mesh.receiveShadow = true
    group.add(mesh)
  }
  group.scale.setScalar(0.1)
  scene.add(group)
})</pre>
			<p>In the <strong class="source-inline">models</strong> folder, you can find a couple of vox models. The following screenshot shows <a id="_idIndexMarker761"/>what it looks like loaded <span class="No-Break">with Three.js:</span></p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/Figure_8.13_B18726.jpg" alt="Figure 8.13 – Vox model loading with Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Vox model loading with Three.js</p>
			<p>The next loader is another very specific one. We’ll look at how to render proteins from <span class="No-Break">PDB format.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Showing proteins from PDB</h2>
			<p>The <a id="_idIndexMarker762"/>PDB website (<a href="http://www.rcsb.org">www.rcsb.org</a>) contains <a id="_idIndexMarker763"/>detailed information about many different molecules and proteins. Besides an explanation of these proteins, it also provides a way to download the structure of these molecules in PDB format. Three.js provides a loader for files specified in the PDB format. In this section, we’ll give an example of how you can parse PDB files and visualize them <span class="No-Break">with Three.js.</span></p>
			<p>With this<a id="_idIndexMarker764"/> loader included, we’re going to create the following 3D model of the molecule description provided (see the <span class="No-Break"><strong class="source-inline">load-pdb.html</strong></span><span class="No-Break"> example):</span></p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/Figure_8.14_B18726.jpg" alt="Figure 8.14 – Visualizing a protein using Three.js and PDBLoader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Visualizing a protein using Three.js and PDBLoader</p>
			<p>Loading a PDB file is done in the same manner as the previous formats, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
PDBLoader().loadAsync('/assets/models/molecules/caffeine.pdb').then((geometries) =&gt; {
  const group = new THREE.Object3D()
  // create the atoms
  const geometryAtoms = geometries.geometryAtoms
  for (let i = 0; i &lt; geometryAtoms.attributes.
    position.count; i++) {
    let startPosition = new THREE.Vector3()
    startPosition.x = geometryAtoms.attributes.
      position.getX(i)
    startPosition.y = geometryAtoms.attributes.
      position.getY(i)
    startPosition.z = geometryAtoms.attributes.position.getZ(i)
    let color = new THREE.Color()
    color.r = geometryAtoms.attributes.color.getX(i)
    color.g = geometryAtoms.attributes.color.getY(i)
    color.b = geometryAtoms.attributes.color.getZ(i)
    let material = new THREE.MeshPhongMaterial({
      color: color
    })
    let sphere = new THREE.SphereGeometry(0.2)
    let mesh = new THREE.Mesh(sphere, material)
    mesh.position.copy(startPosition)
    group.add(mesh)
  }
  // create the bindings
  const geometryBonds = geometries.geometryBonds
  for (let j = 0; j &lt; 
    geometryBonds.attributes.position.count; j += 2) {
    let startPosition = new THREE.Vector3()
    startPosition.x = geometryBonds.attributes.
      position.getX(j)
    startPosition.y = geometryBonds.attributes.position.
      getY(j)
    startPosition.z = geometryBonds.attributes.position.
      getZ(j)
    let endPosition = new THREE.Vector3()
    endPosition.x = geometryBonds.attributes.position.
      getX(j + 1)
    endPosition.y = geometryBonds.attributes.position.
      getY(j + 1)
    endPosition.z = geometryBonds.attributes.position.
      getZ(j + 1)
    // use the start and end to create a curve, and use the 
      curve to draw
    // a tube, which connects the atoms
    let path = new THREE.CatmullRomCurve3([startPosition, 
      endPosition])
    let tube = new THREE.TubeGeometry(path, 1, 0.04)
    let material = new THREE.MeshPhongMaterial({
      color: 0xcccccc
    })
    let mesh = new THREE.Mesh(tube, material)
    group.add(mesh)
  }
  group.scale.set(0.5, 0.5, 0.5)
  scene.add(group)
})</pre>
			<p>As <a id="_idIndexMarker765"/>you can see from this example code, we instantiate a <strong class="source-inline">THREE.PDBLoader</strong> object and pass in the model file we want to load, and once the model is loaded, we process it. In this case, the model consists of two properties: <strong class="source-inline">geometryAtoms</strong> and <strong class="source-inline">geometryBonds</strong>. The position attributes from <strong class="source-inline">geometryAtoms</strong> contain the positions of the individual atoms, and the color attributes can be used to color the individual atoms. For a link between the atoms, <strong class="source-inline">geometryBonds</strong> <span class="No-Break">is used.</span></p>
			<p>Based on the position and color, we create a <strong class="source-inline">THREE.Mesh</strong> object and add it to <span class="No-Break">a group:</span></p>
			<pre class="source-code">
    let sphere = new THREE.SphereGeometry(0.2)
    let mesh = new THREE.Mesh(sphere, material)
    mesh.position.copy(startPosition)
    group.add(mesh)</pre>
			<p>With regard to the connection between the atoms, we follow the same approach. We get the start and end positions of the connection and use those to draw <span class="No-Break">the connection:</span></p>
			<pre class="source-code">
let path = new THREE.CatmullRomCurve3([startPosition, 
  endPosition])
let tube = new THREE.TubeGeometry(path, 1, 0.04)
let material = new THREE.MeshPhongMaterial({
  color: 0xcccccc
})
let mesh = new THREE.Mesh(tube, material)
group.add(mesh)</pre>
			<p>For<a id="_idIndexMarker766"/> the connection, we first create a 3D path using <strong class="source-inline">THREE.CatmullRomCurve3</strong>. This path is used as input for <strong class="source-inline">THREE.TubeGeometry</strong> and is used to create a connection between the atoms. All the connections and atoms are added to a group, and this group is added to the scene. There are many models you can download from PDB. For instance, the following screenshot shows the structure of <span class="No-Break">a diamond:</span></p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/Figure_8.15_B18726.jpg" alt="Figure 8.15 – The structure of a diamond"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – The structure of a diamond</p>
			<p>In the next section, we’re looking at the support Three.js has for the PLY model, which can be used to load point cloud data. </p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Loading a point cloud from a PLY model</h2>
			<p>Working with <a id="_idIndexMarker767"/>the PLY format isn’t that much different than the other formats. You include the loader and handle the loaded model. For this last example, however, we’re going to do something different. Instead of rendering the model as a mesh, we’ll use the information from this model to create a particle system (see the <strong class="source-inline">load-ply.html</strong> example in the <span class="No-Break">following screenshot):</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/Figure_8.16_B18726.jpg" alt="Figure 8.16 – Point cloud loaded from a PLY model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Point cloud loaded from a PLY model</p>
			<p>The JavaScript code to render the preceding screenshot is actually very simple; it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const texture = new THREE.TextureLoader().load('/assets
  /textures/particles/glow.png')
const material = new THREE.PointsMaterial({
  size: 0.15,
  vertexColors: false,
  color: 0xffffff,
  map: texture,
  depthWrite: false,
  opacity: 0.1,
  transparent: true,
  blending: THREE.AdditiveBlending
})
return new PLYLoader().loadAsync('/assets/
  models/carcloud/carcloud.ply').then((model) =&gt; {
  const points = new THREE.Points(model, material)
  points.scale.set(0.7, 0.7, 0.7)
  scene.add(points)
})</pre>
			<p>As you <a id="_idIndexMarker768"/>can see, we use <strong class="source-inline">THREE.PLYLoader</strong> to load the model and use this geometry as input for <strong class="source-inline">THREE.Points</strong>. The material we use is the same as what we used for the last example in <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Points and Sprites</em>. As you can see, with Three.js, it is very easy to combine models from various sources and render them in different ways, all with a few lines <span class="No-Break">of code.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Other loaders</h2>
			<p>At the<a id="_idIndexMarker769"/> beginning of this chapter, in the <em class="italic">Loading geometries from external resources</em> section, we showed you a list of all the different loaders provided by Three.js. We’ve provided examples of all these in the sources <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">chapter-8</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/Figure_8.17_B18726.jpg" alt="Figure 8.17 – Directory showing examples of all the loaders"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Directory showing examples of all the loaders</p>
			<p>The<a id="_idIndexMarker770"/> source code for all these loaders follows the same patterns as we’ve seen for the loaders we have explained in this chapter. Just load the model, determine which part of the loaded model you want to show, make sure scaling and positions are correct, and add it to <span class="No-Break">the scene.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Summary</h1>
			<p>Using models from external sources isn’t that hard to do in Three.js, especially for simple models—you only have to take a few easy steps. </p>
			<p>When working with external models, or creating them using grouping and merging, it is good to keep a couple of things in mind. The first thing you need to remember is that when you group objects, they remain available as individual objects. Transformations applied to the parent also affect the children, but you can still transform the children individually. Besides grouping, you can also merge geometries together. With this approach, you lose the individual geometries and get a single new geometry. This is especially useful when you’re dealing with thousands of geometries you need to render and you’re running into performance issues. The final approach if you want to control a large number of meshes of the same geometry is to use a <strong class="source-inline">THREE.InstancedMesh</strong> object or a <strong class="source-inline">THREE.InstancedBufferGeometry</strong> object, which allows you to position and transform the individual meshes, but still get <span class="No-Break">great performance.</span></p>
			<p>Three.js supports a large number of external formats. When using these format loaders, it’s a good idea to look through the source code and add <strong class="source-inline">console.log</strong> statements to determine what the data loaded really looks like. This will help you to understand the steps you need to take to get the correct mesh and set it to the correct position and scale. Often, when the model doesn’t show correctly, this is caused by its material settings. It could be that incompatible texture formats are used, opacity is incorrectly defined, or the format contains incorrect links to the texture images. It is usually a good idea to use a test material to determine whether the model itself is loaded correctly and log the loaded material to the JavaScript console to check for <span class="No-Break">unexpected values.</span></p>
			<p>If you want to reuse your own scenes or models, you can simply export these by just calling the <strong class="source-inline">asJson</strong> function and loading them again <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ObjectLoader</strong></span><span class="No-Break">.</span></p>
			<p>The models you worked with in this chapter, and in the previous chapters, are mostly static models. They aren’t animated, don’t move around, and don’t change shape. In <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, you’ll learn how you can animate your models to make them come to life. Besides animations, the next chapter will also explain the various camera controls provided by Three.js. With a camera control, you can move, pan, and rotate the camera around <span class="No-Break">your scene.</span></p>
		</div>
	</body></html>