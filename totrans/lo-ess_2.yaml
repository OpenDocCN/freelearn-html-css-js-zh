- en: Chapter 2. Working with Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in JavaScript is an object. This includes functions, arrays, and
    strings. There's also the notion of a plain object—a dictionary of key-value pairs.
    This latter structure is useful when you need support with looking up values by
    a key. In other words, something that a programmer would likely want to read—instead
    of a numerical index found in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of APIs return JSON data—you'll often find plain objects. While you can
    achieve much using JavaScript objects on their own, Lo-Dash makes life easier
    for doing common things with objects. These functions make the mundane a little
    less boring as you'll soon find out, you can often find a less verbose approach
    to working with objects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to plain object access and manipulation, Lo-Dash has several utility
    functions that can be applied to any object in your code. These are mostly concerned
    with validating the type of object you're working with, a duplicitous task using
    Vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining an object type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning and accessing properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and cloning objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining an object type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at how type validation is typically handled in JavaScript
    and how the type-checking functions in Lo-Dash improve the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Type coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type coercion happens in JavaScript when one object is compared to another.
    That is, we have one object operand, the operator, and the second object operand.
    Depending on the operation being performed, the second object might be coerced
    into a representation that is compatible with the first operand. Take the following
    operation, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These are obviously different objects representing different primitive types.
    In the spirit of loosely typed programming, this expression triggers type coercion.
    The first operator is a Boolean value and the second operator is a number. The
    `==` equality operator will take the Boolean representation of `1` and compare
    it with `true`. This is why, this expression always evaluates to `true`. The values
    are *roughly* equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can avoid type coercion using the strict equality operator. The following
    expression will evaluate to `false` since the two operators are compared in their
    raw forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So why turn off type coercion? This seems like a useful tool. Well, it's useful
    when you don't care about certain things. For example, the previous chapter introduced
    you to the concept of truthy and falsey values—things that are roughly true or
    are roughly false. Here, type coercion is your friend because it captures a range
    of possible values, instead of having to strictly check for equality for a number
    of possible values. In short, type coercion exists to make your life easier by
    writing less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are times, however, where type coercion doesn''t help at all, and can
    instead introduce insidious bugs that are painful to track down. For example,
    let''s negate some values with the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These all evaluate to `true` and this fact can be problematic to our code. Especially,
    the fact that an object can have a missing property, and this will evaluate to
    the same thing as a defined property with a `false` or `0` value. Again, it helps
    you to be explicit in these scenarios and turn off type coercion using the strict
    equality/inequality operator.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the point of all this and what does it have to do with Lo-Dash? The
    preceding expressions are just a small sampling of the literally thousands of
    edge cases and issues that can come about when different types of objects interact
    in our application. Lo-Dash aims to reduce some of these complexities by providing
    consistent behavior. Internally, Lo-Dash has to perform all kinds of ugly type
    comparisons and checks so that we don't have to perform them. As an added bonus,
    these utility functions are exposed in the Lo-Dash API.
  prefs: []
  type: TYPE_NORMAL
- en: Managing function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's not always clear what kind of arguments our functions will be called with.
    Nor is it enforced that the number of arguments specified in our function declaration
    match the number supplied by the caller—these are called **variadic** functions.
    The type-checking facility provided by Lo-Dash can better prepare your functions
    to handle anything that's thrown in their way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can explicitly check each function argument in order to determine
    what''s being passed to your function. In the case of optional arguments, you
    can use these functions to explicitly check whether anything was passed as an
    argument at all, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `name` parameter isn't a string, it isn't anything else, in other words,
    the function does nothing. This is the case in the preceding code, in the second
    call to `hello()`. Rather than doing nothing, we can have some other recourse
    built into your function, but that's specific to what our function does. The point
    is that we're conscientious of what might get passed our way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variation on whether an argument is present or not, in a function call, is
    the order in which the arguments are passed. You can ignore the last parameter
    because its value is undefined and it''s optional anyway. However, what if our
    function takes three parameters and the second one is optional? We have to juggle
    the arguments and their values inside our function. A lot of libraries do this
    and Lo-Dash simplifies matters with its type-checking functions, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `hello()` function expects a `greeting` string and a `person` object.
    It turns out that the `greeting` parameter is actually optional but it's the first
    parameter. So the function checks whether `greeting` is actually a plain object,
    signaling that the `greeting` string was omitted. Then, you just make sure that
    `person` is assigned the value of `greeting`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All these type-checking operations can actually be done using Vanilla JavaScript.
    On the other hand, there are nuances to doing this because of JavaScript's esoteric
    type system. Lo-Dash just takes the common things that you don't have to check
    yourself and exposes them as easy-to-decipher function names.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve ever done arithmetic in your JavaScript application, you know that
    using the wrong types as operands can lead to some truly puzzling results. For
    example, the following expressions might or might not look familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The gist of the matter is that when these guys rear their heads, it''s generally
    not a good sign. This can happen as a result of our own function code (under heavy
    development and not in production, obviously) or it would just be that our function
    is getting called with bad data. In either scenario, we need to be prepared to
    troubleshoot what''s happening. We do this by providing a safety net for our arithmetical
    operations, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code iterates over the operands and checks whether each operand is finite
    using the `isFinite()` Lo-Dash function. This function can be thought of as a
    catch-all; if this test passes, then you're generally safe to perform arithmetic
    using the operand. The `else` code runs if `isFinite()` fails, and it's an attempt
    to find a reason for the failure. If it's not a number, then it's obviously not
    finite. This will include values such as `true`, `String`, or `null`. On the other
    hand, if it is a number that's not finite, we know that we're dealing with infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NaN` is actually a number—the JavaScript type system at its best. That''s
    why the `if` statement in the preceding code has a check for `!_.isNumber()` or
    `_.isNaN()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Callable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve ever tried to invoke something that''s not a function, you''ve probably
    seen an error message along the lines of `TypeError: undefined is not a function`.
    In this case, the property or variable doesn''t exist at all. However, we''ll
    get an error message along the same lines if we try to call an object that exists,
    but is not callable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes this error is desirable, as our code is trying to call something
    that''s not a function. The solution: we go and fix it. Remember that JavaScript
    is dynamically typed, and depending on how our application is designed, there
    could be circumstances where you need to explicitly check whether something is
    a function before trying to call it, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first property, `a`, is a function, so the check issued by calling `isFunction()`
    passes, and the function is invoked. The `b` property, on the other hand, is an
    array and is not callable. So nothing happens there.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning and accessing properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating new JavaScript objects with values assigned to them is a straightforward
    task. The tedious part is when we have to merge the contents of one object into
    another or when we have to ensure that the default values are populated for the
    new objects. Locating values in objects and validating whether a key exists or
    not would actually require a significant amount of code were it not for the Lo-Dash
    tools that help us with these activities.
  prefs: []
  type: TYPE_NORMAL
- en: Extending objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common pattern in JavaScript libraries is to extend objects with other objects
    to assign property values. This can be done by assigning one property to an object
    on a statement-by-statement basis. The trouble with this approach is that you
    need to know ahead of time, exactly, which properties are going to be assigned
    to the destination object. Consider when new values come from a function argument.
    Having to know ahead of time all the possible properties these argument values
    might have isn''t feasible. It''s easier to just take what''s passed as the source
    and extend the destination with it. That''s why you''ll find this pattern everywhere,
    including Lo-Dash. These tools are exposed for you to follow the same pattern
    in your application. An example for this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the destination is the `object` variable and it gets the `occupation`
    property assigned to it. In fact, using `assign()`, we have to be careful because
    it pays no attention to the existing properties. Any sources passed in will override
    them, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Two objects are assigned to the destination, `object1`. The `assign()` function
    takes as many arguments as you need to pass—they're all chained together, from
    left to right, successively overriding the previous properties. In the preceding
    code, for example, there are no new objects being assigned that override the `name`
    property. The second object, though, overrides the `age` property. The final object
    has a brand new property and is simply added to the destination. Note that the
    final object is `object1`, which is modified in place.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lo-Dash uses aliases for some of its functions. For example, `extend()` is simply
    an alias for `assign()`; it does the exact same thing. It's a matter of personal
    taste, which one gets used. Do you prefer to think of an object being *assigned*
    to another or to think of one object *extending* another?
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve dealt with simple properties that override one another, but
    what about more complex properties, such as objects and arrays? Would we like
    these values to merge together instead of being completely overridden? Here''s
    an example showing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `merge()` function will recursively examine the object's properties before
    overriding them, unlike the `assign()` function. In other respects, the two functions
    are similar, we're copying the properties of one or more objects to a single destination
    object. Notice the `states` property—it doesn't get overridden. Instead, `merge()`
    will examine the two objects and merge them together. Other types that already
    exist in the destination, with the same property name, are simply overridden.
    This includes arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're able to pass in your own callback function to `merge()`. This
    function determines how to merge properties. The code checks whether the destination
    property and the source property are arrays. If so, concatenate the source to
    the destination, otherwise it'll be overridden. The callback will ignore anything
    that's not an array.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults for new objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common practice in JavaScript programming is to customize properties through
    arguments. That is, when we create a new object instance, we might supply an argument
    that''s unique to the context where the object is being used. However, to use
    this pattern effectively, we have to provide some default values when the caller
    doesn''t supply any values. There are a number of ways to do this, but Lo-Dash
    provides a function that will handle the vast majority of cases, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `name` property isn't overridden with the default values.
    The other two defaults, `age` and `occupation`, are assigned to the object because
    they're undefined. If the property exists with any other value, `defaults()` will
    use that, and not the default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `defaults()` function actually uses the `assign()` function. It just passes
    `assign()`, a callback function that customizes the way defaults are assigned.
    Namely, by looking for undefined values.
  prefs: []
  type: TYPE_NORMAL
- en: Finding keys and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects, in Vanilla JavaScript, use the same syntax as arrays for accessing
    property values. That is, the square bracket notation but typically with a human-readable
    string, instead of a numerical index. However, the same issues that exist with
    numerical indices and arrays exist with objects and keys too. Just because the
    key is a string doesn't mean that we know which keys are available. Sometimes,
    we have to search the object to find the key we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `findKey()` function to locate the key of the first object property
    that callback returns truthy for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the result is `name`; since it''s the first property value our callback
    to `findKey()` returns `true` for. Strangely enough, the pluck style shorthand
    doesn''t work the way you think it might. Calling `_.findKey(object, ''Gene'')`
    doesn''t find anything. That''s because it''s treating each of the property values
    as nested objects. Here''s an example of how the where style shorthand works with
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, it treats each property value as though it''s another object;
    these are the values the `where` criteria is tested against. We can also find
    the key of object properties that have array values using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The callback function passed to `findKey()` checks whether the property value
    is an array. If so, it checks whether the value exists inside it. Otherwise, it'll
    just perform a strict value comparison. Since the `search` term exists in the
    first property value, the resulting key will be `Maria`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `findKey()` function has a complementary function called `findLastKey()`.
    This simply searches in the opposite direction. It's kind of like `find()` and
    `findLast()` for collections. The difference is that the order is preserved in
    arrays. With objects, you're working with an unordered collection of key-value
    pairs. Since the order is never guaranteed, `findLastKey()` is limited in usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might find ourselves working with an object, but we don''t necessarily have
    a use for the keys. Remember that objects are also collections, so you can still
    use `find()` or `where()` as you would on arrays, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These functions treat each `object` property value as though they were an element
    of an array, ignoring the key. Next, we'll look at iterating through objects for
    cases when simple collection shorthands don't suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lo-Dash has a few functions that are useful when we need to iterate over the
    properties of an object in order to fulfill the behavior of our component. We'll
    start off by exploring some basic iterations. Then, we'll look at how to iterate
    over inherited object properties, followed by looking at keys and values and simple
    approaches to iterating over them.
  prefs: []
  type: TYPE_NORMAL
- en: Basic For Each
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we saw in the previous chapter, objects can be iterated, just as arrays—they''re
    both collections. While the mechanism to do so is slightly different, Lo-Dash
    abstracts those differences away behind a unified function API, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should look somewhat familiar. It's just like the `forEach()`
    function. Instead of the index, the second argument passed to the callback function
    is the property key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `_.forOwn()` and `_.forEach()` functions behave identically when applied
    to an object. Both of these functions share the same base function that's used
    to iterate over collections. Lo-Dash has several base functions that are generic
    enough to serve many purposes. While these aren't exposed as a part of the public
    API, they make the exposed functions smaller and more comprehensible.
  prefs: []
  type: TYPE_NORMAL
- en: Including inherited properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object iterations only include *own* properties. That is, properties defined
    directly on the object and not elsewhere higher up in the **prototype chain**.
    We can test that the property in question is an owned property using the `hasOwnProperty()`
    method. We pass this method the name of the property we're looking for and it'll
    return `true` if the property is defined on this property and not further up in
    the prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the term prototype chain sounds foreign, you might want to read about what
    they are and how they work. JavaScript objects are prototypical, so understanding
    this concept is important if you're a JavaScript programmer. This topic goes way
    beyond the scope of this book, but there are literally hundreds of excellent resources
    on prototypes available online. You don't need a full understanding of the topic
    for this book, just this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lo-Dash has another object iteration function called `forIn()`. This function
    has the ability to iterate over both the owned properties, and over properties
    inherited through the prototype chain. An example for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code uses both the forms of object iteration, `forOwn()`, followed by `forIn()`.
    The difference between the two is the `full` key, which only appears in the result
    generated by `forIn()`. That's because it's defined in the `Person` object, which
    is the prototype of `Employee`.
  prefs: []
  type: TYPE_NORMAL
- en: Keys and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we've been working with Lo-Dash functions that directly iterate
    over the object's keys and values. This is the direct route. However, what if
    we've already written some code that's expecting an array of keys or values? There's
    an indirect route to iterating over objects that involves fetching the object's
    keys or its values as an array. You then iterate those.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s some code that will iterate over an object''s keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding result is an array of strings built by the `keys()` function.
    We use the `sortBy()` function as a quick-and-dirty means to sort the array. Each
    property key is then pushed, in order, into the `result` array. Let''s build this
    example and use it as a means to gain ordered access to object property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code takes a bit of a shortcut. However, isn't that what writing good code
    is all about? Instead of employing the `forEach()` function to iterate the keys
    once they've been sorted, we simply pass them to the `at()` function. This function
    accepts an array of keys or indices and will look up the values for us, in order.
    The preceding result is an array of property values, sorted by their keys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `keys()` function plays a vital role in the `forOwn()` function used to
    iterate over objects. This function is used to get the object keys, then the keys
    are iterated over, looking up object values. Again, some of the external Lo-Dash
    functions play an essential role internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complementary to `keys()` is `values()` when you really have no use for key
    names. For example, to build an array of object values, you can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point forward, we have an array of values to work with. The keys
    are disregarded completely. For instance, what if we wanted to sort the `object`
    property values by something specific to the value instead of a key, as we saw
    earlier? This can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It's like we're just turning `object` into an array by truncating the keys.
    In fact, replacing `values()` with `toArray()` yields the exact same result. Under
    the hood, `toArray()` actually calls `values()` if an object is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects don't just come with static property values—some of these values are
    callable functions. Functions assigned as an object's property are often referred
    to as methods, since they're generally interacting with the encapsulated state
    of the object to which they belong. Other times, objects are just a convenient
    vehicle for assigning and passing functions around the code. At the end of the
    day, they're just functions assigned to property values and Lo-Dash has some functions
    that assist with finding and calling them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `result()` function when we''re unsure whether a given property
    name is a function or another type. This can simplify our code greatly because
    we don''t need to write code that checks whether the property should be accessed
    like a regular static property value or if the property needs to be invoked. The
    usage of the `result()` function is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the result is always `Brian` and that the invocation of `result()`
    is the same on all the three objects. However, the result is `Brian` for three
    different reasons. The first object has a `name` property whose string value is
    `Brian`. The second object has a `name` property whose value is a function that
    returns the string `Brian`. The third object has no `name` attribute, so the default
    `Brian` value is used. With very little effort on your part, using the `result()`
    function's objects promotes consistency in terms of object property access.
  prefs: []
  type: TYPE_NORMAL
- en: Use `result()` judiciously, otherwise we'll get confused by its constant use
    in our code. In cases where direct property access or direct method invocation
    produces cleaner code, go that route. In cases where consistent results from property
    access presents a problem, and these should be rare, `result()` is our friend.
  prefs: []
  type: TYPE_NORMAL
- en: Finding methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we call a method, we might want to execute some more complex logic than
    a simple default value if the method doesn't exist. For example, we might know
    that a `name()` method exists on some objects, but not on others. Something else
    we know for certain is that there's no `name` property with simple values, so
    the `result()` function doesn't help here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `functions()` function will look through an object and return an array
    of keys whose values are functions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `name()` method is defined as a part of the person's prototype
    and not directly on the `Person` instance. This makes sense if we think about
    it. If the method exists higher up in the prototype chain, it's still callable,
    using the current instance as its context. So we would want those method names
    in the resulting array, and that's what happened here.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we're implementing a feature and the given object we're working with
    just doesn't fit the bill—you need to transform it into a structure that's better
    suited for our needs. There are a handful of functions that are shipped with Lo-Dash
    to help us do this. We can create an array of arrays out of objects, we can pick
    and choose which object properties we want to work with, and we can turn an object
    inside out by inverting its keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Using pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pairs()` function accepts an object argument and generates an array of
    which each element is itself an array, which contains the key and the value. This
    structure can be a lot more convenient to work with under some circumstances.
    An example of this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code iterates over `object`, but before doing so, it calls the `pairs()`
    function. This transforms the object into an array, so the callback to `forEach()`
    gets an item of this array. The `pair` argument is an array, the first element
    is the key, and the second is the value. Using this key-value pair, we can call
    `apply()` on the `format()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we have a generic callback function that's using something
    like the `format()` function, we don't need to pass it specific arguments. As
    it's illustrated here, when passing the `pair` array, you can call `apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: Picking and omitting properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes not every object property is necessary. In the case of extending
    an object with another, it can actually be a harmful exercise—adding properties
    that aren''t needed. Instead, you can use the `pick()` function to choose the
    properties you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The second object in this example has only one property we're interested in,
    `specialty`. As it so happens, only one property is dropped, `employer`. However,
    what we've done here, by picking only what we need to extend our existing object
    with, is rule out the possibility of any unwanted properties causing issues down
    the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we might know exactly what we don''t want from an object.
    The complementary to `pick()` is `omit()` that excludes the specified properties
    from the object, an example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code is the inverse of the example on `pick()`. Instead of using `pick()`
    to specify what we want to have included, we use `omit()` to specify what we want
    excluded from the assignment. Which one we use depends on the requisite knowledge
    we have about the objects and which properties are valuable where.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from providing the names of properties we want to be included or excluded,
    we can provide custom logic that makes the decision in the form of a callback
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code works in the same vein as `compact()` does with collections. Our callback
    is applied to every `object` property value, and if it returns `true`, then that
    value is omitted from the resulting object. Here, we're omitting falsey values
    with the exception of Boolean types.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting keys and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application might define a function that uses `keys()` or `values()` to
    work with an object. However, we might find ourselves in a situation where we
    want that same function to work inversely. That is, if the function uses `keys()`,
    we want it to use `values()`. If it uses `values()`, we want it to use `keys()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than altering the function that''s used everywhere and we know is stable,
    we can simply invert the object using Lo-Dash''s `invert()` function before it''s
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `sortValues()` function is straightforward enough. It accepts an `object`
    argument, uses the `values()` function to build a property value array, then returns
    that array once it's been sorted. If we would like to reuse `sortValues()` on
    the object keys, for whatever reason, we just use `invert()` on the object before
    it's passed. This makes the keys of the object the values. So, when `sortValues()`
    calls the `values()` function, it's actually getting the keys.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and cloning objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last topic of the chapter is that of creating and cloning JavaScript objects.
    We can get by on a day-to-day basis without putting too much thought into creating
    or cloning objects. The `new` keyword or the object literal notation serves us
    just fine. Rarely is there a need to clone objects. However, Lo-Dash nonetheless
    has tools to deal with both of these scenarios when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `create()` function helps us close the gap between functional and object-oriented
    paradigms. It allows us to leverage some crucial functional JavaScript components
    in our objects. Particularly, when it comes to specifying prototypes when creating
    new objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might not sound like a big deal, but it can make for some fun, elaborate
    hacking. Let''s say that we have a collection of objects defined using the literal
    notation. These objects have just straightforward string property values. Let''s
    also say that we have a class that defines some behavior through methods. Using
    the `create()` function, we can pass the property values directly to a new instance
    of that class, so that you can utilize its behavior, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's helpful in the preceding example to think of the `Person` object as a contract
    or an interface. We then bind that contract to each object in the collection using
    the `create()` function. Now, each of these objects in the collection has a `name()`
    method, and we prove this by generating an array of names using the `invoke()`
    function that will invoke the given method name for each item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the same object instance over and over again can lead to repetitive
    code. Especially, if we''re using the object literal syntax. An alternative is
    to extend a new object with the new properties, but that can be problematic if
    we''re trying to duplicate something that''s not a plain object. Lo-Dash has a
    `clone()` function that''s versatile enough to make a copy of just about anything,
    including deeply-nested objects. This versatility comes at a performance cost,
    so use it wisely. An example of using the `clone()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `object1` variable holds a plain object, while the `object2` variable holds
    an instance of the `Person` class, but they're essentially the same things. They
    both have `first` and `last` properties. The `clone1` and `clone2` variables hold
    their respective clones. What's interesting is the assertions we perform next.
    The first one passes because we're just verifying that the string in the original
    `name` property still exists in the cloned property. The second assertion fails,
    and not because the `first` property of the clone doesn't equal `Bruce`. It fails
    because `clone2` isn't an instance of `Person`. Instead, it's an instance of `Object`
    because the `clone()` function doesn't take the necessary steps of setting up
    the appropriate constructor property, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the cloned object not being an instance of the `Person` class, it's
    pretty much the same object and attribute access, and so on. It should still work
    as it would on a plain object. The focus of `clone()` is really about duplicating
    a plain object so as to break the reference to the original. Then it can be manipulated
    without touching the source.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to how we can use Lo-Dash functions to perform sophisticated
    object interactions. We started with the utilities that made reasoning about the
    JavaScript type system a little less painful. Next, we saw how object properties
    can be accessed and assigned in various contexts. Iterating through object properties
    was the next topic, and there's an abundance of tools at your disposal in Lo-Dash
    here. In particular, iterating over only an object's keys or values would require
    a lot of boilerplate code, were it not for the Lo-Dash functions that take care
    of this for us. Transformations take place when we pass an object to a Lo-Dash
    function and it yields a new structure. Like when we're looking for a collection
    of key-value pairs. Picking or omitting properties is a really straightforward
    activity too. We wrapped up the chapter by taking a look at object creation and
    cloning facilities. These help us when we need to bend the rules a little to meet
    the needs of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Through the first two chapters, you've probably noticed that there are a lot
    of functions being defined and used. That's no accident—JavaScript embraces the
    function as a first-class citizen, and Lo-Dash is no different. Functions are
    the focus of the next chapter.
  prefs: []
  type: TYPE_NORMAL
