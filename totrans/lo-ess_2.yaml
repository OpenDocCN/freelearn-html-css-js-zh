- en: Chapter 2. Working with Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用对象
- en: Everything in JavaScript is an object. This includes functions, arrays, and
    strings. There's also the notion of a plain object—a dictionary of key-value pairs.
    This latter structure is useful when you need support with looking up values by
    a key. In other words, something that a programmer would likely want to read—instead
    of a numerical index found in arrays.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，一切都是对象。这包括函数、数组和字符串。还有一个普通对象的观念——键值对的字典。后者结构在需要通过键查找值时很有用。换句话说，这是程序员可能想要读取的东西——而不是数组中找到的数值索引。
- en: Lots of APIs return JSON data—you'll often find plain objects. While you can
    achieve much using JavaScript objects on their own, Lo-Dash makes life easier
    for doing common things with objects. These functions make the mundane a little
    less boring as you'll soon find out, you can often find a less verbose approach
    to working with objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 API 返回 JSON 数据——你经常会发现普通对象。虽然你可以仅使用 JavaScript 对象实现很多功能，但 Lo-Dash 使使用对象进行常见操作变得更加容易。这些函数使日常任务变得不那么无聊，正如你很快就会发现的，你通常可以找到一种更简洁的方法来处理对象。
- en: In addition to plain object access and manipulation, Lo-Dash has several utility
    functions that can be applied to any object in your code. These are mostly concerned
    with validating the type of object you're working with, a duplicitous task using
    Vanilla JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了平面对象的访问和操作之外，Lo-Dash 还提供了一些可以应用于代码中任何对象的实用函数。这些函数主要关注验证你正在处理的对象的类型，这是一个使用纯
    JavaScript 实现的重复性任务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Determining an object type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定对象类型
- en: Assigning and accessing properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的赋值和访问
- en: Iterating over objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历对象
- en: Calling methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法
- en: Transforming objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的转换
- en: Creating and cloning objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和克隆对象
- en: Determining an object type
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定对象类型
- en: In this section, we'll look at how type validation is typically handled in JavaScript
    and how the type-checking functions in Lo-Dash improve the situation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在 JavaScript 中通常如何处理类型验证以及 Lo-Dash 中的类型检查函数如何改进这种情况。
- en: Type coercion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型强制转换
- en: 'Type coercion happens in JavaScript when one object is compared to another.
    That is, we have one object operand, the operator, and the second object operand.
    Depending on the operation being performed, the second object might be coerced
    into a representation that is compatible with the first operand. Take the following
    operation, for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象与另一个对象进行比较时，JavaScript 中会发生类型强制转换。也就是说，我们有一个操作数对象，一个操作符，以及第二个操作数对象。根据要执行的操作，第二个对象可能会被强制转换为与第一个操作数兼容的表示形式。以下是一个示例操作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are obviously different objects representing different primitive types.
    In the spirit of loosely typed programming, this expression triggers type coercion.
    The first operator is a Boolean value and the second operator is a number. The
    `==` equality operator will take the Boolean representation of `1` and compare
    it with `true`. This is why, this expression always evaluates to `true`. The values
    are *roughly* equal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显然是代表不同原始类型的不同对象。在松散类型编程的精神下，这个表达式触发了类型强制转换。第一个操作数是一个布尔值，第二个操作数是一个数字。`==`
    等于操作符会将 `1` 的布尔表示与 `true` 进行比较。这就是为什么这个表达式总是评估为 `true`。这些值*大致上*是相等的。
- en: 'You can avoid type coercion using the strict equality operator. The following
    expression will evaluate to `false` since the two operators are compared in their
    raw forms:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用严格等于操作符来避免类型强制转换。以下表达式将评估为 `false`，因为两个操作数是以其原始形式进行比较的：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So why turn off type coercion? This seems like a useful tool. Well, it's useful
    when you don't care about certain things. For example, the previous chapter introduced
    you to the concept of truthy and falsey values—things that are roughly true or
    are roughly false. Here, type coercion is your friend because it captures a range
    of possible values, instead of having to strictly check for equality for a number
    of possible values. In short, type coercion exists to make your life easier by
    writing less code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么关闭类型强制转换呢？这似乎是一个有用的工具。好吧，当你不在乎某些事情时，它是有用的。例如，上一章向您介绍了真值和假值的概念——那些大致上是真或大致上是假的事物。在这里，类型强制转换是你的朋友，因为它捕捉了一组可能值，而不是必须严格检查许多可能值的相等性。简而言之，类型强制转换的存在是为了通过编写更少的代码来使你的生活更轻松。
- en: 'There are times, however, where type coercion doesn''t help at all, and can
    instead introduce insidious bugs that are painful to track down. For example,
    let''s negate some values with the following expressions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时类型强制转换根本帮不上忙，反而可能引入难以追踪的隐蔽错误。例如，让我们用以下表达式对一些值取反：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These all evaluate to `true` and this fact can be problematic to our code. Especially,
    the fact that an object can have a missing property, and this will evaluate to
    the same thing as a defined property with a `false` or `0` value. Again, it helps
    you to be explicit in these scenarios and turn off type coercion using the strict
    equality/inequality operator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都评估为`true`，这个事实可能会对我们的代码造成问题。特别是，一个对象可以缺少属性，这会评估为与具有`false`或`0`值的定义属性相同。再次强调，在这些情况下，显式操作和关闭类型强制转换使用严格相等/不等运算符是有帮助的。
- en: So, what's the point of all this and what does it have to do with Lo-Dash? The
    preceding expressions are just a small sampling of the literally thousands of
    edge cases and issues that can come about when different types of objects interact
    in our application. Lo-Dash aims to reduce some of these complexities by providing
    consistent behavior. Internally, Lo-Dash has to perform all kinds of ugly type
    comparisons and checks so that we don't have to perform them. As an added bonus,
    these utility functions are exposed in the Lo-Dash API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有这些的目的是什么，它与 Lo-Dash 有什么关系呢？前面的表达式只是大量边缘情况和问题的一个小样本，这些问题可能在我们应用程序中不同类型的对象交互时出现。Lo-Dash
    通过提供一致的行为来减少这些复杂性。内部，Lo-Dash 必须执行各种丑陋的类型比较和检查，这样我们就不必执行它们。作为额外的奖励，这些实用函数在 Lo-Dash
    API 中公开。
- en: Managing function arguments
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理函数参数
- en: It's not always clear what kind of arguments our functions will be called with.
    Nor is it enforced that the number of arguments specified in our function declaration
    match the number supplied by the caller—these are called **variadic** functions.
    The type-checking facility provided by Lo-Dash can better prepare your functions
    to handle anything that's thrown in their way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是清楚我们的函数将以何种类型的参数被调用。我们的函数声明中指定的参数数量也不一定与调用者提供的数量相匹配——这些被称为**可变参数**函数。Lo-Dash
    提供的类型检查功能可以更好地准备你的函数来处理可能抛给它们的任何内容。
- en: 'For example, you can explicitly check each function argument in order to determine
    what''s being passed to your function. In the case of optional arguments, you
    can use these functions to explicitly check whether anything was passed as an
    argument at all, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以显式检查每个函数参数，以确定传递给函数的内容。在可选参数的情况下，你可以使用这些函数显式检查是否传递了任何参数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the `name` parameter isn't a string, it isn't anything else, in other words,
    the function does nothing. This is the case in the preceding code, in the second
    call to `hello()`. Rather than doing nothing, we can have some other recourse
    built into your function, but that's specific to what our function does. The point
    is that we're conscientious of what might get passed our way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`name`参数不是一个字符串，它就不是其他任何东西，换句话说，函数什么都不做。这就是前面代码中在第二次调用`hello()`时的情形。我们与其什么都不做，不如在我们的函数中内置一些其他补救措施，但这取决于我们的函数具体做什么。关键是我们要意识到可能会传递给我们的内容。
- en: 'A variation on whether an argument is present or not, in a function call, is
    the order in which the arguments are passed. You can ignore the last parameter
    because its value is undefined and it''s optional anyway. However, what if our
    function takes three parameters and the second one is optional? We have to juggle
    the arguments and their values inside our function. A lot of libraries do this
    and Lo-Dash simplifies matters with its type-checking functions, as shown in the
    following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，关于是否存在参数的一个变体是参数传递的顺序。你可以忽略最后一个参数，因为它的值是未定义的，而且它本身也是可选的。然而，如果我们的函数接受三个参数，并且第二个是可选的，那会怎样呢？我们不得不在我们的函数内部调整参数及其值。许多库都这样做，Lo-Dash
    通过其类型检查函数简化了这些问题，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `hello()` function expects a `greeting` string and a `person` object.
    It turns out that the `greeting` parameter is actually optional but it's the first
    parameter. So the function checks whether `greeting` is actually a plain object,
    signaling that the `greeting` string was omitted. Then, you just make sure that
    `person` is assigned the value of `greeting`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`hello()` 函数期望一个 `greeting` 字符串和一个 `person` 对象。结果证明，`greeting` 参数实际上是可选的，但它是最先的参数。因此，函数检查
    `greeting` 是否实际上是一个普通对象，这表明省略了 `greeting` 字符串。然后，你只需确保 `person` 被分配了 `greeting`
    的值。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All these type-checking operations can actually be done using Vanilla JavaScript.
    On the other hand, there are nuances to doing this because of JavaScript's esoteric
    type system. Lo-Dash just takes the common things that you don't have to check
    yourself and exposes them as easy-to-decipher function names.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型检查操作实际上都可以使用 Vanilla JavaScript 完成。另一方面，由于 JavaScript 的神秘类型系统，这样做有一些细微差别。Lo-Dash
    只提取那些你不需要自己检查的常见操作，并将它们作为易于理解的函数名暴露出来。
- en: Arithmetic
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术
- en: 'If you''ve ever done arithmetic in your JavaScript application, you know that
    using the wrong types as operands can lead to some truly puzzling results. For
    example, the following expressions might or might not look familiar:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在 JavaScript 应用程序中做过算术运算，你知道使用错误的类型作为操作数可能会导致一些真正令人困惑的结果。例如，以下表达式可能或可能不熟悉：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The gist of the matter is that when these guys rear their heads, it''s generally
    not a good sign. This can happen as a result of our own function code (under heavy
    development and not in production, obviously) or it would just be that our function
    is getting called with bad data. In either scenario, we need to be prepared to
    troubleshoot what''s happening. We do this by providing a safety net for our arithmetical
    operations, as shown:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的关键在于，当这些家伙抬头时，通常不是一个好兆头。这可能是由于我们自己的功能代码（显然是在开发中且未投入生产）导致的，或者仅仅是因为我们的功能被调用时使用了错误的数据。在任一情况下，我们都需要准备好去排查发生的问题。我们通过为我们的算术操作提供一个安全网来实现这一点，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code iterates over the operands and checks whether each operand is finite
    using the `isFinite()` Lo-Dash function. This function can be thought of as a
    catch-all; if this test passes, then you're generally safe to perform arithmetic
    using the operand. The `else` code runs if `isFinite()` fails, and it's an attempt
    to find a reason for the failure. If it's not a number, then it's obviously not
    finite. This will include values such as `true`, `String`, or `null`. On the other
    hand, if it is a number that's not finite, we know that we're dealing with infinity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历操作数，并使用 Lo-Dash 的 `isFinite()` 函数检查每个操作数是否是有限的。这个函数可以被视为一个万用工具；如果这个测试通过，那么你通常可以使用操作数进行算术运算。如果
    `isFinite()` 失败，则执行 `else` 代码，这是尝试找出失败原因的一种尝试。如果它不是一个数字，那么显然它不是有限的。这包括像 `true`、`String`
    或 `null` 这样的值。另一方面，如果它是一个非有限的数字，我们知道我们正在处理无穷大。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`NaN` is actually a number—the JavaScript type system at its best. That''s
    why the `if` statement in the preceding code has a check for `!_.isNumber()` or
    `_.isNaN()`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN` 实际上是一个数字——这是 JavaScript 类型系统的最佳表现。这就是为什么在前面代码中的 `if` 语句有一个对 `!_.isNumber()`
    或 `_.isNaN()` 的检查。'
- en: Callable objects
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: 'If you''ve ever tried to invoke something that''s not a function, you''ve probably
    seen an error message along the lines of `TypeError: undefined is not a function`.
    In this case, the property or variable doesn''t exist at all. However, we''ll
    get an error message along the same lines if we try to call an object that exists,
    but is not callable.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你曾经尝试调用一个不是函数的东西，你可能已经看到了类似 `TypeError: undefined is not a function` 的错误消息。在这种情况下，属性或变量根本不存在。然而，如果我们尝试调用一个存在但不可调用的对象，我们也会得到类似的错误消息。'
- en: 'Sometimes this error is desirable, as our code is trying to call something
    that''s not a function. The solution: we go and fix it. Remember that JavaScript
    is dynamically typed, and depending on how our application is designed, there
    could be circumstances where you need to explicitly check whether something is
    a function before trying to call it, as shown in the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这种错误是期望的，因为我们的代码正在尝试调用一个不是函数的东西。解决方案：我们去修复它。记住，JavaScript 是动态类型的，根据我们的应用程序是如何设计的，可能存在需要在我们尝试调用它之前显式检查某物是否是函数的情况，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first property, `a`, is a function, so the check issued by calling `isFunction()`
    passes, and the function is invoked. The `b` property, on the other hand, is an
    array and is not callable. So nothing happens there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性 `a` 是一个函数，因此调用 `isFunction()` 发出的检查通过，函数被调用。另一方面，`b` 属性是一个数组，不可调用。所以在那里没有发生任何事情。
- en: Assigning and accessing properties
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配和访问属性
- en: Creating new JavaScript objects with values assigned to them is a straightforward
    task. The tedious part is when we have to merge the contents of one object into
    another or when we have to ensure that the default values are populated for the
    new objects. Locating values in objects and validating whether a key exists or
    not would actually require a significant amount of code were it not for the Lo-Dash
    tools that help us with these activities.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '使用值创建新的 JavaScript 对象是一个简单的任务。繁琐的部分在于当我们需要将一个对象的内容合并到另一个对象中，或者当我们需要确保新对象有默认值时。在对象中定位值并验证键是否存在实际上需要大量的代码，如果不是
    Lo-Dash 工具帮助我们完成这些活动的话。 '
- en: Extending objects
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展对象
- en: 'A common pattern in JavaScript libraries is to extend objects with other objects
    to assign property values. This can be done by assigning one property to an object
    on a statement-by-statement basis. The trouble with this approach is that you
    need to know ahead of time, exactly, which properties are going to be assigned
    to the destination object. Consider when new values come from a function argument.
    Having to know ahead of time all the possible properties these argument values
    might have isn''t feasible. It''s easier to just take what''s passed as the source
    and extend the destination with it. That''s why you''ll find this pattern everywhere,
    including Lo-Dash. These tools are exposed for you to follow the same pattern
    in your application. An example for this is shown as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 库中，一个常见的模式是通过其他对象扩展对象以分配属性值。这可以通过逐个语句将一个属性分配给对象来实现。这种方法的麻烦在于你需要提前确切地知道哪些属性将被分配到目标对象中。考虑当新值来自函数参数时。提前知道所有可能的属性值是不切实际的。直接使用传递的源并扩展目标更简单。这就是为什么你会在
    Lo-Dash 中找到这个模式，包括 Lo-Dash。这些工具被公开，以便你在你的应用程序中遵循相同的模式。以下是一个示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, the destination is the `object` variable and it gets the `occupation`
    property assigned to it. In fact, using `assign()`, we have to be careful because
    it pays no attention to the existing properties. Any sources passed in will override
    them, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，目标对象是 `object` 变量，它被分配了 `occupation` 属性。实际上，使用 `assign()`，我们必须小心，因为它不关注现有属性。任何传入的源都将覆盖它们，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Two objects are assigned to the destination, `object1`. The `assign()` function
    takes as many arguments as you need to pass—they're all chained together, from
    left to right, successively overriding the previous properties. In the preceding
    code, for example, there are no new objects being assigned that override the `name`
    property. The second object, though, overrides the `age` property. The final object
    has a brand new property and is simply added to the destination. Note that the
    final object is `object1`, which is modified in place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象被分配到目标 `object1`。`assign()` 函数接受你需要的任何参数——它们按从左到右的顺序依次连接，并覆盖前面的属性。例如，在前面提到的代码中，没有新的对象被分配以覆盖
    `name` 属性。然而，第二个对象覆盖了 `age` 属性。最终对象有一个全新的属性，并简单地添加到目标中。请注意，最终对象是 `object1`，它被就地修改。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lo-Dash uses aliases for some of its functions. For example, `extend()` is simply
    an alias for `assign()`; it does the exact same thing. It's a matter of personal
    taste, which one gets used. Do you prefer to think of an object being *assigned*
    to another or to think of one object *extending* another?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 为其一些函数使用了别名。例如，`extend()` 只是 `assign()` 的别名；它做的是完全相同的事情。这是一个个人喜好问题，哪个被使用。你更喜欢将一个对象视为被
    *分配* 到另一个对象，还是将一个对象视为 *扩展* 另一个对象？
- en: 'So far, we''ve dealt with simple properties that override one another, but
    what about more complex properties, such as objects and arrays? Would we like
    these values to merge together instead of being completely overridden? Here''s
    an example showing this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理了相互覆盖的简单属性，但更复杂的属性，如对象和数组，怎么办？我们是否希望这些值合并在一起而不是完全被覆盖？以下是一个展示这一点的示例：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `merge()` function will recursively examine the object's properties before
    overriding them, unlike the `assign()` function. In other respects, the two functions
    are similar, we're copying the properties of one or more objects to a single destination
    object. Notice the `states` property—it doesn't get overridden. Instead, `merge()`
    will examine the two objects and merge them together. Other types that already
    exist in the destination, with the same property name, are simply overridden.
    This includes arrays.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()` 函数在覆盖属性之前会递归地检查对象的属性，这与 `assign()` 函数不同。在其他方面，这两个函数是相似的，我们正在将一个或多个对象的属性复制到单个目标对象中。注意
    `states` 属性——它没有被覆盖。相反，`merge()` 将检查两个对象并将它们合并在一起。其他在目标中已经存在的、具有相同属性名的类型将被简单地覆盖。这包括数组。'
- en: Notice that we're able to pass in your own callback function to `merge()`. This
    function determines how to merge properties. The code checks whether the destination
    property and the source property are arrays. If so, concatenate the source to
    the destination, otherwise it'll be overridden. The callback will ignore anything
    that's not an array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够将你自己的回调函数传递给 `merge()`。这个函数决定了如何合并属性。代码检查目标属性和源属性是否为数组。如果是，将源数组合并到目标中，否则它将被覆盖。回调将忽略任何不是数组的值。
- en: Defaults for new objects
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新对象的默认值
- en: 'A common practice in JavaScript programming is to customize properties through
    arguments. That is, when we create a new object instance, we might supply an argument
    that''s unique to the context where the object is being used. However, to use
    this pattern effectively, we have to provide some default values when the caller
    doesn''t supply any values. There are a number of ways to do this, but Lo-Dash
    provides a function that will handle the vast majority of cases, as shown in the
    following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 编程中，一个常见的做法是通过参数自定义属性。也就是说，当我们创建一个新的对象实例时，我们可能提供一个在对象被使用的上下文中独特的参数。然而，为了有效地使用此模式，我们必须在调用者没有提供任何值时提供一些默认值。有几种方法可以做到这一点，但
    Lo-Dash 提供了一个函数可以处理绝大多数情况，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, the `name` property isn't overridden with the default values.
    The other two defaults, `age` and `occupation`, are assigned to the object because
    they're undefined. If the property exists with any other value, `defaults()` will
    use that, and not the default.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`name` 属性没有被默认值覆盖。其他两个默认值，`age` 和 `occupation`，被分配给对象，因为它们是未定义的。如果属性存在任何其他值，`defaults()`
    将使用该值，而不是默认值。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `defaults()` function actually uses the `assign()` function. It just passes
    `assign()`, a callback function that customizes the way defaults are assigned.
    Namely, by looking for undefined values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults()` 函数实际上使用了 `assign()` 函数。它只是传递 `assign()`，一个自定义默认值分配方式的回调函数。具体来说，是通过查找未定义的值。'
- en: Finding keys and values
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找键和值
- en: Objects, in Vanilla JavaScript, use the same syntax as arrays for accessing
    property values. That is, the square bracket notation but typically with a human-readable
    string, instead of a numerical index. However, the same issues that exist with
    numerical indices and arrays exist with objects and keys too. Just because the
    key is a string doesn't mean that we know which keys are available. Sometimes,
    we have to search the object to find the key we're looking for.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JavaScript 中，对象访问属性值使用与数组相同的语法。也就是说，使用方括号表示法，但通常使用可读性强的字符串，而不是数值索引。然而，与数值索引和数组存在相同问题的还有对象和键。仅仅因为键是字符串，并不意味着我们知道哪些键是可用的。有时，我们必须搜索对象以找到我们正在寻找的键。
- en: 'We use the `findKey()` function to locate the key of the first object property
    that callback returns truthy for:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `findKey()` 函数来定位第一个对象属性，该属性返回的回调函数为真值：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the result is `name`; since it''s the first property value our callback
    to `findKey()` returns `true` for. Strangely enough, the pluck style shorthand
    doesn''t work the way you think it might. Calling `_.findKey(object, ''Gene'')`
    doesn''t find anything. That''s because it''s treating each of the property values
    as nested objects. Here''s an example of how the where style shorthand works with
    this function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，结果是 `name`；因为它是我们 `findKey()` 回调返回 `true` 的第一个属性值。奇怪的是，pluck 风格的简写方式并不像你想象的那样工作。调用
    `_.findKey(object, 'Gene')` 什么也没找到。那是因为它将每个属性值都视为嵌套对象。以下是一个如何使用此函数的 where 风格简写方式的示例：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, it treats each property value as though it''s another object;
    these are the values the `where` criteria is tested against. We can also find
    the key of object properties that have array values using the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，它将每个属性值视为另一个对象；这些是 `where` 条件所测试的值。我们还可以使用以下代码找到具有数组值的对象属性的键：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The callback function passed to `findKey()` checks whether the property value
    is an array. If so, it checks whether the value exists inside it. Otherwise, it'll
    just perform a strict value comparison. Since the `search` term exists in the
    first property value, the resulting key will be `Maria`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `findKey()` 的回调函数检查属性值是否为数组。如果是，它会检查值是否存在于其中。否则，它将只执行严格的值比较。由于 `search`
    项存在于第一个属性值中，所以结果键将是 `Maria`。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `findKey()` function has a complementary function called `findLastKey()`.
    This simply searches in the opposite direction. It's kind of like `find()` and
    `findLast()` for collections. The difference is that the order is preserved in
    arrays. With objects, you're working with an unordered collection of key-value
    pairs. Since the order is never guaranteed, `findLastKey()` is limited in usefulness.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`findKey()` 函数有一个互补函数叫做 `findLastKey()`。这个函数简单地朝相反方向搜索。它有点像集合中的 `find()` 和
    `findLast()`。区别在于数组中顺序是保留的。在对象中，你正在处理一个无序的键值对集合。由于顺序从未得到保证，`findLastKey()` 的实用性有限。'
- en: 'We might find ourselves working with an object, but we don''t necessarily have
    a use for the keys. Remember that objects are also collections, so you can still
    use `find()` or `where()` as you would on arrays, as shown in the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现自己正在处理一个对象，但我们不一定需要使用键。记住，对象也是集合，所以你仍然可以使用 `find()` 或 `where()`，就像在数组上使用一样，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These functions treat each `object` property value as though they were an element
    of an array, ignoring the key. Next, we'll look at iterating through objects for
    cases when simple collection shorthands don't suffice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将每个 `object` 属性值视为数组的一个元素，忽略键。接下来，我们将探讨在简单集合简写不足以满足需求的情况下如何遍历对象。
- en: Iterating over objects
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历对象
- en: Lo-Dash has a few functions that are useful when we need to iterate over the
    properties of an object in order to fulfill the behavior of our component. We'll
    start off by exploring some basic iterations. Then, we'll look at how to iterate
    over inherited object properties, followed by looking at keys and values and simple
    approaches to iterating over them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要遍历对象的属性以实现组件的行为时，Lo-Dash 有几个函数非常有用。我们将从探索一些基本迭代开始。然后，我们将探讨如何遍历继承的对象属性，接着查看键和值以及遍历它们的简单方法。
- en: Basic For Each
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本遍历
- en: 'Just as we saw in the previous chapter, objects can be iterated, just as arrays—they''re
    both collections. While the mechanism to do so is slightly different, Lo-Dash
    abstracts those differences away behind a unified function API, as shown in the
    following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，对象可以像数组一样迭代——它们都是集合。虽然这样做的方式略有不同，但 Lo-Dash 通过统一的函数 API 抽象掉了这些差异，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code should look somewhat familiar. It's just like the `forEach()`
    function. Instead of the index, the second argument passed to the callback function
    is the property key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来有些熟悉。它就像 `forEach()` 函数一样。传递给回调函数的第二个参数不是索引，而是属性键。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `_.forOwn()` and `_.forEach()` functions behave identically when applied
    to an object. Both of these functions share the same base function that's used
    to iterate over collections. Lo-Dash has several base functions that are generic
    enough to serve many purposes. While these aren't exposed as a part of the public
    API, they make the exposed functions smaller and more comprehensible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于对象时，`_.forOwn()` 和 `_.forEach()` 函数的行为相同。这两个函数共享同一个基础函数，用于遍历集合。Lo-Dash 有几个足够通用的基础函数，可以服务于许多目的。虽然这些函数不是作为公共
    API 的一部分公开的，但它们使得公开的函数更小、更易于理解。
- en: Including inherited properties
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含继承属性
- en: The object iterations only include *own* properties. That is, properties defined
    directly on the object and not elsewhere higher up in the **prototype chain**.
    We can test that the property in question is an owned property using the `hasOwnProperty()`
    method. We pass this method the name of the property we're looking for and it'll
    return `true` if the property is defined on this property and not further up in
    the prototype chain.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对象迭代只包括 *自有* 属性。也就是说，直接在对象上定义的属性，而不是在 **原型链** 更高的地方定义的属性。我们可以使用 `hasOwnProperty()`
    方法来测试所讨论的属性是否是自有属性。我们传递这个方法要查找的属性名称，如果该属性定义在这个属性上而不是原型链的更高处，它将返回 `true`。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the term prototype chain sounds foreign, you might want to read about what
    they are and how they work. JavaScript objects are prototypical, so understanding
    this concept is important if you're a JavaScript programmer. This topic goes way
    beyond the scope of this book, but there are literally hundreds of excellent resources
    on prototypes available online. You don't need a full understanding of the topic
    for this book, just this section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“原型链”这个术语听起来很陌生，你可能想了解一下它们是什么以及它们是如何工作的。JavaScript 对象是原型的，所以如果你是 JavaScript
    程序员，理解这个概念很重要。这个话题远远超出了本书的范围，但网上有数百个关于原型的优秀资源。对于本书，你不需要完全理解这个主题，只需要这一节的内容。
- en: 'Lo-Dash has another object iteration function called `forIn()`. This function
    has the ability to iterate over both the owned properties, and over properties
    inherited through the prototype chain. An example for this is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 有另一个对象迭代函数，称为 `forIn()`。这个函数能够遍历自有属性，以及通过原型链继承的属性。以下是一个示例：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code uses both the forms of object iteration, `forOwn()`, followed by `forIn()`.
    The difference between the two is the `full` key, which only appears in the result
    generated by `forIn()`. That's because it's defined in the `Person` object, which
    is the prototype of `Employee`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码同时使用了对象迭代的形式，`forOwn()` 后跟 `forIn()`。两者之间的区别在于 `full` 键，它只出现在 `forIn()`
    生成的结果中。这是因为它在 `Person` 对象中定义，而 `Person` 对象是 `Employee` 的原型。
- en: Keys and values
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键和值
- en: Previously, we've been working with Lo-Dash functions that directly iterate
    over the object's keys and values. This is the direct route. However, what if
    we've already written some code that's expecting an array of keys or values? There's
    an indirect route to iterating over objects that involves fetching the object's
    keys or its values as an array. You then iterate those.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们一直在使用直接遍历对象键和值的 Lo-Dash 函数。这是直接的方法。然而，如果我们已经编写了一些期望键或值数组的代码，会怎样呢？有一种间接的方法可以遍历对象，这涉及到将对象的键或值作为数组获取。然后你遍历这些数组。
- en: 'For example, here''s some code that will iterate over an object''s keys:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一些遍历对象键的代码：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding result is an array of strings built by the `keys()` function.
    We use the `sortBy()` function as a quick-and-dirty means to sort the array. Each
    property key is then pushed, in order, into the `result` array. Let''s build this
    example and use it as a means to gain ordered access to object property values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结果是 `keys()` 函数构建的字符串数组。我们使用 `sortBy()` 函数作为一种快速而简单的手段来排序数组。然后按照顺序将每个属性键推入
    `result` 数组。让我们构建这个示例，并使用它作为获取对象属性值的有序访问手段：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code takes a bit of a shortcut. However, isn't that what writing good code
    is all about? Instead of employing the `forEach()` function to iterate the keys
    once they've been sorted, we simply pass them to the `at()` function. This function
    accepts an array of keys or indices and will look up the values for us, in order.
    The preceding result is an array of property values, sorted by their keys.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码采取了一些捷径。然而，这不就是编写好代码的全部意义吗？我们不是使用 `forEach()` 函数在排序后迭代键，而是直接将它们传递给 `at()`
    函数。这个函数接受一个键或索引数组，并将按顺序为我们查找值。上述结果是按键排序的属性值数组。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `keys()` function plays a vital role in the `forOwn()` function used to
    iterate over objects. This function is used to get the object keys, then the keys
    are iterated over, looking up object values. Again, some of the external Lo-Dash
    functions play an essential role internally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()` 函数在用于遍历对象的 `forOwn()` 函数中起着至关重要的作用。这个函数用于获取对象键，然后迭代键，查找对象值。再次强调，一些外部
    Lo-Dash 函数在内部起着至关重要的作用。'
- en: 'Complementary to `keys()` is `values()` when you really have no use for key
    names. For example, to build an array of object values, you can use the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你真的不需要键名时，`values()`与`keys()`互补。例如，为了构建一个包含对象值的数组，你可以使用以下代码：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From this point forward, we have an array of values to work with. The keys
    are disregarded completely. For instance, what if we wanted to sort the `object`
    property values by something specific to the value instead of a key, as we saw
    earlier? This can be done using the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，我们有一个值数组可以工作。键被完全忽略。例如，如果我们想根据值的具体属性而不是键来对`object`属性值进行排序，就像我们之前看到的那样，可以使用以下代码：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's like we're just turning `object` into an array by truncating the keys.
    In fact, replacing `values()` with `toArray()` yields the exact same result. Under
    the hood, `toArray()` actually calls `values()` if an object is passed to it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像我们只是通过截断键将`object`转换成一个数组。实际上，用`toArray()`替换`values()`会产生完全相同的结果。在底层，如果传递给`toArray()`的是一个对象，它实际上会调用`values()`。
- en: Calling methods
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法
- en: Objects don't just come with static property values—some of these values are
    callable functions. Functions assigned as an object's property are often referred
    to as methods, since they're generally interacting with the encapsulated state
    of the object to which they belong. Other times, objects are just a convenient
    vehicle for assigning and passing functions around the code. At the end of the
    day, they're just functions assigned to property values and Lo-Dash has some functions
    that assist with finding and calling them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不仅仅包含静态属性值——其中一些值是可调用的函数。作为对象属性的函数通常被称为方法，因为它们通常与它们所属的对象的封装状态进行交互。有时，对象只是方便地在代码中分配和传递函数的一种方式。最终，它们只是被分配给属性值的函数，而Lo-Dash有一些函数可以帮助找到并调用它们。
- en: Getting results
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取结果
- en: 'We can use the `result()` function when we''re unsure whether a given property
    name is a function or another type. This can simplify our code greatly because
    we don''t need to write code that checks whether the property should be accessed
    like a regular static property value or if the property needs to be invoked. The
    usage of the `result()` function is shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不确定给定的属性名是函数还是其他类型时，我们可以使用`result()`函数。这可以极大地简化我们的代码，因为我们不需要编写检查属性是否应该像常规静态属性值那样访问或是否需要调用的代码。`result()`函数的使用在以下代码中显示：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that the result is always `Brian` and that the invocation of `result()`
    is the same on all the three objects. However, the result is `Brian` for three
    different reasons. The first object has a `name` property whose string value is
    `Brian`. The second object has a `name` property whose value is a function that
    returns the string `Brian`. The third object has no `name` attribute, so the default
    `Brian` value is used. With very little effort on your part, using the `result()`
    function's objects promotes consistency in terms of object property access.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到结果始终是`Brian`，并且`result()`在所有三个对象上的调用都是相同的。然而，结果是`Brian`有三个不同的原因。第一个对象有一个字符串值为`Brian`的`name`属性。第二个对象有一个返回字符串`Brian`的函数值的`name`属性。第三个对象没有`name`属性，因此使用了默认的`Brian`值。通过你非常少的努力，使用`result()`函数的对象促进了对象属性访问的一致性。
- en: Use `result()` judiciously, otherwise we'll get confused by its constant use
    in our code. In cases where direct property access or direct method invocation
    produces cleaner code, go that route. In cases where consistent results from property
    access presents a problem, and these should be rare, `result()` is our friend.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 适度地使用`result()`，否则我们会在代码中对其频繁使用而感到困惑。在直接属性访问或直接方法调用产生更简洁代码的情况下，走这条路。在属性访问产生一致结果呈现问题时，这些情况应该很少，`result()`是我们的朋友。
- en: Finding methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找方法
- en: Before we call a method, we might want to execute some more complex logic than
    a simple default value if the method doesn't exist. For example, we might know
    that a `name()` method exists on some objects, but not on others. Something else
    we know for certain is that there's no `name` property with simple values, so
    the `result()` function doesn't help here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用方法之前，如果方法不存在，我们可能想要执行比简单默认值更复杂的逻辑。例如，我们可能知道某些对象上有`name()`方法，但其他对象上没有。我们确定知道的是，没有带有简单值的`name`属性，所以`result()`函数在这里没有帮助。
- en: 'The `functions()` function will look through an object and return an array
    of keys whose values are functions, as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions()`函数会遍历一个对象，并返回一个数组，其中包含值是函数的键，如下面的代码所示：'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that the `name()` method is defined as a part of the person's prototype
    and not directly on the `Person` instance. This makes sense if we think about
    it. If the method exists higher up in the prototype chain, it's still callable,
    using the current instance as its context. So we would want those method names
    in the resulting array, and that's what happened here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`name()`方法被定义为人的原型的一部分，而不是直接在`Person`实例上。如果我们这样考虑，这是有道理的。如果这个方法在原型链的更高处存在，它仍然是可以调用的，使用当前实例作为其上下文。因此，我们希望那些方法名出现在结果数组中，这正是这里发生的情况。
- en: Transforming objects
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换对象
- en: Sometimes, we're implementing a feature and the given object we're working with
    just doesn't fit the bill—you need to transform it into a structure that's better
    suited for our needs. There are a handful of functions that are shipped with Lo-Dash
    to help us do this. We can create an array of arrays out of objects, we can pick
    and choose which object properties we want to work with, and we can turn an object
    inside out by inverting its keys and values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们在实现一个功能，而我们正在处理的对象根本不适合这个用途——你需要将其转换成一个更适合我们需求的结构。Lo-Dash附带了一些函数可以帮助我们做到这一点。我们可以从对象中创建一个数组的数组，我们可以选择我们想要与之工作的对象属性，我们还可以通过反转键和值来翻转对象。
- en: Using pairs
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用成对
- en: 'The `pairs()` function accepts an object argument and generates an array of
    which each element is itself an array, which contains the key and the value. This
    structure can be a lot more convenient to work with under some circumstances.
    An example of this is shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs()`函数接受一个对象参数，并生成一个数组，其中每个元素本身也是一个数组，包含键和值。在某些情况下，这种结构可能会更加方便。以下是一个例子：'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code iterates over `object`, but before doing so, it calls the `pairs()`
    function. This transforms the object into an array, so the callback to `forEach()`
    gets an item of this array. The `pair` argument is an array, the first element
    is the key, and the second is the value. Using this key-value pair, we can call
    `apply()` on the `format()` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历`object`，但在这样做之前，它调用了`pairs()`函数。这把对象转换成了一个数组，因此`forEach()`的回调函数接收这个数组的一个元素。`pair`参数是一个数组，第一个元素是键，第二个是值。使用这个键值对，我们可以对`format()`函数调用`apply()`。
- en: This means that if we have a generic callback function that's using something
    like the `format()` function, we don't need to pass it specific arguments. As
    it's illustrated here, when passing the `pair` array, you can call `apply()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个通用的回调函数，它使用类似`format()`这样的函数，我们不需要传递特定的参数。正如这里所示，当传递`pair`数组时，你可以调用`apply()`。
- en: Picking and omitting properties
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和省略属性
- en: 'Sometimes not every object property is necessary. In the case of extending
    an object with another, it can actually be a harmful exercise—adding properties
    that aren''t needed. Instead, you can use the `pick()` function to choose the
    properties you need:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，并不是每个对象属性都是必要的。在扩展对象时，实际上这可能是一项有害的练习——添加不必要的属性。相反，你可以使用`pick()`函数来选择你需要的属性：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The second object in this example has only one property we're interested in,
    `specialty`. As it so happens, only one property is dropped, `employer`. However,
    what we've done here, by picking only what we need to extend our existing object
    with, is rule out the possibility of any unwanted properties causing issues down
    the line.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第二个对象只有一个我们感兴趣的属性，即`specialty`。碰巧的是，只有一个属性被删除，即`employer`。然而，我们在这里所做的，就是只选择我们需要用来扩展现有对象的内容，从而排除了任何不想要的属性在后续造成问题的可能性。
- en: 'On the other hand, we might know exactly what we don''t want from an object.
    The complementary to `pick()` is `omit()` that excludes the specified properties
    from the object, an example is shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能确切地知道我们不想从一个对象中得到什么。`pick()`的补充是`omit()`，它从对象中排除指定的属性，以下是一个例子：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code is the inverse of the example on `pick()`. Instead of using `pick()`
    to specify what we want to have included, we use `omit()` to specify what we want
    excluded from the assignment. Which one we use depends on the requisite knowledge
    we have about the objects and which properties are valuable where.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是 `pick()` 示例的反面。我们不是使用 `pick()` 来指定要包含的内容，而是使用 `omit()` 来指定要从赋值中排除的内容。我们使用哪一个取决于我们对对象和哪些属性有价值所拥有的必要知识。
- en: 'Aside from providing the names of properties we want to be included or excluded,
    we can provide custom logic that makes the decision in the form of a callback
    using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供我们想要包含或排除的属性名称之外，我们还可以提供自定义逻辑，以回调函数的形式做出决策，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code works in the same vein as `compact()` does with collections. Our callback
    is applied to every `object` property value, and if it returns `true`, then that
    value is omitted from the resulting object. Here, we're omitting falsey values
    with the exception of Boolean types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 `compact()` 在集合上的工作方式相同。我们的回调函数应用于每个 `object` 属性值，如果它返回 `true`，则该值将从结果对象中省略。在这里，我们省略了非真值，除了布尔类型。
- en: Inverting keys and values
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转键和值
- en: Our application might define a function that uses `keys()` or `values()` to
    work with an object. However, we might find ourselves in a situation where we
    want that same function to work inversely. That is, if the function uses `keys()`,
    we want it to use `values()`. If it uses `values()`, we want it to use `keys()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用可能定义了一个使用 `keys()` 或 `values()` 来处理对象的函数。然而，我们可能会遇到想要该函数反向工作的情形。也就是说，如果函数使用
    `keys()`，我们希望它使用 `values()`。如果它使用 `values()`，我们希望它使用 `keys()`。
- en: 'Rather than altering the function that''s used everywhere and we know is stable,
    we can simply invert the object using Lo-Dash''s `invert()` function before it''s
    passed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是改变我们到处使用且已知稳定的函数，我们可以在传递之前简单地使用 Lo-Dash 的 `invert()` 函数来反转对象：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `sortValues()` function is straightforward enough. It accepts an `object`
    argument, uses the `values()` function to build a property value array, then returns
    that array once it's been sorted. If we would like to reuse `sortValues()` on
    the object keys, for whatever reason, we just use `invert()` on the object before
    it's passed. This makes the keys of the object the values. So, when `sortValues()`
    calls the `values()` function, it's actually getting the keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortValues()` 函数相当简单。它接受一个 `object` 参数，使用 `values()` 函数构建属性值数组，然后返回排序后的数组。如果我们想出于某种原因在对象键上重用
    `sortValues()`，我们只需在传递之前对对象使用 `invert()`。这使得对象的键成为值。因此，当 `sortValues()` 调用 `values()`
    函数时，它实际上获取的是键。'
- en: Creating and cloning objects
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和克隆对象
- en: Our last topic of the chapter is that of creating and cloning JavaScript objects.
    We can get by on a day-to-day basis without putting too much thought into creating
    or cloning objects. The `new` keyword or the object literal notation serves us
    just fine. Rarely is there a need to clone objects. However, Lo-Dash nonetheless
    has tools to deal with both of these scenarios when the need arises.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个主题是创建和克隆 JavaScript 对象。在日常工作中，我们通常不需要过多思考就完成了对象的创建或克隆。`new` 关键字或对象字面量记法已经足够满足我们的需求。很少有必要去克隆对象。然而，当需要时，Lo-Dash
    提供了处理这两种情况所需的工具。
- en: Creating objects
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: The `create()` function helps us close the gap between functional and object-oriented
    paradigms. It allows us to leverage some crucial functional JavaScript components
    in our objects. Particularly, when it comes to specifying prototypes when creating
    new objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 函数帮助我们缩小了函数式和面向对象范式之间的差距。它允许我们在对象中利用一些关键的函数式 JavaScript 组件。特别是，当涉及到创建新对象时指定原型。'
- en: 'This might not sound like a big deal, but it can make for some fun, elaborate
    hacking. Let''s say that we have a collection of objects defined using the literal
    notation. These objects have just straightforward string property values. Let''s
    also say that we have a class that defines some behavior through methods. Using
    the `create()` function, we can pass the property values directly to a new instance
    of that class, so that you can utilize its behavior, as shown in the following
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来不是什么大事，但它可以带来一些有趣、复杂的黑客技巧。假设我们使用字面量记法定义了一个对象集合。这些对象具有简单的字符串属性值。再假设我们有一个通过方法定义了一些行为的类。使用
    `create()` 函数，我们可以直接将属性值传递给该类的新实例，以便利用其行为，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's helpful in the preceding example to think of the `Person` object as a contract
    or an interface. We then bind that contract to each object in the collection using
    the `create()` function. Now, each of these objects in the collection has a `name()`
    method, and we prove this by generating an array of names using the `invoke()`
    function that will invoke the given method name for each item in the collection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，将`Person`对象视为一个合约或接口是有帮助的。然后我们使用`create()`函数将这个合约绑定到集合中的每个对象。现在，集合中的每个对象都有一个`name()`方法，我们通过使用`invoke()`函数生成一个名称数组来证明这一点，该函数将调用集合中每个项目的给定方法名称。
- en: Cloning objects
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆对象
- en: 'Creating the same object instance over and over again can lead to repetitive
    code. Especially, if we''re using the object literal syntax. An alternative is
    to extend a new object with the new properties, but that can be problematic if
    we''re trying to duplicate something that''s not a plain object. Lo-Dash has a
    `clone()` function that''s versatile enough to make a copy of just about anything,
    including deeply-nested objects. This versatility comes at a performance cost,
    so use it wisely. An example of using the `clone()` function is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重复创建相同的对象实例可能导致代码重复。特别是，如果我们使用对象字面量语法。一个替代方案是扩展一个新对象以包含新属性，但如果我们要复制的东西不是一个普通对象，这可能会出现问题。Lo-Dash有一个`clone()`函数，足够灵活，可以复制几乎所有东西，包括嵌套对象。这种灵活性是以性能成本为代价的，所以请明智地使用它。以下是如何使用`clone()`函数的示例：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `object1` variable holds a plain object, while the `object2` variable holds
    an instance of the `Person` class, but they're essentially the same things. They
    both have `first` and `last` properties. The `clone1` and `clone2` variables hold
    their respective clones. What's interesting is the assertions we perform next.
    The first one passes because we're just verifying that the string in the original
    `name` property still exists in the cloned property. The second assertion fails,
    and not because the `first` property of the clone doesn't equal `Bruce`. It fails
    because `clone2` isn't an instance of `Person`. Instead, it's an instance of `Object`
    because the `clone()` function doesn't take the necessary steps of setting up
    the appropriate constructor property, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`object1`变量包含一个普通对象，而`object2`变量包含`Person`类的一个实例，但它们本质上是一样的。它们都有`first`和`last`属性。`clone1`和`clone2`变量包含它们各自的克隆。有趣的是，我们接下来执行的断言。第一个断言通过，因为我们只是验证原始`name`属性中的字符串仍然存在于克隆属性中。第二个断言失败，并不是因为克隆的`first`属性不等于`Bruce`。它失败是因为`clone2`不是`Person`的实例。相反，它是一个`Object`的实例，因为`clone()`函数没有采取设置适当构造函数属性等必要步骤。'
- en: Other than the cloned object not being an instance of the `Person` class, it's
    pretty much the same object and attribute access, and so on. It should still work
    as it would on a plain object. The focus of `clone()` is really about duplicating
    a plain object so as to break the reference to the original. Then it can be manipulated
    without touching the source.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了克隆的对象不是`Person`类的实例之外，它几乎与原始对象和属性访问等相同。它应该仍然像在普通对象上那样工作。`clone()`的重点实际上是复制一个普通对象，以便断开与原始对象的引用。然后它可以被操作而不会触及源。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced us to how we can use Lo-Dash functions to perform sophisticated
    object interactions. We started with the utilities that made reasoning about the
    JavaScript type system a little less painful. Next, we saw how object properties
    can be accessed and assigned in various contexts. Iterating through object properties
    was the next topic, and there's an abundance of tools at your disposal in Lo-Dash
    here. In particular, iterating over only an object's keys or values would require
    a lot of boilerplate code, were it not for the Lo-Dash functions that take care
    of this for us. Transformations take place when we pass an object to a Lo-Dash
    function and it yields a new structure. Like when we're looking for a collection
    of key-value pairs. Picking or omitting properties is a really straightforward
    activity too. We wrapped up the chapter by taking a look at object creation and
    cloning facilities. These help us when we need to bend the rules a little to meet
    the needs of our application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了如何使用 Lo-Dash 函数来执行复杂的对象交互。我们从那些让对 JavaScript 类型系统进行推理变得不那么痛苦的工具开始。接下来，我们看到了在各个上下文中如何访问和分配对象属性。遍历对象属性是下一个话题，Lo-Dash
    提供了大量的工具供你使用。特别是，如果我们只想遍历对象的键或值，而不需要编写大量的样板代码，那么 Lo-Dash 函数就帮我们处理了这一点。当我们向 Lo-Dash
    函数传递一个对象时，它会产生一个新的结构，这就是所谓的转换。比如当我们寻找一组键值对时。选择或省略属性也是一个非常直接的活动。我们通过查看对象创建和克隆功能来结束本章。这些功能在我们需要稍微调整规则以满足应用程序需求时非常有帮助。
- en: Through the first two chapters, you've probably noticed that there are a lot
    of functions being defined and used. That's no accident—JavaScript embraces the
    function as a first-class citizen, and Lo-Dash is no different. Functions are
    the focus of the next chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前两章，你可能已经注意到定义和使用了大量函数。这不是偶然的——JavaScript 将函数视为一等公民，Lo-Dash 也是如此。函数将是下一章的重点。
