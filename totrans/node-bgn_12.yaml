- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Persistence with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain how MongoDB works and why it is a great starting
    point for a web application. We will learn how to install MongoDB locally using
    containers with Docker and Docker Compose and also how to use external MongoDB
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how to use Mongoose to interact with MongoDB, and we will migrate
    our application to use MongoDB instead of a JSON file, we will use tests to grant
    that the migration was properly done and we didn’t introduce any regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up MongoDB locally using containers with Docker and Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an **Object–relational mapping** (**ORM**) library such as Mongoose
    to interact with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to migrate our application to use MongoDB instead of a JSON file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test any application using MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use environment variables to store sensitive information and how to load
    them in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be comfortable using MongoDB in your Node.js
    projects, and you will know how to use tests to plan more complicated features
    such as a database migration.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/0CHOQ35c-_Y](https://youtu.be/0CHOQ35c-_Y)
  prefs: []
  type: TYPE_NORMAL
- en: To start working on this chapter, we need to download the project from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: What is MongoDB?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with relational databases, you will find MongoDB very different.
    MongoDB is a document-oriented database, which means that it stores data in documents
    instead of tables. A document is a set of key-value pairs, and it is the basic
    unit of data in MongoDB. Documents are similar to JSON objects, and they are stored
    in a collection. A collection is a group of documents that have the same structure.
    In MongoDB, documents are stored in **Binary JSON** (**BSON**), a binary representation
    of JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A SQL data structure compared to a MongoDB data structure](img/B21678_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – A SQL data structure compared to a MongoDB data structure
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see the difference between a relational database
    and a document-oriented database more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several versions of MongoDB, but the most popular is MongoDB Community
    Server. In our project, we will also use MongoDB Community Server as well, at
    no extra cost to us.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 16*](B21678_16.xhtml#_idTextAnchor416), we will explore more versions
    of MongoDB when we deploy our application to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know more about the different versions of MongoDB, you can check
    out the following link: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explain how to install MongoDB locally using containers
    with Docker and Docker Compose, as well as how to use external MongoDB instances.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to install MongoDB, but we will use Docker Compose to
    install it locally. Docker Compose is a tool for defining and running multi-container
    Docker applications. With Docker Compose, we will be able to run MongoDB and our
    web application in different containers. If you are not familiar with Docker,
    there is a fantastic guide from MongoDB ([https://www.mongodb.com/compatibility/docker](https://www.mongodb.com/compatibility/docker))
    that can help you get a deeper understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t have Docker installed, you can follow the instructions at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/),
    depending on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s check that Docker is installed correctly. Open a terminal and run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the version installed – in my case, 24.0.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check that Docker Compose is installed correctly. Open a terminal
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running MongoDB with a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of Docker is that we can run MongoDB in a container. A container
    is a standard unit of software that packages up code and all its dependencies.
    That way, we can create a MongoDB container and run it on our local machine, and
    we don’t have to install MongoDB locally. When we don’t need the container anymore,
    we can stop it and remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will use Mongo 7.0.0, which is the latest version of MongoDB.
    We will use the official image of MongoDB, which is available on Docker Hub. You
    can find more information about this image at the following link: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run MongoDB in a container, we will use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a container with the name `whispering-database`, and
    it will map port `27017` of the container to port `27017` of the host machine.
    The `-d` flag means that the container will run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the output, the image was not found locally, so it was downloaded
    from Docker Hub. You might get an error, if the port 2701 is already in use, as
    the container can’t take control over. You can easily check this by following
    these steps ([https://kb.vmware.com/s/article/1003971](https://kb.vmware.com/s/article/1003971)).If
    everything goes well, the container is running in the background, so we can check
    that it is running with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stop the container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can remove the container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you removed the container, you can always create a new container again with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running MongoDB with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to running MongoDB with a container is to use Docker Compose.
    Docker Compose is a tool to define and run multi-container Docker applications
    using a YAML file. One of the advantages of using Docker Compose is that we can
    define the configuration of the container in a YAML file, so we don’t have to
    remember the commands to run the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `docker-compose.yml` file with the following content for our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we define a service called `database` that uses the `mongo:7.0`
    image. We also map port `27017` of the container to port `27017` of the host machine.
    Finally, we define a volume called `db-storage` that will be used to store the
    data of the database, so we don’t lose it when we stop the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the container in the background, we have to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Your containers are now ready to use, but you can stop them by running the
    following command in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to include the Docker-related commands
    to the `package.json` as npm scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker commands to package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it is hard to remember the docker compose commands, so we can add
    them to the `package.json` file. Add the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use `npm run infra:start` and `npm run infra:stop` to manage the
    project database on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to connect to MongoDB – using the `mongo` shell or port `27017`.
    In this section, we will explain how to connect to MongoDB using both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can connect to MongoDB using the `mongo` shell with the following command
    if we use Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see now that we are inside the container, as an alternative you can
    use directly the docker compose command to access the container `docker-compose
    exec database /bin/bash`. Now, we can connect to MongoDB with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can access a `mongo` shell directly if needed. In the following
    sections, we will explain how to connect to MongoDB using port `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to install MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don’t want to use Docker Compose, you can install MongoDB locally. You
    can find the instructions for your operating system at the following link: [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can also use MongoDB Atlas ([https://www.mongodb.com/atlas](https://www.mongodb.com/atlas))
    or any other cloud provider that offers MongoDB as a service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have MongoDB running, we can start using it, but first, we need
    to understand how to use secrets in Node.js so that we can pass the connection
    string to the application in a safe mode. So, in the next section, we will explain
    how to load secrets in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: How to load secrets in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will need to connect to MongoDB, so we need to store the connection
    string in a safe place. You should never store secrets in your code; a very common
    practice is to store them in environment variables. In this section, we will explain
    how to load secrets from environment variables in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Environment variables are variables that are set in the environment in which
    the process runs. They are usually set in the operating system, but we can also
    set them in the terminal. We can access the environment variables in Node.js using
    the `process.env` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set an environment variable in the terminal with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can run your application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can set the environment variable in the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows you might need to use a different approach to handle
    environmental variables in the terminal. Read ([https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html))
    for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use a. `.env` file to manage the secrets
    in a more ergonomic way.
  prefs: []
  type: TYPE_NORMAL
- en: The .env file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While using environmental varaibles directly in the terminal is a very common
    practice, it is not very convenient. We can use a file called `.env` to store
    our environment variables. We can create a `.env` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv))
    to load the environment variables from the `.env` file, but it’s worth mentioning
    that Node.js 20.6.0 introduced support for loading environment variables from
    a `.env` file, so we don’t need to use third-party packages anymore ([https://github.com/nodejs/node/releases/tag/v20.6.0](https://github.com/nodejs/node/releases/tag/v20.6.0)).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: We should never commit the `.env` file to the repository because it contains
    secrets. You can include the `.env` file into the `.gitignore` file to avoid commit
    the .env file along the project source code.
  prefs: []
  type: TYPE_NORMAL
- en: dotenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to load environment variables from a `.env` file is to
    use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)).
    We can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can load the environment variables from the `.env` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do it directly using the `--``require` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will explain how to use **Object-Relational Mapping**
    (**ORM**) to interact with MongoDB and how this can make our life easier when
    building a web application for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM – Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use MongoDB directly, but it will require a bigger understanding and
    more code to interact with the database. As the objective of this book is to learn
    Node.js, we will use an ORM to interact with MongoDB. An ORM is a library that
    allows us to interact with a database using objects instead of SQL queries. In
    this section, we will use Mongoose ([https://mongoosejs.com/](https://mongoosejs.com/)).
    Alternatively, you can use MongoDB Node.js Driver, which is the official MongoDB
    driver ([https://docs.mongodb.com/drivers/node/](https://docs.mongodb.com/drivers/node/))
    for Node.js. The official documentation can be found at [https://mongoosejs.com/docs/guide.html](https://mongoosejs.com/docs/guide.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose offers several features that are quite convenient for a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema validation**: We can define the schema of the documents, and Mongoose
    will validate the data before saving it to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: We can define a model for each collection, and we can use it to
    interact with the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**: We can define middleware functions that will be executed before
    or after certain events – for example, we can define a middleware function that
    will be executed before saving a document to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: We can use plugins to extend the functionality of Mongoose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, if you are new to Node.js or MongoDB, you will find Mongoose easier to
    use than MongoDB directly, and there are plenty of tutorials and resources that
    you can use to get used to it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: Mongo has a huge ecosystem, and it might be a bit overwhelming at the beginning,
    but you can find a curated list of awesome MongoDB resources at [https://github.com/ramnes/awesome-mongodb](https://github.com/ramnes/awesome-mongodb).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have MongoDB running and are familiar with the environment variables,
    we can start using Mongoose in our project. In the next section, we will explain
    how to migrate from local file storage to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a web application to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already added MongoDB to our project using Docker Compose and npm commands,
    but we have not started using it yet. In this section, we will migrate a web application
    to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will install the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Managing the secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `.env` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will load the environment variables from the `.env` file with the
    following code into `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have included the `mongoose` package and have connected to MongoDB using
    the `MONGODB_URI` environment variable. We have also included the `PORT` environment
    variable to run the application in a different port.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the database must be running before we open the HTTP server
    connection. This is because we need to connect to the database to retrieve the
    information for our response to the HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the npm scripts to use `dotenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the database is not running, we will see a similar error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, it tells us that it cannot connect to the database; you can generate
    the same errors just by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section we will start to work on the data layer migration.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the data layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to refactor the `store.js` file to use MongoDB instead of a JSON file.
    Just to keep things simple, we will add the schema and model to the same file,
    but this can be changed later when we introduce authentication in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is considered good practice to encapsulate the database-related code in
    specific files, with the idea of providing an interface that can later be used
    by other parts of our code to make changes in the data layer, without the need
    to understand how the data layer is implemented under the hood. This kind of abstraction
    is a very popular solution and will bring you a lot of support if you decide to
    migrate or combine other storage systems in the future. So, we will create a new
    file called `database.js` and explore together in the following paragraphs how
    it is structured and what is achieved in each statement. The file content is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating** **the schema**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the schema, which is the definition of the structure
    of the documents that we are going to store in the database. In our case, we only
    have one field called `message`, which is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating** **the model**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to create the model, which is a class that we use to interact
    with the database. In our case, we will use the `Whisper` model to interact with
    the `whispers` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Transformers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things that we have to do is to remove the `_id` and `__v` fields
    from the response. We can change this behavior globally so that we don’t have
    to do it for every method, using the `toJSON` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we start with the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we move on to the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Refactored methods**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key in this migration is to keep the same interface so that we don’t have
    to change the behavior of the functions that we export. We will use the same data
    I/O, but we will use Mongoose to interact with MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we keep the same input and output in every method (`getAll`,
    `getById`, `create`, `updateById`, `deleteById`), so we don’t have to change the
    behavior of the functions that we export.
  prefs: []
  type: TYPE_NORMAL
- en: This is the effect that we discussed in the previous chapter; we can change
    the implementation of the methods, but we don’t have to change the interface.
    This is the power of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if you want to change the database in the future, you don’t have to
    change the interface of the methods; you just have to change the implementation
    and the code still works. This is because the business logic is not coupled to
    the database interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing the old** **database file**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can remove the `db.json` file because we are not using it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve** **the routes**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used numerical IDs, just to keep the code more simple,
    so now, we need to change the routes to use the MongoDB IDs, which are alphanumerical
    strings. We only need to remove the references to `parseInt` in the `server.js`
    file. The change is from `parseInt(req.params.id)` to `req.params.id`. You can
    even use *Find and Replace* to change all the references to `parseInt` in the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** **the application**'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can just enjoy the migration by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And if you go to `http://localhost:3000`, you can see the application working
    with MongoDB without any change in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are certain that the application is working as expected, but we shouldn’t
    forget to properly test these changes. So, in the next section, we will refactor
    the tests to use MongoDB, and we will be able to move to the next chapter once
    all the tests are passing (green) as the refactor will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our MongoDB integration layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, we have made the migration and everything seems to be running fine, but
    we need to ensure that the tests work as expected. Currently, the tests use the
    filesystem to store data, so we need to change the tests to make them use MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Update the utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will edit the `test/utils.js` file to use MongoDB instead of the filesystem.
    As we are now using MongoDB, we need to load the fixtures in the database to know
    the IDs. So now, the fixtures will keep the same structure, but they will be stored
    and collected in the database using `populateDb` and the new `getFixtures` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can delete the `test/fixtures.js` file because we are not using it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have more tests than the ones that we really need. We can remove
    specific tests for the stores, as they are already covered by the integration
    tests, and we can remove the `test/store.test.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the migration, we need to make some changes in how the tests are
    prepared to be executed. As a database is an external service, we need to control
    certain aspects before we execute the test. For example, we need a proper database
    connection working before we execute any test, as this can be a failure cause
    for the tests but is not related to the code that we are testing. Also, we need
    to be sure that the database has specific data stored in it so that our tests
    can be executed independently multiple times, without polluting the execution
    context between executions with the modifications that we make in the database.
    This can be achieved by adding certain steps before any specific test is executed,
    with methods such as `beforeAll`, `beforeEach`, `afterAll`, and `afterEach`, which
    are part of the Jest methods available to us. Now, let’s update the tests to use
    the new functions. We will update the `test/server.test.js` file to use the new
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will finish updating the test suite cases, as MongoDB
    introduced small differences that we need to take into account when querying data
    in the test context.
  prefs: []
  type: TYPE_NORMAL
- en: Some tests must change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just to keep it simple, for the scope of the book, some tests have to change.
    All the tests that are use store will be refactored as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating or updating whispers, we will check in the database that the
    whispers are stored correctly. In order to properly compare the data, we will
    use the `normalize` function. That way, we can compare the data without the `_id`
    and `__v` fields and in a normalized way, as we do when converting data to JSON
    while sending the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When deleting a whisper, we need to check that the whisper is not in the database
    anymore. Previously, we checked that the database returned `undefined` when not
    found; using MongoDB, we will get `null` instead, so we need to change the test
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As we finished to refactor the tests, it is a great moment to review the testing
    coverage. In this section we will review this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can run the tests and check the coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we have the same coverage as before, but we have removed some tests,
    and the `store.js` file is covered up to 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there is a line that is not covered (*11–12*), in `server.js`.
    In the previous chapter, we added a new route to render the template in `GET /about`,
    but we forgot to add proper tests. So, let’s add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests again, you will see that the line is covered now and the
    coverage has increased to 100%. We can also improve the scoring by removing from
    the coverage report the `tests` folder, which we can do by adding the following
    line to the `jest.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to keep a clear scope on what files you need to track or
    not for your coverage report; otherwise, the code coverage will become just a
    metric that won’t guide you to focus on the most critical application parts. It
    is quite common to read articles about the frustration associated with a 100%
    coverage target, when, in most cases, we don’t need to aim for that big number,
    and we should be clear on what parts of the code don’t need to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter whether you work alone or in a team, having precise metrics will
    increase the developer experience for all the humans involved in a project. As
    you can see, the coverage is now 100%, as we ignored the files that we are not
    planning to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues running the project in this chapter while following
    the steps, or you tried an alternative approach, you can use the `step3` folder
    from the source code that you downloaded at the beginning of the chapter to compare
    and fix possible bugs more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have finished with the migration, it is time to do a recap in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how MongoDB is different from other databases. We
    learned how to install MongoDB locally using containers, with Docker and Docker
    Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored how we can manage sensitive information in our application
    using environment variables and the `dotenv` package. We also learned how to use
    Mongoose to interact with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we migrated our application to use MongoDB instead of a JSON file.
    This gave us the opportunity to properly learn how to refactor and reorganize
    our previous code. This migration also made it easy to maintain and deploy the
    application, as data is stored and queried as an external source. This will help
    us to scale a lot in the future, as we can connect multiple replicas of our backend
    to the same database instance. We also learned how to test our application using
    MongoDB, and we used this testing approach to ensure that the migration was completed
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce authentication and authorization to our
    application. We will use JWT to authenticate users and use middleware to protect
    the routes that require authentication. Also, we will refactor code to use a database
    to store users and use `bcrypt` library to hash the passwords. Finally, multiple
    users will be able to use our application, which will include private whispers.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fireship | MongoDB in 100 Seconds: [https://www.youtube.com/watch?v=-bt_y4Loofg](https://www.youtube.com/watch?v=-bt_y4Loofg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I Would Never Use an ORM, by Matteo Collina: [https://www.youtube.com/watch?v=qfRQ5zhYuJE](https://www.youtube.com/watch?v=qfRQ5zhYuJE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB in 5 Minutes with Eliot Horowitz: [https://www.youtube.com/watch?v=EE8ZTQxa0AM](https://www.youtube.com/watch?v=EE8ZTQxa0AM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB Explained in 10 Minutes | SQL vs NoSQL | Jumpstart: [https://www.youtube.com/watch?v=RGfFpQF0NpE](https://www.youtube.com/watch?v=RGfFpQF0NpE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
