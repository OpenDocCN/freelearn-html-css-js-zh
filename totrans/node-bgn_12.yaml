- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Persistence with MongoDB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain how MongoDB works and why it is a great starting
    point for a web application. We will learn how to install MongoDB locally using
    containers with Docker and Docker Compose and also how to use external MongoDB
    instances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how to use Mongoose to interact with MongoDB, and we will migrate
    our application to use MongoDB instead of a JSON file, we will use tests to grant
    that the migration was properly done and we didn’t introduce any regression.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, here are the main topics that we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How to set up MongoDB locally using containers with Docker and Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an **Object–relational mapping** (**ORM**) library such as Mongoose
    to interact with MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to migrate our application to use MongoDB instead of a JSON file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test any application using MongoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use environment variables to store sensitive information and how to load
    them in Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be comfortable using MongoDB in your Node.js
    projects, and you will know how to use tests to plan more complicated features
    such as a database migration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/0CHOQ35c-_Y](https://youtu.be/0CHOQ35c-_Y)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To start working on this chapter, we need to download the project from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step2` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: What is MongoDB?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with relational databases, you will find MongoDB very different.
    MongoDB is a document-oriented database, which means that it stores data in documents
    instead of tables. A document is a set of key-value pairs, and it is the basic
    unit of data in MongoDB. Documents are similar to JSON objects, and they are stored
    in a collection. A collection is a group of documents that have the same structure.
    In MongoDB, documents are stored in **Binary JSON** (**BSON**), a binary representation
    of JSON documents.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A SQL data structure compared to a MongoDB data structure](img/B21678_12_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – A SQL data structure compared to a MongoDB data structure
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see the difference between a relational database
    and a document-oriented database more clearly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Versions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several versions of MongoDB, but the most popular is MongoDB Community
    Server. In our project, we will also use MongoDB Community Server as well, at
    no extra cost to us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 16*](B21678_16.xhtml#_idTextAnchor416), we will explore more versions
    of MongoDB when we deploy our application to the cloud.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know more about the different versions of MongoDB, you can check
    out the following link: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explain how to install MongoDB locally using containers
    with Docker and Docker Compose, as well as how to use external MongoDB instances.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to install MongoDB, but we will use Docker Compose to
    install it locally. Docker Compose is a tool for defining and running multi-container
    Docker applications. With Docker Compose, we will be able to run MongoDB and our
    web application in different containers. If you are not familiar with Docker,
    there is a fantastic guide from MongoDB ([https://www.mongodb.com/compatibility/docker](https://www.mongodb.com/compatibility/docker))
    that can help you get a deeper understanding.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t have Docker installed, you can follow the instructions at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/),
    depending on your operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Checking the installation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s check that Docker is installed correctly. Open a terminal and run the
    following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the version installed – in my case, 24.0.2:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also check that Docker Compose is installed correctly. Open a terminal
    and run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running MongoDB with a container
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of Docker is that we can run MongoDB in a container. A container
    is a standard unit of software that packages up code and all its dependencies.
    That way, we can create a MongoDB container and run it on our local machine, and
    we don’t have to install MongoDB locally. When we don’t need the container anymore,
    we can stop it and remove it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will use Mongo 7.0.0, which is the latest version of MongoDB.
    We will use the official image of MongoDB, which is available on Docker Hub. You
    can find more information about this image at the following link: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To run MongoDB in a container, we will use the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will create a container with the name `whispering-database`, and
    it will map port `27017` of the container to port `27017` of the host machine.
    The `-d` flag means that the container will run in the background.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should be something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As shown in the output, the image was not found locally, so it was downloaded
    from Docker Hub. You might get an error, if the port 2701 is already in use, as
    the container can’t take control over. You can easily check this by following
    these steps ([https://kb.vmware.com/s/article/1003971](https://kb.vmware.com/s/article/1003971)).If
    everything goes well, the container is running in the background, so we can check
    that it is running with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can stop the container with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And you can remove the container with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you removed the container, you can always create a new container again with
    the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running MongoDB with Docker Compose
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to running MongoDB with a container is to use Docker Compose.
    Docker Compose is a tool to define and run multi-container Docker applications
    using a YAML file. One of the advantages of using Docker Compose is that we can
    define the configuration of the container in a YAML file, so we don’t have to
    remember the commands to run the container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `docker-compose.yml` file with the following content for our
    project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this file, we define a service called `database` that uses the `mongo:7.0`
    image. We also map port `27017` of the container to port `27017` of the host machine.
    Finally, we define a volume called `db-storage` that will be used to store the
    data of the database, so we don’t lose it when we stop the container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the container in the background, we have to run the following
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should be something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Your containers are now ready to use, but you can stop them by running the
    following command in the same folder:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we will learn how to include the Docker-related commands
    to the `package.json` as npm scripts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker commands to package.json
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it is hard to remember the docker compose commands, so we can add
    them to the `package.json` file. Add the following scripts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we can use `npm run infra:start` and `npm run infra:stop` to manage the
    project database on our local machine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to connect to MongoDB – using the `mongo` shell or port `27017`.
    In this section, we will explain how to connect to MongoDB using both ways.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We can connect to MongoDB using the `mongo` shell with the following command
    if we use Docker:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see now that we are inside the container, as an alternative you can
    use directly the docker compose command to access the container `docker-compose
    exec database /bin/bash`. Now, we can connect to MongoDB with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, we can access a `mongo` shell directly if needed. In the following
    sections, we will explain how to connect to MongoDB using port `27017`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to install MongoDB
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don’t want to use Docker Compose, you can install MongoDB locally. You
    can find the instructions for your operating system at the following link: [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can also use MongoDB Atlas ([https://www.mongodb.com/atlas](https://www.mongodb.com/atlas))
    or any other cloud provider that offers MongoDB as a service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have MongoDB running, we can start using it, but first, we need
    to understand how to use secrets in Node.js so that we can pass the connection
    string to the application in a safe mode. So, in the next section, we will explain
    how to load secrets in Node.js.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: How to load secrets in Node.js
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will need to connect to MongoDB, so we need to store the connection
    string in a safe place. You should never store secrets in your code; a very common
    practice is to store them in environment variables. In this section, we will explain
    how to load secrets from environment variables in Node.js.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Environment variables are variables that are set in the environment in which
    the process runs. They are usually set in the operating system, but we can also
    set them in the terminal. We can access the environment variables in Node.js using
    the `process.env` object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can set an environment variable in the terminal with the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you can run your application with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can set the environment variable in the same command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Windows you might need to use a different approach to handle
    environmental variables in the terminal. Read ([https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html))
    for additional information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use a. `.env` file to manage the secrets
    in a more ergonomic way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The .env file
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While using environmental varaibles directly in the terminal is a very common
    practice, it is not very convenient. We can use a file called `.env` to store
    our environment variables. We can create a `.env` file with the following content:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, we can use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv))
    to load the environment variables from the `.env` file, but it’s worth mentioning
    that Node.js 20.6.0 introduced support for loading environment variables from
    a `.env` file, so we don’t need to use third-party packages anymore ([https://github.com/nodejs/node/releases/tag/v20.6.0](https://github.com/nodejs/node/releases/tag/v20.6.0)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We should never commit the `.env` file to the repository because it contains
    secrets. You can include the `.env` file into the `.gitignore` file to avoid commit
    the .env file along the project source code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: dotenv
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to load environment variables from a `.env` file is to
    use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)).
    We can install it with the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can load the environment variables from the `.env` file with the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we can do it directly using the `--``require` flag:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, we will explain how to use **Object-Relational Mapping**
    (**ORM**) to interact with MongoDB and how this can make our life easier when
    building a web application for the first time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM – Mongoose
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use MongoDB directly, but it will require a bigger understanding and
    more code to interact with the database. As the objective of this book is to learn
    Node.js, we will use an ORM to interact with MongoDB. An ORM is a library that
    allows us to interact with a database using objects instead of SQL queries. In
    this section, we will use Mongoose ([https://mongoosejs.com/](https://mongoosejs.com/)).
    Alternatively, you can use MongoDB Node.js Driver, which is the official MongoDB
    driver ([https://docs.mongodb.com/drivers/node/](https://docs.mongodb.com/drivers/node/))
    for Node.js. The official documentation can be found at [https://mongoosejs.com/docs/guide.html](https://mongoosejs.com/docs/guide.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose offers several features that are quite convenient for a web application:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema validation**: We can define the schema of the documents, and Mongoose
    will validate the data before saving it to the database'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: We can define a model for each collection, and we can use it to
    interact with the database'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**: We can define middleware functions that will be executed before
    or after certain events – for example, we can define a middleware function that
    will be executed before saving a document to the database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: We can use plugins to extend the functionality of Mongoose'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, if you are new to Node.js or MongoDB, you will find Mongoose easier to
    use than MongoDB directly, and there are plenty of tutorials and resources that
    you can use to get used to it quickly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Info
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Mongo has a huge ecosystem, and it might be a bit overwhelming at the beginning,
    but you can find a curated list of awesome MongoDB resources at [https://github.com/ramnes/awesome-mongodb](https://github.com/ramnes/awesome-mongodb).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have MongoDB running and are familiar with the environment variables,
    we can start using Mongoose in our project. In the next section, we will explain
    how to migrate from local file storage to MongoDB.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a web application to MongoDB
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already added MongoDB to our project using Docker Compose and npm commands,
    but we have not started using it yet. In this section, we will migrate a web application
    to MongoDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Installing dependencies
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will install the following dependencies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Managing the secrets
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `.env` file with the following content:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will load the environment variables from the `.env` file with the
    following code into `index.js`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have included the `mongoose` package and have connected to MongoDB using
    the `MONGODB_URI` environment variable. We have also included the `PORT` environment
    variable to run the application in a different port.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the database must be running before we open the HTTP server
    connection. This is because we need to connect to the database to retrieve the
    information for our response to the HTTP requests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update the npm scripts to use `dotenv`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can run the application with the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We should see the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the database is not running, we will see a similar error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Basically, it tells us that it cannot connect to the database; you can generate
    the same errors just by running the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section we will start to work on the data layer migration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the data layer
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to refactor the `store.js` file to use MongoDB instead of a JSON file.
    Just to keep things simple, we will add the schema and model to the same file,
    but this can be changed later when we introduce authentication in the next chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'It is considered good practice to encapsulate the database-related code in
    specific files, with the idea of providing an interface that can later be used
    by other parts of our code to make changes in the data layer, without the need
    to understand how the data layer is implemented under the hood. This kind of abstraction
    is a very popular solution and will bring you a lot of support if you decide to
    migrate or combine other storage systems in the future. So, we will create a new
    file called `database.js` and explore together in the following paragraphs how
    it is structured and what is achieved in each statement. The file content is the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Creating** **the schema**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the schema, which is the definition of the structure
    of the documents that we are going to store in the database. In our case, we only
    have one field called `message`, which is a string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Creating** **the model**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to create the model, which is a class that we use to interact
    with the database. In our case, we will use the `Whisper` model to interact with
    the `whispers` collection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Transformers**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things that we have to do is to remove the `_id` and `__v` fields
    from the response. We can change this behavior globally so that we don’t have
    to do it for every method, using the `toJSON` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This means we start with the following data structure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we move on to the following data structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Refactored methods**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The key in this migration is to keep the same interface so that we don’t have
    to change the behavior of the functions that we export. We will use the same data
    I/O, but we will use Mongoose to interact with MongoDB:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we keep the same input and output in every method (`getAll`,
    `getById`, `create`, `updateById`, `deleteById`), so we don’t have to change the
    behavior of the functions that we export.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This is the effect that we discussed in the previous chapter; we can change
    the implementation of the methods, but we don’t have to change the interface.
    This is the power of abstraction.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: So, even if you want to change the database in the future, you don’t have to
    change the interface of the methods; you just have to change the implementation
    and the code still works. This is because the business logic is not coupled to
    the database interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing the old** **database file**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can remove the `db.json` file because we are not using it anymore.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve** **the routes**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used numerical IDs, just to keep the code more simple,
    so now, we need to change the routes to use the MongoDB IDs, which are alphanumerical
    strings. We only need to remove the references to `parseInt` in the `server.js`
    file. The change is from `parseInt(req.params.id)` to `req.params.id`. You can
    even use *Find and Replace* to change all the references to `parseInt` in the
    file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Running** **the application**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can just enjoy the migration by running the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And if you go to `http://localhost:3000`, you can see the application working
    with MongoDB without any change in the interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are certain that the application is working as expected, but we shouldn’t
    forget to properly test these changes. So, in the next section, we will refactor
    the tests to use MongoDB, and we will be able to move to the next chapter once
    all the tests are passing (green) as the refactor will be completed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Testing our MongoDB integration layer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, we have made the migration and everything seems to be running fine, but
    we need to ensure that the tests work as expected. Currently, the tests use the
    filesystem to store data, so we need to change the tests to make them use MongoDB.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Update the utilities
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will edit the `test/utils.js` file to use MongoDB instead of the filesystem.
    As we are now using MongoDB, we need to load the fixtures in the database to know
    the IDs. So now, the fixtures will keep the same structure, but they will be stored
    and collected in the database using `populateDb` and the new `getFixtures` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we can delete the `test/fixtures.js` file because we are not using it anymore.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the test suite
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have more tests than the ones that we really need. We can remove
    specific tests for the stores, as they are already covered by the integration
    tests, and we can remove the `test/store.test.js` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the migration, we need to make some changes in how the tests are
    prepared to be executed. As a database is an external service, we need to control
    certain aspects before we execute the test. For example, we need a proper database
    connection working before we execute any test, as this can be a failure cause
    for the tests but is not related to the code that we are testing. Also, we need
    to be sure that the database has specific data stored in it so that our tests
    can be executed independently multiple times, without polluting the execution
    context between executions with the modifications that we make in the database.
    This can be achieved by adding certain steps before any specific test is executed,
    with methods such as `beforeAll`, `beforeEach`, `afterAll`, and `afterEach`, which
    are part of the Jest methods available to us. Now, let’s update the tests to use
    the new functions. We will update the `test/server.test.js` file to use the new
    functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will finish updating the test suite cases, as MongoDB
    introduced small differences that we need to take into account when querying data
    in the test context.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Some tests must change
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just to keep it simple, for the scope of the book, some tests have to change.
    All the tests that are use store will be refactored as follows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating or updating whispers, we will check in the database that the
    whispers are stored correctly. In order to properly compare the data, we will
    use the `normalize` function. That way, we can compare the data without the `_id`
    and `__v` fields and in a normalized way, as we do when converting data to JSON
    while sending the HTTP response:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When deleting a whisper, we need to check that the whisper is not in the database
    anymore. Previously, we checked that the database returned `undefined` when not
    found; using MongoDB, we will get `null` instead, so we need to change the test
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we finished to refactor the tests, it is a great moment to review the testing
    coverage. In this section we will review this in detail.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Checking the coverage
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can run the tests and check the coverage:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output should be similar:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Basically, we have the same coverage as before, but we have removed some tests,
    and the `store.js` file is covered up to 100%.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, there is a line that is not covered (*11–12*), in `server.js`.
    In the previous chapter, we added a new route to render the template in `GET /about`,
    but we forgot to add proper tests. So, let’s add the following test:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you run the tests again, you will see that the line is covered now and the
    coverage has increased to 100%. We can also improve the scoring by removing from
    the coverage report the `tests` folder, which we can do by adding the following
    line to the `jest.config.js` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It is very important to keep a clear scope on what files you need to track or
    not for your coverage report; otherwise, the code coverage will become just a
    metric that won’t guide you to focus on the most critical application parts. It
    is quite common to read articles about the frustration associated with a 100%
    coverage target, when, in most cases, we don’t need to aim for that big number,
    and we should be clear on what parts of the code don’t need to be tested.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter whether you work alone or in a team, having precise metrics will
    increase the developer experience for all the humans involved in a project. As
    you can see, the coverage is now 100%, as we ignored the files that we are not
    planning to test:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Information
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues running the project in this chapter while following
    the steps, or you tried an alternative approach, you can use the `step3` folder
    from the source code that you downloaded at the beginning of the chapter to compare
    and fix possible bugs more easily.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have finished with the migration, it is time to do a recap in the
    next section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how MongoDB is different from other databases. We
    learned how to install MongoDB locally using containers, with Docker and Docker
    Compose.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored how we can manage sensitive information in our application
    using environment variables and the `dotenv` package. We also learned how to use
    Mongoose to interact with MongoDB.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we migrated our application to use MongoDB instead of a JSON file.
    This gave us the opportunity to properly learn how to refactor and reorganize
    our previous code. This migration also made it easy to maintain and deploy the
    application, as data is stored and queried as an external source. This will help
    us to scale a lot in the future, as we can connect multiple replicas of our backend
    to the same database instance. We also learned how to test our application using
    MongoDB, and we used this testing approach to ensure that the migration was completed
    successfully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce authentication and authorization to our
    application. We will use JWT to authenticate users and use middleware to protect
    the routes that require authentication. Also, we will refactor code to use a database
    to store users and use `bcrypt` library to hash the passwords. Finally, multiple
    users will be able to use our application, which will include private whispers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fireship | MongoDB in 100 Seconds: [https://www.youtube.com/watch?v=-bt_y4Loofg](https://www.youtube.com/watch?v=-bt_y4Loofg)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I Would Never Use an ORM, by Matteo Collina: [https://www.youtube.com/watch?v=qfRQ5zhYuJE](https://www.youtube.com/watch?v=qfRQ5zhYuJE)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB in 5 Minutes with Eliot Horowitz: [https://www.youtube.com/watch?v=EE8ZTQxa0AM](https://www.youtube.com/watch?v=EE8ZTQxa0AM)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB Explained in 10 Minutes | SQL vs NoSQL | Jumpstart: [https://www.youtube.com/watch?v=RGfFpQF0NpE](https://www.youtube.com/watch?v=RGfFpQF0NpE)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10分钟内解释MongoDB | SQL vs NoSQL | 快速入门：[https://www.youtube.com/watch?v=RGfFpQF0NpE](https://www.youtube.com/watch?v=RGfFpQF0NpE)
