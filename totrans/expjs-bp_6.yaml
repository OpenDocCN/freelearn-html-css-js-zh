- en: Chapter 6. Hacker News API on Koa.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build an API to power our own Hacker News! While technically
    this wouldn't be very different from the previous chapters, we will use a different
    framework altogether, Koa.js ([http://koajs.com/](http://koajs.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Koa.js is a new web framework designed by the team behind Express. Why did they
    create a new framework? Because it is designed from the bottom up, with a minimalistic
    core for more modularity, and to make use of the new generator syntax, proposed
    in ECMAScript 6, but already implemented in node 0.11.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The odd version releases of node are considered unstable. At the time of writing,
    the latest stable release was version 0.10\. However, when this book went to print,
    node 0.12 was finally released and is the latest stable version.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to node 0.11 would be io.js, which at the time of writing reached
    version 1.0, and also implements ES6 goodies (forked from Node.js and maintained
    by a handful of node core contributors). In this chapter, we will stick to node
    0.11\. (When this book went to print, node 0.12 was finally released and is the
    latest stable version of node.)
  prefs: []
  type: TYPE_NORMAL
- en: One of the main benefits of the generator syntax is that you can very elegantly
    avoid callback hell, without the use of complicated promise patterns. You can
    write your APIs even more cleanly than ever before. We'll go over the subtleties
    as well as some caveats that come with the bleeding edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generator syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware philosophy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context, versus req,res
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mongoose models in Koa.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thunkify to use Express modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing generator functions with Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel HTTP requests using co-mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering views with koa-render
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve static assets with koa-mount and koa-static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generator functions are at the core of Koa.js, so let's dive right into dissecting
    this beast. Generators allow adept JavaScript users to implement functions in
    completely new ways. Koa.js makes use of the new syntax to write code in a synchronous-looking
    fashion while maintaining the performance benefits of an asynchronous flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following defines a simple generator function in `src/helloGenerator.js`
    (note the asterisk syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Mocha with Koa.js:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include `co-mocha` to add generator support, requiring once
    at the first line of each test file is the safe way to do it. Now you can pass
    generator functions to Mocha''s `it` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to run this code, you will need to have node 0.11 installed, and use
    the `--harmony-generators` flag as you run Mocha:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, congratulations, you have just written your first generator
    function! Now let's explore the execution flow of generator functions a little
    more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the magic use of the `yield` keyword. The `yield` keyword can only be used
    within a `Generator` function, and works somewhat similar to `return`, expecting
    a single value to be passed, that can also be a generator function (also accepts
    other yieldables—more on that later), and yields the process to that function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a `function*` is passed, the execution flow will wait until that function
    returns before it continues further down. In essence, it would be equivalent to
    the following callback pattern:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Much cleaner, right? Compare the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the nasty callback hello if we didn''t have generator functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another neat advantage is super clean error handling, which we will get into
    later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding example is not too interesting because the `helloGenerator()`
    function is a synchronous function anyway, so it would've worked the same, even
    if we didn't use generator functions!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So let''s make it more interesting and change `helloGenerator.js` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait! Your test is failing?! What is going on here? Well, `yield` should have
    given the flow to the `helloGenerator()` function, let it run asynchronously,
    and wait until it is done before continuing. Yet, `ans` is undefined. And nobody
    is lying.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reason why it is undefined is because the `generator()` function returns
    immediately after calling the `setTimeout` function, which is set to `ans`. The
    message that should have returned from within the `setTimeout` function is broadcast
    into the infinite void, nowhere to be seen, ever again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to keep in mind with generator functions is that once you use a generator
    function, you better commit, and not resort to callbacks down the stack! Recall
    that we mentioned that `yield` expects a generator function. The `setTimeout`
    function is not a generator function, so what do we do? The `yield` method can
    also accept a Promise or a Thunk (more on this later).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `setTimeout()` function isn''t a Promise, so we have two options left;
    we can thunkify the function, which basically takes a normal node function with
    a callback pattern and returns a Thunk, so we can yield to it; alternatively,
    we use co-sleep, which is basically a minuscule node package that has done it
    for you as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will talk about how to thunkify later, so let's use `co-sleep`. Generally
    a good idea to reuse what's available is to just do a quick search in the npm
    registry. There are numerous `co` packages out there!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now all should be good; your tests should pass after sleeping for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the `co` library is what''s under the hood of Koa.js, giving it the
    generator-based control flow goodies. If you want to use this sort of flow outside
    Koa.js, you can use something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Middleware philosophy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be familiar by now with the middlewares in Express. We used them
    a lot to dry out code, especially for validation and authentication. In Express,
    middleware is placed between the server that receives the request and the handler
    that responds to a request. The request flows one way, until it terminates at
    `res.send` or something equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Koa.js, everything is a middleware, including the handler itself. As a matter
    of fact, a Koa.js application is just an object, which contains an array of middleware
    generator functions! The request flows all the way down the stack of middlewares,
    and back up again. This is best explained with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a Koa.js application with two middlewares. The first middleware
    adds an `X-Response-Time` header to the response, whereas the second middleware
    simply sets the response body to `Hello` `World` for each request. The flow is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The request comes in on port `3000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first middleware receives the execution flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Date` object is created and assigned to `start`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow yields to the next middleware on the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second middleware sets `body` on the Context to `Hello` `World`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is no more middleware down the stack to be yielding to, the flow
    returns back upstream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first middleware receives the execution flow again and continues down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response time is calculated and the response header is set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request has reached the top and the Context is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Koa.js does not use `req,` `res` anymore; they are encapsulated into a single
    Context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this app, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Context versus req,res
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Koa.js Context is created for each incoming request. Within each middleware,
    you can access the Context using the `this` object. It includes the Request and
    Response object in `this.request` and `this.response`, respectively, although
    most methods and accessors are directly available from the Context.
  prefs: []
  type: TYPE_NORMAL
- en: The most important property is `this.body`, which sets the response body. The
    response status is automatically set to `200` when the response body is set. You
    may override this by setting `this.status` manually.
  prefs: []
  type: TYPE_NORMAL
- en: Another very useful syntactic sugar is `this.throw`, which allows you to return
    an error response by simply calling `this.throw(400)`, or if you want to override
    the standard HTTP error message, you may pass a second argument with the error
    message. We will get to Koa.js slick error handling later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got the basics down, let's start building a Hacker News API!
  prefs: []
  type: TYPE_NORMAL
- en: The link model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code describes the straightforward link document model in `src/models/links.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is pretty much identical to how you would define a model in
    Express, with one exception: the `upvotes` static method. Since `findByIdAndUpdate`
    is an asynchronous I/O operation, we need to make sure that we `yield` to it,
    so as to make sure we wait for this operation to complete, before we continue
    the execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier we noted that not only generator functions can be yielded to; it also
    accepts Promises, which is awesome, because they are quite ubiquitous. Using Mongoose,
    for example, we can turn Mongoose query instances into Promises by calling the
    `exec()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The link routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the link model in place, let''s set up some routes in `src/routes/links.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This should start to look familiar. Instead of function handlers with the signature
    (`req, res`) that we are used to in Express, we simply use middleware generator
    functions and set the response body in `this.body`.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our model and routes defined perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tie it together in a Koa.js application in `src/app.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use `koa-body-parser` to parse the request body in `this.request.body`
    and `koa-router`, which allows you to define Express style routes, the kind you
    saw earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we connect to the database, which isn't different from the previous chapters,
    so we will omit the code here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we define the Koa app, mount the middleware, and load the routes.
    Then, in the root folder, we have `/app.js` as given in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This just loads the app and starts an HTTP server, which listens on port `3000`.
    Now to start the server, make sure you use the `--harmony-generators` flag. You
    should now have a working Koa API to power a Hacker News-like website!
  prefs: []
  type: TYPE_NORMAL
- en: Validation and error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error-handling is one of the fortes of Koa.js. Using generator functions we
    don't need to deal with error handling in every level of the callbacks, avoiding
    the use of (`err,` `res`) signature callbacks popularized by Node.js. We don't
    even need to use the `.error` or `.catch` methods known to Promises. We can use
    plain old `try/catch` that ships with JavaScript out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implication of this is that we can now have the following centralized error
    handling middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we include this as one of the first middlewares on the Koa stack, it will
    basically wrap the entire stack, which is yielded to downstream, in a giant `try/catch`
    clause. Now we don't need to worry about exceptions being thrown into the ether.
    In fact, you are now encouraged to `throw` common JavaScript errors, knowing that
    this middleware will gracefully unpack it for you, and present it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now this may not always be exactly what you want though. For instance, if you
    try to upvote an ID that is not a valid BSON format, Mongoose will throw `CastError`
    with the message `Cast` `to` `ObjectId` `failed` `for` `value` `xxx` `at` `path`
    `_id''`. While informative for you, it is pretty dirty for the client. So here''s
    how you can override the error by returning a `400` error with a nice, clean message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We basically catch the error where it happens, as opposed to let it bubble up
    all the way to the error handler. While we could throw a JavaScript error object
    with the `status` and `message` fields set to pass it along to the errorHandler
    middleware, we can also handle it here directly with the `this.throw` helper of
    the Context object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you pass a valid BSON ID, but the link does not exist, Mongoose will
    not throw an error. Therefore, you still have to check whether the value of `link`
    is not `undefined`. Here is yet another gorgeous helper of the Context object:
    `this.assert`. It basically asserts whether a condition is met, and if not, it
    will return a `400` error with the message `link` `not` `found`, as passed in
    the second and third argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more validations to the submission of links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We ensure that a title is being passed, as well as a valid URL, for which we
    use the following RegEx util:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now there are still ways to refactor the validation checks into modular middleware;
    similar to what we did in [Chapter 3](ch03.html "Chapter 3. Multiplayer Game API
    – Connect 4"), *Multiplayer Game API – Connect* this is left as an exercise to
    the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Update route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CRUD API is not complete with the update route! If you are a Hacker News frequenter,
    you'll know that titles of the submissions can change (but not the URL). This
    route should be straightforward, but there is one caveat! Yes, you could use `findByIdAndUpdate`,
    which is used by `upvote`, but what if you wanted to use Mongoose's instance method
    `.save()`?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it does not return a Promise, so therefore we cannot `yield` to it. In
    fact, at the time of writing, there is still an open issue about this. Using `save()`,
    we can only use the traditional callback pattern. However, remember the rule—do
    not mix generator functions with callbacks!
  prefs: []
  type: TYPE_NORMAL
- en: So now what? Well, it will be quite common for certain node modules to be only
    available in the callback format. While most common modules are ported to a Koa
    version, you can still use Express packages; you just have to `thunkify` them.
    In fact, you could turn any callback style function into a thunk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here''s how to turn a function that accepts a callback into a yieldable
    thunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the preceding code to `model/links.js`, we can now do the following
    in the update route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `saveThunk()` near the bottom. It is basically a `thunkified`
    version of the original `save()` method. This means that an error that would originally
    be passed as the first argument in the callback is now thrown as an Error. We
    can afford not to wrap it in a `try/catch` block because the errorHandler middleware
    will catch it and throw a `500` error, which would be appropriate in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note how the thunk returns an array. This is because the original callback
    has an arity of `3`. The first argument is the error, the second argument is the
    new document, while the third argument is the number of affected documents. The
    array returned by the thunk contains the latter two values. If the arity of the
    callback was `2`, it would've just returned the value; something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Let's perform some tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we omitted the disciplined TDD approach, since it has been covered
    multiple times in previous chapters. However, testing is slightly different in
    Koa.js, so let's highlight some of those differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still use supertest in the neat way that we did before, with one slight
    adjustment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We need to call the `.callback()` method to return an object that we can pass
    to supertest. In fact, the returned object can even be mounted on top of an Express
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the routes to submit links is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At the start of this test suite, we clear the collection in the DB and submit
    a link using a post request. Nothing special here; note that we use Mocha's default
    callbacks for the asynchronous requests, and not `co-mocha`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s submit a few more links, and check that they are indeed stored in the
    DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we store link IDs in an array for the next test case to demonstrate
    the final, most awesome bonus feature of Koa.js, parallel asynchronous requests,
    out of the box!
  prefs: []
  type: TYPE_NORMAL
- en: Parallel requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The backend of Hacker News should be able to deal with the race condition, that
    is, it should handle hundreds of concurrent `upvote` requests without losing data
    (recall [Chapter 4](ch04.html "Chapter 4. MMO Word Game"), *MMO Word Game* on
    race conditions). So let's write a test case that simulates parallel requests.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, you would immediately think of using the extremely powerful and
    popular `async` library, which has a lot of very useful tools to deal with complex
    asynchronous execution flows. One of the most useful tools that `async` offers
    is `async.parallel`, with which you can make asynchronous requests in parallel.
    It is used to be the go-to solution for parallel requests, but now Koa offers
    something out of the box and with a much cleaner syntax!
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `co` is actually what gives Koa the power of generator functions,
    so refer to the readme page of the `co` project to read more about all the patterns
    that it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we yielded to generator functions, Promises, and thunks. However, that
    is not all. You can also `yield` to an array of the preceding which would execute
    them in parallel! Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, notice how we use a generator function, so be sure that you have `require(co-mocha)`
    on top of your test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, `supertest` does not return a thunk or a promise, which we can yield
    to, so we require `co-supertest` for this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Thirdly, we build an array of requests to be executed later. We are basically
    pushing thunks into an array; they could be promises too. Now when we yield the
    array, it will execute all requests in parallel, and return an array of all the
    response objects!
  prefs: []
  type: TYPE_NORMAL
- en: Quite mind blowing if you're used to `async.parallel` for these things, right?
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have a simple Koa API that has all the basic functionalities
    quite well tested. Let's add a simple view layer on top to show how you can serve
    static files from a Koa app as well. So if the app receives a request from a browser
    for HTML content, we'll serve a functional web page, where we can see the links
    submitted, submit a link, as well as upvote a link.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pause here for a quick real-developer-life anecdote to implement the preceding.
    The tendency for modularity is an empowering force of the open source community.
    A modern day developer has access to a plethora of well-tested modules. Oftentimes,
    the majority of the developer's work is simply to compose an app of several such
    modules. We learn of these modules from prior experience, books, news websites,
    social media, and so on. So how do we go about choosing the right tools instead
    of reinventing the wheel?
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always recommended to do a simple search to see whether a module is already
    available. In this case, we are interested in rendering views with Koa.js, so
    let''s try the search term `koa-render` on [www.npmjs.com](http://www.npmjs.com).
    Two popular packages come up that seem to quite fit our needs, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering HTML pages](img/B00818_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `koa-views` is a template rendering middleware for Koa, supporting many
    template engines. Sounds promising! `koa-render` adds a `render()` method to Koa
    that allows you to render almost any templating engine. Not bad either. As shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering HTML pages](img/B00818_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the things we can look at to guide our choice is the number of downloads;
    both packages have a decent amount of downloads, which shows some credibility.
    The `koa-views` has about 5 times more downloads than `koa-render` per month.
    While these badges are a minor touch, it does show that the author cared enough
    and is likely to support it. The number of recent commits is also a of good indicator
    that can be found on the GitHub page for the project, the number issues that have
    been resolved, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, both projects' GitHub links redirect to `koa-views`,
    which is unexpected, but good for us! Looking at the GitHub account of the author
    of koa-render, we cannot find the project anymore, so it's safe to assume it was
    discontinued; avoid it! When you can, try to avoid using non-maintainable packages
    as it might pose a threat given the fact that Node.js (and io.js) are rapidly
    evolving ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to rendering HTML pages, Koa, unlike Express, has no pre-baked opinion
    about the rendering of views. However, it does provide us with some mechanisms
    for content negotiation, some of which we can use to enhance and reuse the routes
    we already have for our API. Let''s see what our `/links` handler will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our use case is rather simple; we either serve JSON or HTML. When the request
    header `accepts` is set to `text/html`, something browsers set automatically,
    we''ll render the HTML. For the rendering of dynamic jade views to work as expected,
    we must not forget to include the `koa-views` middleware in `app.js` somewhere
    before the router middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The middleware points to a folder with a relative path that will contain the
    templates. Right now, we just need a single template `views/index.jade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's a jade file similar to the ones presented before in this book. It loops
    over every link loaded at the controller, which has a single action to upvote.
    Links are displayed in the descending order of votes, which only happens when
    the page is reloaded. There is also a simple form that allows the user to submit
    new links.
  prefs: []
  type: TYPE_NORMAL
- en: We chose to load jQuery from a CDN simply in order to make the `PUT` request
    for upvotes. Notice that our use of inline JavaScript as well as adding a click
    event using the onclick element is highly discouraged, other than to make this
    example simple to digest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you have your app running and you go to `localhost:3000/links`, here''s
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering HTML pages](img/B00818_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So that's a start from a functional standpoint! Clearly not good enough if we
    want to add more frontend JavaScript and CSS styling to it; we still need to be
    able to serve static files.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although usually you''d be incentivized to create a separate server for your
    assets, let''s keep things simple and dive straight to the goal. We want to serve
    any files from a certain folder to a certain base path. For that purpose, we''ll
    need two small middlewares, respectively, `koa-static` and `koa-mount`. In `src/app.js`,
    we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function `mount()` will namespace the request for each middleware that follows,
    in this particular case being combined with serve, which will serve any file inside
    the `public/` directory. If we decide not to mount to any particular URL, serving
    files would still work; it just won't have a nice namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now all you need to do is create a `public/` directory in the root folder with
    `filepublic/main.css` and it will able to serve a stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: This method allows to serve all static files you'd expect; CSS, JavaScript,
    images, and even videos.
  prefs: []
  type: TYPE_NORMAL
- en: To take it even further, there are many build tools and best practices for front-end
    assets, including ways to set up asset pipelines with Grunt, Gulp, Browserify,
    SASS, CoffeeScript, and many others tools. Not to mention front-end frameworks
    such as Angular, Ember, React, and so on. This is only the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Hope you enjoyed the introduction to Koa.js!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built an API with which you can now host your own Hacker News of X! Obviously,
    we're still missing the sort and decay algorithm, as well as comments, but since
    you reached this far, it should be an easy exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter was really to give you a taste of the neat features
    of Koa.js, and demonstrate the use of the generator function pattern, which will
    be available in ECMAScript 6\. If you like being on the bleeding edge, and enjoy
    the generator syntax, it is definitely a good alternative to Express.js.
  prefs: []
  type: TYPE_NORMAL
