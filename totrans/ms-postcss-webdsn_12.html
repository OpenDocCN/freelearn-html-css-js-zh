<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Mixing Preprocessors</h1></div></div></div><p>Throughout the book, we've explored using PostCSS, and seen how we can build a more efficient preprocessor that meets our needs, without the extra baggage of standard preprocessors. Hold on though—doesn't it take time to build a processor? How do we manage the transition? </p><p>No problem, enter the Pleeease library! Throughout this chapter, we'll use the power of Pleeease to combine both preprocessors and postprocessors into one process, mixing existing systems such as SASS, Less, and Stylus. Over the next few pages we take a look at some examples, and show you how easy it is to harness the power of Pleeease.</p><p>This chapter will cover the following technical topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examining the benefits of using the Pleeease library</li><li class="listitem" style="list-style-type: disc">Installing and configuring the library</li><li class="listitem" style="list-style-type: disc">Exploring some of the features of Pleeease</li><li class="listitem" style="list-style-type: disc">Compiling code using Node or the command line</li><li class="listitem" style="list-style-type: disc">Setting up a configuration file</li><li class="listitem" style="list-style-type: disc">Converting a WordPress installation and testing the results</li></ul></div><p>Let's make a start!</p><div><div><div><div><h1 class="title"><a id="ch12lvl1sec97"/>Taking the first steps</h1></div></div></div><p>When developing a site, developers will nearly always have the opportunity to design and build it from the ground up; we can make decisions regarding the color scheme to use, the structure of the site, and its general appearance.</p><p>Sometimes, though, there will be occasions when we want to use a new technology, but have to use an existing site. A question on the minds of many in this position will likely be: where does one start? It will, of course, depend on many factors, of which one is likely to be whether existing processors such as SASS or Less are being used on the site.</p><p>The flexibility and power of PostCSS allows us to transition easily from the likes of Less or SASS to using PostCSS—throughout this chapter, we're going to go on a journey to explore some of the tricks we can use to begin that transition process. We'll explore some of the plugin options available, then finish with a look at converting a CMS system such as WordPress to using PostCSS.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>Any reason why WordPress was chosen? It is compiled from SASS, but also uses PostCSS to handle vendor prefixes, we'll build on this with additional plugins later in the chapter.</p></div></div><p>Let's begin that journey, our first step is to explore some of the plugins we can use to begin that transition process from using SASS to PostCSS.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec98"/>Exploring the conversion process</h1></div></div></div><p>Cast your mind back to <a class="link" href="ch10.html" title="Chapter 10. Building a Custom Processor">Chapter 10</a>, <em>Building a Custom Processor</em>, for a moment.</p><p>The key theme of that <a id="id748" class="indexterm"/>chapter was bringing together a number of plugins we covered throughout the preceding chapters, to create what would become our processor. So far, all of the plugins used were based around pure PostCSS, so they wouldn't be able to compile raw SASS code.</p><p>We took a brief look at the CSStyle library, as a possible means of getting around this—it's a great library for producing clean code using BEM principles, but it requires that code is written using a specific format. Ordinarily, there is nothing wrong with this at all—every developer's utopia should be to produce clean, efficient code, right?</p><p>Yet there is just one small problem, reality! It wouldn't be practical to rewrite a large, complex e-commerce site to use CSStyle without an enormous amount of work; it would require a lengthy transition period to effect such a change. It's not impossible, but using BEM-style notation is better done from ground up, or at least in defined chunks, if your site has multiple style sheets in use.</p><p>So if using CSStyle isn't a practical solution for our needs, how can we make that change? There is a more practical solution available to us—it may take longer, but the disruption should be reduced, and allow us to make smaller changes to our code in a more manageable transition process:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We start by introducing a task runner to compile existing processor code—plugins exist for using libraries such as SASS or Less within runners such as Gulp or Broccoli, to allow us to compile code.</li><li class="listitem" style="list-style-type: disc">Once we've transitioned to using a task runner, we can then introduce plugins to handle core processes, such as managing vendor prefixes, creating source maps, and minifying our style sheets.</li><li class="listitem" style="list-style-type: disc">We can then break down our existing style sheet into smaller chunks and import each into a master file during compilation. Each can then be converted to use PostCSS plugins that replicate existing processor functionality—for example, we might use <code class="literal">postcss-simple-vars</code> to create new variables to replace existing SASS-based examples.</li></ul></div><p>The latter step in this process should be iterative, at least until everything has been converted, and allows us to remove any dependency on existing processors. We've used a fair number of Gulp task files to date, so we should be reasonably familiar with the basic use of one by now—here's <a id="id749" class="indexterm"/>what a task file might look like, if we were using SASS and Gulp:</p><div><pre class="programlisting">var gulp = require('gulp');
var postcss = require('gulp-postcss');
var sass = require('gulp-sass');
 
var autoprefixer = require('autoprefixer');
var cssnano = require('cssnano');
 
gulp.task('css', function () {
  var processors = [ autoprefixer, cssnano ];
  return gulp.src('./src/*.scss')
    .pipe(sass().on('error', sass.logError))
    .pipe(postcss(processors))
    .pipe(gulp.dest('./dest'));
});</pre></div><p>In this example, we're using the Gulp plugins for SASS and PostCSS—SASS code is compiled first, before vendor prefixes are added by PostCSS, and the code is minified into the final article.</p><p>The benefits of this process, though, mean that we can control the rate of conversion—we are not forced to have to convert everything in one go, and can be selective about what is converted at each point in the process. There will still be a dependency on an external library, but this is temporary; we can remove that dependency when everything has been converted to using PostCSS.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec121"/>Choosing our plugins</h2></div></div></div><p>Assuming that we've made the <a id="id750" class="indexterm"/>transition process to using a task runner, then where do we go from here?</p><p>Well, it's time to choose the plugins we need to use, based on the functionality offered by our site. Some of the more useful plugins to get you started are as follows: </p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Plugin </p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose of plugin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>postcss-mixins</p>
</td><td style="text-align: left" valign="top">
<p>If your code contains SASS mixins, then this will be essential—the format is very <a id="id751" class="indexterm"/>similar, so changes can be made using a search and replace in your editor. The plugin is available from <a class="ulink" href="https://github.com/postcss/postcss-mixins">https://github.com/postcss/postcss-mixins</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>postcss-nested</p>
</td><td style="text-align: left" valign="top">
<p>Nesting code in SASS is a key concept—the <code class="literal">postcss-nested</code> plugin from <a class="ulink" href="https://github.com/postcss/postcss-nested">https://github.com/postcss/postcss-nested</a> is a good choice for replicating this functionality within SASS.</p>
<p>Coupled with <a id="id752" class="indexterm"/>this, the <code class="literal">postcss-nested-props</code> and <code class="literal">postcss-nested-vars</code> plugins can be used to unwrap any properties or variables that are in nested code.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>postcss-sassy-mixins</p>
</td><td style="text-align: left" valign="top">
<p>There are <a id="id753" class="indexterm"/>occasions when we might have blocks of reusable code; we can use mixins to help reduce the amount of code written in our style sheets.</p>
<p>A key concept borrowed from SASS, this plugin replicates the same functionality, and allows us to easily convert from using SASS to PostCSS. The plugin source is available from <a class="ulink" href="https://github.com/andyjansson/postcss-sassy-mixins">https://github.com/andyjansson/postcss-sassy-mixins</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>postcss-simple-extend</p>
</td><td style="text-align: left" valign="top">
<p>If we have <a id="id754" class="indexterm"/>styles that share common elements, then we can remove some of this duplication by extending existing styles. This is a common practice when using SASS; the postcss-simple-extend plugin from <a class="ulink" href="https://github.com/davidtheclark/postcss-simple-extend">https://github.com/davidtheclark/postcss-simple-extend</a> is perfect for replicating this within PostCSS.</p>
</td></tr></tbody></table></div><p>Other plugins are available, depending on your needs. The majority of plugins available are for SASS, but that is <a id="id755" class="indexterm"/>simply due to its maturity; others will no doubt become available for processors such as Less or Stylus over time.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>Take a look at the <a id="id756" class="indexterm"/>PostCSS plugins catalog available from <a class="ulink" href="http://postcss.parts">http://postcss.parts</a> for more details.</p></div></div><p>Adding single plugins is a perfectly acceptable option, but what if we're adding more than just a couple of plugins to mimic SASS code? There are two options that would be useful here, and which we've not covered in our list—using the PreCSS or Pleeease libraries.</p><p>The Pleeease library was designed to handle some of the more menial tasks that are a necessary evil when compiling our code. Although not all of the supported tasks will apply, there will be at least three that do—minifying code, adding vendor prefixes, and generating source maps.</p><p>In stark contrast, the PreCSS library is likely to be more useful, as it is a collection of plugins that emulate SASS features. The beauty, though, is that we only need to install one plugin to handle changes; PreCSS abstracts the manual conversion of PostCSS styles into valid CSS using a single interface. We will explore using it in more detail a little later on in this chapter, but <a id="id757" class="indexterm"/>for now, let's turn our attention to putting the Pleeease library through its paces.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec99"/>Introducing the Pleeease library</h1></div></div></div><p>The Pleeease <a id="id758" class="indexterm"/>library, available from <a class="ulink" href="http://pleeease.io/">http://pleeease.io/</a>, is designed to simplify the use of preprocessors, and combine the benefits of using multiple tools in one library. It means we can configure it to any one of three processors, such as <a id="id759" class="indexterm"/>SASS, Less, or Stylus, in addition to PostCSS, when compiling our code. The compilation can also include all of the typical tasks we might otherwise have to do, such as generating source maps, adding vendor prefixes, and minifying the results.</p><p>The library is easy to install—in its simplest format, we can use a configuration file to compile at the command line. Alternatively, we can use any one of several plugins to hook into a task runner, such as Gulp or Grunt. Let's take a moment to explore this in more detail, beginning with installing and configuring the plugin for use.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec122"/>Installing and configuring the Pleeease library</h2></div></div></div><p>The Pleeease library <a id="id760" class="indexterm"/>is based on Node.js; it is a cinch to install, either for <a id="id761" class="indexterm"/>use manually at the command line, or via a task runner such as Gulp. Let's make a start on getting everything set up for use:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll begin by installing the Pleeease library—for this, go ahead and fire up a Node.js command prompt session, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter <code class="literal">npm install -g pleeease-cli</code>, then press <em>Enter</em>—wait for Node to complete the installation.</li></ol></div><p>At this point, the Pleeease library is installed and configured for use from the command line—if Node complains of elements that need to be updated, then it may be necessary to run <code class="literal">npm update –g n</code> to bring your version up to date. If you are a Windows user, then there is a handy PowerShell script <a id="id762" class="indexterm"/>available at <a class="ulink" href="https://github.com/felixrieseberg/npm-windows-upgrade">https://github.com/felixrieseberg/npm-windows-upgrade</a> to help with this process.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>You may get a couple of warnings about deprecated modules for <code class="literal">graceful-fs</code> and <code class="literal">lodash</code>: these can be ignored for the purposes of the demo.</p></div></div><p>Assuming we did not encounter any issues with installing Pleeease (over and above some deprecation warnings, as already mentioned), then we are now ready to use Pleeease in anger. Over the next few pages, we will take a look at compiling manually as well as using Gulp as our favored <a id="id763" class="indexterm"/>task runner. Let's begin by exploring how easy it is to <a id="id764" class="indexterm"/>perform a basic compilation at the command line using a <code class="literal">.pleeeaserc</code> file.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>For the purposes of this chapter, we will concentrate on using SASS; if your preference is to use Less, you can use the <code class="literal">gulp-less</code> plugin as an alternative. Likewise, if your desire is to use Stylus, then the <code class="literal">gulp-stylus</code> plugin will work equally well with Pleeease.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec123"/>Compiling code manually</h2></div></div></div><p>The simplest <a id="id765" class="indexterm"/>way to compile code using the Pleeease library is with a <code class="literal">.pleeeaserc</code> configuration file.</p><p>This resembles a (simplified) JSON file, and will look something like this:</p><div><pre class="programlisting">{
  "in": ["foo.css", "bar.css"],
  "out": "baz.css",
  "browsers": ["last 3 versions", "Android 2.3"]
}</pre></div><p>Looks pretty straightforward, doesn't it? We simply need to specify our source files (<code class="literal">in</code>), and what we should get (<code class="literal">out</code>). In this example, we've gone one step further, to specify the level of browser support needed—this is mainly to ensure that the right vendor prefixes have been applied.</p><p>This setting uses the same configuration as Autoprefixer: we can equally pass it a valid query from the Browserslist <a id="id766" class="indexterm"/>query list at <a class="ulink" href="https://github.com/ai/browserslist#queries">https://github.com/ai/browserslist#queries</a>.</p><p>This is a useful method for compiling if our requirements do not stretch to using a task runner, or we want to keep our processes simple. The only downside is that we can't tie in any other tasks that could be automated, such as renaming the compiled style sheet with a <code class="literal">.min.css</code> extension—for this, we will need to use a task runner such as Gulp.</p><p>If we do use a task runner, this opens up all kinds of possibilities, such as automating processes to resize images, renaming compiled style sheets, and checking our code for consistency. Before we do so, let's just cover a useful tip—the Pleeease site includes an online playground (available at <a class="ulink" href="http://pleeease.io/play/">http://pleeease.io/play/</a>). We can use this to help familiarize ourselves with using the library before committing ourselves to compiling code for a production site:</p><div><img src="img/BO5194_12_01.jpg" alt="Compiling code manually"/></div><p>Okay, enough <a id="id767" class="indexterm"/>chitchat: it's time to get practical, so to speak! For some, compiling at the command line might be enough, but in this modern age of automation, why spend time performing manual processes that can easily be automated?</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec124"/>Compiling using a task runner</h2></div></div></div><p>If you haven't <a id="id768" class="indexterm"/>already guessed by now, I'm a big fan of using Node.js—my task runner of choice is Gulp. It used to be Grunt, but there is something about Gulp that I find is easier to use—I'm not sure why! Anyway, either can be used with Pleeease, so if your preference isn't Gulp, then please feel free to alter the code accordingly.</p><p>Let's work through the steps needed to use Gulp to run our compilation process:</p><div><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command prompt session, then change the working folder to our project area.</li><li class="listitem">At the prompt, enter these commands, pressing <em>Enter</em> after each:<div><pre class="programlisting"><strong>npm install gulp-pleeease</strong>
</pre></div><p>Keep the Node.js command prompt session open—we will need it shortly.</p></li><li class="listitem">Extract a copy of the <code class="literal">T65 – using gulp-pleeease</code> folder from the code download that accompanies this book to the root of our project area.</li><li class="listitem">Copy the <code class="literal">package.json</code> and <code class="literal">gulpfile.js</code> files to the root of our project area, then copy <code class="literal">example.css</code> from the <code class="literal">src</code> folder under <code class="literal">T65 – using gulp-pleeease</code> to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">Revert to the Node.js command prompt session, then at the prompt enter <code class="literal">gulp</code> and press <em>Enter</em>:<div><img src="img/BO5194_12_02.jpg" alt="Compiling using a task runner"/></div></li></ol></div><p>Assuming compilation is successful, Gulp will produce the now familiar files within the <code class="literal">dest</code> folder at the root of our project area. If we take a look at the results, we should see that it has minified the file, added vendor prefixes, and converted the <code class="literal">blue</code> and <code class="literal">red</code> color attributes to their equivalent HEX values.</p><p>Let's put this technique <a id="id769" class="indexterm"/>to good use and create a simple web page as an example of how we can use Pleeease. When checking our Gulp file, we will see that we don't need to use half of the plugins we've used in previous exercises, as Pleeease adds that support from within its plugin.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec125"/>Building an example using Pleeease</h2></div></div></div><p>Throughout many <a id="id770" class="indexterm"/>of the demos in this book, we've had to import a series of plugins to manage different tasks such as minifying code, or checking it for consistency.</p><p>There is nothing technically wrong with this approach, but it is inefficient—after all, why use six tools when one will suffice, so to speak? We've tried to maintain a one plugin—one job rule throughout the book, so why are we breaking with convention?</p><p>The great thing about using Pleeease is that it already contains support for some of these tasks that would otherwise require separate plugins; this means we can remove some of the plugins referenced in the Gulp task file. Pleeease is simply a layer that abstracts support for six other plugins through one common interface.</p><p>Let's put that to use in the form of compiling styles for a simple web page:</p><div><img src="img/B05194_12_21.jpg" alt="Building an example using Pleeease"/></div><p>Let's make a start:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start, as always, by extracting a copy of the <code class="literal">TXX – creating a page using pleeease</code> folder from the code download that accompanies this book; save it to the root of our project area.</li><li class="listitem">From the <code class="literal">css – completed version</code> folder, copy the <code class="literal">styles – pre compile.css</code> file to the <code class="literal">src</code> folder at the root of our project area; rename it <code class="literal">styles.css</code>.</li><li class="listitem">Copy the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files from the root of the <code class="literal">tutorial</code> folder to the root of the project area—these should replace any already present at the root of our project area.</li><li class="listitem">Fire up a Node.js <a id="id771" class="indexterm"/>command prompt session, then change the working folder to the project area.</li><li class="listitem">At the prompt, type <code class="literal">gulp</code> then press <em>Enter</em>—Pleeease will now go away and compile our code, and spit out valid style sheet files in the <code class="literal">dest</code> folder at the root of our project area.</li><li class="listitem">Once completed, copy the contents of the <code class="literal">dest</code> folder to the <code class="literal">css</code> folder within the <code class="literal">tutorial</code> folder.</li></ol></div><p>If we try previewing the results of our work by double-clicking on <code class="literal">webpage.html</code>, we should see a web page appear, similar to the screenshot at the start of this demo. The real proof, though, is in the Gulp task file—in comparison to other examples we've created in earlier demos, we've managed to remove one task completely, and reduce the number of plugins referenced by over half!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Compiling with other preprocessors</h1></div></div></div><p>Yet there is <a id="id772" class="indexterm"/>one problem—so far, all of our work using Pleeease is PostCSS-based; what if we had been using a processor such as SASS as the basis for producing our code? </p><p>Unfortunately, this is where Pleeease falls down—although it does include support for SASS, Stylus, and Less, it is still very experimental. An example of where this causes an issue is in nesting; Pleeease has yet to support nesting when configured to use SASS. This reduces the appeal of using Pleeease—after all, one of the key reasons for using PostCSS is to remove any dependency on libraries such as SASS!</p><p>To get around this means using the <code class="literal">gulp-sass</code> plugin. This is a wrapper for the <code class="literal">libsass</code> library. To achieve this, we would add a task such as this to our Gulp task file:</p><div><img src="img/BO5194_12_03.jpg" alt="Compiling with other preprocessors"/></div><p>When using this method, we can pre-compile our SASS code to valid CSS before transforming it with PostCSS plugins. The trouble is, it seems an inefficient way to compile our code—there is a better alternative, in the form of the PreCSS library.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec101"/>Using the PreCSS library</h1></div></div></div><p>
<em>Okay…so why is it better, I hear you ask?</em>
</p><p>The simple answer to this is <a id="id773" class="indexterm"/>that we can compile SASS-like code directly without using an external library such as libsass. The distinction here, though, is that it works on SASS-<em>like</em> code, not direct SASS.</p><p>This isn't an issue though—we can easily perform a search and replace using a text editor to make the minor formatting changes required to make it compatible for PreCSS. The library source is <a id="id774" class="indexterm"/>available at <a class="ulink" href="https://github.com/jonathantneal/precss">https://github.com/jonathantneal/precss</a>; the developer has even provided an online playground for our use, at <a class="ulink" href="https://jonathantneal.github.io/precss/">https://jonathantneal.github.io/precss/</a>, so that we can try out changes before committing to code.</p><p>At this point, we're going to break with convention—rather than produce a simple web page, let's push the boat out and use a content management system such as WordPress. Why? Well, for two reasons: WordPress already uses both PostCSS and SASS—it makes perfect sense to continue using the same tools! On this basis, let's dive in and take a look at using both in more detail.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec102"/>Converting a WordPress installation</h1></div></div></div><p>All of our existing <a id="id775" class="indexterm"/>examples have so far been based around single pages; many developers are likely to use content management systems such as WordPress.</p><p>Thankfully, we can apply many of the same principles we've used so far to styling WordPress—in fact, there are some plugins we can use that mimic SASS, which is used to create core style sheets for themes that come as part of each WordPress download. The theme we will use is Twenty Sixteen, which comes with current versions of WordPress downloaded since December 2015; it can also be downloaded from <a class="ulink" href="https://wordpress.org/themes/twentysixteen/">https://wordpress.org/themes/twentysixteen/</a>.</p><p>For the remainder of this chapter, we're going to explore some of the tips and tricks we can use to incorporate PostCSS into a WordPress theme. A key point of note here, is that we've already covered some of the tasks that can be used—with care and planning, some can easily be reused when creating style sheets for CMS applications. We'll explore some of the tips and tricks we can use—although these will be geared towards the Twenty Sixteen theme, they can equally be used in other themes that are developed for WordPress.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>This next example does assume a certain amount of knowledge of WordPress, and ideally some of the basics around using SASS or Less—I would recommend reading around these topics if you are new to either application.</p></div></div><p>Let's get started. Our first task is to set up our environment, ready for use. Before we set up our environment, though, I would strongly recommend you have a copy of the code download for this chapter handy—much of what will be discussed will make reference to the code!</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec103"/>Setting up our environment</h1></div></div></div><p>To get the best out of this <a id="id776" class="indexterm"/>chapter, we need to set up an installation of WordPress—for the uninitiated, there are two ways to achieve this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can install WordPress as a locally hosted application using a web server such as WAMPSever (<a class="ulink" href="http://www.wampserver.com/en">http://www.wampserver.com/en</a>) or Apache (<a class="ulink" href="http://www.apachefriends.org">http://www.apachefriends.org</a>—if you are a Linux or Mac user)</li><li class="listitem" style="list-style-type: disc">We can use a version of WordPress installed on our own web space online</li></ul></div><p>For the purposes of this <a id="id777" class="indexterm"/>book, we will use the former—to get hold of WordPress, head over to <a class="ulink" href="http://www.wordpress.org">http://www.wordpress.org</a> and hit the blue <strong>Download WordPress</strong> button on the right side of the screen (near the top).</p><p>I will assume our version of WordPress has been installed locally under <code class="literal">C:\wamp\www\wordpress</code>, using your local web server of choice, following the instructions available at <a class="ulink" href="https://codex.wordpress.org/Installing_WordPress">https://codex.wordpress.org/Installing_WordPress</a>. My preference is to use WAMPServer (available from <a class="ulink" href="http://www.wampserver.com/en">http://www.wampserver.com/en</a>), but if you would like to use a different web server or folder, then please adjust the steps accordingly.</p><p>Okay, with WordPress <a id="id778" class="indexterm"/>installed, configured, and ready to go, let's crack on. The next step is to take a look at the options available to us for beginning the transition process.</p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>The steps given throughout the remainder of this chapter will be geared towards Windows, as this is the platform normally used by the author; please adjust accordingly, if you use Linux or Mac devices.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec104"/>Considering the conversion process</h1></div></div></div><p>Where does one start, when <a id="id779" class="indexterm"/>working with an average WordPress style sheet, I hear you ask?</p><p>Well, the first thing we should not do is be put off by its size. Yes, I know this might sound crazy (after all, the Twenty Sixteen theme weighs in at 3920 lines!), but with some planning, we can easily break this into something more manageable.</p><p>If we only achieve one task with PostCSS, then that task must be to make use of the <code class="literal">postcss-import</code> plugin to help break our code into more manageable principles. If you happen to have used processors such as SASS or Less, then it's the same principle—in our master <code class="literal">style.css</code>, we can create a series of import statements, and hive off each block into separate files.</p><p>Once we've broken the style sheet into more manageable chunks, there are a fair few things we can implement in our code; we should always consider it an iterative process, until such time as we exhaust all possible alternatives, the site is no longer required, or we migrate to a different solution. Over the next few pages, we'll cover some of the ideas and considerations that are likely to crop up—this should help get you started with making the changes to your theme. So without further ado, where do we start?</p><p>Well, the obvious one is using Autoprefixer; WordPress makes good use of CSS3 styles, of which a fair number still require vendor prefixes. A consideration here, though, is that as we will be working backwards from the original style sheet, we will need to strip out existing vendor prefixes and set our task runner to add these in automatically. It's a necessary evil of working with existing style sheets in WordPress, but at least we should only have to do it once! There may be a temptation to create a mixin to manage vendor prefixes, but this is not considered best practice—Autoprefixer will update styles at each compilation.</p><p>We're already familiar with using Autoprefixer from earlier examples—in the same vein, we can also consider minifying our code, which will help reduce bandwidth usage. Adding such a facility should be a cinch—we can use the same tasks from earlier demos, as long as we set the right order of tasks. We will need to alter it to compile <code class="literal">style.css</code> directly (this is the main file for WordPress style sheets), but as our processor will be geared towards using WordPress, this won't be an issue.</p><p>Another area we can look at is rem unit support, with pixel fallback. Many developers have their own views on using rem as a unit of measure; some say pixel values work just as well, but its suitability will depend on where it is being applied. This aside, Gulp has a suitable plugin we can use to help provide this functionality, if we need it.</p><p>One way to really make an impact on our code is to use nesting—this is a common technique for preprocessors such as SASS, and involves writing code in a nested format. The key benefit is to remove code that is duplicated—consider it a form of shorthand (in a manner of speaking), which will be transformed into valid CSS at compilation.</p><p>A useful technique to also look at is the use of variables; these work in much the same way as scripting or programming languages. Now before you go running for the hills, don't worry: they are easy to use. We need to provide a list of placeholder names, and the values they represent; we can <a id="id780" class="indexterm"/>then do a search and replace throughout our code for each value, and replace it with the appropriate variable. Why do this, I hear you ask? Well, it's simple: if you change a color in the future, you only need to change it in one place; PostCSS will automatically change all other instances for you at the compilation stage.</p><p>If you would like to really get stuck into the core code for WordPress, then it's always worth exploring the code repository at <a class="ulink" href="https://core.trac.wordpress.org/browser/trunk/">https://core.trac.wordpress.org/browser/trunk/</a>. If you look carefully, you should even see where PostCSS is being used!</p><p>Okay, enough chitchat: let's get stuck into some code! The changes we will make as part of our next demo are just some of the ways in which we can incorporate the use of PostCSS plugins (or Gulp, for that matter), into our process. We'll begin by exploring the changes we need to make, and follow this with some ideas for you to try out as part of using PostCSS.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec105"/>Making changes to our code</h1></div></div></div><p>Although we've only <a id="id781" class="indexterm"/>covered a few ideas, there are nevertheless a fair few steps to go through; the key to this (and keeping your sanity!) is to complete each in blocks, and not all in one go.</p><p>The bulk of our changes will use existing tasks we've created in earlier demos; to this we will add the PreCSS <a id="id782" class="indexterm"/>library (from <a class="ulink" href="https://github.com/jonathantneal/precss">https://github.com/jonathantneal/precss</a>), along with postcss-import and gulp-pixrem plugins. With this in mind, we'll make a start—our first task is to split the code into more manageable style sheets.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec126"/>Splitting our style sheet</h2></div></div></div><p>The critical part of this <a id="id783" class="indexterm"/>process is to split our style sheet—for this, we will use the <code class="literal">postcss-import</code> plugin, from <a class="ulink" href="https://github.com/postcss/postcss-import">https://github.com/postcss/postcss-import</a>:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start, as always, by firing up a Node.js command prompt, then changing the working folder to the root of our project area.</li><li class="listitem">At the prompt, go ahead and enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install postcss-import --save-dev</strong>
</pre></div></li><li class="listitem">Wait for Gulp to complete the installation process.</li></ol></div><p>Next, we need to split our style sheet into separate blocks; the most convenient way to do this is split it into sections according to the list at the top of <code class="literal">style.css</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">src</code> folder at the root of our project area, create a new folder called <code class="literal">css</code>.</li><li class="listitem">Go ahead and open up a copy of <code class="literal">style.css</code> from within the Twenty Sixteen folder—it's located at <code class="literal">C:\wamp\www\wordpress\wp-content\themes\twentysixteen\</code>.</li><li class="listitem">Save this to the <code class="literal">src</code> folder at the root of our project area.</li><li class="listitem">On or around line 53, add this line: <code class="literal">@import "css/variables.css";</code>. Don't worry for now what it will be for—this will become clear later in this chapter.</li><li class="listitem">Find lines 54 to 252, then copy them to a new file—save this as <code class="literal">normalize.css</code> in the <code class="literal">css</code> folder within the root <code class="literal">src</code> folder.</li><li class="listitem">In the <code class="literal">style.css</code> file within the <code class="literal">src</code> folder, add these import statements, as indicated:<div><img src="img/BO5194_12_04.jpg" alt="Splitting our style sheet"/></div></li><li class="listitem">Repeat the process until you have extracted all sections into their own files (1 to 15). Save them <a id="id784" class="indexterm"/>with the same names as each main section.<div><div><h3 class="title"><a id="note60"/>Note</h3><p>Note, when saving the files, you <em>don't</em> need to split sections 11 to 15 into their sub-sections—keep these within their respective files.</p></div></div></li><li class="listitem">We have one last step to perform: we need our Gulp task file! From the code download that accompanies this book, go ahead and extract a copy of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> from the <code class="literal">T68 - converting a WordPress theme</code> folder, then save both to the root of our project area.</li><li class="listitem">Take a quick look at the <code class="literal">gulpfile.js</code> file, in particular, at lines 31 to 35:<div><img src="img/BO5194_12_05.jpg" alt="Splitting our style sheet"/></div></li></ol></div><p>Notice how we are compiling directly to <code class="literal">style.css</code>, unlike previous exercises? It's not ideal, but as WordPress themes use <code class="literal">style.css</code> by default, this is something we can live with as part of our compilation process.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec127"/>Adding support for vendor prefixes</h2></div></div></div><p>Our next task is to install support for adding vendor prefixes—in a sense, we've already covered how to <a id="id785" class="indexterm"/>achieve this. Most, if not all, of our previous demos already include support for vendor prefixes, using the Autoprefixer plugin.</p><p>As a reminder, Autoprefixer is available from <a class="ulink" href="https://github.com/postcss/autoprefixer">https://github.com/postcss/autoprefixer</a>; there is an online version we can use to test changes at <a class="ulink" href="https://autoprefixer.github.io/">https://autoprefixer.github.io/</a>.</p><p>If we take a look at the Gulp task file we downloaded in the previous example, we can see the autoprefixer plugin has been called as part of firing PostCSS:</p><div><img src="img/BO5194_12_06.jpg" alt="Adding support for vendor prefixes"/></div><p>There are, however, a couple of key points we should note at this stage.</p><p>When using the <a id="id786" class="indexterm"/>Autoprefixer plugin, it uses data from the Can I Use site (<a class="ulink" href="http://www.caniuse.com">http://www.caniuse.com</a>) to update any vendor prefixes it finds that are out of date. It is worth spending time going through your style sheet to ensure that it does not already include vendor prefixes—if it does, these need to be removed.</p><p>We can remove <a id="id787" class="indexterm"/>them manually, or a more effective route is to use the <code class="literal">postcss-remove-prefixes</code> plugin, available from <a class="ulink" href="https://github.com/johnotander/postcss-remove-prefixes">https://github.com/johnotander/postcss-remove-prefixes</a>. We can add it to our Gulp task file, or run it directly from the command line. The key here is to complete the removal first, so that Autoprefixer can then be used to manage vendor prefixes.</p><p>WordPress already uses <a id="id788" class="indexterm"/>Autoprefixer to manage vendor prefixes—you can see evidence of it in the <code class="literal">Grunt</code> file at <a class="ulink" href="https://core.trac.wordpress.org/browser/trunk/Gruntfile.js">https://core.trac.wordpress.org/browser/trunk/Gruntfile.js</a>. Granted, it is using Grunt, but the process is very similar for those of you using Gulp or one of the other task runners available that are compatible with PostCSS:</p><div><img src="img/BO5194_12_07.jpg" alt="Adding support for vendor prefixes"/></div><p>Although setting up Autoprefixer in our Gulp task file is very easy—at least the basics—it will only be successful if we spend time removing any vendor prefixes that can then be added automatically at <a id="id789" class="indexterm"/>compilation. The <code class="literal">postcss-remove-prefixes</code> plugin will remove simple examples such as the following one, so that we are left with unprefixed versions that Autoprefixer can then update during compilation:</p><div><img src="img/BO5194_12_08.jpg" alt="Adding support for vendor prefixes"/></div><p>The final core task we should perform is to check our code for consistency—by now, this should be an all-too familiar task, as we've already set up a suitable task from earlier demos that can easily be reused for compiling WordPress themes. It's time to revisit this task. To ensure it works correctly, we will need to amend the settings slightly, so let's cover that now.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec128"/>Checking our code for consistency</h2></div></div></div><p>If we take a look at the <a id="id790" class="indexterm"/>Gulp task file we saved at the start of these changes, we should see this configuration object:</p><div><img src="img/BO5194_12_09.jpg" alt="Checking our code for consistency"/></div><p>A little further down is the task, there are two changes here: we've hardcoded the <code class="literal">destination</code> file, and the order which has been adjusted, to allow for the presence of the <code class="literal">pxrem</code> task. The indentation setting has also been changed within the configuration object—when compiled, the style sheet uses tabs for indentation.</p><p>This will throw up a host <a id="id791" class="indexterm"/>of warnings, we can either manually alter 3000+ entries, or alter how the indentation is checked. Hopefully it's a no-brainer as to which we would prefer to do, at least in the short term!</p><p>Leaving aside these two changes, the remainder of the linting task has not changed:</p><div><img src="img/BO5194_12_10.jpg" alt="Checking our code for consistency"/></div><p>Okay, let's change tack: there is one more core task which we should run, which is to minify our code. We've already used it in a number of demos, but let's take a moment to just revisit it within the context of compiling WordPress themes.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec129"/>Minifying our code</h2></div></div></div><p>If we had to rank the top <a id="id792" class="indexterm"/>four key tasks that could be performed using PostCSS, then this next task should definitely be at the top of that list. Minifying our code is key to conserving bandwidth usage—WordPress themes are no lightweights!</p><p>Our Gulp file already has this built in: the <code class="literal">package.json</code> file will have the appropriate reference set. If we take a look at the task file in more detail, we should see something akin to this:</p><div><img src="img/BO5194_12_11.jpg" alt="Minifying our code"/></div><p>Looks familiar? It should—it's an almost direct copy of the existing task we've used from earlier demos. We've switched off <code class="literal">autoprefixer</code>, as this is being used elsewhere in our Gulp file.</p><p>Let's move on. WordPress <a id="id793" class="indexterm"/>uses SASS as its main pre-processor; we could use the Pleeease library to compile both SASS and PostCSS code, but a cleaner option is to use the PreCSS library. This abstracts support for a number of plugins that emulate SASS code (but without the SASS baggage, so to speak). Let's dive in and take a look at this in more detail.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec130"/>Creating variables</h2></div></div></div><p>One of the key features of <a id="id794" class="indexterm"/>SASS (and other processors) is the ability to use variables as placeholders for values—these are transformed into valid CSS styles at compilation.</p><p>Why use them, I hear you ask? Simple, if you decide to change a font family, or color, do you want to wade through thousands of lines of code to update any instance where it has been used? I would hope the answer is no—and quite rightly so: we have better things to do! One of those, is to install the plugin that will add variable support in the form of PreCSS.</p><p>We've already installed PreCSS from an earlier demo, so all that remains to do is to ensure it is added to our Gulp task file accordingly (it's already in ours, and in the accompanying <code class="literal">package.json</code> file):</p><div><img src="img/BO5194_12_12.jpg" alt="Creating variables"/></div><p>The real work comes in changing our style sheet—let's take a look at what is required:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to create a file to store our variables—go ahead and create a blank file in the <code class="literal">css</code> subfolder under the <code class="literal">src</code> folder at the root of our project area, and label it <code class="literal">variables.css</code>.</li><li class="listitem">Open up the <a id="id795" class="indexterm"/><code class="literal">variables.css</code> file. Go ahead and add these values:<div><pre class="programlisting">/**
 * 0 - Variables
 */

 /**
 * 0.1 - Colors
 */
$lightgray: #d1d1d1;
$almostblack: #1a1a1a;
$verydarkgray: #686868;
$white: #ffffff;
$verylightgray: #f7f7f7;
$strongblue: #007acc;

/**
 * 0.2 - Fonts
 */
$Monserrat: Montserrat, "Helvetica Neue", sans-serif;
$OpenSans: "Open Sans", sans-serif;
$Merriweather: Merriweather, Georgia, serif;
$Inconsolata: Inconsolata, monospace;

/**
 * 0.3 - Font Sizes
 */
$baseSize: 16px;</pre></div></li><li class="listitem">Save the file, if we take a look back at <em>Splitting our style sheet</em>, you will notice that we've already included a link to it from our master style sheet:<div><img src="img/BO5194_12_13.jpg" alt="Creating variables"/></div></li><li class="listitem">Values from this file will replace placeholders within our code, to produce valid CSS.</li><li class="listitem">The next task is a necessary evil, we have to work our way through each style sheet to be imported, and replace existing values with the variable equivalents. This <a id="id796" class="indexterm"/>screenshot shows a part example—here, the <code class="literal">font-family</code> value has been updated, but the <code class="literal">border</code> value has yet to be changed:<div><img src="img/BO5194_12_14.jpg" alt="Creating variables"/></div></li><li class="listitem">Once each file has been changed, then save each, ready for the next exercise.</li></ol></div><p>There is no easy way to get around it, but altering WordPress theme style sheets can require lots of patience! The best way to manage it is to use your editor's search and replace function— editors such as Sublime Text 3 (the author's editor of preference) have a very useful facility to replace text in <a id="id797" class="indexterm"/>multiple files; making use of this will help reduce the manual effort required to update each file.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec131"/>Adding support for rem units</h2></div></div></div><p>This next task is one that is <a id="id798" class="indexterm"/>likely to cause debate—altering our code to use rem units, with pixel fallback added automatically.</p><p>Some developers claim that pixel values work just as well; others say that it all depends on where you need to specify a value, as to which unit of measure to use. Either way, we can use PostCSS to add pixel fall-back support automatically. The source for this plugin is available from <code class="literal">https://github.com/gummesson/gulp-pixrem</code>. Let's explore what is needed to add support for rem units:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up a Node.js command prompt session, or if the one from the previous session is still available, then revert to it.</li><li class="listitem">Ensure that the working folder is set to the root of our project folder, then at the prompt enter this command and press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install gulp-pixrem --save-dev</strong>
</pre></div></li><li class="listitem">Gulp will go away and install the plugin—wait for it to complete before continuing.</li><li class="listitem">We already have our Gulp task file in place—if we look at it in detail, we can see it being called at line 39:<div><img src="img/BO5194_12_15.jpg" alt="Adding support for rem units"/></div></li></ol></div><p>At this point, we have everything in place - the next task is to work our way through the various style sheets that we've created, and replace any instance of pixel values with rem equivalents.</p><p>This is a thankless but necessary task—the plugin works by adding pixel fallback values for any instances of rem units that it finds within our code. It is up to us to do as much or as little as we want, in terms of changing values—it is worth making some changes to ensure that the code compiles, but the remaining changes can be done over time.</p><p>When compiling the code, we will end up with code similar to this example—this extract comes from the Widgets section (section 10):</p><div><img src="img/BO5194_12_16.jpg" alt="Adding support for rem units"/></div><p>It's easy to simply <a id="id799" class="indexterm"/>convert our style sheet to use pixel fallback support—the key here is that we need to decide where we want to be using rem unit support, and where existing values such as pixels or em units would be preferable.</p><p>Moving on, there are two more tasks we can set up as part of our compilation process—how about mimicking the ability to nest styles from SASS, or creating mini loops to automate generating certain styles? Don't worry if this is not something that you're familiar with—let's dive in and see what these mean in action.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec132"/>Nesting rules in our style sheet</h2></div></div></div><p>The nesting of styles is a <a id="id800" class="indexterm"/>common feature when using processors such as SASS—if we have a bunch of styles that have very similar selectors, then it creates a degree of unwanted duplication.</p><p>We could stick with this duplication, but a more sensible option is to take the core part of the selector, then nest descendants within that block—this example is taken from the <code class="literal">typography.css</code> file:</p><div><img src="img/BO5194_12_17.jpg" alt="Nesting rules in our style sheet"/></div><p>The idea is to avoid having to write the same duplicated parent styles—we can concentrate on the children instead! While the code may look longer, it is definitely easier to read; we can group together styles that have a common parent.</p><p>The technique is easy to pick up, but can be deceptively hard to get right; if you are not familiar with it, then I would <a id="id801" class="indexterm"/>recommend taking a look at my two books on SASS <em>SASS Essentials</em> and <em>SASS CSS How-to</em>, available at <a class="ulink" href="https://www.packtpub.com/">https://www.packtpub.com/</a>.</p><p>Once compiled, the code will appear as normal CSS. There's one thing to note, though: resist the temptation to nest everything; nesting is really best kept to where you can see a real difference in the amount of code used!</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec133"/>Looping through styles</h2></div></div></div><p>There is one more change <a id="id802" class="indexterm"/>we can make to our code—take a look at the <code class="literal">media.css</code> file that we created earlier in this chapter, in particular around lines 158 to the end:</p><div><img src="img/BO5194_12_18.jpg" alt="Looping through styles"/></div><p>I can already hear the next questions coming, what is that meant to be, and why are we using what looks like a programming loop in our code? In this instance, we're borrowing a principle from SASS, namely creating loops; this, coupled with string interpolation allows us to create the rules automatically.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>String interpolation is creating a placeholder in our code, which will be transformed with values at compilation.</p></div></div><p>When the code is compiled, this is how the code will look:</p><div><img src="img/BO5194_12_19.jpg" alt="Looping through styles"/></div><p>It's a more advanced principle <a id="id803" class="indexterm"/>to grasp, but certainly one worth spending time getting up to speed—if applied correctly, it can save a lot of time with creating styles!</p><p>Let's change tack at this point—we've covered a number of concepts that will help get you started; there are a few more ideas that we can follow up at a later date, once the basics are in place. Let's take a moment to consider these in more detail.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec134"/>Considering future possible ideas</h2></div></div></div><p>Over the last few pages, we've covered a number of areas where PostCSS can be used to help better manage our WordPress style sheets. It's important to bear in mind that there are no hard and fast rules on what should be used, but that each style sheet will have its own requirements.</p><p>The options we've covered only scratch the surface of what is possible—for those of you who are familiar with SASS, you may well be asking why we didn't use SASS mixins, for example. The simple reason is that there is nothing stopping us from doing so: it was all about providing options that give us a quick and easy win at the conversion stage.</p><p>Let's pause for a moment and <a id="id804" class="indexterm"/>consider some other ideas that will help get you started on updating our style sheet:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Adding mixins</strong>: This is the obvious choice, but one that needs planning; this will be all about creating blocks of code that can be reused at will throughout our code.</li><li class="listitem" style="list-style-type: disc"><strong>Color fallback</strong>: Although not part of the PreCSS package we've been using to date, color fallback is another option to consider. The core WordPress themes use standard HEX notation; we can update it to use RGB equivalents and use a PostCSS plugin to add in HEX values. If we prefer, we can even use a plugin such as postcss-rgba-hex to convert from using RGBA colors to plain HEX—you may prefer working with the former, or have processes that require the use of the former format.</li><li class="listitem" style="list-style-type: disc"><strong>Font support</strong>: How about incorporating the font-magician plugin for PostCSS? If we look at the <code class="literal">variables</code> file created earlier, it will contain a number of fonts that are not standard (at least to Windows); it means that our WordPress theme will look a little plain, to say the least! Fortunately, we can use the font-magician <a id="id805" class="indexterm"/>plugin to provide font-face support for the non-standard fonts; most, such as Inconsolata, Open Sans, and <a id="id806" class="indexterm"/>Merriweather, are available from the Font Squirrel website at <a class="ulink" href="http://www.fontsquirrel.com">http://www.fontsquirrel.com</a>.</li></ul></div><p>We've picked on just three ways to help extend your theme—with the use of a task runner such as Gulp, we are really only limited by the extent of what is available as plugins for Gulp. We don't have to limit ourselves to PostCSS plugins only; this will restrict what we can do, and mean that we're missing out on useful functionality. The key here is to consider what changes you want to make, and plan how and when you will make them—the process should be iterative, which will help with managing the changes!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec106"/>Compiling and testing the changes</h1></div></div></div><p>Over the last few <a id="id807" class="indexterm"/>pages, we've covered a number of key tasks that would be perfect for compiling WordPress themes.</p><p>In an ideal world, we would automate as much as possible, or at least tasks where it would make sense—to remove tasks that give little value when done manually, for example. The key, though, is to give plenty of thought as to which order these tasks should be carried out; getting the order right can be the difference between receiving a valid style sheet file ready for use, and getting…well, what can only be classed as rubbish! Yes, that might seem a little extreme, but if the task order isn't right, then you can get compiled files that break your theme.</p><p>Leaving this aside, let's take a look at compiling our code—for the purposes of this exercise, we will use a copy of the pre-edited files that are available in the code download that accompanies this book.</p><div><div><h3 class="title"><a id="note61"/>Note</h3><p>Before continuing, you may like to save copies of the source files you've created in the <code class="literal">src</code> folder that sits at the root of our project area, for safe keeping.</p></div></div><p>To get a feel for what we will be discussing, this is a screenshot excerpt of the Twenty Sixteen theme in action:</p><div><img src="img/BO5194_12_20.jpg" alt="Compiling and testing the changes"/></div><p>Let's make a start:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by downloading and extracting a copy of the <code class="literal">src</code> folder that is under <code class="literal">T68 - converting a WordPress theme</code> in the code download; save this to the root of our project area. Make sure there are <em>no</em> other files present in this folder first!</li><li class="listitem">Next, make sure that the <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> files that we downloaded earlier are still present—we will need both during compilation.</li><li class="listitem">Go ahead and fire up a <a id="id808" class="indexterm"/>Node.js command prompt session, then change the working folder to the root of our project area.</li><li class="listitem">At the prompt, enter <code class="literal">gulp</code> then press <em>Enter</em>; Gulp will run through each task and spit out a compiled theme file in the <code class="literal">dest</code> folder at the root of our project area.</li><li class="listitem">Copy this to the root of the <code class="literal">Twenty Sixteen</code> folder, which can be found at <code class="literal">C:\wamp\www\wordpress\wp-content\themes\twentysixteen</code>—if you use Linux or OSX, then please alter the path accordingly.</li></ol></div><p>We now have a fully compiled style sheet! There are some points of note though—for example, the order of tasks that we covered earlier in this section doesn't match the order shown in the <code class="literal">gulpfile.js</code> file. Let's cover these points now:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The type of tasks you include can be split into two groups—those that I would describe as core, such as minifying files or providing source maps; these can be done for any sites. The second ones are custom tasks—these will be specific for each site, and might include requests to compile variables or nested code. It's up to you to plan how these are created, so that you can reuse them for future projects.</li><li class="listitem" style="list-style-type: disc">There is no right or wrong answer as to what should be included in a Gulp task file; the tasks you want to include, and the order they are called, will ultimately be determined by your own requirements. In our example, we used this order, from top to bottom:<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name of task</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">styles</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This compiled the raw code—merging the rules into one file, running PreCSS through the code, and updating vendor prefixes where needed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pxrem</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With the base code in place, we can now run through it and add pixel fallback for rem units, where appropriate.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lint</code>
</p>
</td><td style="text-align: left" valign="top">
<p>In this task, we're checking the compiled code for consistency.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">rename</code>
</p>
</td><td style="text-align: left" valign="top">
<p>We then rename our base compiled file to have a <code class="literal">.min.css</code> extension; this is in preparation for minifying our code.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sourcemap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>At this stage, we want to produce a source map, so this task kicks in to create a suitable map file for us.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">minifyCSS</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The final task is to minify the CSS style sheet file—it already has the right extension in place.</p>
</td></tr></tbody></table></div></li></ul></div><p>We've done the hard work—it's time to see the fruits of our labor in action. The style sheet is now in the <code class="literal">theme</code> folder within our WordPress installation—all that remains is to test it! We could get into using automated testing facilities such as Quixote (available from <a class="ulink" href="http://www.quixote-css.com/">http://www.quixote-css.com/</a>), but this would fall outside of the scope of this book. Instead, we can simply <a id="id809" class="indexterm"/>launch our local WordPress installation and check to see what it looks like—this is a useful way to gauge if there is anything amiss with our theme.</p><p>For our demo, we used the Twenty <a id="id810" class="indexterm"/>Sixteen theme. Out of the box, this is a very bare theme. Although this may not seem much, we've done most of the hard work needed to implement a PostCSS workflow when working with WordPress. A key measure of success is that the base theme should be identical to the original version that came with WordPress. If this is the case, it then means we can now concentrate on manipulating our style sheet over a period of time to further develop the styles within this (or any other) theme.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec107"/>Summary</h1></div></div></div><p>The success of using PostCSS will be partially determined by how well your code comes across from existing processors such as SASS—this will come from planning and taking an iterative approach to converting code. We've covered a lot of tips and ideas to help with the process, so let's take a moment to review what we've learnt.</p><p>We kicked off with a look at exploring the conversion process, and covered some of the plugins we might use to help with the process. We then moved on to covering the Pleeease library, with a look at installing and configuring it before using it in a quick demo.</p><p>Next up came a quick discussion about why Pleeease may not be as useful as we first thought; we then covered using the PreCSS library as a better alternative for transitioning to PostCSS.</p><p>We then explored using PreCSS in some depth by working through making changes to a standard theme for WordPress—we discovered some of the tips and tricks we can use to score quick wins when making the initial changes. We then rounded out the chapter with a look at compiling our code, and checking it in a standard WordPress installation to ensure it is still working as we would expect to see it operating.</p><p>Phew, we've covered a lot! With careful planning and using an iterative approach, we can transition from using processors such as SASS, and move to using PostCSS. However, sometimes our code may not work as expected—there are a few places where our code may trip up, so we'll cover them in the next chapter.</p></div></body></html>