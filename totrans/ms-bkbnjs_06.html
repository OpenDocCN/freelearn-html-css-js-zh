<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Store data in the Browser</h1></div></div></div><p>Backbone was mainly designed to work with RESTful API servers; however, you don't want to always store the data in a server for offline applications or to bust application loading storing cache data in the browser.</p><p>We have two choices to store data in the user browser: use localStorage or the new IndexedDB API. While localStorage has wide support on major browsers, IndexedDB is the new specification that is yet to be supported in the near future. Another option that is available currently; however, in deprecated status is Web SQL. If you are developing modern web applications, you should avoid using Web SQL.</p><p>In this chapter, you will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basics of localStorage</li><li class="listitem" style="list-style-type: disc">Basics of IndexedDB</li><li class="listitem" style="list-style-type: disc">Using localStorage instead of a RESTful server to store information</li><li class="listitem" style="list-style-type: disc">Using IndexedDB instead of a RESTful server to store information</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>The localStorage</h1></div></div></div><p>The <a id="id225" class="indexterm"/>localStorage is the simplest and the most supported browser data store. At the moment of writing this book, it is supported in almost all the major browsers. As shown in the figure below, the only browser that does not support localStorage is Opera Mini:</p><div><img src="img/B01962_06_01.jpg" alt="The localStorage"/><div><p>Figure 6.1 Browser support of localStorage</p></div></div><p>The localStorage is <a id="id226" class="indexterm"/>a simple key/value database that is able to only store text. In localStorage, you have three main methods to access the data: <code class="literal">setItem()</code>, <code class="literal">getItem()</code>,and <code class="literal">removeItem()</code>. With these three functions, you can manage the data in the store pretty well.</p><p>The downside of localStorage is that it does not have tables or collections, therefore, all the data is mixed; another issue with localStorage is that it is limited to 5 Mb of information. If your storage requirements are bigger than that, you will need IndexedDB.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec29"/>Starting with localStorage</h2></div></div></div><p>To store<a id="id227" class="indexterm"/> the data in the localStorage store, you need to call the <code class="literal">setItem()</code> method in the <code class="literal">localStorage</code> global object:</p><div><pre class="programlisting">localStorage.setItem('myKey', 'myValue');
localStorage.setItem('name', 'John Doe');</pre></div><p>That's it, this would store the information in the browser. We can explore the result of these instructions in Google Chrome as seen in the following figure:</p><div><img src="img/B01962_06_02.jpg" alt="Starting with localStorage"/><div><p>Figure 6.2 Google Chrome and localStorage</p></div></div><p>The data stored <a id="id228" class="indexterm"/>in localStorage is organized by site, which means that can you can only access the data stored on your site. In the above figure, you can see the available sites (<code class="literal">http://localhost:4000</code>) on the left-hand side. On the right-hand side, you can explore the data that we have stored with the <code class="literal">setItem()</code> method for the given site.</p><p>To retrieve the information from localStorage, you have to use the <code class="literal">getItem()</code> method:</p><div><pre class="programlisting">localStorage.getItem('myKey'); // myValue
localStorage.getItem('name'); // John Doe
localStorage.getItem('notExists'); // null</pre></div><p>To delete an item from the store, we can use the <code class="literal">removeItem()</code> method:</p><div><pre class="programlisting">localStorage.removeItem('name');
localStorage.getItem('name'); // null</pre></div><p>As mentioned earlier, localStorage only stores strings on it. However, we want to store objects, how do we do that?</p><div><pre class="programlisting">varmyObj = {name: 'John Doe', age: 26};
localStorage.setItem('object', myObj);
localStorage.getItem('object'); // [Object object]</pre></div><p>Oops…that's <a id="id229" class="indexterm"/>not what we expected. The localStorage automatically converts the object into string before storing the object. You can serialize objects with the <code class="literal">JSON.stringify()</code> function so that localStorage receives a string instead of an object:</p><div><pre class="programlisting">varmyObj = {name: 'John Doe', age: 26};
var serialized = JSON.stringify(myObj);

localStorage.setItem('object', serialized);</pre></div><p>To get the stored object back, you can use the <code class="literal">JSON.parse()</code> inverse function that converts a string into an object:</p><div><pre class="programlisting">var data = localStorage.getItem('object');
varobj = JSON.parse(data);</pre></div><p>This is how you can store and retrieve objects from localStorage. You will need to encode and decode objects as you go. It is not recommended to store big objects in localStorage due to the heavy use of JSON functions; every time you encode or decode an object, the JavaScript thread will block that object.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Backbone and localStorage</h1></div></div></div><p>To store <a id="id230" class="indexterm"/>Backbone models in localStorage, you can use the <code class="literal">ID</code> attribute as key and the serialized data as the value. However, remember that all the data in localStorage is mixed and this strategy will lead to identifier collisions.</p><p>Consider that you have two different models (contacts and invoices) with the same <code class="literal">ID</code>; when you store one of them in the localStorage, it will overwrite the other.</p><p>Another issue with localStorage is that when you want to retrieve data from the store before getting an item from the store, you need to know which key does it have. However, in localStorage, we don't have a clue about what IDs are currently in the store, therefore, we need a way to keep track of the IDs that are in the store at a given time.</p><p>To deal with these issues, you can create a well-known key in the store as an index of the IDs that are available for a given collection. See how it works in the following:</p><div><pre class="programlisting">var data = localStorage.get('contacts'); // index name
varavailableIds = data.split(',');
varcontactList = [];

// Get all contacts
for (leti = 0; i&lt;availableIds.length; i++) {
let id = availableIds[i];
let contact = JSON.parse(localStorage.getItem(id));
contactList.push(contact);
}</pre></div><p>To prevent <a id="id231" class="indexterm"/>collision between collections of models with the same ID, you can generate prefixed keys for the collection items so that instead of having number keys such as <code class="literal">1</code>, you can use keys such as <code class="literal">contacts-1</code>:</p><div><pre class="programlisting">var data = localStorage.get('contacts'); // 1, 5, 6
varavailableIds = data.split(',');
varcontactList = [];

// Get all contacts
for (let i = 0; i&lt;availableIds.length; i++) {
let id = 'contacts-' + availableIds[i];
let contact = JSON.parse(localStorage.getItem(id));
contactList.push(contact);
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Store models in localStorage</h1></div></div></div><p>Now that you <a id="id232" class="indexterm"/>know how to store and retrieve data from localStorage, it's time to store your models. In the following figure, you can see how to make data storage in local instead of a remote server.</p><p>By default, when you call the <code class="literal">save()</code> method on a model Backbone, it transforms the action into an HTTP request for a RESTFul server. To store the data in local, you need to change the default behavior in order to use localStorage instead of making HTTP requests; you will learn how to do this in the next section.</p><p>To make the storage layer maintainable, you will need to create a Backbone driver for localStorage first. The responsibility of the driver is to store and retrieve data from localStorage so that the connection between Backbone and localStorage is simpler:</p><div><img src="img/B01962_06_03.jpg" alt="Store models in localStorage"/><div><p>Figure 6.3 Store models in localStorage</p></div></div><p>In the next <a id="id233" class="indexterm"/>section, I will show you how to construct the <code class="literal">DataStore</code> driver to store the Backbone models in localStorage.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Store Backbone models in localStorage</h1></div></div></div><p>It's time to <a id="id234" class="indexterm"/>use what you have learned about <code class="literal">localStorage</code> to store and retrieve objects. The <code class="literal">DataStore</code> object is responsible to transform models into strings to be stored in localStorage:</p><div><pre class="programlisting">class DataStore {
  constructor(name) {
    this.name = name;

    // Keep track of all ids stored for a particular collection
this.index = this.getIndex();
  }

getIndex() {
var index = localStorage.getItem(this.name);
    return (index &amp;&amp;index.split(',')) || [];
  }
}</pre></div><p>The DataStore object needs a name to be used as a collection index prefix. The first use case is to create a new item:</p><div><pre class="programlisting">class DataStore {
// ...

  create(model) {
    // Assign an id to new models
    if (!model.id&amp;&amp; model.id !== 0) {
      model.id = generateId();
model.set(model.idAttribute, model.id);
    }

    // Save model in the store with an unique name,
    // e.g. collectionName-modelId
localStorage.setItem(
this.itemName(model.id), this.serialize(model)
    );

    // Keep track of stored id
this.index.push(model.get(model.idAttribute));
this.updateIndex();

    // Return stored model
    return this.find(model);
  }
}</pre></div><p>When a new <a id="id235" class="indexterm"/>model is created, it assigns a new ID with a <code class="literal">generateId()</code>function:</p><div><pre class="programlisting">
<code class="literal">var crispy = require('crispy-string');</code>

<code class="literal">const ID_LENGTH = 10;</code>

<code class="literal">function generateId() {</code>
<code class="literal">  return crispy.base32String(ID_LENGTH);</code>
<code class="literal">}</code>
</pre></div><p>The <code class="literal">itemName()</code> function generates a key that is to be used in localStorage given the model ID; the <code class="literal">serialize()</code>method transforms a model into a JSON string that is ready to be stored in localStorage. Finally, the <code class="literal">index</code> attribute in DataStore tracks all the available IDs so that we should push the model ID in the index.</p><p>For the update method, we will overwrite the current value of the model:</p><div><pre class="programlisting">class DataStore {
// ...

  update(model) {
    // Overwrite the data stored in the store,
    // actually makes the update
localStorage.setItem(
this.itemName(model.id), this.serialize(model)
    );

    // Keep track of the model id in the collection
varmodelId = model.id.toString();
    if (_.indexOf((this.index, modelId)) &gt;= 0) {
this.index.push(modelId);
this.updateIndex();
    }

    // Return stored model
    return this.find(model);
  }
}</pre></div><p>If you call the <code class="literal">setItem()</code> method with an existent key on localStorage, the previous value is overwritten with the new one, the net effect is an update operation.</p><p>When you are looking for a model, you need to set the ID of the model and call the <code class="literal">fetch()</code> method on it in order to retrieve the data from a server. In our DataStore, we can call this operation <code class="literal">find</code>:</p><div><pre class="programlisting">class DataStore {
// ...

  find(model) {
    return this.deserialize(
localStorage.getItem(this.itemName(model.id))
    );
  }
}</pre></div><p>The <code class="literal">find()</code> method<a id="id236" class="indexterm"/> is very simple, it tries to get the data from localStorege with an ID built with the <code class="literal">itemName()</code> method; if the model is not found, it will return a <code class="literal">null</code> value. While returning a single model is very simple, retrieving a list of them is a more complex operation:</p><div><pre class="programlisting">class DataStore {
// ...

findAll() {
var result = [];

    // Get all items with the id tracked for the given collection
    for (let i = 0, id, data; i&lt;this.index.length; i++) {
      id = this.index[i];
      data = this.deserialize(localStorage.getItem(
this.itemName(id)
      ));

      if (data) {
result.push(data);
      }
    }

    return result;
  }
}</pre></div><p>This method loops over all the available keys for the given collection; for each item in the list, it converts it from string to a JSON object. All items are aggregated in a single array that returns as a result.</p><p>To remove an <a id="id237" class="indexterm"/>item from DataStore, you will need to remove its value from localStorage and drop the index that is related to it:</p><div><pre class="programlisting">class DataStore {
// ...

  destroy(model) {
    // Remove item from the store
localStorage.removeItem(this.itemName(model.id));

    // Rmoeve id from tracked ids
varmodelId = model.id.toString();
    for (let i = 0; i&lt;this.index.length; i++) {
      if (this.index[i] === modelId) {
this.index.splice(i, 1);
      }
    }
this.updateIndex();

    return model;
  }
}</pre></div><p>We use the <code class="literal">updateIndex()</code> method when the collection of models is altered in localStorage; it should store a list of IDs as strings:</p><div><pre class="programlisting">class DataStore {
// ...

  // Save the ids comma separated for a given collection
updateIndex() {
localStorage.setItem(this.name, this.index.join(','));
  }
}</pre></div><p>Model IDs are generated with the name of the collection and its ID:</p><div><pre class="programlisting">class DataStore {
// ...
itemName(id) {
    return this.name + '-' + id;
  }
}</pre></div><p>The <code class="literal">DataStore</code> class, by <a id="id238" class="indexterm"/>itself, can store and retrieve models from localStorage; however, it is not fully integrated with Backbone. In the next section, we will examine how Backbone stores and retrieves models from a RESTful API and how to change this behavior to use the <code class="literal">DataStore</code> driver.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Backbone.sync</h1></div></div></div><p>This is responsible to <a id="id239" class="indexterm"/>handle connections between a RESTful server and the Backbone application is the Backbone.sync module. It transforms the <code class="literal">fetch()</code> and <code class="literal">save()</code> operations into HTTP requests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fetch()</code> is <a id="id240" class="indexterm"/>mapped as a <code class="literal">read</code> operation. This will make <code class="literal">GET</code> to the the <code class="literal">urlRoot</code> attribute with the model ID for a model or the <code class="literal">url</code> attribute for a collection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">save()</code> is mapped as a <a id="id241" class="indexterm"/><code class="literal">create</code> or <code class="literal">update</code> operation; it depends on the <code class="literal">isNew()</code> method:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This will be mapped as <code class="literal">create</code> if the model does not have an ID (<code class="literal">isNew()</code> method return <code class="literal">true</code>). A POST request is executed.</li><li class="listitem" style="list-style-type: disc">This will be mapped as <code class="literal">update</code> if the model already has an ID (<code class="literal">isNew()</code> method returns <code class="literal">false</code>). A PUT request is executed.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">destroy()</code> is <a id="id242" class="indexterm"/>mapped as a <code class="literal">delete</code> operation. This will make DELETE to the the <code class="literal">urlRoot</code> attribute with the model ID for a model or the <code class="literal">url</code> attribute for a collection.</li></ul></div><p>To better understand how Backbone.sync does its job, consider the following examples:</p><div><pre class="programlisting">// read operation will issue a GET /contacts/1
varjohn= new Contact({id: 1});
john.fetch();

// update operation will issue a PUT /contacts/1
john.set('name', 'Johnson');
john.save();

// delete operation will issue a DELETE /contacts/1
john.destroy();
varjane = new Contact({name: 'Jane'});
// create operation will issue a POST /contacts
jane.save();</pre></div><p>As you can read in <a id="id243" class="indexterm"/>the Backbone documentation, <code class="literal">Backbone.sync</code> has the following signature:</p><div><pre class="programlisting">sync(method, model, [options])</pre></div><p>Here, the method is the operation that is to be issued (<code class="literal">read</code>, <code class="literal">create</code>, <code class="literal">update</code>, or <code class="literal">delete</code>). You can easily overwrite this function in order to redirect the requests to localStorage instead of a RESTful server:</p><div><pre class="programlisting">
<code class="literal">Backbone.sync = function(method, model, options) {</code>
<code class="literal">var response;</code>
<code class="literal">var store = model.dataStore ||</code>
<code class="literal">              (model.collection&amp;&amp;model.collection.dataStore);</code>
<code class="literal">var defer = Backbone.$.Deferred();</code>

<code class="literal">  if (store) {</code>
<code class="literal">    // Use localstorage in the model to execute the query</code>
<code class="literal">    switch(method) {</code>
<code class="literal">      case 'read':</code>
<code class="literal">        response = model.id ?store.find(model) : store.findAll();</code>
<code class="literal">        break;</code>

<code class="literal">      case 'create':</code>
<code class="literal">        response = store.create(model);</code>
<code class="literal">        break;</code>

<code class="literal">      case 'update':</code>
<code class="literal">        response = store.update(model);</code>
<code class="literal">        break;</code>

<code class="literal">      case 'delete':</code>
<code class="literal">        response = store.destroy(model);</code>
<code class="literal">        break;</code>
<code class="literal">    }</code>
<code class="literal">  }</code>

<code class="literal">  // Respond as promise and as options callbacks</code>
<code class="literal">  if (response) {</code>
<code class="literal">defer.resolve(response);</code>
<code class="literal">    if (options &amp;&amp;options.success) {</code>
<code class="literal">options.success(response);</code>
<code class="literal">    }</code>
<code class="literal">  } else {</code>
<code class="literal">defer.reject('Not found');</code>
<code class="literal">    if (options &amp;&amp;options.error) {</code>
<code class="literal">options.error(response);</code>
<code class="literal">    }</code>
<code class="literal">  }</code>

<code class="literal">  return defer.promise();</code>
<code class="literal">};</code>
</pre></div><p>While the <a id="id244" class="indexterm"/>localStorage API is synchronous, it does not need to use callbacks or promises; however, in order to be compatible with the default implementation, we need to create a <code class="literal">Deferred</code> object and return a <code class="literal">promise</code>.</p><p>If you don't know what a promise or <code class="literal">Deferred</code> objects are, please refer to the jQuery documentation for more information about it. The explanation of how promises work is out of the scope of this book.</p><p>The previous <code class="literal">Backbone.sync</code> implementation is looking for a <code class="literal">dataStore</code> attribute in the models/collections. The attribute should be included in these objects in order to be stored correctly. As you may guess, it should be an instance of our DataStore driver:</p><div><pre class="programlisting">// apps/contacts/models/contact.js
class Contact extends Backbone.Model {
  constructor(options) {
    super(options);

this.validation = {
      name: {
        required: true,
minLength: 3
      }
    };

this.dataStore = new DataStore('contacts');
  }
  // ...
}

// apps/contacts/collections/contactCollection.js
class ContactCollection extends Backbone.Collection {
  constructor(options) {
    super(options);
this.dataStore = new DataStore('contacts');
  }

// ...
}</pre></div><p>The<a id="id245" class="indexterm"/> implementation that we made earlier for localStorage is inspired from the Backbone.localStorage plugin. If you want to store all your models in the browser, please use the plugin that has the support of the community.</p><p>Due the limitations of localStorage, it is not suitable to store avatar images on it as we will reach the limits with only a few records.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec30"/>Using localStorage as cache</h2></div></div></div><p>The Datastore driver<a id="id246" class="indexterm"/>
<a id="id247" class="indexterm"/> is useful to develop small applications that do not need to fetch and store the data in a remote server. It can be enough to prototype small web applications or store configuration data in the browser.</p><p>However, another use for the driver can be cache server response in order to speed up the application performance:</p><div><pre class="programlisting">// cachedSync.js
var _ = require('underscore');
var Backbone = require('backbone');

function getStore(model) {
  return model.dataStore;
}

module.exports =  _.wrap(Backbone.sync, (sync, method, model, options) =&gt; {
var store = getStore(model);

  // Try to read from cache store
  if (method === 'read') {
    let cachedModel = getCachedModel(model);

    if (cachedModel) {
      let defer = Backbone.$.Deferred();
defer.resolve(cachedModel);

      if (options &amp;&amp;options.success) {
options.success(cachedModel);
      }

      return defer.promise();
    }
  }

  return sync(method, model, options).then((data) =&gt; {
    // When getting a collection data is an array, if is a
    // model is a single object. Ensure that data is always
    // an array
    if (!_.isArray(data)) {
      data = [data];
    }

data.forEach(item =&gt; {
      let model = new Backbone.Model(item);
cacheResponse(method, store, model);
    });
  });
});</pre></div><p>When the <a id="id248" class="indexterm"/>application needs to read the data, it tries to read the data from localStorage first. If no model is found, it will use the original Backbone.sync function to fetch the data from the server.</p><p>When the server responds, it will store the response in localStorage for future use. To cache a server response, it should store the server response or drop the model from the cache when the model is deleted:</p><div><pre class="programlisting">// cachedSync
function cacheResponse(method, store, model) {
  if (method !== 'delete') {
updateCache(store, model);
  } else {
dropCache(store, model);
  }
}</pre></div><p>Dropping <a id="id249" class="indexterm"/>the model from the cache is quite simple:</p><div><pre class="programlisting">function dropCache(store, model) {
  // Ignore if cache is not supported for the model
  if (store) {
store.destroy(model);
  }
}</pre></div><p>To store and retrieve the data in the cache is more complex; you should have a cache expiration policy. For this project, we will expire the cached responses after 15 minutes, which means that we will remove the cached data and then make a <code class="literal">fetch</code>:</p><div><pre class="programlisting">// cachedSync.js
// ...

const SECONDS = 1000;
const MINUTES = 60 * SECONDS;
const TTL = 15 * MINUTES;

function cacheExpire(data) {
  if (data &amp;&amp;data.fetchedAt) {
    let now = new Date();
    let fetchedAt = new Date(data.fetchedAt);
    let difference = now.getTime() - fetchedAt.getTime();

    return difference &gt; TTL;
  }

  return false;
}

function getCachedModel(model) {
var store = getStore(model);

  // If model does not support localStorage cache or is a
  // collection
  if (!store&amp;&amp; !model.id) {
    return null;
  }

var data = store.find(model);

  if (cacheExpire(data)) {
dropCache(store, model);
    data = null;
  }

  return data;
}</pre></div><p>The <code class="literal">fetchedAt</code> attribute <a id="id250" class="indexterm"/>is used to show the time we fetched the data from the server. When the cache expires, it removes the model from the cache and returns <code class="literal">null</code> to force a server <code class="literal">fetch</code>.</p><p>When a model is cached, it should set the <code class="literal">fetchedAt</code> attribute for the first time when it is fetched:</p><div><pre class="programlisting">// cachedSync.js
function updateCache(store, model) {
  // Ignore if cache is not supported for the model
  if (store) {
varcachedModel = store.find(model);

    // Use fetchedAt attribute mdoel is already cached
    if (cachedModel&amp;&amp;cachedModel.fetchedAt) {
model.set('fetchedAt', cachedModel.fetchedAt);
    } else {
model.set('fetchedAt', new Date());
    }

store.update(model);
  }
}</pre></div><p>Finally, we need to replace the original Backbone.sync function:</p><div><pre class="programlisting">// app.js
varcachedSync = require('./cachedSync');

// ...

Backbone.sync = cachedSync;</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>IndexedDB</h1></div></div></div><p>As you <a id="id251" class="indexterm"/>have seen in the previous sections, localStorage is very easy; however, it has the limitation of 5 MB of storage capacity. IndexedDB, on the other hand, does not have this limitation; however, it has a complex API. The main downside of IndexedDB is that it is not fully supported on all major browsers:</p><div><img src="img/B01962_06_04.jpg" alt="IndexedDB"/><div><p>Figure 6.4: Browser support for IndexedDB</p></div></div><p>At the moment of writing this book, IndexedDB is fully supported by Chrome and Firefox, while Safari and IE have partial support.</p><p>A big difference between localStorage and IndexedDB is that IndexedDB is not a key/value store; IndexedDB has collections (tables) and a query API. If you have worked with MongoDB, you will be familiar with the way IndexedDB stores data.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec31"/>Getting started with IndexedDB</h2></div></div></div><p>An IndexedDB database<a id="id252" class="indexterm"/> is composed of one or more stores. A store is like a JSON container, it contains a collection of JSON. If you have worked with SQL, then a store is like a table. If you have worked with MongoDB, a store is a like a collection. In the same way as MongoDB, IndexedDB is schemaless, which means that you don't need to define the schema of the records (JSONs).</p><p>One of the consequences of schemaless is that the data in the collections is not heterogeneous, you can have different types JSON objects in the same store. For example, you can store contact and invoice data in the same store.</p><p>IndexedDB is<a id="id253" class="indexterm"/> more flexible and powerful than localStorage; however, with great power comes great responsibility. You will have to deal with stores, cursors, indexes, transactions, migrations, and asynchronous API:</p><div><img src="img/B01962_06_05.jpg" alt="Getting started with IndexedDB"/><div><p>Figure 6.5: IndexedDB</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec32"/>Database versions</h2></div></div></div><p>Databases <a id="id254" class="indexterm"/>usually change with time; maybe a new feature needs a new store or adds an index. All IndexedDB databases have a version number. The first time that you create a new database, it starts with version 1. With the help of each version number, you can define the stores and indexes as you need.</p><p>IndexedDB does not allow you to create new stores or indexes, unless you have changed the version number. When a new version number is detected, IndexedDB enters a <code class="literal">versionchange</code> state and calls the <code class="literal">onupgradedneeded()</code> callback, which you can use to modify the database.</p><p>Every time you change the version number, you have the opportunity to run database migrations in the <code class="literal">onupgradedneeded()</code> callback. Every time you open a connection with IndexedDB, you can specify a version number:</p><div><pre class="programlisting">indexedDB.open(&lt;database name&gt;, &lt;version number&gt;)</pre></div><p>The first time you open a database, IndexedDB enters the <code class="literal">versionchange</code> state and calls the <code class="literal">onupgradedneeded()</code>callback.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec33"/>Creating stores</h2></div></div></div><p>To <a id="id255" class="indexterm"/>create stores on IndexedDB, you need to put the database on the version change state, which you can do in the following two ways:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new database.</li><li class="listitem">Change the version number of the database.</li></ol></div><p>In the following example, we are creating a new database named library:</p><div><pre class="programlisting">var request = indexedDB.open("library");

// In this callback the database is in the versionchange state
request.onupgradeneeded = function() {
  // The database did not previously exist, so that
  // we can create object stores and indexes.
vardb = request.result;
var store = db.createObjectStore("books", {keyPath: "isbn"});

  // Populate with initial data.
store.put({
title: "Quarry Memories",
 author: "Fred",
isbn: 123456});
store.put({
title: "Water Buffaloes",
 author: "Fred",
isbn: 234567});
store.put({
title: "Bedrock Nights",
 author: "Barney",
isbn: 345678});
};

request.onsuccess = function() {
window.db = request.result;
};</pre></div><p>When the <code class="literal">open()</code> method is called, it returns a request object that we can use to register the <code class="literal">onscuccess()</code>callback called when the database is successfully opened and is ready to be used. As we are creating a new database, the <code class="literal">onupgradeneeded()</code>callback is called.</p><p>The database<a id="id256" class="indexterm"/> handler is in the <code class="literal">result</code> attribute of the <code class="literal">request</code> object. You can use the <code class="literal">createObjectStore()</code> method of the database handler in order to create a new store:</p><div><pre class="programlisting">createObjectStore(name, options)</pre></div><p>The first argument of the <code class="literal">createObjectStore()</code> method is the name of the store, in our example it is library. The <code class="literal">options</code> arguments should be a plain object where the available fields are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Option name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Default value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>autoIncrement</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>This auto increments the <code class="literal">primary key</code> attribute</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">false</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>keyPath</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the attribute name in the objects that is to be used as <code class="literal">primary key</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td></tr></tbody></table></div><p>After the object store creation, a store handler is returned, which you can use to insert new records in the recently created object store. The <code class="literal">put()</code>method is used to insert new records in the store it accepts as argument the JSON to be stored:</p><div><img src="img/B01962_06_06.jpg" alt="Creating stores"/><div><p> Figure 6.6: IndexedDB in Google Chrome</p></div></div><p>As you can see in the preceding image, the object store has the objects that we insert with the <code class="literal">put()</code> method in the <code class="literal">onupgradeneeded</code> event.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec34"/>Delete a database</h2></div></div></div><p>You can <a id="id257" class="indexterm"/>always delete a database with the <code class="literal">deleteDatabse()</code> method. If you did something wrong and want to start over, just delete the database:</p><div><pre class="programlisting">indexedDB.deleteDatabase('library');</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec35"/>Add elements to an object store</h2></div></div></div><p>You have <a id="id258" class="indexterm"/>seen how to create and delete stores. Now, you will see how to connect to a database and add records to an object store outside of the <code class="literal">onupgradeneeded()</code> callback:</p><div><pre class="programlisting">vartx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");

store.put({
  title: "Quarry Memories",
  author: "Fred",
isbn: 123456
});
store.put({
  title: "Water Buffaloes",
  author: "Fred",
isbn: 234567
});
store.put({
  title: "Bedrock Nights",
  author: "Barney",
isbn: 345678
});

tx.oncomplete = function() {
console.log('Records added!');
};</pre></div><p>Note that we are creating an IndexedDB transaction. The IndexedDB specification by W3C defines a transaction as follows:</p><p>
<em>A transaction is used to interact with the data in a database. Whenever data is read or written to the database it is done by using a transaction.</em>
</p><p>
<em>Transactions offer some protection from application and system failures. A transaction may be used to store multiple data records or to conditionally modify certain data records. A transaction represents an atomic and durable set of data access and data mutation operations.</em>
</p><p>The <code class="literal">transaction()</code>method<a id="id259" class="indexterm"/> of the <code class="literal">indexedDB</code> object has two arguments: scope and mode, as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Argument</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Examples</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>scope</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>The store or stores where the transaction interacts</p>
</td><td style="text-align: left" valign="top">
<p>'books',['contacts', 'invoices']</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>mode</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>This states what type of interaction will be done</p>
</td><td style="text-align: left" valign="top">
<p>'readonly', 'readwrite'</p>
</td></tr></tbody></table></div><p>When the transaction is created, you can access the stores with the <code class="literal">objectStore()</code>method of the transaction object, which returns an object store handler that you can use to add or remove records.</p><p>The <code class="literal">put()</code> method is used to insert objects into the store; however, the method is asynchronous, which means that the records are not stored immediately like in localStorage. You should register an <code class="literal">oncomplete()</code> callback in the transaction object that will be called when the operations are done.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Performing queries</h2></div></div></div><p>To query<a id="id260" class="indexterm"/> the data in an object store, you need to open a <code class="literal">readonly</code> transaction:</p><div><pre class="programlisting">vartx = db.transaction("books", "readonly");
var store = tx.objectStore("books");

var request = store.openCursor(IDBKeyRange.only(123456));
request.onsuccess = function() {
var cursor = request.result;
  if (cursor) {
    // Called for each matching record.
console.log(cursor.value);
cursor.continue();
} else {
    // No more matching records, cursor === null
console.log('Done!');
  }
};</pre></div><p>Queries are to be done by opening cursors with the <code class="literal">openCursor()</code> method. The first argument <a id="id261" class="indexterm"/>of the <code class="literal">openCursor()</code> method is a query that should be an <code class="literal">IDBKeyRange</code> object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">only(value)</code>: It looks for the value, such as an == operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">lower(value)</code>: It looks for the values lower or equal to the value, such as a &lt;= operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">lowerOpen(value)</code>: It looks for values lower than the value, such as a &lt; operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">upper(value)</code>: It looks for values greater than or equal to the value, such as a &gt;= operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">upperOpen(value)</code>: It looks for values greater than the value, such as a &gt; operation</li></ul></div><p>These are some of the queries that are available; please refer to the IndexedDB specification for a complete list of all the available queries. IndexedDB uses the query to compare the values that are passed as an argument with the objects in the store; however, which attribute in the store is compared? The answer is the key that is specified in <code class="literal">keyPath</code>. In our example, the <code class="literal">isbn</code> attribute will be used.</p><p>The cursor will call the <code class="literal">onsuccess()</code> callback repeatedly for every object found, you should call the <code class="literal">continue()</code> method on the cursor object to fetch the next object. The result will be <code class="literal">null</code> when no more objects are found.</p><p>If you want to query the objects by a different attribute, you should create indexes in the store for the attributes that you need. Use a different version number to add new indexes to the object stores:</p><div><pre class="programlisting">var request = indexedDB.open("library", 2);

request.onupgradeneeded = function() {
vardb = request.result;
var store = db.createObjectStore("books", {keyPath: "isbn"});
vartitleIndex = store.createIndex("by_title", "title", {
    unique: true
  });
varauthorIndex = store.createIndex("by_author", "author");

  // ...
};

request.onsuccess = function() {
db = request.result;

vartx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_title");

var request = index.get("Bedrock Nights");
request.onsuccess = function() {
    // ...
  };
};</pre></div><p>As you can see in the <a id="id262" class="indexterm"/>preceding example, you can use an index to query objects. The same <code class="literal">onsuccess()</code> method is invoked every time that the index finds a result.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec37"/>Delete objects in the store</h2></div></div></div><p>To delete <a id="id263" class="indexterm"/>objects, you should call the <code class="literal">delete()</code> method in the object store with a query argument for these objects that you want to remove:</p><div><pre class="programlisting">vartx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");

store.delete(123456); // deletes book with isbn == 123456
store.delete(IDBKeyRange.lowerBound(456789)); // deletes books with store &lt;= 456789</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>IndexedDB in Backbone</h1></div></div></div><p>As<a id="id264" class="indexterm"/> the IndexedDB API is more complex than localStorage, it will be more difficult to create an IndexedDB driver for Backbone as we did with localStorage; in this section, you will use what you have learned about IndexedDB in order to build a driver for Backbone.</p><p>The driver should open a database and initialize the stores when it is created for the first time:</p><div><pre class="programlisting">// indexedDB/dataStore.js
'use strict';

var Backbone = require('backbone');

const ID_LENGTH = 10;

var contacts = [
  // ...
];

class DataStore {
constructor() {
this.databaseName = 'contacts';
  }

openDatabase() {
var defer = Backbone.$.Deferred();

    // If a database connection is already active use it,
    // otherwise open a new connection
    if (this.db) {
defer.resolve(this.db);
    } else {
      let request = indexedDB.open(this.databaseName, 1);

request.onupgradeneeded = () =&gt; {
        let db = request.result;
this.createStores(db);
      };

request.onsuccess = () =&gt; {
        // Cache recently opened connection
this.db = request.result;
defer.resolve(this.db);
      };
    }

    return defer.promise();
  }

createStores(db) {
var store = db.createObjectStore('contacts', {keyPath: 'id'});

    // Create the first records
contacts.forEach(contact =&gt; {
store.put(contact);
    });
  }
}</pre></div><p>When the<a id="id265" class="indexterm"/> connection is opened, it creates the contacts store and puts the first records in the store. After that it caches the database handler in the <code class="literal">db</code> attribute to reuse the connection for future requests.</p><p>Now, we should create the necessary method to create, update, delete, and read the data from the store:</p><div><pre class="programlisting">// indexedDB/dataStore.js

var crispy = require('crispy-string');

// ...

class DataStore {
  create(model) {
var defer = Backbone.$.Deferred();

    // Assign an id to new models
    if (!model.id&amp;&amp; model.id !== 0) {
      let id = this.generateId();
model.set(model.idAttribute, id);
    }

    // Get the database connection
this.openDatabase()
.then(db =&gt;this.store(db, model))
.then(result =&gt;defer.resolve(result));

    return defer.promise();
  }

generateId() {
    return crispy.base32String(ID_LENGTH);
  }
  // ...
}</pre></div><p>When a <a id="id266" class="indexterm"/>record is created, we should ensure that the model has an ID. We can generate it for the models that do not have an ID assigned. The <code class="literal">store()</code> method will put the record in the indexedDB database:</p><div><pre class="programlisting">// indexedDB/dataStore.js

var crispy = require('crispy-string');

// ...

class DataStore {
  // ...

store(db, model) {
var defer = Backbone.$.Deferred();

    // Get the name of the object store
varstoreName = model.store;

    // Get the object store handler
vartx = db.transaction(storeName, 'readwrite');
var store = tx.objectStore(storeName);

    // Save the model in the store
varobj = model.toJSON();
store.put(obj);

tx.oncomplete = function() {
defer.resolve(obj);
    };

tx.onerror = function() {
defer.reject(obj);
    };

    return defer.promise();
  }

  // ...
}</pre></div><p>The <code class="literal">store()</code> method obtains the name of the store from the <code class="literal">modelstore</code> attribute and then, creates a <code class="literal">readwrite</code> transaction for the given store name to put the record on it. The <code class="literal">update()</code> method uses the same <code class="literal">store()</code> method to save the record:</p><div><pre class="programlisting">// indexedDB/dataStore.js
class DataStore {
  // ...

  update(model) {
var defer = Backbone.$.Deferred();

    // Get the database connection
this.openDatabase()
.then(db =&gt;this.store(db, model))
.then(result =&gt;defer.resolve(result));

    return defer.promise();
  }

  // ...
}</pre></div><p>The update method <a id="id267" class="indexterm"/>does not assign an ID to the model, it completely replaces the previous record with the new model data. To delete a record, you can use the <code class="literal">delete()</code> method of the object store handler:</p><div><pre class="programlisting">// indexedDB/dataStore.js
class DataStore {
  // ...

destroy(model) {
var defer = Backbone.$.Deferred();

    // Get the database connection
this.openDatabase().then(function(db) {
      // Get the name of the object store
      let storeName = model.store;

      // Get the store handler
vartx = db.transaction(storeName, 'readwrite');
var store = tx.objectStore(storeName);

      // Delete object from the database
      let obj = model.toJSON();
store.delete(model.id);

tx.oncomplete = function() {
defer.resolve(obj);
      };

tx.onerror = function() {
defer.reject(obj);
      };
    });

    return defer.promise();
  }

  // ...
}</pre></div><p>To get all the <a id="id268" class="indexterm"/>models stored on an object store, you need to open a cursor and put all the items in an array, as follows:</p><div><pre class="programlisting">// indexedDB/dataStore.js
class DataStore {
  // ...

findAll(model) {
var defer = Backbone.$.Deferred();

    // Get the database connection
this.openDatabase().then(db =&gt; {
      let result = [];

      // Get the name of the object store
      let storeName = model.store;

      // Get the store handler
      let tx = db.transaction(storeName, 'readonly');
      let store = tx.objectStore(storeName);

      // Open the query cursor
      let request = store.openCursor();

      // onsuccesscallback will be called for each record
      // found for the query
request.onsuccess = function() {
        let cursor = request.result;

        // Cursor will be null at the end of the cursor
        if (cursor) {
result.push(cursor.value);

          // Go to the next record
cursor.continue();
        } else {
defer.resolve(result);
        }
      };
    });

    return defer.promise();
  }

  // ...
}</pre></div><p>Note how<a id="id269" class="indexterm"/> this time the transaction opened is in the <code class="literal">readonly</code> mode. A single object can be obtained by querying the model ID:</p><div><pre class="programlisting">// indexedDB/dataStore.js
class DataStore {
  // ...

  find(model) {
var defer = Backbone.$.Deferred();

    // Get the database connection
this.openDatabase().then(db =&gt; {
      // Get the name of the collection/store
      let storeName = model.store;

      // Get the store handler
      let tx = db.transaction(storeName, 'readonly');
      let store = tx.objectStore(storeName);

      // Open the query cursor
      let request = store.openCursor(IDBKeyRange.only(model.id));

request.onsuccess = function() {
        let cursor = request.result;

        // Cursor will be null if record was not found
        if (cursor) {
defer.resolve(cursor.value);
        } else {
defer.reject();
        }
      };
    });

    return defer.promise();
  }

  // ...
}</pre></div><p>In the same <a id="id270" class="indexterm"/>way as we did with localStorage, this IndexedDB driver can be used to overwrite the <code class="literal">Backbone.sync</code> function:</p><div><pre class="programlisting">// app.js
var store = new DataStore();

// ...

Backbone.sync = function(method, model, options) {
var response;
var defer = Backbone.$.Deferred();

  switch(method) {
    case 'read':
      if (model.id) {
        response = store.find(model);
      } else {
        response = store.findAll(model);
      }
      break;

    case 'create':
      response = store.create(model);
      break;

    case 'update':
      response = store.update(model);
      break;

    case 'delete':
      response = store.destroy(model);
      break;
  }

response.then(function(result) {
    if (options &amp;&amp;options.success) {
options.success(result);
defer.resolve(result);
    }
  });

  return defer.promise();
};</pre></div><p>Then, models <a id="id271" class="indexterm"/>should add the <code class="literal">store</code> attribute to indicate in which object store the model will be saved:</p><div><pre class="programlisting">class Contact extends Backbone.Model {
  constructor(options) {
// ,,,
this.store = 'contacts';
  }

  // ...
}

class ContactCollection extends Backbone.Collection {
  constructor(options) {
// ...
this.store = 'contacts';
  }

// ...
}</pre></div><p>IndexedDB allows <a id="id272" class="indexterm"/>you to store more data than localStorage; therefore, you can use it to store the avatar image too. Just make sure that the <code class="literal">avatar</code> attribute is set so that an image is always selected:</p><div><pre class="programlisting">class ContactPreview extends ModelView {
  // ...

fileSelected(event) {
event.preventDefault();

var $img = this.$('img');

    // Get a blob instance of the file selected
var $fileInput = this.$('#avatar')[0];
varfileBlob = $fileInput.files[0];

    // Render the image selected in the img tag
varfileReader = new FileReader();
fileReader.onload = event =&gt; {
      $img.attr('src', event.target.result);

this.model.set({
        avatar: {
url: event.target.result
        }
      });
    };
fileReader.readAsDataURL(fileBlob);

this.trigger('avatar:selected', fileBlob);
  }
}</pre></div><p>Do not try to<a id="id273" class="indexterm"/> upload the image:</p><div><pre class="programlisting">class ContactEditor {
// ...

showEditor(contact) {
    // ...

    // When avatar is selected, we can save it inmediatly if the
    // contact already exists on the server, otherwise just
    // remember the file selected
    //this.listenTo(contactPreview, 'avatar:selected', blob =&gt; {
    //  this.avatarSelected = blob;

    //  if (!contact.isNew()) {
    //    this.uploadAvatar(contact);
    //  }
    //});
  }
saveContact(contact) {
// ...

    // The avatar attribute is read-only
    //if (contact.has('avatar')) {
    //  contact.unset('avatar');
    //}

// ...
  }

  // ...
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Summary</h1></div></div></div><p>You have learned two ways to store data in the browser and use them as a replacement for a RESTful API server. The localStorage method has a simple API and it is widely supported for all major browsers; this is going to be your first choice if you want support old browsers; however, it has the limitation that you can only store five megabytes.</p><p>IndexedDB is powerful; however, its API is more complicated than localStorage. You need to learn some concepts before you start working with it. Once you know how it works, you should write your app asynchronously.</p></div></body></html>