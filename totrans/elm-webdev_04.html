<html><head></head><body>
        

                            
                    <h1 class="header-title">Preparing a Unit Conversion Website in Elm</h1>
                
            
            
                
<p>Welcome to <a href="5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml">Chapter 4</a>, <em>Preparing a Unit Conversion Website in Elm</em>. The goal of this chapter is to prepare a website that will convert miles to metric system measurements, that is, to kilometers. By completing this chapter, you will acquire practical skills that are integral to how Elm works, all in a fun project.</p>
<p>The topics we will cover include:</p>
<ul>
<li>Elm language features used to make the website, which include type annotations, <kbd>case</kbd> expressions, union types, and messages</li>
<li>Understanding <kbd>Result</kbd> as a way to handle errors</li>
<li>Discussing Elm architecture, and workflow concepts to make the website</li>
</ul>
<p>After completing this chapter, you will be able to:</p>
<ul>
<li>Work with type annotations, case expressions, union types, and messages</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What are we going to build?</h1>
                
            
            
                
<p>In this chapter, we will build the core of a simple unit conversion website. We will introduce a lot of new concepts and use them in practice right away. To be able to fit everything into one chapter, we'll only set up the basic plumbing. </p>
<p>In the next chapter, we'll expand on what we have built to create a more complex structure. To get started, we'll start a brand new Elm app.</p>
<p>To do that, run the following command in your console:</p>
<pre><strong>create-elm-app unit-converter-simple</strong></pre>
<p>Remember that to run your app, you need to point your console to your new app folder, and then use the <kbd>elm-app start</kbd> command in your console. Now that we've set everything up for development, it's time to start building the app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building our Unit Conversion app</h1>
                
            
            
                
<p>To begin, let's delete everything in <kbd>Main.elm</kbd>. Next, let's set up a working bare-bones app:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>-- Model<br/>init =<br/>    {}<br/><br/>-- Update<br/>type Msg<br/>    = Nothing<br/><br/>update msg model =<br/>    model<br/><br/>-- View<br/>view model =<br/>    div [] [ text "Everything will go here" ]<br/><br/>-- Main<br/>main =<br/>    beginnerProgram<br/>        { model = init<br/>        , view = view<br/>        , update = update<br/>        }</pre>
<p>At this point, we have an app that works, that is, that displays on the screen. However, it doesn't really do anything. Still, it is worthwhile to look at what each line of the preceding code actually does. We start off the usual way, by declaring the <kbd>main</kbd> module and importing all the other modules used in our app.</p>
<p>The <kbd>init</kbd> function is our app's initial model, which we set to an empty <kbd>Record</kbd>. Next, we set up a union type of <kbd>Msg</kbd>, and give it the value of <kbd>Nothing</kbd>. <kbd>Nothing</kbd> is simply nothing—our <kbd>Msg</kbd> union type currently has no value.</p>
<p>Next, we pass two parameters to our <kbd>update</kbd> function, <kbd>msg</kbd> and <kbd>model</kbd>, and return the <kbd>model</kbd>. The <kbd>view</kbd> function is just a <kbd>div</kbd> with a text node in its second <kbd>List</kbd>.</p>
<p>Finally, let's look at the entry point of our app, the <kbd>main</kbd> function. We simply pass it the <kbd>beginnerProgram</kbd>, setting the <kbd>model</kbd> to the value of <kbd>init</kbd>, <kbd>view</kbd> to <kbd>view</kbd>, and <kbd>update</kbd> to <kbd>update</kbd>. Next, let's update the <kbd>init</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the init function</h1>
                
            
            
                
<p>Our <kbd>init</kbd> function will be the initial state of our app. Let's update it like this:</p>
<pre>init = <br/>    { unit1 = "Kilometers"<br/>    , unit2 = "Miles"<br/>    , ratio = 1.608<br/>    , convertedValue = 0.0<br/>    }</pre>
<p>The <kbd>init</kbd> function gets assigned the value of a <kbd>Record</kbd> that has two <kbd>Strings</kbd> and two <kbd>Floats</kbd>. Basically, here we are modeling the data that our app will use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Type annotations and type aliases</h1>
                
            
            
                
<p>At this point, we might want to add the type annotation above the <kbd>init</kbd> function. If you are using the linter with Atom, you should see the following warning in the editor:</p>
<pre>Top-level value 'init' does not have a type annotation.<br/>I inferred the type annotation so you can copy it into your code:<br/>init : { convertedValue : Float, ratio : Float, unit1 : String, unit2 : String }</pre>
<p>Note that the order of named values inside the type annotation does not match the order we gave the <kbd>Record</kbd> we assigned to our <kbd>init</kbd> function. The reason is simple: records in Elm are not index-based.</p>
<p>Thus, we can choose to add the suggested type annotation above the <kbd>init</kbd> function, and the compiler will be happy.</p>
<p>However, there is an even better thing that we can do: use a type alias instead. With type alias, we shorten our type annotations, making it easier to use them wherever needed. In this case, we need to create a type alias to use on the <kbd>init</kbd> function. Since the <kbd>init</kbd> function is basically just the initial model, it only makes sense to create a type alias called <kbd>Model</kbd>, and then use it as needed.</p>
<p>Thus, let's set up a type alias <kbd>Model</kbd>, just above the <kbd>init</kbd> function in our code, like so:</p>
<pre>type alias Model = <br/>    { convertedValue : Float<br/>    , ratio : Float<br/>    , unit1 : String<br/>    , unit2 : String <br/>    }</pre>
<p>Now, our updated <kbd>Main.elm</kbd> will look like this:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/><br/>-- MODEL<br/><br/>type alias Model =<br/>    { convertedValue : Float<br/>    , ratio : Float<br/>    , unit1 : String<br/>    , unit2 : String <br/>    }<br/><br/><br/>init : Model<br/>init =<br/>    { unit1 = "Kilometers"<br/>    , unit2 = "Miles"<br/>    , ratio = 1.608<br/>    , convertedValue = 0.0<br/>    }</pre>
<p>Looking at the preceding code, we can see that the type annotation for <kbd>init</kbd> is simply <kbd>init : Model</kbd>, because now we are using the type alias of <kbd>Model</kbd>. Let's turn our attention to the <kbd>view</kbd> and <kbd>update</kbd> functions now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating the view and update functions</h1>
                
            
            
                
<p>It's important to understand that the <kbd>view</kbd> and <kbd>update</kbd> functions are connected via messages. Whatever message is sent out by the <kbd>view</kbd> function is received by the <kbd>update</kbd> function. That's why the type of message that the <kbd>view</kbd> function sends should be the same type that the <kbd>update</kbd> message receives. This might seem obvious, but having no doubts about this will make you a better Elm developer. </p>
<p>First, let's add some more content to our <kbd>view</kbd> function:</p>
<pre>view model =<br/>    div []<br/>        [ p []<br/>            [ label [ for "unit1Input" ] [ text "Kilometers" ]<br/>            , br [] []<br/>            , input [ id "unit1Input" ] []<br/>            , button [ onClick Nothing ] [ text "Switch to Miles Input" ]<br/>            , p [ id "unit2Value" ] [ text "Result of calculation" ]<br/>            ]<br/>        ]</pre>
<p>At this point, our <kbd>view</kbd> is displaying on the screen, and the button sends the message of <kbd>Nothing</kbd> to <kbd>update</kbd>. If we compile the app and run it at this point, we will see an improved UI on our page. However, everything is static, and clicking the button will not do anything at this point. </p>
<p>Let's begin making the page interactive by replacing the <kbd>Nothing</kbd> value with a different value. We'll call it <kbd>Swap</kbd>:</p>
<pre>view model =<br/>    div []<br/>        [ p []<br/>            [ label [ for "unit1Input" ] [ text "Kilometers" ]<br/>            , br [] []<br/>            , input [ id "unit1Input" ] []<br/>            , button [ onClick Swap] [ text "Switch to Miles Input" ]<br/>            , p [ id "unit2Value" ] [ text "Result of calculation" ]<br/>            ]<br/>        ]</pre>
<p>Since our <kbd>view</kbd> function is now sending the <kbd>Swap</kbd> message <kbd>onClick</kbd> of the button in our <kbd>view</kbd>, let's update our union type of <kbd>Msg</kbd>, with the value of <kbd>Swap</kbd>, just above the <kbd>update</kbd> function:</p>
<pre>type Msg<br/>    = Swap </pre>
<p>Finally, let's tell the <kbd>update</kbd> function what to do with the message of <kbd>Swap</kbd>:</p>
<pre>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1 }</pre>
<p>In the preceding code snippet, we are using some code that we have not seen before. Let's look at how it works. If the <kbd>update</kbd> function receives a message of value <kbd>Swap</kbd>, it will run the following expression:</p>
<pre>{ model | unit1 = model.unit2, unit2 = model.unit1 }</pre>
<p>What does the preceding code do? Let's start with this section of code:</p>
<pre>{ model | ... }</pre>
<p>The preceding code means—return the same model that you had previously, with the only update specified in the code on the right-hand side of the pipe character. </p>
<p>The code on the right of the pipe character does the following: it sets the value of <kbd>unit1</kbd> to <kbd>model.unit2</kbd>, and the value of <kbd>unit2</kbd> to <kbd>model.unit1</kbd>. </p>
<p>If you save your app at this point and run it, you'll see that after it renders the HTML in the browser; nothing else changes. To make sure the code actually does something, we need to replace the hard-coded <kbd>Strings</kbd> inside the <kbd>text</kbd> functions of our <kbd>view</kbd> to the appropriate <kbd>model</kbd> values, like this:</p>
<pre>view model =<br/>    div []<br/>        [ div []<br/>            [ label [ for "unit1Input" ] [ text model.unit1 ]<br/>            , input [ id "unit1Input" ] []<br/>            , button [ onClick Swap ] [ text "Switch" ]<br/>            , label [ for "unit2" ] [ text model.unit2 ]<br/>            , div [ id "unit2Value" ] [ text "1234" ]<br/>            ]<br/>        ]</pre>
<p>Now, running our code and clicking the button will actually send the <kbd>Swap</kbd> message from the <kbd>view</kbd> to the <kbd>update</kbd>, which the user will see as "Kilometers" and "Miles" on the screen switching places on a button-click.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the conversion logic</h1>
                
            
            
                
<p>Now, we can make our app convert the inputs it receives on a button- click. Let's begin by updating our <kbd>view</kbd> function so that it displays the initial converted value, that is, the value of 0.0, as that is the value we gave the <kbd>Record</kbd> that we are passing to the <kbd>init</kbd> function. Note that the following code will not compile:</p>
<pre>view model =<br/>    div []<br/>        [ div []<br/>            [ label [ for "unit1Input" ] [ text model.unit1 ]<br/>            , input [ id "unit1Input" ] []<br/>            , button [ onClick Swap ] [ text "Switch" ]<br/>            , label [ for "unit2" ] [ text model.unit2 ]<br/>            , div [ id "unit2Value" ] [ text model.convertedValue ]<br/>            ]<br/>        ]</pre>
<p>Running our app with the preceding update will result in the compiler throwing an error. Why? Simply because the <kbd>text</kbd> function must always receive a <kbd>String</kbd>. So, we need to first run the <kbd>toString</kbd> function on <kbd>model.convertedValue</kbd>, and then give the result of that expression to the <kbd>text</kbd> function. Like this:</p>
<pre>...<br/>            , div [ id "unit2Value" ] [ text (toString model.convertedValue) ]<br/>            ]<br/>        ]</pre>
<p>Running the app at this point will only introduce a minor change on the screen. A zero will be displayed on the screen. However, if the user types into the input field, this will not affect the zero—it will still just sit there. Let's fix that now by improving the <kbd>input</kbd> function in our view.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Improving the input function</h1>
                
            
            
                
<p>In order for our app to be able to convert the values entered into the input text field, we need to be able to do something with that input. In other words, we need to send the value of the input to the <kbd>update</kbd> function, and then tell the <kbd>update</kbd> function what to do with the message that it received.</p>
<p>So first, let's add to our <kbd>view</kbd> function so that when the user types something, it sends a <kbd>message</kbd> of that event to the <kbd>update</kbd> function:</p>
<pre>view model =<br/>    div []<br/>        [ div []<br/>            [ label [ for "unit1Input" ] [ text model.unit1 ]<br/>            , input [ id "unit1Input", onInput Convert ] []<br/>            , button [ onClick Swap ] [ text "Switch" ]<br/>            , label [ for "unit2" ] [ text model.unit2 ]<br/>            , div [ id "unit2Value" ] [ text (toString model.convertedValue) ]<br/>            ]<br/>        ]</pre>
<p>In the preceding code, we have just added another item to the first <kbd>List</kbd> of the <kbd>input</kbd> function. The item we added is the <kbd>onInput</kbd> function, which receives a parameter we called <kbd>Convert</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The stumbling block</h1>
                
            
            
                
<p>So far in the development of our app, we haven't had any major issues. We are about to hit a minor road bump, and it's important to walk through this slowly, just as it's laid out in the section that follows.</p>
<p>We are done with the <kbd>view</kbd>. Now, we can change our <kbd>update</kbd> function accordingly:</p>
<pre>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1, ratio = 1 / model.ratio }<br/><br/>        Convert newValue -&gt;<br/>            { model | convertedValue = newValue }</pre>
<p>If we ran our app right now, it would not compile. Even though the preceding code is perfectly valid, there is a piece missing. Have a look at the error message, and try to understand what the reason is for this error:</p>
<pre class="mce-root">NAMING ERROR<br/> Line 28, Column 9<br/> Cannot find pattern Convert<br/>NAMING ERROR<br/> Line 36, Column 48<br/> Cannot find variable Convert</pre>
<p class="mce-root">Obviously, on line <kbd>28</kbd>, our <kbd>update</kbd> function is trying to pattern-match for the pattern called <kbd>Convert</kbd>, and it cannot find it. Similarly, on line <kbd>36</kbd>, our <kbd>view</kbd> function is trying to use a variable called <kbd>Convert</kbd>, but it cannot find it.</p>
<p class="mce-root">To solve this error, let's briefly think about the messages that our <kbd>view</kbd> function can send. How many are there?</p>
<p class="mce-root">Of course, there are only two messages: <kbd>Swap</kbd> and <kbd>Convert</kbd>.</p>
<p>If you look at the <kbd>Swap</kbd> message, you'll see that it's used in three places in our code: in the <kbd>view</kbd> function, as a parameter of the <kbd>onClick</kbd> function. In the <kbd>update</kbd> function's <kbd>case</kbd> expression, it is used as the <kbd>Swap</kbd> pattern, and in the union type of <kbd>Msg</kbd>, it is used as its only possible value.</p>
<p>Thus, to solve our error, we need to add the <kbd>Convert</kbd> value as another possible value of the <kbd>Msg</kbd> union type, like this:</p>
<pre>type Msg <br/>    = Swap<br/>    | Convert</pre>
<p>Running the app now will result in another error, but the solution to this one should be a bit more obvious. Here is the text of the error:</p>
<pre>TOO MANY ARGUMENTS<br/>Line 29, Column 9<br/>Pattern Main.Convert has too many arguments.<br/>Expecting 0, but got 1.</pre>
<p>As we can see from the error message, the compiler is looking at the <kbd>Convert</kbd> pattern, and it sees that it has the argument we called <kbd>newValue</kbd>. But when it looks at the <kbd>Msg</kbd> union type, it only sees <kbd>Convert</kbd>. There are no arguments there!</p>
<p>To fix the current error, we need to specify the argument that the <kbd>Convert</kbd> value must take along with it:</p>
<pre>type Msg<br/>    = Swap<br/>    | Convert String</pre>
<p>Saving the preceding changes in our app will bring us one step closer to the fully working code. </p>
<p>With the current code, even after the improvements, our app still won't compile. An impatient reader at this point might start getting slightly irritated with the compiler, helpful as it is. </p>
<p>However, what follows is probably the most important piece of knowledge in this entire chapter. It's about toggling primitive values in our apps - a subject that is rarely, if ever, discussed in online resources, perhaps because it is considered as another one of those <em>expected understandings</em>.</p>
<p>So, let's work through this stumbling block. To begin, let's revisit our <kbd>model</kbd>, that is, the type alias of <kbd>Model</kbd>:</p>
<pre>type alias Model =<br/>    { convertedValue : Float<br/>    , ratio : Float<br/>    , unit1 : String<br/>    , unit2 : String <br/>    }</pre>
<p>As we can see in the preceding code, the <kbd>convertedValue</kbd> is a <kbd>Float</kbd>, not a <kbd>String</kbd>. We might think that the solution would be to simply change the value passed to <kbd>Convert</kbd> from <kbd>String</kbd> to <kbd>Float</kbd>, in our <kbd>Msg</kbd> union type:</p>
<pre>type Msg<br/>    = Swap<br/>    | Convert Float</pre>
<p>Unfortunately, this will only result in a different error:</p>
<pre><strong>TYPE MISMATCH</strong><br/><strong> Line 37, Column 48</strong><br/><strong> The argument to function onInput is causing a mismatch.<br/></strong><br/><strong>Function onInput is expecting the argument to be:</strong><br/><br/><strong>String -&gt; msg</strong><br/><strong> But it is:</strong><br/><strong>Float -&gt; Main.Msg</strong></pre>
<p>So, obviously, our <kbd>onInput</kbd> message needs to be a <kbd>String</kbd>. Let's try converting the <kbd>newValue</kbd>, which is a <kbd>String</kbd>, to a <kbd>Float</kbd>:</p>
<pre>        Convert newValue -&gt;<br/>            { model | convertedValue = String.toFloat newValue }</pre>
<p>The preceding code will throw yet another error, and this one might look a bit intimidating at first:</p>
<pre><strong>TYPE MISMATCH</strong><br/><strong> Line 47, Column 9</strong><br/><strong> The argument to function beginnerProgram is causing a mismatch.</strong><br/><strong>Function beginnerProgram is expecting the argument to be:</strong><br/><strong>{ ..., update : Main.Msg -&gt; Main.Model -&gt; Main.Model }</strong><br/><strong> But it is:</strong><br/><strong>{ ...</strong><br/><strong> , update :</strong><br/><strong> Main.Msg</strong><br/><strong> -&gt; { convertedValue : Result.Result String Float</strong><br/><strong> , ratio : Float</strong><br/><strong> , unit1 : String</strong><br/><strong> , unit2 : String</strong><br/><strong> }</strong><br/><strong> -&gt; { convertedValue : Result.Result String Float</strong><br/><strong> , ratio : Float</strong><br/><strong> , unit1 : String</strong><br/><strong> , unit2 : String</strong><br/><strong> }</strong><br/><strong> }</strong><br/><strong> Hint: Problem at update.convertedValue...</strong></pre>
<p>The reason why this message might look a bit less intuitive from what we're used to is two-fold. Firstly, the message is reporting an error that has to do with our type alias <kbd>Model</kbd>, which was great at hiding complexity from our app, but now it might be hampering our efforts to understand the issue. Secondly, inside the error, we can see a new Elm keyword: <kbd>Result</kbd>.</p>
<p>Let's resolve the error step by step. We'll begin by trying to produce a more understandable error, by commenting out the type alias of <kbd>Model</kbd>, together with the <kbd>init</kbd> function's type annotation:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>-- Model<br/>{--<br/>type alias Model = <br/>    { convertedValue : Float<br/>    , ratio : Float<br/>    , unit1 : String<br/>    , unit2 : String <br/>    }<br/><br/>init : Model<br/>--}</pre>
<p>Now, let's try recompiling the app to get a slightly different error message, as follows:</p>
<pre><strong>TYPE MISMATCH</strong><br/><strong> Line 49, Column 9</strong><br/><strong> The argument to function beginnerProgram is causing a mismatch.</strong><br/><strong>Function beginnerProgram is expecting the argument to be:</strong><br/><strong>{ ...</strong><br/><strong> , update :</strong><br/><strong> Main.Msg</strong><br/><strong> -&gt; { ..., convertedValue : Float }</strong><br/><strong> -&gt; { ..., convertedValue : Float }</strong><br/><strong> }</strong><br/><strong> But it is:</strong><br/><strong>{ ...</strong><br/><strong> , update :</strong><br/><strong> Main.Msg</strong><br/><strong> -&gt; { ..., convertedValue : Result.Result String Float }</strong><br/><strong> -&gt; { ..., convertedValue : Result.Result String Float }</strong><br/><strong> }</strong><br/><strong> Hint: Problem at update.convertedValue...</strong></pre>
<p>The preceding error message makes it slightly more obvious. We are having issues with this <kbd>Result.Result</kbd> thing. Just what is it?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dealing with the Result.Result error</h1>
                
            
            
                
<p><kbd>Result</kbd> is a type. We use the <kbd>Result</kbd> type whenever we have a function that could possibly return an error.</p>
<p>In our preceding example, we have an input field. The user types into the input field, and we are expecting the input to be of type <kbd>Float</kbd>. However, what if the user types in one or more letters, or a combination of letters and numbers, or any other odd character other than just numbers?</p>
<p>Conceptually, it boils down to two possibilities—a function returns an <em>error</em> by virtue of the user typing unexpected characters into the input field, or it returns a <em>result</em>, by virtue of the user typing <kbd>Floats</kbd>, as we expect.</p>
<p>This is how the <kbd>Result</kbd> package is defined in the official documentation, available at: <a href="http://package.elm-lang.org/packages/elm-lang/core/latest/Result">http://package.elm-lang.org/packages/elm-lang/core/latest/Result</a>:</p>
<p>"A Result is the result of a computation that may fail. This is a great way to manage errors in Elm."</p>
<p>The official documentation gives the following union type definition:</p>
<pre>type Result error value<br/>    = Ok value<br/>    | Err error</pre>
<p>So, if our function succeeds, we'll get an <kbd>Ok</kbd> with the value; otherwise, we'll get an <kbd>Err</kbd> with an error. This begs the question: how do we then deal with errors in our programs, using <kbd>Result</kbd>?</p>
<p>At its core, the solution is simple and elegant, like everything else in Elm: if we get an <kbd>Ok</kbd>, the function should return a value; if we get an <kbd>Err</kbd>, the function should return a <em>default</em> value. Let's take another example from the official documentation and run it in the REPL:</p>
<pre>Result.withDefault 0 (String.toInt "123") == 123</pre>
<p>In the preceding code, we are parsing the string of <kbd>"123"</kbd> to an <kbd>Int</kbd>, but just to be on the safe side, in case we get an <kbd>Err</kbd>, we set the default value to zero.</p>
<p>This is what the REPL returns:</p>
<pre>True : Bool</pre>
<p>Let's try the second example now:</p>
<pre>Result.withDefault 0 (String.toInt "abc") == 0</pre>
<p>What will REPL return now? The exact same thing:</p>
<pre>True : Bool</pre>
<p>The conclusion is, no matter what we write inside the double quotes, Elm will take care of it, as long as we have a default solution for <kbd>Err</kbd> values.</p>
<p>Now that we understand what <kbd>Result.Result</kbd> is, let's go back to fixing our app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Result type to fix our app</h1>
                
            
            
                
<p>After getting sidetracked with a lot of error messages and some dry theory, let's put our new skills in to practice by changing the <kbd>update</kbd> function to the following code:</p>
<pre>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1 }<br/>            <br/>        Convert newValue -&gt;<br/>            { model | convertedValue = Result.withDefault 10 (String.toFloat newValue) }</pre>
<p>The preceding code should be a lot easier to understand now. If our <kbd>update</kbd> function receives a message that pattern-matches the <kbd>Convert</kbd> pattern with its <kbd>newValue</kbd> string, we'll execute the code after the arrow.</p>
<p>The code after the arrow says: use the existing model, with a change to be made only to the model's <kbd>convertedValue</kbd>. The updated value to assign to <kbd>convertedValue</kbd> is the result of the expression:</p>
<pre>Result.withDefault 10 (String.toFloat newValue)</pre>
<p>Elm evaluates the expression starting with the parentheses: it takes the <kbd>newValue</kbd> String and converts it to <kbd>Float</kbd>.</p>
<p>If the operation is successful, it returns the given <kbd>Float</kbd> as the value of the evaluated expression. If the operation is not successful, it returns number <kbd>10</kbd>, and that is indeed what you'll see on the screen if you type anything other than numbers into the input field in your running app.</p>
<p>There is only one thing left to do: uncomment the type alias <kbd>Model</kbd> and the <kbd>init</kbd> function's type annotation. With all the changes we have had, this is the full code of our app at this point:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>-- Model<br/>type alias Model = <br/>    { convertedValue : Float<br/>    , ratio : Float<br/>    , unit1 : String<br/>    , unit2 : String <br/>    }<br/><br/>init : Model<br/><br/>init = <br/>    { unit1 = "Kilometers"<br/>    , unit2 = "Miles"<br/>    , ratio = 1.608<br/>    , convertedValue = 0.0<br/>    }<br/><br/>-- Update<br/>type Msg<br/>    = Swap<br/>    | Convert String<br/><br/>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1 }<br/>            <br/>        Convert newValue -&gt;<br/>            { model | convertedValue = Result.withDefault 10 (String.toFloat newValue) }<br/>            <br/>-- View<br/>view model =<br/>    div []<br/>        [ div []<br/>            [ label [ for "unit1Input" ] [ text model.unit1 ]<br/>            , input [ id "unit1Input", onInput Convert ] []<br/>            , button [ onClick Swap ] [ text "Switch" ]<br/>            , label [ for "unit2" ] [ text model.unit2 ]<br/>            , div [ id "unit2Value" ] [ text (toString model.convertedValue) ]<br/>            ]<br/>        ]<br/><br/>-- Main<br/>main =<br/>    beginnerProgram<br/>        { model = init<br/>        , view = view<br/>        , update = update<br/>        }</pre>
<p>Run the app and test it out. </p>
<p>If you type a number into the input field, you'll get that same number on the next line. However, if you type any other characters inside the input field, you'll get number 10 on the next line—a clear sign that our function's <kbd>Result</kbd> was <kbd>Err</kbd>.</p>
<p>In the next section, we'll make our app actually convert the values it receives from the input field.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculating the conversion</h1>
                
            
            
                
<p>Let's update the <kbd>Convert</kbd> pattern in the <kbd>update</kbd> function's <kbd>case</kbd> expression. Our new code will look like this:</p>
<pre>        Convert newValue -&gt;<br/>            { model | convertedValue = (Result.withDefault 10 (String.toFloat newValue)) * model.ratio }</pre>
<p>After the update, save the app and test the behavior of the input field. Once you start typing a number, you'll see it immediately being converted to its converted value in kilometers.</p>
<p>However, there is another improvement we need to make. As our <kbd>Result.withDefault</kbd> is now 10, whenever a user types anything else besides numbers, or even before they start typing, we see the number <kbd>16.08</kbd> displayed on the screen.</p>
<p>This is an easy enough fix. Instead of 10, we'll simply use zero as the default <kbd>Result</kbd>. Update the code to the following:</p>
<pre>        Convert newValue -&gt;<br/>            { model | convertedValue = (Result.withDefault 0 (String.toFloat newValue)) * model.ratio }</pre>
<p>Now, the app has the expected behavior. </p>
<p>However, the expression after the <kbd>-&gt;</kbd> operator is a bit unwieldy. We will make our code a bit nicer to look at, and learn another feature of the Elm language along the way, by using a <kbd>let</kbd> expression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring our app using a let expression</h1>
                
            
            
                
<p>At this point, we are ready to use a <kbd>let</kbd> expression to improve the <kbd>Convert</kbd> pattern of our <kbd>update</kbd> function's case expression.</p>
<p>A <kbd>let</kbd> expression in Elm consists of two parts: <kbd>let</kbd> and <kbd>in</kbd>. The <kbd>let</kbd> part lets us declare variables and functions that will be used in the <kbd>in</kbd> section of the <kbd>let</kbd> expression. It's important to note that the variables declared here are scoped to the function they are used in. The rest of our program is not aware of it. In other words, these variables are local, and do not exist in the rest of our program.  Contrast that to functions such as the <kbd>update</kbd> or the <kbd>view</kbd> functions, which live in the global scope.</p>
<p>The <kbd>in</kbd> section of a <kbd>let</kbd> expression should return a single value as a result of whatever expressions are placed there.</p>
<p>Let's look at how we can write our <kbd>Convert</kbd> pattern as a <kbd>let</kbd> expression. To begin, let's look at it again:</p>
<pre>        Convert newValue -&gt;<br/>            { model | convertedValue = (Result.withDefault 0 (String.toFloat newValue)) * model.ratio }</pre>
<p>Now, let's think about putting a part of the preceding code in a variable, scoped to the <kbd>let</kbd> expression. An obvious candidate would be this bit of code:</p>
<pre>(Result.withDefault 0 (String.toFloat newValue))</pre>
<p>What name could we give to the preceding snippet of code? </p>
<p>How about <kbd>floatValue</kbd>? It's a nice, descriptive name, since we are indeed converting the existing <kbd>newValue</kbd> string to a <kbd>Float</kbd>, and giving it the default value of zero. So, our updated code will look like this:</p>
<pre>floatValue =<br/>   Result.withDefault 0 (String.toFloat newValue)</pre>
<p>Next, let's rewrite our <kbd>Convert</kbd> pattern as a <kbd>let</kbd> expression:</p>
<pre>Convert newValue -&gt;<br/>    let<br/>        floatValue =<br/>            Result.withDefault 0 (String.toFloat newValue)<br/>    in<br/>        { model | convertedValue = floatValue * model.ratio }</pre>
<p>There, much better.</p>
<p>We've reduced the cognitive load of trying to decipher that long, one-line expression we previously had, into a nice <kbd>let</kbd> expression that is a lot easier to reason about. Working with <kbd>let</kbd> expressions will soon feel so natural to you that you'll wonder how you ever did without them. Why? Because writing our code like this makes a clear separation between variables being declared in the <kbd>let</kbd> part of the <kbd>let</kbd> expression, and the actual expression, in its <kbd>in</kbd> part.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making our app look nicer</h1>
                
            
            
                
<p>In this chapter, we've covered a lot of theory and we've also put it into practice. Let's look at the full code of our app at this stage:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (beginnerProgram, div, button, input, text, label, span)<br/>import Html.Attributes exposing (for, id, value)<br/>import Html.Events exposing (onClick, onInput)<br/><br/><br/>type alias Model =<br/>    { unit1 : String<br/>    , unit2 : String<br/>    , ratio : Float<br/>    , convertedValue : Float<br/>    }<br/><br/><br/>initModel : Model<br/>initModel =<br/>    { unit1 = "Kilometers"<br/>    , unit2 = "Miles"<br/>    , ratio = 1.608<br/>    , convertedValue = 0.0<br/>    }<br/><br/><br/>main =<br/>    beginnerProgram { model = initModel, view = view, update = update }<br/><br/><br/>view model =<br/>    div []<br/>        [ div []<br/>            [ label [ for "unit1Input" ] [ text model.unit1 ]<br/>            , input [ id "unit1Input", onInput Convert ] []<br/>            , button [ onClick Swap ] [ text "Switch" ]<br/>            , label [ for "unit2" ] [ text model.unit2 ]<br/>            , div [ id "unit2Value" ] [ text (toString model.convertedValue) ]<br/>            ]<br/>        ]<br/><br/><br/>type Msg<br/>    = Swap<br/>    | Convert String<br/><br/><br/>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1, ratio = 1 / model.ratio }<br/><br/>        Convert newValue -&gt;<br/>            let<br/>                floatValue =<br/>                    Result.withDefault 0 (String.toFloat newValue)<br/>            in<br/>                { model | convertedValue = floatValue * model.ratio }</pre>
<p>Next, we'll focus on making the app look nicer by using Bootstrap 4.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Bootstrap styles</h1>
                
            
            
                
<p>To begin, navigate to <kbd>index.html</kbd> in your project's <kbd>public</kbd> folder and add the following line of code:</p>
<pre>&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous"&gt;</pre>
<p>The starting point of our code update will be a simple snippet of HTML, copied from the official Bootstrap documentation website. The code we will be using is for a Bootstrap-based input group:</p>
<pre>  &lt;div class="col-lg-offset-3 col-lg-6"&gt;<br/>    &lt;div class="input-group"&gt;<br/>      &lt;span class="input-group-btn"&gt;<br/>        &lt;button class="btn btn-secondary" type="button"&gt;Hate it&lt;/button&gt;<br/>      &lt;/span&gt;<br/>      &lt;input type="text" class="form-control" placeholder="Product name"&gt;<br/>      &lt;span class="input-group-btn"&gt;<br/>        &lt;button class="btn btn-secondary" type="button"&gt;Love it&lt;/button&gt;<br/>      &lt;/span&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;</pre>
<p>Let's convert the preceding snippet to Elm code, using the HTML to Elm page, available at: <a href="https://mbylstra.github.io/html-to-elm/">https://mbylstra.github.io/html-to-elm/</a>. After our HTML gets parsed, this is what we get:</p>
<pre class="elm hljs">div [ class "col-lg-offset-3 col-lg-6" ]<br/>    [ div [ class "input-group" ]<br/>        [ span [ class "input-group-btn" ]<br/>            [ button [ class "btn btn-secondary", type_ "button" ]<br/>                [ text "Hate it" ]<br/>            ]<br/>        , input [ class "form-control", placeholder "Product name", type_ "text" ]<br/>            []<br/>        , span [ class "input-group-btn" ]<br/>            [ button [ class "btn btn-secondary", type_ "button" ]<br/>                [ text "Love it" ]<br/>            ]<br/>        ]<br/>    ]</pre>
<p>Now, we need to map our existing Elm code to the preceding Elm code. To make it easier to work with, we will also assign it to a variable. After we've done that, our <kbd>view</kbd> function will look like this:</p>
<pre class="elm hljs">view model =<br/> div []<br/> [ div [ class "col-lg-offset-3 col-lg-6 mt5 pt5" ]<br/> [ h1 []<br/>        [ text "Unit Converter App" ]<br/> , div [ class "input-group" ]<br/> [ span [ class "input-group-btn" ]<br/> [ button [ class "btn btn-secondary", type_ "button" ]<br/> [ text model.unit1 ]<br/> ]<br/> , input [ onInput Convert, class "form-control", placeholder "Type a number to convert", type_ "text" ] []<br/> , span [ class "input-group-btn" ]<br/> [ button [ onClick Swap, class "btn btn-primary", type_ "button" ] [ text "Switch" ]<br/> ]<br/> ]<br/> , div [ class "mt5 pt5" ] [ text model.unit2 ]<br/> , div [ id "unit2Value" ] [ text (toString model.convertedValue) ] <br/> ]<br/> ]</pre>
<p>The preceding code gives a slightly different HTML structure than what we had so far, but it is also more semantic and nicer looking for the end user. Let's look at the complete code for our app at this point:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (beginnerProgram, div, button, input, text, label, span, h1)<br/>import Html.Attributes exposing (for, id, value, class, placeholder, type_)<br/>import Html.Events exposing (onClick, onInput)<br/><br/><br/>type alias Model =<br/>    { unit1 : String<br/>    , unit2 : String<br/>    , ratio : Float<br/>    , convertedValue : Float<br/>    }<br/><br/><br/>initModel : Model<br/>initModel =<br/>    { unit1 = "Kilometers"<br/>    , unit2 = "Miles"<br/>    , ratio = 1.608<br/>    , convertedValue = 0.0<br/>    }<br/><br/><br/>main =<br/>    beginnerProgram { model = initModel, view = view, update = update }<br/><br/><br/>view model =<br/> div []<br/> [ div [ class "col-lg-offset-3 col-lg-6 mt5 pt5" ]<br/> [ h1 []<br/>        [ text "Unit Converter App" ]<br/> , div [ class "input-group" ]<br/> [ span [ class "input-group-btn" ]<br/> [ button [ class "btn btn-secondary", type_ "button" ]<br/> [ text model.unit1 ]<br/> ]<br/> , input [ onInput Convert, class "form-control", placeholder "Type a number to convert", type_ "text" ] []<br/> , span [ class "input-group-btn" ]<br/> [ button [ onClick Swap, class "btn btn-primary", type_ "button" ] [ text "Switch" ]<br/> ]<br/> ]<br/> , div [ class "mt5 pt5" ] [ text model.unit2 ]<br/> , div [ id "unit2Value" ] [ text (toString model.convertedValue) ] <br/> ]<br/> ]<br/><br/><br/>type Msg<br/>    = Swap<br/>    | Convert String<br/><br/><br/>update msg model =<br/>    case msg of<br/>        Swap -&gt;<br/>            { model | unit1 = model.unit2, unit2 = model.unit1, ratio = 1 / model.ratio }<br/><br/>        Convert newValue -&gt;<br/>            let<br/>                floatValue =<br/>                    Result.withDefault 0 (String.toFloat newValue)<br/>            in<br/>                { model | convertedValue = floatValue * model.ratio }</pre>
<p>At this point, our app should look like this:</p>
<div><img src="img/31e3afa6-b64e-4975-a7b0-f09d42ab9d06.png" style="width:36.08em;height:11.17em;"/></div>
<p>There are a few improvements that can be made to our app at this point. For example, the Switch button only switches the names of units between kilometers and miles, but when the Switch button is pressed, it does not update the values that are already present in the input field. Also, the page layout and styling, although better than what we had, could still use a bit more improvement.</p>
<p>In the next chapter, we will add these features and further improve the app so that it has multiple inputs for the conversion of multiple units. Now, we'll shift our focus to looking at ways to apply what we learned in this chapter and update our <em>FizzBuzz</em> app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Revisiting the FizzBuzz app</h1>
                
            
            
                
<p>Before we can start improving our <em>FizzBuzz</em> app, let's remind ourselves of where we left off in the previous chapter:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/>ourList = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]<br/><br/>fizzBuzzCheck fizz buzz fizzBuzz num =<br/>    if num % 15 == 0 then<br/>        toString fizzBuzz<br/>    else if num % 5 == 0 then<br/>        toString buzz<br/>    else<br/>        toString num<br/><br/>
main =<br/>    List.map (fizzBuzzCheck "fizz" "buzz" "fizz buzz") ourList<br/>    |&gt; String.concat<br/>    |&gt; text</pre>
<p>Let's convert the preceding app so that it works with the Elm architecture, and so it prints out either a number or a word based on user input. We'll begin with the bare-bones app we used before, which utilizes the <kbd>beginnerProgram</kbd> function:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>-- Model<br/>initModel =<br/>    {}<br/><br/>-- Update<br/>type Msg<br/>    = Nothing<br/><br/>update msg model =<br/>    model<br/><br/>-- View<br/>view model =<br/>    div [] [ text "Everything will go here" ]<br/><br/>-- Main<br/>main =<br/>    beginnerProgram<br/>        { model = initModel<br/>        , view = view<br/>        , update = update<br/>        }</pre>
<p>Next, let's populate our initial model:</p>
<pre>initModel =<br/>    { inputValue = ""<br/>    , outputValue = 0.0<br/>    }</pre>
<p>Now, let's add a type alias of <kbd>Model</kbd>, and update the type annotation of <kbd>initModel</kbd> accordingly:</p>
<pre>type alias Model =<br/>    { inputValue : String<br/>    , outputValue : Float<br/>    }<br/><br/>initModel : Model<br/>initModel =<br/>    { inputValue = ""<br/>    , outputValue = 0.0<br/>    }</pre>
<p>Next, let's give our <kbd>view</kbd> function some HTML:</p>
<pre>-- View<br/>view model =<br/>    div []<br/>        [ div [ class "col-lg-6" ]<br/>            [ div [ class "input-group" ]<br/>                [ input <br/>                    [ onInput DisplayInput, class "form-control", placeholder "Enter sth", type_ "text" ]<br/>                    []<br/>                , span [ class "input-group-btn" ]<br/>                    [ button [ class "btn btn-secondary", type_ "button" ]<br/>                        [ text "FizzBuzz It!" ]<br/>                    ]<br/>                ]<br/>            , div [ class "display-4" ] [ text (toString model.outputValue) ]<br/>            ]<br/>        ]</pre>
<p>If we compile the app now, we'll see an input and a button in our browser. What we want to do in this version of the <em>FizzBuzz</em> app is we want the user to type a number inside the input, and after they click the button, the app will print out either a number or one of the words, as per the rules of the game.</p>
<p>Now, we can start to make the app receive user input. Let's update the nested <kbd>input</kbd> function inside the <kbd>view</kbd> function by adding an <kbd>onInput</kbd> message:</p>
<pre>[ input [ onInput DisplayInput, class "form-control", placeholder "Enter a number", type_ "text" ]</pre>
<p>Now, we need to allow our <kbd>update</kbd> function to receive that message:</p>
<pre>update msg model =<br/>    case msg of<br/>        DisplayInput newValue-&gt;<br/>           { model | outputValue = Result.withDefault 0 (String.toFloat newValue) }</pre>
<p>Of course, we still need to make changes to the <kbd>Msg</kbd> union type:</p>
<pre>type Msg<br/>    = DisplayInput String</pre>
<p>If we ran our app now, we'd see an input, a button, and below it, the number zero. If we typed letters, nothing would change; however, if we typed numbers, they would get displayed in place of the zero.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Giving our FizzBuzz app some logic</h1>
                
            
            
                
<p>In this section, we'll give our <em>FizzBuzz</em> app some logic so that it displays results based on user input. Let's do that by adding logic to the <kbd>DisplayInput</kbd> patter of our update function's <kbd>case</kbd> expression:</p>
<pre>update msg model =<br/>    case msg of<br/>        DisplayInput newValue -&gt;<br/>            let<br/>              condition = <br/>                  if (Result.withDefault 1 (String.toInt newValue) % 15) == 0 then<br/>                      "fizzBuzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 5) == 0 then<br/>                      "buzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 3) == 0 then<br/>                      "fizz"<br/>                  else<br/>                      newValue<br/>            in<br/>              { model | outputValue = condition }</pre>
<p>What we have done in the preceding code can be explained in several points:</p>
<ul>
<li>We have given our <kbd>DisplayInput</kbd> pattern a scoped variable we called <kbd>condition</kbd></li>
<li>The <kbd>condition</kbd> variable will evaluate to one of the <kbd>if</kbd> expressions inside of it, based on the number that the user typed into the <kbd>input</kbd> field (which was stored in the <kbd>newValue</kbd> variable)</li>
<li>In the <kbd>in</kbd> part of the <kbd>let</kbd> expression, we simply return the same model plus the updated <kbd>outputValue</kbd>, based on the value that the condition variable equated to in the <kbd>let</kbd> part of the <kbd>let</kbd> expression</li>
</ul>
<p>We can now save and run our app and observe how it dynamically updates the text node of the <kbd>div</kbd> under the input field, based on user inputs.</p>
<p>We can observe the following behavior:</p>
<ul>
<li>Typing a number will result in a correct calculation of a number or a word from the <em>FizzBuzz</em> game</li>
<li>Typing anything else will return that exact same string in the <kbd>div</kbd> under the input</li>
</ul>
<p>This means that there is still more room for improvement for our app. We will improve it by simply adding another <kbd>if</kbd> expression to our condition variable, and resolving the rest to a message to the user telling them that they need to input a number, not other characters.</p>
<p>The update we need to make is easy enough:</p>
<pre>update msg model =<br/>    case msg of<br/>        DisplayInput newValue -&gt;<br/>            let<br/>              condition = <br/>                  if (Result.withDefault 1 (String.toInt newValue) % 15) == 0 then<br/>                      "fizzBuzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 5) == 0 then<br/>                      "buzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 3) == 0 then<br/>                      "fizz"<br/>                  else if (Result.withDefault 0 (String.toInt newValue)) /= 0 then<br/>                      newValue<br/>                  else<br/>                      "Type a number, please!"<br/>            in<br/>              { model | outputValue = condition }</pre>
<p>At this point, our <em>FizzBuzz</em> app is behaving a lot nicer. Let's see the full code of the app at this point:</p>
<pre>module Main exposing (..)<br/><br/>import Html exposing (..)<br/>import Html.Attributes exposing (..)<br/>import Html.Events exposing (..)<br/><br/>type alias Model =<br/>    { inputValue : String<br/>    , outputValue : String<br/>    }<br/><br/>initModel : Model<br/>initModel =<br/>    { inputValue = ""<br/>    , outputValue = ""<br/>    }<br/><br/>-- Update<br/>type Msg<br/>    = DisplayInput String<br/><br/>update msg model =<br/>    case msg of<br/>        DisplayInput newValue -&gt;<br/>            let<br/>              condition = <br/>                  if (Result.withDefault 1 (String.toInt newValue) % 15) == 0 then<br/>                      "fizzBuzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 5) == 0 then<br/>                      "buzz"<br/>                  else if (Result.withDefault 1 (String.toInt newValue) % 3) == 0 then<br/>                      "fizz"<br/>                  else if (Result.withDefault 0 (String.toInt newValue)) /= 0 then<br/>                      newValue<br/>                  else<br/>                      "Type a number, please!"<br/>            in<br/>              { model | outputValue = condition }<br/>-- View<br/>view model =<br/>    div []<br/>        [ div [ class "col-lg-6" ]<br/>            [ div [ class "pt-5 pb-5 display-4" ] [text "Fizz Buzz App, v4" ]<br/>            , div [ class "input-group" ]<br/>                [ input <br/>                    [ onInput DisplayInput, class "form-control", placeholder "Enter sth", type_ "text" ]<br/>                    []<br/>                , span [ class "input-group-btn" ]<br/>                    [ button [ class "btn btn-secondary", type_ "button" ]<br/>                        [ text "FizzBuzz It!" ]<br/>                    ]<br/>                ]<br/>            , div [ class "display-4" ] [ text (toString model.outputValue) ]<br/>            ]<br/>        ]<br/><br/>-- Main<br/>main =<br/>    beginnerProgram<br/>        { model = initModel<br/>        , view = view<br/>        , update = update<br/>        }</pre>
<p>This is the welcome screen of our improved <em>FizzBuzz</em> app:</p>
<div><img src="img/1e479343-888e-4467-9aa5-f5d9bc922d44.png" style="width:52.92em;height:14.08em;"/></div>
<p>Typing a number produces the desired result:</p>
<div><img src="img/6a2f6929-879a-46f1-b759-0fe069fb0966.png" style="width:28.83em;height:9.50em;"/></div>
<p>Typing anything else will produce a user-friendly error message:</p>
<div><img src="img/ca4b2331-2f12-4615-9ea0-9be167ccf830.png" style="width:26.92em;height:9.67em;"/></div>
<p>There are still many things that we can improve, as we'll see in <a href="d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml">Chapter 5</a>, <em>Completing the Unit Conversion Website in Elm</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In <a href="5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml">Chapter 4</a>, <em>Preparing a Unit Conversion Website in Elm</em>, we learned a number of important concepts, such as:</p>
<ul>
<li>Working with the <kbd>Msg</kbd> union type</li>
<li>Setting up our model's data with <kbd>Records</kbd></li>
<li>Using type annotations and type aliases</li>
<li>Updating only a section of our model using pipe characters in our expressions</li>
<li>Working with the <kbd>Result</kbd> union type to handle potential errors in our apps</li>
<li>Working with <kbd>let</kbd> expressions</li>
</ul>
<p>In the next chapter, we will improve our unit conversion website by adding multiple inputs for converting various units.</p>


            

            
        
    </body></html>