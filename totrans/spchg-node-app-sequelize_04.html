<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor111"/>4</h1>
<h1 id="_idParaDest-104"><a id="_idTextAnchor112"/>Associating Models</h1>
<p>Other than using validations to ensure consistency within our database, we can also create associations between two tables to ensure symbiotic relationships are maintained and updated. Databases maintain these relationships by creating <strong class="bold">foreign key references</strong> that hold metadata as to which table and column the foreign key is associated with. This metadata is what maintains integrity for the database. If we were to update a foreign key’s value without a proper reference, we would have to perform a separate query to update all of the rows that contained a reference to the foreign key to its new value.</p>
<p>For instance, we have three tables: <strong class="source-inline">customers</strong>, <strong class="source-inline">products</strong>, and <strong class="source-inline">receipts</strong>. The <strong class="source-inline">receipts</strong> table would have two columns (in addition to others) with each referencing a column on the <strong class="source-inline">customers</strong> and <strong class="source-inline">products</strong> table, respectively. If we wanted to update a product’s identification column, we would have to just modify the applicable product’s identification value. Then, the rows referencing the product within <strong class="source-inline">receipts</strong> would update automatically. Without a foreign reference, we would have to explicitly update the <strong class="source-inline">receipts</strong> table after updating the product’s identification.</p>
<p class="callout-heading">Note</p>
<p class="callout">Traditionally, foreign keys would reference a primary key column or some form of identification column, but you are not limited to just those columns. </p>
<p>Relations between models can be managed by Sequelize automatically, or in a configurable way, for adopting pre-existing databases. Mapping relations between models can help ORMs form efficient queries depending on the environment by <strong class="bold">eager loading</strong> or <strong class="bold">lazy loading</strong>. </p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Association methods</li>
<li>Relationship patterns</li>
<li>Querying associations with eager loading and lazy loading</li>
<li>Using advanced association options</li>
<li>Applying associations to Avalon Airlines</li>
</ul>
<h1 id="_idParaDest-105"><a id="_idTextAnchor113"/>Technical requirements</h1>
<p>You can find the code files for this chapter at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch4</a></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor114"/>Association methods</h1>
<p>There are a few options for creating relational mappings with ORMs. Defining the relations through an ORM can help build your database with the proper attributes and columns automatically, manage associated validations (for example, checking to see whether there is strictly only <a id="_idIndexMarker425"/>one related record), and perform optimization patterns on queries when fetching or inserting data. Sequelize offers support for four association patterns:</p>
<ul>
<li><strong class="bold">HasOne</strong> – A one-to-one<a id="_idIndexMarker426"/> association where the <em class="italic">foreign key references the child</em> model. The attribute<a id="_idIndexMarker427"/> is defined on the parent model.</li>
<li><strong class="bold">BelongsTo</strong> – A one-to-one<a id="_idIndexMarker428"/> association where the <em class="italic">foreign key references the parent</em> model. The<a id="_idIndexMarker429"/> attribute is defined on the child model.</li>
<li><strong class="bold">HasMany</strong> – A one-to-many <a id="_idIndexMarker430"/>association where the <em class="italic">foreign key references the parent</em> model. The attribute<a id="_idIndexMarker431"/> is defined on the child model. </li>
<li><strong class="bold">BelongsToMany</strong> – A many-to-many <a id="_idIndexMarker432"/>association where<a id="_idIndexMarker433"/> a separate model (called a <em class="italic">junction table</em>) will store<a id="_idIndexMarker434"/> the references of the associated models.</li>
</ul>
<p>Sequelize will follow a pattern for creating methods on models with associations. Depending on the relationship, there can be <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, <strong class="source-inline">add</strong>, <strong class="source-inline">create</strong>, <strong class="source-inline">remove</strong>, and <strong class="source-inline">count</strong> as the prefix for the method’s name following with the association’s name (singular or pluralized wherever applicable).</p>
<p>In this section, we will go over the list of associations with their corresponding methods. Once we have gone through the association overview, then we can begin with the patterns for the relationships overview. Throughout this section, we will be using the concept of actors and plays/movies/jobs to help us grasp the fundamentals of associative properties and behavior on models. These examples are for illustrative purposes only and should not be included within our project’s code base.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can add a <strong class="source-inline">where</strong> clause statement (along with other finder parameters) within the <strong class="source-inline">get</strong> association methods, such as the following:</p>
<p class="callout"><strong class="source-inline">Actor.getJobs({</strong></p>
<p class="callout"><strong class="source-inline">     where: { category: 'Action' },</strong></p>
<p class="callout"><strong class="source-inline">     limit: 10, offset: 20, /* etc. */</strong></p>
<p class="callout"><strong class="source-inline">});</strong></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor115"/>hasOne</h2>
<p>The <strong class="source-inline">hasOne</strong> association <a id="_idIndexMarker435"/>will generate <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, and <strong class="source-inline">create</strong> methods for the<a id="_idIndexMarker436"/> associating model. Suppose we had the following association and instance:</p>
<pre class="source-code">
Actor.hasOne(Job);
const actor = await Actor.create({ … });</pre>
<p>We can use the <strong class="source-inline">createJob</strong> method to insert and set the job with the actor:</p>
<pre class="source-code">
await actor.createJob({ name: '…' });</pre>
<p>The <strong class="source-inline">setJob</strong> method will update the association of the actor and the job from a <strong class="source-inline">Job</strong> instance:</p>
<pre class="source-code">
const job = await Job.create({ name: '…' });
await actor.setJob(job);</pre>
<p>You may use the <strong class="source-inline">set</strong> prefix<a id="_idIndexMarker437"/> method to remove an association as well with a <strong class="source-inline">null</strong> value:</p>
<pre class="source-code">
await actor.setJob(null);</pre>
<h2 id="_idParaDest-108"><a id="_idTextAnchor116"/>belongsTo</h2>
<p>Let’s change our previous <a id="_idIndexMarker438"/>example’s model to this:</p>
<pre class="source-code">
Actor.belongsTo(Job);</pre>
<p>The <strong class="source-inline">belongsTo</strong> association will generate the exact same methods on the same model as the <strong class="source-inline">hasOne</strong> association. For further explanation, this association will not create <strong class="source-inline">setActor</strong> on the <strong class="source-inline">Job</strong> model but will create the <strong class="source-inline">setJob</strong> method on the <strong class="source-inline">Actor</strong> model still.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor117"/>hasMany</h2>
<p>The <strong class="source-inline">hasMany</strong> association will<a id="_idIndexMarker439"/> generate the following prefixed methods: <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, <strong class="source-inline">create</strong>, <strong class="source-inline">count</strong>, <strong class="source-inline">has</strong>, <strong class="source-inline">add</strong>, and <strong class="source-inline">remove</strong>. The <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> methods are similar to the previous example except that the suffix of the method’s name will be a pluralized version of the model’s name:</p>
<pre class="source-code">
Actor.hasMany(Job);
let jobs = await Job.findAll();
await Actor.setJobs(jobs);
await Actor.getJobs();</pre>
<p>The <strong class="source-inline">create</strong> prefix method will still only create one record at a time and therefore the model’s name is still singular-cased:</p>
<pre class="source-code">
await Actor.createJob({ name: '…' });</pre>
<p>We can also check to see whether a relationship already exists with the <strong class="source-inline">has</strong> method:</p>
<pre class="source-code">
const job = await Job.findOne();
// true or false boolean value
const hasJob = await Actor.hasJob(job);
// using jobs from our previous example
const hasAllJobs = await Actor.hasJobs(jobs);</pre>
<p>We can add one or multiple associations using the <strong class="source-inline">add</strong> method like so:</p>
<pre class="source-code">
await Actor.addJob(job);
await Actor.addJobs(jobs);</pre>
<p>To retrieve how many<a id="_idIndexMarker440"/> associations we have for a model, we can invoke the <strong class="source-inline">count</strong> method:</p>
<pre class="source-code">
// will return 2 following the examples in this section
await Actor.countJobs();</pre>
<p>Removing the associations can be done with the <strong class="source-inline">remove</strong> methods:</p>
<pre class="source-code">
await Actor.removeJob(job);
await Actor.removeJobs(jobs);</pre>
<h2 id="_idParaDest-110"><a id="_idTextAnchor118"/>belongsToMany</h2>
<p>Next, we change the <a id="_idIndexMarker441"/>association to <strong class="source-inline">belongsToMany</strong>:</p>
<pre class="source-code">
Actor.belongsToMany(Job, { through: '...' });</pre>
<p>The <strong class="source-inline">belongsToMany</strong> association will generate the same methods on the same model as the previous <strong class="source-inline">hasMany</strong> example, similar to how <strong class="source-inline">belongsTo</strong> generated the same methods as the <strong class="source-inline">hasOne</strong> association.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor119"/>Renaming associations</h2>
<p>You can modify how Sequelize<a id="_idIndexMarker442"/> will generate the method names by creating an alias to the association using the <strong class="source-inline">as</strong> parameter:</p>
<pre class="source-code">
Actor.hasOne(Job, {
  as: 'gig'
});
const actor = await Actor.create({ … });
const gig = await Job.create({ … });
actor.createGig({ … });
actor.setGig(gig);
actor.hasGig(gig);</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can manually set the identifier of a relationship directly to the attribute and Sequelize will update the value with the <strong class="source-inline">save</strong> method. However, if you have made any changes within the associated records, their information will not be updated by calling the associating instance’s <strong class="source-inline">save</strong> method. Changes to the actual associations would need to be done from their own instance.</p>
<p>Now that we know <a id="_idIndexMarker443"/>how to apply association methods to our models, we can go over the various relationship patterns to help us get a better understanding of where, and when, these associations are coupled. In the next section, we will go into detail on the relationship patterns that Sequelize supports along with examples for each pattern.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor120"/>Relationship patterns</h1>
<p>In this section, we will go over the<a id="_idIndexMarker444"/> details of each type of relation (except Super-Many-To-Many, which is discussed in a later section), and how to use Sequelize to define the associations. After that, we will update the Avalon Airlines project’s models with associations.</p>
<p>We can combine several association patterns to define a relationship pattern. Sequelize supports four relationship patterns:</p>
<ul>
<li><strong class="bold">One-to-One</strong> – We would use<a id="_idIndexMarker445"/> the <em class="italic">hasOne</em> and <em class="italic">belongsTo</em> associations together.</li>
<li><strong class="bold">One-to-Many</strong> – The <em class="italic">hasMany</em> and <em class="italic">belongsTo</em> associations<a id="_idIndexMarker446"/> are used for this pattern.</li>
<li><strong class="bold">Many-to-Many</strong> – Two <em class="italic">belongsToMany</em> associations are used for this pattern.</li>
<li><strong class="bold">Super-Many-to-Many</strong> – Two <em class="italic">One-to-Many</em> relations where the <em class="italic">One</em> models are still considered symbiotic. This relationship will be explained in further detail in the <em class="italic">Creating Super Many-to-Many relationships</em> section.</li>
</ul>
<h2 id="_idParaDest-113"><a id="_idTextAnchor121"/>One-to-One</h2>
<p>The One-to-One relational <a id="_idIndexMarker447"/>pattern involves the <strong class="source-inline">hasOne</strong> and <strong class="source-inline">belongsTo</strong> associations for<a id="_idIndexMarker448"/> the models. The difference between the two associations is which table will have the identification column.</p>
<p>As an example, we have an <strong class="source-inline">Airplane</strong> and <strong class="source-inline">BoardingTicket</strong> model. Since the <strong class="source-inline">Airplane</strong> model would no longer be involved with <strong class="source-inline">BoardingTicket</strong>, after the flight has been completed, we can omit the memorization of the boarding ticket from the <strong class="source-inline">Airplane</strong> model’s table. This means that <strong class="source-inline">Airplane</strong> would not need a <strong class="source-inline">hasOne</strong> association, but <strong class="source-inline">BoardingTicket</strong> will still need a <strong class="source-inline">belongsTo</strong> association.</p>
<p>To define a One-to-One relationship, we would define our models like so:</p>
<pre class="source-code">
const A = sequelize.define('A', { … });
const B = sequelize.define('B', { … });
A.hasOne(B);
B.belongsTo(A);</pre>
<p>Using Sequelize’s <strong class="source-inline">sync</strong> command would yield the following queries:</p>
<pre class="source-code">
CREATE TABLE IF NOT EXISTS "b" (
  /* ... */
);
CREATE TABLE IF NOT EXISTS "b" (
  /* ... */
  "aId" INTEGER REFERENCES "a" ("id") ON DELETE SET NULL ON UPDATE CASCADE
  /* ... */
);</pre>
<p class="callout-heading">Note</p>
<p class="callout">Without calling <strong class="source-inline">A.hasOne(B)</strong>, Sequelize would not know how to eager load from model A to B (but would be able to eager load from model B to A).</p>
<p>There are several <a id="_idIndexMarker449"/>options that you can pass as a second parameter for tuning the behavior of the associations:</p>
<ul>
<li><strong class="source-inline">onUpdate</strong> – Tells the DBMS how to handle updated foreign relationships. Possible values are <strong class="source-inline">CASCADE</strong>, <strong class="source-inline">RESTRICT</strong>, <strong class="source-inline">NO ACTION</strong>, <strong class="source-inline">SET DEFAULT</strong>, and <strong class="source-inline">SET NULL</strong>. The default value for this option is <strong class="source-inline">CASCADE</strong>.</li>
<li><strong class="source-inline">onDelete</strong> – Same as <strong class="source-inline">onUpdate</strong> but for handling deleted foreign relationships. The default for this option is <strong class="source-inline">SET NULL</strong>.</li>
<li><strong class="source-inline">foreignKey</strong> – Accepts a literal string value or an object with the same options as an attribute when defining models (<strong class="source-inline">name</strong>, <strong class="source-inline">allowNull</strong>, <strong class="source-inline">unique</strong>, etc.). </li>
<li><strong class="source-inline">sourceKey</strong> – The name of the column, from the source table, to use as identification for the foreign key column’s value. By default, Sequelize will use the source table’s attribute that has a <strong class="source-inline">primaryKey: true</strong> parameter. If your model contains no explicit <strong class="source-inline">primaryKey</strong> attribute, then Sequelize will use the default <strong class="source-inline">id</strong> attribute. Applicable to <strong class="source-inline">hasOne</strong> and <strong class="source-inline">hasMany</strong> associations.</li>
<li><strong class="source-inline">targetKey</strong> – Similar to <strong class="source-inline">sourceKey</strong> except this value will reference the column from the target table as opposed to the source table. Applicable to <strong class="source-inline">belongsTo</strong> associations.</li>
</ul>
<p>Here are a few examples of how to use these options:</p>
<pre class="source-code">
A.hasOne(B, {
    onUpdate: 'SET NULL',
    onDelete: 'CASCADE',
    foreignKey: 'otherId'
});
B.belongsTo(A);
A.hasOne(B, {
    onUpdate: 'CASCADE',
    onDelete: 'SET NULL',
    foreignKey: { name: 'otherId' }
});
B.belongsTo(A);</pre>
<p>You can use the second<a id="_idIndexMarker450"/> options interchangeably between models A and B:</p>
<pre class="source-code">
A.hasOne(B);
B.belongsTo(A, {
    onUpdate: 'SET NULL',
    onDelete: 'CASCADE',
    foreignKey: 'otherId'
});
A.hasOne(B);
B.belongsTo(A, {
    onUpdate: 'CASCADE',
    onDelete: 'SET NULL',
    foreignKey: { name: 'otherId' }
});</pre>
<p>By default, Sequelize will make One-to-One relations optional, but if we wanted to require a relationship between<a id="_idIndexMarker451"/> the two models, then we would define <strong class="source-inline">allowNull</strong> as <strong class="source-inline">false</strong> in the association options like so:</p>
<pre class="source-code">
A.hasOne(B, {
  foreignKey: { allowNull: false }
});</pre>
<h2 id="_idParaDest-114"><a id="_idTextAnchor122"/>One-to-Many</h2>
<p>This relational pattern <a id="_idIndexMarker452"/>will only create a foreign reference column <a id="_idIndexMarker453"/>on the <strong class="source-inline">belongsTo</strong> model. Defining an attribute with the <strong class="source-inline">hasMany</strong> association helps Sequelize with data retrieval optimization and adding helper functions to the parent model. The options in the second parameter are the same as a One-to-One relationship.</p>
<p>Suppose we had <strong class="source-inline">Employees</strong> that belonged to <strong class="source-inline">Organization</strong>. With Sequelize, the code would be similar to the following:</p>
<pre class="source-code">
Organization.hasMany(Employee);
Employee.belongsTo(Organization);</pre>
<p>This would execute these couple of queries:</p>
<pre class="source-code">
CREATE TABLE IF NOT EXISTS "Organizations" (
  /* ... */
);
CREATE TABLE IF NOT EXISTS "Employees" (
  /* ... */
  "OrganizationId" INTEGER REFERENCES "Organizations" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
  /* ... */
);</pre>
<h2 id="_idParaDest-115"><a id="_idTextAnchor123"/>Many-to-Many</h2>
<p>This relationship will use an<a id="_idIndexMarker454"/> associative entity to keep references between<a id="_idIndexMarker455"/> two models. Some other names for an associative entity are junction table, junction model, cross-reference table, and pairing table. With <strong class="source-inline">sequelize.sync()</strong>, Sequelize will automatically create a junction model for you, but we still have the option of defining our own junction table for situations where we want to add more attributes, constraints, life cycle events, and so on.</p>
<p>In this example, we have employees that have tasks assigned to them. Employees can work on multiple tasks and tasks can require many employees:</p>
<pre class="source-code">
Employee.belongsToMany(Task, { through: 'EmployeeTasks' });
Task.belongsToMany(Employee, { through: 'EmployeeTasks' });</pre>
<p>This will execute the following query:</p>
<pre class="source-code">
CREATE TABLE IF NOT EXISTS "EmployeeTasks" (
    "createdAt" TIMESTAMP WITH TIME ZONE NOT NULL,
    "updatedAt" TIMESTAMP WITH TIME ZONE NOT NULL,
    "EmployeeId" INTEGER REFERENCES "Employees" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    "TaskId" INTEGER REFERENCES "Tasks" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    PRIMARY KEY ("EmployeeId","TaskId")
);</pre>
<p class="callout-heading">Note</p>
<p class="callout">Many-to-Many relationships will use <strong class="source-inline">CASCADE</strong> as the default behavior for managing foreign keys and relationships on both updates and deletions.</p>
<p>If we wanted to be more explicit in our definitions or wanted to add a custom attribute to the junction model, we <a id="_idIndexMarker456"/>can define the junction model and relations like so:</p>
<pre class="source-code">
// Employee and Task are pre-defined for brevity
const EmployeeTasks = sequelize.define('EmployeeTasks', {
    EmployeeId: {
      type: DataTypes.INTEGER,
      references: {
        model: Employee,
        key: 'id'
      }
    },
    TaskId: {
      type: DataTypes.INTEGER,
      references: {
        model: 'Tasks', // string literal values work here 
                           too
        key: 'id'
      }
    },
    SomeOtherColumn: {
        type: DataTypes.STRING
    }
});
Employee.belongsToMany(Task, {
    through: EmployeeTasks
});
Task.belongsToMany(Employee, {
    through: EmployeeTasks
});</pre>
<p>Other than the <strong class="source-inline">through</strong> parameter, Many-to-Many offers a parameter called <strong class="source-inline">uniqueKey</strong>, which will allow you to name a<a id="_idIndexMarker457"/> reference column. By default, Sequelize will create the junction table with a unique key composed of both<a id="_idIndexMarker458"/> referencing columns (<strong class="source-inline">employeeId</strong> and <strong class="source-inline">taskId</strong>). If you wish to change this behavior, you may set the <strong class="source-inline">unique</strong> attribute parameter to <strong class="source-inline">false</strong> in the junction model’s definition. </p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor124"/>Using custom foreign key definitions</h2>
<p>When, and how, to use <strong class="source-inline">sourceKey</strong> and <strong class="source-inline">targetKey</strong> properly can be confusing at first. The <strong class="source-inline">hasOne</strong> and <strong class="source-inline">hasMany</strong> associations <a id="_idIndexMarker459"/>will reference themselves from the Parent model (target model) to the Child model (source<a id="_idIndexMarker460"/> model); another way of saying this is, “This child is mine through name, marriage, and so on.” The <strong class="source-inline">belongsTo</strong> association will reference the Parent model, or “I belong to this parent through name, marriage, and so on.”</p>
<p>We reference these models as <em class="italic">source</em> and <em class="italic">target</em> models since parent and child could be misleading and would imply some form of hierarchy. Associations do not require a hierarchy; they just form relationships.</p>
<p class="callout-heading">Note</p>
<p class="callout">Attributes that are defined as references are required to have a unique constraint applied to them. This can be done by adding <strong class="source-inline">unique: true</strong> to the attribute’s options and using Sequelize’s <strong class="source-inline">sync()</strong> method. </p>
<p>For an example of how to configure the source and target keys, we will first define our models:</p>
<pre class="source-code">
const Actor = sequelize.define('Actors', {
    name: {
        type: DataTypes.TEXT,
        unique: true
    }
});
const Role = sequelize.define('Roles', {
    title: {
        type: DataTypes.TEXT,
        unique: true
    }
});
const Costume = sequelize.define('Costumes', {
    wardrobe: {
        type: DataTypes.TEXT,
        unique: true
    }
});</pre>
<p>Using these roles, we<a id="_idIndexMarker461"/> will go through examples of using <strong class="source-inline">hasOne</strong>, <strong class="source-inline">hasMany</strong>, <strong class="source-inline">belongsTo</strong>, and <strong class="source-inline">belongsToMany</strong> separately. </p>
<h3>Using hasOne</h3>
<p>The following code will create an attribute called <strong class="source-inline">actorName</strong> on the <strong class="source-inline">Roles</strong> model, and the value for that attribute <a id="_idIndexMarker462"/>will be associated with<a id="_idIndexMarker463"/> the actor’s name (instead of the actor’s ID attribute):</p>
<pre class="source-code">
Actor.hasOne(Role, {
    sourceKey: 'name',
    foreignKey: 'actorName'
});</pre>
<h3>Using hasMany</h3>
<p>We would use the same <a id="_idIndexMarker464"/>options for the <strong class="source-inline">hasMany</strong> association. The following<a id="_idIndexMarker465"/> code will create an attribute called <strong class="source-inline">roleTitle</strong> on the <strong class="source-inline">Costumes</strong> model, which will be associated with the role’s title:</p>
<pre class="source-code">
Roles.hasMany(Costumes, {
    sourceKey: 'title',
    foreignKey: 'roleTitle'
});</pre>
<h3>Using belongsTo</h3>
<p>The <strong class="source-inline">belongsTo</strong> association<a id="_idIndexMarker466"/> works a bit differently. Instead of referencing<a id="_idIndexMarker467"/> from the source model, <strong class="source-inline">belongsTo</strong> will reference from the target model like so (this would yield the same results as the previous <strong class="source-inline">Actors.hasOne(Roles, ...)</strong> code):</p>
<pre class="source-code">
Roles.belongsTo(Actors, {
    targetKey: 'name',
    foreignKey: 'actorName'
});</pre>
<p>In other words, the foreign keys will be placed on the model that is creating the association when using <strong class="source-inline">belongsTo</strong>, and for the <strong class="source-inline">hasOne</strong>/<strong class="source-inline">hasMany</strong> associations, the foreign keys are placed on the other model that is not<a id="_idIndexMarker468"/> invoking the association method.</p>
<h3>Using belongsToMany</h3>
<p>The <strong class="source-inline">belongsToMany</strong> association accepts both the target and the source keys as parameters to configure the<a id="_idIndexMarker469"/> references. On the movie set, an<a id="_idIndexMarker470"/> actor could have multiple costumes for all of their different scenes. We can illustrate this relationship in Sequelize like so:</p>
<pre class="source-code">
Costumes.belongsToMany(Actors, {
    through: 'actor_costumes',
    sourceKey: 'name',
    targetKey: 'wardrobe'
});</pre>
<p>This will create a junction table called <strong class="source-inline">actor_costumes</strong> with two reference columns being <strong class="source-inline">actorsName</strong> and <strong class="source-inline">costumesWardrobe</strong>, referencing the Actor and Costume model, respectively.</p>
<p>Now that we have gone over definitions, options, use cases, and examples for Sequelize’s association patterns, and the main three relational patterns, we can start practicing including those relations for when we select or modify records.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor125"/>Querying associations with eager loading and lazy loading</h1>
<p>Sequelize offers two different methods<a id="_idIndexMarker471"/> of querying associations depending on how you wish to query the data: eager loading and lazy loading. With eager<a id="_idIndexMarker472"/> loading, you would load all of the associated data at once. The lazy loading method will load the associations per query as they are called upon from the code. It is easier to explain eager loading than lazy loading but to see the benefits of eager loading, we will need to go over lazy loading first. </p>
<p class="callout-heading">Note</p>
<p class="callout">You may have heard of the “N+1 select problem” with other ORM frameworks; this is referring to the lazy loading method (although, not mutually exclusive) and how selecting an association per row could be hazardous to your application’s performance.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor126"/>Lazy loading</h2>
<p>Sequelize tries to make no<a id="_idIndexMarker473"/> presumptions about your intent and will initially select only the model’s data. We will need to explicitly call the associations if we want to <a id="_idIndexMarker474"/>transverse through the model’s related data. A good use case for lazy loading would be querying related data conditionally (for example, we may not want to fetch movie reviews until after the movie is released). Lazy loading would look similar to this:</p>
<pre class="source-code">
const actor = await Actor.findOne();
// SELECT * FROM jobs WHERE actorId=?
const job = await Actor.getJob();
let reviews = [];
if (job.isDone) {
  // SELECT * FROM reviews WHERE jobId=?
  reviews = await job.getReviews({
    where: { published: true }
  });
}</pre>
<h2 id="_idParaDest-119"><a id="_idTextAnchor127"/>Eager loading</h2>
<p>Usually, you would use <a id="_idIndexMarker475"/>this form of loading when you have <a id="_idIndexMarker476"/>a lot of associations or a lot of rows returned from the main table. Referencing the previous example, let’s say we replaced <strong class="source-inline">getJob</strong> with <strong class="source-inline">getJobs</strong> and called <strong class="source-inline">getReviews</strong> per job, like so:</p>
<pre class="source-code">
const jobs = await Actor.getJobs();
let reviews = [];
jobs.map(async job =&gt; {
  if (job.isDone) {
    let jobReviews = await job.getReviews({
      where: { published: true }
    });
    reviews = reviews.concat(jobReviews);
  }
});</pre>
<p>If the actor ever became too famous and had hundreds of jobs, we could see how quickly the number of queries<a id="_idIndexMarker477"/> could become too cumbersome for the system. One way to prevent this is by using the eager loading method, which will include<a id="_idIndexMarker478"/> the associated data at the top-level query using <strong class="source-inline">JOIN</strong> statements. Let us convert the previous example into an eager-loaded query with Sequelize by beginning to define our completed jobs association:</p>
<pre class="source-code">
const completedJobs = {
    model: Job,
    as: 'CompletedJobs',
    where: {
        completed: true
    },
    include: {
        model: Review,
        where: {
            published: true
        }
    }
}</pre>
<p>This first <strong class="source-inline">include</strong> parameter will load the <strong class="source-inline">Job</strong> model, set an alias to <strong class="source-inline">CompletedJobs</strong>, add a <strong class="source-inline">where</strong> clause for the <strong class="source-inline">completed</strong> flag, and then call a nested association from <strong class="source-inline">Job</strong> to <strong class="source-inline">Review</strong> (along with a <strong class="source-inline">published</strong> <strong class="source-inline">where</strong> clause for the review).</p>
<p>Next, we need to define our incomplete jobs association:</p>
<pre class="source-code">
const incompleteJobs = {
    model: Job,
    as: 'IncompleteJobs',
    where: {
        completed: false
    }
}</pre>
<p>The second parameter is a<a id="_idIndexMarker479"/> simpler alias association for <strong class="source-inline">Job</strong> with <a id="_idIndexMarker480"/>an inverted <strong class="source-inline">where</strong> clause from <strong class="source-inline">CompletedJobs</strong>.</p>
<p>The idea here is to query the completed and incomplete jobs separately since we only want to include reviews from jobs that are done. Now, we can query our actor with the jobs and reviews:</p>
<pre class="source-code">
const actor = await Actor.findOne({
    include: [ completedJobs, incompleteJobs ]
});</pre>
<p>This will generate an SQL query similar to this (some selected columns have been omitted for brevity):</p>
<pre class="source-code">
SELECT
    `Actor`.*,
    `CompletedJobs`.`title` AS `CompletedJobs.title`,
    `CompletedJobs`.`completed` AS `CompletedJobs.completed`,
    `CompletedJobs-&gt;Reviews`.`id` AS `CompletedJobs.Reviews.     id`,
    `CompletedJobs-&gt;Reviews`.`published` AS `CompletedJobs.
     Reviews.published`,
    
    `IncompleteJobs`.`title` AS `IncompleteJobs.title`,
    `IncompleteJobs`.`completed` AS `IncompleteJobs.completed`
    
FROM (
    SELECT `Actor`.`id`, `Actor`.`name`, `Actor`.`createdAt`, 
    `Actor`.`updatedAt`
    FROM `Actors` AS `Actor`
    LIMIT 1
) AS `Actor`
LEFT OUTER JOIN `Jobs` AS `CompletedJobs` ON
    `Actor`.`id` = `CompletedJobs`.`ActorId` AND
    `CompletedJobs`.`completed` = true
LEFT OUTER JOIN `Reviews` AS `CompletedJobs-&gt;Reviews` ON
    `CompletedJobs`.`id` = `CompletedJobs-&gt;Reviews`.`JobId` AND
    `CompletedJobs-&gt;Reviews`.`published` = true
LEFT OUTER JOIN `Jobs` AS `IncompleteJobs` ON
    `Actor`.`id` = `IncompleteJobs`.`ActorId` AND
    `IncompleteJobs`.`completed` = false;</pre>
<p>Then, concatenate the<a id="_idIndexMarker481"/> completed and incomplete jobs:</p>
<pre class="source-code">
const jobs = [].concat(
  actor.CompletedJobs,
  actor.IncompleteJobs
);</pre>
<p>Now we can<a id="_idIndexMarker482"/> iterate through jobs and display the reviews if applicable:</p>
<pre class="source-code">
jobs.forEach(job =&gt; {
  const reviews = job.Reviews || [];
  // display reviews here
});</pre>
<p>Now that we have the fundamentals of the two load types for Sequelize, we can now start venturing into more advanced concepts when associating data. In the next section, we will go over more advanced query patterns for associations: Super Many-to-Many associations and polymorphic associations.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor128"/>Using advanced association options</h1>
<p>Sequelize offers a variety of tricks to help communicate with your database’s relations properly. Some of these <a id="_idIndexMarker483"/>methods will help query associations in a more organized and ergonomic way. Other methods will offer us a way to compose the database’s schematics for more advanced relationship patterns. In this section, we will be going over examples of how to manage complex many-to-many relationships using the Super Many-to-Many pattern, define scoped associations, and query polymorphic associations.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor129"/>Using scopes with associations</h2>
<p>Scopes are a way to <a id="_idIndexMarker484"/>define a namespace with a default set of parameters, or parameters that override previously applied scopes to a query. Associations may have defined scopes to help with organization of the code base. A key difference between scopes for associations and models is that the association scope’s parameters are applicable for the <strong class="source-inline">WHERE</strong> clause. Model scopes can define the <strong class="source-inline">WHERE</strong>, <strong class="source-inline">LIMIT</strong>, and <strong class="source-inline">OFFSET</strong> clauses, for example.</p>
<p>The following is an example of querying associations with scopes:</p>
<pre class="source-code">
const Worker = sequelize.define('worker', { name: DataTypes.STRING });
const Task = sequelize.define('task', {
  title: DataTypes.STRING,
  completed: DataTypes.BOOLEAN
});
Worker.hasMany(Task, {
    scope: {
        completed: true
    },
    as: 'completedTasks'
});
const worker = await Worker.create({ name: "Bob" });
await worker.getCompletedTasks();</pre>
<p>Sequelize will <a id="_idIndexMarker485"/>add a mixin for the <strong class="source-inline">worker</strong> instance called <strong class="source-inline">getCompletedTasks()</strong>, which would invoke a query similar to this:</p>
<pre class="source-code">
SELECT `id`, `completed`, `workerId`
FROM `tasks` AS `task`
WHERE `task`.`completed` = true AND `task`.`workerId` = 1;</pre>
<p>The <strong class="source-inline">`task`.`completed` = true</strong> part was automatically added from Sequelize from the scope’s definition. An alternative way of defining the same scope is shown here:</p>
<pre class="source-code">
Task.addScope('completed', {
    where: { completed: true }
});
Worker.hasMany(Task.scope('completed'), {
  as: 'completedTasks'
});</pre>
<p>When creating scoped associations, Sequelize will automatically add default values for those parameters when calling the <strong class="source-inline">create</strong> or <strong class="source-inline">add</strong> mixins. As an example, we know a worker has already <a id="_idIndexMarker486"/>completed a task and wanted to insert the association like so:</p>
<pre class="source-code">
const worker = Worker.findOne();
await worker.createCompletedTask({ title: 'Repair Cluster' });</pre>
<p>Sequelize will execute a similar query when creating a completed task via <strong class="source-inline">worker</strong>:</p>
<pre class="source-code">
INSERT INTO "tasks" (
    "id", "title", "completed"
) VALUES (
    DEFAULT, 'Repair Cluster', true, 1
) RETURNING *;</pre>
<p>The <strong class="source-inline">completed</strong> attribute has been automatically set to <strong class="source-inline">true</strong> for when we want to add a completed task. The same behavior would be exhibited if we were to use the <strong class="source-inline">add</strong> mixin.</p>
<p>Using the scope parameter on a <strong class="source-inline">belongsToMany</strong> association would apply the scope to the target model instead of the junction mode. If you wish to apply a scope on the junction model instead, you would add the scope parameter inside of the <strong class="source-inline">through</strong> configuration like so:</p>
<pre class="source-code">
const WorkerTask = sequelize.define('WorkerTask', {
  published: DataTypes.BOOLEAN
});
Worker.belongsToMany(Task.scope('completed'), {
  through: {
    model: WorkerTasks,
    scope: { published: true }
  },
  as: 'CompletedAndPublishedTask'
});</pre>
<h2 id="_idParaDest-122"><a id="_idTextAnchor130"/>Creating Super Many-to-Many relationships</h2>
<p>Suppose we<a id="_idIndexMarker487"/> owned a store and wanted to maintain lists of associations between employees and customers through transactions. Typically, we can define this sort of relationship by adding a <strong class="source-inline">belongsToMany</strong> association on the <strong class="source-inline">Employee</strong> and <strong class="source-inline">Customer</strong> model using the <strong class="source-inline">Transaction</strong> model as the junction table. </p>
<p>Let us start with the definitions of these models to use throughout this section:</p>
<pre class="source-code">
const Employee = sequelize.define('employee', {
  name: DataTypes.STRING,
});
const Customer = sequelize.define('customer', {
  name: DataTypes.STRING
});
const Transaction = sequelize.define('transaction', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    allowNull: false
  },
  couponCode: DataTypes.STRING
});</pre>
<p>You may have noticed that the <strong class="source-inline">Transaction</strong> model has the <strong class="source-inline">id</strong> attribute explicitly defined as the primary key. This will prevent Sequelize from using the composition keys of <strong class="source-inline">employeeId</strong> and <strong class="source-inline">customerId</strong> as the primary key, which is required for establishing Super Many-to-Many relationships.</p>
<p>There are two ways<a id="_idIndexMarker488"/> to create a Many-to-Many relationship with these three models. The common way would be to use the <strong class="source-inline">belongsToMany</strong> association like so:</p>
<pre class="source-code">
Employee.belongsToMany(Customer, { through: Transaction });
Customer.belongsToMany(Employee, { through: Transaction });</pre>
<p>The other method is to use <strong class="source-inline">hasMany</strong> and <strong class="source-inline">belongsTo</strong> on both of the associating models:</p>
<pre class="source-code">
Employee.hasMany(Transaction);
Transaction.belongsTo(Employee);
Customer.hasMany(Transaction);
Transaction.belongsTo(Customer);</pre>
<p>These two methods will yield the same schematic result for the junction table (creating <strong class="source-inline">employeeId</strong> and <strong class="source-inline">customerId</strong> on the junction model). However, when you try to eager load the data, you may run into several issues depending on how you are trying to query the data.</p>
<p>With the <strong class="source-inline">belongsToMany</strong> associations, we may query our models in the following way (however, this will not work for the <strong class="source-inline">hasMany</strong> and <strong class="source-inline">belongsTo</strong> method):</p>
<pre class="source-code">
Employee.findAll({ include: Customer });
Customer.findAll({ include: Employee });</pre>
<p>Including the junction model from the associated models would not work for the <strong class="source-inline">belongsToMany</strong> approach, but the following code would work for the <strong class="source-inline">hasMany</strong> and <strong class="source-inline">belongsTo</strong> method:</p>
<pre class="source-code">
Employee.findAll({ include: Transaction });
Customer.findAll({ include: Transaction });</pre>
<p>Trying to include associated models through the junction model will only work with the <strong class="source-inline">hasMany</strong> and <strong class="source-inline">belongsTo</strong> method. The following code will not work for the <strong class="source-inline">belongsToMany</strong> pattern:</p>
<pre class="source-code">
Transaction.findAll({ include: Employee });
Transaction.findAll({ include: Customer });</pre>
<p>In order to be able to<a id="_idIndexMarker489"/> use all of the various forms of eager loading for these models, we can implement the Super Many-to-Many pattern by combining the two associated methods such as the following:</p>
<pre class="source-code">
Employee.belongsToMany(Customer, { through: Transaction });
Customer.belongsToMany(Employee, { through: Transaction });
Employee.hasMany(Transaction);
Transaction.belongsTo(Employee);
Customer.hasMany(Transaction);
Transaction.belongsTo(Customer);</pre>
<p>Declaring our associations like this would allow us to query associative data via the junction model, or the associated models themselves, without constraint or stipulations. Deeply nested includes are also supported natively with the Super Many-to-Many relationship.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor131"/>Using polymorphic associations</h2>
<p>When we have two or<a id="_idIndexMarker490"/> more associative models targeting the same foreign key on a junction table we can use a polymorphic association pattern for that scenario. You may think of polymorphic associations as some type of generic interfacing for associated data.</p>
<p>Suppose we owned an online retail store and wanted to store reviews for both widgets and gizmos under one review table. Initially, we would want to use <strong class="source-inline">hasMany</strong> and <strong class="source-inline">belongsTo</strong> associations, but this would cause Sequelize to generate two columns on the junction model (<strong class="source-inline">widgetId</strong> and <strong class="source-inline">gizmoId</strong>) instead of one for a generic pattern. Semantically, this would not make sense either since a review is not associated with a widget <em class="italic">and</em> a gizmo product. </p>
<p>First, we will need to define our <strong class="source-inline">Widget</strong> and <strong class="source-inline">Gizmo</strong> models:</p>
<pre class="source-code">
const Widget = sequelize.define('Widget', {
  sku: DataTypes.STRING,
  url: DataTypes.STRING
});
const Gizmo = sequelize.define('Gizmo', {
  name: DataTypes.STRING
});</pre>
<p>Next, we will define<a id="_idIndexMarker491"/> our <strong class="source-inline">Review</strong> model like so:</p>
<pre class="source-code">
const Review = sequelize.define('Review', {
  message: DataTypes.STRING,
  entityId: DataTypes.INTEGER,
  entityType: DataTypes.STRING
}, {
    instanceMethods: {
        getEntity(options) {
if (!this.entityType) return Promise.resolve(null);
const mixinMethodName = `get${this.entityType}`;
            return this[mixinMethodName](options);
        }
    }
});</pre>
<p>The <strong class="source-inline">instanceMethods</strong> parameter will create a <strong class="source-inline">getEntity</strong> function per instance, which will check to see whether <strong class="source-inline">entityType</strong> is null. If there is an entity type, then we can call the<a id="_idIndexMarker492"/> associated mixin function by adding a <strong class="source-inline">get</strong> prefix to the entity type’s value.</p>
<p>Now we can establish our relationships as shown here:</p>
<pre class="source-code">
Widget.hasMany(Review, {
  foreignKey: 'entityId',
  constraints: false,
  scope: {
    entityType: 'Widget'
  }
});
Review.belongsTo(Widget, { foreignKey: 'entityId', 
                           constraints: false });
Gizmo.hasMany(Review, {
  foreignKey: 'entityId',
  constraints: false,
  scope: {
    entityType: 'Gizmo'
  }
});
Review.belongsTo(Gizmo, { foreignKey: 'entityId', 
                          constraints: false });</pre>
<p>For each association, we will use <strong class="source-inline">entityId</strong> as <strong class="source-inline">foreignKey</strong>, and since the junction model references more than one table, we cannot set a reference constraint on that table (which is why we set <strong class="source-inline">constraints</strong> to <strong class="source-inline">false</strong>):</p>
<pre class="source-code">
Review.addHook("afterFind", findResult =&gt; {
if (!Array.isArray(findResult)) findResult = [findResult];
  for (const instance of findResult) {
    if (instance.entityType === "Widget" &amp;&amp; instance.Widget 
        !== undefined) {
      instance.entity = instance.Widget;
    } else if (instance.entityType === "Gizmo" &amp;&amp; in
               stance.Gizmo !== undefined) {
      instance.entity = instance.Gizmo;
    }
  }
});</pre>
<p>To query the <a id="_idIndexMarker493"/>associations, do the following:</p>
<pre class="source-code">
const widget = await Widget.create({ sku: "WID-1" });
const review = await widget.createReview({ message: "it works!" });
// the following should be true
console.log(review.entityId === widget.id);</pre>
<p>Polymorphism allows us to retrieve the widget or gizmo without being pre-deterministic in our queries by calling our instance method, <strong class="source-inline">getEntity</strong>:</p>
<pre class="source-code">
const entity = await review.getEntity();
// widget and entity should be the same object and return 
   "true" for deep comparison checking
const isDeepEqual = require('deep-equal');
console.log(isDeepEqual(widget, entity));</pre>
<p>In order to load our <a id="_idIndexMarker494"/>data eagerly, we would include the associated models like any other eager-loaded query:</p>
<pre class="source-code">
const reviews = await Review.findAll({
    include: [Widget, Gizmo]
});
for (const review of reviews) {
    console.log('Found a review with the following entity: 
                 ', review.entity.toJSON());
}</pre>
<p>The <strong class="source-inline">afterFind</strong> hook will automatically associate the <strong class="source-inline">create</strong> instance to the <strong class="source-inline">entity</strong> key for each review. </p>
<p>Since we are referencing more than one table to one target column, we will need to be extra careful when querying the junction model. For instance, if both <strong class="source-inline">Widget</strong> and <strong class="source-inline">Gizmo</strong> had an ID of <strong class="source-inline">5</strong> and a review had <strong class="source-inline">entityType</strong> of <strong class="source-inline">Gizmo</strong>, and we queried reviews with <strong class="source-inline">Review.findAll({ include: Widget })</strong>, then the <strong class="source-inline">Widget</strong> instance would be eager loaded into <strong class="source-inline">Review</strong> regardless of <strong class="source-inline">entityType</strong>.</p>
<p>Sequelize will not automatically infer the entity’s type from the model’s name. Luckily, our <strong class="source-inline">afterFind</strong> life cycle event will assign the entity value properly. It is recommended to always use the abstracted methods (for example, <strong class="source-inline">getEntity</strong>) over Sequelize’s mixins (for example, <strong class="source-inline">getWidget</strong>, <strong class="source-inline">getGizmo</strong>, etc.) in order to avoid ambiguity.</p>
<p>So far, we have shown an example of a One-to-Many relationship, but what about a Many-to-Many? Using the previous example models, we can add an associated model called <strong class="source-inline">Categories</strong>, which would look like the following:</p>
<pre class="source-code">
const Category = sequelize.define('Category', {
    name: DataTypes.STRING
}, {
    instanceMethods: {
        getEntities(options) {
            const widgets = await this.getWidgets(options);
            const gizmos = await this.getGizmos(options);
            return [].concat(widgets, gizmos);
        }
    }
});</pre>
<p>Now, we can create<a id="_idIndexMarker495"/> our junction model for a Many-to-Many relationship by assigning two foreign key columns:</p>
<pre class="source-code">
const CategoryEntity = sequelize.define('CategoryEntity', {
    categoryId: {
        type: DataTypes.INTEGER,
        unique: 'ce_unique_constraint'
    },
    entityId: {
        type: DataTypes.INTEGER,
        unique: 'ce_unique_constraint',
        references: null
    },
    entityType: {
        type: DataTypes.STRING,
        unique: 'ce_unique_constraint'
    }
});</pre>
<p>The <strong class="source-inline">ce_unique_constraint</strong> lines will tell Sequelize that all three of these attributes belong to the same composited unique key. The null reference for <strong class="source-inline">entityId</strong> will ensure that Sequelize will not create a reference constraint for that column.</p>
<p>Next, we can define<a id="_idIndexMarker496"/> our relations for <strong class="source-inline">Widget</strong> and <strong class="source-inline">Gizmo</strong> along with a helper method. We will assign a common parameter configuration along with a function for amending a scope to the parameter:</p>
<pre class="source-code">
const throughJunction = {
    through: {
      model: CategoryEntity,
      unique: false
    },
    foreignKey: 'entityId',
    constraints: false
};
function scopeJunction(scope) {
    let opts = throughJunction;
    opts.through.scope = {
        entityType: scope
    };
    return opts;
}</pre>
<p>Then, we can assign our relationships to the applicable models:</p>
<pre class="source-code">
Widget.belongsToMany(Category, scopeJunction('Widget'));
Category.belongsToMany(Widget, throughJunction);
  
Gizmo.belongsToMany(Category, scopeJunction('Gizmo'));
Category.belongsToMany(Gizmo, throughJunction);</pre>
<p>Calling a<a id="_idIndexMarker497"/> method such as <strong class="source-inline">widget.getCategories()</strong> would execute a similar query to this:</p>
<pre class="source-code">
SELECT
    `Category`.`id`,
    `Category`.`name`,
    `CategoryEntity`.`categoryId` AS `CategoryEntity.
     categoryId`,
    `CategoryEntity`.`entityId` AS `CategoryEntity.entityId`,
    `CategoryEntity`.`entityType` AS `CategoryEntity.
     entityType`,
FROM `Categories` AS `Category`
INNER JOIN `CategoryEntities` AS `CategoryEntity` ON
    `Category`.`id` = `CategoryEntity`.`categoryId` AND
    `CategoryEntity`.`entityId` = 1 AND
    `CategoryEntity`.`entityType` = 'Widget';</pre>
<p>Now that we have learned how to operate with associations and relationships for Sequelize, we can begin making some modifications to our Avalon Airlines project.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor132"/>Applying associations to Avalon Airlines</h1>
<p>Luckily, the <a id="_idIndexMarker498"/>models for the project are simple and won’t require the <a id="_idIndexMarker499"/>amount of effort as defining a Super Many-to-Many relationship. Within these next several model updates, this book will demonstrate what to modify only for the <strong class="source-inline">class</strong> model block (the rest of the contents within each file should remain the same).</p>
<p>Starting in alphabetical order, we will begin modifying the <strong class="source-inline">models/airplane.js</strong> file’s <strong class="source-inline">class</strong> block by adding a relationship to <strong class="source-inline">FlightSchedule</strong>:</p>
<pre class="source-code">
class Airplane extends Model {
  static associate(models) {
this.FlightSchedules =
this.hasMany(models.FlightSchedule);
  }
};</pre>
<p>Next, we can edit the <strong class="source-inline">models/boardingticket.js</strong> file’s <strong class="source-inline">class</strong> block and add a <strong class="source-inline">Customer</strong> and <strong class="source-inline">FlightSchedule</strong> relationship:</p>
<pre class="source-code">
class BoardingTicket extends Model {
  static associate(models) {
    this.Customer = this.belongsTo(models['Customer']);
    this.FlightSchedule = this.belongsTo(models['FlightSchedule']);
  }
};</pre>
<p>Customers will now <a id="_idIndexMarker500"/>have many boarding tickets; the <strong class="source-inline">models/customer.js</strong> file’s <strong class="source-inline">class</strong> block should now look like this:</p>
<pre class="source-code">
class Customer extends Model {
  static associate(models) {
this.BoardingTickets = 
this.hasMany(models.BoardingTicket);
  }
};</pre>
<p>Flight schedules <a id="_idIndexMarker501"/>will belong to a specific airplane, and they will have many boarding tickets. We can edit the <strong class="source-inline">models/flightschedule.js</strong> file’s <strong class="source-inline">class</strong> block to match the following example:</p>
<pre class="source-code">
class FlightSchedule extends Model {
  static associate(models) {
    this.Airplane = this.belongsTo(models['Airplane']);
    this.BoardingTickets = this.hasMany(models['BoardingTicket']);
  }
};</pre>
<p>Since we are not executing <strong class="source-inline">sync({ force: true })</strong> when initializing Sequelize, we will need to generate a migrations file and add the necessary references for their respective models. We can use the Sequelize CLI tool to generate a new migrations file using the <strong class="source-inline">migration:generate</strong> subcommand:</p>
<p class="source-code">sequelize migration:generate --name add-references</p>
<p>Sequelize will notify<a id="_idIndexMarker502"/> you on the new file that it has generated a<a id="_idIndexMarker503"/> migration file with a message similar to this:</p>
<p class="source-code">New migration was created at /Users/book/migrations/20211031155604-add-references.js .</p>
<p>The prefixed number on the filename will be different from what appears on your screen, but if we look into the <strong class="source-inline">migrations</strong> directory, then we will see a newly generated file. We can quickly overwrite the file’s contents.</p>
<p>At the top of the file, we will want to include <strong class="source-inline">DataTypes</strong> and start our migration’s <strong class="source-inline">up</strong> block:</p>
<pre class="source-code">
const { DataTypes } = require("@sequelize/core");
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; { </pre>
<p>We can now add the <strong class="source-inline">FlightSchedule</strong> model’s reference for the <strong class="source-inline">Airplane</strong> model by adding a column first and then adding the constraint:</p>
<pre class="source-code">
    await queryInterface.addColumn('FlightSchedules', 'AirplaneId', {
      type: DataTypes.INTEGER,
    });
    await queryInterface.addConstraint('FlightSchedules', {
      type: 'foreign key',
      fields: ['AirplaneId'],
      references: {
        table: 'Airplanes',
        field: 'id'
      },
      name: 'fkey_flight_schedules_airplane',
      onDelete: 'set null',
      onUpdate: 'cascade'
    });</pre>
<p>Next, we will <a id="_idIndexMarker504"/>want to do the same for <strong class="source-inline">BoardingTicket</strong> and its<a id="_idIndexMarker505"/> related models, <strong class="source-inline">Customer</strong> and <strong class="source-inline">FlightSchedule</strong>:</p>
<pre class="source-code">
    await queryInterface.addColumn('BoardingTickets', 'CustomerId', {
      type: DataTypes.INTEGER,
    }
);    await queryInterface.addConstraint('BoardingTickets', {
      type: 'foreign key',
      fields: ['CustomerId'],
      references: {
        table: 'Customers',
        field: 'id'
      }
,      name: 'fkey_boarding_tickets_customer',
      onDelete: 'set null',
      onUpdate: 'cascade'
    });
    await queryInterface.addColumn('BoardingTickets',  
                                   'FlightScheduleId', {
      type: DataTypes.INTEGER,
    });
    await queryInterface.addConstraint('BoardingTickets', {
      type: 'foreign key',
      fields: ['FlightScheduleId'],
      references: {
        table: 'FlightSchedules',
        field: 'id'
      },
      name: 'fkey_boarding_tickets_flight_schedule',
      onDelete: 'set null',
      onUpdate: 'cascade'
    });</pre>
<p>Now, we can <a id="_idIndexMarker506"/>close the <strong class="source-inline">up</strong> block and start our <strong class="source-inline">down</strong> block for migration reversal support:</p>
<pre class="source-code">
  },
  down: async (queryInterface, Sequelize) =&gt; {</pre>
<p>We will need to<a id="_idIndexMarker507"/> remove the constraints first, then the columns, and finally, close the <strong class="source-inline">down</strong> block and exported object like so:</p>
<pre class="source-code">
    await queryInterface.removeConstraint(
      'FlightSchedules', 'fkey_flight_schedules_airplane'
    );
    await queryInterface.removeConstraint(
      'BoardingTickets', 'fkey_boarding_tickets_customer'
    );
    await queryInterface.removeConstraint(
      'BoardingTickets', 
      'fkey_boarding_tickets_flight_schedule'
    );
    await queryInterface.removeColumn('FlightSchedules', 
       'AirplaneId');
    await queryInterface.removeColumn('BoardingTickets', 
       'CustomerId');
    await queryInterface.removeColumn('BoardingTickets', 
    'FlightScheduleId');
  }
};</pre>
<p>In our console, we <a id="_idIndexMarker508"/>can migrate these new changes with the<a id="_idIndexMarker509"/> following command:</p>
<p class="source-code">sequelize db:migrate</p>
<p>Sequelize will confirm that the migration has been completed, and our models are officially related to each other through associations. Throughout this book, we will use the lessons learned from this chapter for including associated data within our queries, but for now, we will move on to the next lesson.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor133"/>Summary</h1>
<p>In this chapter, we went over defining relations of models using associative properties along with some advanced options and relational patterns, and we went over the differences between eager loading and lazy loading. At the end of this chapter, we took our lessons from the previous chapter, <em class="italic">Validating Models</em>, and added validations, associations, and migrations for our Avalon Airlines project.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you ever get stuck on associations and need a quick reference, the related material can be found here: <a href="https://sequelize.org/docs/v6/core-concepts/assocs/">https://sequelize.org/docs/v6/core-concepts/assocs/</a>.</p>
<p>In the next chapter, we will go over Sequelize’s hook feature (also known as a life cycle event), how to define hooks for models, and what would be some good use cases for life cycle events.</p>
</div>
</div></body></html>