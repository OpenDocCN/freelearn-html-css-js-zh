- en: Documenting Our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have followed a test-driven approach to developing our User Directory
    application. We started by writing **End-to-End** (**E2E**) tests and using them
    to drive the development of our implementation code, and then added unit tests
    to catch regressions. We have also discussed that writing tests is the best form
    of documentation, since it provides actual examples of how to interact with our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'While our test suite is the most accurate and best form of documentation, providers
    of all major APIs also maintain browser-based API documentation that your end
    users can access as a web page/site. This is because:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all APIs are open-sourced, so developers may not always have access to the
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may require a lot of time and effort to understand the test suite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests lack *context*—you know how to call an endpoint, but you will have to
    figure out for yourself how it fits into the workflow of an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is language- and framework-specific—the browser-based documentation describes
    the interface of the API, not the implementation. It doesn't matter if our API
    is implemented in Express, Restify, Hapi, or in Python or Go. The end user does
    not need to understand JavaScript in order to understand this form of documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we simply provided the test suite for our end users without further guidance,
    they are likely to be deterred by the steep learning curve and decide to use an
    alternative service. Therefore, we must provide more user-friendly API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An API documentation describes, with examples, the functionality of each endpoint,
    and the constraints when calling them. Good API documentation usually:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provides a high-level overview of our API, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of the platform
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example use cases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to find more resources and/or receive support
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes a concise step-by-step guided tour on how to perform common scenarios
    (e.g. create a user, and then log in); that is, which API calls needs to be made,
    and in what order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes an API Specification, which provides technical references of each endpoint—what
    parameters are allowed and in which format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authoring of the high-level overview and the guided tour falls under the scope
    of a Technical Writer. But what makes a good piece of technical writing is beyond
    the scope of this book; instead, we will focus on how to write a good API specification. Specifically,
    we will be using the OpenAPI API specification language to write our API specification,
    and then use a set of tools called Swagger to generate an interactive browser-based
    API reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the **OpenAPI Specification** (**OAS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your own OpenAPI specification in **YAML**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **Swagger UI** to generate web-based API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of OpenAPI and Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **API description language** (or **API description format**) is a standard
    format for describing APIs. For example, the snippet below informs the consumers
    of our API that they need to provide a JSON payload with an `email` and `digest`
    field when calling the `POST /login` endpoint. In return, they can expect our
    API to respond with one of the four listed status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several benefits to writing an API specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The specification acts as a contract between our platform and the end consumers,
    which may not be limited to just developers, but also other internal APIs as well.
    Having a contract means consumers of our API are able to develop their integrations
    before our API is complete—because we have agreed, through the specification,
    how our API should behave—as long as everyone stays faithful to the API specification,
    the integration will be successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forces us to design the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create mock servers. These mock servers mimic the behavior of the real
    API server, but responds with canned responses instead. We can provide this mock
    server for end consumers before our API is complete, so they'll know how our API
    should respond.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using open source tools (such as Dredd—[dredd.org](http://dredd.org/en/latest/)),
    we can automatically test our API server to see if it complies with the specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools that integrate with our API server, we can use the specification
    to validate requests and responses automatically, without having to write extra
    validation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking an API specification language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example uses a standard called **OpenAPI** (formerly **Swagger**).
    At the time of writing, there are two other popular API specification languages
    out there, namely **RAML** and **API Blueprint**. Before we go any further, it's
    important to note that each language has its own set of limitations in terms of
    how accurately it can describe an existing API, or the comprehensiveness of the
    tooling surrounding it. Out of the three, however, OpenAPI is the most mature
    and has the best community support, and it's what we will be using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger vs OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When reading articles online, you'll often hear the terms Swagger and OpenAPI
    used interchangeably. So, before we continue, let's clarify these terms. *Swagger* began
    in 2011 as a set of tools that allow developers to represent API as code, in order
    to automatically generate documentation and client SDKs. Swagger has since undergone
    two major versions (1.0 and 2.0). After the release of Swagger 2.0, the rights
    to Swagger were bought by SmartBear Software, who decided to donate the rights
    of the specification format to the Linux Foundation, under the OpenAPI Initiative.
  prefs: []
  type: TYPE_NORMAL
- en: On 1 January 2016, the Swagger specification was renamed to the *OpenAPI Specification* (OAS).
    Since then, a newer version, 3.0.0 of OAS, has been released.
  prefs: []
  type: TYPE_NORMAL
- en: OAS 2.0 is identical to Swagger 2.0 apart from the name.
  prefs: []
  type: TYPE_NORMAL
- en: However, although the specification has been renamed to OAS, the tooling around
    the specification is still developed and maintained by SmartBear Software; therefore,
    you may hear developers talk about both Swagger and OpenAPI at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In short, OpenAPI is the specification language itself, while Swagger is a set
    of tools that work with and around an OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So let''s examine the Swagger Toolchain in more detail. Swagger is a set of
    developer tools that are useful across the entire API lifecycle, and includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger Editor**: A split-screen editor that allows you to write your specification
    on one side, and provide real-time feedback on the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger UI**: Generates documentation in HTML format from your specification
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger Codegen**: Generates Client SDKs in multiple languages, allowing
    developers to easily interact with your API without calling the endpoints directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger Inspector**: Allows you to test your endpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the official tools developed and maintained by SmartBear Software,
    there are also numerous community-contributed packages and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swagger Editor is like your code editor for specification. It provides real-time
    validation, code auto-completion, code highlighting and a preview of the output
    documentation. Here''s a screenshot of Uber''s API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59c03172-1803-4689-841c-78b741f59840.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swagger UI is a self-contained, frontend application that renders an interactive
    documentation from your specification. All you have to do is provide a public
    URL to the OpenAPI specification, and Swagger UI will do the rest. Following is
    a screenshot of the sample Swagger Petstore documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a22b63f8-7aeb-40c1-b92d-2c044084b3aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The interactive documentation also has a Try it now button, which allows you
    to send real requests to the server and view the results, all without leaving
    the documentation page. This streamlines the workflow of our end users as they
    don’t have to open external tools like Postman and/or Paw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/509f74aa-7a7b-456c-a82a-6a0bd614bac9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can try out a live demo at [petstore.swagger.io](http://petstore.swagger.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Swagger Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger Inspector is like Postman for Swagger—it allows you to call and validate
    REST, GraphQL, and SOAP APIs. Like Postman, it saves a history of your past queries.
    Furthermore, it can automatically generate a specification from the results returned
    from the inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger codegen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger is able to use your API specification to generate server stubs and client
    SDKs. There are many languages/frameworks supported by Swagger Codegen. You may
    use the server stubs as boilerplate for the API you are about to build, or as a
    mock server to showcase how the API should behave. You may also use the generated client
    SDKs as the foundation and build upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an API specification with OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand what an API specification and the OpenAPI standard are,
    as well as the tooling provided by Swagger, let''s begin the documentation process
    by writing the specification for our API. We''ll start by creating a file new
    at `src/spec/openapi/hobnob.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Learning YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to know is that an OpenAPI specification must be a valid JSON
    document. The specification also explicitly allows YAML, which is a superset of
    JSON and can be converted to JSON. We will be using YAML because it is more readable
    (and thus writable) by humans, even for non-developers. Furthermore, you can add
    comments inside YAML files, something that's not possible with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by learning the basics of YAML. We only need to learn a few basic
    pieces of syntax to write our OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: Like JSON, getting started with the basic syntax for YAML is very simple. All
    YAML documents start with three dashes (`---`) to indicate the start of the file,
    and three periods (`...`) to indicate the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the most common data structures you need to represent in a configuration
    file are key-value pairs and lists. To represent a set of key-value pairs, simply
    write each one on a new line, separated by a colon and space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you do not need to use quotes unless you use a special character,
    or need to be explicit about the data type (for example, `10` may be interpreted
    as a number, and `yes` may be interpreted as `true`). For simplicity's and consistency's
    sake, you may want to use double quotes for all your strings, but we won't do
    that here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent nested objects, simply indent the child object by two spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent a list, place each item on a new line, preceded by a dash and
    a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To conserve newline characters, use the pipe (`|`) character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to break a line of text over multiple lines (to make it easier to read),
    which shouldn''t preserve newlines, use the greater-than character (`>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An overview of the root fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basics of YAML, we're ready to write our specification.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few versions of the OpenAPI Specification available. At the time
    of writing this book, the OpenAPI Specification is at version `3.0.0` and was
    officially released on 26 July 2017\. You may also find many OpenAPI 2.0 specifications
    in the wild as tooling support for 3.0.0 is lacking in many areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use OAS 3.0.0 as it is the latest version. Here, you''ll find an overview
    of all the possible root properties in OAS 3.0.0\. Not all fields are covered,
    and required fields are marked with an asterisk (`*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`openapi*` (string): This specifies the OpenAPI specification version in use.
    We should specify the semver version; for us, we will use `"3.0.0"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info*` (object): Metadata about the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version*` (string): The version of the API this specification is written for. **Please
    note that this is the version of the API itself, not the OpenAPI Specification.**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title*` (string): The name of your API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` (string): A short description of your API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact` (object): Information regarding whom to contact for support.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` (string): The name of the person/department/organization to contact.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` (string): A valid URL pointing to a page with contact information.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email` (string): A valid email address where inquiries can be sent.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`termsOfService` (string): A valid URL pointing to the Terms of Service notice
    for the API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license` (object): License information of the API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name*` (string): Name of the license.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` (string): A valid URL pointing to the license.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servers` (array of objects) A list of servers that are serving the API. This
    is an improvement on the OAS 2.0 root fields `host` and `basePath`, as it allows
    for multiple hosts to be specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url*` (string): A valid URL to the target host. This may be a relative URL,
    relative from the location at which the OpenAPI specification is being served.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` (string): A short description of the host. This is useful for
    distinguishing between different hosts if multiple are specified.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paths*` (object): All paths and operations (such as endpoints) are exposed
    by the API. The paths object is a dictionary of paths (for example, `/users`)
    and *Path Item Objects*. A Path Item Object is a dictionary of (mostly) HTTP verbs
    (for example, `post`) and *Operation Objects*. The Operation Object is the one
    that defines the behavior of the endpoint, such as what parameters it accepts
    and the type of responses it emits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`components` (object): This holds a set of reusable objects to be reused. The
    purpose of components is to minimize duplication within the specification. For
    example, if *multiple* endpoints may return a `401 Unauthorized` error with the
    message `"The Authorization header must be set"`, we can define a component called
    `NoAuthHeaderSet`, and reuse this object in place of the response definition. Components
    can be referenced from other parts of the specification later using JSON references
    (`$ref`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In OAS 2.0, the components root field did not exist; instead, the `definitions`,
    `parameters`, and `responses` root fields were used. In OAS 3.0.0, components
    are not limited to data types (or schema), parameters and responses, but also
    examples, request bodies, headers, security schemes, links, and callbacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`security` (array of objects): A list of *Security Requirement Objects* that
    are acceptable across the whole API. A Security Requirement Object is a dictionary
    of security schemes that are common across different operations. For example,
    we require that the client provides a valid token on many endpoints; therefore,
    we can define that requirement here, and apply it in a DRY manner within each
    definition. For endpoints that do not require a token, we can override this requirement
    on an individual basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags` (array of strings): You can group operations using tags by specifying
    a list of strings inside the Operation Object. Tools, such as Swagger UI, may
    use these tags to group related endpoints together. The root `tags` property provides
    metadata (e.g. long description) on those tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`externalDocs` (object): Additional external documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a brief overview of the root fields, let's begin composing
    our specification. To ease ourselves into it, we will start by defining the simpler
    fields like `info`, then moving on to endpoints that do not require authentication.
    Once we are more comfortable, we will define security schemes and security requirements
    and add the specification for endpoints that require authentication.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, add the following metadata to `spec/openapi/hobnob.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the GET /salt endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ease our way into composing the full API specification, let''s start with
    the simplest endpoint—`GET /salt`. To start off, we will add the `paths` root
    property, specify the path we are defining (`/salt`), and then the operation (`get`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `get` property, we will define an *operation object*. The full specification
    for the Operation Object can be found at [github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object).
    For our use cases, we are concerned with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tags`: This is used to logically group operations when displayed with Swagger
    UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`summary`: A short summary of what the operation does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: A more verbose description of the operation, which may include
    nuances that a developer might need to be aware of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters`: A *parameter object* that describes what parameters are allowed/required,
    and how these parameters should be provided (such as URL parameters, query strings,
    headers, or cookies).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestBody`: A *request body object* that describes the body of the request,
    if any. It describes what types of payloads are allowed (for example, `application/json`,
    `text/plain`), and, if it is an object, what data type and formats each property
    should be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responses`: A *Responses Object* that describes all possible responses this
    endpoint can produce.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s start with the simpler fields: `tags`, `summary`, and `description`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Specifying parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Get Salt endpoint does not accept any request bodies, but it does require
    a query string parameter called `email`, which must be set to a valid email address.
    Therefore, we must define a `parameters` property, containing a list of *parameter
    objects*. Each Parameter Object can contain the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name*` (string): The name of the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in*` (string): Where the parameter is specified. Possible values are `query`,
    `header`, `path`, or `cookie`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (boolean): Whether the parameter is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` (object): This describes the structure of the parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the OpenAPI syntax for defining schema looks a lot
    like JSON Schema. This is because OpenAPI Specification is actually based on the
    first drafts of the JSON Schema specification.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to specify what our endpoint can potentially respond with. This
    is a required field for all operation objects. The responses Object is a map of
    numeric HTTP status codes and a *response object*, which should contain two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`description`: A short description of the payload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content` (object): This specifies the valid MIME types (for example, `application/json`, `text/plain`) that
    are acceptable for this endpoint, as well as the expected structure of the payload:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that we haven't forgotten any responses, we can check our request
    handler (`src/handlers/auth/salt/retrieve/index.js`), our middleware, as well
    as our E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have now defined the Get Salt endpoint with the OpenAPI specification language.
    Let's move on to a slightly more complicated endpoint—Create User—and see how
    we can specify payload bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Create User endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using what you''ve just learned, specify a new path, operation, and operation
    object for the Create User endpoint, filling in the `tags`, `summary`, `description,`
    and `responses` properties. You should end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the request body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Create User endpoint does not accept any parameters, but it does require
    a JSON payload that conforms to our User schema. Therefore, we should add a new `requestBody` field
    inside our Operation Object to define this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `requestBody` field should contain three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`description`: A short description of the payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`(object): This specifies the valid MIME types (for example, `application/json`, `text/plain`) that
    are acceptable for this endpoint, as well as the expected structure of the payload.
    This structure is defined under the MIME type property, under a sub-property called `schema`,
    and is very similar to the JSON schema syntax, represented as YAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (boolean): This specifies whether the request payload is required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining common components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that our specification is not very DRY – we are repeatedly
    specifying common responses like the 500 Internal Error. Therefore, before we
    learn how to specify URL parameters and our security schemes, let's first see
    how we can use the `components` root property to define common entities in a single
    location, and reference it throughout the OpenAPI specification. We will do this
    for our Create User object, as well as all our responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the following `components` section as a root property
    to our specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now refer to this Profile schema component anywhere in our specification
    using the reference `''#/components/schemas/Profile''`. In other words, we can
    shorten our definition for the `requestBody` property of our Create User endpoint
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through another example. Currently, our `GET /salt` endpoint can
    respond with a 200 response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pull this response out and define it as a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like before, we can reference the `SaltRetrieved` response component
    by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Having gone through two examples, you should now try to pull out as many common
    components as you can. Once you're done, check the code bundle to see our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Retrieve User endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to use Components to reduce code duplication, let's
    carry on with specifying the Get User endpoint, and learn how to represent URL
    parameters in OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that it's very simple—it's just another parameter, just like query
    parameters. The only difference is that we need to use path templating to specify
    where this parameter resides in our URL. For instance, the path would be specified
    as `/users/{userId}` for our Retrieve User endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to define a new Schema object called `UserLimited`, which describes
    a complete User object but without the `digest` field. This is the shape of the
    object we will return in our Retrieve User endpoint. Lastly, we also added a new
    `ErrorNotFound` response to cater for when a user with that ID does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The additions made to the schema should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the Replace Profile endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we will demonstrate is describing the Replace Profile endpoint.
    This endpoint requires the user to be logged in and provides the token in the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s use everything we have learned so far to define the parameters,
    request bodies, and responses for the Replace Profile endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined two new response:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Success`, which is simply a `200 Success` response with no payload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ErrorUnauthorized`, which should be returned if the `Authorization` header
    (containing our JSON Web Token) is not present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's new is the `securitySchemes` we've defined under `components` at the
    root of the OpenAPI object. In OAS, a *security scheme* is a method for our client
    to authenticate themselves. Supported schemes are HTTP authentication, API key,
    OAuth2, and OpenID Connect Discovery. Since we are using the Bearer scheme in
    our HTTP Authorization header to authenticate, we have defined it as such.
  prefs: []
  type: TYPE_NORMAL
- en: In our Operation Object, we have also included a `security` property that states
    that this endpoint needs to be authenticated using the security scheme we've defined
    called `token`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the rest of the endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've covered so far should have provided enough information for you to
    complete the OpenAPI specification for the rest of the endpoints. Do attempt to
    complete it and refer back to the code bundle to check it against our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation with Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a valid OpenAPI specification, which we can use to generate web-based
    API documentation using Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Swagger UI to our repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swagger UI source files are located in the `dist/` directory of the official
    repository. The official way of generating documentation UI for our own specification
    is to download the Swagger UI source files from [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases)
    and statically serve the page at `dist/index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''ll more preferable to have the source code of the web UI in the
    same repository as our API. A naive approach would be to download the latest source
    files for Swagger UI from [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases),
    unpack the contents, and copy the contents of the `dist/` directory into a `docs/`
    directory inside our repository. However, this requires us to manually update
    the contents of the `docs/` directory each time there''s an update on Swagger
    UI; obviously, that''s not ideal. Luckily, there''s a cleaner way of achieving
    the same thing using **Git submodules**. Run the following at our project''s root
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Locally, this will download the entire contents of the Swagger UI repository
    and save it into the `docs/` directory at the root of your project. However, in
    Git, only the `.gitmodules` file and a small `docs` file is tracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b2c2b0f-50b4-4982-95a8-837bcf9f2f52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This keeps our Git repository clean, and tracks only code which is our own
    (and not third-party code). When we want to update to the latest version of Swagger
    UI, all we have to do is update the Git `submodule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the update script as an npm script to make it easier to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using our specification in the Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have added the Swagger UI into our repository, the next task is
    to write a script to serve it on a web server. Since these are simply static files
    with no backend involvement, any web server would be sufficient. Here, we will
    use the `http-server` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `http-server` package uses the port 8080, which we are already
    using for our API. Therefore, we must use the `-p` flag to specify an alternate
    port. However, we don''t want to hard-code this value into our NPM script; instead,
    we want to take it from our environment variable `SWAGGER_UI_PORT`. To achieve
    this, we need to create a new Bash script at `scripts/swagger-ui/serve.sh` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember to make the script executable by running `chmod +x scripts/swagger-ui/serve.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside `.env` and `.env.example`, define the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a new NPM script to serve our docs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will download or update the Swagger UI source code and serve the site
    from the `docs/dist/` directory. Now, navigate to `http://127.0.0.1:8000` from
    your browser and you should see a page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf7609d2-d2e7-4d03-91c0-d2c354186686.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, `dist/index.html` uses a demo specification available at [petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json),
    which is what is shown here. To make Swagger UI display documentation for our
    own API, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose the `hobnob.yaml` file in a publicly-accessible location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a script to replace the demo URL with our own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exposing swagger.yaml from our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exposing the `hobnob.yaml` file is as simple as adding a new endpoint to our
    API. However, the specification file is located at `spec/openapi/hobnob.yaml`,
    which is outside the `dist/` directory of our application. Therefore, first, we
    should modify our serve script to also copy the OpenAPI specification to the root
    of the `dist/` directory after the application has been built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside `src/index.js`, we need to add a new endpoint to retrieve and serve
    that same `openapi.yaml`. Add the following to `src/index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, whilst running the `dev:serve` script, open your browser to `http://127.0.0.1:8080/openapi.yaml`.
    You should see the OpenAPI specification displayed on the screen!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, if we go back to our Swagger UI page (at `127.0.0.1:8000`) and paste
    the URL `http://localhost:8000/openapi.yaml` into the input bar, it should load
    the page with our own API specification. However, the page shows an error about **Cross-Origin
    Resource Sharing** (**CORS**).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5d4fa4d-b533-4bc5-b9e9-7a4fdcaa65aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Same-origin policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For security reasons and in order to protect end users, most browsers enforce
    the **same-origin policy**, which means that the browser will prevent scripts
    loaded from one origin (for example, `http://127.0.0.1:8000`) from making calls
    to a server of a different origin (for example, `http://localhost:8080`). To demonstrate
    why the same-origin policy is important, take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose you are logged in to your online banking site, `personal.bank.io`.
    Then, you open a malicious site, `malicious.io`, which runs the following script
    inside `malicious.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the same-origin policy was not in place and this request was allowed to proceed,
    then you would have lost a lot of money. Note that this is a variation on the **Cross-Site
    Request Forgery** (**CSRF**) attack we analyzed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, the same-origin policy also limits legitimate use cases just like our
    own. Therefore, the **World Wide Web Consortium** (**W3C**) came up with the **Cross-Origin
    Resource Sharing** (**CORS**) specification to deal with this. The CORS specification
    outlines the mechanism whereby browsers and servers can communicate with each
    other, through a set of HTTP headers, in order to determine which cross-origin
    requests are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full specification at [w3.org/TR/cors/](https://www.w3.org/TR/cors/).
  prefs: []
  type: TYPE_NORMAL
- en: 'CORS requires support from both the client (the browser) and the server. Almost
    all modern browsers support CORS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbb0dc7a-2570-4165-885e-b33bfe989ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: You can explore more detailed browser support for CORS at [caniuse.com/#feat=cors](https://caniuse.com/#feat=cors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the only thing we need to do is set up our Express server to enable
    CORS. To make things easy, there''s a really handy site, [enable-cors.org](https://enable-cors.org/),
    that provides sample code of how to enable CORS for your specific server. We can
    find the instruction for Express at [enable-cors.org/server_expressjs.html](https://enable-cors.org/server_expressjs.html).
    All we need to do is add the following middleware before our other middlewares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Access-Control-Allow-Origin` header specifies requests from which origins
    are allowed to make cross-site requests. Here, we are using the glob wildcard
    `'*'` to allow cross-site requests from all origins.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we paste in their sample code into `src/index.js`, reload our server, and
    also reload the Swagger UI documentation page, the CORS issue should be resolved
    and we should see details about our API displayed on-screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d3a65e2-5c57-4e80-b64f-ba1303cf1a34.png)'
  prefs: []
  type: TYPE_IMG
- en: However, allowing CORS requests for all origins is the same as disregarding
    the same-origin policy set by browsers, which, as we've demonstrated, is an important
    policy to keep. Therefore, if possible, we should specify a whitelist of origins
    that are allowed to make CORS requests. At the moment, this is only the Swagger
    UI documentation site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can update our code to whitelist the documentation site''s origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, when we deploy our application and make our documentation publically
    available, we know that the docs would be served as a publicly-accessible URL,
    and not at `127.0.0.1:8000`. Therefore, it makes little sense for us to hard-code
    the origin into the code. Instead, consistent with our approach so far, we should
    define the origin as a set of environment variables, use those variables within
    our code, and update our code to use these variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Save and restart your API server, and our Swagger UI documentation should still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Final touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last issue remains—when the documentation page first loads, it still defaults
    to using the demo [petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json)
    URL. This is not good for user experience as the user must manually paste in the
    URL of the specification they are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, our page should load the correct specification on the first load, and
    there should be no top bar for our visitors to load another API's specification.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the specification URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To replace the demo URL, we are going to use a Bash script that will use environment variables
    to compose the URL of our `openapi.yaml`, and then substitute it in using `sed`.
    However, the `SERVER_*` environment variables we have set are internal, and won't
    be valid for our clients. Therefore, we need to add three more environment variables
    to hold the external URL of our API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `envs/.env` and `envs/.env.example`, add the following three environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new file at `scripts/swagger-ui/format.sh` with execute permissions and
    paste in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, also add a new NPM script to call our the `format.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also update our `docs:update` script in order to:'
  prefs: []
  type: TYPE_NORMAL
- en: Reset any changes made in the Git submodules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the latest Swagger UI repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `docs:format` to replace the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, run `yarn run docs:update` and then reload our Swagger UI page, it'll default
    to using our API specification instead of the demo specification.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, we need to remove the header from Swagger UI. The header
    has a CSS class of `topbar`. Therefore, to remove the header from our page, we
    can simply inject the following CSS into the header of our page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To do that, we will search for the `</head>` closing tag within `docs/dist/index.html`,
    and insert a newline above it with our own style tag. These steps can be achieved
    with one simple `sed` script. Add it at the end of `scripts/swagger-ui/format.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Run `yarn run docs:update && docs:serve` once more. Now, our page will not display
    the header any more!
  prefs: []
  type: TYPE_NORMAL
- en: Once you're happy with the changes, commit them and merge it back to the `dev`
    and `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, let's go into our remote server and deploy our documentation site. We
    do this by pulling in our changes and installing the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll also need to generate a new set of keys and set the `SWAGGER_UI_*` environment
    variables inside the `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the `docs:update` script to generate the static files which would
    be served by NGINX. To give NGINX access to these files, we should also update
    the owner and group of the `docs` directory to `nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the API server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, add a new virtual host definition at `/etc/nginx/sites-available/docs.hobnob.social`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will simply ask NGINX to serve the static files at `/home/hobnob/projects/hobnob/docs/dist`.
    Then, to enable this `server` block, link it to the `/etc/nginx/sites-enabled/`
    directory and restart NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, go to the DigitalOcean administrative panel and add an `A` record for
    `docs.hobnob.social`, pointing to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba0bf50c-e7e7-466c-8931-8269717ef08f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you should be able to see our documentation at `docs.hobnob.social`!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the OpenAPI specification format to document our API
    and used Swagger UI to transfer that specification into a user-friendly web page.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the work we need to do for our back-end code. In the next chapter,
    we will build the front-end user interface that will interact with our API.
  prefs: []
  type: TYPE_NORMAL
