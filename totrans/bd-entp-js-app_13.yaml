- en: Documenting Our API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录我们的API
- en: So far, we have followed a test-driven approach to developing our User Directory
    application. We started by writing **End-to-End** (**E2E**) tests and using them
    to drive the development of our implementation code, and then added unit tests
    to catch regressions. We have also discussed that writing tests is the best form
    of documentation, since it provides actual examples of how to interact with our
    API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直遵循测试驱动的方法来开发我们的用户目录应用程序。我们首先编写**端到端**（**E2E**）测试，并使用它们来驱动实现代码的开发，然后添加单元测试来捕获回归。我们还讨论了编写测试是最佳文档形式，因为它提供了如何与我们的API交互的实际示例。
- en: 'While our test suite is the most accurate and best form of documentation, providers
    of all major APIs also maintain browser-based API documentation that your end
    users can access as a web page/site. This is because:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的测试套件是最准确和最好的文档形式，但所有主要API的提供者也维护基于浏览器的API文档，您的最终用户可以将其作为网页/站点访问。这是因为：
- en: Not all APIs are open-sourced, so developers may not always have access to the
    tests.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有API都是开源的，因此开发者可能无法始终访问测试。
- en: It may require a lot of time and effort to understand the test suite.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试套件可能需要大量的时间和精力。
- en: Tests lack *context*—you know how to call an endpoint, but you will have to
    figure out for yourself how it fits into the workflow of an application.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试缺乏**上下文**——您知道如何调用端点，但您将不得不自己弄清楚它如何适应应用程序的工作流程。
- en: It is language- and framework-specific—the browser-based documentation describes
    the interface of the API, not the implementation. It doesn't matter if our API
    is implemented in Express, Restify, Hapi, or in Python or Go. The end user does
    not need to understand JavaScript in order to understand this form of documentation.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是语言和框架特定的——基于浏览器的文档描述了API的接口，而不是实现。无论我们的API是用Express、Restify、Hapi、Python还是Go实现的，最终用户都不需要理解JavaScript就能理解这种文档形式。
- en: If we simply provided the test suite for our end users without further guidance,
    they are likely to be deterred by the steep learning curve and decide to use an
    alternative service. Therefore, we must provide more user-friendly API documentation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是向最终用户提供测试套件而不提供进一步指导，他们可能会因为陡峭的学习曲线而感到沮丧，并决定使用替代服务。因此，我们必须提供更用户友好的API文档。
- en: 'An API documentation describes, with examples, the functionality of each endpoint,
    and the constraints when calling them. Good API documentation usually:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: API文档通过示例描述了每个端点的功能以及调用它们的约束。好的API文档通常：
- en: 'Provides a high-level overview of our API, including:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了我们API的高级概述，包括：
- en: A brief overview of the platform
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台的简要概述
- en: Example use cases
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例用例
- en: Where to find more resources and/or receive support
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里可以找到更多资源或获得支持
- en: Includes a concise step-by-step guided tour on how to perform common scenarios
    (e.g. create a user, and then log in); that is, which API calls needs to be made,
    and in what order.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个简明扼要的逐步引导游览，说明如何执行常见场景（例如创建用户，然后登录）；也就是说，需要调用哪些API调用，以及它们的顺序。
- en: Includes an API Specification, which provides technical references of each endpoint—what
    parameters are allowed and in which format.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含API规范，它提供了每个端点的技术参考——允许哪些参数以及它们的格式。
- en: Authoring of the high-level overview and the guided tour falls under the scope
    of a Technical Writer. But what makes a good piece of technical writing is beyond
    the scope of this book; instead, we will focus on how to write a good API specification. Specifically,
    we will be using the OpenAPI API specification language to write our API specification,
    and then use a set of tools called Swagger to generate an interactive browser-based
    API reference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 高级概述和引导游览的编写属于技术作家的范围。但什么是好的技术写作超出了本书的范围；相反，我们将专注于如何编写好的API规范。具体来说，我们将使用OpenAPI
    API规范语言来编写我们的API规范，然后使用一套称为Swagger的工具来生成交互式的基于浏览器的API参考。
- en: 'By following this chapter, you will:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章，您将：
- en: Learn about the **OpenAPI Specification** (**OAS**)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**OpenAPI规范**（**OAS**）
- en: Write your own OpenAPI specification in **YAML**
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**YAML**编写您自己的OpenAPI规范
- en: Use **Swagger UI** to generate web-based API documentation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Swagger UI**生成基于Web的API文档
- en: Overview of OpenAPI and Swagger
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAPI和Swagger概述
- en: 'An **API description language** (or **API description format**) is a standard
    format for describing APIs. For example, the snippet below informs the consumers
    of our API that they need to provide a JSON payload with an `email` and `digest`
    field when calling the `POST /login` endpoint. In return, they can expect our
    API to respond with one of the four listed status codes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**API描述语言**（或**API描述格式**）是描述API的标准格式。例如，下面的片段通知我们的API消费者，在调用`POST /login`端点时，他们需要提供一个包含`email`和`digest`字段的JSON有效负载。作为回报，他们可以期待我们的API以以下四种列出的状态码之一响应：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are several benefits to writing an API specification:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编写API规范有几种好处：
- en: The specification acts as a contract between our platform and the end consumers,
    which may not be limited to just developers, but also other internal APIs as well.
    Having a contract means consumers of our API are able to develop their integrations
    before our API is complete—because we have agreed, through the specification,
    how our API should behave—as long as everyone stays faithful to the API specification,
    the integration will be successful.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该规范充当了我们平台与最终消费者之间的合同，这并不仅限于开发者，还包括其他内部API。拥有合同意味着我们的API消费者能够在我们的API完成之前开发他们的集成——因为我们已经通过规范同意了我们的API应该如何表现——只要每个人都忠于API规范，集成就会成功。
- en: It forces us to design the interface.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使我们设计接口。
- en: We can create mock servers. These mock servers mimic the behavior of the real
    API server, but responds with canned responses instead. We can provide this mock
    server for end consumers before our API is complete, so they'll know how our API
    should respond.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建模拟服务器。这些模拟服务器模仿真实API服务器的行为，但以预定义的响应进行响应。在我们的API完成之前，我们可以为最终消费者提供这个模拟服务器，这样他们就会知道我们的API应该如何响应。
- en: Using open source tools (such as Dredd—[dredd.org](http://dredd.org/en/latest/)),
    we can automatically test our API server to see if it complies with the specification.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源工具（如Dredd—[dredd.org](http://dredd.org/en/latest/)），我们可以自动测试我们的API服务器，以查看它是否遵守规范。
- en: Using tools that integrate with our API server, we can use the specification
    to validate requests and responses automatically, without having to write extra
    validation code.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与我们的API服务器集成的工具，我们可以使用规范自动验证请求和响应，而无需编写额外的验证代码。
- en: Picking an API specification language
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择API规范语言
- en: The preceding example uses a standard called **OpenAPI** (formerly **Swagger**).
    At the time of writing, there are two other popular API specification languages
    out there, namely **RAML** and **API Blueprint**. Before we go any further, it's
    important to note that each language has its own set of limitations in terms of
    how accurately it can describe an existing API, or the comprehensiveness of the
    tooling surrounding it. Out of the three, however, OpenAPI is the most mature
    and has the best community support, and it's what we will be using in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用了一个称为**OpenAPI**（以前称为**Swagger**）的标准。在撰写本文时，还有两种其他流行的API规范语言，即**RAML**和**API
    Blueprint**。在继续之前，重要的是要注意，每种语言都有其自身的一套限制，即它如何准确地描述现有的API，或者围绕它的工具的全面性。然而，在这三者中，OpenAPI是最成熟的，并且拥有最好的社区支持，这就是我们将在本章中使用的规范。
- en: Swagger vs OpenAPI
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger vs OpenAPI
- en: When reading articles online, you'll often hear the terms Swagger and OpenAPI
    used interchangeably. So, before we continue, let's clarify these terms. *Swagger* began
    in 2011 as a set of tools that allow developers to represent API as code, in order
    to automatically generate documentation and client SDKs. Swagger has since undergone
    two major versions (1.0 and 2.0). After the release of Swagger 2.0, the rights
    to Swagger were bought by SmartBear Software, who decided to donate the rights
    of the specification format to the Linux Foundation, under the OpenAPI Initiative.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在线阅读文章时，你经常会听到Swagger和OpenAPI这两个术语被互换使用。因此，在我们继续之前，让我们澄清这些术语。*Swagger*始于2011年，是一套工具，允许开发者将API表示为代码，以便自动生成文档和客户端SDK。Swagger自那时起已经经历了两个主要版本（1.0和2.0）。在Swagger
    2.0发布后，Swagger的权利被SmartBear Software购买，该公司决定将规范格式的权利捐赠给Linux Foundation，在OpenAPI倡议下。
- en: On 1 January 2016, the Swagger specification was renamed to the *OpenAPI Specification* (OAS).
    Since then, a newer version, 3.0.0 of OAS, has been released.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年1月1日，Swagger规范被更名为*OpenAPI规范*（OAS）。从那时起，OAS的一个新版本，3.0.0，已经发布。
- en: OAS 2.0 is identical to Swagger 2.0 apart from the name.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OAS 2.0与Swagger 2.0在名称上相同。
- en: However, although the specification has been renamed to OAS, the tooling around
    the specification is still developed and maintained by SmartBear Software; therefore,
    you may hear developers talk about both Swagger and OpenAPI at the same time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管规范已被重命名为 OAS，但围绕该规范的工具仍然由 SmartBear Software 开发和维护；因此，您可能会同时听到开发者谈论 Swagger
    和 OpenAPI。
- en: In short, OpenAPI is the specification language itself, while Swagger is a set
    of tools that work with and around an OpenAPI specification.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，OpenAPI 是规范语言本身，而 Swagger 是一套与 OpenAPI 规范一起工作和围绕其工作的工具集。
- en: Swagger Toolchain
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger 工具链
- en: 'So let''s examine the Swagger Toolchain in more detail. Swagger is a set of
    developer tools that are useful across the entire API lifecycle, and includes
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更详细地检查 Swagger 工具链。Swagger 是一套在整个 API 生命周期中都有用的开发者工具，包括以下内容：
- en: '**Swagger Editor**: A split-screen editor that allows you to write your specification
    on one side, and provide real-time feedback on the other'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger 编辑器**：一个分屏编辑器，允许您在一侧编写规范，并在另一侧提供实时反馈'
- en: '**Swagger UI**: Generates documentation in HTML format from your specification
    file'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger UI**：从您的规范文件生成 HTML 格式的文档'
- en: '**Swagger Codegen**: Generates Client SDKs in multiple languages, allowing
    developers to easily interact with your API without calling the endpoints directly'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger Codegen**：生成多种语言的客户端 SDK，使开发者能够轻松地与您的 API 交互，而无需直接调用端点'
- en: '**Swagger Inspector**: Allows you to test your endpoints'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger Inspector**：允许您测试您的端点'
- en: Apart from the official tools developed and maintained by SmartBear Software,
    there are also numerous community-contributed packages and frameworks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SmartBear Software 开发和维护的官方工具之外，还有许多社区贡献的包和框架。
- en: Swagger Editor
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger Editor
- en: 'Swagger Editor is like your code editor for specification. It provides real-time
    validation, code auto-completion, code highlighting and a preview of the output
    documentation. Here''s a screenshot of Uber''s API:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 编辑器类似于您的规范代码编辑器。它提供实时验证、代码自动完成、代码高亮和输出文档的预览。以下是 Uber API 的截图：
- en: '![](img/59c03172-1803-4689-841c-78b741f59840.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c03172-1803-4689-841c-78b741f59840.png)'
- en: Swagger UI
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger UI
- en: 'Swagger UI is a self-contained, frontend application that renders an interactive
    documentation from your specification. All you have to do is provide a public
    URL to the OpenAPI specification, and Swagger UI will do the rest. Following is
    a screenshot of the sample Swagger Petstore documentation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 是一个自包含的前端应用程序，它从您的规范中渲染交互式文档。您只需提供 OpenAPI 规范的公开 URL，Swagger UI 就会完成剩余的工作。以下是
    Swagger Petstore 示例文档的截图：
- en: '![](img/a22b63f8-7aeb-40c1-b92d-2c044084b3aa.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a22b63f8-7aeb-40c1-b92d-2c044084b3aa.png)'
- en: 'The interactive documentation also has a Try it now button, which allows you
    to send real requests to the server and view the results, all without leaving
    the documentation page. This streamlines the workflow of our end users as they
    don’t have to open external tools like Postman and/or Paw:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式文档还有一个“现在尝试”按钮，允许您向服务器发送真实请求并查看结果，而无需离开文档页面。这简化了最终用户的流程，因为他们不需要打开像 Postman
    和/或 Paw 这样的外部工具：
- en: '![](img/509f74aa-7a7b-456c-a82a-6a0bd614bac9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/509f74aa-7a7b-456c-a82a-6a0bd614bac9.png)'
- en: You can try out a live demo at [petstore.swagger.io](http://petstore.swagger.io/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [petstore.swagger.io](http://petstore.swagger.io/) 尝试一个实时演示。
- en: Swagger Inspector
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger Inspector
- en: Swagger Inspector is like Postman for Swagger—it allows you to call and validate
    REST, GraphQL, and SOAP APIs. Like Postman, it saves a history of your past queries.
    Furthermore, it can automatically generate a specification from the results returned
    from the inspection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger Inspector 类似于 Postman，它是 Swagger 的一个工具——允许您调用和验证 REST、GraphQL 和 SOAP
    API。像 Postman 一样，它保存了您过去查询的历史记录。此外，它可以从检查结果自动生成规范。
- en: Swagger codegen
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger codegen
- en: Swagger is able to use your API specification to generate server stubs and client
    SDKs. There are many languages/frameworks supported by Swagger Codegen. You may
    use the server stubs as boilerplate for the API you are about to build, or as a
    mock server to showcase how the API should behave. You may also use the generated client
    SDKs as the foundation and build upon it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 能够使用您的 API 规范生成服务器存根和客户端 SDK。Swagger Codegen 支持许多语言/框架。您可以将服务器存根用作您即将构建的
    API 的样板，或用作模拟服务器来展示 API 应该如何表现。您还可以使用生成的客户端 SDK 作为基础并在此基础上构建。
- en: Defining an API specification with OpenAPI
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 定义 API 规范
- en: 'Now that we understand what an API specification and the OpenAPI standard are,
    as well as the tooling provided by Swagger, let''s begin the documentation process
    by writing the specification for our API. We''ll start by creating a file new
    at `src/spec/openapi/hobnob.yaml`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了API规范和OpenAPI标准是什么，以及Swagger提供的工具，让我们开始文档编写过程，为我们的API编写规范。我们将从在`src/spec/openapi/hobnob.yaml`创建一个新文件开始：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Learning YAML
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习YAML
- en: The first thing to know is that an OpenAPI specification must be a valid JSON
    document. The specification also explicitly allows YAML, which is a superset of
    JSON and can be converted to JSON. We will be using YAML because it is more readable
    (and thus writable) by humans, even for non-developers. Furthermore, you can add
    comments inside YAML files, something that's not possible with JSON.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，OpenAPI规范必须是一个有效的JSON文档。规范还明确允许使用YAML，它是JSON的超集，可以转换为JSON。我们将使用YAML，因为它对人类来说更易读（因此也更容易编写），即使是非开发者也是如此。此外，你可以在YAML文件中添加注释，这是JSON无法做到的。
- en: Let's start by learning the basics of YAML. We only need to learn a few basic
    pieces of syntax to write our OpenAPI specification.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先学习YAML的基本知识。我们只需要学习一些基本的语法规则来编写我们的OpenAPI规范。
- en: Like JSON, getting started with the basic syntax for YAML is very simple. All
    YAML documents start with three dashes (`---`) to indicate the start of the file,
    and three periods (`...`) to indicate the end of the file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON一样，开始学习YAML的基本语法非常简单。所有YAML文档都以三个短横线（`---`）开始，以指示文件的开始，以三个点（`...`）结束，以指示文件的结束。
- en: 'Typically, the most common data structures you need to represent in a configuration
    file are key-value pairs and lists. To represent a set of key-value pairs, simply
    write each one on a new line, separated by a colon and space:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在配置文件中需要表示的最常见的数据结构是键值对和列表。要表示一组键值对，只需将每个键值对写在新的行上，用冒号和空格分隔：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Generally, you do not need to use quotes unless you use a special character,
    or need to be explicit about the data type (for example, `10` may be interpreted
    as a number, and `yes` may be interpreted as `true`). For simplicity's and consistency's
    sake, you may want to use double quotes for all your strings, but we won't do
    that here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，除非你使用特殊字符或需要明确数据类型（例如，`10`可能被解释为数字，而`yes`可能被解释为`true`），否则你不需要使用引号。为了简单和一致起见，你可能想为所有的字符串使用双引号，但在这里我们不会这样做。
- en: 'To represent nested objects, simply indent the child object by two spaces:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示嵌套对象，只需将子对象缩进两个空格：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To represent a list, place each item on a new line, preceded by a dash and
    a space:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个列表，将每个项目放在新的一行上，前面加上一个破折号和一个空格：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To conserve newline characters, use the pipe (`|`) character:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省换行符，使用竖线（`|`）字符：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or to break a line of text over multiple lines (to make it easier to read),
    which shouldn''t preserve newlines, use the greater-than character (`>`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了在多行上断开文本行（使其更容易阅读），不应保留换行符，使用大于号（`>`）：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An overview of the root fields
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根字段的概述
- en: Now that we understand the basics of YAML, we're ready to write our specification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了YAML的基本知识，我们准备好编写我们的规范了。
- en: There are a few versions of the OpenAPI Specification available. At the time
    of writing this book, the OpenAPI Specification is at version `3.0.0` and was
    officially released on 26 July 2017\. You may also find many OpenAPI 2.0 specifications
    in the wild as tooling support for 3.0.0 is lacking in many areas.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的OpenAPI规范版本有几个。在撰写本书时，OpenAPI规范是`3.0.0`版本，并于2017年7月26日正式发布。你可能会在野外找到许多OpenAPI
    2.0规范，因为3.0.0在许多领域的工具支持不足。
- en: 'We will use OAS 3.0.0 as it is the latest version. Here, you''ll find an overview
    of all the possible root properties in OAS 3.0.0\. Not all fields are covered,
    and required fields are marked with an asterisk (`*`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OAS 3.0.0，因为它是最新版本。在这里，你可以找到OAS 3.0.0中所有可能的根属性概述。并非所有字段都被涵盖，并且必需字段用星号（`*`）标记：
- en: '`openapi*` (string): This specifies the OpenAPI specification version in use.
    We should specify the semver version; for us, we will use `"3.0.0"`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openapi*` (string): 这指定了正在使用的OpenAPI规范版本。我们应该指定semver版本；对于我们来说，我们将使用`"3.0.0"`。'
- en: '`info*` (object): Metadata about the API.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info*` (object): API的元数据。'
- en: '`version*` (string): The version of the API this specification is written for. **Please
    note that this is the version of the API itself, not the OpenAPI Specification.**'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version*` (string): 为此规范编写的API版本。**请注意，这是API本身的版本，而不是OpenAPI规范。**'
- en: '`title*` (string): The name of your API.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title*` (string): 您API的名称。'
- en: '`description` (string): A short description of your API.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` (string): 您API的简要描述。'
- en: '`contact` (object): Information regarding whom to contact for support.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact` (object): 关于联系支持的信息。'
- en: '`name` (string): The name of the person/department/organization to contact.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` (string): 要联系的个人/部门/组织的名称。'
- en: '`url` (string): A valid URL pointing to a page with contact information.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` (string): 指向包含联系信息的页面的有效URL。'
- en: '`email` (string): A valid email address where inquiries can be sent.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email` (string): 一个有效的电子邮件地址，可以通过它发送询问。'
- en: '`termsOfService` (string): A valid URL pointing to the Terms of Service notice
    for the API.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`termsOfService` (string): 指向API服务条款通知的有效URL。'
- en: '`license` (object): License information of the API.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license` (object): API的许可信息。'
- en: '`name*` (string): Name of the license.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name*` (string): 许可证的名称。'
- en: '`url` (string): A valid URL pointing to the license.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` (string): 指向许可的有效URL。'
- en: '`servers` (array of objects) A list of servers that are serving the API. This
    is an improvement on the OAS 2.0 root fields `host` and `basePath`, as it allows
    for multiple hosts to be specified.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers` (array of objects) 一个提供API的服务器列表。这是对OAS 2.0根字段`host`和`basePath`的改进，因为它允许指定多个主机。'
- en: '`url*` (string): A valid URL to the target host. This may be a relative URL,
    relative from the location at which the OpenAPI specification is being served.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url*` (string): 指向目标主机的有效URL。这可能是一个相对URL，相对于OpenAPI规范被提供的位置。'
- en: '`description` (string): A short description of the host. This is useful for
    distinguishing between different hosts if multiple are specified.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` (string): 主机的简要描述。如果有多个主机被指定，这有助于区分不同的主机。'
- en: '`paths*` (object): All paths and operations (such as endpoints) are exposed
    by the API. The paths object is a dictionary of paths (for example, `/users`)
    and *Path Item Objects*. A Path Item Object is a dictionary of (mostly) HTTP verbs
    (for example, `post`) and *Operation Objects*. The Operation Object is the one
    that defines the behavior of the endpoint, such as what parameters it accepts
    and the type of responses it emits:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths*` (object): API公开的所有路径和操作（例如端点）。路径对象是一个路径（例如，`/users`）和*路径项对象*的字典。路径项对象是一个包含（主要是）HTTP动词（例如，`post`）和*操作对象*的字典。操作对象是定义端点行为的对象，例如它接受哪些参数以及它发出的响应类型：'
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`components` (object): This holds a set of reusable objects to be reused. The
    purpose of components is to minimize duplication within the specification. For
    example, if *multiple* endpoints may return a `401 Unauthorized` error with the
    message `"The Authorization header must be set"`, we can define a component called
    `NoAuthHeaderSet`, and reuse this object in place of the response definition. Components
    can be referenced from other parts of the specification later using JSON references
    (`$ref`).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components` (object): 包含一组可重用对象，可用于重用。组件的目的在于最小化规范内的重复。例如，如果*多个*端点可能返回一个`401
    Unauthorized`错误，错误信息为`"The Authorization header must be set"`，我们可以定义一个名为`NoAuthHeaderSet`的组件，并在响应定义中使用此对象进行重用。组件可以在规范的其他部分稍后使用JSON引用（`$ref`）进行引用。'
- en: In OAS 2.0, the components root field did not exist; instead, the `definitions`,
    `parameters`, and `responses` root fields were used. In OAS 3.0.0, components
    are not limited to data types (or schema), parameters and responses, but also
    examples, request bodies, headers, security schemes, links, and callbacks.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在OAS 2.0中，组件根字段不存在；相反，使用了`definitions`、`parameters`和`responses`根字段。在OAS 3.0.0中，组件不仅限于数据类型（或模式）、参数和响应，还包括示例、请求体、头、安全方案、链接和回调。
- en: '`security` (array of objects): A list of *Security Requirement Objects* that
    are acceptable across the whole API. A Security Requirement Object is a dictionary
    of security schemes that are common across different operations. For example,
    we require that the client provides a valid token on many endpoints; therefore,
    we can define that requirement here, and apply it in a DRY manner within each
    definition. For endpoints that do not require a token, we can override this requirement
    on an individual basis.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security` (array of objects): 一系列在整个API中可接受的*安全需求对象*。安全需求对象是一个包含跨不同操作的安全方案的字典。例如，我们要求客户端在许多端点上提供一个有效的令牌；因此，我们可以在这里定义该要求，并以DRY（Don''t
    Repeat Yourself）的方式在每个定义中应用它。对于不需要令牌的端点，我们可以单独覆盖此要求。'
- en: '`tags` (array of strings): You can group operations using tags by specifying
    a list of strings inside the Operation Object. Tools, such as Swagger UI, may
    use these tags to group related endpoints together. The root `tags` property provides
    metadata (e.g. long description) on those tags.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`（字符串数组）：您可以通过在操作对象内部指定字符串列表来使用标签对操作进行分组。例如，Swagger UI 可能会使用这些标签将相关的端点分组在一起。根
    `tags` 属性提供了有关这些标签的元数据（例如，长描述）。'
- en: '`externalDocs` (object): Additional external documentation.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalDocs`（对象）：额外的外部文档。'
- en: Now that you have a brief overview of the root fields, let's begin composing
    our specification. To ease ourselves into it, we will start by defining the simpler
    fields like `info`, then moving on to endpoints that do not require authentication.
    Once we are more comfortable, we will define security schemes and security requirements
    and add the specification for endpoints that require authentication.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对根字段有了简要的了解，让我们开始编写我们的规范。为了使我们更容易上手，我们将从定义简单的字段 `info` 开始，然后转向不需要身份验证的端点。一旦我们更加熟悉，我们将定义安全方案和安全要求，并添加需要身份验证的端点的规范。
- en: To get started, add the following metadata to `spec/openapi/hobnob.yaml`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请将以下元数据添加到 `spec/openapi/hobnob.yaml`。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Specifying the GET /salt endpoint
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定 GET /salt 端点
- en: 'To ease our way into composing the full API specification, let''s start with
    the simplest endpoint—`GET /salt`. To start off, we will add the `paths` root
    property, specify the path we are defining (`/salt`), and then the operation (`get`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化编写完整的 API 规范的过程，让我们从最简单的端点 `GET /salt` 开始。首先，我们将添加 `paths` 根属性，指定我们定义的路径（`/salt`），然后是操作（`get`）：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Under the `get` property, we will define an *operation object*. The full specification
    for the Operation Object can be found at [github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object).
    For our use cases, we are concerned with the following properties:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get` 属性下，我们将定义一个 *操作对象*。操作对象的完整规范可以在 [github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object)
    找到。对于我们的用例，我们关注以下属性：
- en: '`tags`: This is used to logically group operations when displayed with Swagger
    UI.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：当与 Swagger UI 一起显示时，用于逻辑上分组操作。'
- en: '`summary`: A short summary of what the operation does.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summary`：操作的简要总结。'
- en: '`description`: A more verbose description of the operation, which may include
    nuances that a developer might need to be aware of.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：对操作的更详细描述，可能包括开发者可能需要了解的细微差别。'
- en: '`parameters`: A *parameter object* that describes what parameters are allowed/required,
    and how these parameters should be provided (such as URL parameters, query strings,
    headers, or cookies).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`：一个 *参数对象*，描述了允许/必需的参数，以及这些参数应该如何提供（例如 URL 参数、查询字符串、头部或 cookie）。'
- en: '`requestBody`: A *request body object* that describes the body of the request,
    if any. It describes what types of payloads are allowed (for example, `application/json`,
    `text/plain`), and, if it is an object, what data type and formats each property
    should be.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestBody`：一个 *请求体对象*，描述了请求体（如果有）。它描述了允许的负载类型（例如，`application/json`、`text/plain`），如果它是对象，则每个属性的数据类型和格式应该是什么。'
- en: '`responses`: A *Responses Object* that describes all possible responses this
    endpoint can produce.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responses`：一个 *响应对象*，描述了此端点可以产生的所有可能的响应。'
- en: 'So, let''s start with the simpler fields: `tags`, `summary`, and `description`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从更简单的字段开始：`tags`、`summary` 和 `description`：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Specifying parameters
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定参数
- en: 'Our Get Salt endpoint does not accept any request bodies, but it does require
    a query string parameter called `email`, which must be set to a valid email address.
    Therefore, we must define a `parameters` property, containing a list of *parameter
    objects*. Each Parameter Object can contain the following properties:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Get Salt 端点不接受任何请求体，但它确实需要一个名为 `email` 的查询字符串参数，该参数必须设置为有效的电子邮件地址。因此，我们必须定义一个
    `parameters` 属性，包含一个 *参数对象* 的列表。每个 参数对象 可以包含以下属性：
- en: '`name*` (string): The name of the parameter'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name*`（字符串）：参数的名称'
- en: '`in*` (string): Where the parameter is specified. Possible values are `query`,
    `header`, `path`, or `cookie`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in*`（字符串）：指定参数的位置。可能的值是 `query`、`header`、`path` 或 `cookie`。'
- en: '`required` (boolean): Whether the parameter is required.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`（布尔值）：参数是否必需。'
- en: '`schema` (object): This describes the structure of the parameter:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schema`（对象）：这描述了参数的结构：'
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might have noticed that the OpenAPI syntax for defining schema looks a lot
    like JSON Schema. This is because OpenAPI Specification is actually based on the
    first drafts of the JSON Schema specification.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，OpenAPI定义模式语法看起来很像JSON Schema。这是因为OpenAPI规范实际上是基于JSON Schema规范的第一稿。
- en: Specifying responses
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定响应
- en: 'Next, we need to specify what our endpoint can potentially respond with. This
    is a required field for all operation objects. The responses Object is a map of
    numeric HTTP status codes and a *response object*, which should contain two fields:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们的端点可能响应的内容。这是所有操作对象的一个必需字段。响应对象是一个数字HTTP状态码和响应对象的映射，该响应对象应包含两个字段：
- en: '`description`: A short description of the payload'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：有效负载的简短描述'
- en: '`content` (object): This specifies the valid MIME types (for example, `application/json`, `text/plain`) that
    are acceptable for this endpoint, as well as the expected structure of the payload:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`（对象）：这指定了此端点可接受的有效的MIME类型（例如，`application/json`、`text/plain`），以及有效负载的预期结构：'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To make sure that we haven't forgotten any responses, we can check our request
    handler (`src/handlers/auth/salt/retrieve/index.js`), our middleware, as well
    as our E2E tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们没有忘记任何响应，我们可以检查我们的请求处理器（`src/handlers/auth/salt/retrieve/index.js`）、中间件以及我们的端到端测试。
- en: We have now defined the Get Salt endpoint with the OpenAPI specification language.
    Let's move on to a slightly more complicated endpoint—Create User—and see how
    we can specify payload bodies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用OpenAPI规范语言定义了获取盐端点。让我们继续到一个稍微复杂一点的端点——创建用户——并看看我们如何指定有效负载体。
- en: Specifying the Create User endpoint
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定创建用户端点
- en: 'Using what you''ve just learned, specify a new path, operation, and operation
    object for the Create User endpoint, filling in the `tags`, `summary`, `description,`
    and `responses` properties. You should end up with something like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你刚刚学到的知识，为创建用户端点指定一个新的路径、操作和操作对象，填写`tags`、`summary`、`description`和`responses`属性。你应该得到类似以下内容：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specifying the request body
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定请求体
- en: Our Create User endpoint does not accept any parameters, but it does require
    a JSON payload that conforms to our User schema. Therefore, we should add a new `requestBody` field
    inside our Operation Object to define this requirement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的创建用户端点不接受任何参数，但它确实需要一个符合我们用户模式的JSON有效负载。因此，我们应该在我们的操作对象内部添加一个新的`requestBody`字段来定义这个要求。
- en: 'The value of the `requestBody` field should contain three fields:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestBody`字段的值应包含三个字段：'
- en: '`description`: A short description of the payload.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：有效负载的简短描述。'
- en: '`content`(object): This specifies the valid MIME types (for example, `application/json`, `text/plain`) that
    are acceptable for this endpoint, as well as the expected structure of the payload.
    This structure is defined under the MIME type property, under a sub-property called `schema`,
    and is very similar to the JSON schema syntax, represented as YAML.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`（对象）：这指定了此端点可接受的有效的MIME类型（例如，`application/json`、`text/plain`），以及有效负载的预期结构。此结构在MIME类型属性下定义，在子属性`schema`下，并且与JSON
    schema语法非常相似，表示为YAML。'
- en: '`required` (boolean): This specifies whether the request payload is required:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`（布尔值）：这指定了请求有效负载是否是必需的：'
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Defining common components
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义常见组件
- en: You might have noticed that our specification is not very DRY – we are repeatedly
    specifying common responses like the 500 Internal Error. Therefore, before we
    learn how to specify URL parameters and our security schemes, let's first see
    how we can use the `components` root property to define common entities in a single
    location, and reference it throughout the OpenAPI specification. We will do this
    for our Create User object, as well as all our responses.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们的规范并不是非常DRY（Don't Repeat Yourself，不要重复自己）——我们反复指定了常见的响应，比如500内部错误。因此，在我们学习如何指定URL参数和我们的安全方案之前，让我们首先看看我们如何可以使用`components`根属性在单个位置定义常见实体，并在整个OpenAPI规范中引用它。我们将为此创建用户对象以及所有响应。
- en: 'Let''s start by adding the following `components` section as a root property
    to our specification:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将以下`components`部分作为根属性添加到我们的规范中：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now refer to this Profile schema component anywhere in our specification
    using the reference `''#/components/schemas/Profile''`. In other words, we can
    shorten our definition for the `requestBody` property of our Create User endpoint
    to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用引用`'#/components/schemas/Profile'`在任何我们的规范中引用这个 Profile 架构组件。换句话说，我们可以将我们的
    Create User 端点的 `requestBody` 属性的定义缩短为以下内容：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s go through another example. Currently, our `GET /salt` endpoint can
    respond with a 200 response:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再通过另一个示例。目前，我们的 `GET /salt` 端点可以响应一个 200 响应：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can pull this response out and define it as a component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个响应提取出来并定义为一个组件：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And just like before, we can reference the `SaltRetrieved` response component
    by reference:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们可以通过引用来引用 `SaltRetrieved` 响应组件：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Having gone through two examples, you should now try to pull out as many common
    components as you can. Once you're done, check the code bundle to see our implementation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两个示例之后，你现在应该尝试尽可能多地提取出公共组件。完成后，检查代码包以查看我们的实现。
- en: Specifying the Retrieve User endpoint
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定 Retrieve User 端点
- en: Now that we have learned how to use Components to reduce code duplication, let's
    carry on with specifying the Get User endpoint, and learn how to represent URL
    parameters in OpenAPI.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用组件来减少代码重复，让我们继续指定 Get User 端点，并学习如何在 OpenAPI 中表示 URL 参数。
- en: It turns out that it's very simple—it's just another parameter, just like query
    parameters. The only difference is that we need to use path templating to specify
    where this parameter resides in our URL. For instance, the path would be specified
    as `/users/{userId}` for our Retrieve User endpoint.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明这非常简单——它只是一个参数，就像查询参数一样。唯一的区别是我们需要使用路径模板来指定这个参数在 URL 中的位置。例如，对于我们的 Retrieve
    User 端点，路径将被指定为 `/users/{userId}`。
- en: We also need to define a new Schema object called `UserLimited`, which describes
    a complete User object but without the `digest` field. This is the shape of the
    object we will return in our Retrieve User endpoint. Lastly, we also added a new
    `ErrorNotFound` response to cater for when a user with that ID does not exist.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个新的 Schema 对象，称为 `UserLimited`，它描述了一个完整的用户对象，但不包括 `digest` 字段。这是我们将在
    Retrieve User 端点返回的对象的形状。最后，我们还添加了一个新的 `ErrorNotFound` 响应，以应对不存在该 ID 的用户的情况。
- en: 'The additions made to the schema should resemble the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对架构所做的添加应类似于以下内容：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Specifying the Replace Profile endpoint
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定 Replace Profile 端点
- en: The last thing we will demonstrate is describing the Replace Profile endpoint.
    This endpoint requires the user to be logged in and provides the token in the
    request.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要演示的最后一件事是描述 Replace Profile 端点。这个端点要求用户登录，并在请求中提供令牌。
- en: 'But first, let''s use everything we have learned so far to define the parameters,
    request bodies, and responses for the Replace Profile endpoint:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们利用到目前为止所学的一切来定义 Replace Profile 端点的参数、请求体和响应：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we have defined two new response:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了两个新的响应：
- en: '`Success`, which is simply a `200 Success` response with no payload'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`成功`，这只是一个没有负载的`200 成功`响应'
- en: '`ErrorUnauthorized`, which should be returned if the `Authorization` header
    (containing our JSON Web Token) is not present'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorUnauthorized`，如果 `Authorization` 标头（包含我们的 JSON Web 令牌）不存在，则应该返回'
- en: What's new is the `securitySchemes` we've defined under `components` at the
    root of the OpenAPI object. In OAS, a *security scheme* is a method for our client
    to authenticate themselves. Supported schemes are HTTP authentication, API key,
    OAuth2, and OpenID Connect Discovery. Since we are using the Bearer scheme in
    our HTTP Authorization header to authenticate, we have defined it as such.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是我们在 OpenAPI 对象根部的 `components` 下定义的 `securitySchemes`。在 OAS 中，*安全方案* 是我们的客户端进行身份验证的方法。支持的方案包括
    HTTP 身份验证、API 密钥、OAuth2 和 OpenID Connect Discovery。由于我们使用 Bearer 方案在我们的 HTTP 授权头中进行身份验证，所以我们将其定义为这样。
- en: In our Operation Object, we have also included a `security` property that states
    that this endpoint needs to be authenticated using the security scheme we've defined
    called `token`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Operation 对象中，我们还包含了一个 `security` 属性，表明这个端点需要使用我们定义的安全方案进行身份验证，该方案称为 `token`。
- en: Specifying the rest of the endpoints
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定其余的端点
- en: What we've covered so far should have provided enough information for you to
    complete the OpenAPI specification for the rest of the endpoints. Do attempt to
    complete it and refer back to the code bundle to check it against our implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所涵盖的内容应该已经提供了足够的信息，以便您完成其余端点的 OpenAPI 规范。请尝试完成它，并参考代码包以检查我们的实现。
- en: Generating documentation with Swagger UI
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger UI 生成文档
- en: We now have a valid OpenAPI specification, which we can use to generate web-based
    API documentation using Swagger UI.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个有效的 OpenAPI 规范，我们可以使用 Swagger UI 生成基于 Web 的 API 文档。
- en: Adding the Swagger UI to our repository
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Swagger UI 添加到我们的仓库中
- en: The Swagger UI source files are located in the `dist/` directory of the official
    repository. The official way of generating documentation UI for our own specification
    is to download the Swagger UI source files from [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases)
    and statically serve the page at `dist/index.html`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 源文件位于官方仓库的 `dist/` 目录中。为我们自己的规范生成文档 UI 的官方方法是下载 Swagger UI 源文件从 [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases)，并在
    `dist/index.html` 静态地提供页面。
- en: 'However, it''ll more preferable to have the source code of the web UI in the
    same repository as our API. A naive approach would be to download the latest source
    files for Swagger UI from [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases),
    unpack the contents, and copy the contents of the `dist/` directory into a `docs/`
    directory inside our repository. However, this requires us to manually update
    the contents of the `docs/` directory each time there''s an update on Swagger
    UI; obviously, that''s not ideal. Luckily, there''s a cleaner way of achieving
    the same thing using **Git submodules**. Run the following at our project''s root
    directory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 Web UI 的源代码放在与我们的 API 相同的仓库中会更受欢迎。一个简单的方法是从 [github.com/swagger-api/swagger-ui/releases](https://github.com/swagger-api/swagger-ui/releases)
    下载 Swagger UI 的最新源文件，解压内容，并将 `dist/` 目录的内容复制到我们仓库内的 `docs/` 目录中。然而，这需要我们每次 Swagger
    UI 更新时手动更新 `docs/` 目录的内容；显然，这不是理想的做法。幸运的是，使用 **Git 子模块** 可以更干净地实现相同的功能。在我们的项目根目录中运行以下命令：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Locally, this will download the entire contents of the Swagger UI repository
    and save it into the `docs/` directory at the root of your project. However, in
    Git, only the `.gitmodules` file and a small `docs` file is tracked:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本地情况下，这将下载 Swagger UI 仓库的全部内容，并将其保存到项目根目录下的 `docs/` 目录中。然而，在 Git 中，只有 `.gitmodules`
    文件和一个小型的 `docs` 文件被跟踪：
- en: '![](img/3b2c2b0f-50b4-4982-95a8-837bcf9f2f52.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b2c2b0f-50b4-4982-95a8-837bcf9f2f52.png)'
- en: 'This keeps our Git repository clean, and tracks only code which is our own
    (and not third-party code). When we want to update to the latest version of Swagger
    UI, all we have to do is update the Git `submodule`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的 Git 仓库保持清洁，并仅跟踪我们的代码（而不是第三方代码）。当我们想要更新到 Swagger UI 的最新版本时，我们只需要更新 Git
    `submodule`：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can add the update script as an npm script to make it easier to remember:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将更新脚本作为 npm 脚本添加，以便更容易记住：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using our specification in the Swagger UI
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的规范在 Swagger UI 中
- en: Now that we have added the Swagger UI into our repository, the next task is
    to write a script to serve it on a web server. Since these are simply static files
    with no backend involvement, any web server would be sufficient. Here, we will
    use the `http-server` package.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Swagger UI 添加到我们的仓库中，下一个任务是编写一个脚本来在 Web 服务器上提供它。由于这些只是没有后端参与的静态文件，任何
    Web 服务器都足够了。在这里，我们将使用 `http-server` 包。
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By default, the `http-server` package uses the port 8080, which we are already
    using for our API. Therefore, we must use the `-p` flag to specify an alternate
    port. However, we don''t want to hard-code this value into our NPM script; instead,
    we want to take it from our environment variable `SWAGGER_UI_PORT`. To achieve
    this, we need to create a new Bash script at `scripts/swagger-ui/serve.sh` with
    the following content:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`http-server` 包使用端口 8080，我们已经在我们的 API 中使用了这个端口。因此，我们必须使用 `-p` 标志来指定一个备用端口。然而，我们不想将此值硬编码到我们的
    NPM 脚本中；相反，我们希望从环境变量 `SWAGGER_UI_PORT` 中获取它。为了实现这一点，我们需要在 `scripts/swagger-ui/serve.sh`
    创建一个新的 Bash 脚本，内容如下：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember to make the script executable by running `chmod +x scripts/swagger-ui/serve.sh`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记得通过运行 `chmod +x scripts/swagger-ui/serve.sh` 使脚本可执行。
- en: 'Then, inside `.env` and `.env.example`, define the following environment variables:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `.env` 和 `.env.example` 中定义以下环境变量：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And add a new NPM script to serve our docs:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个新的NPM脚本来提供我们的文档：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will download or update the Swagger UI source code and serve the site
    from the `docs/dist/` directory. Now, navigate to `http://127.0.0.1:8000` from
    your browser and you should see a page like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载或更新Swagger UI源代码，并从`docs/dist/`目录提供网站。现在，从您的浏览器导航到`http://127.0.0.1:8000`，你应该看到一个像这样的页面：
- en: '![](img/cf7609d2-d2e7-4d03-91c0-d2c354186686.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf7609d2-d2e7-4d03-91c0-d2c354186686.png)'
- en: 'By default, `dist/index.html` uses a demo specification available at [petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json),
    which is what is shown here. To make Swagger UI display documentation for our
    own API, we need to do the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`dist/index.html`使用在[petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json)可用的演示规范，这就是这里显示的内容。为了使Swagger
    UI显示我们自己的API的文档，我们需要做以下操作：
- en: Expose the `hobnob.yaml` file in a publicly-accessible location.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公开可访问的位置公开`hobnob.yaml`文件。
- en: Write a script to replace the demo URL with our own.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个脚本，将演示URL替换为我们自己的。
- en: Exposing swagger.yaml from our API
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的API公开swagger.yaml
- en: 'Exposing the `hobnob.yaml` file is as simple as adding a new endpoint to our
    API. However, the specification file is located at `spec/openapi/hobnob.yaml`,
    which is outside the `dist/` directory of our application. Therefore, first, we
    should modify our serve script to also copy the OpenAPI specification to the root
    of the `dist/` directory after the application has been built:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 公开`hobnob.yaml`文件就像在我们的API中添加一个新的端点一样简单。然而，规范文件位于`spec/openapi/hobnob.yaml`，这位于我们应用程序的`dist/`目录之外。因此，首先，我们应该修改我们的serve脚本，在应用程序构建后，将OpenAPI规范复制到`dist/`目录的根目录：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, inside `src/index.js`, we need to add a new endpoint to retrieve and serve
    that same `openapi.yaml`. Add the following to `src/index.js`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`src/index.js`内部，我们需要添加一个新的端点来检索和提供相同的`openapi.yaml`。将以下内容添加到`src/index.js`。
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, whilst running the `dev:serve` script, open your browser to `http://127.0.0.1:8080/openapi.yaml`.
    You should see the OpenAPI specification displayed on the screen!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行`dev:serve`脚本的同时，打开您的浏览器到`http://127.0.0.1:8080/openapi.yaml`。你应该在屏幕上看到OpenAPI规范。
- en: Enabling CORS
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用CORS
- en: In theory, if we go back to our Swagger UI page (at `127.0.0.1:8000`) and paste
    the URL `http://localhost:8000/openapi.yaml` into the input bar, it should load
    the page with our own API specification. However, the page shows an error about **Cross-Origin
    Resource Sharing** (**CORS**).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果我们回到我们的Swagger UI页面（在`127.0.0.1:8000`），并将URL `http://localhost:8000/openapi.yaml`粘贴到输入栏中，它应该加载带有我们自己的API规范的页面。然而，页面显示了一个关于**跨源资源共享**（**CORS**）的错误。
- en: '![](img/c5d4fa4d-b533-4bc5-b9e9-7a4fdcaa65aa.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5d4fa4d-b533-4bc5-b9e9-7a4fdcaa65aa.png)'
- en: Same-origin policy
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同源策略
- en: For security reasons and in order to protect end users, most browsers enforce
    the **same-origin policy**, which means that the browser will prevent scripts
    loaded from one origin (for example, `http://127.0.0.1:8000`) from making calls
    to a server of a different origin (for example, `http://localhost:8080`). To demonstrate
    why the same-origin policy is important, take a look at the following example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因以及为了保护最终用户，大多数浏览器强制执行**同源策略**，这意味着浏览器将阻止从同一来源（例如，`http://127.0.0.1:8000`）加载的脚本调用不同来源的服务器（例如，`http://localhost:8080`）。为了说明同源策略的重要性，请看以下示例。
- en: 'Let''s suppose you are logged in to your online banking site, `personal.bank.io`.
    Then, you open a malicious site, `malicious.io`, which runs the following script
    inside `malicious.io`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你登录到了你的在线银行网站，`personal.bank.io`。然后，你打开一个恶意网站，`malicious.io`，该网站在`malicious.io`内部运行以下脚本：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the same-origin policy was not in place and this request was allowed to proceed,
    then you would have lost a lot of money. Note that this is a variation on the **Cross-Site
    Request Forgery** (**CSRF**) attack we analyzed earlier.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有同源策略，并且这个请求被允许继续，那么你可能会损失很多钱。注意，这是一个我们之前分析过的**跨站请求伪造**（**CSRF**）攻击的变体。
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）
- en: However, the same-origin policy also limits legitimate use cases just like our
    own. Therefore, the **World Wide Web Consortium** (**W3C**) came up with the **Cross-Origin
    Resource Sharing** (**CORS**) specification to deal with this. The CORS specification
    outlines the mechanism whereby browsers and servers can communicate with each
    other, through a set of HTTP headers, in order to determine which cross-origin
    requests are allowed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相同的源策略也限制了像我们自己的合法用例。因此，**万维网联盟**（**W3C**）提出了**跨源资源共享**（**CORS**）规范来解决这个问题。CORS
    规范概述了浏览器和服务器通过一系列 HTTP 头部相互通信的机制，以确定哪些跨源请求是被允许的。
- en: You can find the full specification at [w3.org/TR/cors/](https://www.w3.org/TR/cors/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [w3.org/TR/cors/](https://www.w3.org/TR/cors/) 找到完整的规范。
- en: 'CORS requires support from both the client (the browser) and the server. Almost
    all modern browsers support CORS:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 需要客户端（浏览器）和服务器双方的支持。几乎所有的现代浏览器都支持 CORS：
- en: '![](img/bbb0dc7a-2570-4165-885e-b33bfe989ecf.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbb0dc7a-2570-4165-885e-b33bfe989ecf.png)'
- en: You can explore more detailed browser support for CORS at [caniuse.com/#feat=cors](https://caniuse.com/#feat=cors).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [caniuse.com/#feat=cors](https://caniuse.com/#feat=cors) 探索更多关于 CORS 的浏览器支持详情。
- en: 'Therefore, the only thing we need to do is set up our Express server to enable
    CORS. To make things easy, there''s a really handy site, [enable-cors.org](https://enable-cors.org/),
    that provides sample code of how to enable CORS for your specific server. We can
    find the instruction for Express at [enable-cors.org/server_expressjs.html](https://enable-cors.org/server_expressjs.html).
    All we need to do is add the following middleware before our other middlewares:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们唯一需要做的是设置我们的 Express 服务器以启用 CORS。为了简化操作，有一个非常方便的网站 [enable-cors.org](https://enable-cors.org/)，它提供了如何为您的特定服务器启用
    CORS 的示例代码。我们可以在 [enable-cors.org/server_expressjs.html](https://enable-cors.org/server_expressjs.html)
    找到 Express 的说明。我们只需要在我们的其他中间件之前添加以下中间件：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Access-Control-Allow-Origin` header specifies requests from which origins
    are allowed to make cross-site requests. Here, we are using the glob wildcard
    `'*'` to allow cross-site requests from all origins.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Origin` 头部指定了哪些来源可以发起跨站请求。在这里，我们使用全局通配符 `''*''` 允许所有来源发起跨站请求。'
- en: 'If we paste in their sample code into `src/index.js`, reload our server, and
    also reload the Swagger UI documentation page, the CORS issue should be resolved
    and we should see details about our API displayed on-screen:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将他们的示例代码粘贴到 `src/index.js` 中，重新加载我们的服务器，并重新加载 Swagger UI 文档页面，CORS 问题应该得到解决，我们应该在屏幕上看到我们的
    API 的详细信息：
- en: '![](img/8d3a65e2-5c57-4e80-b64f-ba1303cf1a34.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d3a65e2-5c57-4e80-b64f-ba1303cf1a34.png)'
- en: However, allowing CORS requests for all origins is the same as disregarding
    the same-origin policy set by browsers, which, as we've demonstrated, is an important
    policy to keep. Therefore, if possible, we should specify a whitelist of origins
    that are allowed to make CORS requests. At the moment, this is only the Swagger
    UI documentation site.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许所有来源发起 CORS 请求等同于忽略了浏览器设置的相同源策略，正如我们所展示的，这是一个重要的策略需要保留。因此，如果可能的话，我们应该指定一个允许发起
    CORS 请求的来源白名单。目前，这仅限于 Swagger UI 文档网站。
- en: 'Therefore, we can update our code to whitelist the documentation site''s origin:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以更新我们的代码，将文档网站的来源添加到白名单中：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, when we deploy our application and make our documentation publically
    available, we know that the docs would be served as a publicly-accessible URL,
    and not at `127.0.0.1:8000`. Therefore, it makes little sense for us to hard-code
    the origin into the code. Instead, consistent with our approach so far, we should
    define the origin as a set of environment variables, use those variables within
    our code, and update our code to use these variables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们部署我们的应用程序并使我们的文档公开可用时，我们知道文档将以公开可访问的 URL 提供服务，而不是在 `127.0.0.1:8000`。因此，将来源硬编码到代码中几乎没有意义。相反，遵循我们迄今为止的方法，我们应该将来源定义为一系列环境变量，在代码中使用这些变量，并更新我们的代码以使用这些变量。
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save and restart your API server, and our Swagger UI documentation should still
    work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并重启您的 API 服务器，我们的 Swagger UI 文档应该仍然可以工作。
- en: Final touches
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的润色
- en: One last issue remains—when the documentation page first loads, it still defaults
    to using the demo [petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json)
    URL. This is not good for user experience as the user must manually paste in the
    URL of the specification they are interested in.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题仍然存在——当文档页面首次加载时，它仍然默认使用演示 [petstore.swagger.io/v2/swagger.json](http://petstore.swagger.io/v2/swagger.json)
    URL。这对用户体验来说并不好，因为用户必须手动粘贴他们感兴趣的规范URL。
- en: Ideally, our page should load the correct specification on the first load, and
    there should be no top bar for our visitors to load another API's specification.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们的页面应在首次加载时加载正确的规范，并且不应有顶部栏供访客加载另一个API的规范。
- en: Replacing the specification URL
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换规范URL
- en: To replace the demo URL, we are going to use a Bash script that will use environment variables
    to compose the URL of our `openapi.yaml`, and then substitute it in using `sed`.
    However, the `SERVER_*` environment variables we have set are internal, and won't
    be valid for our clients. Therefore, we need to add three more environment variables
    to hold the external URL of our API server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换演示URL，我们将使用一个Bash脚本，该脚本将使用环境变量来组合我们的 `openapi.yaml` 的URL，然后使用 `sed` 替换它。然而，我们设置的
    `SERVER_*` 环境变量是内部的，并且对客户端无效。因此，我们需要添加三个额外的环境变量来保存我们的API服务器的外部URL。
- en: 'In `envs/.env` and `envs/.env.example`, add the following three environment
    variables:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `envs/.env` 和 `envs/.env.example` 中添加以下三个环境变量：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create a new file at `scripts/swagger-ui/format.sh` with execute permissions and
    paste in the following script:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `scripts/swagger-ui/format.sh` 中创建一个新的文件，并赋予执行权限，然后粘贴以下脚本：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, also add a new NPM script to call our the `format.sh` script:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，也添加一个新的NPM脚本来调用 `format.sh` 脚本：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We must also update our `docs:update` script in order to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更新我们的 `docs:update` 脚本，以便：
- en: Reset any changes made in the Git submodules.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置在Git子模块中做出的任何更改。
- en: Pull the latest Swagger UI repository.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取最新的Swagger UI仓库。
- en: 'Run `docs:format` to replace the URL:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docs:format` 来替换URL：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, run `yarn run docs:update` and then reload our Swagger UI page, it'll default
    to using our API specification instead of the demo specification.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `yarn run docs:update` 然后重新加载我们的Swagger UI页面，它将默认使用我们的API规范而不是演示规范。
- en: Removing the header
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除标题
- en: Last but not least, we need to remove the header from Swagger UI. The header
    has a CSS class of `topbar`. Therefore, to remove the header from our page, we
    can simply inject the following CSS into the header of our page.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要从Swagger UI中移除标题。标题有一个CSS类名为 `topbar`。因此，为了从我们的页面中移除标题，我们可以在页面的标题中注入以下CSS。
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To do that, we will search for the `</head>` closing tag within `docs/dist/index.html`,
    and insert a newline above it with our own style tag. These steps can be achieved
    with one simple `sed` script. Add it at the end of `scripts/swagger-ui/format.sh`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将在 `docs/dist/index.html` 中搜索 `</head>` 关闭标签，并在其上方插入一个带有我们自己的样式标签的新换行符。这些步骤可以通过一个简单的
    `sed` 脚本来实现。将其添加到 `scripts/swagger-ui/format.sh` 的末尾：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Run `yarn run docs:update && docs:serve` once more. Now, our page will not display
    the header any more!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `yarn run docs:update && docs:serve`。现在，我们的页面将不再显示标题！
- en: Once you're happy with the changes, commit them and merge it back to the `dev`
    and `master` branch.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对更改满意，提交它们并将它们合并回 `dev` 和 `master` 分支。
- en: Deployment
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: Lastly, let's go into our remote server and deploy our documentation site. We
    do this by pulling in our changes and installing the dependencies.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们进入我们的远程服务器并部署我们的文档站点。我们通过拉取更改并安装依赖项来完成此操作。
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we''ll also need to generate a new set of keys and set the `SWAGGER_UI_*` environment
    variables inside the `.env` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要生成一组新的密钥，并在 `.env` 文件中设置 `SWAGGER_UI_*` 环境变量：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, run the `docs:update` script to generate the static files which would
    be served by NGINX. To give NGINX access to these files, we should also update
    the owner and group of the `docs` directory to `nginx`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行 `docs:update` 脚本来生成将被NGINX提供的静态文件。为了使NGINX能够访问这些文件，我们还应该更新 `docs` 目录的所有者和组为
    `nginx`：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, restart the API server:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新启动API服务器：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After this, add a new virtual host definition at `/etc/nginx/sites-available/docs.hobnob.social`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，在 `/etc/nginx/sites-available/docs.hobnob.social` 中添加一个新的虚拟主机定义：
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will simply ask NGINX to serve the static files at `/home/hobnob/projects/hobnob/docs/dist`.
    Then, to enable this `server` block, link it to the `/etc/nginx/sites-enabled/`
    directory and restart NGINX.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地要求NGINX在 `/home/hobnob/projects/hobnob/docs/dist` 目录下提供静态文件。然后，为了启用这个 `server`
    块，将其链接到 `/etc/nginx/sites-enabled/` 目录，并重新启动NGINX。
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, go to the DigitalOcean administrative panel and add an `A` record for
    `docs.hobnob.social`, pointing to our server:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前往DigitalOcean管理面板，为 `docs.hobnob.social` 添加一个指向我们服务器的 `A` 记录：
- en: '![](img/ba0bf50c-e7e7-466c-8931-8269717ef08f.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba0bf50c-e7e7-466c-8931-8269717ef08f.png)'
- en: Now, you should be able to see our documentation at `docs.hobnob.social`!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够看到我们的文档在 `docs.hobnob.social` 上！
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the OpenAPI specification format to document our API
    and used Swagger UI to transfer that specification into a user-friendly web page.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了OpenAPI规范格式来记录我们的API，并使用Swagger UI将规范转换为用户友好的网页。
- en: This concludes the work we need to do for our back-end code. In the next chapter,
    we will build the front-end user interface that will interact with our API.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们需要为后端代码所做的所有工作。在下一章中，我们将构建与我们的API交互的前端用户界面。
