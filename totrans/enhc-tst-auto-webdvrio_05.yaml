- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Alter Egos – The ClickAdv Wrapper
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个自我 – 点击包装器
- en: In this and the next few chapters, we will introduce the concept of adding wrappers
    for the`.click()`, `.select()`, and `.setValue()` intrinsic methods. These wrappers
    allow us to add more functionality to these methods to make the framework more
    robust and less likely to fail during a test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的几章中，我们将介绍为`.click()`、`.select()`和`.setValue()`内置方法添加包装器的概念。这些包装器使我们能够向这些方法添加更多功能，从而使框架更加健壮，减少在测试过程中出现故障的可能性。
- en: Wrappers are the easiest way to extend functionality throughout the test suite,
    eliminating the need to repeatedly add code in the form of multiple test scripts.
    Sometimes when testing, the page loads slowly and our elements take longer to
    load. Sometimes, the page is updated due to **Asynchronous JavaScript and XML**
    (**AJAX**) and the element we found is now stale and must be found again. Our
    results, shown in both the console window and Allure, should be detailed enough
    to indicate what is occurring. Wrappers allow us to start handling all that information
    efficiently, including scrolling an element into view for screen captures, looking
    for similar replacement objects to reduce maintenance, and burning time during
    page builds so that elements have time to appear without resorting to slower hardcoded
    wait methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器是扩展测试套件功能的最简单方法，消除了重复添加代码（以多个测试脚本的形式）的需要。有时在测试时，页面加载缓慢，我们的元素需要更长的时间才能加载。有时，页面由于**异步JavaScript和XML**（**AJAX**）而更新，我们找到的元素现在已过时，必须再次找到。我们在控制台窗口和Allure中显示的结果应该足够详细，以指示正在发生什么。包装器使我们能够高效地处理所有这些信息，包括滚动元素到视图中进行屏幕截图，寻找类似的替换对象以减少维护，以及在页面构建期间节省时间，以便元素有时间出现，而不必求助于较慢的硬编码等待方法。
- en: 'There are three ways that we will explore for injecting superpowers into our
    framework:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索三种方法来为我们的框架注入超级力量：
- en: Helper commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助命令
- en: Browser commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器命令
- en: Element commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素命令
- en: We will first start adding a `helpers` file along with its prerequisites.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开始添加一个`helpers`文件及其先决条件。
- en: Adding a helpers file
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个辅助文件
- en: 'We begin by preparing our helper commands, which require the `utility-types`
    package in order to support optional parameters in TypeScript. This package is
    installed with the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先准备我们的辅助命令，这些命令需要`utility-types`包来支持TypeScript中的可选参数。此包可以通过以下命令安装：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will next add a `\helpers` folder that contains a `helpers.ts` file module.
    This contains several methods for resolving issues in the framework. This is where
    we will store the majority of our custom supporting code for the framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将添加一个包含`helpers.ts`文件模块的`\helpers`文件夹。这个模块包含解决框架中问题的几个方法。这是我们存储框架大部分自定义支持代码的地方。
- en: 'To create a helpers file in a WebdriverIO project written in TypeScript, we
    need to do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用TypeScript编写的WebdriverIO项目中创建一个辅助文件，我们需要执行以下操作：
- en: Create a new directory in our project to store our helper functions. This directory
    will be called `helpers`, located within our `src` directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中创建一个新的目录来存储我们的辅助函数。这个目录将被称为`helpers`，位于我们的`src`目录中。
- en: Within the `helpers` directory, create a new TypeScript file for our helper
    functions. Let’s call this file `helpers.ts`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`helpers`目录中，为我们的辅助函数创建一个新的TypeScript文件。让我们称这个文件为`helpers.ts`。
- en: 'At the top of the `helpers.ts` file, we need to import the necessary types
    and functions to support file paths, global objects, and Allure reports. Some
    of these will come into play in future chapters:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`helpers.ts`文件的顶部，我们需要导入支持文件路径、全局对象和Allure报告的必要类型和函数。其中一些将在未来的章节中发挥作用：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Within the `helpers.ts` file, we need to define our helper functions. The structure
    of the file will include the public method wrappers such as `click()`, `pageSync()`,
    and `assert()`. It will also contain private supporting methods for finding and
    replacing data tokens, and `getElementType()` to determine how to handle errors
    by class:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`helpers.ts`文件中，我们需要定义我们的辅助函数。文件的结构将包括公共方法包装器，如`click()`、`pageSync()`和`assert()`。它还将包含用于查找和替换数据标记的私有支持方法，以及`getElementType()`来确定如何通过类处理错误：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the files where we want to use the helper functions, we import the functions
    from the `helpers.ts` file as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们想要使用辅助函数的文件中，我们按照以下方式从`helpers.ts`文件中导入函数：
- en: '[PRE3]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is just one example of how we can create and use helper functions in a
    WebdriverIO project written in TypeScript. We can define as many helper functions
    as we need in the `helpers.ts` file and import them into our test code as and
    when required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们如何在用TypeScript编写的WebdriverIO项目中创建和使用辅助函数的一个例子。我们可以在`helpers.ts`文件中定义我们需要的任何辅助函数，并在需要时将它们导入到测试代码中。
- en: 'Before we get to the `click()` method, let’s begin with a wrapper of `console.log`
    so we can customize the detail. If we happen to call it with a string such as
    `is blank` or `empty`, or a `null` variable, it does not need to print anything.
    But if anything other than a string or number is passed, such as a promise or
    an object, it should output a warning without failing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达`click()`方法之前，让我们从`console.log`的包装器开始，这样我们就可以自定义详细信息。如果我们碰巧用`is blank`或`empty`或`null`变量等字符串调用它，它不需要打印任何内容。但如果传递了除字符串或数字之外的内容，例如一个承诺或一个对象，它应该输出一个警告而不会失败：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice there is some extra spacing when the error is output to the console.
    This is intentional. We will be making our output visually helpful with spacing
    and color later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当错误输出到控制台时有一些额外的间距。这是故意的。我们将在稍后通过间距和颜色使我们的输出更直观。
- en: 'To utilize the helpers, we add the following import line to our test files:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用辅助工具，我们在测试文件中添加以下导入行：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To call the method, we use this statement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用该方法，我们使用以下语句：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the method is called with a null string, it does not output anything to
    the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法被调用时传递了一个空字符串，它不会在控制台输出任何内容：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If anything other than a string or number is passed then the object and a trace
    is output, something like the following commonly occurs, where a promise object
    is returned instead of a string due to a missing `await` keyword:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的不是字符串或数字，那么会输出对象和跟踪信息，以下情况通常会发生，由于缺少`await`关键字，返回了一个承诺对象而不是字符串：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When a problematic element is passed to the `helper.log` wrapper, the second
    line of code, `UserContext`, will identify where the actual error occurred. Our
    debugging is now starting to look a little bit better.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有问题的元素传递给`helper.log`包装器时，第二行代码`UserContext`将确定实际错误发生的位置。我们的调试现在开始看起来好一些。
- en: Let’s next identify and resolve a potential problem in the `.click` method of
    the `login.page.ts` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来识别并解决`login.page.ts`文件中`.click`方法的一个潜在问题。
- en: The “Hello, World!” of test automation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化的“Hello, World!”
- en: 'The test-automation equivalent of `Hello, World!` is usually a test that checks
    for the presence of a simple element on a web page, such as a heading or a paragraph
    of text. This can involve writing a test that does the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化的“Hello, World!”通常是一个检查网页上简单元素存在性的测试，例如标题或一段文本。这可能涉及编写以下操作的测试：
- en: Navigates to a web page
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到一个网页
- en: Locates an element on the page using an XPath or CSS selector method
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XPath或CSS选择器方法在页面上定位一个元素
- en: Verifies that the element is present and displayed on the page
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证元素是否在页面上存在并显示
- en: 'In our first example, we have the following five simple steps to perform a
    login:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们有以下五个简单的步骤来执行登录：
- en: Navigate to a simulated login screen.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到一个模拟的登录界面。
- en: Enter the username.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名。
- en: Enter the password credentials.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入密码凭据。
- en: Click the login button.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击登录按钮。
- en: Validate that a message appears, indicating the login was successful.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否出现一条消息，表明登录成功。
- en: 'An example can be found in the `pageObjects\login.page.ts` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以在`pageObjects\login.page.ts`文件中找到：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have already resolved errors that can arise from lines of code executing
    out of order by using the `await` statement. However, element locators may become
    stale over time as developers change the pages we are automating. For example,
    imagine the class of the login button was initially a `button` class:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用`await`语句解决了由于代码执行顺序错误可能出现的错误。然而，随着开发者更改我们正在自动化的页面，元素定位器可能会随着时间的推移而变得过时。例如，想象一下登录按钮的类最初是一个`button`类：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But in the next release, it was changed to an anchor link class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但在下一个版本中，它被更改为一个锚链接类：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then the `.click` method will throw the following error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`.click`方法将抛出以下错误：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could surround the click with a `try`/`catch` method to capture exceptions
    and get more detail about what exactly caused an error to be thrown. In this example,
    if the click method was successful, we output the successful event. However, if
    the element did not exist, was covered by another element, or otherwise could
    not be clicked, we output the `captured` error detail and send it to our console:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在点击周围使用 `try`/`catch` 方法来捕获异常，并获取更多关于确切错误原因的详细信息。在这个例子中，如果点击方法成功，我们输出成功的事件。然而，如果元素不存在，被另一个元素覆盖，或者以其他方式无法点击，我们输出
    `captured` 错误细节并将其发送到我们的控制台：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We would like to have this for every element, but we do not want to have to
    add this code repeatedly in all of our test scripts. Fortunately, with wrappers,
    there is a better way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个元素都有这样的功能，但又不希望在我们所有的测试脚本中重复添加此代码。幸运的是，有了包装器，有更好的方法。
- en: ES6 helper modules versus overriding intrinsic methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 辅助模块与覆盖内建方法
- en: 'There are multiple ways to achieve this goal. One way to do this would be to
    completely override the intrinsic actions of the `click()` method in every call.
    Alternatively, we could create our own custom method with its own unique naming
    convention. Lastly, we can create our own function that takes the object as a
    parameter and performs additional functionality. Here is what those three approaches
    might look like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这个目标。一种方法是在每次调用中完全覆盖 `click()` 方法的内建行为。另一种方法是创建我们自己的自定义方法，并使用其独特的命名约定。最后，我们可以创建一个自己的函数，该函数接受对象作为参数并执行额外的功能。以下是这三种方法可能的样子：
- en: 'We could override all intrinsic `click()` methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以覆盖所有的内建 `click()` 方法：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We could add a custom method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个自定义方法：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or create a custom function in our `Helpers` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在我们的 `Helpers` 文件中创建一个自定义函数：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The approach you use is up to you. But the key is to pick one and stick with
    it consistently, rather than having a mishmash of different approaches. Each one
    has its own advantages worth considering. Let us look at the pros and cons of
    the first two approaches.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的方法由你决定。但关键是选择一个并始终如一地坚持，而不是使用不同方法的混合。每种方法都有其独特的优点值得考虑。让我们看看前两种方法的优缺点。
- en: Overriding intrinsic element methods
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖内建元素方法
- en: 'One way we could enhance the `click()` method is to completely override the
    intrinsic element methods from the `ts.config.json` file, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强 `click()` 方法的一种方式是完全覆盖来自 `ts.config.json` 文件的内建元素方法，如下所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command will encapsulate features such as checking the object validity,
    setting the frame, setting the framework to somewhere, and skipping additional
    methods if called when the element does not exist. The way we do this is with
    sanity testing. For example, we will attempt to click on a nonexistent button
    called `btnBogus` and see how the rest of the script executes. Here is an object
    description of the bogus button:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将封装诸如检查对象有效性、设置框架、将框架设置到某个位置以及当元素不存在时跳过额外方法等功能。我们通过健全性测试来完成这项工作。例如，我们将尝试点击一个不存在的按钮
    `btnBogus` 并查看脚本的其他部分如何执行。以下是这个虚假按钮的对象描述：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this approach, the signature stays the same and all our test scripts are
    enhanced:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，签名保持不变，并且我们所有的测试脚本都得到了增强：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The custom `click()` method can add more detail as to what is happening:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的 `click()` 方法可以添加更多关于正在发生什么的细节：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This approach efficiently adds enhanced functionality to the `click()` method
    of every element in the entire suite of tests. But this is also a drawback – an
    error in this method could break everywhere the `click()` method is used. There
    is no easy way to revert a specific line in a test script to the original intrinsic
    method to see whether the error caused the overridden code. We can only turn it
    all on or turn it all off.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效地为整个测试套件中每个元素的 `click()` 方法添加了增强功能。但这也是一个缺点——这个方法中的错误可能会在 `click()` 方法被使用的任何地方造成破坏。没有简单的方法可以将测试脚本中的特定行恢复到原始的内建方法，以查看错误是否是由覆盖的代码引起的。我们只能全部开启或全部关闭。
- en: There must be another way!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 必须还有另一种方法！
- en: Adding a custom element method
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义元素方法
- en: 'We can add a custom element command to the browser object. In this case, let
    us call it `clickAdv()`. It can be implemented by changing the first and last
    lines of the preceding code to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向浏览器对象添加一个自定义元素命令。在这种情况下，让我们称它为 `clickAdv()`。它可以通过更改前面代码的第一行和最后一行来实现，如下所示：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The call to the method becomes this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的调用变为如下所示：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The custom `clickAdv()` method has the same detail as the overridden version:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`clickAdv()`方法与覆盖版本具有相同的细节：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Quick tip
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提示
- en: Avoid “magic” values. These are values known only to the developer and may not
    be easily found in the documentation. In this preceding example, the last line
    overrides the implicit `false` with `true`. The meaning is that the custom method
    is to be added to an element rather than the browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用“魔法”值。这些值只有开发者知道，可能在文档中难以找到。在上一个示例中，最后一行将隐式的`false`覆盖为`true`。这意味着自定义方法应该添加到元素中，而不是浏览器中。
- en: 'Now we have the flexibility of a `clickAdv()` custom method that can be reverted
    to an intrinsic version by removing `Adv` at an atomic level:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`clickAdv()`自定义方法的灵活性，可以通过在原子级别移除`Adv`来将其还原为内置版本：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is done by removing `Adv` from the method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过从方法中移除`Adv`来实现的：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This seems perfect! All we need now is to do a little negative testing with
    a bogus element and see whether the output indicates the click failed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很完美！我们现在只需要用无效元素进行一点负面测试，看看输出是否表明点击失败。
- en: Who tests the SDET’s code? Sanity testing of the automation framework
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁测试SDET的代码？自动化框架的健全性测试
- en: Unit testing is an important part of any development project. Since it is expected
    that developers will write unit tests for the functionality of the application,
    so too it would be reasonable that the SDETs write unit tests for the framework
    code base itself. However, the terms “unit testing” and “integration testing”
    often cause confusion when applied to the automation framework itself. Let us
    refer to this aspect as “sanity testing of the automation framework”, although
    it is really unit testing of discreet framework functionality and the integration
    of those features. These are scripts written to intentionally test the viability
    of the features in the framework. Like the previous “Hello, World” example, test
    automation has a version of sanity testing that exercises each of our advanced
    methods. Since automation is a development project, we should have a short test
    that intentionally exercises the capabilities of the framework. This may include
    finding elements with stale XPath or CSS locators, dynamically changing embedded
    data tags to the current date, or writing detailed logging from the wrapper methods.
    It might include a negative test on a non-existent element that intentionally
    fails as its expected result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是任何开发项目的重要组成部分。由于预期开发者将为应用程序的功能编写单元测试，因此SDETs为框架代码库本身编写单元测试也是合理的。然而，“单元测试”和“集成测试”这两个术语在应用于自动化框架本身时常常引起混淆。让我们将这个方面称为“自动化框架的健全性测试”，尽管它实际上是针对离散框架功能及其集成的单元测试。这些是故意测试框架中功能可行性的脚本。就像之前的“Hello,
    World”示例一样，测试自动化有一个健全性测试版本，它测试我们的每个高级方法。由于自动化是一个开发项目，我们应该有一个简短的测试，故意测试框架的能力。这可能包括查找过时的XPath或CSS定位器，动态更改嵌入的数据标签为当前日期，或从包装方法中编写详细的日志。它可能包括对一个不存在的元素的负面测试，故意失败作为其预期结果。
- en: 'As we add more functionality, we should also add sanity testing to our scripts.
    We will add a non-existent button called `btnBogus` that will force the method
    to fail:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加更多功能，我们也应该在脚本中添加健全性测试。我们将添加一个不存在的按钮`btnBogus`，这将迫使方法失败：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To sanity test, we will click the `btnBogus` button followed by the `submit`
    button in our `login fail` method in the `login` `page` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行健全性测试，我们将点击`btnBogus`按钮，然后点击`login` `page`类中的`login fail`方法中的`submit`按钮：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And our results are not what we expected:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们的结果并不是我们所预期的：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: WebdriverIO validates the element before it executes the custom method. The
    same occurs if the method was overridden. The problem here is that it prevents
    us from implementing self-healing objects in our framework or replacing a stale
    element with a viable one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: WebdriverIO在执行自定义方法之前验证元素。如果方法被覆盖，也会发生相同的情况。这里的问题是它阻止我们在框架中实现自我修复对象或用可行的元素替换过时的元素。
- en: There must be another way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有另一种方法。
- en: Extending our ES module helper file with a custom click method
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义点击方法扩展我们的ES模块辅助文件
- en: There are two ways to write error-free programs; only the third one works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以编写无错误的程序；只有第三种方法有效。
- en: – Allen J. Perlis
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: –艾伦·J·佩里斯
- en: 'Our third option is to create a `click()` method in the `helpers` file. While
    it changes our signature, it allows us more control to recover from issues with
    elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个选项是在`helpers`文件中创建一个`click()`方法。虽然它改变了我们的签名，但它使我们能够更好地控制从元素问题中恢复：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output now looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在看起来是这样的：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Quick tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提示
- en: Unlike many coding conventions, there is no common approach for naming wrapper
    methods. Some teams may use a trailing underscore (`_`) while others might append
    the word `Wrapper`. The important takeaway here is that teams should agree on
    an identifiable naming convention that is documented in a Coding Standards document
    and followed in code reviews.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编码约定不同，没有命名包装方法（wrapper methods）的通用方法。一些团队可能会使用尾随下划线（`_`），而其他团队可能会附加 `Wrapper`
    这个词。这里的重要启示是，团队应该就一个可识别的命名约定达成一致，并在编码标准文档中记录，并在代码审查中遵循。
- en: Now that we are checking that our button can be clicked, let’s look at what
    happens afterward.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检查我们的按钮是否可以点击，让我们看看之后会发生什么。
- en: Why are waits difficult to implement correctly?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么等待（waits）难以正确实现？
- en: 'All automation tools have ways to determine what to do when an element does
    not exist. The most common solution is to wait until the object exists. WebdriverIO
    has an option to adjust the timeout for elements in the `wdio.config.json` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自动化工具都有确定当元素不存在时该做什么的方法。最常见的方法是等待对象存在。WebdriverIO 在 `wdio.config.json` 文件中有一个选项可以调整元素的超时时间：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The default is 10 seconds. For years, the most common choice was to wait 30
    seconds. The problem was, depending on our tool, if our script navigated to the
    wrong page, that timeout might happen on every element. That is a long time to
    wait for the script to finally end if a lot of elements do not exist.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认时间是 10 秒。多年来，最常见的做法是等待 30 秒。问题是，根据我们的工具，如果我们的脚本导航到了错误的页面，超时可能会发生在每个元素上。如果有很多元素不存在，那么等待脚本最终结束的时间就会很长。
- en: Back in 2000s, the founder of WorkSoft, Linda Hayes, noted that there is a way
    to calculate a good wait timeout for our framework. Take the average time for
    our slowest page to render and triple it. This means we will anticipate a load
    will be added to our application under test and can be flexible enough to handle
    it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 2000 年代，WorkSoft 的创始人琳达·海斯（Linda Hayes）指出，有一种方法可以为我们框架计算一个良好的等待超时时间。将我们最慢页面渲染的平均时间乘以三。这意味着我们将预测测试中的应用程序将增加负载，并且可以足够灵活地处理它。
- en: 'Different tools have many ways to wait for elements to appear. Tools such as
    Selenium, for example, have three: implicit, explicit, and fluent waits. Implicit
    waits tell Selenium to wait a certain amount of time before throwing an exception
    if an element is not found on the page. Explicit waits wait for a specific condition
    to be met before continuing, such as `enabled` or `clickable`. Fluent waits allow
    customization of the maximum wait time, the frequency with which the condition
    should be checked, and the types of exceptions that should be ignored.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具有许多等待元素出现的方法。例如，Selenium 这样的工具有三个：隐式等待（implicit waits）、显式等待（explicit waits）和流畅等待（fluent
    waits）。隐式等待告诉 Selenium 在找不到页面上的元素之前等待一定的时间，然后抛出异常。显式等待等待特定条件满足后再继续，例如 `enabled`
    或 `clickable`。流畅等待允许自定义最大等待时间、检查条件的频率以及应忽略的异常类型。
- en: But what is the next most common reason that an element does not exist? It is
    because the page is still building. We could just add a hardcoded wait for an
    element to appear.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个元素不存在下一个最常见的原因是什么？那是因为页面仍在构建中。我们只需为元素出现添加一个硬编码的等待时间即可。
- en: The problem is when these waits are mixed together that the actual wait time
    of a Selenium script can add up to several minutes and become difficult to debug.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于当这些等待混合在一起时，Selenium 脚本的实际等待时间可能会累计到几分钟，变得难以调试。
- en: Similarly, WebdriverIO provides several types of waits to handle dynamic elements
    on a web page. These include commands such as `waitUntil()`, `waitForExist()`,
    `waitForDisplayed()`, `waitForEnabled()`, and `waitForSelected()`, which allow
    waiting for specific conditions to be met before continuing with test execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，WebdriverIO 提供了多种等待类型来处理网页上的动态元素。这些包括 `waitUntil()`、`waitForExist()`、`waitForDisplayed()`、`waitForEnabled()`
    和 `waitForSelected()` 等命令，这些命令允许在继续测试执行之前等待特定条件满足。
- en: Note that the `waitForExist()` command rarely has a use in test automation.
    It merely means the element exists in the DOM, not that it appears on the page.
    `waitForDisplayed()` provides the same check and makes it more likely the element
    can be interacted with by the user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`waitForExist()` 命令在测试自动化中很少使用。它仅仅意味着元素存在于 DOM 中，并不意味着它出现在页面上。`waitForDisplayed()`
    提供了相同的检查，并使得元素更有可能被用户交互。
- en: Again, Linda Hayes noted that to make a framework more robust, each element
    should be checked to make sure that it exists and is enabled. This provides the
    breaks for our high-speed car as we make our way down the curvy mountain road
    at night.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，琳达·海斯指出，为了使框架更健壮，每个元素都应该被检查以确保它存在并且已启用。这就像我们在夜间沿着蜿蜒的山路开车时，为我们的高速汽车提供了刹车。
- en: What if, instead of waiting for every element to appear and be enabled, we could
    wait for the page build to complete after each click? Then it would be more likely
    that every element on the page is viable. This would eliminate the need to check
    whether the element exists every time. Only if the element is not found then the
    framework can get creative about finding it before throwing an error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是等待每个元素都出现并启用，而是等待每次点击后页面构建完成，那会怎么样？这样，页面上每个元素更有可能是有效的。这将消除每次检查元素是否存在的需求。只有在元素未找到时，框架才能在抛出错误之前想出找到它的方法。
- en: “I don’t always use Pause(), but when I do, It’s less than 1000 milliseconds”
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “我不总是使用Pause()，但当我使用时，它的时间不到1000毫秒”
- en: 'Yes, there will be times when we need to perform a wait but we want to be smarter
    about it. For example, the `pageSync()` wrapper method needs a quarter-second
    wait as it counts how many elements are on the page. This is the code for the
    custom `pause(ms)` method that will tell us when a hardcoded wait of half a second
    occurs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有时我们需要执行等待操作，但我们希望做得更智能。例如，`pageSync()`包装方法需要一个四分之一秒的等待时间，因为它正在计算页面上的元素数量。这是自定义`pause(ms)`方法的代码，它将告诉我们当硬编码的半秒等待时间发生时：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The method will write to the console if the delay is more than half a second.
    This is to remind us to be aware of how much delay is in the framework. `wait`
    is like adding salt to a soup: a little is okay, but too much spoils it for everyone.
    We could also count how much time is wasted in total.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟时间超过半秒，该方法将写入控制台。这是为了提醒我们注意框架中的延迟量。`wait`就像给汤里加盐一样：一点是好的，但太多会毁掉所有人的汤。我们还可以计算总共浪费了多少时间。
- en: Highlighting elements
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突出显示元素
- en: 'Next, we will add a way to highlight an element to make sure we can see what
    is occurring when we are debugging. These highlights are also a handy way to check
    whether an element is visible. This code will highlight an element in green, although
    we can override that color. It also has a check to see whether the element we
    are highlighting has gone stale. If that is the case, the element is saved to
    the automation switchboard and a stale element switch is set to `true`. This allows
    us to update the element in the calling routines to eliminate the chance of stale
    elements slowing our test execution. Lastly, the function returns whether the
    element was visible or not:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一种突出显示元素的方法，以确保我们在调试时可以看到正在发生的情况。这些突出显示也是一个方便的检查元素是否可见的方法。此代码将以绿色突出显示一个元素，尽管我们可以覆盖该颜色。它还有一个检查，看我们正在突出显示的元素是否已经过时。如果是这种情况，该元素将被保存到自动化交换板，并且过时元素开关设置为`true`。这允许我们在调用例程中更新元素，以消除过时元素减慢测试执行速度的可能性。最后，该函数返回元素是否可见：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we have the highlight functionality turned on, we should add something
    that turns the highlight off, for which we will use a spinner detection method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经启用了突出显示功能，我们应该添加一些可以关闭突出显示的东西，我们将使用旋转器检测方法：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method simply tells us whether the element was visible or not when removing
    the highlight.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法简单地告诉我们移除突出显示时元素是否可见。
- en: 'Next, let us implement a spinner detection method that waits until a spinner
    no longer appears on the page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个旋转器检测方法，该方法等待直到旋转器不再出现在页面上：
- en: '![](img/B19395_05_1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19395_05_1.jpg)'
- en: 'Note that this element locator will be different from project to project. In
    some projects, we look for spinners and loaders:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个元素定位器将因项目而异。在某些项目中，我们寻找旋转器和加载器：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The method utilizes the `highlightOn()` and the `highlightOff()` methods to
    flash the spinner or **loading…** element when it is detected. It will log a message
    if the spinner did not disappear within the timeout. And finally, it returns a
    Boolean value if a spinner was detected. This helps us optimize our framework,
    as we would need to perform a page sync if a spinner appeared.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法利用`highlightOn()`和`highlightOff()`方法在检测到旋转器或**加载中…**元素时闪烁它。如果旋转器在超时时间内没有消失，它将记录一条消息。最后，如果检测到旋转器，它将返回一个布尔值。这有助于我们优化框架，因为如果我们需要执行页面同步，旋转器就会出现。
- en: Now we can proceed to expand the `click()` wrapper. It will require a dynamic
    method to wait for the page to build.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续扩展`click()`包装器。它需要一个动态方法来等待页面构建。
- en: Expanding the click method wrapper
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展点击方法包装器
- en: 'Let’s extend the `clickAdv()` method to make it more robust and less likely
    to fail. First, we will add a `pageSync()` function to the helper class. This
    function is an alternative way to determine when the page build has settled. After
    each click, we will perform the following actions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`clickAdv()`方法，使其更加健壮，减少失败的可能性。首先，我们将在辅助类中添加一个`pageSync()`函数。这是一个确定页面构建何时稳定下来的替代方法。在每次点击后，我们将执行以下操作：
- en: Count the number of visible `/span` elements on the page.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算页面上可见的`/span`元素的数量。
- en: Wait 1/4 of a second.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待1/4秒。
- en: 'Repeat until either of the following occur:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以上步骤，直到以下任一情况发生：
- en: The count of /span elements is stable 3 times
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/span`元素的计数稳定了三次'
- en: The timeout is reached
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时了
- en: Report service-level-agreement metrics on how long it took to complete.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告完成所需时间的服务级别协议指标。
- en: Add the option to customize the length of the wait time.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加自定义等待时间长度的选项。
- en: The page sync method will dynamically wait for the page to build. It is optimized
    to spend a minimum of 0.75 seconds detecting when the page is completed. This
    reduces the chance of throwing an error if our element does not exist as the page
    is building. But it also gives us the flexibility to wait longer, up to 30 seconds
    for the page if there is a significant load put on the system slowing everything
    down.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 页面同步方法将动态等待页面构建。它被优化为至少花费0.75秒来检测页面何时完成。这减少了如果我们的元素在页面构建过程中不存在时抛出错误的概率。但它也给了我们等待更长时间的灵活性，如果系统负载很大，导致一切变慢，页面可以等待长达30秒。
- en: 'It is rather large, so let us break it down:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当大，所以让我们将其分解：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We begin by waiting for any spinner or **loading…** elements to appear. Then
    we optimize by executing only when the URL has changed:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先等待任何旋转器或**加载…**元素出现。然后我们通过仅在URL发生变化时执行来优化：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the URL has not changed, it is more likely that a spinner simply appeared
    because a list option was selected, changing the elements on the page. If the
    URL is new then we begin by getting the first count of elements. This is a dynamic
    loop that executes no less than three times:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL没有变化，那么更有可能是因为选择了列表选项，导致页面上的元素发生了变化，从而简单地出现了一个旋转器。如果URL是新的，那么我们首先获取元素的第一次计数。这是一个动态循环，至少执行三次：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After each element count, we let the page continue building for a brief moment.
    Then we count the elements again until the count is the same for three consecutive
    attempts. In addition, we keep checking whether the page count is greater than
    20 elements. Often, this is the threshold below which lies a blank page without
    a spinner or **loading…** element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个元素计数之后，我们让页面短暂地继续构建。然后我们再次计数元素，直到连续三次尝试的计数相同。此外，我们持续检查页面计数是否大于20个元素。通常，这低于一个阈值，如果没有旋转器或**加载…**元素，页面就是空的。
- en: 'It is important to note that we only count `Span` elements. This could be `div`
    elements, but we should not count all elements with a star wildcard, the reason
    being that counting every element on the page itself can take longer than a quarter-second:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只计数`Span`元素。这可能是`div`元素，但我们不应该计数所有带有星号通配符的元素，原因在于，计数页面上的每个元素本身可能需要超过四分之一秒的时间：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The count of elements could throw errors. The function could time out. The
    page could have no span elements or the call might have been performed without
    an `await` keyword. In any case, the function exits:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 元素计数可能会抛出错误。函数可能会超时。页面可能没有span元素，或者调用可能没有使用`await`关键字。在任何情况下，函数都会退出：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method takes two optional arguments. The first is the amount of milliseconds
    to wait for between counts of the page elements. The default value can be as low
    as 25 milliseconds but should not be more than 250\. This gives us an optimal
    amount of time for the page to complete building after a click. If the page has
    not changed when the click was executed, the synchronization is skipped for speed,
    and it will exit early if no span element exists. This generally occurs when the
    page is blank. It will exit if the page did not settle within a few seconds and
    report this to the console.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个可选参数。第一个是页面元素计数之间的等待时间（以毫秒为单位）。默认值可以低至25毫秒，但不应该超过250毫秒。这为我们提供了在点击后页面完成构建的最佳时间量。如果点击执行时页面没有变化，则为了速度，将跳过同步，并且如果没有span元素存在，它将提前退出。这通常发生在页面为空白的情况下。如果页面在几秒钟内没有稳定下来，它将退出并报告给控制台。
- en: It also gives us a warning if the wait time exceeded the expected timeout for
    the framework. This means that the page is taking longer to load than a user might
    be willing to wait. We could call our DBA and check for SQL queries with excessive
    record retrieval times.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果等待时间超过了框架的预期超时时间，它还会给我们一个警告。这意味着页面加载时间比用户愿意等待的时间更长。我们可以调用我们的DBA并检查具有过度记录检索时间的SQL查询。
- en: For greater efficiency, `pageSync` will only execute if the page URL has changed.
    This is a speed optimization. The second parameter is a switch to force a page
    sync check even if the page URL remains the same.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，`pageSync`只有在页面URL发生变化时才会执行。这是一个速度优化。第二个参数是一个开关，用于强制进行页面同步检查，即使页面URL保持不变。
- en: Lastly, it will indicate whether the browser no longer exists. This can occur
    if an await statement is missing in the calling method and the test ends early.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将指示浏览器是否不再存在。这可能发生在调用方法中缺少await语句，并且测试提前结束的情况下。
- en: Supercharged scroll before a click event
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击事件前的超级充电滚动
- en: 'It is a good practice to check whether an element is on screen before performing
    a click. This method returns `true` if the element is in the viewport:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行点击之前检查元素是否在屏幕上是一个好的做法。此方法如果元素在视口中，则返回`true`：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using this method, we can optimize our code to scroll an element only if it
    is off-screen before performing the click event. However, there is a caveat: if
    an element is moving while WebdriverIO is attempting to click it, it may click
    the wrong element! So, we need another function to tell us when the element stops
    moving:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们可以在执行点击事件之前仅当元素不在屏幕上时才滚动元素，从而优化我们的代码。然而，有一个注意事项：如果元素在WebdriverIO尝试点击它时正在移动，它可能会点击错误的元素！因此，我们需要另一个函数来告诉我们元素何时停止移动：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method checks to see whether the element location has changed horizontally
    or vertically. To optimize speed, this will only be called if it was detected
    that the element was off-screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查元素位置是否在水平或垂直方向上发生变化。为了优化速度，只有在检测到元素已离屏时才会调用此方法。
- en: Let’s now tie all this together into a `clickAdv()` method to make it less likely
    to fail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将这些内容组合成一个`clickAdv()`方法，以降低其失败的可能性。
- en: 'Quick tip: accuracy over speed'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提示：准确性胜过速度
- en: Running a test faster delivers no advantage if the test can’t reach a successful
    conclusion. The wait between element counts in `pageSync()` can be reduced to
    0 milliseconds, but it increases the risk of executing too soon. You can tweak
    this value for optimal performance, but be careful that the framework doesn’t
    run *too* fast.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试无法达到成功结论，那么加快测试速度并不会带来优势。在`pageSync()`中的元素计数之间的等待时间可以减少到0毫秒，但这会增加执行过早的风险。你可以调整这个值以获得最佳性能，但要注意框架不要运行得太快。
- en: Expanding the click method wrapper
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展点击方法包装器
- en: 'We are now ready to add our `clickAdv()` wrapper method. We will have a `pageSync()`
    method execute after every click to build in the flexible timing while we wait
    for the page to complete:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好添加我们的`clickAdv()`包装方法。每次点击后，我们将有一个`pageSync()`方法执行，以便在等待页面完成时内置灵活的时间：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this code, we get the name of the selector from the element. We use a `try`/`catch`
    around the click method. Then, we end the test by forcing a failure with our own
    custom error message indicating the element could not be clicked. In the automation
    switchboard, we set the value already failed to true to ensure the execution of
    the additional methods in the framework is skipped because the click failed. Finally,
    we return a Boolean value of `true` or `false` for success.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从元素中获取选择器的名称。我们在点击方法周围使用`try`/`catch`。然后，我们通过使用我们自己的自定义错误消息强制测试失败来结束测试，指出元素无法点击。在自动化交换机中，我们将已失败的值设置为true，以确保由于点击失败而跳过框架中其他方法的执行。最后，我们返回`true`或`false`布尔值以表示成功。
- en: 'Now when we run the test with a bad element, we get more detail on the underlying
    issue:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用错误的元素运行测试时，我们可以得到更多关于潜在问题的详细信息：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Notice that we get an error that the element could not be found after 30 seconds.
    However, our page was built 28 seconds ago. So, let us change our timeout to be
    more efficient. This can be done by modifying the `waitforTimeout` value in the
    `wdio.conf.ts` file as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在30秒后得到了一个错误，说元素找不到。然而，我们的页面是在28秒前构建的。因此，让我们将我们的超时设置得更高效一些。这可以通过修改`wdio.conf.ts`文件中的`waitforTimeout`值来实现，如下所示：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now when the test runs, no more than three seconds will be used before the
    test fails, but the test will wait longer for the page to build:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当测试运行时，测试失败之前不会超过三秒钟，但测试会等待更长的时间来构建页面：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, this time-out value will differ from project to project. Next, we need
    implement functionality to track some information about our execution.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个超时值会因项目而异。接下来，我们需要实现跟踪我们执行的一些信息的功能。
- en: The importance of metrics
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标的重要性
- en: These methods report how much time they take to execute. `ClickAdv()` also reports
    a warning if the time taken to build the page was longer than the default timeout
    of the framework. With this, we can begin to get insights into how much our changes
    impact the application responsiveness over time, as well as how much the framework
    itself affects the speed of execution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法报告了它们执行所需的时间。`ClickAdv()` 还会在构建页面所需的时间超过框架默认超时时间时报告一个警告。通过这种方式，我们可以开始了解我们的更改如何随着时间的推移影响应用程序的响应速度，以及框架本身如何影响执行速度。
- en: For example, using a baseline execution time for a given test, we can see whether
    framework enhancements are impacting total time positively, or inadvertently slowing
    down execution. A good page stabilization method will often continue execution
    sooner than a hardcoded wait. Tracking to total amount of time added by `Pause()`
    methods are added to the total execution time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用给定测试的基线执行时间，我们可以看到框架增强是否对总时间有积极影响，或者意外地减慢了执行速度。一个好的页面稳定化方法通常会早于硬编码的等待继续执行。通过跟踪`Pause()`方法添加的总时间来跟踪总执行时间。
- en: Self-healing elements
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自愈元素
- en: With custom method wrappers, we can now start to work to reduce the required
    maintenance in our framework with self-healing elements. These are elements in
    a user interface that automatically recover from issues without the need for updating
    the page object model. This can include link elements that have become invalid
    because the class has changed since the last release. Self-healing elements are
    designed to improve the testing experience by reducing the need for manual input
    and allowing the test a better chance to run to completion.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自定义方法包装器，我们现在可以开始通过使用自愈元素来减少框架中所需的维护工作。这些是在用户界面中自动从问题中恢复而不需要更新页面对象模型的元素。这可以包括由于自上次发布以来类已更改而变得无效的链接元素。自愈元素旨在通过减少手动输入的需求并允许测试有更好的机会完成来改善测试体验。
- en: 'For example, let’s say the `Login` button in the last release was a link:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在最新版本中`Login`按钮是一个链接：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After this, we call the button that is no longer valid:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们调用不再有效的按钮：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Normally, if this element were clicked, it would throw an error. But if we
    inject a function that gets a valid element based on the locator, we have a chance
    of getting through this step even if the underlying class has changed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果点击此元素，它会抛出错误。但如果我们注入一个基于定位器获取有效元素的函数，即使底层类已更改，我们也有机会通过这一步：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the following code, we will extract the class tag name and the text from
    the link and generate a button element locator on the fly. While unlikely, the
    code also covers the reverse case, where the button class has become a link:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将提取链接的类标签名和文本，并动态生成按钮元素定位器。虽然不太可能，但代码也涵盖了反向情况，即按钮类已变为链接：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At this point, we have found no elements matching the locator. So we need to
    get creative based on the element that has gone missing since the last release.
    In the following code, we will look at a potential change of class from a link
    anchor to a button or vice versa:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有找到与定位器匹配的元素。因此，我们需要根据自上次发布以来丢失的元素进行创新。在以下代码中，我们将查看从链接锚点变为按钮或反之亦然的潜在类更改：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the following code, we will add similar class-switching code to handle lists
    and `Input` elements:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将添加类似的类切换代码来处理列表和`Input`元素：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Keep in mind that `getValidElement()` will not solve all of our maintenance
    issues. The goal is to reduce our maintenance by a significant amount by having
    a framework that is smart enough to recover from multiple stale elements and still
    get to a given endpoint. The code for replacement locators will be unique to each
    project, but it may be surprising how robust your tests will remain. There is
    some overhead with extra code and console logging, but it is minor compared to
    the amount of time required for updating element locators when a new release is
    pushed to the staging environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`getValidElement()`并不能解决我们所有的维护问题。目标是通过拥有足够智能的框架来从多个过时元素中恢复，并到达给定的端点，从而显著减少我们的维护工作。替换定位器的代码将针对每个项目是独特的，但可能会令人惊讶地发现你的测试将多么稳健。虽然有一些额外的代码和控制台日志的开销，但与将新版本推送到预发布环境时更新元素定位器所需的时间相比，这微不足道。
- en: Stubbing out methods with the “alreadyFailed” switchboard key
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“alreadyFailed”开关板键来模拟方法
- en: 'A framework with a single point of exit can use the switchboard to track the
    number of pass, fail, and skipped steps. By embedding the `alreadyFailed` switch
    in the ASB switchboard, methods can be written to be stubbed out, reporting only
    what the action had been intended to do:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单一出口点的框架可以使用开关板来跟踪通过、失败和跳过的步骤数量。通过在ASB开关板中嵌入`alreadyFailed`开关，可以编写方法以模拟，仅报告动作本意要执行的操作：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This skips all page sync time and delays while incrementing a counter for the
    number of steps needed to get the test to its destination.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以跳过所有页面同步时间和延迟，同时增加计数器以获取测试到达目的地的所需步骤数。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a `helpers` library with several methods to enhance
    our `click` method. We then addressed bringing elements on screen if they are
    outside the viewport and using page synchronization to wait for flexible amounts
    of time for the page to build to ensure that our elements do not throw an error
    when testing. We added highlights as well as a spinner detector. We introduced
    the concept of class switching to try finding, and also included some details
    of execution speed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了一个`helpers`库，其中包含几个方法来增强我们的`click`方法。然后我们解决了将屏幕外的元素拉到屏幕上，并使用页面同步等待页面构建的灵活时间，以确保我们的元素在测试时不会抛出错误的问题。我们还添加了高亮显示以及旋转检测器。我们引入了类切换的概念，以尝试找到，并包括了一些关于执行速度的细节。
- en: Now that we have most of our supporting framework in place for the `click()`
    method, let us do the same thing with `setValue()`. This includes validating our
    input elements and using the quickest way to populate a field via the clipboard.
    Next, we’ll see how to enter text and replace dynamic data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`click()`方法建立了大部分支持框架，让我们对`setValue()`做同样的事情。这包括验证我们的输入元素，并使用最快的方式通过剪贴板填充字段。接下来，我们将看到如何输入文本并替换动态数据。
