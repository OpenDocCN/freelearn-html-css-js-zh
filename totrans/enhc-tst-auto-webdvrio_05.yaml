- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alter Egos – The ClickAdv Wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this and the next few chapters, we will introduce the concept of adding wrappers
    for the`.click()`, `.select()`, and `.setValue()` intrinsic methods. These wrappers
    allow us to add more functionality to these methods to make the framework more
    robust and less likely to fail during a test.
  prefs: []
  type: TYPE_NORMAL
- en: Wrappers are the easiest way to extend functionality throughout the test suite,
    eliminating the need to repeatedly add code in the form of multiple test scripts.
    Sometimes when testing, the page loads slowly and our elements take longer to
    load. Sometimes, the page is updated due to **Asynchronous JavaScript and XML**
    (**AJAX**) and the element we found is now stale and must be found again. Our
    results, shown in both the console window and Allure, should be detailed enough
    to indicate what is occurring. Wrappers allow us to start handling all that information
    efficiently, including scrolling an element into view for screen captures, looking
    for similar replacement objects to reduce maintenance, and burning time during
    page builds so that elements have time to appear without resorting to slower hardcoded
    wait methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways that we will explore for injecting superpowers into our
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Helper commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first start adding a `helpers` file along with its prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a helpers file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We begin by preparing our helper commands, which require the `utility-types`
    package in order to support optional parameters in TypeScript. This package is
    installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will next add a `\helpers` folder that contains a `helpers.ts` file module.
    This contains several methods for resolving issues in the framework. This is where
    we will store the majority of our custom supporting code for the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a helpers file in a WebdriverIO project written in TypeScript, we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory in our project to store our helper functions. This directory
    will be called `helpers`, located within our `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `helpers` directory, create a new TypeScript file for our helper
    functions. Let’s call this file `helpers.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `helpers.ts` file, we need to import the necessary types
    and functions to support file paths, global objects, and Allure reports. Some
    of these will come into play in future chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `helpers.ts` file, we need to define our helper functions. The structure
    of the file will include the public method wrappers such as `click()`, `pageSync()`,
    and `assert()`. It will also contain private supporting methods for finding and
    replacing data tokens, and `getElementType()` to determine how to handle errors
    by class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the files where we want to use the helper functions, we import the functions
    from the `helpers.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is just one example of how we can create and use helper functions in a
    WebdriverIO project written in TypeScript. We can define as many helper functions
    as we need in the `helpers.ts` file and import them into our test code as and
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the `click()` method, let’s begin with a wrapper of `console.log`
    so we can customize the detail. If we happen to call it with a string such as
    `is blank` or `empty`, or a `null` variable, it does not need to print anything.
    But if anything other than a string or number is passed, such as a promise or
    an object, it should output a warning without failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice there is some extra spacing when the error is output to the console.
    This is intentional. We will be making our output visually helpful with spacing
    and color later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize the helpers, we add the following import line to our test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the method, we use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the method is called with a null string, it does not output anything to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If anything other than a string or number is passed then the object and a trace
    is output, something like the following commonly occurs, where a promise object
    is returned instead of a string due to a missing `await` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When a problematic element is passed to the `helper.log` wrapper, the second
    line of code, `UserContext`, will identify where the actual error occurred. Our
    debugging is now starting to look a little bit better.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s next identify and resolve a potential problem in the `.click` method of
    the `login.page.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: The “Hello, World!” of test automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test-automation equivalent of `Hello, World!` is usually a test that checks
    for the presence of a simple element on a web page, such as a heading or a paragraph
    of text. This can involve writing a test that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigates to a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locates an element on the page using an XPath or CSS selector method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies that the element is present and displayed on the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our first example, we have the following five simple steps to perform a
    login:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to a simulated login screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the login button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that a message appears, indicating the login was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example can be found in the `pageObjects\login.page.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already resolved errors that can arise from lines of code executing
    out of order by using the `await` statement. However, element locators may become
    stale over time as developers change the pages we are automating. For example,
    imagine the class of the login button was initially a `button` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But in the next release, it was changed to an anchor link class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `.click` method will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could surround the click with a `try`/`catch` method to capture exceptions
    and get more detail about what exactly caused an error to be thrown. In this example,
    if the click method was successful, we output the successful event. However, if
    the element did not exist, was covered by another element, or otherwise could
    not be clicked, we output the `captured` error detail and send it to our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We would like to have this for every element, but we do not want to have to
    add this code repeatedly in all of our test scripts. Fortunately, with wrappers,
    there is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 helper modules versus overriding intrinsic methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways to achieve this goal. One way to do this would be to
    completely override the intrinsic actions of the `click()` method in every call.
    Alternatively, we could create our own custom method with its own unique naming
    convention. Lastly, we can create our own function that takes the object as a
    parameter and performs additional functionality. Here is what those three approaches
    might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could override all intrinsic `click()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We could add a custom method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or create a custom function in our `Helpers` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The approach you use is up to you. But the key is to pick one and stick with
    it consistently, rather than having a mishmash of different approaches. Each one
    has its own advantages worth considering. Let us look at the pros and cons of
    the first two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding intrinsic element methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way we could enhance the `click()` method is to completely override the
    intrinsic element methods from the `ts.config.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will encapsulate features such as checking the object validity,
    setting the frame, setting the framework to somewhere, and skipping additional
    methods if called when the element does not exist. The way we do this is with
    sanity testing. For example, we will attempt to click on a nonexistent button
    called `btnBogus` and see how the rest of the script executes. Here is an object
    description of the bogus button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this approach, the signature stays the same and all our test scripts are
    enhanced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom `click()` method can add more detail as to what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This approach efficiently adds enhanced functionality to the `click()` method
    of every element in the entire suite of tests. But this is also a drawback – an
    error in this method could break everywhere the `click()` method is used. There
    is no easy way to revert a specific line in a test script to the original intrinsic
    method to see whether the error caused the overridden code. We can only turn it
    all on or turn it all off.
  prefs: []
  type: TYPE_NORMAL
- en: There must be another way!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom element method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add a custom element command to the browser object. In this case, let
    us call it `clickAdv()`. It can be implemented by changing the first and last
    lines of the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the method becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom `clickAdv()` method has the same detail as the overridden version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Quick tip
  prefs: []
  type: TYPE_NORMAL
- en: Avoid “magic” values. These are values known only to the developer and may not
    be easily found in the documentation. In this preceding example, the last line
    overrides the implicit `false` with `true`. The meaning is that the custom method
    is to be added to an element rather than the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the flexibility of a `clickAdv()` custom method that can be reverted
    to an intrinsic version by removing `Adv` at an atomic level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done by removing `Adv` from the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This seems perfect! All we need now is to do a little negative testing with
    a bogus element and see whether the output indicates the click failed.
  prefs: []
  type: TYPE_NORMAL
- en: Who tests the SDET’s code? Sanity testing of the automation framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is an important part of any development project. Since it is expected
    that developers will write unit tests for the functionality of the application,
    so too it would be reasonable that the SDETs write unit tests for the framework
    code base itself. However, the terms “unit testing” and “integration testing”
    often cause confusion when applied to the automation framework itself. Let us
    refer to this aspect as “sanity testing of the automation framework”, although
    it is really unit testing of discreet framework functionality and the integration
    of those features. These are scripts written to intentionally test the viability
    of the features in the framework. Like the previous “Hello, World” example, test
    automation has a version of sanity testing that exercises each of our advanced
    methods. Since automation is a development project, we should have a short test
    that intentionally exercises the capabilities of the framework. This may include
    finding elements with stale XPath or CSS locators, dynamically changing embedded
    data tags to the current date, or writing detailed logging from the wrapper methods.
    It might include a negative test on a non-existent element that intentionally
    fails as its expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we add more functionality, we should also add sanity testing to our scripts.
    We will add a non-existent button called `btnBogus` that will force the method
    to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To sanity test, we will click the `btnBogus` button followed by the `submit`
    button in our `login fail` method in the `login` `page` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And our results are not what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: WebdriverIO validates the element before it executes the custom method. The
    same occurs if the method was overridden. The problem here is that it prevents
    us from implementing self-healing objects in our framework or replacing a stale
    element with a viable one.
  prefs: []
  type: TYPE_NORMAL
- en: There must be another way.
  prefs: []
  type: TYPE_NORMAL
- en: Extending our ES module helper file with a custom click method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to write error-free programs; only the third one works.
  prefs: []
  type: TYPE_NORMAL
- en: – Allen J. Perlis
  prefs: []
  type: TYPE_NORMAL
- en: 'Our third option is to create a `click()` method in the `helpers` file. While
    it changes our signature, it allows us more control to recover from issues with
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Quick tip
  prefs: []
  type: TYPE_NORMAL
- en: Unlike many coding conventions, there is no common approach for naming wrapper
    methods. Some teams may use a trailing underscore (`_`) while others might append
    the word `Wrapper`. The important takeaway here is that teams should agree on
    an identifiable naming convention that is documented in a Coding Standards document
    and followed in code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are checking that our button can be clicked, let’s look at what
    happens afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Why are waits difficult to implement correctly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All automation tools have ways to determine what to do when an element does
    not exist. The most common solution is to wait until the object exists. WebdriverIO
    has an option to adjust the timeout for elements in the `wdio.config.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The default is 10 seconds. For years, the most common choice was to wait 30
    seconds. The problem was, depending on our tool, if our script navigated to the
    wrong page, that timeout might happen on every element. That is a long time to
    wait for the script to finally end if a lot of elements do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2000s, the founder of WorkSoft, Linda Hayes, noted that there is a way
    to calculate a good wait timeout for our framework. Take the average time for
    our slowest page to render and triple it. This means we will anticipate a load
    will be added to our application under test and can be flexible enough to handle
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different tools have many ways to wait for elements to appear. Tools such as
    Selenium, for example, have three: implicit, explicit, and fluent waits. Implicit
    waits tell Selenium to wait a certain amount of time before throwing an exception
    if an element is not found on the page. Explicit waits wait for a specific condition
    to be met before continuing, such as `enabled` or `clickable`. Fluent waits allow
    customization of the maximum wait time, the frequency with which the condition
    should be checked, and the types of exceptions that should be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: But what is the next most common reason that an element does not exist? It is
    because the page is still building. We could just add a hardcoded wait for an
    element to appear.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is when these waits are mixed together that the actual wait time
    of a Selenium script can add up to several minutes and become difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, WebdriverIO provides several types of waits to handle dynamic elements
    on a web page. These include commands such as `waitUntil()`, `waitForExist()`,
    `waitForDisplayed()`, `waitForEnabled()`, and `waitForSelected()`, which allow
    waiting for specific conditions to be met before continuing with test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `waitForExist()` command rarely has a use in test automation.
    It merely means the element exists in the DOM, not that it appears on the page.
    `waitForDisplayed()` provides the same check and makes it more likely the element
    can be interacted with by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Linda Hayes noted that to make a framework more robust, each element
    should be checked to make sure that it exists and is enabled. This provides the
    breaks for our high-speed car as we make our way down the curvy mountain road
    at night.
  prefs: []
  type: TYPE_NORMAL
- en: What if, instead of waiting for every element to appear and be enabled, we could
    wait for the page build to complete after each click? Then it would be more likely
    that every element on the page is viable. This would eliminate the need to check
    whether the element exists every time. Only if the element is not found then the
    framework can get creative about finding it before throwing an error.
  prefs: []
  type: TYPE_NORMAL
- en: “I don’t always use Pause(), but when I do, It’s less than 1000 milliseconds”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yes, there will be times when we need to perform a wait but we want to be smarter
    about it. For example, the `pageSync()` wrapper method needs a quarter-second
    wait as it counts how many elements are on the page. This is the code for the
    custom `pause(ms)` method that will tell us when a hardcoded wait of half a second
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The method will write to the console if the delay is more than half a second.
    This is to remind us to be aware of how much delay is in the framework. `wait`
    is like adding salt to a soup: a little is okay, but too much spoils it for everyone.
    We could also count how much time is wasted in total.'
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will add a way to highlight an element to make sure we can see what
    is occurring when we are debugging. These highlights are also a handy way to check
    whether an element is visible. This code will highlight an element in green, although
    we can override that color. It also has a check to see whether the element we
    are highlighting has gone stale. If that is the case, the element is saved to
    the automation switchboard and a stale element switch is set to `true`. This allows
    us to update the element in the calling routines to eliminate the chance of stale
    elements slowing our test execution. Lastly, the function returns whether the
    element was visible or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the highlight functionality turned on, we should add something
    that turns the highlight off, for which we will use a spinner detection method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This method simply tells us whether the element was visible or not when removing
    the highlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let us implement a spinner detection method that waits until a spinner
    no longer appears on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19395_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this element locator will be different from project to project. In
    some projects, we look for spinners and loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The method utilizes the `highlightOn()` and the `highlightOff()` methods to
    flash the spinner or **loading…** element when it is detected. It will log a message
    if the spinner did not disappear within the timeout. And finally, it returns a
    Boolean value if a spinner was detected. This helps us optimize our framework,
    as we would need to perform a page sync if a spinner appeared.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can proceed to expand the `click()` wrapper. It will require a dynamic
    method to wait for the page to build.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the click method wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s extend the `clickAdv()` method to make it more robust and less likely
    to fail. First, we will add a `pageSync()` function to the helper class. This
    function is an alternative way to determine when the page build has settled. After
    each click, we will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Count the number of visible `/span` elements on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait 1/4 of a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat until either of the following occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The count of /span elements is stable 3 times
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The timeout is reached
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Report service-level-agreement metrics on how long it took to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the option to customize the length of the wait time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The page sync method will dynamically wait for the page to build. It is optimized
    to spend a minimum of 0.75 seconds detecting when the page is completed. This
    reduces the chance of throwing an error if our element does not exist as the page
    is building. But it also gives us the flexibility to wait longer, up to 30 seconds
    for the page if there is a significant load put on the system slowing everything
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is rather large, so let us break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin by waiting for any spinner or **loading…** elements to appear. Then
    we optimize by executing only when the URL has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the URL has not changed, it is more likely that a spinner simply appeared
    because a list option was selected, changing the elements on the page. If the
    URL is new then we begin by getting the first count of elements. This is a dynamic
    loop that executes no less than three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After each element count, we let the page continue building for a brief moment.
    Then we count the elements again until the count is the same for three consecutive
    attempts. In addition, we keep checking whether the page count is greater than
    20 elements. Often, this is the threshold below which lies a blank page without
    a spinner or **loading…** element.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that we only count `Span` elements. This could be `div`
    elements, but we should not count all elements with a star wildcard, the reason
    being that counting every element on the page itself can take longer than a quarter-second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The count of elements could throw errors. The function could time out. The
    page could have no span elements or the call might have been performed without
    an `await` keyword. In any case, the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two optional arguments. The first is the amount of milliseconds
    to wait for between counts of the page elements. The default value can be as low
    as 25 milliseconds but should not be more than 250\. This gives us an optimal
    amount of time for the page to complete building after a click. If the page has
    not changed when the click was executed, the synchronization is skipped for speed,
    and it will exit early if no span element exists. This generally occurs when the
    page is blank. It will exit if the page did not settle within a few seconds and
    report this to the console.
  prefs: []
  type: TYPE_NORMAL
- en: It also gives us a warning if the wait time exceeded the expected timeout for
    the framework. This means that the page is taking longer to load than a user might
    be willing to wait. We could call our DBA and check for SQL queries with excessive
    record retrieval times.
  prefs: []
  type: TYPE_NORMAL
- en: For greater efficiency, `pageSync` will only execute if the page URL has changed.
    This is a speed optimization. The second parameter is a switch to force a page
    sync check even if the page URL remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it will indicate whether the browser no longer exists. This can occur
    if an await statement is missing in the calling method and the test ends early.
  prefs: []
  type: TYPE_NORMAL
- en: Supercharged scroll before a click event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a good practice to check whether an element is on screen before performing
    a click. This method returns `true` if the element is in the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this method, we can optimize our code to scroll an element only if it
    is off-screen before performing the click event. However, there is a caveat: if
    an element is moving while WebdriverIO is attempting to click it, it may click
    the wrong element! So, we need another function to tell us when the element stops
    moving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This method checks to see whether the element location has changed horizontally
    or vertically. To optimize speed, this will only be called if it was detected
    that the element was off-screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now tie all this together into a `clickAdv()` method to make it less likely
    to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick tip: accuracy over speed'
  prefs: []
  type: TYPE_NORMAL
- en: Running a test faster delivers no advantage if the test can’t reach a successful
    conclusion. The wait between element counts in `pageSync()` can be reduced to
    0 milliseconds, but it increases the risk of executing too soon. You can tweak
    this value for optimal performance, but be careful that the framework doesn’t
    run *too* fast.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the click method wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to add our `clickAdv()` wrapper method. We will have a `pageSync()`
    method execute after every click to build in the flexible timing while we wait
    for the page to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we get the name of the selector from the element. We use a `try`/`catch`
    around the click method. Then, we end the test by forcing a failure with our own
    custom error message indicating the element could not be clicked. In the automation
    switchboard, we set the value already failed to true to ensure the execution of
    the additional methods in the framework is skipped because the click failed. Finally,
    we return a Boolean value of `true` or `false` for success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we run the test with a bad element, we get more detail on the underlying
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we get an error that the element could not be found after 30 seconds.
    However, our page was built 28 seconds ago. So, let us change our timeout to be
    more efficient. This can be done by modifying the `waitforTimeout` value in the
    `wdio.conf.ts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the test runs, no more than three seconds will be used before the
    test fails, but the test will wait longer for the page to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, this time-out value will differ from project to project. Next, we need
    implement functionality to track some information about our execution.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These methods report how much time they take to execute. `ClickAdv()` also reports
    a warning if the time taken to build the page was longer than the default timeout
    of the framework. With this, we can begin to get insights into how much our changes
    impact the application responsiveness over time, as well as how much the framework
    itself affects the speed of execution.
  prefs: []
  type: TYPE_NORMAL
- en: For example, using a baseline execution time for a given test, we can see whether
    framework enhancements are impacting total time positively, or inadvertently slowing
    down execution. A good page stabilization method will often continue execution
    sooner than a hardcoded wait. Tracking to total amount of time added by `Pause()`
    methods are added to the total execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Self-healing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With custom method wrappers, we can now start to work to reduce the required
    maintenance in our framework with self-healing elements. These are elements in
    a user interface that automatically recover from issues without the need for updating
    the page object model. This can include link elements that have become invalid
    because the class has changed since the last release. Self-healing elements are
    designed to improve the testing experience by reducing the need for manual input
    and allowing the test a better chance to run to completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say the `Login` button in the last release was a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we call the button that is no longer valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, if this element were clicked, it would throw an error. But if we
    inject a function that gets a valid element based on the locator, we have a chance
    of getting through this step even if the underlying class has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will extract the class tag name and the text from
    the link and generate a button element locator on the fly. While unlikely, the
    code also covers the reverse case, where the button class has become a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have found no elements matching the locator. So we need to
    get creative based on the element that has gone missing since the last release.
    In the following code, we will look at a potential change of class from a link
    anchor to a button or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will add similar class-switching code to handle lists
    and `Input` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that `getValidElement()` will not solve all of our maintenance
    issues. The goal is to reduce our maintenance by a significant amount by having
    a framework that is smart enough to recover from multiple stale elements and still
    get to a given endpoint. The code for replacement locators will be unique to each
    project, but it may be surprising how robust your tests will remain. There is
    some overhead with extra code and console logging, but it is minor compared to
    the amount of time required for updating element locators when a new release is
    pushed to the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing out methods with the “alreadyFailed” switchboard key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A framework with a single point of exit can use the switchboard to track the
    number of pass, fail, and skipped steps. By embedding the `alreadyFailed` switch
    in the ASB switchboard, methods can be written to be stubbed out, reporting only
    what the action had been intended to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This skips all page sync time and delays while incrementing a counter for the
    number of steps needed to get the test to its destination.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a `helpers` library with several methods to enhance
    our `click` method. We then addressed bringing elements on screen if they are
    outside the viewport and using page synchronization to wait for flexible amounts
    of time for the page to build to ensure that our elements do not throw an error
    when testing. We added highlights as well as a spinner detector. We introduced
    the concept of class switching to try finding, and also included some details
    of execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have most of our supporting framework in place for the `click()`
    method, let us do the same thing with `setValue()`. This includes validating our
    input elements and using the quickest way to populate a field via the clipboard.
    Next, we’ll see how to enter text and replace dynamic data.
  prefs: []
  type: TYPE_NORMAL
