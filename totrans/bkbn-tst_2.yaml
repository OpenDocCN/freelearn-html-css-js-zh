- en: Chapter 2. Creating a Backbone.js Application Test Plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a basic test infrastructure, we''ll turn our attention toward
    integrating a Backbone.js application and mapping out a test development strategy.
    In this chapter, we will create a test plan by working through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some fundamental concepts of Backbone.js development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a Backbone.js application to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining relevant testing concepts and approaches to guide test plan creation
    and execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating parts of the Backbone.js application to test in complete or partial
    isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying tests that exercise multiple interacting parts of the Backbone.js
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Backbone.js application into our test infrastructure, and authoring
    and running a few introductory application tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Backbone.js refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this book assumes a comfortable level of familiarity with Backbone.js,
    Underscore.js, and jQuery, we will briefly touch upon the basics of Backbone.js
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backbone.js provides abstractions and useful functionality for architecting
    and developing JavaScript web applications. Backbone.js brings order to the chaotic
    interactions between program and display logic, DOM events, and backend communication.
    This is achieved via what could loosely be considered a **Model-View-Controller**
    (**MVC**) paradigm that separates application code into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling and retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display rendering and user interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brokering data and display logic to appropriately bind and manipulate data models
    and user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Backbone.js does not completely follow a traditional MVC approach, causing some
    observers to call it an **MV*** framework. An MV* application has a model and
    a view but has something other than a controller connecting the model and the
    view. For a much more detailed discussion on MVC and the various MV* approaches,
    see *Developing Backbone.js Applications* by *Addy Osmani*, and the article, *Journey
    Through The JavaScript MVC Jungle* ([http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/](http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, Backbone.js provides a set of core library components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events**: The `Backbone.Events` module gives JavaScript objects the ability
    to emit and respond to events, including built-in Backbone.js class events as
    well as custom application events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Models**: The `Backbone.Model` class provides a data wrapper that can synchronize
    with a backend, validate data changes, and emit events to other parts of a Backbone.js
    application. A model is the fundamental unit of data in a Backbone.js application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections**: The `Backbone.Collection` class wraps a set of models in an
    ordered list. Collections provide events, backend synchronization, and many helper
    methods for manipulating and mutating the set of underlying models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Backbone.js leaves the choice of the template library up to
    the developer (we will use Underscore.js templates for this book). Other popular
    template alternatives include Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)),
    Mustache ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/)),
    and EJS ([http://embeddedjs.com/](http://embeddedjs.com/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**: A `Backbone.View` object is the glue that binds models, collections,
    and templates together with the browser environment and DOM. Backbone.js is deliberately
    agnostic as to what a view must do, but a typical view references a collection
    or a model, couples data to the user interface via a template, and mediates user
    interaction and backend server events. To clarify potentially confusing terminologies,
    `Backbone.View` is much more analogous to a traditional MVC controller, and a
    Backbone.js template acts like an MVC view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routers**: Backbone.js programs are commonly developed as single-page applications
    in which the entire HTML page source and JavaScript libraries are downloaded in
    a single page load. `Backbone.Router` maintains the internal state of the application
    and manages the browser history. Routers provide client-side routing via URL hash
    fragments (`#app-page`) to allow different views to be linked to, bookmarked,
    and navigated like traditional web pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the chapters that follow, we will test these components separately and together,
    so it is important to ensure a solid grasp of the fundamentals. The core documentation
    at [http://backbonejs.org](http://backbonejs.org) is a good starting point for
    the concepts, API, and pointers and tips on application development. For a deeper
    dive into Backbone.js topics, there are many great online and print resources,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Developing Backbone.js Applications* by *Addy Osmani*, which is a Creative-Commons-licensed
    book developed with the help of the open source community on GitHub. This book
    discusses the theory, architecture, and fundamentals of creating Backbone.js applications
    ([https://github.com/addyosmani/backbone-fundamentals](https://github.com/addyosmani/backbone-fundamentals)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Derick Bailey''s Blog*, which is a blog that is frequently updated with many
    Backbone.js posts and has been written by the creator of `Backbone.Marionette`
    ([http://lostechies.com/derickbailey/category/backbone/](http://lostechies.com/derickbailey/category/backbone/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official Backbone.js wiki page that aggregates blog posts, tutorials, and
    working examples ([https://github.com/documentcloud/backbone/wiki/Tutorials%2C-blog-posts-and-example-sites](https://github.com/documentcloud/backbone/wiki/Tutorials%2C-blog-posts-and-example-sites)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a Backbone.js application to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Devising and implementing a test plan is fundamentally a practical exercise,
    and we can better achieve our goal of overall application reliability by applying
    test lessons and techniques to a real application—whether it is one that has just
    been started or an existing application in need of better test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have a Backbone.js application in development, you can most likely
    skip to the next section of this chapter. One potential issue we want to identify
    is the complexity of the existing application, especially one with minimal or
    no existing tests. Complicated dependencies, non-modular design, and highly coupled
    application components may require extensive mocking and stubbing to even permit
    a base level of test framework integration. Ultimately, the test infrastructure
    written around a legacy application will likely be quite different from the one
    written around a modular, decoupled application such as Notes. Accordingly, you
    may wish to use our reference application as a learning tool instead.
  prefs: []
  type: TYPE_NORMAL
- en: We provide a small reference Backbone.js application to use along with this
    book, simply named Notes. Notes is an online note manager that allows a user to
    create, view, and edit notes using the Markdown ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/))
    language. You can try out an online demo of the application at [http://backbone-testing.com/notes/app/](http://backbone-testing.com/notes/app/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The full source code of Notes is available as part of the examples repository
    (see the *Preface* for the download instructions). We actually provide two versions
    of the Notes application that share most of the same underlying code. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Application**: The `notes/` directory in the examples repository contains
    an application backed by HTML5 localStorage ([https://developer.mozilla.org/en-US/docs/DOM/Storage#localStorage](https://developer.mozilla.org/en-US/docs/DOM/Storage#localStorage))
    for persistent, client-side storage in a web browser. The application can be run
    without a network connection from a URL based on `file://`, and will be used for
    most of the examples in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server Application**: The `notes-rest/` directory in the examples repository
    contains an application backed by a MongoDB database and served by a Node.js web
    server (available at `notes-rest/server.js`). The examples repository contains
    further instructions on installing and running the backend server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting acquainted with the Notes application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Notes application initially presents a user with a list of existing note
    titles with buttons for editing/deleting individual notes. The page also provides
    a **Write a new note** input form for creating notes and a simple search box for
    a user to filter displayed notes by title.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting acquainted with the Notes application](img/5248OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notes list
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on a note title, such as **Things to do in Washington, DC.**, activates
    the single note view and displays the note with rendered HTML (headings, bulleted
    lists, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting acquainted with the Notes application](img/5248OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Single note view
  prefs: []
  type: TYPE_NORMAL
- en: 'The single note editor provides form inputs for title and Markdown text data.
    Any changes to the title or text are immediately saved to the backing datastore
    and made available for viewing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting acquainted with the Notes application](img/5248OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A single-note-editing form
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of the Notes application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript `script` tags in the `notes/app/index.html` web page illustrate
    the program files and the overall structure of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if the long list of JavaScript libraries and application files looks
    foreboding. We will introduce each application piece as we test it. The examples
    in this book stand on their own without the need to look at the full source code
    of the Notes application. At the same time, downloading, running, and testing
    the Notes application is a useful exercise, particularly as you advance to the
    later chapters of this book and want to see the entire test collection put together
    in a single package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working our way through the JavaScript libraries, we start with the familiar
    core of Backbone.js (v1.0.0), Underscore.js (v1.4.4), and jQuery (v2.0.2). The
    additional vendor libraries in `notes/app/js/lib/` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backbone.localStorage**: This allows us to save model data into the `localStorage`
    database for the `notes/app/` example application—[https://github.com/jeromegn/Backbone.localStorage](https://github.com/jeromegn/Backbone.localStorage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bootstrap**: This is a popular user interface layout and components library—[http://twitter.github.io/bootstrap/](http://twitter.github.io/bootstrap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Showdown**: This converts Markdown text (for example, `## Heading`) to formatted
    HTML (for example, `<h2>Heading</h2>`)—[https://github.com/coreyti/showdown](https://github.com/coreyti/showdown)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of application structure and event flow, the key components of Notes
    can loosely be presented in a hierarchical fashion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The application `app` bootstraps various application parts and starts up the
    router `App.Routers.Router`. The router routes hash fragments to either the list
    view `App.Views.Notes` or the single note view `App.Views.Note`. Both of these
    views use Underscore.js template strings from `App.Templates`. The list view `App.Views.Notes`
    contains two additional view objects for filtering and displaying list items,
    and a collection of notes. The `App.Views.Note` single note view contains two
    views objects for menu bar navigation actions and rendering Markup, and a note
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Diving into the application files, the `notes/app/js/app/` directory decomposes
    into module groups, starting with some helper utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace.js`: This sets up a global namespace for our application classes
    (`App`) and instance (`app`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.js`: This sets up configuration variables for the application instance,
    which we will be overriding in some of our tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application has a single model and collection that abstract the note data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Models.Note` (`models/note.js`): This is a model class that represents
    a note'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Collections.Notes` (`collections/notes.js`): This is a collection that
    wraps `App.Models.Note` model instances, representing a list of notes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All view templates are maintained in one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Templates` (`templates/templates.js`): This is an object literal that
    contains the Underscore.js template strings for rendering HTML sections for various
    views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single note page has three view objects—a parent view (`App.Views.Note`)
    containing a child view (`App.Views.NoteView`) that renders a note, and a helper
    view (`App.Views.NoteNav`) for interacting with the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Views.NoteNav` (`views/note-nav.js`): This is a helper view that controls
    the note navigation bar options **View**, **Edit**, and **Delete** and listens
    for / triggers events for interaction with other views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Views.NoteView` (`views/note-view.js`): This is a child view that renders
    note Markdown data as HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Views.Note` (`views/note.js`): This is a parent view that represents a
    single `App.Models.Note` model for viewing, editing, and deleting. It contains
    the `App.Views.NoteView` child view and the `App.Views.NoteNav` helper view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of notes on the home page has a similar assortment of views.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Views.NotesFilter` (`views/notes-filter.js`): This is a helper view for
    managing the filter form input and for hiding/showing notes based on the filter
    query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Views.NotesItem` (`views/notes-item.js`): This is a child view that renders
    a single note list entry on the home page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.Views.Notes` (`views/notes.js`): This is a parent view containing an `App.Collections.Notes`
    collection, an `App.Views.NotesFilter` view, and multiple `App.Views.NotesItem`
    view instances, allowing a user to peruse available notes by title and click on
    action buttons to invoke specific note actions (for example, edit or delete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have the router and the application instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.Routers.Router` (`routers/router.js`): This is the application router,
    which mediates routes for the home and single note pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.js`: This is the Backbone.js application instance, which instantiates
    the `App.Views.Notes` and `App.Routers.Router` instances and starts routing history.
    The application instance is functionally similar to the `main` function entry
    point in languages such as C and Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components serve as the basis for the test examples throughout this book.
    At the same time, the specific code, classes, and objects of the Notes application
    are not special or unique as a testing target—any Backbone.js application with
    a standard assortment of models, views, templates, and routers should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numerous other sample Backbone.js applications are available as learning tools
    for testing and development practices, many of which are documented on the Backbone.js
    example sites wiki page. One particularly well-liked project is TodoMVC ([http://todomvc.com/](http://todomvc.com/))
    that provides a simple task manager using Backbone.js. TodoMVC further provides
    examples of the same application using other JavaScript frameworks, including
    AngularJS, Knockout.js, Meteor, and Derby, making it a great way to try out popular
    frontend frameworks outside the world of Backbone.js.
  prefs: []
  type: TYPE_NORMAL
- en: Test paradigms and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous competing and complementary theories regarding software testing
    and development methodologies. Reading up on the world of test methods provides
    an excellent background for any developer looking to improve the ways in which
    they construct, implement, and manage tests. For brevity's sake, we will only
    introduce two paradigms in this book that are particularly useful for Backbone.js
    testing—Test-Driven Development (TDD) and Behavior-Driven Development (BDD).
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-Driven Development is a process wherein tests are written first and *then*
    the actual code is written. The benefits of this approach include:'
  prefs: []
  type: TYPE_NORMAL
- en: Making tests a first-class priority in the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encouraging code to be written in small modular units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing the knowledge of code implementation details from unduly influencing
    the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD and general software testing principles are covered in many resources; a
    recommended reference on the subject is *Growing Object-Oriented Software, Guided
    by Tests* by *Steve Freeman and Nat Pryce* ([http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627](http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purpose of readability, we usually present the code first and the tests
    second. However, this is not necessarily the order in which the code and tests
    would be developed. Notwithstanding our examples, we strongly encourage that you
    incorporate TDD practices into your software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development is a refinement to TDD. It was developed by *Dan
    North* ([http://dannorth.net/introducing-bdd/](http://dannorth.net/introducing-bdd/)),
    and centers around specifying and describing tests in terms of the desired *behavior*
    of the application. In other words, BDD tests focus on what the *application*
    should be doing and not what the *test code* is testing, causing developers to
    ideally think less about internal test details and more about the application
    as a whole. To learn more about the principles and applications of BDD, a great
    starting point is the [http://behaviour-driven.org/](http://behaviour-driven.org/)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BDD and TDD as library configuration options**'
  prefs: []
  type: TYPE_NORMAL
- en: The BDD and TDD paradigms are so prevalent in the testing vernacular that many
    test libraries have adopted the terms BDD or TDD to designate APIs and configurations.
    For example, in [Chapter 3](ch03.html "Chapter 3. Test Assertions, Specs, and
    Suites"), *Test Assertions, Specs, and Suites*, we'll explore the Mocha `bdd`
    and `tdd` API interfaces. To avoid any confusion, it is best to view test library
    modes as just configuration options that may or may not have a strict relationship
    to the paradigms we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concepts, approaches, and planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before jumping into the testing waters, it makes sense to have a plan of *what*
    we should test and *why*. The term **test plan** is heavily overloaded with many
    potential interpretations as processes, literature, and practices have been prevalent
    and continuously evolving for decades. It is not surprising that modern test plans
    can range from casual, mostly ad-hoc practices to formal, 100-page documents requiring
    executive sign offs at various stages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed discussion on the test plan practices applied to modern
    JavaScript applications, see the *JavaScript Testing Beginner's Guide* by *Yuxian
    Eugene Liang* ([http://www.packtpub.com/javascript-testing-beginners-guide/book](http://www.packtpub.com/javascript-testing-beginners-guide/book)).
  prefs: []
  type: TYPE_NORMAL
- en: As Backbone.js applications are typically created in iterative development cycles,
    often without a lot of extra formality, we will take a fairly practical approach
    and create a test plan that simply identifies testing categories and applies them
    to the application under test. While an actual planning document or wiki is a
    best practice, it is not absolutely necessary. The overriding point is being able
    to identify what tests are appropriate for a given piece of code or feature during
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on a few of the many overlapping concepts within the auspices
    of a test plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: Unit tests isolate parts of the application (individual functions,
    classes, and modules) to exercise. Some interpretations of a frontend unit test
    further require that the test executes quickly and without any I/O (network, disk,
    and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial integration tests**: Integration tests typically involve testing
    the *entire* application stack—frontend, web server, backend datastore, and everything
    in between. We will not go that far in this book but will instead write frontend
    tests that combine multiple application parts (for example, collections and views)
    and verify that they are interacting correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests take a narrow view and are often used by a developer to set forth
    a set of required behaviors for the small piece of code they are presently working
    on. Then, the code is developed to match up with the unit test assertions. Partial
    integration tests take a higher-level view, piecing together the application and
    checking that the individual components add up to a functional whole. In an exemplary
    Backbone.js application, a unit test might create a single model and test-only
    model methods. In contrast, a partial integration test might create a view with
    several subviews and a collection and verify that collection data changes modify
    the subview display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other concepts that we will not explicitly cover in this book, but that are
    worth becoming familiar with and integrating into the overall development and
    testing process, include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full integration tests**: Full integration tests incorporate the entire application
    (often seeded with known test data), exercise behavior as a user would through
    the frontend, and verify that the application responses propagate all the way
    from the backend to the user interface. For a Backbone.js application, this would
    entail pointing a browser window to the application''s HTML page and running the
    application like a real user would.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression tests**: Regression tests isolate and expose reported bugs in
    an application. The tests are written *first* to verify that the bug is reproduced,
    after which the source code is fixed. The tests continue to be run as part of
    the overall test suite to ensure that the bug does not reappear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability tests**: Usability testing encompasses many different forms and
    focuses on getting feedback that exposes portions of the application that need
    user interface or user experience improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance/load tests**: Performance tests verify that the application maintains
    minimum response times for given use cases. Load testing checks that the application
    can still meet performance goals when different parts of the program are stressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance tests**: Acceptance tests form the criteria by which a customer
    can verify that the application meets its requirements. A suite of acceptance
    tests can include any of the categories of tests mentioned previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have had a brief introduction of these various testing concepts,
    we will develop an informal test plan for our Backbone.js application. We will
    examine the various parts of our Backbone.js application and identify what needs
    to be tested, what type of tests we should apply, and the behavior that we need
    to verify in the application. For the parts of an application that are still in
    development or in the early design phases, we'll go through the same exercises,
    just with a focus on the behaviors we expect the application to exhibit once it
    has been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Testing individual Backbone.js components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone.js applications are quite amenable to testing separation. Backbone.js
    provides a small number of core components that mostly avoid interdependencies.
    Our goal in this section is to identify the different parts of a Backbone.js application
    that can be unit tested in isolation and start thinking about the features of
    each one that we should test. Many components can simply be instantiated alone
    while others will need some extra mocking or patching help in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone.js models most often are independent entities that can be instantiated
    with a simple `new MyModel({foo: 123})` invocation. Accordingly, we can create
    standalone model objects in our tests without references to any other objects.
    Our model tests should include the assertions that:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be instantiated with supplied and/or default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be synchronized with a backing datastore (for example, `localStorage`
    or a REST server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom and built-in events fire and/or are consumed on appropriate state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation logic accurately distinguishes the correctness of attribute data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collections customarily have a single dependency on a model, declared like
    `model: MyModel` in the class definition. We can either directly instantiate collections
    in our tests or mock the `model` property for further test isolation. A typical
    set of collection specs should verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: Collection objects can be created with or without an array of model objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model objects can be added and removed from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are triggered on container and model changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is appropriately synchronized with the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although templates are not an actual Backbone.js component, there are several
    conventional template development techniques for Backbone.js integration that
    we'll observe. Templates generally do not have any dependencies and can readily
    be used alone in test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specifics of template tests largely depend on the engine used (for example,
    Underscore.js or Handlebars). A reasonable test starting point would confirm that:'
  prefs: []
  type: TYPE_NORMAL
- en: Template objects render the appropriate HTML output with the provided data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex data structures such as arrays and objects are correctly interpolated
    in the template output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views frequently have the most dependencies of any Backbone.js component. Views
    can contain combinations of model, collection, template, router, and child/helper
    view references. Accordingly, we will have to mock or patch dependencies to isolate
    views and/or provide partial dependencies in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all application views, we will want to verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: Views can render the target HTML, binding model data to a template string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View objects provided with an `el` property get added to the DOM on creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View methods correctly bind to DOM and Backbone.js events, and respond appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects contained by a view (for example, subviews and models) are properly
    disposed on the view removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routers commonly contain several top-level views and may have collection or
    model references. For unit-testing purposes, we will usually mock out dependencies
    to easily test the routing behavior without regard to the rest of the application.
    Our router tests will need to assert that:'
  prefs: []
  type: TYPE_NORMAL
- en: URL routes are accurately matched to appropriate views or other actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A router maintains the browser history correctly after navigation events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Utilities include any helper code that is not actually a core Backbone.js class
    or object. As utilities are ad-hoc creations and have no real constraints, they
    can usually be unit tested easily, provided they are developed along with, and
    in consideration with, their supporting tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing application interactions and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Backbone.js application is used as a cohesive whole by end users, and wherever
    possible, we should have the test infrastructure verify overall application functionality
    and behaviors that cut across single Backbone.js components.
  prefs: []
  type: TYPE_NORMAL
- en: Partial integrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While unit tests are a staple of modern software development, we must metaphorically
    move from unit-testing trees to the forest of partial integration tests to ensure
    that at least some pieces of the application work together harmoniously and reliably.
    In practice, this just means varying the degree to which we mock or remove component
    dependencies in the tests we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests can interact with application parts in many ways, including:'
  prefs: []
  type: TYPE_NORMAL
- en: By creating a parent view with a collection and subviews, invoking DOM events,
    and checking appropriate changes are made to both the collection data and subview
    displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By filling in and submitting the form input in a Backbone.js view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By directly adding models to a collection and triggering events in listening
    views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Backbone.js classes extend the `Backbone.Events` base class and typically
    emit and consume events as a first-order means of communication. We will want
    to test that our application components trigger correctly and react to various
    expected events during the application's execution. We will often leverage tools,
    such as spies, stubs, and mocks, to exercise the event logic we want to test while
    not actually affecting other application states.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to carefully craft our test code to properly set up and tear
    down the test environment so that we can make reasonable assumptions about the
    starting event listener state in each test. For example, if multiple tests add
    custom listeners to a shared object without cleaning up, other tests could spuriously
    fail due to listener callback interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event behaviors that we will want to test across all our Backbone.js components
    include whether:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects respond to custom/built-in events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects emit events correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners are properly cleaned up on disposal events, such as object or
    view removal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dipping our toes in the application testing waters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can identify the aspects of the Backbone.js components that we want
    to test, let's begin planning and writing tests for the namespace utility and
    the Backbone.js model. For each component, we will examine application use cases
    and expected behaviors and then write tests to verify our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The starting point for the Notes application is a namespace utility that provides
    two global variables to organize our application classes (`App`) and instance
    (`app`). In the `notes/app/js/app/namespace.js` example application file, we''ll
    create the two namespace object literals with class/application properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior that we want to test of these helper objects is if they contain
    the correct properties that other application components will rely upon. Accordingly,
    the `chapters/02/test/js/spec/namespace.spec.js` test file just needs a few specs
    to cover these objects. The first spec `provides the ''App'' object` asserts that
    `App` is a JavaScript object with properties for all of the different grouping
    names (`Models`, `Views`, and so on) that we have attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second spec `provides the ''app'' object` just checks that the global `app`
    variable exists as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving on to the actual Backbone.js classes, we will start with the model `notes/app/js/app/models/note.js`
    file that provides the data backing a single note in the Notes application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The model has three fields: `title`, `text`, and `createdAt`. As our example
    Notes application uses `localStorage` configured in the collection class, we do
    not have to provide backend synchronization declarations (for example, a `urlRoot`
    property or a `url` function) to persist model data. Because our model essentially
    comprises a single `defaults` declaration, the behavior that we need to test is
    simply that the default and modified attributes work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test file for the model, `chapters/02/test/js/spec/models/note.spec.js`,
    has two specs. The first spec creates an `App.Models.Note` object with default
    values and uses `get()`to verify each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second spec `sets passed attributes` tests a model created with the supplied
    values for `title` and `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running the application tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our Backbone.js application files and the preliminary application tests
    ready, we need to integrate everything into the test driver we created in [Chapter
    1](ch01.html "Chapter 1. Setting Up a Test Infrastructure"), *Setting Up a Test
    Infrastructure*. We will continue with the existing application directory structure
    by adding specs to `chapters/02/test/js/spec` and copying the application libraries
    from `notes/app/js/app` to `chapters/02/app/js/app`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Notes application resides in the `notes/app` directory, which is the base
    location we will use to discuss the application components. At the same time,
    the chapter code examples are aimed to be independent. Therefore, we maintain
    our layout rules that the application code goes in `chapters/NUMBER/app` and the
    tests go in `chapters/NUMBER/test`.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the downloadable examples link files such as `chapters/02/app/js/app/namespace.js`
    to `notes/app/js/app/namespace.js`. Thus, throughout this book, we will talk about
    a file such as `namespace.js` interchangeably using either of the full paths as
    a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chapters/02/test/test.html` test driver page, we''ll add `script` tags
    referencing our libraries, application files, and tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted tag lines in the previous file illustrate that we have now
    added the core vendor libraries (Underscore.js, Backbone.js, and so on), the application
    libraries, and our two spec files. Opening `chapters/02/test/test.html` gives
    us our test report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application tests](img/5248OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test report
  prefs: []
  type: TYPE_NORMAL
- en: With our finished test report, we have now exercised and tested specific Backbone.js
    components and hooked everything into the overall test infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the basics of Backbone.js applications and introduced
    the Notes application as a helpful, if optional, companion to the test examples
    in this book. We then reviewed some relevant high-level testing concepts and dived
    into the specifics of what we will want to test in a Backbone.js application—in
    separated application pieces and as integrated parts of a whole. Finally, we wrote
    our first application unit tests and extended the test infrastructure from [Chapter
    1](ch01.html "Chapter 1. Setting Up a Test Infrastructure"), *Setting Up a Test
    Infrastructure*, to execute our test reporter.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to take an existing or in-development Backbone.js application,
    analyze its components, and create an abstract test infrastructure outline that
    will later be filled in with actual tests and suites.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Chai assertions, basic Mocha test constructs
    (specs and suites), test setup/teardown/configuration, and how to deterministically
    verify behavior in an asynchronous application environment. We will also broadly
    increase our test coverage as we write many more tests for our Backbone.js application
    in the course of learning testing technologies.
  prefs: []
  type: TYPE_NORMAL
