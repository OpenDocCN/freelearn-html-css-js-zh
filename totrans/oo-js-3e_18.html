<html><head></head><body><div class="appendix" title="Appendix&#xA0;E.&#xA0;Answers to Exercise Questions"><div class="titlepage"><div><div><h1 class="title"><a id="appE"/>Appendix E. Answers to Exercise Questions</h1></div></div></div><p>This appendix lists possible answers to the exercises at the end of the chapters. Possible answers meaning they are not the only ones, so don't worry if your solution is different.</p><p>As with the rest of the book, you should try them in your console and play around a bit.</p><p>The first and the last chapters don't have the <span class="emphasis"><em>Exercises</em></span> section, so let's start with <a class="link" href="ch02.html" title="Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions">Chapter 2</a>, <span class="emphasis"><em>Primitive Data Types, Arrays, Loops, and Conditions</em></span>.</p><div class="section" title="Chapter 2, Primitive Data Types, Arrays, Loops, and Conditions"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec111"/>Chapter 2, Primitive Data Types, Arrays, Loops, and Conditions</h1></div></div></div><p>Lets try and solve the following exercises:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec197"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The result will be as follows:<pre class="programlisting">        &gt; var a; typeof a; &#13;
        "undefined" &#13;
</pre><p>When you declare a variable but do not initialize it with a value, it automatically gets the undefined value. You can also check:</p><pre class="programlisting">        &gt; a === undefined; &#13;
        true &#13;
</pre><p>The value of <code class="literal">v</code> will be:</p><pre class="programlisting">        &gt; var s = '1s'; s++; &#13;
        NaN &#13;
</pre><p>Adding <code class="literal">1</code> to the string <code class="literal">'1s'</code> returns the string <code class="literal">'1s1'</code>, which is <span class="emphasis"><em>Not A Number</em></span>, but the <code class="literal">++</code> operator should return a number; so it returns the special <code class="literal">NaN</code> number.</p><p>The program is as follows:</p><pre class="programlisting">        &gt; !!"false"; &#13;
        true &#13;
</pre><p>The tricky part of the question is that <code class="literal">"false"</code> is a string and all strings are <code class="literal">true</code> when cast to Booleans (except the empty string <code class="literal">""</code>). If the question wasn't about the string <code class="literal">"false"</code> but the Boolean <code class="literal">false</code> instead, the double negation !! returns the same Boolean:</p><pre class="programlisting">        &gt; !!false; &#13;
        false &#13;
</pre><p>As you'd expect, single negation returns the opposite:</p><pre class="programlisting">        &gt; !false; &#13;
        true &#13;
        &gt; !true; &#13;
        false &#13;
</pre><p>You can test with any string and it will cast to a Boolean <code class="literal">true</code>, except the empty string:</p><pre class="programlisting">        &gt; !!"hello"; &#13;
        true &#13;
        &gt; !!"0"; &#13;
        true &#13;
        &gt; !!""; &#13;
        false &#13;
</pre><p>The output after executing <code class="literal">undefined</code> is as follows:</p><pre class="programlisting">        &gt; !!undefined; &#13;
        false &#13;
</pre><p>Here <code class="literal">undefined</code> is one of the falsy values and it casts to <code class="literal">false</code>. You can try with any of the other falsy values, such the empty string <code class="literal">""</code> in the previous example, <code class="literal">NaN</code>, or <code class="literal">0</code>.</p><pre class="programlisting">        &gt; typeof -Infinity; &#13;
        "number" &#13;
</pre><p>The number type includes all numbers, <code class="literal">NaN</code>, positive and negative <code class="literal">Infinity</code>.</p><p>The output after executing the following is:</p><pre class="programlisting">        &gt; 10 % "0"; &#13;
        NaN &#13;
</pre><p>The string <code class="literal">"0"</code> is cast to the number <code class="literal">0</code>. Division by <code class="literal">0</code> is <code class="literal">Infinity</code>, which has no remainder.</p><p>The output after executing the following is:</p><pre class="programlisting">        &gt; undefined == null; &#13;
        true &#13;
</pre><p>Comparison with <code class="literal">==</code> operator doesn't check the types, but converts the operands; in this case both are falsy values. Strict comparison checks the types too:</p><pre class="programlisting">        &gt; undefined === null; &#13;
        false &#13;
</pre><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; false === ""; &#13;
        false &#13;
</pre><p>Strict comparison between different types (in this case Boolean and string) is doomed to fail, no matter what the values are.</p><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; typeof "2E+2"; &#13;
        "string" &#13;
</pre><p>Anything in quotes is a string, even though:</p><pre class="programlisting">        &gt; 2E+2; &#13;
        200 &#13;
        &gt; typeof 2E+2; &#13;
        "number" &#13;
</pre><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; a = 3e+3; a++; &#13;
        3000 &#13;
</pre><p>
<code class="literal">3e+3</code> is <code class="literal">3</code> with three zeroes, meaning <code class="literal">3000</code>. Then <code class="literal">++</code> is a post-increment, meaning it returns the old value and then it increments it and assigns it to <code class="literal">a</code>. That's why you get the return value <code class="literal">3000</code> in the console, although <code class="literal">a</code> is now <code class="literal">3001</code>:</p><pre class="programlisting">        &gt; a; &#13;
        3001 &#13;
</pre></li><li class="listitem">The value of <code class="literal">v</code> after executing the following is:<pre class="programlisting">        &gt; var v = v || 10; &#13;
        &gt; v; &#13;
        10 &#13;
</pre><p>If <code class="literal">v</code> has never been declared, it's <code class="literal">undefined</code> so this is the same as:</p><pre class="programlisting">        &gt; var v = undefined || 10; &#13;
        &gt; v; &#13;
        10 &#13;
</pre><p>However, if <code class="literal">v</code> has already been defined and initialized with a non-falsy value, you'll get the previous value.</p><pre class="programlisting">        &gt; var v = 100; &#13;
        &gt; var v = v || 10; &#13;
        &gt; v; &#13;
        100 &#13;
</pre><p>The second use of <code class="literal">var</code> doesn't "reset" the variable.</p><p>If <code class="literal">v</code> was already a falsy value (not a <code class="literal">100</code>), the check <code class="literal">v || 10</code> will return <code class="literal">10</code>.</p><pre class="programlisting">        &gt; var v = 0; &#13;
        &gt; var v = v || 10; &#13;
        &gt; v; &#13;
        10 &#13;
</pre></li><li class="listitem">For printing multiplication tables, perform the following:<pre class="programlisting">        for (var i = 1; i &lt;= 12; i++) { &#13;
          for (var j = 1; j &lt;= 12; j++) { &#13;
            console.log(i + ' * ' + j + ' = ' + i * j); &#13;
          } &#13;
        } &#13;
</pre><p>Or:</p><pre class="programlisting">        var i = 1, j = 1; &#13;
        while (i &lt;= 12) { &#13;
          while (j &lt;= 12) { &#13;
            console.log(i + ' * ' + j + ' = ' + i * j); &#13;
            j++; &#13;
          } &#13;
          i++; &#13;
          j = 1; &#13;
        } &#13;
</pre></li></ol></div></div></div></div>
<div class="section" title="Chapter 3, Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec112"/>Chapter 3, Functions</h1></div></div></div><p>Lets do the following exercises:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec198"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To convert Hex colors to RGB, perform the following:<pre class="programlisting">        function getRGB(hex) { &#13;
          return "rgb(" + &#13;
            parseInt(hex[1] + hex[2], 16) + ", " + &#13;
            parseInt(hex[3] + hex[4], 16) + ", " + &#13;
            parseInt(hex[5] + hex[6], 16) + ")"; &#13;
        } &#13;
        Testing: &#13;
        &gt; getRGB("#00ff00"); &#13;
               "rgb(0, 255, 0)" &#13;
        &gt; getRGB("#badfad"); &#13;
               "rgb(186, 223, 173)" &#13;
</pre><p>One problem with this solution is that array access to strings like <code class="literal">hex[0]</code> is not in ECMAScript 3, although many browsers have supported it for a long time and is now described in ES5.</p><p>However, But at this point in the book, there was as yet no discussion of objects and methods. Otherwise an ES3-compatible solution would be to use one of the string methods, such as <code class="literal">charAt()</code>, <code class="literal">substring()</code>, or <code class="literal">slice()</code>. You can also use an array to avoid too much string concatenation:</p><pre class="programlisting">    function getRGB2(hex) { &#13;
      var result = []; &#13;
      result.push(parseInt(hex.slice(1, 3), 16)); &#13;
      result.push(parseInt(hex.slice(3, 5), 16)); &#13;
      result.push(parseInt(hex.slice(5), 16)); &#13;
      return "rgb(" + result.join(", ") + ")"; &#13;
    } &#13;
</pre><p>
<span class="strong"><strong>Bonus exercise</strong></span>: Rewrite the preceding function using a loop so you don't have to type <code class="literal">parseInt()</code> three times, but just once.</p></li><li class="listitem">The result is as follows:<pre class="programlisting">        &gt; parseInt(1e1); &#13;
        10 &#13;
        Here, you're parsing something that is already an integer: &#13;
        &gt; parseInt(10); &#13;
        10 &#13;
        &gt; 1e1; &#13;
        10 &#13;
</pre><p>Here, the parsing of a string gives up on the first non-integer value. <code class="literal">parseInt()</code> doesn't understand exponential literals, it expects integer notation:</p><pre class="programlisting">        &gt; parseInt('1e1'); &#13;
        1 &#13;
</pre><p>This is parsing the string <code class="literal">'1e1'</code> while expecting it to be in decimal notation, including exponential:</p><pre class="programlisting">        &gt; parseFloat('1e1'); &#13;
        10 &#13;
</pre><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; isFinite(0 / 10); &#13;
        true &#13;
</pre><p>Because <code class="literal">0/10</code> is <code class="literal">0</code> and <code class="literal">0</code> is finite.</p><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; isFinite(20 / 0); &#13;
        false &#13;
</pre><p>Because division by <code class="literal">0</code> is <code class="literal">Infinity</code>:</p><pre class="programlisting">        &gt; 20 / 0; &#13;
        Infinity &#13;
</pre><p>The following is the code line and its output:</p><pre class="programlisting">        &gt; isNaN(parseInt(NaN)); &#13;
        true &#13;
</pre><p>Parsing the special <code class="literal">NaN</code> value is <code class="literal">NaN</code>.</p></li><li class="listitem">What is the result of:<pre class="programlisting">        var a = 1; &#13;
        function f() { &#13;
          function n() { &#13;
            alert(a); &#13;
          } &#13;
          var a = 2; &#13;
          n(); &#13;
        } &#13;
        f(); &#13;
</pre><p>This snippet alerts <code class="literal">2</code> even though <code class="literal">n()</code> was defined before the assignment, <code class="literal">a = 2</code>. Inside the function <code class="literal">n()</code> you see the variable <code class="literal">a</code> that is in the same scope, and you access its most recent value at the time invocation of <code class="literal">f()</code> (and hence <code class="literal">n()</code>). Due to hoisting <code class="literal">f()</code> acts as if it was:</p><pre class="programlisting">        function f() { &#13;
          var a; &#13;
          function n() { &#13;
            alert(a); &#13;
          } &#13;
          a = 2; &#13;
          n(); &#13;
        } &#13;
</pre><p>More interestingly, consider this code:</p><pre class="programlisting">        var a = 1; &#13;
        function f() { &#13;
          function n() { &#13;
            alert(a); &#13;
          } &#13;
          n(); &#13;
          var a = 2; &#13;
          n(); &#13;
        } &#13;
        f(); &#13;
</pre><p>It alerts <code class="literal">undefined</code> and then <code class="literal">2</code>. You might expect the first alert to say <code class="literal">1</code>, but again due to variable hoisting, the declaration (not initialization) of <code class="literal">a</code> is moved to the top of the function. As if <code class="literal">f()</code> was:</p><pre class="programlisting">        var a = 1; &#13;
        function f() { &#13;
          var a; // a is now undefined &#13;
          function n() { &#13;
            alert(a); &#13;
          } &#13;
          n(); // alert undefined &#13;
          a = 2; &#13;
          n(); // alert 2 &#13;
        } &#13;
        f(); &#13;
</pre><p>The local <code class="literal">a</code> "shadows" the global <code class="literal">a</code>, even if it's at the bottom.</p></li><li class="listitem">Why all these alert "Boo!"<p>The following is the result of Example 1:</p><pre class="programlisting">        var f = alert; &#13;
        eval('f("Boo!")'); &#13;
</pre><p>The following is the result of Example 2. You can assign a function to a different variable. So <code class="literal">f()</code> points to <code class="literal">alert()</code>. Evaluating this string is like doing:</p><pre class="programlisting">        &gt; f("Boo"); &#13;
</pre><p>The following is the output after we execute <code class="literal">eval()</code>:</p><pre class="programlisting">        var e; &#13;
        var f = alert; &#13;
        eval('e=f')('Boo!'); &#13;
</pre><p>The following is the output of Example 3. <code class="literal">eval()</code> returns the result on the evaluation. In this case it's an assignment <code class="literal">e = f</code> that also returns the new value of <code class="literal">e</code>. Like the following:</p><pre class="programlisting">        &gt; var a = 1; &#13;
        &gt; var b; &#13;
        &gt; var c = (b = a); &#13;
        &gt; c; &#13;
        1 &#13;
</pre><p>So <code class="literal">eval('e=f')</code> gives you a pointer to <code class="literal">alert()</code> that is executed immediately with <code class="literal">"Boo!"</code>.</p><p>The immediate (self-invoking) anonymous function returns a pointer to the function <code class="literal">alert()</code>, which is also immediately invoked with a parameter <code class="literal">"Boo!"</code>:</p><pre class="programlisting">        (function(){ &#13;
          return alert; &#13;
        })()('Boo!'); &#13;
</pre></li></ol></div></div></div>
<div class="section" title="Chapter 4, Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec113"/>Chapter 4, Objects</h1></div></div></div><p>Lets solve the following exercises:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec199"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">What happens here? What is <code class="literal">this</code> and what's <code class="literal">o</code>?<pre class="programlisting">        function F() { &#13;
          function C() { &#13;
            return this; &#13;
          } &#13;
          return C(); &#13;
        } &#13;
        var o = new F(); &#13;
</pre><p>Here, <code class="literal">this === window</code> because <code class="literal">C()</code> was called without <code class="literal">new</code>.</p><p>Also <code class="literal">o === window</code> because <code class="literal">new F()</code> returns the object returned by <code class="literal">C()</code>, which is <code class="literal">this</code>, and <code class="literal">this</code> is <code class="literal">window</code>.</p><p>You can make the call to <code class="literal">C()</code> a constructor call:</p><pre class="programlisting">        function F() { &#13;
          function C() { &#13;
            return this; &#13;
          } &#13;
          return new C(); &#13;
        } &#13;
        var o = new F(); &#13;
</pre><p>Here, <code class="literal">this</code> is the object created by the <code class="literal">C()</code> constructor. So is <code class="literal">o</code>:</p><pre class="programlisting">        &gt; o.constructor.name; &#13;
        "C" &#13;
</pre><p>It becomes more interesting with ES5's strict mode. In the strict mode, non-constructor invocations result in <code class="literal">this</code> being <code class="literal">undefined</code>, not the global object. With <code class="literal">"use strict"</code> inside <code class="literal">F()</code> or <code class="literal">C()</code> constructor's body, <code class="literal">this</code> would be <code class="literal">undefined</code> in <code class="literal">C()</code>. Therefore, <code class="literal">return C()</code> cannot return the non-object <code class="literal">undefined</code> (because all constructor invocations return some sort of object) and returns <code class="literal">F</code> instances' <code class="literal">this</code> (which is in the closure scope). Try it:</p><pre class="programlisting">        function F() { &#13;
          "use strict"; &#13;
          this.name = "I am F()"; &#13;
          function C() { &#13;
            console.log(this); // undefined &#13;
            return this; &#13;
          } &#13;
          return C(); &#13;
        } &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; var o = new F(); &#13;
        &gt; o.name; &#13;
        "I am F()" &#13;
</pre></li><li class="listitem">What happens when invoking this constructor with <code class="literal">new</code>?<pre class="programlisting">        function C() { &#13;
          this.a = 1; &#13;
          return false; &#13;
        } &#13;
        And testing: &#13;
        &gt; typeof new C(); &#13;
        "object" &#13;
        &gt; new C().a; &#13;
         1 &#13;
</pre><p>
<code class="literal">new C()</code> is an object, not Boolean, because constructor invocations always produce an object. It's the <code class="literal">this</code> object you get unless you return some other object in your constructor. Returning non-objects doesn't work and you still get <code class="literal">this</code>.</p></li><li class="listitem">What does this do?<pre class="programlisting">        &gt; var c = [1, 2, [1, 2]]; &#13;
        &gt; c.sort(); &#13;
        &gt; c; &#13;
         [1, Array[2], 2] &#13;
</pre><p>This is because <code class="literal">sort()</code> compares strings. <code class="literal">[1, 2].toString()</code> is <code class="literal">"1,2"</code>, so it comes after <code class="literal">"1"</code> and before <code class="literal">"2"</code>.</p><p>The same thing with <code class="literal">join()</code>:</p><pre class="programlisting">        &gt; c.join('--'); &#13;
        &gt; c; &#13;
        "1--1,2--2" &#13;
</pre></li><li class="listitem">Pretend <code class="literal">String()</code> doesn't exist and create <code class="literal">MyString()</code> mimicking <code class="literal">String()</code>. Treat the input primitive strings as arrays (array access officially supported in ES5).<p>Here's a sample implementation with just the methods the exercise asked for. Feel free to continue with the rest of the methods. Refer to <a class="link" href="apc.html" title="Appendix C. Built-in Objects">Appendix C</a>, <span class="emphasis"><em>Built-in Objects</em></span> for the full list.</p><pre class="programlisting">        function MyString(input) { &#13;
          var index = 0; &#13;
 &#13;
          // cast to string &#13;
          this._value = '' + input; &#13;
 &#13;
          // set all numeric properties for array access &#13;
          while (input[index] !== undefined) { &#13;
            this[index] = input[index]; &#13;
            index++; &#13;
          } &#13;
 &#13;
          // remember the length &#13;
          this.length = index; &#13;
        } &#13;
 &#13;
        MyString.prototype = { &#13;
          constructor: MyString, &#13;
          valueOf: function valueOf() { &#13;
            return this._value; &#13;
          }, &#13;
          toString: function toString() { &#13;
            return this.valueOf(); &#13;
          }, &#13;
          charAt: function charAt(index) { &#13;
            return this[parseInt(index, 10) || 0]; &#13;
          }, &#13;
          concat: function concat() { &#13;
            var prim = this.valueOf(); &#13;
            for (var i = 0, len = arguments.length; i &lt; len; i++) { &#13;
              prim += arguments[i]; &#13;
            } &#13;
            return prim; &#13;
          }, &#13;
          slice: function slice(from, to) { &#13;
            var result = '', &#13;
                original = this.valueOf(); &#13;
            if (from === undefined) { &#13;
              return original; &#13;
            } &#13;
            if (from &gt; this.length) { &#13;
              return result; &#13;
            } &#13;
            if (from &lt; 0) { &#13;
              from = this.length - from; &#13;
            } &#13;
            if (to === undefined || to &gt; this.length) { &#13;
              to = this.length; &#13;
            } &#13;
            if (to &lt; 0) { &#13;
              to = this.length + to; &#13;
            } &#13;
            // end of validation, actual slicing loop now &#13;
            for (var i = from; i &lt; to; i++) { &#13;
              result += original[i]; &#13;
            } &#13;
            return result; &#13;
          }, &#13;
          split: function split(re) { &#13;
            var index = 0, &#13;
               result = [], &#13;
                original = this.valueOf(), &#13;
                match, &#13;
                pattern = '', &#13;
                modifiers = 'g'; &#13;
 &#13;
            if (re instanceof RegExp) { &#13;
              // split with regexp but always set "g" &#13;
              pattern = re.source; &#13;
              modifiers += re.multiline  ? 'm' : ''; &#13;
              modifiers += re.ignoreCase ? 'i' : ''; &#13;
            } else { &#13;
              // not a regexp, probably a string, we'll convert it &#13;
              pattern = re; &#13;
            } &#13;
            re = RegExp(pattern, modifiers); &#13;
 &#13;
            while (match = re.exec(original)) { &#13;
              result.push(this.slice(index, match.index)); &#13;
              index = match.index + new MyString(match[0]).length; &#13;
            } &#13;
            result.push(this.slice(index)); &#13;
            return result; &#13;
           } &#13;
        }; &#13;
</pre><p>Testing:</p><pre class="programlisting">         &gt; var s = new MyString('hello'); &#13;
        &gt; s.length; &#13;
         5 &#13;
        &gt; s[0]; &#13;
        "h" &#13;
         &gt; s.toString(); &#13;
         "hello" &#13;
        &gt; s.valueOf(); &#13;
         "hello" &#13;
        &gt; s.charAt(1); &#13;
         "e" &#13;
        &gt; s.charAt('2'); &#13;
        "l" &#13;
        &gt; s.charAt('e'); &#13;
        "h" &#13;
        &gt; s.concat(' world!'); &#13;
        "hello world!" &#13;
        &gt; s.slice(1, 3); &#13;
        "el" &#13;
        &gt; s.slice(0, -1); &#13;
        "hell" &#13;
        &gt; s.split('e'); &#13;
         ["h", "llo"] &#13;
        &gt; s.split('l'); &#13;
         ["he", "", "o"] &#13;
</pre><p>Feel free to play splitting with a regular expression.</p></li><li class="listitem">Update <code class="literal">MyString()</code> with a <code class="literal">reverse()</code> method:<pre class="programlisting">        &gt; MyString.prototype.reverse = function reverse() { &#13;
            return this.valueOf().split("").reverse().join(""); &#13;
          }; &#13;
        &gt; new MyString("pudding").reverse(); &#13;
         "gniddup" &#13;
</pre></li><li class="listitem">Imagine <code class="literal">Array()</code> is gone and the world needs you to implement <code class="literal">MyArray()</code>. Here are a handful of methods to get you started:<pre class="programlisting">        function MyArray(length) { &#13;
          // single numeric argument means length &#13;
          if (typeof length === 'number' &amp;&amp; &#13;
              arguments[1] === undefined) { &#13;
            this.length = length; &#13;
            return this; &#13;
          } &#13;
   &#13;
          // usual case &#13;
           this.length = arguments.length; &#13;
          for (var i = 0, len = arguments.length; i &lt; len; i++) { &#13;
            this[i] = arguments[i]; &#13;
          } &#13;
          return this; &#13;
   &#13;
          // later in the book you'll learn how to support &#13;
          // a non-constructor invocation too &#13;
        } &#13;
 &#13;
        MyArray.prototype = { &#13;
          constructor: MyArray, &#13;
          join: function join(glue) { &#13;
            var result = ''; &#13;
            if (glue === undefined) { &#13;
              glue = ','; &#13;
            } &#13;
            for (var i = 0; i &lt; this.length - 1; i++) { &#13;
              result += this[i] === undefined ? '' : this[i]; &#13;
              result += glue; &#13;
            } &#13;
            result += this[i] === undefined ? '' : this[i]; &#13;
            return result; &#13;
          }, &#13;
          toString: function toString() { &#13;
            return this.join(); &#13;
          }, &#13;
          push: function push() { &#13;
            for (var i = 0, len = arguments.length; i &lt; len; i++) { &#13;
              this[this.length + i] = arguments[i]; &#13;
            } &#13;
            this.length += arguments.length; &#13;
            return this.length; &#13;
          }, &#13;
          pop: function pop() { &#13;
            var poppd = this[this.length - 1]; &#13;
            delete this[this.length - 1]; &#13;
            this.length--; &#13;
            return poppd; &#13;
          } &#13;
        }; &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; var a = new MyArray(1, 2, 3, "test"); &#13;
        &gt; a.toString(); &#13;
        "1,2,3,test" &#13;
        &gt; a.length; &#13;
         4 &#13;
        &gt; a[a.length - 1]; &#13;
        "test" &#13;
        &gt; a.push('boo'); &#13;
         5 &#13;
        &gt; a.toString(); &#13;
        "1,2,3,test,boo" &#13;
        &gt; a.pop(); &#13;
        "boo" &#13;
        &gt; a.toString(); &#13;
        "1,2,3,test" &#13;
        &gt; a.join(','); &#13;
        "1,2,3,test" &#13;
        &gt; a.join(' isn't '); &#13;
        "1 isn't 2 isn't 3 isn't test" &#13;
</pre><p>If you found this exercise amusing, don't stop with <code class="literal">join()</code>; go on with as many methods as possible.</p></li><li class="listitem">Create <code class="literal">MyMath</code> object that also has <code class="literal">rand()</code>, <code class="literal">min([])</code>, <code class="literal">max([])</code>.<p>The point here is that <code class="literal">Math</code> is not a constructor, but an object that has some "static" properties and methods. Below are some methods to get you started.</p><p>Let's also use an immediate function to keep some private utility functions. You can also take this approach with <code class="literal">MyString</code> above, where <code class="literal">this._value</code> could be really private.</p><pre class="programlisting">        var MyMath = (function () { &#13;
 &#13;
         function isArray(ar) { &#13;
            return &#13;
              Object.prototype.toString.call(ar) === &#13;
                '[object Array]'; &#13;
         } &#13;
 &#13;
          function sort(numbers) { &#13;
            // not using numbers.sort() directly because &#13;
            // `arguments` is not an array and doesn't have sort() &#13;
            return Array.prototype.sort.call(numbers, function (a, b) { &#13;
              if (a === b) { &#13;
                return 0; &#13;
              } &#13;
              return  1 * (a &gt; b) - 0.5; // returns 0.5 or -0.5 &#13;
           }); &#13;
          } &#13;
 &#13;
          return { &#13;
            PI:   3.141592653589793, &#13;
            E:    2.718281828459045, &#13;
            LN10: 2.302585092994046, &#13;
            LN2:  0.6931471805599453, &#13;
            // ... more constants &#13;
            max: function max() { &#13;
              // allow unlimited number of arguments &#13;
              // or an array of numbers as first argument &#13;
              var numbers = arguments; &#13;
              if (isArray(numbers[0])) { &#13;
                numbers = numbers[0]; &#13;
              } &#13;
              // we can be lazy:  &#13;
              // let Array sort the numbers and pick the last &#13;
              return sort(numbers)[numbers.length - 1]; &#13;
            }, &#13;
            min: function min() { &#13;
              // different approach to handling arguments: &#13;
              // call the same function again &#13;
              if (isArray(numbers)) { &#13;
                return this.min.apply(this, numbers[0]); &#13;
              } &#13;
 &#13;
              // Different approach to picking the min: &#13;
              // sorting the array is an overkill, it's too much  &#13;
              // work since we don't worry about sorting but only  &#13;
              // about the smallest number. &#13;
              // So let's loop: &#13;
              var min = numbers[0]; &#13;
              for (var i = 1; i &lt; numbers.length; i++) { &#13;
                if (min &gt; numbers[i]) { &#13;
                  min = numbers[i]; &#13;
                } &#13;
             } &#13;
              return min; &#13;
            }, &#13;
            rand: function rand(min, max, inclusive) { &#13;
              if (inclusive) { &#13;
                return Math.round(Math.random() * (max - min) + min); &#13;
                // test boundaries for random number &#13;
                // between 10 and 100 *inclusive*: &#13;
                // Math.round(0.000000 * 90 + 10); // 10 &#13;
                // Math.round(0.000001 * 90 + 10); // 10 &#13;
                // Math.round(0.999999 * 90 + 10); // 100 &#13;
 &#13;
              } &#13;
              return Math.floor(Math.random() * (max - min - 1) + min + 1); &#13;
              // test boundaries for random number &#13;
              // between 10 and 100 *non-inclusive*: &#13;
              // Math.floor(0.000000 * (89) + (11)); // 11 &#13;
              // Math.floor(0.000001 * (89) + (11)); // 11 &#13;
              // Math.floor(0.999999 * (89) + (11)); // 99 &#13;
            } &#13;
          }; &#13;
        })(); &#13;
</pre><p>After you have finished the book and know about ES5 you can try using <code class="literal">defineProperty()</code> for tighter control and closer replication of the built-ins.</p></li></ol></div></div></div>
<div class="section" title="Chapter 5, Prototype"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec114"/>Chapter 5, Prototype</h1></div></div></div><p>Lets try and solve the following exercise:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec200"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an object called <code class="literal">shape</code> that has a <code class="literal">type</code> property and a <code class="literal">getType()</code> method:<pre class="programlisting">        var shape = { &#13;
          type: 'shape', &#13;
          getType: function () { &#13;
            return this.type; &#13;
          } &#13;
        }; &#13;
</pre></li><li class="listitem">The following is the program for a <code class="literal">Triangle ()</code> constructor:<pre class="programlisting">        function Triangle(a, b, c) { &#13;
          this.a = a; &#13;
          this.b = b; &#13;
          this.c = c; &#13;
        } &#13;
 &#13;
        Triangle.prototype = shape; &#13;
        Triangle.prototype.constructor = Triangle; &#13;
        Triangle.prototype.type = 'triangle'; &#13;
</pre></li><li class="listitem">To add the <code class="literal">getPerimeter()</code> method, use the following code:<pre class="programlisting">        Triangle.prototype.getPerimeter = function () { &#13;
          return this.a + this.b + this.c; &#13;
        }; &#13;
</pre></li><li class="listitem">Test the following code:<pre class="programlisting">        &gt; var t = new Triangle(1, 2, 3); &#13;
        &gt; t.constructor === Triangle; &#13;
        true &#13;
        &gt; shape.isPrototypeOf(t); &#13;
        true &#13;
        &gt; t.getPerimeter(); &#13;
        6 &#13;
        &gt; t.getType(); &#13;
        "triangle" &#13;
</pre></li><li class="listitem">Loop over <code class="literal">t</code> showing only own properties and methods:<pre class="programlisting">        for (var i in t) { &#13;
          if (t.hasOwnProperty(i)) { &#13;
            console.log(i, '=', t[i]); &#13;
         } &#13;
        } &#13;
</pre></li><li class="listitem">Randomize array elements using the following code snippet:<pre class="programlisting">        Array.prototype.shuffle = function () { &#13;
          return this.sort(function () { &#13;
            return Math.random() - 0.5; &#13;
          }); &#13;
        }; &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; [1, 2, 3, 4, 5, 6, 7, 8, 9].shuffle(); &#13;
         [4, 2, 3, 1, 5, 6, 8, 9, 7] &#13;
        &gt; [1, 2, 3, 4, 5, 6, 7, 8, 9].shuffle(); &#13;
         [2, 7, 1, 3, 4, 5, 8, 9, 6] &#13;
        &gt; [1, 2, 3, 4, 5, 6, 7, 8, 9].shuffle(); &#13;
         [4, 2, 1, 3, 5, 6, 8, 9, 7] &#13;
</pre></li></ol></div></div></div>
<div class="section" title="Chapter 6, Inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec115"/>Chapter 6, Inheritance</h1></div></div></div><p>Lets solve the following exercise:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec201"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Multiple inheritance by mixing into the prototype, for example:<pre class="programlisting">        var my = objectMulti(obj, another_obj, a_third, { &#13;
          additional: "properties" &#13;
        }); &#13;
        A possible solution: &#13;
        function objectMulti() { &#13;
          var Constr, i, prop, mixme; &#13;
 &#13;
        // constructor that sets own properties &#13;
        var Constr = function (props) { &#13;
          for (var prop in props) { &#13;
            this[prop] = props[prop]; &#13;
          } &#13;
        }; &#13;
 &#13;
       // mix into the prototype &#13;
       for (var i = 0; i &lt; arguments.length - 1; i++) { &#13;
         var mixme = arguments[i]; &#13;
         for (var prop in mixme) { &#13;
           Constr.prototype[prop] = mixme[prop]; &#13;
         } &#13;
       } &#13;
 &#13;
      return new Constr(arguments[arguments.length - 1]);&#13;
   } &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; var obj_a = {a: 1}; &#13;
        &gt; var obj_b = {a: 2, b: 2}; &#13;
        &gt; var obj_c = {c: 3}; &#13;
        &gt; var my = objectMulti(obj_a, obj_b, obj_c, {hello: "world"}); &#13;
        &gt; my.a; &#13;
         2 &#13;
</pre><p>Property <code class="literal">a</code> is <code class="literal">2</code> because <code class="literal">obj_b</code> overwrote the property with the same name from <code class="literal">obj_a</code> (last one wins):</p><pre class="programlisting">        &gt; my.b; &#13;
        2 &#13;
        &gt; my.c; &#13;
        3 &#13;
        &gt; my.hello; &#13;
        "world" &#13;
        &gt; my.hasOwnProperty('a'); &#13;
        false &#13;
        &gt; my.hasOwnProperty('hello'); &#13;
        true &#13;
</pre></li><li class="listitem">Practice with the canvas example at <a class="ulink" href="http://www.phpied.com/files/canvas/">http://www.phpied.com/files/canvas/</a>.<p>Draw a few triangles using the following code snippet:</p><pre class="programlisting">        new Triangle( &#13;
          new Point(100, 155), &#13;
          new Point(30, 50), &#13;
          new Point(220, 00)).draw(); &#13;
 &#13;
        new Triangle( &#13;
          new Point(10, 15),   &#13;
          new Point(300, 50), &#13;
          new Point(20, 400)).draw(); &#13;
</pre><p>Draw a few squares using the following code snippet:</p><pre class="programlisting">        new Square(new Point(150, 150), 300).draw(); &#13;
        new Square(new Point(222, 222), 222).draw(); &#13;
</pre><p>Draw a few rectangles using the following code snippet:</p><pre class="programlisting">        new Rectangle(new Point(100, 10), 200, 400).draw(); &#13;
        new Rectangle(new Point(400, 200), 200, 100).draw(); &#13;
</pre></li><li class="listitem">To add Rhombus, Kite, Pentagon, Trapezoid, and Circle (reimplements <code class="literal">draw()</code>), use the following code:<pre class="programlisting">        function Kite(center, diag_a, diag_b, height) { &#13;
          this.points = [ &#13;
            new Point(center.x - diag_a / 2, center.y), &#13;
            new Point(center.x, center.y + (diag_b - height)), &#13;
            new Point(center.x + diag_a / 2, center.y), &#13;
            new Point(center.x, center.y - height) &#13;
          ]; &#13;
          this.getArea = function () { &#13;
            return diag_a * diag_b / 2; &#13;
          }; &#13;
        } &#13;
 &#13;
        function Rhombus(center, diag_a, diag_b) { &#13;
          Kite.call(this, center, diag_a, diag_b, diag_b / 2); &#13;
        } &#13;
 &#13;
        function Trapezoid(p1, side_a, p2, side_b) { &#13;
          this.points = [p1, p2, new Point(p2.x + side_b, p2.y),&#13;
          new Point(p1.x + side_a, p1.y) &#13;
          ]; &#13;
 &#13;
          this.getArea = function () { &#13;
            var height = p2.y - p1.y; &#13;
            return height * (side_a + side_b) / 2; &#13;
          }; &#13;
        } &#13;
   &#13;
        // regular pentagon, all edges have the same length &#13;
        function Pentagon(center, edge) { &#13;
          var r = edge / (2 * Math.sin(Math.PI / 5)), &#13;
              x = center.x, &#13;
              y = center.y; &#13;
 &#13;
          this.points = [new Point(x + r, y),&#13;
        new Point(x + r * Math.cos(2 * Math.PI / 5), y - r * &#13;
         Math.sin(2 * Math.PI / 5)), &#13;
        new Point(x - r * Math.cos(    Math.PI / 5), y - r * &#13;
         Math.sin(    Math.PI / 5)), &#13;
        new Point(x - r * Math.cos(    Math.PI / 5), y + r * &#13;
         Math.sin(    Math.PI / 5)), &#13;
        new Point(x + r * Math.cos(2 * Math.PI / 5), y + r * &#13;
         Math.sin(2 * Math.PI / 5)) &#13;
          ]; &#13;
 &#13;
          this.getArea = function () { &#13;
            return 1.72 * edge * edge; &#13;
          }; &#13;
        } &#13;
 &#13;
        function Circle(center, radius) { &#13;
          this.getArea = function () { &#13;
            return Math.pow(radius, 2) * Math.PI; &#13;
          }; &#13;
   &#13;
          this.getPerimeter = function () { &#13;
            return 2 * radius * Math.PI; &#13;
          };   &#13;
   &#13;
          this.draw = function () { &#13;
            var ctx = this.context; &#13;
            ctx.beginPath(); &#13;
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI); &#13;
            ctx.stroke(); &#13;
          }; &#13;
        } &#13;
 &#13;
        (function () { &#13;
          var s = new Shape(); &#13;
          Kite.prototype = s; &#13;
          Rhombus.prototype = s; &#13;
          Trapezoid.prototype = s; &#13;
          Pentagon.prototype = s; &#13;
          Circle.prototype = s; &#13;
        }()); &#13;
</pre><p>Testing:</p><pre class="programlisting">        new Kite(new Point(300, 300), 200, 300, 100).draw(); &#13;
        new Rhombus(new Point(200, 200), 350, 200).draw(); &#13;
        new Trapezoid( &#13;
          new Point(100, 100), 100,  &#13;
          new Point(50, 250), 400).draw(); &#13;
        new Pentagon(new Point(400, 400), 100).draw(); &#13;
        new Circle(new Point(500, 300), 270).draw(); &#13;
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_69_001.jpg" alt="Exercises"/></div><p>
</p><p>The result of testing new shapes</p></li><li class="listitem">Think of another way to do the inheritance part. Use <code class="literal">uber</code> so kids can have access to their parents. Also, get parents to be aware of their children.<p>Keep in mind that not all children inherit <code class="literal">Shape</code>; for example, <code class="literal">Rhombus</code> inherits <code class="literal">Kite</code> and <code class="literal">Square</code> inherits <code class="literal">Rectangle</code>. You end up with something like this:</p><pre class="programlisting">        // inherit(Child, Parent) &#13;
        inherit(Rectangle, Shape); &#13;
        inherit(Square, Rectangle); &#13;
</pre><p>In the inheritance pattern from the chapter and the previous exercise, all children were sharing the same prototype, for example:</p><pre class="programlisting">        var s = new Shape(); &#13;
        Kite.prototype = s; &#13;
        Rhombus.prototype = s; &#13;
</pre><p>While this is convenient, it also means no one can touch the prototype because it will affect everyone else's prototype. The drawback is that all custom methods need to own properties, for example <code class="literal">this.getArea</code>.</p><p>It's a good idea to have methods shared among instances and defined in the prototype, instead of recreating them for every object. The following example moves the custom <code class="literal">getArea()</code> methods to the prototype.</p><p>In the inheritance function, you'll see the children only inherit the parent's prototype. So own properties such as <code class="literal">this.lines</code> will not be set. Therefore, you need to have each child constructor call its <code class="literal">uber</code> in order to get the own properties, for example:</p><pre class="programlisting">        Child.prototype.uber.call(this, args...) &#13;
</pre><p>Another nice-to-have feature is carrying over the prototype properties already added to the child. This allows the child to inherit first and then add more customizations or the other way around as well, which is just a little more convenient.</p><pre class="programlisting">        function inherit(Child, Parent) { &#13;
          // remember prototype &#13;
          var extensions = Child.prototype; &#13;
 &#13;
          // inheritance with an intermediate F() &#13;
          var F = function () {}; &#13;
           F.prototype = Parent.prototype; &#13;
          Child.prototype = new F(); &#13;
          // reset constructor &#13;
          Child.prototype.constructor = Child; &#13;
          // remember parent &#13;
          Child.prototype.uber = Parent; &#13;
 &#13;
          // keep track of who inherits the Parent &#13;
          if (!Parent.children) { &#13;
            Parent.children = []; &#13;
          } &#13;
          Parent.children.push(Child); &#13;
 &#13;
          // carry over stuff previsouly added to the prototype &#13;
          // because the prototype is now overwritten completely &#13;
          for (var i in extensions) { &#13;
            if (extensions.hasOwnProperty(i)) { &#13;
              Child.prototype[i] = extensions[i]; &#13;
            } &#13;
          } &#13;
        } &#13;
</pre><p>Everything about <code class="literal">Shape()</code>, <code class="literal">Line()</code>, and <code class="literal">Point()</code> stays the same. The changes are in the children only:</p><pre class="programlisting">        function Triangle(a, b, c) { &#13;
          Triangle.prototype.uber.call(this); &#13;
          this.points = [a, b, c]; &#13;
        } &#13;
 &#13;
        Triangle.prototype.getArea = function () { &#13;
          var p = this.getPerimeter(), s = p / 2; &#13;
          return Math.sqrt(s * (s - this.lines[0].length) * &#13;
        (s - this.lines[1].length) * (s - this.lines[2].length)); &#13;
        }; &#13;
 &#13;
 &#13;
        function Rectangle(p, side_a, side_b) { &#13;
          // calling parent Shape() &#13;
          Rectangle.prototype.uber.call(this); &#13;
 &#13;
          this.points = [ p, &#13;
            new Point(p.x + side_a, p.y), &#13;
            new Point(p.x + side_a, p.y + side_b), &#13;
            new Point(p.x, p.y + side_b) &#13;
          ]; &#13;
        } &#13;
 &#13;
       Rectangle.prototype.getArea = function () { &#13;
           // Previsouly we had access to side_a and side_b  &#13;
           // inside the constructor closure. No more. &#13;
          // option 1: add own properties this.side_a and this.side_b &#13;
          // option 2: use what we already have: &#13;
          var lines = this.getLines(); &#13;
          return lines[0].length * lines[1].length; &#13;
        }; &#13;
 &#13;
 &#13;
        function Square(p, side) { &#13;
          this.uber.call(this, p, side, side); &#13;
          // this call is shorter than Square.prototype.uber.call() &#13;
          // but may backfire in case you inherit  &#13;
          // from Square and call uber &#13;
          // try it :-) &#13;
        } &#13;
</pre><p>Inheritance:</p><pre class="programlisting">        inherit(Triangle, Shape); &#13;
        inherit(Rectangle, Shape); &#13;
        inherit(Square, Rectangle); &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; var sq = new Square(new Point(0, 0), 100); &#13;
        &gt; sq.draw(); &#13;
        &gt; sq.getArea(); &#13;
        10000 &#13;
</pre><p>Testing that <code class="literal">instanceof</code> is correct:</p><pre class="programlisting">        &gt; sq.constructor === Square; &#13;
        true &#13;
        &gt; sq instanceof Square; &#13;
        true &#13;
        &gt; sq instanceof Rectangle; &#13;
        true &#13;
        &gt; sq instanceof Shape; &#13;
        true &#13;
</pre><p>The <code class="literal">children</code> arrays:</p><pre class="programlisting">        &gt; Shape.children[1] === Rectangle; &#13;
        true &#13;
        &gt; Rectangle.children[0] === Triangle; &#13;
        false &#13;
        &gt; Rectangle.children[0] === Square; &#13;
        true &#13;
        &gt; Square.children; &#13;
        undefined &#13;
</pre><p>And uber looks ok too:</p><pre class="programlisting">        &gt; sq.uber === Rectangle; &#13;
        true &#13;
</pre><p>Calling <code class="literal">isPrototypeOf()</code> also returns expected results:</p><pre class="programlisting">        Shape.prototype.isPrototypeOf(sq); &#13;
        true &#13;
        Rectangle.prototype.isPrototypeOf(sq); &#13;
        true &#13;
        Triangle.prototype.isPrototypeOf(sq); &#13;
        false &#13;
</pre><p>The full code is available at <a class="ulink" href="http://www.phpied.com/files/canvas/index2.html">http://www.phpied.com/files/canvas/index2.html</a>, together with the additional <code class="literal">Kite()</code>, <code class="literal">Circle()</code>, and so on from the previous exercise.</p></li></ol></div></div></div>
<div class="section" title="Chapter 7, The Browser Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch18lvl1sec116"/>Chapter 7, The Browser Environment</h1></div></div></div><p>Lets practice the following exercise:</p><div class="section" title="Exercises"><div class="titlepage"><div><div><h2 class="title"><a id="ch18lvl2sec202"/>Exercises</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The title clock program is as follows:<pre class="programlisting">        setInterval(function () { &#13;
          document.title = new Date().toTimeString(); &#13;
        }, 1000); &#13;
</pre></li><li class="listitem">To animate resizing of a 200 x 200 pop up to 400 x 400, use the following code:<pre class="programlisting">        var w = window.open( &#13;
            'http://phpied.com', 'my', &#13;
             'width = 200, height = 200'); &#13;
 &#13;
        var i = setInterval((function () { &#13;
          var size = 200; &#13;
          return function () { &#13;
            size += 5; &#13;
            w.resizeTo(size, size); &#13;
            if (size === 400) { &#13;
              clearInterval(i); &#13;
            } &#13;
          }; &#13;
        }()), 100); &#13;
</pre><p>Every 100 ms (1/10th of a second) the pop-up size increases by five pixels. You keep a reference to the interval <code class="literal">i</code> so you can clear it once done. The variable <code class="literal">size</code> tracks the pop-up size (and why not keep it private inside a closure).</p></li><li class="listitem">The earthquake program is as follows:<pre class="programlisting">       var i = setInterval((function () { &#13;
          var start = +new Date(); // Date.now() in ES5 &#13;
          return function () { &#13;
            w.moveTo( &#13;
              Math.round(Math.random() * 100), &#13;
              Math.round(Math.random() * 100)); &#13;
            if (new Date() - start &gt; 5000) { &#13;
              clearInterval(i); &#13;
            } &#13;
          }; &#13;
         }()), 20); &#13;
</pre><p>Try all of them, but using <code class="literal">requestAnimationFrame()</code> instead of <code class="literal">setInterval()</code>.</p></li><li class="listitem">A different <code class="literal">walkDOM()</code> with a callback is as follows:<pre class="programlisting">        function walkDOM(n, cb) { &#13;
          cb(n); &#13;
          var i, &#13;
              children = n.childNodes, &#13;
              len = children.length, &#13;
              child; &#13;
          for (i = 0; i &lt; len; i++) { &#13;
          child = n.childNodes[i]; &#13;
            if (child.hasChildNodes()) { &#13;
              walkDOM(child, cb); &#13;
            } &#13;
          } &#13;
        } &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; walkDOM(document.documentElement,&#13;
        console.dir.bind(console)); &#13;
       html &#13;
       head &#13;
       title &#13;
       body &#13;
       h1 &#13;
       ... &#13;
</pre></li><li class="listitem">To remove content and clean up functions, use the following code:<pre class="programlisting">        // helper &#13;
        function isFunction(f) { &#13;
          return Object.prototype.toString.call(f) === &#13;
            "[object Function]"; &#13;
        } &#13;
 &#13;
        function removeDom(node) { &#13;
          var i, len, attr; &#13;
 &#13;
          // first drill down inspecting the children &#13;
          // and only after that remove the current node &#13;
          while (node.firstChild) { &#13;
            removeDom(node.firstChild); &#13;
          } &#13;
 &#13;
          // not all nodes have attributes, e.g. text nodes don't &#13;
          len = node.attributes ? node.attributes.length : 0; &#13;
 &#13;
          // cleanup loop &#13;
          // e.g. node === &lt;body&gt;,  &#13;
          // node.attributes[0].name === "onload" &#13;
          // node.onload === function()... &#13;
          // node.onload is not enumerable so we can't use  &#13;
          // a for-in loop and have to go the attributes route &#13;
          for (i = 0; i &lt; len; i++) { &#13;
            attr = node[node.attributes[i].name]; &#13;
            if (isFunction(attr)) { &#13;
              // console.log(node, attr); &#13;
              attr = null; &#13;
            } &#13;
          } &#13;
 &#13;
          node.parentNode.removeChild(node); &#13;
        } &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; removeDom(document.body); &#13;
</pre></li><li class="listitem">To include scripts dynamically, use the following code:<pre class="programlisting">        function include(url) { &#13;
          var s = document.createElement('script'); &#13;
          s.src = url; &#13;
          document.getElementsByTagName('head')[0].&#13;
          appendChild(s); &#13;
        } &#13;
</pre><p>Testing:</p><pre class="programlisting">        &gt; include("http://www.phpied.com/files/jinc/1.js"); &#13;
        &gt; include("http://www.phpied.com/files/jinc/2.js"); &#13;
</pre></li><li class="listitem"><span class="strong"><strong>Events</strong></span>: The event utility program is as follows:<pre class="programlisting">        var myevent = (function () { &#13;
 &#13;
          // wrap some private stuff in a closure &#13;
          var add, remove, toStr = Object.prototype.toString; &#13;
 &#13;
          // helper &#13;
          function toArray(a) { &#13;
            // already an array &#13;
            if (toStr.call(a) === '[object Array]') { &#13;
              return a; &#13;
           } &#13;
     &#13;
            // duck-typing HTML collections, arguments etc &#13;
            var result, i, len; &#13;
            if ('length' in a) { &#13;
              for (result = [], i = 0, len = a.length; i &lt; len; i++)&#13;
              { &#13;
                result[i] = a[i]; &#13;
              } &#13;
              return result; &#13;
           } &#13;
 &#13;
            // primitives and non-array-like objects &#13;
            // become the first and single array element &#13;
            return [a]; &#13;
          } &#13;
 &#13;
          // define add() and remove() depending &#13;
          // on the browser's capabilities &#13;
          if (document.addEventListener) { &#13;
            add = function (node, ev, cb) { &#13;
              node.addEventListener(ev, cb, false); &#13;
            }; &#13;
            remove = function (node, ev, cb) { &#13;
              node.removeEventListener(ev, cb, false); &#13;
            }; &#13;
          } else if (document.attachEvent) { &#13;
            add = function (node, ev, cb) { &#13;
              node.attachEvent('on' + ev, cb); &#13;
            }; &#13;
            remove = function (node, ev, cb) { &#13;
              node.detachEvent('on' + ev, cb); &#13;
            }; &#13;
          } else { &#13;
            add = function (node, ev, cb) { &#13;
              node['on' + ev] = cb; &#13;
            }; &#13;
            remove = function (node, ev) { &#13;
              node['on' + ev] = null; &#13;
            }; &#13;
          } &#13;
 &#13;
          // public API &#13;
          return { &#13;
 &#13;
            addListener: function (element, event_name, callback) { &#13;
              // element could also be an array of elements &#13;
              element = toArray(element); &#13;
              for (var i = 0; i &lt; element.length; i++) { &#13;
                add(element[i], event_name, callback); &#13;
              } &#13;
            }, &#13;
 &#13;
           removeListener: function (element, event_name, callback) { &#13;
              // same as add(), only practicing a different loop &#13;
              var i = 0, els = toArray(element), len = els.length; &#13;
             for (; i &lt; len; i++) { &#13;
                remove(els[i], event_name, callback); &#13;
              } &#13;
           }, &#13;
 &#13;
            getEvent: function (event) { &#13;
              return event || window.event; &#13;
            }, &#13;
  &#13;
            getTarget: function (event) { &#13;
              var e = this.getEvent(event); &#13;
              return e.target || e.srcElement; &#13;
            }, &#13;
 &#13;
            stopPropagation: function (event) { &#13;
              var e = this.getEvent(event); &#13;
              if (e.stopPropagation) { &#13;
                e.stopPropagation(); &#13;
              } else { &#13;
                e.cancelBubble = true; &#13;
              } &#13;
            }, &#13;
 &#13;
            preventDefault: function (event) { &#13;
              var e = this.getEvent(event); &#13;
              if (e.preventDefault) { &#13;
                e.preventDefault(); &#13;
              } else { &#13;
                e.returnValue = false; &#13;
              } &#13;
            } &#13;
 &#13;
          }; &#13;
        }()); &#13;
</pre><p>
<span class="strong"><strong>Testing</strong></span>: Go to any page with links, execute the following, and then click any link:</p><pre class="programlisting">        function myCallback(e) { &#13;
          e = myevent.getEvent(e); &#13;
          alert(myevent.getTarget(e).href); &#13;
          myevent.stopPropagation(e); &#13;
          myevent.preventDefault(e); &#13;
        } &#13;
        myevent.addListener(document.links, 'click', myCallback); &#13;
</pre></li><li class="listitem">Move a <code class="literal">div</code> around with the keyboard using the following code:<pre class="programlisting">        // add a div to the bottom of the page &#13;
        var div = document.createElement('div'); &#13;
        div.style.cssText = 'width: 100px; height:&#13;
         100px; background: red; position: absolute;'; &#13;
        document.body.appendChild(div); &#13;
 &#13;
        // remember coordinates &#13;
        var x = div.offsetLeft; &#13;
        var y = div.offsetTop; &#13;
 &#13;
        myevent.addListener(document.body, &#13;
         'keydown', function (e) { &#13;
         // prevent scrolling &#13;
          myevent.preventDefault(e); &#13;
 &#13;
          switch (e.keyCode) { &#13;
            case 37: // left &#13;
              x--; &#13;
              break; &#13;
            case 38: // up &#13;
              y--; &#13;
              break; &#13;
            case 39: // right &#13;
              x++; &#13;
              break; &#13;
            case 40: // down &#13;
              y++; &#13;
              break; &#13;
            default: &#13;
              // not interested &#13;
          } &#13;
 &#13;
          // move &#13;
          div.style.left = x + 'px'; &#13;
          div.style.top  = y + 'px'; &#13;
 &#13;
        }); &#13;
</pre></li><li class="listitem">Your own Ajax utility:<pre class="programlisting">        var ajax = { &#13;
          getXHR: function () { &#13;
            var ids = ['MSXML2.XMLHTTP.3.0', &#13;
             'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP']; &#13;
            var xhr; &#13;
            if (typeof XMLHttpRequest === 'function') { &#13;
              xhr = new XMLHttpRequest(); &#13;
            } else { &#13;
              // IE: try to find an ActiveX object to use &#13;
              for (var i = 0; i &lt; ids.length; i++) { &#13;
                try { &#13;
                  xhr = new ActiveXObject(ids[i]); &#13;
                  break; &#13;
                } catch (e) {} &#13;
              } &#13;
            } &#13;
            return xhr; &#13;
 &#13;
          }, &#13;
          request: function (url, method, cb, post_body) { &#13;
            var xhr = this.getXHR(); &#13;
            xhr.onreadystatechange = (function (myxhr) { &#13;
              return function () { &#13;
                if (myxhr.readyState === 4 &amp;&amp; myxhr.status === 200) { &#13;
                  cb(myxhr); &#13;
                } &#13;
              }; &#13;
            }(xhr)); &#13;
            xhr.open(method.toUpperCase(), url, true); &#13;
            xhr.send(post_body || ''); &#13;
          } &#13;
        }; &#13;
</pre><p>When testing, remember that same origin restrictions apply, so you have to be on the same domain. You can go to <a class="ulink" href="http://www.phpied.com/files/jinc/">http://www.phpied.com/files/jinc/</a>, which is a directory listing and then test in the console:</p><pre class="programlisting">        function myCallback(xhr) { &#13;
          alert(xhr.responseText); &#13;
        } &#13;
        ajax.request('1.css', 'get', myCallback); &#13;
        ajax.request('1.css', 'post', myCallback,&#13;
         'first=John&amp;last=Smith'); &#13;
</pre><p>The result of the two is the same, but if you look into the <span class="strong"><strong>Network</strong></span> tab of the Web Inspector, you can see that the second is indeed a <code class="literal">POST</code> request with a body.</p></li></ol></div></div></div></body></html>