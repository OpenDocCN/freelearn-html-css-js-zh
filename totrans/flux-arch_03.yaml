- en: Chapter 3. Building a Skeleton Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to think in Flux is to write code in Flux. This is why we want
    to start building a **skeleton architecture** as early as possible. We call this
    phase of building our application the skeleton architecture because it isn't yet
    the full architecture. It's missing a lot of key application components, and this
    is on purpose. The aim of the skeleton is to keep the moving parts to a minimum,
    allowing us to focus on the information our stores will generate for our views.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get off the ground with a minimalist structure that, while small, doesn't
    require a lot of work to turn our skeleton architecture into our code base. Then,
    we'll move on to some of the information design goals of the skeleton architecture.
    Next, we'll dive into implementing some aspects of our stores.
  prefs: []
  type: TYPE_NORMAL
- en: As we start building, we'll begin to get a sense of how these stores map to
    domains—the features our users will interact with. After this, we'll create some
    really simple views, which can help us ensure that our data flows are in fact
    reaching their final destination. Finally, we'll end the chapter by running through
    a checklist for each of the Flux architectural layers, to make sure that we've
    validated our skeleton before moving on to other development activities.
  prefs: []
  type: TYPE_NORMAL
- en: General organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a first step in building a skeleton Flux architecture, we'll spend a few
    minutes getting organized. In this section, we'll establish a basic directory
    structure, figure out how we'll manage our dependencies, and choose our build
    tools. None of this is set in stone—the idea is to get going quickly, but at the
    same time, establish some norms so that transforming our skeleton architecture
    into application code is as seamless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The directory structure used to start building our skeleton doesn''t need to
    be fancy. It''s a skeleton architecture, not the complete architecture, so the
    initial directory structure should follow suit. Having said that, we also don''t
    want to use a directory structure that''s difficult to evolve into what''s actually
    used in the product. Let''s take a look at the items that we''ll find in the root
    of our project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Directory structure](img/B05419_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pretty simple right? Let''s walk through what each of these items represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.js`: This is the main entry point into the application. This JavaScript
    module will bootstrap the initial actions of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatcher.js`: This is our dispatcher module. This is where the Flux dispatcher
    instance is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actions`: This directory contains all our action creator functions and action
    constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stores`: This directory contains our store modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views`: This directory contains our view modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may not seem like much, and this is by design. The directory layout is
    reflective of the architectural layers of Flux. Obviously there will be more to
    the actual application once we move past the skeleton architecture phase, but
    not a whole lot. We should refrain from adding any extraneous components at this
    point though, because the skeleton architecture is all about information design.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a starting point, we're going to require the basic Facebook Flux dispatcher
    as a dependency of our skeleton architecture—even if we don't end up using this
    dispatcher in our final product. We need to start designing our stores, as this
    is the most crucial and the most time-consuming aspect of the skeleton architecture;
    worrying about things like the dispatcher at this juncture simply doesn't pay
    off.
  prefs: []
  type: TYPE_NORMAL
- en: We need to start somewhere and the Facebook dispatcher implementation is good
    enough. The question is, will we need any other packages? In [Chapter 1](ch01.html
    "Chapter 1. What is Flux?"), *What is Flux?* we walked through the setup of the
    Facebook Flux NPM package and used Webpack to build our code. Can this work as
    our eventual production build system?
  prefs: []
  type: TYPE_NORMAL
- en: Not having a package manager or a module bundler puts us at a disadvantage,
    right from the onset of the project. This is why we need to think about dependency
    management as a first step of the skeleton architecture, even though we don't
    have many dependencies at the moment. If this is the first time we're building
    an application that has a Flux architecture behind it, the way we handle dependencies
    will serve as a future blueprint for subsequent Flux projects.
  prefs: []
  type: TYPE_NORMAL
- en: Is it a bad idea to add more module dependencies during the development of our
    skeleton architecture? Not at all. In fact, it's better that we use a tool that's
    well suited for the job. As we're implementing the skeleton, we'll start to see
    places in our stores where a library would be helpful. For example, if we're doing
    a lot of sorting and filtering on data collections and we're building higher-order
    functions, using something like lodash for this is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, pulling in something like ReactJS or jQuery at this stage
    doesn't make a whole lot of sense because we're still thinking about the information
    and not how to present it in the DOM. So that's the approach we're going to use
    in this book—NPM as our package manager and Webpack as our bundler. This is the
    basic infrastructure we need, without much overhead to distract us.
  prefs: []
  type: TYPE_NORMAL
- en: Information design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that the skeleton architecture we're trying to build is specifically
    focused on getting the right information into the hands of our users. This means
    that we're not paying much attention to user interactivity or formatting the information
    in a user-friendly way. It might help if we set some rough goals for ourselves—how
    do we know we're actually getting anywhere with our information design?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll talk about the negative influence API data models can
    have on our user interface design. Then, we'll look at mapping data to what the
    user sees and how these mappings should be encouraged throughout our stores. Finally,
    we'll think about the environment we find ourselves working in.
  prefs: []
  type: TYPE_NORMAL
- en: Users don't understand models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our job as user interface programmers is to get the right information to the
    user at the right time. How do we do this? Conventional wisdom revolves around
    taking some data that we got from the API and then rendering it as HTML. Apart
    from semantic markup and some styles, nothing much has changed with the data since
    it arrived from the API. We''re saying *here''s the data we have, let''s make
    it look nice for the user*. Here''s an illustration of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Users don''t understand models](img/B05419_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s no data transformation taking place here, which is fine, so long as
    the user is getting what they need. The problem this picture paints is that the
    data model of the API has taken the UI feature development hostage. We must heed
    everything that''s sent down to us from the backend. The reason this is a problem
    is because we''re limited in what we can actually do for the user. Something we
    can do is have our own models enhance the data that''s sent back from the API.
    This means that if we''re working on a feature that would require information
    that isn''t exactly as the API intended it, we can fabricate it as a frontend
    model, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Users don''t understand models](img/B05419_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This gets us slightly closer to our goal in the sense that we can create a model
    of the feature we're trying to implement and put it in front of the user. So while
    the API might not deliver exactly what we want to display on the screen, we can
    use our transformation functions to generate a model of the information we need.
  prefs: []
  type: TYPE_NORMAL
- en: During the skeleton architecture phase of our design process, we should think
    about stores independent of API's as much as possible. Not completely independently;
    we don't want to go way out into left field, jeopardizing the product. But the
    idea of producing a Flux skeleton architecture is to ensure that we're producing
    the right information, first and foremost. If there's no way the API can support
    what we're trying to do, then we can take the necessary steps, before spending
    a lot of time implementing full-fledged features.
  prefs: []
  type: TYPE_NORMAL
- en: Stores map to what the user sees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State isn't the only thing that's encapsulated by the stores found in our Flux
    architecture. There's also the data transformations that map old state to new
    state. We should spend more time thinking about what the user needs to see and
    less time thinking about the API data, which means that the store transformation
    functions are essential.
  prefs: []
  type: TYPE_NORMAL
- en: We need to embrace data transformations in Flux stores, because they're the
    ultimate determinant of how things change in front of the user's eyes. Without
    these transformations, the user would only be able to view static information.
    Of course, we could aim to design an architecture that only uses the data that's
    passed into the system "as-is", without transforming it. This never works out
    as we intend, for the simple reason that we're going to uncover dependencies with
    other UI components.
  prefs: []
  type: TYPE_NORMAL
- en: What should our early goals be with stores and how we transform their state?
    Well, the skeleton architecture is all about experimentation, and if we start
    writing transformation functionality upfront, we're likely to discover dependencies
    sooner. Dependencies aren't necessarily a bad thing, except when we find a lot
    of them late in the project, well after we've completed the skeleton architecture
    phase. Of course, new features are going to add new dependencies. If we can use
    state transformations early on to identify potential dependencies, then we can
    avoid future headaches.
  prefs: []
  type: TYPE_NORMAL
- en: What do we have to work with?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we'll need to consider before we roll up our sleeves and start
    implementing this skeleton Flux architecture is what's already in place. For example,
    does this application already have an established API and we're re-architecting
    the frontend? Do we need to retain the user experience of an existing UI? Is the
    project completely greenfield with no API or user experience input?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how these external factors influence the
    way we treat the implementation of our skeleton architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What do we have to work with?](img/B05419_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's nothing wrong with having these two factors shape our Flux architecture.
    In the case of existing APIs, we'll have a starting point from which we can start
    writing our state transformation functions, to get the user the information that
    they need. In the case of keeping an existing user experience, we already know
    what the shape of our target information looks like, and we can work the transformation
    functions from a different angle.
  prefs: []
  type: TYPE_NORMAL
- en: When the Flux architecture is completely greenfield, we can let it inform both
    the user experience and the APIs that need to be implemented. It's highly unlikely
    that any of the scenarios in which we find ourselves building a skeleton architecture
    will be cut-and-dried. These are just the starting points that we may find ourselves
    in. Having said that, it's time to start implementing some skeleton stores.
  prefs: []
  type: TYPE_NORMAL
- en: Putting stores into action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to implement some stores in our skeleton architecture.
    They won't be complete stores capable of supporting end-to-end work-flows. However,
    we'll be able to see where the stores fit within the context of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the most basic of all store actions, which are populating them
    with some data; this is usually done by fetching it via some API. Then, we'll
    discuss changing the state of remote API data. Finally, we'll look at actions
    that change the state of a store locally, without the use of an API.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching API data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of whether or not there's an API with application data ready to consume,
    we know that eventually this is how we'll populate our store data. So it makes
    sense that we think about this as the first design activity of implementing skeleton
    stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a basic store for the homepage of our application. The obvious
    information that the user is going to want to see here is the currently logged-in
    user, a navigation menu, and perhaps a summarized list of recent events that are
    relevant to the user. This means that fetching this data is one of the first things
    our application will have to do. Here''s our first implementation of the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is fairly easy to follow, so lets point out the important pieces. First,
    we need to import the dispatcher so that we can register our store. When the store
    is created, the default state is stored in the `state` property. When the `HOME_LOAD`
    action is dispatched, we change the state of the store. Lastly, we export the
    store instance as the default module member.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the action name implies, `HOME_LOAD` is dispatched when data for the store
    has loaded. Presumably, we''re going to pull this data for the home store from
    some API endpoints. Let''s go ahead and put this store to use in our `main.js`
    module—our application entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is some fairly straightforward usage of our home store. We're logging the
    default state of the store, dispatching the `HOME_LOAD` action with some new payload
    data, and logging the state again to make sure that the state of the store did
    in fact change. So the question is, what does this code have to do with the API?
  prefs: []
  type: TYPE_NORMAL
- en: This is a good starting point for our skeleton architecture because there's
    a number of things to think about before we even get to implementing API calls.
    We haven't even started implementing actions yet, because if we did, they'd just
    be another distraction. And besides, actions and real API calls are easy to implement
    once we flesh out our stores.
  prefs: []
  type: TYPE_NORMAL
- en: The first question that comes to mind about the `main.js` module is the location
    of the `dispatch()` call to `HOME_LOAD`. Here, we're bootstrapping data into the
    store. Is this the right place to do this? When the `main.js` module runs will
    we always require that this store be populated? Is this the place where we'll
    want to bootstrap data into all of our stores? We don't need immediate answers
    to these questions, because that would likely result in us dwelling on one aspect
    of the architecture for far too long, and there are many other issues to think
    about.
  prefs: []
  type: TYPE_NORMAL
- en: For example, does the coupling of our store make sense? The home store we just
    implemented has a `navigation` array. These are just simple strings right now,
    but they'll likely turn into objects. The bigger issue is that the navigation
    data might not even belong in this store—several other stores are probably going
    to require navigation state data too. Another example is the way we're setting
    the new state of the store using the dispatch payload. Using `Object.assign()`
    is advantageous, because we can dispatch the `HOME_LOAD` event with a payload
    with only one state property and everything will continue to function the same.
    Implementing this store took us very little time at all, but we've asked some
    very important questions and learned a powerful technique for assigning new store
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the skeleton architecture, and so we''re not concerned with the mechanics
    of actually fetching the API data. We''re more concerned about the actions that
    get dispatched as a result of API data arriving in the browser; in this case,
    it''s `HOME_LOAD`. It''s the mechanics of information flowing through stores that
    matters in the context of a skeleton Flux architecture. And on that note, let''s
    expand the capabilities of our store slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The store still does everything it did before, only now the store class inherits
    from `EventEmitter`, and when the `HOME_LOAD` action is dispatched, it emits a
    `change` event using the store state as the event data. This gets us one step
    closer to having a full work-flow, as views can now listen to the `change` event
    to get the new state of the store. Let''s update our main module code to see how
    this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This enhancement to the store in our skeleton architecture brings about yet
    more questions, namely, about setting up event listeners on our stores. As you
    can see, we have to make sure that the handler is actually listening to the store
    before any actions are dispatched. All of these concerns we need to address, and
    we've only just begun to design our architecture. Let's move on to changing the
    state of backend resources.
  prefs: []
  type: TYPE_NORMAL
- en: Changing API resource state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we''ve set the initial store state by asking the API for some data, we''ll
    likely end up needing to change the state of that backend resource. This happens
    in response to user activity. In fact, the common pattern looks like the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing API resource state](img/B05419_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's think about this pattern in the context of a Flux store. We've already
    seen how to load data into a store. In the skeleton architecture we're building,
    we're not actually making these API calls, even if they exist—we're focused solely
    on the information that's produced by the frontend right now. When we dispatch
    an action that changes the state of a store, we'll probably need to update the
    state of this store in response to successful completion of the API call. The
    real question is, what does this entail exactly?
  prefs: []
  type: TYPE_NORMAL
- en: For example, does the call we make to change the state of the backend resource
    actually respond with the updated resource, or does it respond with a mere success
    indication? These types of API patterns have a dramatic impact on the design of
    our stores because it means the difference between having to always make a secondary
    call or having the data in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code now. First, we have a user store as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll assume that this singular user store is for a page in our application
    where only a single user is displayed. Now, let''s implement a store that''s useful
    for tracking the state of several users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create the `main.js` module that will work with these stores. In
    particular, we want to see how interacting with the API to change the state of
    a backend resource will influence the design of our stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `createUser()` function serves as a proxy for the
    actual API implementation. Remember, this is a skeleton architecture where the
    chief concern is the information constructed by our stores. Implementing a function
    that returns a promise is perfectly acceptable here because this is very easy
    to change later on once we start talking to the real API.
  prefs: []
  type: TYPE_NORMAL
- en: We're on the lookout for interesting aspects of our stores—their state, how
    that state changes, and the dependencies between our stores. In this case, when
    we create the new user, the API returns the new object. Then, this is dispatched
    as a `USER_LOAD` action. Our `userStore` is now populated. We're also dispatching
    a `USER_ADD` action so that the new user data can be added to this list. Presumably,
    these two stores service different parts of our application, and yet the same
    API call that changes the state of something in the backend is relevant.
  prefs: []
  type: TYPE_NORMAL
- en: What can we learn about our architecture from all of this? For starters, we
    can see that the promise callback is going to have to dispatch multiple actions
    for multiple stores. This means that we can probably expect more of the same with
    similar API calls that create resources. What about calls that modify users, would
    the code look similar?
  prefs: []
  type: TYPE_NORMAL
- en: Something that we're missing here is an action to update the state of a user
    object within the array of users in `userListStore`. Alternatively, we could have
    this store also handle the `USER_LOAD` action. Any approach is fine, it's the
    exercise of building the skeleton architecture that's supposed to help us find
    the approach that best fits our application. For example, we're dispatching a
    single `USER_REMOVE` action here too, and this is handled easily by both our stores.
    Maybe this is the approach we're looking for?
  prefs: []
  type: TYPE_NORMAL
- en: Local actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll close the section on store actions with a look at local actions. These
    are actions that have nothing to do with the API. Local actions are generally
    in response to user interactions, and dispatching them will have a visible effect
    on the UI. For example, the user wants the toggle the visibility of some component
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical application would just execute a jQuery one-liner to locate the
    element in the DOM and make the appropriate CSS changes. This type of thing doesn''t
    fly in Flux architectures, and it''s the type of thing we should start thinking
    about during the skeleton architecture phase of our application. Let''s implement
    a simple store that handles local actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PANEL_TOGGLE` action and the `ITEM_SELECT` action are two local actions
    handled by this store. They''re local because they''re likely triggered by the
    user clicking a button or selecting a checkbox. Let''s dispatch these actions
    so we can see how our store handles them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example serves as an illustration as to why we should consider all things
    state-related during the skeleton architecture implementation phase. Just because
    we're not implementing actual UI components right now, doesn't mean we can't guess
    at some of the potential states of common building blocks. In this code, we've
    discovered that the `ITEM_SELECT` action is actually dependent on the `PANEL_TOGGLE`
    action. This is because we don't actually want to select an item and update the
    view when the panel is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Building on this idea, should other components be able to dispatch this action
    in the first place? We've just found a potential store dependency, where the dependent
    store would query the state of `panelStore` before actually enabling UI elements.
    All of this from local actions that don't even talk to APIs, and without actual
    user interface elements. We're probably going to find many more items like this
    throughout the course of our skeleton architecture, but don't get hung up on finding
    everything. The idea is to learn what we can, while we have an opportunity to,
    because once we start implementing real features, things become more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Stores and feature domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With more traditional frontend architectures, models that map directly to what's
    returned from the API provide a clear and concise data model for our JavaScript
    components to work with. Flux, as we now know, leans more in the direction of
    the user, and focuses on the information that they need to see and interact with.
    This doesn't need to be a gigantic headache for us, especially if we're able to
    decompose our user interface into domains. Think of a domain as a really big feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll talk about identifying the top-level features that form
    the core of our UI. Then, we'll work on shedding irrelevant API data from the
    equation. We'll finish the section with a look at the structure of our store data,
    and the role it plays in the design of our skeleton architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying top-level features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the skeleton architecture phase of our Flux project, we should jump in
    and start writing store code, just as we've done in this chapter. We've been thinking
    about the information the user is going to need and how we can best get this information
    to the user. Something we didn't spend a lot of time on upfront was trying to
    identify the top level features of the application. This is fine, because the
    exercises we've performed so far in this chapter are often a prerequisite for
    figuring out how to organize our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: However, once we've identified how we're going to implement some of the low-level
    store mechanisms that get us the information we're after, we need to start thinking
    about these top-level features. And there's a good reason for this—the stores
    we ultimately maintain will map to these features. When we say top-level, it's
    tempting to use the navigation as the point of reference. There's actually nothing
    wrong with using the page navigation as a guide; if it's big enough for the main
    navigation, it's probably a top-level feature that's worthy of its own Flux store.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being a top-level feature, we need to think about the role of
    the store—why does it exist? What value does this add for the user? The reason
    these questions are important is because we could end up having six pages that
    all could have used the same store. So it's a balance between consolidating value
    into one store and making sure that the store isn't to large and general-purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Applications are complex, with lots of moving parts that drive lots of features.
    Our user interface probably has 50 awesome features. But this is unlikely to require
    50 awesome top-level navigation links and 50 Flux stores. Our stores will have
    to represent the complex intricacies of these features in their data, at some
    point. This comes later though, for now we just need to get a handle on approximately
    how many stores we're working with, and how many dependencies we have between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Irrelevant API data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use it or lose it—the mantra of Flux store data. The challenge with API data
    is that it's a representation of a backend resource—it's not going to return data
    that's specifically required for our UI. An API exists so that more than one UI
    can be built on it. However, this means that we often end up with irrelevant data
    in our stores. For example, if we only need a few properties from an API resource,
    we don't want to store 36 properties. Especially when some of these can themselves
    be collections. This is wasteful in terms of memory consumption, and confusing
    in terms of their existence. It's actually the latter point that's more concerning
    because we can easily mislead other programmers working on this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential solution is to exclude these unused values from the API response.
    Many APIs today support this, by letting us opt-in to the properties we want returned.
    And this is probably a good idea if it means drastically reduced network bandwidth.
    However, this approach can also be error-prone because we have to perform this
    filtering at the ajax call level, instead of at the store level. Let''s look at
    an example that takes a different approach, by specifying a store record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the default `state` object plays an important role, other
    than providing default state values. It also provides the store record. In other
    words, the property keys used by the default state determine the allowable values
    when the `PLAYER_LOAD` action is dispatched. Let''s see if this works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Structuring store data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the examples shown so far in this chapter have relatively simple state
    objects within stores. Once we build the skeleton architecture up, these simple
    objects will turn into something more complicated. Remember, the state of a store
    reflects the state of the information that the user is looking at. This includes
    the state of some of the elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: This is something we need to keep an eye on. Just because we're through performing
    the skeleton architecture exercise doesn't mean an idea will hold up as we start
    to implement more elaborate features. In other words, if a store state becomes
    too large—too nested and deep—then it's time to consider moving our stores around
    a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we don't want too many stores driving our views, because they're
    more like models from an MVC architecture at this point. We want the stores to
    represent a specific feature of the application. This doesn't always work out,
    because we could end up having some complex and convoluted state in the store
    for the feature. In this case, our top-level feature needs to be split somehow.
  prefs: []
  type: TYPE_NORMAL
- en: This will no doubt happen at some point during our time with Flux, and there's
    no rule in place that says when it's time to refactor stores. Instead, if the
    state data stays at a size where it feels comfortable to work with, you're probably
    fine with the store as it is.
  prefs: []
  type: TYPE_NORMAL
- en: Bare bone views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made some progress with our skeleton stores to the point where we're ready
    to start looking at skeleton views. These are simple classes, much in the same
    spirit as stores are, except we're not actually rendering anything to the DOM.
    The idea with these bare bone views is to affirm the sound infrastructure of our
    architecture, and that these view components are in fact getting the information
    they expect. This is crucial because the views are the final item in the Flux
    data-flow, so if they're not getting what they need, when they need it, we need
    to go back and fix our stores.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll discuss how our bare-boned views can help us more quickly
    identify when stores are missing a particular piece of information. Then, we'll
    look at how these views can help us identify potential actions in our Flux application.
  prefs: []
  type: TYPE_NORMAL
- en: Finding missing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first activity we'll perform with our bare bone views is figuring out whether
    or not the stores are passing along all the essential information required by
    the view. By essential, we're talking about things that would be problematic for
    the user were they not there. For example, we're looking at a settings page, and
    there's a whole section missing. Or, there's a list of options to select from,
    but we don't actually have the string labels to show because they're part of some
    other API.
  prefs: []
  type: TYPE_NORMAL
- en: Once we figure out that these critical pieces of information are missing from
    the store, the next step is to determine if they're a possibility, because if
    they're not, we've just avoided spending an inordinate amount of time implementing
    a full-fledged view. However, these are the rare cases. Usually, it isn't a big
    deal to go back to the store in question and add the missing transformation that
    will compute and set the missing state we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: How much time do we need to spend on these bare bone views? Think of it this
    way—as we start implementing the actual views that render to the DOM for us, we'll
    discover more missing state from the store. These, however, are superficial and
    easy to fix. With the bare bone views, we're more concerned with teasing out the
    critical parts that are missing. What can we do with these views when we're done
    with them? Are they garbage? Not necessarily, depending on how we want to implement
    our production views, we could either adjust them to become ReactJS components
    or we could embed the actual view inside the bare-bone view, making it more of
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier in the chapter, the first set of actions to be dispatched
    by a given Flux architecture are going to be related to fetching data from the
    backend API. Ultimately, these are the start of the data-flows that end with the
    views. Sometimes, these are merely *load* type actions, where we're explicitly
    saying to go fetch the resource and populate our store. Other times, we might
    have more abstract actions that describe the action taken by the user, resulting
    in several stores being populated from many different API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: This gets the user to a point where we can start thinking about how they're
    going to want to interact with this information. The only way they do so is by
    dispatching more actions. Let's create a view with some action methods. Essentially,
    the goal is to have access our views from the browser JavaScript console. This
    lets us view the state information associated with the view at any given point,
    as well as call the method to dispatch the given action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to adjust our Webpack configuration slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This one line will export a global `views` variable in the browser window,
    and its value will be whatever our `main.js` module exports. Let''s have a look
    at this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this looks interesting. We''re simply exporting our view as `settings`.
    So, as we''re creating our bare bone views in the skeleton architecture, we simply
    follow this pattern in `main.js` to keep adding views to the browser console to
    experiment with. Let''s now take a look at the settings view itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left to do now is to see what''s available in the browser console
    when we load this page. We should have a global `views` variable, and this should
    have each of our view instances as properties. Now, we get to play around with
    actions dispatched by views as though we''re users clicking around in the DOM.
    Let''s see how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: End-to-end scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, we're going to have to wrap up the skeleton architecture phase
    of the project and start implementing real features. We don't want the skeleton
    phase to drag on for too long because then we'll start making too many assumptions
    about the reality of our implementation. At the same time, we'll probably want
    to walk through a few end-to-end scenarios before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this section is to provide you with a few high-level points to be
    on the lookout for in each architectural layer. These aren't strict criteria,
    but they can certainly help us formulate our own measurements that determine whether
    or not we've adequately answered our questions about the information architecture
    by building a skeleton. If we're feeling confident, it's time to go full steam
    and flesh out the application detail—the subsequent chapters in this book dive
    into the nitty-gritty of implementing Flux.
  prefs: []
  type: TYPE_NORMAL
- en: Action checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following items are worth thinking about when we''re implementing actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do our features have actions that bootstrap store data by fetching it from the
    API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have actions that change the state of backend resources? How are these
    changes reflected in our frontend Flux stores?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does a given feature have any local actions, and are they distinct from actions
    that issue API requests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following items are worth thinking about when implementing stores:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the store map to a top-level feature in our application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well does the data structure of the store meet the needs of the views that
    use it? Is the structure too complex? If so, can we refactor the store into two
    stores?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the stores discard API data that isn't used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the stores map API data to relevant information that the user needs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is our store structure amenable to change once we start adding more elaborate
    view functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have too many stores? If so, do we need to rethink the way we've structured
    the top-level application features?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following items are worth thinking about when implementing views:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the view get the information it needs out of the store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which actions result in the view rendering?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which actions does the view dispatch, in response to user interaction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about getting started with a Flux architecture by building
    some skeleton components. The goal being to think about the information architecture,
    without the distraction of other implementation issues. We could find ourselves
    in a situation where the API is already defined for us, or where the user experience
    is already in place. Either of these factors will influence the design of our
    stores, and ultimately the information we present to our users.
  prefs: []
  type: TYPE_NORMAL
- en: The stores we implemented were basic, loading data when the application starts
    and updating their state in response to an API call. We did, however, learn to
    ask the pertinent questions about our stores, such as the approach taken with
    parsing the new data to set as the store's state, and how this new state will
    affect other stores.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we thought about the top-level features that form the core of our application.
    These features give a good indication of the stores that our architecture will
    need. Toward the end of the skeleton architecture phase, we want to walk through
    a few end-to-end scenarios to sanity-check our chosen information design. We looked
    at a few high-level checklist items to help ensure we didn't leave anything important
    out. In the following chapter, we'll take a deeper look at actions and how they're
    dispatched.
  prefs: []
  type: TYPE_NORMAL
