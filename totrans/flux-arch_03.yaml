- en: Chapter 3. Building a Skeleton Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 建立骨架架构
- en: The best way to think in Flux is to write code in Flux. This is why we want
    to start building a **skeleton architecture** as early as possible. We call this
    phase of building our application the skeleton architecture because it isn't yet
    the full architecture. It's missing a lot of key application components, and this
    is on purpose. The aim of the skeleton is to keep the moving parts to a minimum,
    allowing us to focus on the information our stores will generate for our views.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 以Flux的方式思考的最佳方法是使用Flux编写代码。这就是为什么我们希望尽早开始构建骨架架构。我们称构建我们应用程序的这个阶段为骨架架构，因为它还不是完整的架构。它缺少许多关键的应用程序组件，这是故意的。骨架的目的是将移动部件保持在最低限度，使我们能够专注于我们的存储将为我们的视图生成的信息。
- en: We'll get off the ground with a minimalist structure that, while small, doesn't
    require a lot of work to turn our skeleton architecture into our code base. Then,
    we'll move on to some of the information design goals of the skeleton architecture.
    Next, we'll dive into implementing some aspects of our stores.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一种极简的结构开始，虽然规模不大，但不需要做很多工作就能将我们的骨架架构转换为我们的代码库。然后，我们将继续探讨骨架架构的一些信息设计目标。接下来，我们将深入实施存储的一些方面。
- en: As we start building, we'll begin to get a sense of how these stores map to
    domains—the features our users will interact with. After this, we'll create some
    really simple views, which can help us ensure that our data flows are in fact
    reaching their final destination. Finally, we'll end the chapter by running through
    a checklist for each of the Flux architectural layers, to make sure that we've
    validated our skeleton before moving on to other development activities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建的过程中，我们将开始了解这些存储如何映射到领域——用户将与之交互的功能。在此之后，我们将创建一些非常简单的视图，这有助于我们确保我们的数据流确实达到了最终目的地。最后，我们将通过检查每个Flux架构层的清单来结束本章，以确保我们在进行其他开发活动之前已经验证了我们的骨架。
- en: General organization
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般组织
- en: As a first step in building a skeleton Flux architecture, we'll spend a few
    minutes getting organized. In this section, we'll establish a basic directory
    structure, figure out how we'll manage our dependencies, and choose our build
    tools. None of this is set in stone—the idea is to get going quickly, but at the
    same time, establish some norms so that transforming our skeleton architecture
    into application code is as seamless as possible.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建骨架Flux架构的第一步，我们将花几分钟时间进行组织。在本节中，我们将建立一个基本的目录结构，弄清楚我们将如何管理我们的依赖关系，并选择我们的构建工具。这一切都不是一成不变的——我们的想法是快速开始，同时建立一些规范，以便将我们的骨架架构转换为应用程序代码尽可能无缝。
- en: Directory structure
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录结构
- en: 'The directory structure used to start building our skeleton doesn''t need to
    be fancy. It''s a skeleton architecture, not the complete architecture, so the
    initial directory structure should follow suit. Having said that, we also don''t
    want to use a directory structure that''s difficult to evolve into what''s actually
    used in the product. Let''s take a look at the items that we''ll find in the root
    of our project directory:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 用于开始构建我们的骨架的目录结构不需要很复杂。这是一个骨架架构，而不是完整的架构，因此初始目录结构应该与之相匹配。话虽如此，我们也不想使用一个难以演变成产品实际使用的目录结构。让我们看看我们将在项目目录根目录中找到的项目：
- en: '![Directory structure](img/B05419_03_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![目录结构](img/B05419_03_01.jpg)'
- en: 'Pretty simple right? Let''s walk through what each of these items represent:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？让我们逐一了解这些项目代表什么：
- en: '`main.js`: This is the main entry point into the application. This JavaScript
    module will bootstrap the initial actions of the system.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.js`: 这是应用程序的主要入口点。这个JavaScript模块将启动系统的初始动作。'
- en: '`dispatcher.js`: This is our dispatcher module. This is where the Flux dispatcher
    instance is created.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatcher.js`: 这是我们的调度器模块。这是Flux调度器实例创建的地方。'
- en: '`actions`: This directory contains all our action creator functions and action
    constants.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions`: 这个目录包含所有我们的动作创建函数和动作常量。'
- en: '`stores`: This directory contains our store modules.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stores`: 这个目录包含我们的存储模块。'
- en: '`views`: This directory contains our view modules.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`: 这个目录包含我们的视图模块。'
- en: This may not seem like much, and this is by design. The directory layout is
    reflective of the architectural layers of Flux. Obviously there will be more to
    the actual application once we move past the skeleton architecture phase, but
    not a whole lot. We should refrain from adding any extraneous components at this
    point though, because the skeleton architecture is all about information design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，这是有意为之。目录结构反映了Flux的架构层。显然，一旦我们过了骨架架构阶段，实际应用将会有更多内容，但不会太多。不过，在这个阶段，我们应避免添加任何额外的组件，因为骨架架构完全是关于信息设计的。
- en: Dependency management
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖管理
- en: As a starting point, we're going to require the basic Facebook Flux dispatcher
    as a dependency of our skeleton architecture—even if we don't end up using this
    dispatcher in our final product. We need to start designing our stores, as this
    is the most crucial and the most time-consuming aspect of the skeleton architecture;
    worrying about things like the dispatcher at this juncture simply doesn't pay
    off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们将需要Facebook Flux分发器作为我们骨架架构的依赖项——即使我们最终的产品中不会使用这个分发器。我们需要开始设计我们的存储，因为这是骨架架构中最关键且最耗时的方面；在这个阶段担心像分发器这样的问题根本不值得。
- en: We need to start somewhere and the Facebook dispatcher implementation is good
    enough. The question is, will we need any other packages? In [Chapter 1](ch01.html
    "Chapter 1. What is Flux?"), *What is Flux?* we walked through the setup of the
    Facebook Flux NPM package and used Webpack to build our code. Can this work as
    our eventual production build system?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从某个地方开始，Facebook分发器的实现已经足够好。问题是，我们是否需要其他包？在[第1章](ch01.html "第1章。什么是Flux？")中，*什么是Flux？*我们介绍了Facebook
    Flux NPM包的设置，并使用Webpack构建我们的代码。这可以作为我们最终的生产构建系统吗？
- en: Not having a package manager or a module bundler puts us at a disadvantage,
    right from the onset of the project. This is why we need to think about dependency
    management as a first step of the skeleton architecture, even though we don't
    have many dependencies at the moment. If this is the first time we're building
    an application that has a Flux architecture behind it, the way we handle dependencies
    will serve as a future blueprint for subsequent Flux projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有包管理器或模块打包器让我们从一开始就处于不利地位。这就是为什么我们需要将依赖管理视为骨架架构的第一步，即使目前我们没有很多依赖。如果我们是第一次构建一个背后有Flux架构的应用程序，我们处理依赖的方式将作为未来Flux项目的蓝图。
- en: Is it a bad idea to add more module dependencies during the development of our
    skeleton architecture? Not at all. In fact, it's better that we use a tool that's
    well suited for the job. As we're implementing the skeleton, we'll start to see
    places in our stores where a library would be helpful. For example, if we're doing
    a lot of sorting and filtering on data collections and we're building higher-order
    functions, using something like lodash for this is perfect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发骨架架构期间添加更多的模块依赖是否是一个坏主意？根本不是。事实上，使用适合这项工作的工具会更好。在我们实现骨架的过程中，我们将开始看到在存储中一些地方使用库会有所帮助。例如，如果我们对数据集合进行大量的排序和过滤，并构建高阶函数，使用类似lodash这样的工具是完美的。
- en: On the other hand, pulling in something like ReactJS or jQuery at this stage
    doesn't make a whole lot of sense because we're still thinking about the information
    and not how to present it in the DOM. So that's the approach we're going to use
    in this book—NPM as our package manager and Webpack as our bundler. This is the
    basic infrastructure we need, without much overhead to distract us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在这个阶段引入像ReactJS或jQuery这样的东西并不合理，因为我们还在考虑信息而不是如何在DOM中呈现它。所以，这本书中我们将采用这种方法——NPM作为我们的包管理器，Webpack作为我们的打包器。这是我们需要的最基本的基础设施，没有太多开销来分散我们的注意力。
- en: Information design
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息设计
- en: We know that the skeleton architecture we're trying to build is specifically
    focused on getting the right information into the hands of our users. This means
    that we're not paying much attention to user interactivity or formatting the information
    in a user-friendly way. It might help if we set some rough goals for ourselves—how
    do we know we're actually getting anywhere with our information design?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们正在尝试构建的骨架架构特别关注将正确的信息传递给我们的用户。这意味着我们并没有太多关注用户的交互性或以用户友好的方式格式化信息。如果我们为自己设定一些粗略的目标——我们如何知道我们的信息设计实际上有所进展？
- en: In this section, we'll talk about the negative influence API data models can
    have on our user interface design. Then, we'll look at mapping data to what the
    user sees and how these mappings should be encouraged throughout our stores. Finally,
    we'll think about the environment we find ourselves working in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论API数据模型对我们用户界面设计可能产生的负面影响。然后，我们将探讨将数据映射到用户所看到的内容，以及这些映射应该如何在我们的商店中得到鼓励。最后，我们将思考我们正在工作的环境。
- en: Users don't understand models
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户不理解模型
- en: 'Our job as user interface programmers is to get the right information to the
    user at the right time. How do we do this? Conventional wisdom revolves around
    taking some data that we got from the API and then rendering it as HTML. Apart
    from semantic markup and some styles, nothing much has changed with the data since
    it arrived from the API. We''re saying *here''s the data we have, let''s make
    it look nice for the user*. Here''s an illustration of this idea:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户界面程序员，我们的任务是确保在正确的时间将正确的信息提供给用户。我们如何做到这一点？传统智慧围绕着从API获取一些数据，然后将其渲染为HTML。除了语义标记和一些样式外，自数据从API到达以来，数据并没有发生太大的变化。我们说的是“这里有我们的数据，让我们让它对用户看起来更美观。”以下是这个想法的说明：
- en: '![Users don''t understand models](img/B05419_03_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![用户不理解模型](img/B05419_03_02.jpg)'
- en: 'There''s no data transformation taking place here, which is fine, so long as
    the user is getting what they need. The problem this picture paints is that the
    data model of the API has taken the UI feature development hostage. We must heed
    everything that''s sent down to us from the backend. The reason this is a problem
    is because we''re limited in what we can actually do for the user. Something we
    can do is have our own models enhance the data that''s sent back from the API.
    This means that if we''re working on a feature that would require information
    that isn''t exactly as the API intended it, we can fabricate it as a frontend
    model, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有进行数据转换，这是可以接受的，只要用户得到他们需要的东西。这幅图描绘的问题在于API的数据模型已经绑架了UI功能开发。我们必须注意从后端发送给我们的每一件事。这是因为我们实际上能为用户提供的东西有限。我们可以做的一件事是让我们的模型增强从API返回的数据。这意味着如果我们正在开发一个需要的信息与API意图不完全一致的功能，我们可以像这里展示的那样，在前端模型中构建它。
- en: '![Users don''t understand models](img/B05419_03_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![用户不理解模型](img/B05419_03_03.jpg)'
- en: This gets us slightly closer to our goal in the sense that we can create a model
    of the feature we're trying to implement and put it in front of the user. So while
    the API might not deliver exactly what we want to display on the screen, we can
    use our transformation functions to generate a model of the information we need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们在某种程度上更接近我们的目标，因为我们可以创建一个我们试图实现的特性的模型，并将其展示给用户。所以尽管API可能无法提供我们想在屏幕上显示的确切内容，但我们可以使用我们的转换函数来生成所需信息的模型。
- en: During the skeleton architecture phase of our design process, we should think
    about stores independent of API's as much as possible. Not completely independently;
    we don't want to go way out into left field, jeopardizing the product. But the
    idea of producing a Flux skeleton architecture is to ensure that we're producing
    the right information, first and foremost. If there's no way the API can support
    what we're trying to do, then we can take the necessary steps, before spending
    a lot of time implementing full-fledged features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计过程的骨架架构阶段，我们应该尽可能独立于API来考虑商店。不是完全独立；我们不希望偏离太远，危及产品。但生产Flux骨架架构的想法是确保我们首先产生正确的信息。如果API无法支持我们试图做的事情，那么我们可以在花费大量时间实现完整功能之前采取必要的步骤。
- en: Stores map to what the user sees
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 商店映射用户所看到的内容
- en: State isn't the only thing that's encapsulated by the stores found in our Flux
    architecture. There's also the data transformations that map old state to new
    state. We should spend more time thinking about what the user needs to see and
    less time thinking about the API data, which means that the store transformation
    functions are essential.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 状态并不是我们Flux架构中商店唯一封装的东西。还有将旧状态映射到新状态的数据转换。我们应该花更多的时间思考用户需要看到什么，而不是花更多的时间思考API数据，这意味着商店转换函数是至关重要的。
- en: We need to embrace data transformations in Flux stores, because they're the
    ultimate determinant of how things change in front of the user's eyes. Without
    these transformations, the user would only be able to view static information.
    Of course, we could aim to design an architecture that only uses the data that's
    passed into the system "as-is", without transforming it. This never works out
    as we intend, for the simple reason that we're going to uncover dependencies with
    other UI components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Flux存储中拥抱数据转换，因为它们是用户眼前事物变化的最终决定因素。没有这些转换，用户只能查看静态信息。当然，我们可以试图设计一个只使用传入系统的“原样”数据的架构，而不进行转换。这永远不会按照我们的意图实现，简单的理由是我们将发现与其他UI组件的依赖关系。
- en: What should our early goals be with stores and how we transform their state?
    Well, the skeleton architecture is all about experimentation, and if we start
    writing transformation functionality upfront, we're likely to discover dependencies
    sooner. Dependencies aren't necessarily a bad thing, except when we find a lot
    of them late in the project, well after we've completed the skeleton architecture
    phase. Of course, new features are going to add new dependencies. If we can use
    state transformations early on to identify potential dependencies, then we can
    avoid future headaches.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在存储方面应该设定什么样的早期目标？我们如何转换它们的状态？嗯，骨架架构完全是关于实验的，如果我们一开始就编写转换功能，我们可能会更早地发现依赖关系。依赖关系并不一定是坏事，除非我们在项目后期发现了很多依赖关系，那时我们早已完成了骨架架构阶段。当然，新功能会添加新的依赖关系。如果我们能尽早使用状态转换来识别潜在的依赖关系，那么我们可以避免未来的麻烦。
- en: What do we have to work with?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们有什么可以工作的？
- en: The last thing we'll need to consider before we roll up our sleeves and start
    implementing this skeleton Flux architecture is what's already in place. For example,
    does this application already have an established API and we're re-architecting
    the frontend? Do we need to retain the user experience of an existing UI? Is the
    project completely greenfield with no API or user experience input?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们卷起袖子开始实现这个骨架Flux架构之前，我们需要考虑的最后一件事情是已经存在的东西。例如，这个应用程序已经有一个建立的API，我们正在重构前端？我们需要保留现有UI的用户体验吗？项目是完全的绿色地带，没有任何API或用户体验输入？
- en: 'The following diagram illustrates how these external factors influence the
    way we treat the implementation of our skeleton architecture:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这些外部因素如何影响我们对待骨架架构实现的方式：
- en: '![What do we have to work with?](img/B05419_03_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![我们有什么可以工作的？](img/B05419_03_04.jpg)'
- en: There's nothing wrong with having these two factors shape our Flux architecture.
    In the case of existing APIs, we'll have a starting point from which we can start
    writing our state transformation functions, to get the user the information that
    they need. In the case of keeping an existing user experience, we already know
    what the shape of our target information looks like, and we can work the transformation
    functions from a different angle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让这两个因素塑造我们的Flux架构并没有什么不妥。在现有API的情况下，我们将有一个起点，从这里我们可以开始编写我们的状态转换函数，为用户提供他们所需的信息。在保持现有用户体验的情况下，我们已经知道我们的目标信息的形状，我们可以从不同的角度工作转换函数。
- en: When the Flux architecture is completely greenfield, we can let it inform both
    the user experience and the APIs that need to be implemented. It's highly unlikely
    that any of the scenarios in which we find ourselves building a skeleton architecture
    will be cut-and-dried. These are just the starting points that we may find ourselves
    in. Having said that, it's time to start implementing some skeleton stores.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当Flux架构完全是绿色地带时，我们可以让它指导用户体验和需要实现的API。我们发现自己构建骨架架构的任何场景都不太可能是非黑即白的。这些只是我们可能发现自己处于的起点。话虽如此，是时候开始实现一些骨架存储了。
- en: Putting stores into action
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将存储付诸实践
- en: In this section, we're going to implement some stores in our skeleton architecture.
    They won't be complete stores capable of supporting end-to-end work-flows. However,
    we'll be able to see where the stores fit within the context of our application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在我们骨架架构中实现一些存储。它们不会是完整的存储，能够支持端到端的工作流程。然而，我们将能够看到存储在我们应用程序的上下文中的位置。
- en: We'll start with the most basic of all store actions, which are populating them
    with some data; this is usually done by fetching it via some API. Then, we'll
    discuss changing the state of remote API data. Finally, we'll look at actions
    that change the state of a store locally, without the use of an API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从所有商店动作中最基本的开始，即用一些数据填充它们；这通常是通过通过某些API获取数据来完成的。然后，我们将讨论更改远程API数据的状态。最后，我们将查看不使用API而更改商店本地状态的动作。
- en: Fetching API data
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取API数据
- en: Regardless of whether or not there's an API with application data ready to consume,
    we know that eventually this is how we'll populate our store data. So it makes
    sense that we think about this as the first design activity of implementing skeleton
    stores.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否有准备好的应用程序数据API可供消费，我们都知道最终我们将以这种方式填充我们的商店数据。因此，将这视为实现骨架商店的第一个设计活动是有意义的。
- en: 'Let''s create a basic store for the homepage of our application. The obvious
    information that the user is going to want to see here is the currently logged-in
    user, a navigation menu, and perhaps a summarized list of recent events that are
    relevant to the user. This means that fetching this data is one of the first things
    our application will have to do. Here''s our first implementation of the store:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序的主页创建一个基本的商店。用户在这里想要看到的最明显的信息是当前登录的用户、一个导航菜单，以及可能是一些与用户相关的最近事件的总结列表。这意味着获取这些数据将是我们的应用程序必须做的第一件事。这是我们的商店的第一个实现：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is fairly easy to follow, so lets point out the important pieces. First,
    we need to import the dispatcher so that we can register our store. When the store
    is created, the default state is stored in the `state` property. When the `HOME_LOAD`
    action is dispatched, we change the state of the store. Lastly, we export the
    store instance as the default module member.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当容易理解，所以让我们指出重要的部分。首先，我们需要导入分发器，以便我们可以注册我们的商店。当商店被创建时，默认状态存储在`state`属性中。当`HOME_LOAD`动作被分发时，我们改变商店的状态。最后，我们将商店实例作为默认模块成员导出。
- en: 'As the action name implies, `HOME_LOAD` is dispatched when data for the store
    has loaded. Presumably, we''re going to pull this data for the home store from
    some API endpoints. Let''s go ahead and put this store to use in our `main.js`
    module—our application entry point:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如动作名称所暗示的，当商店的数据加载完成时，会触发`HOME_LOAD`。我们可能将从某些API端点拉取这些数据用于主商店。让我们继续在`main.js`模块中使用这个商店——我们的应用程序入口点：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is some fairly straightforward usage of our home store. We're logging the
    default state of the store, dispatching the `HOME_LOAD` action with some new payload
    data, and logging the state again to make sure that the state of the store did
    in fact change. So the question is, what does this code have to do with the API?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们主页商店的一些相当直接的使用。我们正在记录商店的默认状态，使用一些新的有效载荷数据分发`HOME_LOAD`动作，并再次记录状态以确保商店的状态确实发生了变化。所以问题是，这段代码与API有什么关系？
- en: This is a good starting point for our skeleton architecture because there's
    a number of things to think about before we even get to implementing API calls.
    We haven't even started implementing actions yet, because if we did, they'd just
    be another distraction. And besides, actions and real API calls are easy to implement
    once we flesh out our stores.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们骨架架构的一个很好的起点，因为在我们开始实现API调用之前，有许多事情需要考虑。我们甚至还没有开始实现动作，因为如果我们这样做，它们只是另一个干扰。此外，一旦我们完善了我们的商店，动作和真实的API调用就很容易实现了。
- en: The first question that comes to mind about the `main.js` module is the location
    of the `dispatch()` call to `HOME_LOAD`. Here, we're bootstrapping data into the
    store. Is this the right place to do this? When the `main.js` module runs will
    we always require that this store be populated? Is this the place where we'll
    want to bootstrap data into all of our stores? We don't need immediate answers
    to these questions, because that would likely result in us dwelling on one aspect
    of the architecture for far too long, and there are many other issues to think
    about.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`main.js`模块的第一个问题可能是`HOME_LOAD`的`dispatch()`调用的位置。在这里，我们正在将数据引导到商店中。这是否是做这件事的正确地方？当`main.js`模块运行时，我们是否总是需要这个商店被填充？这是否是我们想要将数据引导到所有商店的地方？我们不需要立即回答这些问题，因为这可能会让我们在一个架构方面停留得太久，而且还有许多其他问题需要考虑。
- en: For example, does the coupling of our store make sense? The home store we just
    implemented has a `navigation` array. These are just simple strings right now,
    but they'll likely turn into objects. The bigger issue is that the navigation
    data might not even belong in this store—several other stores are probably going
    to require navigation state data too. Another example is the way we're setting
    the new state of the store using the dispatch payload. Using `Object.assign()`
    is advantageous, because we can dispatch the `HOME_LOAD` event with a payload
    with only one state property and everything will continue to function the same.
    Implementing this store took us very little time at all, but we've asked some
    very important questions and learned a powerful technique for assigning new store
    state.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的存储耦合是否合理？我们刚刚实现的首页存储有一个`navigation`数组。这些现在只是简单的字符串，但它们很可能会变成对象。更大的问题是，导航数据甚至可能不属于这个存储——几个其他存储可能也需要导航状态数据。另一个例子是我们设置存储新状态的方式。使用`Object.assign()`是有优势的，因为我们可以用只有一个状态属性的负载派发`HOME_LOAD`事件，而一切都将继续正常工作。实现这个存储几乎花了我们很少的时间，但我们提出了一些非常重要的问题，并学习了一种强大的分配新存储状态的技术。
- en: 'This is the skeleton architecture, and so we''re not concerned with the mechanics
    of actually fetching the API data. We''re more concerned about the actions that
    get dispatched as a result of API data arriving in the browser; in this case,
    it''s `HOME_LOAD`. It''s the mechanics of information flowing through stores that
    matters in the context of a skeleton Flux architecture. And on that note, let''s
    expand the capabilities of our store slightly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是骨架架构，所以我们不关心实际获取API数据的机制。我们更关心的是由于API数据到达浏览器而派发的行动；在这种情况下，它是`HOME_LOAD`。在骨架Flux架构的上下文中，信息通过存储流动的机制才是重要的。关于这一点，让我们稍微扩展一下我们存储的能力：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The store still does everything it did before, only now the store class inherits
    from `EventEmitter`, and when the `HOME_LOAD` action is dispatched, it emits a
    `change` event using the store state as the event data. This gets us one step
    closer to having a full work-flow, as views can now listen to the `change` event
    to get the new state of the store. Let''s update our main module code to see how
    this is done:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 存储仍然做它之前所做的一切，但现在存储类从`EventEmitter`继承，当派发`HOME_LOAD`行动时，它使用存储状态作为事件数据发出一个`change`事件。这让我们更接近拥有完整的工作流程，因为视图现在可以监听`change`事件以获取存储的新状态。让我们更新我们的主模块代码来看看这是如何完成的：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This enhancement to the store in our skeleton architecture brings about yet
    more questions, namely, about setting up event listeners on our stores. As you
    can see, we have to make sure that the handler is actually listening to the store
    before any actions are dispatched. All of these concerns we need to address, and
    we've only just begun to design our architecture. Let's move on to changing the
    state of backend resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们骨架架构中对存储的这种增强带来了更多的问题，即关于在存储上设置事件监听器。正如你所看到的，我们必须确保在派发任何行动之前，处理程序实际上正在监听存储。我们需要解决所有这些关注点，而我们刚刚才开始设计我们的架构。让我们继续到改变后端资源的状态。
- en: Changing API resource state
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改API资源状态
- en: 'After we''ve set the initial store state by asking the API for some data, we''ll
    likely end up needing to change the state of that backend resource. This happens
    in response to user activity. In fact, the common pattern looks like the following
    diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过向API请求一些数据设置初始存储状态后，我们可能最终需要改变后端资源的状态。这是对用户活动的响应。事实上，常见的模式看起来像以下图表：
- en: '![Changing API resource state](img/B05419_03_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![更改API资源状态](img/B05419_03_05.jpg)'
- en: Let's think about this pattern in the context of a Flux store. We've already
    seen how to load data into a store. In the skeleton architecture we're building,
    we're not actually making these API calls, even if they exist—we're focused solely
    on the information that's produced by the frontend right now. When we dispatch
    an action that changes the state of a store, we'll probably need to update the
    state of this store in response to successful completion of the API call. The
    real question is, what does this entail exactly?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Flux存储的上下文中思考这个模式。我们已经看到了如何将数据加载到存储中。在我们构建的骨架架构中，我们实际上并没有进行这些API调用，即使它们存在——我们只专注于当前前端产生的信息。当我们派发一个改变存储状态的行动时，我们可能需要更新这个存储的状态，以响应API调用的成功完成。真正的问题是，这具体意味着什么？
- en: For example, does the call we make to change the state of the backend resource
    actually respond with the updated resource, or does it respond with a mere success
    indication? These types of API patterns have a dramatic impact on the design of
    our stores because it means the difference between having to always make a secondary
    call or having the data in the response.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们调用更改后端资源状态实际上会返回更新后的资源，还是只返回一个成功的指示？这些类型的API模式对我们存储库的设计有重大影响，因为它意味着在必须始终进行二次调用或数据在响应中可用之间的区别。
- en: 'Let''s look at some code now. First, we have a user store as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码。首先，我们有一个如下所示的用户存储库：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll assume that this singular user store is for a page in our application
    where only a single user is displayed. Now, let''s implement a store that''s useful
    for tracking the state of several users:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这个单一的用户存储库是我们应用程序中的一个页面，其中只显示单个用户。现在，让我们实现一个用于跟踪多个用户状态的存储库：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s now create the `main.js` module that will work with these stores. In
    particular, we want to see how interacting with the API to change the state of
    a backend resource will influence the design of our stores:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`main.js`模块，它将与这些存储库一起工作。特别是，我们想看看与API交互以更改后端资源的状态将如何影响我们存储库的设计：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we can see that the `createUser()` function serves as a proxy for the
    actual API implementation. Remember, this is a skeleton architecture where the
    chief concern is the information constructed by our stores. Implementing a function
    that returns a promise is perfectly acceptable here because this is very easy
    to change later on once we start talking to the real API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`createUser()`函数充当实际API实现的代理。记住，这是一个骨架架构，主要关注的是我们存储库构建的信息。实现一个返回Promise的函数在这里是完全可接受的，因为一旦我们开始与真实API通信，这很容易在以后进行更改。
- en: We're on the lookout for interesting aspects of our stores—their state, how
    that state changes, and the dependencies between our stores. In this case, when
    we create the new user, the API returns the new object. Then, this is dispatched
    as a `USER_LOAD` action. Our `userStore` is now populated. We're also dispatching
    a `USER_ADD` action so that the new user data can be added to this list. Presumably,
    these two stores service different parts of our application, and yet the same
    API call that changes the state of something in the backend is relevant.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找我们存储库的有趣方面——它们的状态、状态如何变化以及存储库之间的依赖关系。在这种情况下，当我们创建新用户时，API返回新对象。然后，这作为`USER_LOAD`操作被派发。现在我们的`userStore`已经填充。我们还派发了一个`USER_ADD`操作，以便将新用户数据添加到这个列表中。假设这两个存储库服务于我们应用程序的不同部分，但更改后端中某物状态的相同API调用是相关的。
- en: What can we learn about our architecture from all of this? For starters, we
    can see that the promise callback is going to have to dispatch multiple actions
    for multiple stores. This means that we can probably expect more of the same with
    similar API calls that create resources. What about calls that modify users, would
    the code look similar?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能从所有这些中学到关于我们架构的什么？首先，我们可以看到Promise回调将不得不为多个存储库派发多个操作。这意味着我们可能期望在创建资源的类似API调用中看到更多相同的情况。那么，修改用户的调用会看起来相似吗？
- en: Something that we're missing here is an action to update the state of a user
    object within the array of users in `userListStore`. Alternatively, we could have
    this store also handle the `USER_LOAD` action. Any approach is fine, it's the
    exercise of building the skeleton architecture that's supposed to help us find
    the approach that best fits our application. For example, we're dispatching a
    single `USER_REMOVE` action here too, and this is handled easily by both our stores.
    Maybe this is the approach we're looking for?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里缺少的是更新`userListStore`中用户数组中用户对象状态的操作。或者，我们也可以让这个存储库也处理`USER_LOAD`操作。任何方法都可以，构建骨架架构的练习应该帮助我们找到最适合我们应用程序的方法。例如，我们在这里也派发了一个单一的`USER_REMOVE`操作，并且这两个存储库都能轻松处理。这可能就是我们要找的方法？
- en: Local actions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地操作
- en: We'll close the section on store actions with a look at local actions. These
    are actions that have nothing to do with the API. Local actions are generally
    in response to user interactions, and dispatching them will have a visible effect
    on the UI. For example, the user wants the toggle the visibility of some component
    on the page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用查看本地操作来结束存储库操作的章节。这些操作与API无关。本地操作通常是响应用户交互的，派发它们将对UI产生可见的影响。例如，用户想要切换页面上某些组件的可见性。
- en: 'The typical application would just execute a jQuery one-liner to locate the
    element in the DOM and make the appropriate CSS changes. This type of thing doesn''t
    fly in Flux architectures, and it''s the type of thing we should start thinking
    about during the skeleton architecture phase of our application. Let''s implement
    a simple store that handles local actions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的应用程序会执行一个jQuery单行代码来定位DOM中的元素并做出适当的CSS更改。这种类型的事情在Flux架构中行不通，而且我们应该在我们的应用程序骨架架构阶段开始考虑这种类型的事情。让我们实现一个简单的存储库来处理本地动作：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `PANEL_TOGGLE` action and the `ITEM_SELECT` action are two local actions
    handled by this store. They''re local because they''re likely triggered by the
    user clicking a button or selecting a checkbox. Let''s dispatch these actions
    so we can see how our store handles them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`PANEL_TOGGLE`动作和`ITEM_SELECT`动作是这个存储库处理的两个本地动作。它们是局部的，因为它们很可能是用户点击按钮或选择复选框触发的。让我们分派这些动作，以便我们可以看到我们的存储库如何处理它们：'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example serves as an illustration as to why we should consider all things
    state-related during the skeleton architecture implementation phase. Just because
    we're not implementing actual UI components right now, doesn't mean we can't guess
    at some of the potential states of common building blocks. In this code, we've
    discovered that the `ITEM_SELECT` action is actually dependent on the `PANEL_TOGGLE`
    action. This is because we don't actually want to select an item and update the
    view when the panel is disabled.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了为什么在骨架架构实现阶段，我们应该考虑所有与状态相关的事项。仅仅因为我们现在没有实现实际的UI组件，并不意味着我们不能猜测一些常见构建块的潜在状态。在这段代码中，我们发现`ITEM_SELECT`动作实际上依赖于`PANEL_TOGGLE`动作。这是因为我们实际上不希望在面板禁用时选择一个项目并更新视图。
- en: Building on this idea, should other components be able to dispatch this action
    in the first place? We've just found a potential store dependency, where the dependent
    store would query the state of `panelStore` before actually enabling UI elements.
    All of this from local actions that don't even talk to APIs, and without actual
    user interface elements. We're probably going to find many more items like this
    throughout the course of our skeleton architecture, but don't get hung up on finding
    everything. The idea is to learn what we can, while we have an opportunity to,
    because once we start implementing real features, things become more complicated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在这一点上，其他组件是否应该首先能够分派这个动作？我们刚刚发现一个潜在的存储依赖，其中依赖的存储库在实际上启用UI元素之前会查询`panelStore`的状态。所有这些都是从甚至不与API交谈的本地动作中发现的，而且没有实际的用户界面元素。我们可能会在我们的骨架架构过程中发现更多这样的项目，但不要陷入寻找所有事物的困境。我们的想法是在有机会的时候学习我们能学到的东西，因为一旦我们开始实现真实的功能，事情就会变得更加复杂。
- en: Stores and feature domains
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和特性领域
- en: With more traditional frontend architectures, models that map directly to what's
    returned from the API provide a clear and concise data model for our JavaScript
    components to work with. Flux, as we now know, leans more in the direction of
    the user, and focuses on the information that they need to see and interact with.
    This doesn't need to be a gigantic headache for us, especially if we're able to
    decompose our user interface into domains. Think of a domain as a really big feature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在更传统的前端架构中，直接映射到API返回结果的模型为我们的JavaScript组件提供了一个清晰简洁的数据模型。正如我们所知，Flux更倾向于用户方向，并专注于他们需要看到和交互的信息。这不应该成为我们的巨大头痛，特别是如果我们能够将用户界面分解为领域。将领域想象成一个非常大的特性。
- en: In this section, we'll talk about identifying the top-level features that form
    the core of our UI. Then, we'll work on shedding irrelevant API data from the
    equation. We'll finish the section with a look at the structure of our store data,
    and the role it plays in the design of our skeleton architecture.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论识别构成我们UI核心的顶级特性。然后，我们将努力从方程式中去除无关的API数据。我们将以查看我们的存储数据结构及其在骨架架构设计中的作用来结束本节。
- en: Identifying top-level features
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别顶级特性
- en: During the skeleton architecture phase of our Flux project, we should jump in
    and start writing store code, just as we've done in this chapter. We've been thinking
    about the information the user is going to need and how we can best get this information
    to the user. Something we didn't spend a lot of time on upfront was trying to
    identify the top level features of the application. This is fine, because the
    exercises we've performed so far in this chapter are often a prerequisite for
    figuring out how to organize our user interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们Flux项目的骨架架构阶段，我们应该积极参与并开始编写store代码，就像我们在本章中所做的那样。我们一直在思考用户可能需要的信息以及我们如何最好地将这些信息传递给用户。我们一开始并没有花太多时间去尝试识别应用程序的最高级功能。这是可以的，因为在本章中我们已经完成的练习通常是确定如何组织用户界面的先决条件。
- en: However, once we've identified how we're going to implement some of the low-level
    store mechanisms that get us the information we're after, we need to start thinking
    about these top-level features. And there's a good reason for this—the stores
    we ultimately maintain will map to these features. When we say top-level, it's
    tempting to use the navigation as the point of reference. There's actually nothing
    wrong with using the page navigation as a guide; if it's big enough for the main
    navigation, it's probably a top-level feature that's worthy of its own Flux store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们确定了如何实现一些低级store机制来获取我们所需的信息，我们就需要开始考虑这些最高级功能。这样做有一个很好的理由——我们最终维护的store将映射到这些功能上。当我们说最高级时，很容易以导航作为参考点。实际上，使用页面导航作为指南并没有什么不妥；如果它足够大，可以用于主要导航，那么它可能是一个值得拥有自己Flux
    store的最高级功能。
- en: In addition to being a top-level feature, we need to think about the role of
    the store—why does it exist? What value does this add for the user? The reason
    these questions are important is because we could end up having six pages that
    all could have used the same store. So it's a balance between consolidating value
    into one store and making sure that the store isn't to large and general-purpose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是一个最高级功能之外，我们还需要考虑store的作用——为什么它存在？它为用户增加了什么价值？这些问题之所以重要，是因为我们可能会最终有六个页面，它们都可以使用同一个store。因此，这是一个在将价值整合到一个store和确保store不是太大且通用之间取得平衡的问题。
- en: Applications are complex, with lots of moving parts that drive lots of features.
    Our user interface probably has 50 awesome features. But this is unlikely to require
    50 awesome top-level navigation links and 50 Flux stores. Our stores will have
    to represent the complex intricacies of these features in their data, at some
    point. This comes later though, for now we just need to get a handle on approximately
    how many stores we're working with, and how many dependencies we have between
    them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很复杂，有很多动态部分驱动着许多功能。我们的用户界面可能拥有50个令人惊叹的功能。但这不太可能需要50个令人惊叹的最高级导航链接和50个Flux
    store。我们的store将不得不在某个时候用它们的数据表示这些功能的复杂细节。但这将在稍后进行，现在我们只需要大致了解我们正在处理多少个store，以及它们之间有多少依赖关系。
- en: Irrelevant API data
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无关的API数据
- en: Use it or lose it—the mantra of Flux store data. The challenge with API data
    is that it's a representation of a backend resource—it's not going to return data
    that's specifically required for our UI. An API exists so that more than one UI
    can be built on it. However, this means that we often end up with irrelevant data
    in our stores. For example, if we only need a few properties from an API resource,
    we don't want to store 36 properties. Especially when some of these can themselves
    be collections. This is wasteful in terms of memory consumption, and confusing
    in terms of their existence. It's actually the latter point that's more concerning
    because we can easily mislead other programmers working on this project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用之或不弃之——这是Flux store数据的座右铭。API数据的挑战在于它是对后端资源的表示——它不会返回专门为我们UI所需的数据。API的存在是为了让多个UI可以基于它构建。然而，这意味着我们经常在我们的store中遇到无关数据。例如，如果我们只需要从API资源中获取几个属性，我们不想存储36个属性。尤其是当其中一些本身可以是集合时。这在内存消耗方面是浪费的，在存在性方面也是令人困惑的。实际上，后一点更令人担忧，因为我们很容易误导其他在这个项目上工作的程序员。
- en: 'One potential solution is to exclude these unused values from the API response.
    Many APIs today support this, by letting us opt-in to the properties we want returned.
    And this is probably a good idea if it means drastically reduced network bandwidth.
    However, this approach can also be error-prone because we have to perform this
    filtering at the ajax call level, instead of at the store level. Let''s look at
    an example that takes a different approach, by specifying a store record:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是排除 API 响应中的这些未使用值。许多 API 今天支持这一点，允许我们选择我们想要返回的属性。如果这意味着大幅减少网络带宽，这可能是一个好主意。然而，这种方法也可能存在错误，因为我们必须在
    AJAX 调用级别执行此过滤，而不是在存储级别。让我们看看一个采用不同方法的例子，通过指定存储记录：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, the default `state` object plays an important role, other
    than providing default state values. It also provides the store record. In other
    words, the property keys used by the default state determine the allowable values
    when the `PLAYER_LOAD` action is dispatched. Let''s see if this works as expected:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，默认的 `state` 对象除了提供默认状态值外，还扮演着重要的角色，它还提供了存储记录。换句话说，默认状态使用的属性键决定了在派发 `PLAYER_LOAD`
    动作时的允许值。让我们看看它是否按预期工作：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Structuring store data
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化存储数据
- en: All of the examples shown so far in this chapter have relatively simple state
    objects within stores. Once we build the skeleton architecture up, these simple
    objects will turn into something more complicated. Remember, the state of a store
    reflects the state of the information that the user is looking at. This includes
    the state of some of the elements on the page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中迄今为止展示的所有示例都在存储中具有相对简单的状态对象。一旦我们构建起骨架架构，这些简单的对象将变得更为复杂。记住，存储的状态反映了用户查看的信息的状态。这包括页面上的某些元素的状态。
- en: This is something we need to keep an eye on. Just because we're through performing
    the skeleton architecture exercise doesn't mean an idea will hold up as we start
    to implement more elaborate features. In other words, if a store state becomes
    too large—too nested and deep—then it's time to consider moving our stores around
    a little bit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要关注的事情。仅仅因为我们完成了骨架架构练习，并不意味着一个想法在我们开始实现更复杂的功能时仍然有效。换句话说，如果一个存储状态变得太大——太嵌套和深入——那么是时候考虑稍微移动我们的存储了。
- en: The idea is that we don't want too many stores driving our views, because they're
    more like models from an MVC architecture at this point. We want the stores to
    represent a specific feature of the application. This doesn't always work out,
    because we could end up having some complex and convoluted state in the store
    for the feature. In this case, our top-level feature needs to be split somehow.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们不希望有太多的存储驱动我们的视图，因为它们在这个阶段更像是 MVC 架构中的模型。我们希望存储代表应用程序的特定功能。这并不总是行得通，因为我们可能会在存储中为该功能结束一些复杂和混乱的状态。在这种情况下，我们的顶级功能需要以某种方式拆分。
- en: This will no doubt happen at some point during our time with Flux, and there's
    no rule in place that says when it's time to refactor stores. Instead, if the
    state data stays at a size where it feels comfortable to work with, you're probably
    fine with the store as it is.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑会在我们使用 Flux 的时间段的某个时刻发生，而且没有规则规定何时应该重构存储。相反，如果状态数据的大小让你感觉可以舒适地与之工作，那么你很可能对当前的存储状态感到满意。
- en: Bare bone views
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁的视图
- en: We've made some progress with our skeleton stores to the point where we're ready
    to start looking at skeleton views. These are simple classes, much in the same
    spirit as stores are, except we're not actually rendering anything to the DOM.
    The idea with these bare bone views is to affirm the sound infrastructure of our
    architecture, and that these view components are in fact getting the information
    they expect. This is crucial because the views are the final item in the Flux
    data-flow, so if they're not getting what they need, when they need it, we need
    to go back and fix our stores.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在骨架存储方面取得了一些进展，现在我们准备开始查看骨架视图。这些是简单的类，与存储的精神非常相似，但我们实际上并没有将任何内容渲染到 DOM 中。这些简洁视图的目的是确认我们架构的坚实基础，并确保这些视图组件确实获得了他们期望的信息。这是至关重要的，因为视图是
    Flux 数据流中的最后一项，所以如果它们没有得到他们需要的信息，或者在他们需要的时候没有得到，我们就需要回去修复我们的存储。
- en: In this section, we'll discuss how our bare-boned views can help us more quickly
    identify when stores are missing a particular piece of information. Then, we'll
    look at how these views can help us identify potential actions in our Flux application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论我们的基本视图如何帮助我们更快地识别存储缺失特定信息的情况。然后，我们将探讨这些视图如何帮助我们识别Flux应用程序中的潜在动作。
- en: Finding missing data
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找缺失数据
- en: The first activity we'll perform with our bare bone views is figuring out whether
    or not the stores are passing along all the essential information required by
    the view. By essential, we're talking about things that would be problematic for
    the user were they not there. For example, we're looking at a settings page, and
    there's a whole section missing. Or, there's a list of options to select from,
    but we don't actually have the string labels to show because they're part of some
    other API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基本视图执行的第一项活动是确定存储是否传递了视图所需的所有基本信息。就基本而言，我们谈论的是如果它们不存在，就会对用户造成问题的东西。例如，我们正在查看一个设置页面，有一个整个部分缺失。或者，有一个选项列表可供选择，但我们实际上没有字符串标签来显示，因为它们是某个其他API的一部分。
- en: Once we figure out that these critical pieces of information are missing from
    the store, the next step is to determine if they're a possibility, because if
    they're not, we've just avoided spending an inordinate amount of time implementing
    a full-fledged view. However, these are the rare cases. Usually, it isn't a big
    deal to go back to the store in question and add the missing transformation that
    will compute and set the missing state we're looking for.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定这些关键信息缺失，下一步就是确定它们是否可能，因为如果它们不可能，我们就避免了花费大量时间实现一个完整的视图。然而，这些是罕见的情况。通常，回到有问题的存储并添加缺失的转换，以计算和设置我们正在寻找的缺失状态，并不是什么大问题。
- en: How much time do we need to spend on these bare bone views? Think of it this
    way—as we start implementing the actual views that render to the DOM for us, we'll
    discover more missing state from the store. These, however, are superficial and
    easy to fix. With the bare bone views, we're more concerned with teasing out the
    critical parts that are missing. What can we do with these views when we're done
    with them? Are they garbage? Not necessarily, depending on how we want to implement
    our production views, we could either adjust them to become ReactJS components
    or we could embed the actual view inside the bare-bone view, making it more of
    a container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这些基本视图上花费多少时间？可以这样想——当我们开始实现实际视图，这些视图将渲染到DOM中时，我们会发现更多从存储中缺失的状态。然而，这些只是表面的，并且容易修复。对于基本视图，我们更关注挖掘缺失的关键部分。完成这些视图后，我们能做什么？它们是垃圾吗？不一定，根据我们如何实现我们的生产视图，我们可以调整它们成为ReactJS组件，或者我们可以在基本视图内嵌入实际视图，使其更像是一个容器。
- en: Identifying actions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别动作
- en: As we saw earlier in the chapter, the first set of actions to be dispatched
    by a given Flux architecture are going to be related to fetching data from the
    backend API. Ultimately, these are the start of the data-flows that end with the
    views. Sometimes, these are merely *load* type actions, where we're explicitly
    saying to go fetch the resource and populate our store. Other times, we might
    have more abstract actions that describe the action taken by the user, resulting
    in several stores being populated from many different API endpoints.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，给定Flux架构将要分发的第一组动作将与从后端API获取数据有关。最终，这些是导致视图的数据流的开始。有时，这些仅仅是*加载*类型的动作，我们明确表示去获取资源并填充我们的存储。有时，我们可能有更抽象的动作，这些动作描述了用户采取的动作，导致多个存储从许多不同的API端点被填充。
- en: This gets the user to a point where we can start thinking about how they're
    going to want to interact with this information. The only way they do so is by
    dispatching more actions. Let's create a view with some action methods. Essentially,
    the goal is to have access our views from the browser JavaScript console. This
    lets us view the state information associated with the view at any given point,
    as well as call the method to dispatch the given action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用户带到我们可以开始考虑他们如何与这些信息交互的点。他们唯一能这样做的方式就是通过分发更多的动作。让我们创建一个带有一些动作方法的视图。本质上，目标是能够从浏览器JavaScript控制台访问我们的视图。这让我们可以在任何给定点查看与视图关联的状态信息，以及调用方法来分发给定的动作。
- en: 'To do this, we need to adjust our Webpack configuration slightly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要稍微调整我们的Webpack配置：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This one line will export a global `views` variable in the browser window,
    and its value will be whatever our `main.js` module exports. Let''s have a look
    at this now:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将导出一个全局的`views`变量到浏览器窗口中，其值将是我们的`main.js`模块导出的内容。现在让我们来看看这一点：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Well, this looks interesting. We''re simply exporting our view as `settings`.
    So, as we''re creating our bare bone views in the skeleton architecture, we simply
    follow this pattern in `main.js` to keep adding views to the browser console to
    experiment with. Let''s now take a look at the settings view itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这看起来很有趣。我们只是将视图导出为`settings`。因此，当我们创建骨架架构中的基本视图时，我们只需在`main.js`中遵循此模式，不断将视图添加到浏览器控制台以进行实验。现在让我们来看看设置视图本身：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The only thing left to do now is to see what''s available in the browser console
    when we load this page. We should have a global `views` variable, and this should
    have each of our view instances as properties. Now, we get to play around with
    actions dispatched by views as though we''re users clicking around in the DOM.
    Let''s see how this looks:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的唯一事情就是看看当我们加载这个页面时浏览器控制台中有什么。我们应该有一个全局的`views`变量，并且这个变量应该有我们每个视图实例作为属性。现在，我们可以像用户在DOM中点击一样玩转视图派发的操作。让我们看看这看起来怎么样：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: End-to-end scenarios
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端场景
- en: At some point, we're going to have to wrap up the skeleton architecture phase
    of the project and start implementing real features. We don't want the skeleton
    phase to drag on for too long because then we'll start making too many assumptions
    about the reality of our implementation. At the same time, we'll probably want
    to walk through a few end-to-end scenarios before we move on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们将不得不结束项目骨架架构阶段，并开始实现真实的功能。我们不希望骨架阶段拖得太久，因为这会导致我们对实现现实的假设过多。同时，在我们继续前进之前，我们可能想要走几个端到端场景。
- en: The aim of this section is to provide you with a few high-level points to be
    on the lookout for in each architectural layer. These aren't strict criteria,
    but they can certainly help us formulate our own measurements that determine whether
    or not we've adequately answered our questions about the information architecture
    by building a skeleton. If we're feeling confident, it's time to go full steam
    and flesh out the application detail—the subsequent chapters in this book dive
    into the nitty-gritty of implementing Flux.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是向您提供一些高级要点，以便在每一层架构中留意。这些不是严格的标准，但它们确实可以帮助我们制定自己的衡量标准，以确定通过构建骨架是否充分回答了关于信息架构的问题。如果我们感到自信，那么是时候全力以赴，详细阐述应用程序的细节了——本书的后续章节将深入探讨实现Flux的细节。
- en: Action checklist
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作清单
- en: 'The following items are worth thinking about when we''re implementing actions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现操作时，以下项目值得思考：
- en: Do our features have actions that bootstrap store data by fetching it from the
    API?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的功能是否有通过从API获取数据来引导存储数据的操作？
- en: Do we have actions that change the state of backend resources? How are these
    changes reflected in our frontend Flux stores?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有改变后端资源状态的操作？这些更改如何在我们的前端Flux存储中反映？
- en: Does a given feature have any local actions, and are they distinct from actions
    that issue API requests?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的功能是否有任何本地操作，并且它们是否与发出API请求的操作不同？
- en: Store checklist
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储清单
- en: 'The following items are worth thinking about when implementing stores:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现存储时，以下项目值得思考：
- en: Does the store map to a top-level feature in our application?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储是否映射到我们应用程序中的顶级功能？
- en: How well does the data structure of the store meet the needs of the views that
    use it? Is the structure too complex? If so, can we refactor the store into two
    stores?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的数据结构是否满足使用它的视图的需求？结构是否过于复杂？如果是这样，我们能否将存储重构为两个存储？
- en: Do the stores discard API data that isn't used?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储是否丢弃了未使用的API数据？
- en: Do the stores map API data to relevant information that the user needs?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储是否将API数据映射到用户所需的相关信息？
- en: Is our store structure amenable to change once we start adding more elaborate
    view functionality?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们开始添加更复杂视图功能时，我们的存储结构是否易于更改？
- en: Do we have too many stores? If so, do we need to rethink the way we've structured
    the top-level application features?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有太多的存储？如果是这样，我们是否需要重新思考我们构建顶级应用程序功能的方式？
- en: View checklist
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图清单
- en: 'The following items are worth thinking about when implementing views:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现视图时，以下项目值得思考：
- en: Does the view get the information it needs out of the store?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图是否从存储中获取所需的信息？
- en: Which actions result in the view rendering?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些操作会导致视图渲染？
- en: Which actions does the view dispatch, in response to user interaction?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图在响应用户交互时派发了哪些动作？
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about getting started with a Flux architecture by building
    some skeleton components. The goal being to think about the information architecture,
    without the distraction of other implementation issues. We could find ourselves
    in a situation where the API is already defined for us, or where the user experience
    is already in place. Either of these factors will influence the design of our
    stores, and ultimately the information we present to our users.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于通过构建一些骨架组件来开始使用Flux架构。目标是思考信息架构，而不受其他实现问题的干扰。我们可能会发现自己处于API已经定义好或者用户体验已经到位的情况。这两个因素中的任何一个都将影响我们存储的设计，以及最终我们向用户展示的信息。
- en: The stores we implemented were basic, loading data when the application starts
    and updating their state in response to an API call. We did, however, learn to
    ask the pertinent questions about our stores, such as the approach taken with
    parsing the new data to set as the store's state, and how this new state will
    affect other stores.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的存储是基本的，当应用程序启动时加载数据，并响应API调用更新其状态。然而，我们确实学会了提出关于我们存储的相关问题，例如，如何解析新数据并将其设置为存储的状态，以及这种新状态将如何影响其他存储。
- en: Then, we thought about the top-level features that form the core of our application.
    These features give a good indication of the stores that our architecture will
    need. Toward the end of the skeleton architecture phase, we want to walk through
    a few end-to-end scenarios to sanity-check our chosen information design. We looked
    at a few high-level checklist items to help ensure we didn't leave anything important
    out. In the following chapter, we'll take a deeper look at actions and how they're
    dispatched.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们思考了构成我们应用程序核心的顶级特性。这些特性为我们架构所需存储提供了良好的指示。在骨架架构阶段的后期，我们希望通过几个端到端场景来验证我们选择的信息设计是否合理。我们查看了一些高级清单项，以确保我们没有遗漏任何重要内容。在下一章中，我们将更深入地探讨动作及其分发方式。
