- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and Monitoring Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining records and metrics provides us with many advantages during our
    development cycle. They can help us increase our application’s performance, observe
    issues before they become problems, and give us insights into the application’s
    state. Logging and monitoring your application can reduce the time your development
    (and debugging) takes, as well as the number of headaches you acquire throughout
    the project. Logging is something that is often overlooked or treated with minimal
    afterthought, but it could make the difference between losing an hour’s worth
    of uptime or an entire day’s worth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we had an application that simply inserted the details of a registration
    form into a database table. One day, the team accidentally renamed the `first_name`
    column to `firstname` and now no new records were being inserted. With logging,
    we would see something along the lines of a “`first_name` column does not exist”
    type of error. This would help guide us into looking at the database’s schema
    and figuring out where the disconnection is occurring (in this case, our typo
    from removing the underscore).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What if the error was more complex than that though? Our application is now
    running in a cluster and each node within the cluster receives a unique message
    exclusively from the other nodes. Occasionally, we would notice our table was
    missing some records without a clear pattern from the data itself. Using a logging
    mechanism, we would occasionally see a `Could not establish connection` error.
    We can double-check our connection pooling management (if applicable) or test
    each node if we can successfully connect to the database. On a small cluster,
    this would not be a problem, but on a large system, this could become tedious
    and time-consuming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: A solution for helping manage applications in a larger cluster would be to customize
    (or add) additional context to your application’s logging records. Meta-information
    such as the machine’s identifier could have helped us in the previous example.
    Sequelize offers a way to customize our logging, using an `options.logging` parameter,
    with the ability to change the logging behavior with different method invocations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logging with all of the available interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating third-party logging applications such as Pino or Bunyan
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting metrics and statistics for Sequelize with OpenTelemetry
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter at [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch8)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logging with all of the available interfaces
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequelize offers a few overload signatures for incorporating logs into an application.
    The default behavior is to call `console.log` for each query. The following is
    a list of signatures that Sequelize will abide by:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`function (msg) {}`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function (...msg) {}`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true`/`false`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg => someLogger.debug(msg)`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`someLogger.debug.bind(someLogger)`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we wanted to customize Sequelize’s logging behavior, the following example
    would be a quick introduction to how to do so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to Sequelize sending the SQL queries into our `customLog` function,
    we are also given a helper method for when we need to log additional info beyond
    our queries. The Sequelize instance provides a `log` method and can be called
    as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If your Sequelize instance’s `benchmark` parameter is set to `true`, then Sequelize
    will add the total elapsed time for the query to complete at the end of the message.
    Using our previous example, a log entry might look something similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, we will want to log the log query, query objects, applicable parameters,
    or any other form of metadata. Sequelize will recognize the spread pattern for
    this type of support:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now call the Sequelize instance’s `log` method, which will send the
    parameters to our `multiLog` function as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would print each parameter onto its own newline due to the behavior of
    the `multiLog` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The logging parameter can also accept a Boolean value. The `true` value will
    coalesce into Sequelize’s default behavior (`console.log`). Setting the value
    to `false` would disable logging completely and nullify any log invocations. The
    following example would prevent Sequelize from logging queries:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The `true` value for logging is considered deprecated and is not preferable
    to omitting the logging value for the default behavior or using `console.log`
    as the parameter’s value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequelize can also limit logging to specific queries with the logging parameter
    on each queryable method (for example, `findAll`, `update`, and `create`). For
    instance, if we wanted to disable logging on a specific query, we can do so by
    setting the following query’s `logging` parameter to `false`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You can also see a log output of queries by taking advantage of Sequelize’s
    use of the debug NPM package. By setting the environment variable to `DEBUG=sequelize:sql*`,
    your terminal should show queries executed by Sequelize.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Integrating third-party logging applications such as Pino or Bunyan
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If our application already utilizes a third-party application for logging, Sequelize
    can offer support for integrating with such systems. This section references two
    logging applications, Pino and Bunyan, but any logging library or framework should
    also be compatible with Sequelize.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Pino
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pino is a low overhead Node.js logger that also offers redaction, transport,
    and asynchronous support. Presuming our project has Pino installed within our
    `node_modules` folder, we can simply integrate it with our Sequelize instance
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, when we call `sequelize.log` manually or execute queries, the logs will
    be sent to the Pino logging library. The output would look similar to this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For more information on Pino, you can refer to the project’s repository at [https://github.com/pinojs/pino](https://github.com/pinojs/pino).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Bunyan
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes a logging framework requires an intermediary step before being able
    to bind the framework to Sequelize. An example of this would be the Bunyan framework.
    Bunyan is a logging framework that focuses on offering serialization and streaming
    methods. Integrating this framework would look similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example shows the output of Bunyan’s logging with Sequelize:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information on Bunyan, you can refer to the project’s repository at
    [https://github.com/trentm/node-bunyan](https://github.com/trentm/node-bunyan).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: From the Pino and Bunyan examples, we can see that adding a logging framework
    already resolves our unique machine identifier, the time of the error, and urgency
    research. By looking at the logs, it should now be easier to sift through wherever
    an error is occurring within clusters or applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now finish integrating a logging framework within the Avalon Airlines
    project. From the project’s root directory, we will need to install the necessary
    package:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Within `models/index.js`, see the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Export the Pino framework underneath with a constant:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After exporting the constant, see this line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Underneath, we can add the logging parameter to the `config` object as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, our application supports custom logs using the Pino logging framework.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Collecting metrics and statistics for Sequelize with OpenTelemetry
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenTelemetry is a standardized specification for collecting, aggregating, and
    instrumenting various statistics, metrics, traces, and logs. OpenTelemetry can
    help us identify where bottlenecks may occur, categorize and apply topological
    filters on logs, and plug into third-party applications (for example, for alert
    monitoring).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate OpenTelemetry with Sequelize, we would need to install the following
    packages within our Avalon Airlines project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within `models/index.js`, under the `''use strict'';` line, we can now add
    our new packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just above the `let sequelize;` line, we can add the trace provider, which
    will register the correct Sequelize OpenTelemetry plugin:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Below the `traceProvider` declaration block, we can associate the provider
    with the Sequelize instrument specifications:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional references and option parameters for Sequelize instrumentation
    at [https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize](https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize](https://github.com/aspecto-io/opentelemetry-ext-js/tree/master/packages/instrumentation-sequelize)找到关于
    Sequelize 仪表化的额外参考和选项参数。
- en: 'At the root directory of the Avalon Airlines project, create a file called
    `tracing.js` with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Avalon Airlines 项目的根目录下，创建一个名为 `tracing.js` 的文件，并包含以下代码：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can call our application with the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令调用我们的应用程序：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After that, open a browser to the project’s URL (by default, `http://localhost:3000/`)
    and refresh the page a few times. After a few seconds, you should see some events
    within your terminal that look similar to this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开浏览器访问项目的 URL（默认为 `http://localhost:3000/`）并刷新页面几次。几秒钟后，你应该能在你的终端看到一些类似以下的事件：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Traditionally, the application would export this data to a collector such as
    Zipkin ([https://zipkin.io/](https://zipkin.io/)), Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)),
    or Prometheus ([https://prometheus.io/](https://prometheus.io/)). For instructions
    on how to associate the application’s telemetry data, you can refer to this tutorial
    here: https://opentelemetry.io/docs/instrumentation/js/exporters/.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序会将这些数据导出到收集器，如 Zipkin ([https://zipkin.io/](https://zipkin.io/))、Jaeger
    ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)) 或 Prometheus
    ([https://prometheus.io/](https://prometheus.io/))。有关如何关联应用程序的遥测数据的说明，请参阅此教程：https://opentelemetry.io/docs/instrumentation/js/exporters/。
- en: 'If you were to use Zipkin as your collector, then under the `const tracerProvider
    = new NodeTracerProvider({` block within `models/index.js`, we would replace this
    line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用 Zipkin 作为你的收集器，那么在 `models/index.js` 文件中的 `const tracerProvider = new
    NodeTracerProvider({)` 块下，我们将替换这一行：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to replace it with the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will tell our trace provider to export the traces and logs to the Zipkin
    Exporter (multiple exporters can be used at the same time).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示我们的跟踪提供程序将跟踪和日志导出到 Zipkin 导出器（可以同时使用多个导出器）。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the different overload signatures for configuring
    logging with Sequelize. We also learned how to integrate third-party frameworks,
    such as OpenTelemetry, within our Node.js application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了配置 Sequelize 日志的不同重载签名。我们还学习了如何在我们的 Node.js 应用程序中集成第三方框架，例如 OpenTelemetry。
- en: In the next chapter, we will be covering how to integrate plugins, or adapters,
    into our Sequelize instance. The following chapter will also demonstrate how to
    create our own adapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何将插件或适配器集成到我们的 Sequelize 实例中。下一章也将演示如何创建我们自己的适配器。
