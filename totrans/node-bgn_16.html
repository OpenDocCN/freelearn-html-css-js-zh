<html><head></head><body>
		<div><h1 id="_idParaDest-408" class="chapter-number"><a id="_idTextAnchor416"/>16</h1>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor417"/>Deploying Node.js Applications</h1>
			<p>In this chapter, we will learn how to deploy our application to the public internet. We will learn how important it is to have a clear definition of the requirements and how to choose the best solution for our needs. We will push the application code to the GitHub repository in order to use GitHub Actions for continuous integration.</p>
			<p>Finally, We will deploy the application in DigitalOcean and we will use PM2 to keep the application running. We will configure and use MongoDB Atlas to host the database in the cloud.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How to define the requirements and how to choose the best solution for our needs</li>
				<li>How to push the application code to the GitHub repository</li>
				<li>How to use MongoDB Atlas to host the database as an external resource</li>
				<li>How to use DigitalOcean Droplet to host the application</li>
				<li>How to use PM2 to keep the application running</li>
			</ul>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor418"/>Technical requirements</h1>
			<p>You will need to create accounts with the following providers in order to follow the examples in this chapter:</p>
			<ul>
				<li>DigitalOcean: <a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a></li>
				<li>MongoDB Atlas: <a href="https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/">https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/</a><a href="https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/&#13;"/></li>
				<li>GitHub: <a href="https://github.com/signup">https://github.com/signup</a></li>
			</ul>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/cWkqR2xJJ0k">https://youtu.be/cWkqR2xJJ0k</a></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will use DigitalOcean to host the application, but you can use any other provider or even your own laptop (as an alternative). If you don’t have a DigitalOcean account, you can create one here: <a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a>.</p>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor419"/>Defining the requirements</h1>
			<p>We have the application working<a id="_idIndexMarker962"/> on our computer, but we need to deploy it to the public internet. So, we need to define the requirements in order to choose the best solution for our needs.</p>
			<p>First of all, we need to consider<a id="_idIndexMarker963"/> the following technical questions:</p>
			<ul>
				<li><em class="italic">What is the target environment </em>(<em class="italic">bare metal, VMs, containers, cloud solutions...</em>)<em class="italic">? </em>As our application uses Node.js and standard NPM libraries, we can deploy it easily directly in bare metal machines or VMs. Other solutions are also possible but require some work to be done in terms of configuration.</li>
				<li><em class="italic">What is the target platform</em> (<em class="italic">AWS, Azure, GCP, DigitalOcean, Heroku...</em>)<em class="italic">?</em> In our case, we don’t expect much traffic or many users at all. Also, we are not working in a team and don’t have any specific requirements, such as a Service-Level Agreement (SLA). We can safely choose to use the most simple provider in terms of the onboarding process that also has competitive pricing. In our case, we will use DigitalOcean.</li>
				<li><em class="italic">What is the target operating system</em> (<em class="italic">Linux, Windows, macOS...</em>)<em class="italic">?</em> Node.js is capable of running on common and exotic operating systems. Our application does not have any special dependencies on an operating system so we can easily choose Linux as it is the most popular OS for servers and also has the most extensive offering of the providers.</li>
				<li><em class="italic">What is the target architecture</em> (<em class="italic">x86, ARM...</em>)<em class="italic">?</em> In this case, our application is pure JavaScript. Node.js supports both architectures (x86 and ARM), so we can easily choose x86 because it is a more common architecture for servers, often with lower prices.</li>
				<li><em class="italic">What is the target Node.js version</em> (<em class="italic">18, 20, 21...</em>)<em class="italic">?</em> We have a clear dependency on Node.js 20.11.0, as we used this version while developing the application, but we can be sure that the application should work on any Node.js 20 LTS version.</li>
				<li><em class="italic">What is the target database</em> (<em class="italic">MongoDB, MySQL, PostgreSQL, Redis...</em>)<em class="italic">?</em> We depend on MongoDB, so we need to consider that as a dependency for our infrastructure decisions. Aside from this, there are no more external dependencies or services that we depend on. Managing a database is not simple, so in this case, we can safely choose any managed service. MongoDB provides<a id="_idIndexMarker964"/> MongoDB Atlas (<a href="https://www.mongodb.com/atlas/database">https://www.mongodb.com/atlas/database</a>) as their cloud solution for MongoDB<a id="_idIndexMarker965"/> in the cloud. Also, the free tier should cover our needs.</li>
			</ul>
			<p>So, as a summary, we will deploy the application<a id="_idIndexMarker966"/> that we have been building in the previous chapters. We will deploy a Node.js application with Express. The only external dependency is MongoDB. We will use a Linux machine with x86 architecture and the Node.js 20.x version. Also, we will use MongoDB Atlas to host the database so we don’t need to worry a lot about the operational aspects of the database.</p>
			<p>Also, we need to consider the following things that are relevant to the team and the project, especially if we are working in a professional environment, if we plan to deploy an application for a long time, or expect to scale soon:</p>
			<ul>
				<li>What is the budget?</li>
				<li>How many deployments are we expecting?</li>
				<li>What is the team size?</li>
				<li>What is the team’s experience and knowledge?</li>
			</ul>
			<p>It is not the same to deploy a Node.js application for a pet project<a id="_idIndexMarker967"/> as for a big company with aggressive <strong class="bold">Service-Level Agreements</strong> (<strong class="bold">SLAs</strong>) and an infrastructure team with a lot of experience.</p>
			<p>In our case, I will assume that this is the first time that you are deploying a Node.js application. Also, I will assume a limited budget, experience, and time to invest in maintaining the infrastructure, so we will try the cheapest option possible. Certainly, we won’t have a lot of deployments and we won’t have a lot of traffic. So, we don’t need to worry about scalability, performance, or high availability.</p>
			<p>Overall, we have two main options that we will explore in this chapter and the next one:</p>
			<ul>
				<li>Deploying the application on a bare metal machine or VM</li>
				<li>Deploying the application in a cloud solution</li>
			</ul>
			<p>You can deploy the application on a bare-metal machine, which<a id="_idIndexMarker968"/> can be an old laptop, a <strong class="bold">single-board computer</strong> (<strong class="bold">SBC</strong>) such as a Raspberry Pi, or a virtual machine on your own computer. In this scenario, you can choose to enable remote access to the machine or not. But in any case, this is a good option to learn and test the application.</p>
			<p>Another option is to face the public internet<a id="_idIndexMarker969"/> and deploy the application in a cloud solution. There are many providers with a big product offering out there. So, in order to keep this simple, I will focus on a single provider for the compute resources (DigitalOcean) and a single provider for the database (MongoDB Atlas).</p>
			<p>In the next section, we will create the GitHub repository, and we will push the code to the repository.</p>
			<h1 id="_idParaDest-412"><a id="_idTextAnchor420"/>Using a GitHub repository</h1>
			<p>We will use GitHub<a id="_idIndexMarker970"/> to host the code and deploy the application. We will use GitHub Actions to run the tests and to check the code quality. We will then use GitHub to pull the code from the repository and deploy the application.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor421"/>Creating a GitHub repository</h2>
			<p>You can create<a id="_idIndexMarker971"/> a new repository using this guide: <a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories">https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories</a><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories&#13;"/></p>
			<p>In my case, I created a repository called <code>nodejs-for-beginners</code>, as you can see in the screenshot:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_1.jpg" alt="Figure 16.1–  Web Browser Screenshot of the repository created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1–  Web Browser Screenshot of the repository created</p>
			<p>Now that we have a repository<a id="_idIndexMarker972"/> ready, it is time to start using it by adding our code to it.</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor422"/>Pushing the code to the repository</h2>
			<p>You will need<a id="_idIndexMarker973"/> to download<a id="_idIndexMarker974"/> the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <code>step4</code> folder, and then you will need to push the code to the repository. You need to be sure that the <code>package.json</code> file is present in the root folder of the repository.</p>
			<p>Here are two guides that can help you to push the code to the repository:</p>
			<ul>
				<li>How to clone a repository: <a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository">https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository</a><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository&#13;"/></li>
				<li>How to push code: <a href="https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository">https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository</a><a href="https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository&#13;"/></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">In order to simplify the process, we are going to use only the <code>main</code> branch. But in the real world, most teams use multiple branches to manage their code so they can use great features such as pull requests, code reviews, and so on. That is out of the scope of this book.</p>
			<p>Once this is<a id="_idIndexMarker975"/> done, the repository<a id="_idIndexMarker976"/> should look like this:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_2.jpg" alt="Figure 16.2 – Web browser screenshot of the repository with the files and folders added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Web browser screenshot of the repository with the files and folders added</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <code>step5</code> folder from the source code that you downloaded at the beginning<a id="_idIndexMarker977"/> of the chapter to compare and fix possible<a id="_idIndexMarker978"/> bugs more easily.</p>
			<p>In the next section, we will implement continuous integration with GitHub Actions. This is a great way to ensure that the application is working as expected.</p>
			<h1 id="_idParaDest-415"><a id="_idTextAnchor423"/>Continuous integration with GitHub Actions</h1>
			<p>We can understand continuous integration<a id="_idIndexMarker979"/> as a way to do<a id="_idIndexMarker980"/> automatic checks on the code. This will help us to reduce human errors and will help us to mechanize the process of checking the project’s quality.</p>
			<p>This is an optional step that is not required in order to deploy the application, but if you want to get a better understanding of professional development environments, you can follow along.</p>
			<p>So, the first step is to define what we expect from the automation and then we can implement it. In our case, we want to install the dependencies, run the linter, and run the tests. And we want to do this every time that we push code to the repository.</p>
			<p>In order to implement this, we will create the <code>.github/workflows/ci.yml</code> file with the following content:</p>
			<pre class="source-code">
name: Continous Integration
on: [push]
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm install
      - name: Check code style
        run: npm run lint
      - name: Generate a random JWT secret
        id: generate-secret
        run: echo "::set-output name=JWT_SECRET::$(openssl rand -base64 30)"
        shell: bash
      - name: Prepare environment
        run: npm run infra:start
      - name: Run tests
        run: npm test
        env:
          MONGODB_URI: mongodb://localhost:27017/whispering-database
          PORT: 3000
          SALT_ROUNDS: 10
          JWT_SECRET: ${{ steps.generate-secret.outputs.JWT_SECRET }}</pre>			<p>This YAML file defines<a id="_idIndexMarker981"/> a workflow called <strong class="bold">Continous Integration</strong> that will be triggered every time we push<a id="_idIndexMarker982"/> code to the repository. This workflow will run in a virtual machine with Ubuntu and it will run the following steps:</p>
			<ol>
				<li>Check the code from the repository.</li>
				<li>Install the dependencies by running the <code>npm </code><code>install</code> command.</li>
				<li>Run the linter by running the <code>npm run </code><code>lint</code> command.</li>
				<li>Generate a random JWT secret. We generate a random string with 30 characters that will be used as a JWT secret later on.</li>
				<li>Prepare the environment by running the <code>npm run </code><code>infra:start</code> command.</li>
				<li>Run the tests with the <code>MONGODB_URI</code>, <code>PORT</code>, <code>SALT_ROUNDS</code>, and <code>JWT_SECRET</code> environment variables, and we will use the JWT secret generated in the previous step.</li>
			</ol>
			<p>Once we push the code<a id="_idIndexMarker983"/> to the repository, we can check<a id="_idIndexMarker984"/> the status of the workflow in the <strong class="bold">Actions</strong> tab:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_3.jpg" alt="Figure 16.3 – Web browser screenshot showing the GitHub actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Web browser screenshot showing the GitHub actions</p>
			<p>If we click on the workflow, we can see the details of it:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_4.jpg" alt="Figure 16.4 – Web browser screenshot showing the GitHub Action execution details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Web browser screenshot showing the GitHub Action execution details</p>
			<p>As we can see, all the checks<a id="_idIndexMarker985"/> are passing, so we can be confident<a id="_idIndexMarker986"/> that the application is working as expected.</p>
			<p>We can click on the <strong class="bold">Run tests</strong> step to see the details of the tests:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_5.jpg" alt="Figure 16.5 – Web browser screenshot showing the tests execution step in detail"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Web browser screenshot showing the tests execution step in detail</p>
			<p>As you can see, the tests are passing, the same way as on our local machine. Ultimately, the continuous integration machine is just a remote machine that will follow the steps that we define, and it is not very different<a id="_idIndexMarker987"/> from our own environment<a id="_idIndexMarker988"/> in that respect.</p>
			<p>Now, that we have the continuous integration in place, we can start thinking about preparing the MongoDB instance using Atlas in the next section.</p>
			<h1 id="_idParaDest-416"><a id="_idTextAnchor424"/>Using MongoDB Atlas</h1>
			<p>We will use MongoDB Atlas <a id="_idIndexMarker989"/>to host the database. We will create a free tier cluster and we will use the connection string to connect to the database.</p>
			<p>Here are some guides that will help you:</p>
			<ul>
				<li>How to create a free tier cluster: <a href="https://docs.atlas.mongodb.com/tutorial/create-new-cluster/">https://docs.atlas.mongodb.com/tutorial/create-new-cluster/</a></li>
				<li>How to connect<a id="_idIndexMarker990"/> to the database: <a href="https://www.mongodb.com/docs/atlas/driver-connection/">https://www.mongodb.com/docs/atlas/driver-connection/</a><a href="https://www.mongodb.com/docs/atlas/driver-connection/&#13;"/></li>
			</ul>
			<p>In my case, I created a free tier cluster called <code>nodejs-for-beginners</code>, as you can see in the following screenshot:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_6.jpg" alt="Figure 16.6 – Web browser screenshot showing the cluster creation details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 – Web browser screenshot showing the cluster creation details</p>
			<p>At the end of the process, you will have a connection string like this (but with your own credentials):</p>
			<pre class="console">
mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</pre>			<p>You can use that connection string to connect to the database from the application. You only need to replace the value of the <code>MONGODB_URI</code> environment variable with the new connection string in the <code>.</code><code>env</code> file.</p>
			<p>It is important to notice that the username and password need to be URI encoded, so the special characters are converted. This<a id="_idIndexMarker991"/> can easily be done with the <code>encodeURIComponent</code> function (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent</a>). Here is a conversion example:</p>
			<pre class="source-code">
encodeURIComponent('P@ssword') // P%40ssword</pre>			<p>If you run the test or run<a id="_idIndexMarker992"/> the application locally, you will see that the application is using the new database and the data is persisted in the cloud, as expected.</p>
			<p>In the following screenshot, you can see the data in the database:</p>
			<div><div><img src="img/Image96437.jpg" alt="Figure 16.7 – Web browser screenshot showing the project details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7 – Web browser screenshot showing the project details</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Once you are ready with the database, you can restore the <code>.env</code> file to the original state to avoid polluting the database<a id="_idIndexMarker993"/> with test data in future executions.</p>
			<p>Now, that we have the external database ready, we can start thinking about deploying the application. In the next section, we will prepare the application using PM2.</p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor425"/>Deploying Node.js applications with PM2</h1>
			<p>This is a very <em class="italic">exciting</em> moment! We are about<a id="_idIndexMarker994"/> to make our application available on the public internet. In this case, we will use a DigitalOcean Droplet to host the application. A Droplet is a virtual machine with Ubuntu 23.10 and 0.5 GB of RAM that will host the application. We will use PM2 to keep the application running and to restart it if it crashes.</p>
			<p>If you don’t want to use DigitalOcean, as an alternative, you can use an old computer that has at least 4 GB RAM, Ubuntu (or another Linux distro), and have SSH communication enabled (no need to install Node.js or deploy a website at this point). An old laptop is a great<a id="_idIndexMarker995"/> option or even a Raspberry PI (3, 4, or 5) (<a href="https://www.raspberrypi.com/">https://www.raspberrypi.com/</a>) with Raspbian (<a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a>) will do the job. Here, you can<a id="_idIndexMarker996"/> find two tutorials that will help you with the setup:</p>
			<ul>
				<li><a href="https://www.xda-developers.com/turn-old-laptop-into-home-server">https://www.xda-developers.com/turn-old-laptop-into-home-server</a>/</li>
				<li><a href="https://www.youtube.com/watch?v=iSAF8D8rp0o">https://www.youtube.com/watch?v=iSAF8D8rp0o</a></li>
			</ul>
			<p>If the setup was done properly, you can skip the next section and jump directly to the <em class="italic">Preparing the </em><em class="italic">machine</em> section.</p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor426"/>Creating a DigitalOcean Droplet</h2>
			<p>We will use <a id="_idIndexMarker997"/>DigitalOcean to host<a id="_idIndexMarker998"/> the application. We will use the most basic, cheap Droplet possible, currently with 512 MB RAM and 1 virtual CPU.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will use the SSH key to access the machine, so please<a id="_idIndexMarker999"/> follow this guide if you don’t know how to do it:</p>
			<p class="callout"><a href="https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/">https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/</a><a href="https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/&#13;"/></p>
			<p>In my case, I created a Droplet called <code>nodejs-for-beginners</code>, as you can see in the following screenshot:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_8.jpg" alt="Figure 16.8 – Web browser screenshot showing the droplet details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8 – Web browser screenshot showing the droplet details</p>
			<p>As you can see, the droplet<a id="_idIndexMarker1000"/> is available at the IP<a id="_idIndexMarker1001"/> address <code>144.126.217.34</code> and we will use that IP address to access the machine using SSH or HTTP when the application is running.</p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor427"/>Connecting to the machine</h2>
			<p>There are many ways to access<a id="_idIndexMarker1002"/> the machine with SSH. The most common is to use the terminal directly. But in this case, we will use VSCode to connect<a id="_idIndexMarker1003"/> to the machine. You can follow the guide at <a href="https://code.visualstudio.com/docs/remote/ssh">https://code.visualstudio.com/docs/remote/ssh</a> to learn how to do it as it is more convenient than directly connect from your terminal to the machine.</p>
			<p>In both cases, we need to use the same credentials. The username is <code>root</code> and the password is replaced by your SSH key that was added to your Droplet.</p>
			<p>Now that we are able to connect to the machine, it is time to start setting up the environment.</p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor428"/>Preparing the machine</h2>
			<p>Once you are connected<a id="_idIndexMarker1004"/> to the machine, you can run the following commands in the terminal in order to create the working directory and access the new directory created:</p>
			<pre class="console">
mkdir nodejs-for-beginners
cd nodejs-for-beginners</pre>			<p>Then we will install Node.js 20.11.0 using <code>nvm</code>:</p>
			<pre class="console">
apt update
wget -qO- https: //raw.githubusercontent. com/creationix/nvm/ v0.39.3/install. sh | bash
source ~/.profile
nvm --version
nvm install 20.11.0</pre>			<p>The output should be something like this:</p>
			<pre class="console">
Downloading and installing node v20.11.0...
Downloading https: //nodejs. org/dist/ v20.11.0/n ode-v20.11.0-linux- x64.tar. xz...
################################################################################################## 100.0%
Computing checksum with sha256sum
Checksums matched!
Now using node v20.11.0 (npm v10.2.4)
Creating default alias: default -&gt; 20.11.0 (-&gt; v20.11.0)</pre>			<p>The next step is to install PM2 globally on the machine:</p>
			<pre class="console">
npm install pm2 -g</pre>			<p>You can check the version of PM2 with the following:</p>
			<pre class="console">
pm2 --version</pre>			<p>The output should be something like this:</p>
			<pre class="console">
[PM2] PM2 Successfully daemonized
5.2.2</pre>			<p>Now, we have the machine<a id="_idIndexMarker1005"/> ready to work with our code. Our next step will be to bring the application code to our machine.</p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor429"/>Cloning the repository</h2>
			<p>If you are using a private<a id="_idIndexMarker1006"/> repository, you will need to add the SSH key to the machine. You can follow the guide at <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh</a>, but you can prevent this step if you make the repository public.</p>
			<p>Then we will clone the repository:</p>
			<pre class="console">
git clone https: //github. com/YOUR- USER/ YOUR-REPO .git</pre>			<p>We can check that the code is present in the folder by checking the directory in VSCode or by running the following command:</p>
			<pre class="console">
ls -la</pre>			<p>This command will list all files, including hidden ones, in the current directory, and show detailed information about these files. The output should be something like this:</p>
			<pre class="console">
README.md     docker-compose.yml   node_modules        public      tests
coverage      index.js             package-lock.json   server.js   utils.js
database.js   jest.config.js       package.json        stores      views</pre>			<p>We can confirm that the code<a id="_idIndexMarker1007"/> has been downloaded, so our next step will be to install the dependencies.</p>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor430"/>Installing the dependencies</h2>
			<p>After cloning the<a id="_idIndexMarker1008"/> repository, we will install the dependencies:</p>
			<pre class="console">
npm install</pre>			<p>This might take a while as the machine is not very powerful, but it should finish without errors. If you have errors or the process is much longer than expected, you can try to increase the size of the Droplet, but this will increase the price per hour.</p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor431"/>Preparing the environment</h2>
			<p>We will create a <code>.env</code> file as we<a id="_idIndexMarker1009"/> did in the previous chapters, but we will use the connection string of the MongoDB Atlas cluster that we created in the previous section.</p>
			<p>Once this is ready, the application is ready to run, but we will use PM2 to keep the application running and restart it if it crashes.</p>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor432"/>Managing the application with PM2</h2>
			<p>We decided to use PM2 as the process <a id="_idIndexMarker1010"/>manager for our<a id="_idIndexMarker1011"/> application, so you won’t start the application directly using <code>node</code> command like <code>node index.js</code>. We will let PM2 handle the application lifecycle.</p>
			<p>We will start the application with PM2:</p>
			<pre class="console">
pm2 start index.js</pre>			<p>We can check the status of the application with the following:</p>
			<pre class="console">
pm2 status</pre>			<p>We can check the logs of the application with this:</p>
			<pre class="console">
pm2 logs</pre>			<p>We can stop the<a id="_idIndexMarker1012"/> application<a id="_idIndexMarker1013"/> with this:</p>
			<pre class="console">
pm2 stop index.js</pre>			<p>Now, we can start the application again with PM2 and check whether the application is available through the internet.</p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor433"/>Accessing the application</h2>
			<p>Now, we can access the application<a id="_idIndexMarker1014"/> using the IP address of the Droplet. In my case, the IP address is <code>144.126.217.34</code> and the application is running in port <code>3000</code>, so I can access the application using the following URL: <code>http://144.126.217.34:3000</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using a different host, such as a machine in your local network, this might be different, as it will depend on your local network configuration and/or firewalls. But if your network is correctly set up, then you should be able to access the website by using the IP address of the machine in your local network, for example, <code>192.168.1.44</code>.</p>
			<p>We can see the application running as expected:</p>
			<div><div><img src="img/B21678_16_ForCEing_FS_9.jpg" alt="Figure 16.9 – Web browser screenshot showing the project running using the droplet IP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9 – Web browser screenshot showing the project running using the droplet IP</p>
			<p>Yes! The application is running<a id="_idIndexMarker1015"/> as expected. We’ll explore another way to run our application in the next chapter, but this time we will use Docker.</p>
			<h1 id="_idParaDest-426"><a id="_idTextAnchor434"/>Summary</h1>
			<p>In this chapter, we learned how to deploy our application to the public internet. We learned how important it is to have a clear definition of the requirements and how to choose the best solution for our needs. We created accounts with the providers that we used in this chapter and we pushed the application code to the GitHub repository to have proper source control in place.</p>
			<p>Finally, we used MongoDB Atlas to host the database as an external resource and we used a DigitalOcean Droplet to host the application. We learned how to use PM2 to keep the application running.</p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor435"/>Further reading</h1>
			<ul>
				<li>How To Set Up a Node.js Application for Production on Ubuntu 22.04: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04">https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04</a><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04&#13;"/></li>
				<li>Express Production best practices: <a href="https://expressjs.com/en/advanced/best-practice-performance.html">https://expressjs.com/en/advanced/best-practice-performance.html</a><a href="https://expressjs.com/en/advanced/best-practice-performance.html&#13;"/></li>
			</ul>
		</div>
	</body></html>