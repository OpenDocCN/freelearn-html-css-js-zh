<html><head></head><body>
		<div id="_idContainer112">
			<h1 id="_idParaDest-408" class="chapter-number"><a id="_idTextAnchor416"/>16</h1>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor417"/>Deploying Node.js Applications</h1>
			<p>In this chapter, we will learn how to deploy our application to the public internet. We will learn how important it is to have a clear definition of the requirements and how to choose the best solution for our needs. We will push the application code to the GitHub repository in order to use GitHub Actions for <span class="No-Break">continuous integration.</span></p>
			<p>Finally, We will deploy the application in DigitalOcean and we will use PM2 to keep the application running. We will configure and use MongoDB Atlas to host the database in <span class="No-Break">the cloud.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to define the requirements and how to choose the best solution for <span class="No-Break">our needs</span></li>
				<li>How to push the application code to the <span class="No-Break">GitHub repository</span></li>
				<li>How to use MongoDB Atlas to host the database as an <span class="No-Break">external resource</span></li>
				<li>How to use DigitalOcean Droplet to host <span class="No-Break">the application</span></li>
				<li>How to use PM2 to keep the <span class="No-Break">application running</span></li>
			</ul>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor418"/>Technical requirements</h1>
			<p>You will need to create accounts with the following providers in order to follow the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">DigitalOcean: </span><a href="https://www.digitalocean.com/"><span class="No-Break">https://www.digitalocean.com/</span></a></li>
				<li>MongoDB <span class="No-Break">Atlas: </span><a href="https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/"><span class="No-Break">https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/</span></a><a href="https://www.mongodb.com/docs/atlas/tutorial/create-atlas-account/&#13;"/></li>
				<li><span class="No-Break">GitHub: </span><a href="https://github.com/signup"><span class="No-Break">https://github.com/signup</span></a></li>
			</ul>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/cWkqR2xJJ0k"><span class="No-Break">https://youtu.be/cWkqR2xJJ0k</span></a></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will use DigitalOcean to host the application, but you can use any other provider or even your own laptop (as an alternative). If you don’t have a DigitalOcean account, you can create one <span class="No-Break">here: </span><a href="https://www.digitalocean.com/"><span class="No-Break">https://www.digitalocean.com/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor419"/>Defining the requirements</h1>
			<p>We have the application working<a id="_idIndexMarker962"/> on our computer, but we need to deploy it to the public internet. So, we need to define the requirements in order to choose the best solution for <span class="No-Break">our needs.</span></p>
			<p>First of all, we need to consider<a id="_idIndexMarker963"/> the following <span class="No-Break">technical questions:</span></p>
			<ul>
				<li><em class="italic">What is the target environment </em>(<em class="italic">bare metal, VMs, containers, cloud solutions...</em>)<em class="italic">? </em>As our application uses Node.js and standard NPM libraries, we can deploy it easily directly in bare metal machines or VMs. Other solutions are also possible but require some work to be done in terms <span class="No-Break">of configuration.</span></li>
				<li><em class="italic">What is the target platform</em> (<em class="italic">AWS, Azure, GCP, DigitalOcean, Heroku...</em>)<em class="italic">?</em> In our case, we don’t expect much traffic or many users at all. Also, we are not working in a team and don’t have any specific requirements, such as a Service-Level Agreement (SLA). We can safely choose to use the most simple provider in terms of the onboarding process that also has competitive pricing. In our case, we will <span class="No-Break">use DigitalOcean.</span></li>
				<li><em class="italic">What is the target operating system</em> (<em class="italic">Linux, Windows, macOS...</em>)<em class="italic">?</em> Node.js is capable of running on common and exotic operating systems. Our application does not have any special dependencies on an operating system so we can easily choose Linux as it is the most popular OS for servers and also has the most extensive offering of <span class="No-Break">the providers.</span></li>
				<li><em class="italic">What is the target architecture</em> (<em class="italic">x86, ARM...</em>)<em class="italic">?</em> In this case, our application is pure JavaScript. Node.js supports both architectures (x86 and ARM), so we can easily choose x86 because it is a more common architecture for servers, often with <span class="No-Break">lower prices.</span></li>
				<li><em class="italic">What is the target Node.js version</em> (<em class="italic">18, 20, 21...</em>)<em class="italic">?</em> We have a clear dependency on Node.js 20.11.0, as we used this version while developing the application, but we can be sure that the application should work on any Node.js 20 <span class="No-Break">LTS version.</span></li>
				<li><em class="italic">What is the target database</em> (<em class="italic">MongoDB, MySQL, PostgreSQL, Redis...</em>)<em class="italic">?</em> We depend on MongoDB, so we need to consider that as a dependency for our infrastructure decisions. Aside from this, there are no more external dependencies or services that we depend on. Managing a database is not simple, so in this case, we can safely choose any managed service. MongoDB provides<a id="_idIndexMarker964"/> MongoDB Atlas (<a href="https://www.mongodb.com/atlas/database">https://www.mongodb.com/atlas/database</a>) as their cloud solution for MongoDB<a id="_idIndexMarker965"/> in the cloud. Also, the free tier should cover <span class="No-Break">our needs.</span></li>
			</ul>
			<p>So, as a summary, we will deploy the application<a id="_idIndexMarker966"/> that we have been building in the previous chapters. We will deploy a Node.js application with Express. The only external dependency is MongoDB. We will use a Linux machine with x86 architecture and the Node.js 20.x version. Also, we will use MongoDB Atlas to host the database so we don’t need to worry a lot about the operational aspects of <span class="No-Break">the database.</span></p>
			<p>Also, we need to consider the following things that are relevant to the team and the project, especially if we are working in a professional environment, if we plan to deploy an application for a long time, or expect to <span class="No-Break">scale soon:</span></p>
			<ul>
				<li>What is <span class="No-Break">the budget?</span></li>
				<li>How many deployments are <span class="No-Break">we expecting?</span></li>
				<li>What is the <span class="No-Break">team size?</span></li>
				<li>What is the team’s experience <span class="No-Break">and knowledge?</span></li>
			</ul>
			<p>It is not the same to deploy a Node.js application for a pet project<a id="_idIndexMarker967"/> as for a big company with aggressive <strong class="bold">Service-Level Agreements</strong> (<strong class="bold">SLAs</strong>) and an infrastructure team with a lot <span class="No-Break">of experience.</span></p>
			<p>In our case, I will assume that this is the first time that you are deploying a Node.js application. Also, I will assume a limited budget, experience, and time to invest in maintaining the infrastructure, so we will try the cheapest option possible. Certainly, we won’t have a lot of deployments and we won’t have a lot of traffic. So, we don’t need to worry about scalability, performance, or <span class="No-Break">high availability.</span></p>
			<p>Overall, we have two main options that we will explore in this chapter and the <span class="No-Break">next one:</span></p>
			<ul>
				<li>Deploying the application on a bare metal machine <span class="No-Break">or VM</span></li>
				<li>Deploying the application in a <span class="No-Break">cloud solution</span></li>
			</ul>
			<p>You can deploy the application on a bare-metal machine, which<a id="_idIndexMarker968"/> can be an old laptop, a <strong class="bold">single-board computer</strong> (<strong class="bold">SBC</strong>) such as a Raspberry Pi, or a virtual machine on your own computer. In this scenario, you can choose to enable remote access to the machine or not. But in any case, this is a good option to learn and test <span class="No-Break">the application.</span></p>
			<p>Another option is to face the public internet<a id="_idIndexMarker969"/> and deploy the application in a cloud solution. There are many providers with a big product offering out there. So, in order to keep this simple, I will focus on a single provider for the compute resources (DigitalOcean) and a single provider for the database (<span class="No-Break">MongoDB Atlas).</span></p>
			<p>In the next section, we will create the GitHub repository, and we will push the code to <span class="No-Break">the repository.</span></p>
			<h1 id="_idParaDest-412"><a id="_idTextAnchor420"/>Using a GitHub repository</h1>
			<p>We will use GitHub<a id="_idIndexMarker970"/> to host the code and deploy the application. We will use GitHub Actions to run the tests and to check the code quality. We will then use GitHub to pull the code from the repository and deploy <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor421"/>Creating a GitHub repository</h2>
			<p>You can create<a id="_idIndexMarker971"/> a new repository using this <span class="No-Break">guide: </span><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories"><span class="No-Break">https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories</span></a><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories&#13;"/></p>
			<p>In my case, I created a repository called <strong class="source-inline">nodejs-for-beginners</strong>, as you can see in <span class="No-Break">the screenshot:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_1.jpg" alt="Figure 16.1–  Web Browser Screenshot of the repository created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1–  Web Browser Screenshot of the repository created</p>
			<p>Now that we have a repository<a id="_idIndexMarker972"/> ready, it is time to start using it by adding our code <span class="No-Break">to it.</span></p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor422"/>Pushing the code to the repository</h2>
			<p>You will need<a id="_idIndexMarker973"/> to download<a id="_idIndexMarker974"/> the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <strong class="source-inline">step4</strong> folder, and then you will need to push the code to the repository. You need to be sure that the <strong class="source-inline">package.json</strong> file is present in the root folder of <span class="No-Break">the repository.</span></p>
			<p>Here are two guides that can help you to push the code to <span class="No-Break">the repository:</span></p>
			<ul>
				<li>How to clone a <span class="No-Break">repository: </span><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository"><span class="No-Break">https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository</span></a><a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository&#13;"/></li>
				<li>How to push <span class="No-Break">code: </span><a href="https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository"><span class="No-Break">https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository</span></a><a href="https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository&#13;"/></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">In order to simplify the process, we are going to use only the <strong class="source-inline">main</strong> branch. But in the real world, most teams use multiple branches to manage their code so they can use great features such as pull requests, code reviews, and so on. That is out of the scope of <span class="No-Break">this book.</span></p>
			<p>Once this is<a id="_idIndexMarker975"/> done, the repository<a id="_idIndexMarker976"/> should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_2.jpg" alt="Figure 16.2 – Web browser screenshot of the repository with the files and folders added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Web browser screenshot of the repository with the files and folders added</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <strong class="source-inline">step5</strong> folder from the source code that you downloaded at the beginning<a id="_idIndexMarker977"/> of the chapter to compare and fix possible<a id="_idIndexMarker978"/> bugs <span class="No-Break">more easily.</span></p>
			<p>In the next section, we will implement continuous integration with GitHub Actions. This is a great way to ensure that the application is working <span class="No-Break">as expected.</span></p>
			<h1 id="_idParaDest-415"><a id="_idTextAnchor423"/>Continuous integration with GitHub Actions</h1>
			<p>We can understand continuous integration<a id="_idIndexMarker979"/> as a way to do<a id="_idIndexMarker980"/> automatic checks on the code. This will help us to reduce human errors and will help us to mechanize the process of checking the <span class="No-Break">project’s quality.</span></p>
			<p>This is an optional step that is not required in order to deploy the application, but if you want to get a better understanding of professional development environments, you can <span class="No-Break">follow along.</span></p>
			<p>So, the first step is to define what we expect from the automation and then we can implement it. In our case, we want to install the dependencies, run the linter, and run the tests. And we want to do this every time that we push code to <span class="No-Break">the repository.</span></p>
			<p>In order to implement this, we will create the <strong class="source-inline">.github/workflows/ci.yml</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
name: Continous Integration
on: [push]
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm install
      - name: Check code style
        run: npm run lint
      - name: Generate a random JWT secret
        id: generate-secret
        run: echo "::set-output name=JWT_SECRET::$(openssl rand -base64 30)"
        shell: bash
      - name: Prepare environment
        run: npm run infra:start
      - name: Run tests
        run: npm test
        env:
          MONGODB_URI: mongodb://localhost:27017/whispering-database
          PORT: 3000
          SALT_ROUNDS: 10
          JWT_SECRET: ${{ steps.generate-secret.outputs.JWT_SECRET }}</pre>			<p>This YAML file defines<a id="_idIndexMarker981"/> a workflow called <strong class="bold">Continous Integration</strong> that will be triggered every time we push<a id="_idIndexMarker982"/> code to the repository. This workflow will run in a virtual machine with Ubuntu and it will run the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Check the code from <span class="No-Break">the repository.</span></li>
				<li>Install the dependencies by running the <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install</strong></span><span class="No-Break"> command.</span></li>
				<li>Run the linter by running the <strong class="source-inline">npm run </strong><span class="No-Break"><strong class="source-inline">lint</strong></span><span class="No-Break"> command.</span></li>
				<li>Generate a random JWT secret. We generate a random string with 30 characters that will be used as a JWT secret <span class="No-Break">later on.</span></li>
				<li>Prepare the environment by running the <strong class="source-inline">npm run </strong><span class="No-Break"><strong class="source-inline">infra:start</strong></span><span class="No-Break"> command.</span></li>
				<li>Run the tests with the <strong class="source-inline">MONGODB_URI</strong>, <strong class="source-inline">PORT</strong>, <strong class="source-inline">SALT_ROUNDS</strong>, and <strong class="source-inline">JWT_SECRET</strong> environment variables, and we will use the JWT secret generated in the <span class="No-Break">previous step.</span></li>
			</ol>
			<p>Once we push the code<a id="_idIndexMarker983"/> to the repository, we can check<a id="_idIndexMarker984"/> the status of the workflow in the <span class="No-Break"><strong class="bold">Actions</strong></span><span class="No-Break"> tab:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_3.jpg" alt="Figure 16.3 – Web browser screenshot showing the GitHub actions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Web browser screenshot showing the GitHub actions</p>
			<p>If we click on the workflow, we can see the details <span class="No-Break">of it:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_4.jpg" alt="Figure 16.4 – Web browser screenshot showing the GitHub Action execution details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Web browser screenshot showing the GitHub Action execution details</p>
			<p>As we can see, all the checks<a id="_idIndexMarker985"/> are passing, so we can be confident<a id="_idIndexMarker986"/> that the application is working <span class="No-Break">as expected.</span></p>
			<p>We can click on the <strong class="bold">Run tests</strong> step to see the details of <span class="No-Break">the tests:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_5.jpg" alt="Figure 16.5 – Web browser screenshot showing the tests execution step in detail"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – Web browser screenshot showing the tests execution step in detail</p>
			<p>As you can see, the tests are passing, the same way as on our local machine. Ultimately, the continuous integration machine is just a remote machine that will follow the steps that we define, and it is not very different<a id="_idIndexMarker987"/> from our own environment<a id="_idIndexMarker988"/> in <span class="No-Break">that respect.</span></p>
			<p>Now, that we have the continuous integration in place, we can start thinking about preparing the MongoDB instance using Atlas in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-416"><a id="_idTextAnchor424"/>Using MongoDB Atlas</h1>
			<p>We will use MongoDB Atlas <a id="_idIndexMarker989"/>to host the database. We will create a free tier cluster and we will use the connection string to connect to <span class="No-Break">the database.</span></p>
			<p>Here are some guides that will <span class="No-Break">help you:</span></p>
			<ul>
				<li>How to create a free tier <span class="No-Break">cluster: </span><a href="https://docs.atlas.mongodb.com/tutorial/create-new-cluster/"><span class="No-Break">https://docs.atlas.mongodb.com/tutorial/create-new-cluster/</span></a></li>
				<li>How to connect<a id="_idIndexMarker990"/> to the <span class="No-Break">database: </span><a href="https://www.mongodb.com/docs/atlas/driver-connection/"><span class="No-Break">https://www.mongodb.com/docs/atlas/driver-connection/</span></a><a href="https://www.mongodb.com/docs/atlas/driver-connection/&#13;"/></li>
			</ul>
			<p>In my case, I created a free tier cluster called <strong class="source-inline">nodejs-for-beginners</strong>, as you can see in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_6.jpg" alt="Figure 16.6 – Web browser screenshot showing the cluster creation details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6 – Web browser screenshot showing the cluster creation details</p>
			<p>At the end of the process, you will have a connection string like this (but with your <span class="No-Break">own credentials):</span></p>
			<pre class="console">
mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster-url&gt;/test?retryWrites=true&amp;w=majority</pre>			<p>You can use that connection string to connect to the database from the application. You only need to replace the value of the <strong class="source-inline">MONGODB_URI</strong> environment variable with the new connection string in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">env</strong></span><span class="No-Break"> file.</span></p>
			<p>It is important to notice that the username and password need to be URI encoded, so the special characters are converted. This<a id="_idIndexMarker991"/> can easily be done with the <strong class="source-inline">encodeURIComponent</strong> function (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent</a>). Here is a <span class="No-Break">conversion example:</span></p>
			<pre class="source-code">
encodeURIComponent('P@ssword') // P%40ssword</pre>			<p>If you run the test or run<a id="_idIndexMarker992"/> the application locally, you will see that the application is using the new database and the data is persisted in the cloud, <span class="No-Break">as expected.</span></p>
			<p>In the following screenshot, you can see the data in <span class="No-Break">the database:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Image96437.jpg" alt="Figure 16.7 – Web browser screenshot showing the project details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7 – Web browser screenshot showing the project details</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Once you are ready with the database, you can restore the <strong class="source-inline">.env</strong> file to the original state to avoid polluting the database<a id="_idIndexMarker993"/> with test data in <span class="No-Break">future executions.</span></p>
			<p>Now, that we have the external database ready, we can start thinking about deploying the application. In the next section, we will prepare the application <span class="No-Break">using PM2.</span></p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor425"/>Deploying Node.js applications with PM2</h1>
			<p>This is a very <em class="italic">exciting</em> moment! We are about<a id="_idIndexMarker994"/> to make our application available on the public internet. In this case, we will use a DigitalOcean Droplet to host the application. A Droplet is a virtual machine with Ubuntu 23.10 and 0.5 GB of RAM that will host the application. We will use PM2 to keep the application running and to restart it if <span class="No-Break">it crashes.</span></p>
			<p>If you don’t want to use DigitalOcean, as an alternative, you can use an old computer that has at least 4 GB RAM, Ubuntu (or another Linux distro), and have SSH communication enabled (no need to install Node.js or deploy a website at this point). An old laptop is a great<a id="_idIndexMarker995"/> option or even a Raspberry PI (3, 4, or 5) (<a href="https://www.raspberrypi.com/">https://www.raspberrypi.com/</a>) with Raspbian (<a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a>) will do the job. Here, you can<a id="_idIndexMarker996"/> find two tutorials that will help you with <span class="No-Break">the setup:</span></p>
			<ul>
				<li><a href="https://www.xda-developers.com/turn-old-laptop-into-home-server"><span class="No-Break">https://www.xda-developers.com/turn-old-laptop-into-home-server</span></a><span class="No-Break">/</span></li>
				<li><a href="https://www.youtube.com/watch?v=iSAF8D8rp0o"><span class="No-Break">https://www.youtube.com/watch?v=iSAF8D8rp0o</span></a></li>
			</ul>
			<p>If the setup was done properly, you can skip the next section and jump directly to the <em class="italic">Preparing the </em><span class="No-Break"><em class="italic">machine</em></span><span class="No-Break"> section.</span></p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor426"/>Creating a DigitalOcean Droplet</h2>
			<p>We will use <a id="_idIndexMarker997"/>DigitalOcean to host<a id="_idIndexMarker998"/> the application. We will use the most basic, cheap Droplet possible, currently with 512 MB RAM and 1 <span class="No-Break">virtual CPU.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will use the SSH key to access the machine, so please<a id="_idIndexMarker999"/> follow this guide if you don’t know how to <span class="No-Break">do it:</span></p>
			<p class="callout"><a href="https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/"><span class="No-Break">https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/</span></a><a href="https://docs.digitalocean.com/products/droplets/how-to/add-ssh-keys/&#13;"/></p>
			<p>In my case, I created a Droplet called <strong class="source-inline">nodejs-for-beginners</strong>, as you can see in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_8.jpg" alt="Figure 16.8 – Web browser screenshot showing the droplet details"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8 – Web browser screenshot showing the droplet details</p>
			<p>As you can see, the droplet<a id="_idIndexMarker1000"/> is available at the IP<a id="_idIndexMarker1001"/> address <strong class="source-inline">144.126.217.34</strong> and we will use that IP address to access the machine using SSH or HTTP when the application <span class="No-Break">is running.</span></p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor427"/>Connecting to the machine</h2>
			<p>There are many ways to access<a id="_idIndexMarker1002"/> the machine with SSH. The most common is to use the terminal directly. But in this case, we will use VSCode to connect<a id="_idIndexMarker1003"/> to the machine. You can follow the guide at <a href="https://code.visualstudio.com/docs/remote/ssh">https://code.visualstudio.com/docs/remote/ssh</a> to learn how to do it as it is more convenient than directly connect from your terminal to <span class="No-Break">the machine.</span></p>
			<p>In both cases, we need to use the same credentials. The username is <strong class="source-inline">root</strong> and the password is replaced by your SSH key that was added to <span class="No-Break">your Droplet.</span></p>
			<p>Now that we are able to connect to the machine, it is time to start setting up <span class="No-Break">the environment.</span></p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor428"/>Preparing the machine</h2>
			<p>Once you are connected<a id="_idIndexMarker1004"/> to the machine, you can run the following commands in the terminal in order to create the working directory and access the new <span class="No-Break">directory created:</span></p>
			<pre class="console">
mkdir nodejs-for-beginners
cd nodejs-for-beginners</pre>			<p>Then we will install Node.js 20.11.0 <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">nvm</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
apt update
wget -qO- https: //raw.githubusercontent. com/creationix/nvm/ v0.39.3/install. sh | bash
source ~/.profile
nvm --version
nvm install 20.11.0</pre>			<p>The output should be something <span class="No-Break">like this:</span></p>
			<pre class="console">
Downloading and installing node v20.11.0...
Downloading https: //nodejs. org/dist/ v20.11.0/n ode-v20.11.0-linux- x64.tar. xz...
################################################################################################## 100.0%
Computing checksum with sha256sum
Checksums matched!
Now using node v20.11.0 (npm v10.2.4)
Creating default alias: default -&gt; 20.11.0 (-&gt; v20.11.0)</pre>			<p>The next step is to install PM2 globally on <span class="No-Break">the machine:</span></p>
			<pre class="console">
npm install pm2 -g</pre>			<p>You can check the version of PM2 with <span class="No-Break">the following:</span></p>
			<pre class="console">
pm2 --version</pre>			<p>The output should be something <span class="No-Break">like this:</span></p>
			<pre class="console">
[PM2] PM2 Successfully daemonized
5.2.2</pre>			<p>Now, we have the machine<a id="_idIndexMarker1005"/> ready to work with our code. Our next step will be to bring the application code to <span class="No-Break">our machine.</span></p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor429"/>Cloning the repository</h2>
			<p>If you are using a private<a id="_idIndexMarker1006"/> repository, you will need to add the SSH key to the machine. You can follow the guide at <a href="https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh</a>, but you can prevent this step if you make the <span class="No-Break">repository public.</span></p>
			<p>Then we will clone <span class="No-Break">the repository:</span></p>
			<pre class="console">
git clone https: //github. com/YOUR- USER/ YOUR-REPO .git</pre>			<p>We can check that the code is present in the folder by checking the directory in VSCode or by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
ls -la</pre>			<p>This command will list all files, including hidden ones, in the current directory, and show detailed information about these files. The output should be something <span class="No-Break">like this:</span></p>
			<pre class="console">
README.md     docker-compose.yml   node_modules        public      tests
coverage      index.js             package-lock.json   server.js   utils.js
database.js   jest.config.js       package.json        stores      views</pre>			<p>We can confirm that the code<a id="_idIndexMarker1007"/> has been downloaded, so our next step will be to install <span class="No-Break">the dependencies.</span></p>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor430"/>Installing the dependencies</h2>
			<p>After cloning the<a id="_idIndexMarker1008"/> repository, we will install <span class="No-Break">the dependencies:</span></p>
			<pre class="console">
npm install</pre>			<p>This might take a while as the machine is not very powerful, but it should finish without errors. If you have errors or the process is much longer than expected, you can try to increase the size of the Droplet, but this will increase the price <span class="No-Break">per hour.</span></p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor431"/>Preparing the environment</h2>
			<p>We will create a <strong class="source-inline">.env</strong> file as we<a id="_idIndexMarker1009"/> did in the previous chapters, but we will use the connection string of the MongoDB Atlas cluster that we created in the <span class="No-Break">previous section.</span></p>
			<p>Once this is ready, the application is ready to run, but we will use PM2 to keep the application running and restart it if <span class="No-Break">it crashes.</span></p>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor432"/>Managing the application with PM2</h2>
			<p>We decided to use PM2 as the process <a id="_idIndexMarker1010"/>manager for our<a id="_idIndexMarker1011"/> application, so you won’t start the application directly using <strong class="source-inline">node</strong> command like <strong class="source-inline">node index.js</strong>. We will let PM2 handle the <span class="No-Break">application lifecycle.</span></p>
			<p>We will start the application <span class="No-Break">with PM2:</span></p>
			<pre class="console">
pm2 start index.js</pre>			<p>We can check the status of the application with <span class="No-Break">the following:</span></p>
			<pre class="console">
pm2 status</pre>			<p>We can check the logs of the application <span class="No-Break">with this:</span></p>
			<pre class="console">
pm2 logs</pre>			<p>We can stop the<a id="_idIndexMarker1012"/> application<a id="_idIndexMarker1013"/> <span class="No-Break">with this:</span></p>
			<pre class="console">
pm2 stop index.js</pre>			<p>Now, we can start the application again with PM2 and check whether the application is available through <span class="No-Break">the internet.</span></p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor433"/>Accessing the application</h2>
			<p>Now, we can access the application<a id="_idIndexMarker1014"/> using the IP address of the Droplet. In my case, the IP address is <strong class="source-inline">144.126.217.34</strong> and the application is running in port <strong class="source-inline">3000</strong>, so I can access the application using the following <span class="No-Break">URL: </span><span class="No-Break"><strong class="source-inline">http://144.126.217.34:3000</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using a different host, such as a machine in your local network, this might be different, as it will depend on your local network configuration and/or firewalls. But if your network is correctly set up, then you should be able to access the website by using the IP address of the machine in your local network, for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">192.168.1.44</strong></span><span class="No-Break">.</span></p>
			<p>We can see the application running <span class="No-Break">as expected:</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B21678_16_ForCEing_FS_9.jpg" alt="Figure 16.9 – Web browser screenshot showing the project running using the droplet IP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9 – Web browser screenshot showing the project running using the droplet IP</p>
			<p>Yes! The application is running<a id="_idIndexMarker1015"/> as expected. We’ll explore another way to run our application in the next chapter, but this time we will <span class="No-Break">use Docker.</span></p>
			<h1 id="_idParaDest-426"><a id="_idTextAnchor434"/>Summary</h1>
			<p>In this chapter, we learned how to deploy our application to the public internet. We learned how important it is to have a clear definition of the requirements and how to choose the best solution for our needs. We created accounts with the providers that we used in this chapter and we pushed the application code to the GitHub repository to have proper source control <span class="No-Break">in place.</span></p>
			<p>Finally, we used MongoDB Atlas to host the database as an external resource and we used a DigitalOcean Droplet to host the application. We learned how to use PM2 to keep the <span class="No-Break">application running.</span></p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor435"/>Further reading</h1>
			<ul>
				<li>How To Set Up a Node.js Application for Production on Ubuntu <span class="No-Break">22.04: </span><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04"><span class="No-Break">https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04</span></a><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-22-04&#13;"/></li>
				<li>Express Production best <span class="No-Break">practices: </span><a href="https://expressjs.com/en/advanced/best-practice-performance.html"><span class="No-Break">https://expressjs.com/en/advanced/best-practice-performance.html</span></a><a href="https://expressjs.com/en/advanced/best-practice-performance.html&#13;"/></li>
			</ul>
		</div>
	</body></html>