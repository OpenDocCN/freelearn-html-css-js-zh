<html><head></head><body>
        

                            
                    <h1 class="header-title">Understanding Chatbots</h1>
                
            
            
                
<p>To create successful chatbots using Alexa or Lex, you first need to understand the components that make up a chatbot. These parts can then be used to create conversation diagrams and flow diagrams, helping visualize the user's path through the conversation. Being able to have this map for the user's conversation makes building chatbots far easier and quicker.</p>
<p>Toward the end of the chapter, we will also introduce Alexa and Lex and have a look at their similarities and differences. We'll also have a quick look at some of the use cases for each of them.</p>
<p>The chapter will explain the following topics:</p>
<ul>
<li>Introducing chatbots</li>
<li>Designing conversation flow diagrams</li>
<li>Best practices</li>
<li>Amazon Alexa and Amazon Lex</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What are chatbots?</h1>
                
            
            
                
<p class="mce-root">Chatbots are a new way to interact with a user in a more human way, through conversation. This is vastly different from existing methods, which provide minimal interaction or personalization.</p>
<p class="mce-root">Chatbots can be either voice or text-based interactions, allowing them to be integrated into existing websites and apps or used in phone calls and virtual assistants.</p>
<p class="mce-root">They have recently been put in the spotlight with products such as Amazon Echo and Google Home, as well as an enormous number of Facebook Messenger chatbots. These advances in technology allow you to check the weather or order a pizza without looking at a screen, or get personalized information without having to wait to talk to a call center.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What makes up a chatbot?</h1>
                
            
            
                
<p>A chatbot is very different in the way that it interacts with a user, and therefore how it works is also very different. There are three main components of a chatbot: <strong>intents</strong>, <strong>slots</strong>, and <strong>utterances</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Intents</h1>
                
            
            
                
<p>Intents are the most important part of a chatbot. They are the tasks or conversations that the chatbot can process. They are called intents because they are the things that the user intends to do.</p>
<p>Intents can vary in complexity from very simple to extremely complicated. A basic intent may just be <kbd>SayHello</kbd>, which just says "Hi" to the user. A more complex intent may be booking a holiday, choosing and buying a pair of shoes, or ordering a pizza. They can be designed to be as elaborate as your imagination allows.</p>
<p>They are started or triggered when the user says one of the <strong>sample utterances</strong>. The sample utterances are a list of words or phrases that the user might say when they are trying to start an intent. Each intent can have lots of sample utterances. In the <kbd>SayHello</kbd> example, they might be "Hello chatbot", "Hey there chatbot", or just "Hi".</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Slots</h1>
                
            
            
                
<p>To allow the chatbot to be really useful, it has to be able to gather details about what the user is asking for. If you are wanting to order a pizza, the chatbot needs to know what toppings you want, what style of base you want, and where you want it delivered to. This information is collected and stored in slots.</p>
<p>Slots are designed to only accept certain types of information. If you were trying to find out whether they wanted a large, medium, or small pizza, it wouldn't be very useful if they could enter any random information. Defining the information that can be stored in a certain slot is called creating a <strong>slot type</strong>.</p>
<p>To make use of the information gathered in the slots, they can be accessed in the next stage of the chatbot logic. This could be as simple as saying "You have ordered a <em>large</em> <em>Hawaiian</em> pizza", where the size and topping are exactly what the user previously ordered.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Utterances</h1>
                
            
            
                
<p>An utterance is a word or phrase that has been said. This is key to chatbots as this is how a user interacts with the chatbot.</p>
<p>These utterances can trigger which intent the user is trying to access and they can also be used to get the exact information needed to fill the slots.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing conversation flows</h1>
                
            
            
                
<p>Now that we understand the components that make up a chatbot, we can start to design the conversations that we want our chatbot to handle. Designing conversations now makes it a lot easier to visualize how the chatbot will work, making it easier and quicker to build. Designing conversations in this way makes them easy to understand, making it a great tool for creating chatbots with people who can't code.</p>
<p>This design method will work for voice or text chatbots; just imagine the textboxes as speech bubbles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting with the perfect conversation diagram</h1>
                
            
            
                
<p>Everything has to start somewhere, so it may as well be perfect. The aim of this stage is to have a basic conversation diagram that we will later expand into a detailed flow diagram.</p>
<p>To do this, you need to think about what the perfect conversation with your user would be. Start by writing down what the user will say and how the bot will respond. This is an example of ordering a pizza:</p>
<div><img src="img/eb1621bf-6e58-4ef7-aa63-15b85326f36b.png" style=""/></div>
<p>Ordering pizza conversation</p>
<p>This can be done in lots of ways: with flow diagram software, using two phones or two messaging accounts, or simply with pen and paper. The aim is just to understand how the chatbot is going to be interacting with the user and what utterances the user is likely to say.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conversation flow diagrams</h1>
                
            
            
                
<p>Now that you have a basic conversation diagram, we need to make it into a flow diagram. A flow diagram is different from a conversation diagram in a few key ways:</p>
<ul>
<li>Each part of a flow diagram has its own symbol, making it easy to understand what is happening at each stage.</li>
<li>A flow diagram contain more than just the conversation. It also describes the logic, information, and processes that take place behind the scenes.</li>
<li>Flow diagrams aren't linear. This means that they can describe lots of conversations where the user says different things.</li>
</ul>
<p>To properly describe our chatbots, we need to have a symbol for each of the parts of the conversation. To start with, we are going to be using six, but we can add more symbols later on:</p>
<div><img src="img/c3603139-a654-43bb-851f-9b6408ef6a10.png" style=""/></div>
<p>Flow diagram symbols</p>
<p>To create our flow diagrams, we'll be using flow diagram software. There are a couple of reasons we want to use flow diagram software instead of a normal document or even creating them by hand:</p>
<ul>
<li>They are easily editable. We are going to be changing the stages of the conversational flow and the text of utterances and replies as we work through this book. Having to redraw the diagram every time you make a change would be very time-consuming.</li>
<li>It's the easiest way to make flow diagrams. The symbols snap into place and are easy to edit and modify. Doing flow diagrams in Word would be far more time-consuming.</li>
</ul>
<p>In all of the examples throughout this book, we'll be using <a href="https://www.draw.io/">www.draw.io</a>, but if you have a different flow diagram software that you prefer then that will work too. We use draw.io as it's free, online, and is very easy to use.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a conversation flow diagram</h1>
                
            
            
                
<p>Now that we know the parts of a conversation flow diagram, let's create one. We'll use the same pizza order conversation that we used earlier.</p>
<p>Start at the very beginning of the conversation. Create a symbol for the user's first utterance. This first message from the user is a really important one as it will trigger an intent:</p>
<div><img src="img/07a433dc-1995-4eb3-9ad9-831d3ad7becf.png" style=""/></div>
<p>Utterance triggering an intent</p>
<p>Now that the <kbd>OrderPizza</kbd> intent has been triggered, our chatbot can start asking the user about the pizza they want to order. We'll start by asking what topping they want and they reply with "Hawaiian":</p>
<div><img src="img/ed5eebe7-a61c-484d-bd7b-cd558775f549.png" style=""/></div>
<p>Starting the intent</p>
<p>Later on, we want to remember that they chose Hawaiian as their topping so we need to store this as a slot. We store the information against a slot name, so in this case, it will be <strong>topping = Hawaiian</strong>. As well as storing the slot, we need to carry on the conversation, asking them what size of pizza they want:</p>
<div><img src="img/c7b50a80-dc4e-4229-a58b-ec53a1933f49.png" style=""/></div>
<p>Storing a slot value</p>
<p>With the response from the user, we store the size in a slot and proceed to the next stage. We repeat the question, answer, slot process for the size of pizza the user wants. </p>
<p>Now that we have all of the information that we need, we need to tell the pizzeria that someone has ordered a medium Hawaiian pizza. For this, we'll use the action symbol and make sure to include the slots that are required. When we include slot information into anything, it is normal to write it as the slot name wrapped in curly braces.</p>
<p>As well as telling the pizzeria about the order, we need to let the user know that their order has been placed and tell them when to collect it. Again, we use the slot name wrapped in curly braces to customize the message with slot information:</p>
<div><img src="img/3a82030d-254a-4698-893b-496705c267a0.png" style=""/></div>
<p>Full pizza ordering flow diagram</p>


            

            
        
    

        

                            
                    <h1 class="header-title">User stories</h1>
                
            
            
                
<p>User stories are a vital tool in the design and testing of chatbots. They are stories about fictional users, what they want, and how they will interact with your bot. When we create a user story, it needs to be as close to a real user as possible. They should be based on a real user or the type of user that would be using your chatbot. If you have existing customers that you are wanting to target your chatbot toward then you can create data-driven user stories.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To create a user story, start by describing the user and why they are talking with your bot. Examples of the pizza ordering bot might be the following:</p>
<ul>
<li>Chris, a 23-year-old joiner. Wants to order a pizza on his phone so he can pick it up on the way home from work.</li>
<li>Claire, a 35-year-old bank manager. Ordering a pizza using Alexa while she watches TV.</li>
</ul>
<p>The user descriptions don't have to be very long or complicated, but they have to represent the kind of users the bot will get.</p>
<p>For each user, go through the flow diagram pretending that the bot is talking to that user. The aim of this is to test your flow diagram before we start building the bot. If you find that the conversation doesn't work for a certain part of the flow diagram, changing it now will save you time later on.</p>
<p>For simple examples like this pizza order, there won't be a big difference between all of the conversations, but user stories will become more important as we create more complicated flow diagrams.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Best practices</h1>
                
            
            
                
<p>Anyone can make a chatbot. With a bit of practice, you can build a simple bot in a few hours. The problem with building bots like this is that, as they grow in scope and complexity, they can very easily become unmanageable. Simple changes can result in hours or even days of bug fixing and it can ruin the joy you get when you finally get the chatbot working.</p>
<p>To avoid the horror of working with a disorganized and complex chatbot, there are a few best practices. Following these will reduce your headache later on and allow you to quickly and easily add new features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling errors</h1>
                
            
            
                
<p>Throughout a user's conversation with a chatbot, there are a lot of points where errors can occur. Errors can occur when an utterance isn't understood, an API returns an error or when there is a mistake in the developer's code. Each of these needs to be caught and dealt with properly. We'll cover how to use <kbd>try</kbd>/<kbd>catch</kbd> and the <kbd>to()</kbd> method to catch these errors in <a href="7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml" target="_blank">Chapter 4</a>, <em>Connecting Your Alexa Skill to External APIs</em>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Missed utterances</h1>
                
            
            
                
<p>The most common error will be when utterances aren't understood or aren't what the chatbot expected. This can be because the user typed something incorrectly, misspelled a word, or just typed a response you hadn't thought of. Alexa and Lex both use <strong>natural language understanding</strong> (<strong>NLU</strong>) to try to reduce the errors from misspelling and varied responses but they aren't perfect.</p>
<p>Because not understanding the user's utterance is such a common error, both Lex and Alexa also have systems to handle them. This involves a failure phrase that can be sent to the user when the chatbot doesn't understand what the user just said. Make sure that this is set up properly and that you are asking the user to try again or to choose a different option:</p>
<div><img src="img/be26d4ed-98ec-4bb8-bb8f-ba3f003deb01.png" style=""/></div>
<p>Failed utterances</p>
<p>Alexa and Lex also have a feature that stores all of the times that it couldn't understand an utterance. Using this list, you can add more sample utterances to help the chatbot understand more. Doing this regularly can give a massive boost to your user satisfaction, as well as helping you understand how your users interact with your bot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">External APIs</h1>
                
            
            
                
<p>Every time you deal with anything outside of your code, there is a risk that it will error. This might be a third-party API, your own API, or simply a query to a database. You should always write these requests so that if the request returns an error, you fully deal with it. This means logging what the error was and where it took place and making sure that the chatbot still works when an error occurs.</p>
<p>Making sure that the chatbot still works when an error occurs is really important as no one wants to talk to a chatbot that just stops talking to you halfway through the conversation. To make sure this doesn't happen, you have three options: create error messages for every external call you make, let all errors flow down to a very low-level error handler that sends a generic <em>We had an error</em> message, or a combination of the two. The idea would be using custom messages for every error that could happen but as your chatbot becomes larger and more complicated, that can become very time-consuming.</p>
<p>An effective method for dealing with the errors is to create a low-level error handler that passes a generic error message unless a specific error message is provided. This gives you the flexibility to let the user know exactly what went wrong when it matters but saves you having to create lots of similar error messages:</p>
<pre>try {<br/>    let result = AccessPeopleAPI();<br/>    if (result === null || typeof result !== 'number'){<br/>        throw 'I've failed to get the number of people';<br/>    }<br/>    return 'We have ' + result + ' people in the building';<br/>} catch (error) {<br/>    console.log(error || 'The system has had an error');<br/>    return error || "Unfortunately I've had an error";<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Errors in your code</h1>
                
            
            
                
<p>No developer wants to admit there are bugs in their code, but if you create more than a simple chatbot, there probably will be. There are different ways to approach this problem, from writing tests for every function, to thorough end-to-end testing, to wrapping everything in a <kbd>try</kbd>/<kbd>catch</kbd>. This book will let you decide how you want to deal with these errors, but expecting your code to be error-free is a very dangerous path.</p>
<p>No matter how you want to stop errors getting into your code, you need to deal with them when you get them. This is where having a low-level error handler can also be of use. You can use that to catch errors that have occurred in your code the same way that you deal with errors from external APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tone of voice</h1>
                
            
            
                
<p>One of the best things about chatbots is the fact that they are conversational and feel more human. Because of this, you need to give your bot a personality and you need to tailor that personality to suit the purpose of the chatbot and the users who will be interacting with it.</p>
<p>Having a banking chatbot that uses slang might make the users trust the chatbot less, whereas having a clothing sales chatbot that uses lots of very formal or old-fashioned language might be just as off-putting.</p>
<p>Try to design the language that the chatbot uses to be in line with your brand persona. If you don't have a brand persona then you can build one by interviewing your staff and customers. Use these interviews to create a persona (similar to a user story) that relates closely to your customers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Identifying suitable use cases</h1>
                
            
            
                
<p>Chatbots are awesome! Being able to create a new way for users to interact is such a great feeling that you want to make a chatbot for everything. Unfortunately, chatbots aren't suited to every situation and some things need to be carefully thought through before being implemented. You need to think about whether users would want to talk about certain things with a chatbot, as well as how the chatbot will be communicating back.</p>
<p>Thinking about the way that the bot will be communicating is particularly important for voice-based chatbots, as everything that the chatbot says will be sent through speakers for everyone around to hear. This could end badly for a chatbot that accesses your bank information, reads your emails, or deals with any other personal information. When designing your Alexa conversations, ask yourself whether you'd want Alexa telling all of your friends and colleagues about your results from your doctor's appointment or reading out an email from your partner about what they had planned for that evening.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing the information for the delivery method</h1>
                
            
            
                
<p>As the method of information delivery is very different from existing methods (emails, websites, and printed media), you also need to think about what it will be like for the user. For example, when creating a newspaper chatbot, having Alexa read the whole paper for 15 minutes or Lex send a huge chunk of text might not be very user-friendly. Instead, you could break down the information into smaller chunks, or give a brief overview of the information.</p>
<p>There can be a fine line between a chatbot that provides the user with great information and one that talks too much. Make sure that the amount of information is designed in a way that is suited to the end delivery method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Amazon Alexa and Lex</h1>
                
            
            
                
<p>Alexa and Lex are a pair of tools built by Amazon to change the way that users interact with technology. They are platforms that allow developers to create immensely powerful conversational interfaces without having to study deep learning, natural language processing, or speech recognition.</p>
<p>They are part of the <strong>Amazon Web Services</strong> (<strong>AWS</strong>) group and therefore work brilliantly alongside the rest of the services, making the development process smoother and more consistent.</p>
<p>The main difference between Alexa and Lex is that the Alexa platform allows developers to create skills for Alexa-enabled devices, whereas Lex allows developers to create generic text or voice-based chatbots. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Amazon Alexa</h1>
                
            
            
                
<p>Amazon Alexa is a voice-based chatbot that is the brains behind the Echo family of products from Amazon. Users can customize their Echo experience by adding <strong>skills</strong> to their Alexa account in a similar way to how you add apps onto a smartphone. These skills can be downloaded from the Alexa Skills Store and there are thousands to choose from.</p>
<p>Similar to apps, each of these skills has been designed to perform a single task, whether that's to talk you through a recipe to cook, guide you through your morning workout, or just to tell you jokes.</p>
<p>Alexa was released in November 2014 and has become increasingly popular. By the end of 2017, Amazon had sold tens of millions of Alexa-connected devices. This has resulted in Alexa devices securing 55% of the market for virtual assistants by February 2018.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Amazon Lex</h1>
                
            
            
                
<p>Amazon Lex is a chatbot service that allows developers to create either text- or voice-based chatbots, utilizing the incredible power of the deep learning, natural language understanding, and speech recognition that Amazon has developed. Lex differs from Alexa in that it can be integrated into different devices and services.</p>
<p>Lex is most commonly used as a text-based chatbot. There are loads of different ways that users interact with text-based chats, and Lex can integrate with a lot of them. Developers can create Facebook Messenger bots, Slack bots, Kik bots, and Twilio texting bots through integrations built into the Lex platform.</p>
<p>Lex can also be triggered through the AWS-SDK, meaning that it can be put behind an endpoint. This means that developers can set up a system where they post messages to an API and get back the response from Lex. This gives you the flexibility to send messages to Lex from almost any system. This can be used to create a chat window inside a website, create a chatbot on almost any messaging service, or integrate it with any system that can connect with the internet.</p>
<p>Using Amazon Transcribe for speech recognition, you could create a system very similar to Alexa. This has been used very effectively in call centers, allowing a customer to talk to a virtual service representative instead of just waiting until a human service representative is available. This means that a lot of callers can get the information that they need without talking to a human. This has the dual effect of reducing the time to get an answer if the bot can solve your problem, and reducing the number of people going through to the call center, reducing call wait times.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've learned about the components of chatbots—intents, slots, and utterances—and the role that each of them plays.</p>
<p>Next, we learned how to design conversation flows, starting with an ideal conversation and converting it into a conversation flow diagram. Using flowchart software, we created conversation flow diagrams to help visualize how our chatbot will interact with the users.</p>
<p>We talked about the best practices for creating a chatbot, from handling errors to designing your conversations to work well on chatbots, from the tone of voice to good chatbot use cases.</p>
<p>The last part of this chapter introduced Amazon Alexa and Amazon Lex. We learned about the similarities and differences between the two types of chatbot as well as a bit of background into them both.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What are the three main components of a chatbot?</li>
<li>Name two things that Alexa and Amazon Lex have in common.</li>
<li>Name two differences between Alexa and Amazon Lex.</li>
<li>When designing a conversation flow, where should you start?</li>
<li>What does <em>tone of voice</em> mean?</li>
<li>What are the three main types of errors that can occur in chatbots?</li>
</ol>


            

            
        
    </body></html>