<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-122">6. <a id="_idTextAnchor155"/>Advanced Types</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to advanced types. You will start with the building blocks of advanced types – type alias, string, and number literals. This will allow you to gain a better understanding as you take on more complex concepts such as union types. You will also learn how you can combine types to build more complex types, such as intersections. Using advanced types, this chapter teaches you how to write code that is easier to understand for yourself and any others working with you or who are inheriting the project. By the end of this chapter, you will be able to build advanced types by combining primitive types, such as strings, numbers, and Booleans, with objects.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor156"/>Introduction</h1>
			<p>In the previous chapter, we went over interfaces and inheritance. You saw how they allowed for the extension and modeling of your classes. Interfaces give your classes structure, and inheritance allows you to extend and build on your existing code. </p>
			<p>As web applications become more complex, it is necessary to be able to model that complexity, and TypeScript makes that easy with advanced types. Advanced types allow you to model the complex data you will be working with as a modern web developer. You will be able to take primitive types and make more complex types from them, creating types that are conditional and flexible. This will allow you to write code that is easy to understand and therefore easier to work with. As a working developer, you may come across a dataset provided by an API that you need to integrate into your application. These datasets can be complex. For example, Cloud Firestore from Google is a document-based, real-time database that can have objects nested within objects. With advanced types, you can create a type that is an exact representation of the data coming from the API. This will provide much more context to your code, which, in turn, will make it easier to work with for you and your team. You will also be able to stack complexity by building simpler types and stacking them to make more complex types.</p>
			<p>In this chapter, we will cover the building blocks of advanced types – type aliases and type literals. Once we learn how to build types, we will move on to more advanced concepts, including intersection, union, and index types. All these concepts will help you to learn how to use advanced types to add context and abstract complexity to code. </p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor157"/>Type Aliases</h1>
			<p><strong class="bold">Type Aliases</strong> allow you to declare references to any type – advanced or primitive. Aliases make our code easier to read by allowing us to be less verbose. Aliases allow you, the developer, to declare your type once and reuse it throughout your application. This makes working with complex types easier and your code more readable and maintainable.</p>
			<p>Let's say, for example, we are working on a social networking application and we needed to provide an administrator user type for users to manage the pages they created. Additionally, we also need to define a site administrator user. On a base level, they are both admins, and therefore the types would have some commonality between them. With a type alias, we could create an admin type as shown in <em class="italic">Figure 6.1</em>, with common properties an admin user would possess and build upon that admin when creating our site admin and user admin types. Aliases allow you to mask the complexity of your code, which will make it easier to understand. Here we have a diagram of an alias that assigns the <code>Admin</code> alias to an admin type, which is a complex <code>type</code> object. We also have an example of an alias, <code>One</code>, that is assigned to a type, <code>number</code>, which is a primitive type:</p>
			<div><div><img src="img/B14508_06_01.jpg" alt="Figure 6.1: Alias assigning a complex admin type alias&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Alias assigning a complex admin type alias</p>
			<p>Consider the following code snippet:</p>
			<pre>// primitive type assignment
type One = number;</pre>
			<p>In the preceding example, we have created an alias, <code>One</code>, that can be used as a type for any number, as it is assigned to the type number.</p>
			<p>Now, consider the following code snippet:</p>
			<pre>// complex (object assignment)
type Admin = {
    username: string,
    email: string,
    userId: string,
    AllowedPages: string   
};</pre>
			<p>Here, we have created an <code>Admin</code> alias, which we have assigned to an object that represents the common properties of a typical administrator, in the context of this example. As you can see, we have created a reference to a <code>type</code> object, which we can now use in our code instead of having to implement the object each time. </p>
			<p>As you can see in the preceding diagram and code snippet, type aliases work in a similar way to variable assignments, except a reference is created for a primitive type and/or an object. This reference can then be used as a template for your data. This will allow you to take advantage of all the benefits of a strongly typed language, such as code completion and data validation.</p>
			<p>Before we go into our first exercise on type aliases, we will look at some examples of primitive and complex assignments. </p>
			<p>Let's say you are working on a class method that takes numbers as arguments, and only numbers. You want to make sure that when your method is used, only numbers are passed as arguments and the right error messages are shown to the user if any other type is passed.</p>
			<p>First, we need to create a number type alias with the following syntax:</p>
			<pre>type OnlyNumbers = number;</pre>
			<p>The <code>type</code> keyword is followed by the alias, <code>OnlyNumbers</code>, and then the <code>number</code> type.</p>
			<p>Now we can build a class with a method that only takes numbers as an argument and use the type alias to enforce our rule:</p>
			<pre>// instance of numbers only class
class NumbersOnly {
    count: number
    SetNumber(someNumber: OnlyNumbers) {
        this.count = someNumber
    }
}</pre>
			<p>Now, let's instance our class and pass some arguments to our method to see whether our code works. </p>
			<p>For this example, let's try and assign a string as the argument type:</p>
			<pre>// class instance
const onlyNumbers = new NumbersOnly;
// method with incorrect arguments
onlyNumbers.SetNumber("15");</pre>
			<p>In the preceding code snippet, we have provided the wrong argument of the <code>string</code> type and this will result in a warning because our method, <code>SetNumber</code>, is expecting a number. Also, by providing your type aliases with meaningful names such as <code>onlyNumbers</code>, you can make your code easier to read and debug. For this example, the section of the code with the problem is highlighted, and when you hover over the error, you get a very helpful error message telling you what the issue is and how it can be resolved:</p>
			<div><div><img src="img/B14508_06_02.jpg" alt="Figure 6.2: Error message in VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Error message in VS Code</p>
			<p>This is the case provided that you have the correct support from your IDE. If you don't have IDE support, you will be shown an error message at code compilation.</p>
			<p>This is a simple use case, but as your applications become larger, some time has passed, or you are working in a large team, this kind of type security is vital to writing code that is free of mistakes.</p>
			<p>Let's consider another example: Say you are working on an online store application and you need to use a product class that was not created by you. If the person who created the class made use of types and used descriptive names, it would be easier for you to work with that code. </p>
			<p>Now, let's edit the first example with the correct argument type:</p>
			<pre>// method with correct arguments
onlyNumbers.SetNumber(15);</pre>
			<p>In the preceding code snippet, we have provided the correct argument type of <code>number</code> and your class method takes the argument with no issues. </p>
			<p>Now, let's consider a complex alias assignment. </p>
			<p>For example, we want to create a new function that takes a user object as a type argument. We could define the object as the function argument inline, as shown here:</p>
			<pre>// function and type definition  
function badCode(user: {
    email: string,
    userName: string,
    token: string, 
    lastLogin: number
}) {}</pre>
			<p>In the preceding snippet, the code creates a function that takes a user as an argument, but the type is defined in the function itself. While this would work, let's say you were using the object in a few places in your code, then, you would have to define this object each time. This is very inefficient and, as a good developer, you don't want to repeat code. This way of working will also lead to errors; it will make your code harder to work with and update as every instance of the <code>User</code> type will need to be changed throughout your code. Type aliases resolve this by allowing you to define your type once, as we will demonstrate in the following code snippet.</p>
			<p>In much the same way as we have defined our primitive type, we have defined our <code>User</code> type. We use the <code>type</code> keyword, but now we have mapped to an object that is a template of our <code>User</code> type. We can now use the <code>User</code> alias, rather than having to redeclare the object every time we need to define the <code>User</code> type:</p>
			<pre>// object / complex type User
type User = {
    email: string,
    userName: string,
    token: string, 
    lastLogin: number
};</pre>
			<p>As you can see, we have created a type with the alias <code>User</code>. This allows you to make a single reference to this object type and reuse it throughout your code. If we did not do this, we would have to reference the type directly. </p>
			<p>Now you can build a new function using your <code>User</code> type:</p>
			<pre>// function with type alias
function goodCode(user: User){}</pre>
			<p>As you can see, this code is much less verbose and easy to understand. All your code regarding the <code>User</code> type is in one location, and when changes are made to the object, all aliases are updated. In the following exercise, you will implement what we have covered so far to build your own type alias.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor158"/>Exercise 6.01: Implementing a Type Alias</h2>
			<p>In this exercise, we will use our knowledge of types to build a function that creates products. Let's say, for example, you are working on a shopping application and when the inventory manager adds a product to the inventory, you need to push that product to your array of products. This exercise demonstrates a few ways in which type aliases can be useful by allowing you to define your <code>Product</code> model once and reuse it throughout your code. </p>
			<p>Now, in an actual inventory management application, you might have a frontend page that allows a user to input the product name and supporting information manually. For the purpose of this exercise, let's assume the products you want to add are named <code>Product_0</code> through to <code>Product_5</code> and all have a price of 100, while the number of each of these products added to the inventory is 15.</p>
			<p>This may not be truly reflective of an actual scenario in an inventory management application, but remember, our key goal is to use a type alias. So for now, a simple <code>for</code> loop to complete the aforementioned tasks will suffice:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All files in this chapter can be executed by running <code>npx ts-node filename.ts</code> on the terminal. The code file for this exercise can be found here: <a href="https://packt.link/EAiHb">https://packt.link/EAiHb</a>.</p>
			<ol>
				<li>Open VS Code and create a new file named <code>Exercise01.ts</code>.</li>
				<li>Create a primitive type alias, <code>Count</code>, that is of the <code>number</code> type. <code>Count</code> will be used to keep track of the number of products:<pre>//primitive type
type Count = number;</pre></li>
				<li>Create an object type alias, <code>Product</code>, that is of the <code>type</code> object. Re-use <code>Count</code> to define the count of the product. The <code>Product</code> type alias will be used to define every product we add to our inventory. The properties are common across all products:<pre>// object type 
type Product = {
    name: string,
    count: Count, //reuse Count
    price: number,
    amount:number,
}</pre></li>
				<li>Declare a <code>products</code> variable of the <code>Product</code> type array:<pre>// product array
const products_list: Product[] = [];</pre><p>In order for us to make use of the <code>Product</code> type, it was first assigned to a variable in the preceding code, and the <code>product_list</code> variable is an array of objects of the <code>Product</code> type.</p></li>
				<li>Create a function that adds products to the array. Re-use the <code>Product</code> type alias to validate the argument input:<pre>// add products to product array function
function makeProduct(p : Product ) {
    products_list.push(p); // add product to end of array
}</pre></li>
				<li>Use a <code>for</code> loop to create product objects of the <code>Product</code> type and add them to the <code>products</code> array:<pre>// use a for loop to create 5 products
for (let index = 0; index &lt; 5; index++) {
    let p : Product = {
        name: "Product"+"_"+`${index}`,
        count: index,
        price: 100,
        amount: 15
    }//make product
    makeProduct(p);
}
console.log(products_list);</pre></li>
				<li>Compile and run the program by executing <code>npx ts-node Exercise01.ts</code> in the correct directory in which this file is present. You should obtain the following output:<pre> [
  { name: 'Product_0', count: 0, price: 100, amount: 15 },
  { name: 'Product_1', count: 1, price: 100, amount: 15 },
  { name: 'Product_2', count: 2, price: 100, amount: 15 },
  { name: 'Product_3', count: 3, price: 100, amount: 15 },
  { name: 'Product_4', count: 4, price: 100, amount: 15 }
]</pre></li>
			</ol>
			<p>In this exercise, you created two type aliases, which in turn created references to your actual types.</p>
			<p>This allowed you to reduce complexity and make your code more readable, as now you can provide names that have additional context with descriptive names such as <code>Product</code> and <code>products_list</code>. If we were to write this code without the use of aliases, at every place where you used your aliases in the exercise, you would have to define the object or the type directly. This might not be much of an issue here with this simple function, but keep in mind how much more code you would need to build a class or a major project.</p>
			<p>As we proceed to more complex type structures, this knowledge will become invaluable. We will continue to build on our knowledge in the next section as we cover type literals. </p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor159"/>Type Literals</h1>
			<p><strong class="bold">Type literals</strong> allow you to create a type based on a specific string or number. This, in itself, is not very useful, but as we move on to more complex types such as union types, their use will become apparent. Literals are straightforward, so we will not spend a lot of time on them but you will need to understand the concept of literals as we move into the next phase.</p>
			<p>Let's start by creating our string and number literals. </p>
			<p>We will begin with a string literal:</p>
			<p><strong class="bold">Example01.ts</strong></p>
			<pre>1 // string literal  
2 type Yes = "yes";
Link to the preceding example: <a href="https://packt.link/96IlD">https://packt.link/96IlD</a>. </pre>
			<p>The preceding code creates a <code>Yes</code> type that will take only a specific string, <code>"yes"</code>, as the input.</p>
			<p>Similarly, we can create a number literal:</p>
			<pre>3 // number literal
4 type One = 1;</pre>
			<p>Here, we create a number literal type, <code>One</code>, that will only take <code>1</code> as the input.</p>
			<p>The basic syntax as observed in the preceding examples is quite simple. We start with the <code>type</code> keyword, followed by the name (alias) of our new literal, and then the literal itself, as shown in the preceding syntax. We now have a type of the <code>yes</code> string and the number <code>1</code>.</p>
			<p>Next, we will build a function that will make use of our new types:</p>
			<pre>5 // process my literal 
6 function yesOne(yes: Yes, one: One ) {
7     console.log(yes, one);
8 }</pre>
			<p>We have cast our function arguments to our literal types, and because our types are literal, only the "<code>yes</code>" string or the number <code>1</code> will be accepted as arguments. Our function will not take other arguments. Let's say we passed <code>""</code> and <code>2</code> as arguments (<code>yesOne("", 2)</code>). You will notice the following warning in VS Code:</p>
			<div><div><img src="img/B14508_06_03.jpg" alt="Figure 6.3: IDE warning when incorrect arguments are passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: IDE warning when incorrect arguments are passed</p>
			<p>Now, let's say we passed <code>"yes"</code> and <code>2</code> as arguments. Again, you will get the following warning:</p>
			<div><div><img src="img/B14508_06_04.jpg" alt="Figure 6.4: Errors displayed when a parameter that cannot be assigned is passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Errors displayed when a parameter that cannot be assigned is passed</p>
			<p>The preceding are some examples of error messages you might expect if you provide the wrong arguments. The error messages are clear and tell you precisely what you need to do to resolve the error. As you can see, even though we are passing a string and a number, we still get a type error. This happens because these arguments are literal; they can only match themselves exactly.</p>
			<p>Now, let's try and pass the correct arguments:</p>
			<pre>9 // function with the correct arguments 
10 yesOne("yes", 1);</pre>
			<p>Once provided with the correct arguments, the function can be called without any issue, as shown in the following output:</p>
			<pre>yes 1</pre>
			<p>Before we move on to intersection types, let's quickly complete a simple exercise to cement our knowledge of string and number literals.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor160"/>Exercise 6.02: Type Literals</h2>
			<p>Now that we have a better understanding of literals, let's go through a small exercise to reinforce what we have covered. Here we will create a function that takes a string literal and returns a number literal:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/hHgNa">https://packt.link/hHgNa</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <code>Exercise02.ts</code>.</li>
				<li>Create a string literal type, <code>No</code>, and assign the string <code>"no"</code> as the value. Also, create a number literal and assign 0 as the value:<pre>type No = "no"
type Zero = 0</pre></li>
				<li>Build a function that takes the "<code>No</code>" literal and prints it to the console: <pre>function onlyNo(no: No):Zero {
    return 0;
}</pre></li>
				<li>Console out the function call results:<pre>console.log(
    onlyNo("no")
)</pre><p>This will result in the following output:</p><pre>0</pre></li>
			</ol>
			<p>Literals by themselves are not very useful, but when used in combination with more complex types, their usefulness will become apparent. For now, you need to understand how to create literals, so you can make use of them later in this chapter. In the next section, we move on to intersection types. All the work that we have completed so far will help as we make use of type aliases and literals.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor161"/>Intersection Types</h1>
			<p><strong class="bold">Intersection Types</strong> allow you to combine types to form a new type with the properties of the combined types. This is useful in cases where you have an existing type that does not, by itself, address some data you need to define, but it can do so in combination with another existing type. This is similar to multi-class inheritance, as the child object can have more than one parent object that it derives its properties from. </p>
			<p>Let's say you have a type <code>A</code> with a name and age property. You also have a type <code>B</code> with a height and weight property. In your application, you find that there is a need for a person type: you want to track the user's name, age, height, and weight. You can intersect type <code>A</code> and <code>B</code> to form a <code>Person</code> type. Why not just create a new type you ask? Well, this takes us back to wanting to be good coders and good coders stay DRY – Don't Repeat Yourself. Unless a type is truly unique in your application, you should reuse as much code as possible. Also, there is centralization. </p>
			<p>If you need to make changes to any of the type code for <code>Person</code>, you just need to make the changes in <code>A</code> or <code>B</code>. This is also a bit limiting as there may be cases where type <code>A</code> is used by more than one object, and if you make changes, it will break the application. With intersection, you can simply create a type <code>C</code> with the changes and update your <code>Person</code> type. You can also merge types with common properties. </p>
			<p>Consider a situation where you have a <code>name</code> property in <code>A</code> and also in <code>B</code>. When the types are intersected, you would now have just one <code>name</code> property; however, the merged properties must not only be the same in name, but should also be of the same type, otherwise the types will not merge and will result in errors. </p>
			<p>If this is not clear, let's look at a property, <code>age</code>. This can be a number in one type and a string in another. The only way you could intersect these types would be to make the properties common, as either would need to be a string or number.</p>
			<p>Imagine that as part of an e-commerce project, you are required to build a shopping cart object that derives its properties from a <code>Product</code> object and an <code>Order</code> object.</p>
			<p>The following diagram shows the basic properties of each object and the properties of the new <code>Cart</code> object that is formed using the <code>Product</code> and <code>Order</code> objects:</p>
			<div><div><img src="img/B14508_06_05.jpg" alt="Figure 6.5: Diagram showing the properties of the Cart object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Diagram showing the properties of the Cart object</p>
			<p>In the diagram, we have our parent objects, <code>Product</code> and <code>Order</code>, that combine to form a child object, <code>Cart</code>, with all the properties of its parent objects. Please note that we can have more than two parents in an intersection, but for the sake of this explanation, we will stick to two, as this will allow you to grasp the concept faster. In the upcoming example, we will walk through the process of creating our new <code>Cart</code> type in code and a basic use case.</p>
			<p>Imagine you are working on the shopping application. You need to create an object to model the product data you will push to the cart for checking out. We already have a <code>Product</code> type for our product data. The <code>Product</code> type has most of what we need to display correct information pertaining to our products on the web page. However, we are missing a few things we require when checking a product out. We will address this not by creating a new type of product, but we will create an <code>Order</code> type with just the properties we need: <code>orderId</code>, <code>amount</code>, and <code>discount</code>, the last of which is optional as it will not always apply. </p>
			<p>Here is the code for declaration of the <code>Product</code> type: </p>
			<pre>Example02.ts
1 // product type
2 type Product = {
3     name: string, 
4     price: number,
5     description: string
6 } 
7 
8 // order type
9 type Order = {
10     orderId: string,
11     amount: number,
12     discount?: number 
13 }
Link to the preceding example: <a href="https://packt.link/DZ7Iz">https://packt.link/DZ7Iz</a></pre>
			<p>In the preceding code snippet, we have created our parent types names <code>Product</code> and <code>Order</code>. Now we need to merge them. This will create the type we need to model our cart data:</p>
			<pre>14 // Alias Cart of Product intersect Order
15 type Cart = Product &amp; Order;</pre>
			<p>We build our cart object by assigning an alias, <code>Cart</code>, to our <code>Product</code> and <code>Order</code> types and using <code>&amp;</code> between our two types, as shown in the preceding snippet. We now have a new merged type, <code>Cart</code>, that we can use to model our cart data:</p>
			<pre>16 // cart of type Cart
17 const cart: Cart = {
18     name: "Mango",
19     price: 400,
20     orderId: "x123456",
21     amount: 4,
22     description: "big sweet, full of sugar !!!" 
23 }</pre>
			<p>The preceding is an example of a cart object declared using the <code>Cart</code> type. As you can see, we have access to all our properties and can omit optional ones that may not always apply, such as <code>discount</code>. </p>
			<p>If we do not provide all the required properties, the IDE gives a very helpful error message telling us just what we need to do in order to fix the issue:</p>
			<div><div><img src="img/B14508_06_06.jpg" alt="Figure 6.6: The error message displayed when missing required properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: The error message displayed when missing required properties</p>
			<p>Now, let's console out our new cart object: This will display the following output:</p>
			<pre>{
  name: 'Mango',
  price: 400,
  orderId: 'x123456',
  amount: 4,
  description: 'big, sweet, and full of sugar !!!'
}</pre>
			<p>In the next section, you will get some hands-on experience in terms of creating intersection types by performing an exercise in which you will build a prototype user management system.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor162"/>Exercise 6.03: Creating Intersection Types</h2>
			<p>You are working on an e-commerce application; you have been assigned the task of building out the user management system. In the application requirements, the customer has listed the types of user profiles they expect will interact with the system. You will use type intersection to build out your user types. This will allow you to build simple types that can be combined to make more complex types and separate your concerns. This will result in code that is less error-prone and better supported. Here, we name the user types we will build and provide an overview of their functions:</p>
			<ul>
				<li><code>_id</code>, <code>email</code>, and <code>token</code>.</li>
				<li><code>accessPages</code> and <code>lastLogin</code>. <code>accessPages</code> is a string array of pages that this user can access, while <code>lastLogin</code> will help us to log the activates of the Admin user.</li>
				<li><code>lastBackUp</code> and <code>backUpLocation</code>. <code>lastBackUp</code> will let us know what time the system was last backed up, while <code>backUpLocation</code> will tell us where the backup files are stored.</li>
				<li><strong class="bold">superUser</strong>: This user is an intersection of the Admin and User types. All users require the properties of a Basic user, but only Admin users require Admin properties. Here, we use type intersection to build the necessary properties we need.</li>
				<li><code>Backup</code> user and <code>Basic</code> user types. Once again, we can incorporate into our basic user the necessary complexity this user type requires in order to function.<p class="callout-heading">Note</p><p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/FVvj5">https://packt.link/FVvj5</a>.</p></li>
			</ul>
			<ol>
				<li value="1">Open VS Code and create a new file named <code>Exercise03.ts</code>.</li>
				<li>Create a basic <code>User</code> type:<pre>// create user object type
type User = {
    _id: number;
    email: string;
    token: string;
}</pre><p>This will be the type we will use as our base for the other user types in our application. Thus, it has all the common user properties that all users will require.</p></li>
				<li>Create an <code>Admin</code> user type for users who need to perform the functions of an administrator:<pre>// create an admin object type
type Admin = {
    accessPages: string[],
    lastLogin: Date
}</pre></li>
				<li>Create a <code>Backup</code> user type for users who are responsible for backing up the application data:<pre>// create backupUser object type
type Backup = {
    lastBackUp: Date,
    backUpLocation: string
}</pre></li>
				<li>Using your <code>User</code> and <code>Admin</code> types, declare a <code>superuser</code> object of the <code>User</code> type at the <code>Admin</code> intersect. Add the required properties. In order to create a superuser, you will have to provide values for the properties of <code>User</code> and <code>Admin</code>, as shown in the following code block: <pre>// combine user and admin to create the user object
const superUser: User &amp; Admin = {
    _id: 1,
    email: 'rayon.hunte@gmail.com',
    token: '12345',
    accessPages: [
        'profile', 'adminConsole', 'userReset'
    ],
    lastLogin: new Date() 
}; </pre><p>In an actual application, this code may be in a login function and the values returned might be from an API on login.</p></li>
				<li>Build a <code>BackUpUser</code> type by assigning the alias <code>BackUpUser</code> to the intersection of <code>User</code> and <code>Backup</code>:<pre>// create BackUpUser type
type BackUpUser = User &amp; Backup</pre></li>
				<li>Declare a <code>backUpUser</code> object of the <code>BackUpUser</code> type and add the requisite properties: <pre>// create backup user
const backUpUser: BackUpUser = {
    _id: 2,
    email: 'rayon.backup@gmail.com',
    token: '123456',
    lastBackUp: new Date(),
    backUpLocation: '~/backup'
};</pre></li>
				<li>Console out your <code>superUser</code> and <code>backupUser</code> objects:<pre>// console out superUser props
console.log(superUser);
// console out backup user props
console.log(backUpUser);</pre><p>This will print the following output:</p><pre>{
  _id: 1,
  email: 'rayon.hunte@gmail.com',
  token: '12345',
  accessPages: [ 'profile', 'adminConsole', 'userReset' ],
  lastLogin: 2021-02-25T07:27:57.009Z
}
{
  _id: 2,
  email: 'rayon.backup@gmail.com',
  token: '123456',
  lastBackUp: 2021-02-25T07:27:57.009Z,
  backUpLocation: '~/backup'
}</pre></li>
			</ol>
			<p>In the preceding exercise, you built two user types using the <code>superUser</code> and <code>backupUser</code> intersections that are based on the <code>User</code>, <code>Admin</code>, and <code>Backup</code> types. The use of intersections allows you to keep your core user type simple and can therefore be used as a model for most of your user data. <code>Admin</code> and <code>Backup</code> are intersected with <code>User</code> only when it is necessary to model that specific user case. This is the separation of concerns. Now, any changes made to <code>User</code>, <code>Backup</code>, or <code>Admin</code> will be reflected in all child types. We will now take a look at union types, which is a type functionality. However, unlike intersections, union types provide an <code>OR</code> functionality when types are merged.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor163"/>Union Types</h1>
			<p><code>or</code> type functionality instead of an <code>and</code> type functionality, which was the case with intersection types. This works in a similar way to the ternary operator in JavaScript, where the types you are combining are separated by the <code>|</code> pipe. If this is confusing, it will all become clear as we move on to an example. We will also take a look at type guards, which is a pattern that will play a major role in the app use of union types. First, consider the following visual representation of a union type: </p>
			<div><div><img src="img/B14508_06_07.jpg" alt="Figure 6.7: Illustration of a union type assignment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Illustration of a union type assignment</p>
			<p>In the preceding diagram, we have a basic diagram of a union type assignment, where <code>Age</code> can be of the <code>number</code> or <code>string</code> datatypes. You can have union types with more than two options and non-primitive types. This gives you the option to write code that is more dynamic. In the upcoming example, we will extend our age example as mentioned previously and build a basic union type. </p>
			<p>Let's say you're working on an application that needs to validate someone's age. You want to write one function that will process ages from a database that are stored as a number and ages from the web frontend that come in as a string. In a case such as this, you might be tempted to use <code>any</code> as a type. However, unions allow us to address this kind of scenario without creating a vector for errors by using <code>any</code>:</p>
			<pre>Example03.ts
1 // basic union type
2 type Age =  number | string;
Link to the preceding example: <a href="https://packt.link/EHziL">https://packt.link/EHziL</a>.</pre>
			<p>First, we create a union type, <code>Age</code>, which can be of the <code>number</code> or <code>string</code> datatypes, as shown in the preceding syntax. We assign our <code>Age</code> alias to our types separated by a pipe, <code>|</code>. We could have more than two options, for example, <code>"number" | "string" | "object"</code>:</p>
			<p>Now we create a function that will make use of the new type, <code>Age</code>, as shown in the preceding snippet:</p>
			<pre>3  function myAge(age: Age): Age {
4      if (typeof age === "number") {
5          return `my age is ${age} and this a number`;
6      } else if (typeof age === "string"){
7          return `my age is ${age} and this a string`;
8      } else {
9          return `incorrect type" ${typeof(age)}`;
10     }
11 }</pre>
			<p>The <code>myAge</code> function takes the <code>Age</code> type as an argument and returns a formatted string of the <code>Age</code> type using an <code>if …else</code> loop. We are also making use of a type guard pattern, <code>typeof</code>, which allows you to check the type of your argument. This kind of type checking is necessary while using union types as your argument can be of several types, which, in the case of this preceding code snippet, is a string or a number. Each type will need to be processed with a different logic. </p>
			<p>Union types can also be objects; however, in such a case, <code>typeof</code> will not be very useful as it will only return the type, which will always be <code>object</code>. To resolve such cases, you can check for any unique properties of your object and apply your logic in this way. We will see examples of this as we work through our exercise in the next section.</p>
			<p>Now, let's get back to the example. To ensure that our functions are working as they should, we console out the results by calling them with different argument types (number and string):</p>
			<pre>console.log(myAge(45));
console.log(myAge("45"));</pre>
			<p>This will result in the following output:</p>
			<pre>my age is 45 and this a number
my age is 45 and this a string</pre>
			<p>Let's say that you passed an incorrect argument instead:</p>
			<pre>console.log(myAge(false));</pre>
			<p>You will see the following error message:</p>
			<pre>error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'Age'.</pre>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor164"/>Exercise 6.04: Updating the Products Inventory using an API</h2>
			<p>In the following exercise, we will extend our inventory management example from <em class="italic">Exercise 03</em> by adding an API. This will allow remote users to add and update products in our inventory via an API <code>PUT</code> or <code>POST</code> request. </p>
			<p>Since the processes of updating and adding a product are so similar, we will write one method to handle both requests and use a union type to allow our method to take both types and remain type safe. This will also mean that we can write less code and encapsulate all related code to the one method, which will make it easy for us or any other developer working on the application to find and resolve errors. </p>
			<p>You could use the <code>any</code> type, but then your code would become type insecure, which could lead to bugs and unstable code:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/Qvx6D">https://packt.link/Qvx6D</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <code>Exercise04.ts</code>.</li>
				<li>Create three types, <code>Product</code>, <code>Post</code>, and <code>Put</code>, along with the base objects you will require, as shown here:<pre>type Product = {
    name: string,
    price: number,
    amount: number,
}
type Post = {
    header: string,
    method: string,
    product: Product
}
type Put = {
    header: string,
    method: string,
    product: Product,
    productId: number
}</pre><p>We first create a product type that will help us to define what format the product data will take as part of a <code>Put</code> or <code>Post</code> request. We have also defined <code>Put</code> and <code>Post</code>, which differ slightly because a <code>Put</code> request will need to update a record that already exists. Note that <code>Put</code> has the property <code>productId</code>.  </p></li>
				<li>Create a union type, <code>SomeRequest</code>, which can be either the <code>Put</code> or <code>Post</code> type:   <pre>type SomeRequest =  Post | Put</pre><p>The data being matched to the union type can be any of the types in the union. Note that unions do not combine types; they simply try to match the data to one of the types in the union, which gives you, the developer, more flexibility.</p></li>
				<li>Create an instance of an array of the <code>Product</code> type:<pre>const products: Product[] = [];</pre></li>
				<li>Build a handler function that processes a request of the <code>SomeRequest</code> type:<pre>function ProcessRequest(request: SomeRequest ) {
    if ("productId" in request) { products.forEach(
            (p: Product, i: number) =&gt; {
               products[request.productId] = {
                   ...request.product
               };});        
    } else {
        products.push(request.product);
    }}</pre><p>This function will receive a request of the <code>Put</code> or <code>Post</code> type and add or update an attached product to the <code>products</code> array. In order to know whether it should update or add the function, it first checks whether the product has a <code>productId</code> argument.  If it does, we will loop through the <code>Products</code> array until we find a matching <code>productId</code> argument. Then, we use the spread operator to update the product data with the data from the request. If the product does not have a <code>productId</code> argument, we then just use the <code>push</code> function attached to the array to add the new product to the array.</p></li>
				<li>Declare <code>apple</code> and <code>mango</code> objects of the <code>Product</code> type, as shown here: <pre>const apple: Product = {
    name: "apple",
    price: 12345,
    amount: 10
}; 
const mango: Product = {
    name: "mango",
    price: 66666,
    amount: 15
};</pre><p>In a real API, the data would be provided by the user sending it via a request, but for the purposes of this exercise, we have hardcoded some data for you to work with.</p></li>
				<li>Declare <code>postAppleRequest</code> and <code>putMangoRequest</code> objects of the <code>Post</code> and <code>Put</code> types:<pre>const postAppleRequest : Post = {
    header: "zzzzz",
    method: 'new',
    product: apple,
};
const putMangoRequest : Put = {
    header:"ggggg",
    method: 'update',
    product: mango,
    productId: 2
};</pre><p>In the preceding code, we have defined our <code>POST</code> and <code>PUT</code> objects. We have attached the product object as a payload of the request. Remember that the function is not checking the product object but the request type, which will tell the function whether it's <code>POST</code> or <code>PUT</code>.</p></li>
				<li>Call the handler function and pass <code>postAppleRequest</code> and <code>putMangoRequest</code> as arguments, as shown in the following code snippet:   <pre>ProcessRequest(postAppleRequest);
ProcessRequest(putMangoRequest);</pre><p>In a normal API, when the user makes a <code>PUT</code> or <code>POST</code> request, the <code>ProcessRequest</code> method would be called. We are, however, just simulating an API and making the calls ourselves.</p></li>
				<li>Console out the results:<pre>console.log(products)</pre><p>You will see the following output:</p><pre>[
  { name: 'apple', price: 12345, amount: 10 },
  &lt;1 empty item&gt;,
  { name: 'mango', price: 66666, amount: 15 }
]</pre><p>In the preceding output, we can now see the products that we passed to our methods. This means that our simulated API code using unions works as intended. </p></li>
			</ol>
			<p>Union types, such as intersection types, give you, the developer, more functionality and flexibility when building your applications. In the preceding exercise, we were able to write a function that takes a single argument of two different types and applies logic based on type checking patterns or type guards. In the next section, we will continue the theme of more code flexibility with index types.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor165"/>Index Types</h1>
			<p>Index types allow us to create objects that have flexibility as regards the number of properties they may hold. Let's say you have a type that defines an error message, which can be more than one type, and you want the flexibility to add more types of messages over time. Because objects have a fixed number of properties, we would need to make changes to our message code whenever there was a new message type. Index types allow you to define a signature for your type using an interface, which gives you the ability to have a flexible number of properties. In the following example, we will expand on this in the code:</p>
			<pre>Example04.ts
1 interface ErrorMessage  {
2    // can only be string | number | symbol
3    [msg: number ]: string;
4     // you can add other properties once they are of the same type
5     apiId: number
6 }
Link to the preceding example: <a href="https://packt.link/IqpWH">https://packt.link/IqpWH</a></pre>
			<p>First, we create our type signature, as shown in the preceding snippet. Here we have a property name and type, which is the index <code>[msg: number]</code> followed by the value type. The name of the <code>msg</code> argument can be anything, but as a good coder, you should provide a name that makes sense in the context of the type. Note that your index can only be a number, string, or symbol. </p>
			<p>You can also add other properties to your index, but they must be the same type as the index, as shown in the preceding code snippet, <code>apiId: number</code>. Next, we make use of your type by casting it to <code>errorMessage</code>. We can now have an error message object with as many properties as we require. There is no need to modify the type as our list of messages grows. We maintain flexibility while keeping our code typed, thereby making it easy to scale and support:</p>
			<pre>7  // message object of Index type ErrorMessage
8  const errorMessage: ErrorMessage  = {
9       0: "system error",
10      1: "overload",
11      apiId: 12345
12 };</pre>
			<p>Now, we console out the new object just to make sure that everything works:</p>
			<pre>// console out object
console.log(
    errorMessage
);</pre>
			<p>You will get the following output once you run the file:</p>
			<pre>{ '0': 'system error', '1': 'overload', apiId: 12345 }</pre>
			<p>If we try to give a property name of an incorrect type, such as a string, we get the kind of error message you might expect: </p>
			<div><div><img src="img/B14508_06_08.jpg" alt="Figure 6.8: Output displaying the type error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Output displaying the type error</p>
			<p>You can, however, use strings that are numbers, for example, and the code will function as before and the output will be the same:</p>
			<pre>14 // message object of Index type ErrorMessage
15 const errorMessage: ErrorMessage  = {
16    '0': "system error",
17     1: "overload",
18    apiId: 12345 };</pre>
			<p>You may think that this will not work given that the value is a string, but it gets converted to a number literal. It will also work the other way around using a number literal that gets converted to a string. Next in our exercise, we will simulate the real-world usage of an index type, building a simple system to process error messages.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor166"/>Exercise 6.05: Displaying Error Messages</h2>
			<p>In this exercise, we will build a system to process error messages. We will also reuse the <code>ErrorMessage</code> index type we created in our example. The code in this exercise is somewhat contrived but will serve to help you get a better understanding of index types:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/ZkApY">https://packt.link/ZkApY</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <code>Exercise05.ts</code>.</li>
				<li>Create the <code>ErrorMessage</code> type interface from our example if you have not already done so:<pre>interface ErrorMessage  {
    // can only be string | number | symbol
    [msg: number ]: string;
    // you can add other properties once they are of the same type
    apiId: number
}</pre></li>
				<li>Build an <code>errorCodes</code> object as an <code>ErrorMessage</code> type, as shown here:<pre>const errorMessage : ErrorMessage = {
    400:"bad request",
    401:"unauthorized",
    403:"forbidden",  apiId: 123456,
 };</pre></li>
				<li>Create an error code array as <code>errorCodes</code>, as shown here:<pre>const errorCodes: number [] = [
    400,401,403
 ];</pre></li>
				<li>Loop through the <code>errorCodes</code> array and console out the error messages:<pre>errorCodes.forEach(
    (code: number) =&gt;  {
        console.log(
            errorMessage[code]
        );
    }
);</pre><p>Once you run the file, you will obtain the following output:</p><pre>bad request
unauthorized
forbidden</pre></li>
			</ol>
			<p>Index types allow you to have flexibility with your type definitions, as you can see in the preceding exercise. If you need to add new codes, you will not need to change your type definition; simply add the new code property to your <code>errorCode</code> object. Index types work here because even though the properties for the object are different, they all have the same basic makeup – a number property (key) followed by a string value. </p>
			<p>Now that you have the building blocks for advanced types, you can work through the following activities. The activities will make use of all the skills you have acquired in this chapter.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor167"/>Activity 6.01: Intersection Type</h2>
			<p>Imagine that you are a developer working on a truck builder feature for a custom truck website. You will need to make it possible for customers that come to the site to build a variety of truck types. To that end, you need to build your own intersection type, <code>PickUptruck</code>, by combining two types, <code>Motor</code> and <code>Truck</code>. You can then use your new type, <code>PickUpTruck</code>, with a function that returns the type and validates its input with the <code>PickUpTruck</code> intersection type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/n4tfL">https://packt.link/n4tfL</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Create a <code>Motor</code> type, which will house some common properties you may reuse on their own or in combination with other types to describe a vehicle object. You can use the following properties as a starting point: <code>color</code>, <code>doors</code>, <code>wheels</code>, and <code>fourWheelDrive</code>. </li>
				<li>Create a <code>Truck</code> type with properties common to a truck, for example, <code>doubleCab</code> and <code>winch</code>.</li>
				<li>Intersect the two types to create a <code>PickUpTruck</code> type.</li>
				<li>Build a <code>TruckBuilder</code> function that returns our <code>PickUpTruck</code> type and also takes <code>PickUpTruck</code> as an argument. </li>
				<li>Console out the function return.</li>
				<li>Once you complete the activity, you should obtain the following output:<pre>{
  color: 'red',
  doors: 4,
  doubleCab: true,
  wheels: 4,
  fourWheelDrive: true,
  winch: true
}</pre><p class="callout-heading">Note </p><p class="callout">The solution to this activity is presented via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor409">this link</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor168"/>Activity 6.02: Union Type</h2>
			<p>A logistics company has asked you to develop a feature on their website that will allow customers to choose the way they would like their packages to be shipped – via land or air. You have decided to use union types to achieve this. You can build your own union type called <code>ComboPack</code>, which can be either the <code>LandPack</code> or <code>AirPack</code> type. You can add any properties to your package types that you think will be common to a package. Also, consider using one type literal to identify your package as air or land, and a label property that will be optional. You will then need to construct a class to process your packages. Your class should have a method to identify your package type that takes arguments of the <code>ComboPack</code> type and uses your literal property to identify the package type and add the correct label, <code>air cargo</code> or <code>land cargo</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/GQ2ZS">https://packt.link/GQ2ZS</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Build a <code>LandPack</code> and an <code>AirPack</code> type. Make sure to have a literal to identify the package type.</li>
				<li>Construct a union type, <code>ComboPack</code>, which can be <code>LandPack</code> or <code>AirPack</code>.</li>
				<li>Make a <code>Shipping</code> class to process your packages. Make sure to use your literal to identify your package types and modify your package with the correct label for its type.</li>
				<li>Create two package objects of the <code>AirPack</code> and <code>LandPack</code> types.</li>
				<li>Instantiate your <code>Shipping</code> class, process your new objects, and console out the modified objects.<p class="callout-heading">Note </p><p class="callout">The solution to this activity is presented via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor411">this link</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor169"/>Activity 6.03: Index Type</h2>
			<p>Now that you have done such a good job of incorporating the shipping option into the website, the company now needs you to add a feature that will allow their customers to track the status of their packages. It is important to the client that they have the ability to add new package statuses as the company grows, and as shipping methods change, they would like that flexibility.</p>
			<p>Hence, you have decided to build an index type, <code>PackageStatus</code>, using an interface signature of the <code>status</code> property of the <code>string</code> type and a value of the <code>Boolean</code> type. You will then construct a <code>Package</code> type with some common package properties. You will also include a <code>packageStatus</code> property of the <code>PackageStatus</code> type. You will use <code>PackageStatus</code> to track three statuses of your package: <code>shipped</code>, <code>packed</code>, and <code>delivered</code>, set to <code>true</code> or <code>false</code>. You will then construct a class that takes an object of the <code>Package</code> type on initialization, contains a method that returns the <code>status</code> property, and a method that updates the <code>status</code> property, which takes <code>status</code> as a string and <code>Boolean</code> as a state. </p>
			<p>The method that updates your package should also return your <code>packageStatus</code> property.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/2LwHq">https://packt.link/2LwHq</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Build your <code>PackageStatus</code> index type using an interface with a property of <code>status</code> of the <code>string</code> type and a value of the <code>Boolean</code> type.</li>
				<li>Create a <code>Package</code> type that includes a property of the <code>PackageStatus</code> type and some common properties of a typical package.</li>
				<li>Make a class to process your <code>Package</code> type that takes the <code>Package</code> type on initialization, has a method to return your <code>packageStatus</code> property, and a method that updates and returns the <code>packageStatus</code> property.</li>
				<li>Create a <code>Package</code> object called <code>pack</code>.</li>
				<li>Instantiate your <code>PackageProcess</code> class with your new <code>pack</code> object.</li>
				<li>Console out your <code>pack</code> status.</li>
				<li>Update your <code>pack</code> status and console out your new <code>pack</code> status. <p>The expected output is as follows:</p><pre>{ shipped: false, packed: true, delivered: true }
{ shipped: true, packed: true, delivered: true }</pre><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor413">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we covered advanced types, which allow you to extend beyond your basic types. As applications become more complex and the frontend takes on more functionality, your data models will also become more complex. This chapter showed you how TypeScript advanced types give you the ability to implement strong typing, which will help you develop cleaner and more reliable applications. We covered the building blocks of advanced types – type aliases and literals, and we then moved on to intersection, union, and index types with some practical examples, exercises, and activities. </p>
			<p>You now have the ability to create complex types that will allow you to build types for modern applications and write code that is well supported and scalable. Having reached this point, you now have the tools to take on web frameworks, such as Angular2 and React. You can even use TypeScript on the server side with Node.js. There is much more to advanced types and the topic is quite vast, complex, and abstract in its implementations. However, here in this chapter, you have been equipped with the skills you need to start building applications with advanced types. </p>
		</div>
		<div><div></div>
		</div>
	</body></html>