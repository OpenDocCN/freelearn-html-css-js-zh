<html><head></head><body>
		<div>
			<div id="_idContainer080" class="Content">
			</div>
		</div>
		<div id="_idContainer081" class="Content">
			<h1 id="_idParaDest-122">6. <a id="_idTextAnchor155"/>Advanced Types</h1>
		</div>
		<div id="_idContainer090" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to advanced types. You will start with the building blocks of advanced types – type alias, string, and number literals. This will allow you to gain a better understanding as you take on more complex concepts such as union types. You will also learn how you can combine types to build more complex types, such as intersections. Using advanced types, this chapter teaches you how to write code that is easier to understand for yourself and any others working with you or who are inheriting the project. By the end of this chapter, you will be able to build advanced types by combining primitive types, such as strings, numbers, and Booleans, with objects.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor156"/>Introduction</h1>
			<p>In the previous chapter, we went over interfaces and inheritance. You saw how they allowed for the extension and modeling of your classes. Interfaces give your classes structure, and inheritance allows you to extend and build on your existing code. </p>
			<p>As web applications become more complex, it is necessary to be able to model that complexity, and TypeScript makes that easy with advanced types. Advanced types allow you to model the complex data you will be working with as a modern web developer. You will be able to take primitive types and make more complex types from them, creating types that are conditional and flexible. This will allow you to write code that is easy to understand and therefore easier to work with. As a working developer, you may come across a dataset provided by an API that you need to integrate into your application. These datasets can be complex. For example, Cloud Firestore from Google is a document-based, real-time database that can have objects nested within objects. With advanced types, you can create a type that is an exact representation of the data coming from the API. This will provide much more context to your code, which, in turn, will make it easier to work with for you and your team. You will also be able to stack complexity by building simpler types and stacking them to make more complex types.</p>
			<p>In this chapter, we will cover the building blocks of advanced types – type aliases and type literals. Once we learn how to build types, we will move on to more advanced concepts, including intersection, union, and index types. All these concepts will help you to learn how to use advanced types to add context and abstract complexity to code. </p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor157"/>Type Aliases</h1>
			<p><strong class="bold">Type Aliases</strong> allow you to declare references to any type – advanced or primitive. Aliases make our code easier to read by allowing us to be less verbose. Aliases allow you, the developer, to declare your type once and reuse it throughout your application. This makes working with complex types easier and your code more readable and maintainable.</p>
			<p>Let's say, for example, we are working on a social networking application and we needed to provide an administrator user type for users to manage the pages they created. Additionally, we also need to define a site administrator user. On a base level, they are both admins, and therefore the types would have some commonality between them. With a type alias, we could create an admin type as shown in <em class="italic">Figure 6.1</em>, with common properties an admin user would possess and build upon that admin when creating our site admin and user admin types. Aliases allow you to mask the complexity of your code, which will make it easier to understand. Here we have a diagram of an alias that assigns the <strong class="source-inline">Admin</strong> alias to an admin type, which is a complex <strong class="source-inline">type</strong> object. We also have an example of an alias, <strong class="source-inline">One</strong>, that is assigned to a type, <strong class="source-inline">number</strong>, which is a primitive type:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B14508_06_01.jpg" alt="Figure 6.1: Alias assigning a complex admin type alias&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Alias assigning a complex admin type alias</p>
			<p>Consider the following code snippet:</p>
			<p class="source-code">// primitive type assignment</p>
			<p class="source-code">type One = number;</p>
			<p>In the preceding example, we have created an alias, <strong class="source-inline">One</strong>, that can be used as a type for any number, as it is assigned to the type number.</p>
			<p>Now, consider the following code snippet:</p>
			<p class="source-code">// complex (object assignment)</p>
			<p class="source-code">type Admin = {</p>
			<p class="source-code">    username: string,</p>
			<p class="source-code">    email: string,</p>
			<p class="source-code">    userId: string,</p>
			<p class="source-code">    AllowedPages: string   </p>
			<p class="source-code">};</p>
			<p>Here, we have created an <strong class="source-inline">Admin</strong> alias, which we have assigned to an object that represents the common properties of a typical administrator, in the context of this example. As you can see, we have created a reference to a <strong class="source-inline">type</strong> object, which we can now use in our code instead of having to implement the object each time. </p>
			<p>As you can see in the preceding diagram and code snippet, type aliases work in a similar way to variable assignments, except a reference is created for a primitive type and/or an object. This reference can then be used as a template for your data. This will allow you to take advantage of all the benefits of a strongly typed language, such as code completion and data validation.</p>
			<p>Before we go into our first exercise on type aliases, we will look at some examples of primitive and complex assignments. </p>
			<p>Let's say you are working on a class method that takes numbers as arguments, and only numbers. You want to make sure that when your method is used, only numbers are passed as arguments and the right error messages are shown to the user if any other type is passed.</p>
			<p>First, we need to create a number type alias with the following syntax:</p>
			<p class="source-code">type OnlyNumbers = number;</p>
			<p>The <strong class="source-inline">type</strong> keyword is followed by the alias, <strong class="source-inline">OnlyNumbers</strong>, and then the <strong class="source-inline">number</strong> type.</p>
			<p>Now we can build a class with a method that only takes numbers as an argument and use the type alias to enforce our rule:</p>
			<p class="source-code">// instance of numbers only class</p>
			<p class="source-code">class NumbersOnly {</p>
			<p class="source-code">    count: number</p>
			<p class="source-code">    SetNumber(someNumber: OnlyNumbers) {</p>
			<p class="source-code">        this.count = someNumber</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, let's instance our class and pass some arguments to our method to see whether our code works. </p>
			<p>For this example, let's try and assign a string as the argument type:</p>
			<p class="source-code">// class instance</p>
			<p class="source-code">const onlyNumbers = new NumbersOnly;</p>
			<p class="source-code">// method with incorrect arguments</p>
			<p class="source-code">onlyNumbers.SetNumber("15");</p>
			<p>In the preceding code snippet, we have provided the wrong argument of the <strong class="source-inline">string</strong> type and this will result in a warning because our method, <strong class="source-inline">SetNumber</strong>, is expecting a number. Also, by providing your type aliases with meaningful names such as <strong class="source-inline">onlyNumbers</strong>, you can make your code easier to read and debug. For this example, the section of the code with the problem is highlighted, and when you hover over the error, you get a very helpful error message telling you what the issue is and how it can be resolved:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B14508_06_02.jpg" alt="Figure 6.2: Error message in VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Error message in VS Code</p>
			<p>This is the case provided that you have the correct support from your IDE. If you don't have IDE support, you will be shown an error message at code compilation.</p>
			<p>This is a simple use case, but as your applications become larger, some time has passed, or you are working in a large team, this kind of type security is vital to writing code that is free of mistakes.</p>
			<p>Let's consider another example: Say you are working on an online store application and you need to use a product class that was not created by you. If the person who created the class made use of types and used descriptive names, it would be easier for you to work with that code. </p>
			<p>Now, let's edit the first example with the correct argument type:</p>
			<p class="source-code">// method with correct arguments</p>
			<p class="source-code">onlyNumbers.SetNumber(15);</p>
			<p>In the preceding code snippet, we have provided the correct argument type of <strong class="source-inline">number</strong> and your class method takes the argument with no issues. </p>
			<p>Now, let's consider a complex alias assignment. </p>
			<p>For example, we want to create a new function that takes a user object as a type argument. We could define the object as the function argument inline, as shown here:</p>
			<p class="source-code">// function and type definition  </p>
			<p class="source-code">function badCode(user: {</p>
			<p class="source-code">    email: string,</p>
			<p class="source-code">    userName: string,</p>
			<p class="source-code">    token: string, </p>
			<p class="source-code">    lastLogin: number</p>
			<p class="source-code">}) {}</p>
			<p>In the preceding snippet, the code creates a function that takes a user as an argument, but the type is defined in the function itself. While this would work, let's say you were using the object in a few places in your code, then, you would have to define this object each time. This is very inefficient and, as a good developer, you don't want to repeat code. This way of working will also lead to errors; it will make your code harder to work with and update as every instance of the <strong class="source-inline">User</strong> type will need to be changed throughout your code. Type aliases resolve this by allowing you to define your type once, as we will demonstrate in the following code snippet.</p>
			<p>In much the same way as we have defined our primitive type, we have defined our <strong class="source-inline">User</strong> type. We use the <strong class="source-inline">type</strong> keyword, but now we have mapped to an object that is a template of our <strong class="source-inline">User</strong> type. We can now use the <strong class="source-inline">User</strong> alias, rather than having to redeclare the object every time we need to define the <strong class="source-inline">User</strong> type:</p>
			<p class="source-code">// object / complex type User</p>
			<p class="source-code">type User = {</p>
			<p class="source-code">    email: string,</p>
			<p class="source-code">    userName: string,</p>
			<p class="source-code">    token: string, </p>
			<p class="source-code">    lastLogin: number</p>
			<p class="source-code">};</p>
			<p>As you can see, we have created a type with the alias <strong class="source-inline">User</strong>. This allows you to make a single reference to this object type and reuse it throughout your code. If we did not do this, we would have to reference the type directly. </p>
			<p>Now you can build a new function using your <strong class="source-inline">User</strong> type:</p>
			<p class="source-code">// function with type alias</p>
			<p class="source-code">function goodCode(user: User){}</p>
			<p>As you can see, this code is much less verbose and easy to understand. All your code regarding the <strong class="source-inline">User</strong> type is in one location, and when changes are made to the object, all aliases are updated. In the following exercise, you will implement what we have covered so far to build your own type alias.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor158"/>Exercise 6.01: Implementing a Type Alias</h2>
			<p>In this exercise, we will use our knowledge of types to build a function that creates products. Let's say, for example, you are working on a shopping application and when the inventory manager adds a product to the inventory, you need to push that product to your array of products. This exercise demonstrates a few ways in which type aliases can be useful by allowing you to define your <strong class="source-inline">Product</strong> model once and reuse it throughout your code. </p>
			<p>Now, in an actual inventory management application, you might have a frontend page that allows a user to input the product name and supporting information manually. For the purpose of this exercise, let's assume the products you want to add are named <strong class="source-inline">Product_0</strong> through to <strong class="source-inline">Product_5</strong> and all have a price of 100, while the number of each of these products added to the inventory is 15.</p>
			<p>This may not be truly reflective of an actual scenario in an inventory management application, but remember, our key goal is to use a type alias. So for now, a simple <strong class="source-inline">for</strong> loop to complete the aforementioned tasks will suffice:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All files in this chapter can be executed by running <strong class="source-inline">npx ts-node filename.ts</strong> on the terminal. The code file for this exercise can be found here: <a href="https://packt.link/EAiHb">https://packt.link/EAiHb</a>.</p>
			<ol>
				<li>Open VS Code and create a new file named <strong class="source-inline">Exercise01.ts</strong>.</li>
				<li>Create a primitive type alias, <strong class="source-inline">Count</strong>, that is of the <strong class="source-inline">number</strong> type. <strong class="source-inline">Count</strong> will be used to keep track of the number of products:<p class="source-code">//primitive type</p><p class="source-code">type Count = number;</p></li>
				<li>Create an object type alias, <strong class="source-inline">Product</strong>, that is of the <strong class="source-inline">type</strong> object. Re-use <strong class="source-inline">Count</strong> to define the count of the product. The <strong class="source-inline">Product</strong> type alias will be used to define every product we add to our inventory. The properties are common across all products:<p class="source-code">// object type </p><p class="source-code">type Product = {</p><p class="source-code">    name: string,</p><p class="source-code">    count: Count, //reuse Count</p><p class="source-code">    price: number,</p><p class="source-code">    amount:number,</p><p class="source-code">}</p></li>
				<li>Declare a <strong class="source-inline">products</strong> variable of the <strong class="source-inline">Product</strong> type array:<p class="source-code">// product array</p><p class="source-code">const products_list: Product[] = [];</p><p>In order for us to make use of the <strong class="source-inline">Product</strong> type, it was first assigned to a variable in the preceding code, and the <strong class="source-inline">product_list</strong> variable is an array of objects of the <strong class="source-inline">Product</strong> type.</p></li>
				<li>Create a function that adds products to the array. Re-use the <strong class="source-inline">Product</strong> type alias to validate the argument input:<p class="source-code">// add products to product array function</p><p class="source-code">function makeProduct(p : Product ) {</p><p class="source-code">    products_list.push(p); // add product to end of array</p><p class="source-code">}</p></li>
				<li>Use a <strong class="source-inline">for</strong> loop to create product objects of the <strong class="source-inline">Product</strong> type and add them to the <strong class="source-inline">products</strong> array:<p class="source-code">// use a for loop to create 5 products</p><p class="source-code">for (let index = 0; index &lt; 5; index++) {</p><p class="source-code">    let p : Product = {</p><p class="source-code">        name: "Product"+"_"+`${index}`,</p><p class="source-code">        count: index,</p><p class="source-code">        price: 100,</p><p class="source-code">        amount: 15</p><p class="source-code">    }//make product</p><p class="source-code">    makeProduct(p);</p><p class="source-code">}</p><p class="source-code">console.log(products_list);</p></li>
				<li>Compile and run the program by executing <strong class="source-inline">npx ts-node Exercise01.ts</strong> in the correct directory in which this file is present. You should obtain the following output:<p class="source-code"> [</p><p class="source-code">  { name: 'Product_0', count: 0, price: 100, amount: 15 },</p><p class="source-code">  { name: 'Product_1', count: 1, price: 100, amount: 15 },</p><p class="source-code">  { name: 'Product_2', count: 2, price: 100, amount: 15 },</p><p class="source-code">  { name: 'Product_3', count: 3, price: 100, amount: 15 },</p><p class="source-code">  { name: 'Product_4', count: 4, price: 100, amount: 15 }</p><p class="source-code">]</p></li>
			</ol>
			<p>In this exercise, you created two type aliases, which in turn created references to your actual types.</p>
			<p>This allowed you to reduce complexity and make your code more readable, as now you can provide names that have additional context with descriptive names such as <strong class="source-inline">Product</strong> and <strong class="source-inline">products_list</strong>. If we were to write this code without the use of aliases, at every place where you used your aliases in the exercise, you would have to define the object or the type directly. This might not be much of an issue here with this simple function, but keep in mind how much more code you would need to build a class or a major project.</p>
			<p>As we proceed to more complex type structures, this knowledge will become invaluable. We will continue to build on our knowledge in the next section as we cover type literals. </p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor159"/>Type Literals</h1>
			<p><strong class="bold">Type literals</strong> allow you to create a type based on a specific string or number. This, in itself, is not very useful, but as we move on to more complex types such as union types, their use will become apparent. Literals are straightforward, so we will not spend a lot of time on them but you will need to understand the concept of literals as we move into the next phase.</p>
			<p>Let's start by creating our string and number literals. </p>
			<p>We will begin with a string literal:</p>
			<p><strong class="bold">Example01.ts</strong></p>
			<p class="source-code">1 // string literal  </p>
			<p class="source-code">2 type Yes = "yes";</p>
			<p class="source-code-link">Link to the preceding example: <a href="https://packt.link/96IlD">https://packt.link/96IlD</a>. </p>
			<p>The preceding code creates a <strong class="source-inline">Yes</strong> type that will take only a specific string, <strong class="source-inline">"yes"</strong>, as the input.</p>
			<p>Similarly, we can create a number literal:</p>
			<p class="source-code">3 // number literal</p>
			<p class="source-code">4 type One = 1;</p>
			<p>Here, we create a number literal type, <strong class="source-inline">One</strong>, that will only take <strong class="source-inline">1</strong> as the input.</p>
			<p>The basic syntax as observed in the preceding examples is quite simple. We start with the <strong class="source-inline">type</strong> keyword, followed by the name (alias) of our new literal, and then the literal itself, as shown in the preceding syntax. We now have a type of the <strong class="source-inline">yes</strong> string and the number <strong class="source-inline">1</strong>.</p>
			<p>Next, we will build a function that will make use of our new types:</p>
			<p class="source-code">5 // process my literal </p>
			<p class="source-code">6 function yesOne(yes: Yes, one: One ) {</p>
			<p class="source-code">7     console.log(yes, one);</p>
			<p class="source-code">8 }</p>
			<p>We have cast our function arguments to our literal types, and because our types are literal, only the "<strong class="source-inline">yes</strong>" string or the number <strong class="source-inline">1</strong> will be accepted as arguments. Our function will not take other arguments. Let's say we passed <strong class="source-inline">""</strong> and <strong class="source-inline">2</strong> as arguments (<strong class="source-inline">yesOne("", 2)</strong>). You will notice the following warning in VS Code:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B14508_06_03.jpg" alt="Figure 6.3: IDE warning when incorrect arguments are passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: IDE warning when incorrect arguments are passed</p>
			<p>Now, let's say we passed <strong class="source-inline">"yes"</strong> and <strong class="source-inline">2</strong> as arguments. Again, you will get the following warning:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B14508_06_04.jpg" alt="Figure 6.4: Errors displayed when a parameter that cannot be assigned is passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Errors displayed when a parameter that cannot be assigned is passed</p>
			<p>The preceding are some examples of error messages you might expect if you provide the wrong arguments. The error messages are clear and tell you precisely what you need to do to resolve the error. As you can see, even though we are passing a string and a number, we still get a type error. This happens because these arguments are literal; they can only match themselves exactly.</p>
			<p>Now, let's try and pass the correct arguments:</p>
			<p class="source-code">9 // function with the correct arguments </p>
			<p class="source-code">10 yesOne("yes", 1);</p>
			<p>Once provided with the correct arguments, the function can be called without any issue, as shown in the following output:</p>
			<p class="source-code">yes 1</p>
			<p>Before we move on to intersection types, let's quickly complete a simple exercise to cement our knowledge of string and number literals.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor160"/>Exercise 6.02: Type Literals</h2>
			<p>Now that we have a better understanding of literals, let's go through a small exercise to reinforce what we have covered. Here we will create a function that takes a string literal and returns a number literal:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/hHgNa">https://packt.link/hHgNa</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <strong class="source-inline">Exercise02.ts</strong>.</li>
				<li>Create a string literal type, <strong class="source-inline">No</strong>, and assign the string <strong class="source-inline">"no"</strong> as the value. Also, create a number literal and assign 0 as the value:<p class="source-code">type No = "no"</p><p class="source-code">type Zero = 0</p></li>
				<li>Build a function that takes the "<strong class="source-inline">No</strong>" literal and prints it to the console: <p class="source-code">function onlyNo(no: No):Zero {</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
				<li>Console out the function call results:<p class="source-code">console.log(</p><p class="source-code">    onlyNo("no")</p><p class="source-code">)</p><p>This will result in the following output:</p><p class="source-code">0</p></li>
			</ol>
			<p>Literals by themselves are not very useful, but when used in combination with more complex types, their usefulness will become apparent. For now, you need to understand how to create literals, so you can make use of them later in this chapter. In the next section, we move on to intersection types. All the work that we have completed so far will help as we make use of type aliases and literals.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor161"/>Intersection Types</h1>
			<p><strong class="bold">Intersection Types</strong> allow you to combine types to form a new type with the properties of the combined types. This is useful in cases where you have an existing type that does not, by itself, address some data you need to define, but it can do so in combination with another existing type. This is similar to multi-class inheritance, as the child object can have more than one parent object that it derives its properties from. </p>
			<p>Let's say you have a type <strong class="source-inline">A</strong> with a name and age property. You also have a type <strong class="source-inline">B</strong> with a height and weight property. In your application, you find that there is a need for a person type: you want to track the user's name, age, height, and weight. You can intersect type <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> to form a <strong class="source-inline">Person</strong> type. Why not just create a new type you ask? Well, this takes us back to wanting to be good coders and good coders stay DRY – Don't Repeat Yourself. Unless a type is truly unique in your application, you should reuse as much code as possible. Also, there is centralization. </p>
			<p>If you need to make changes to any of the type code for <strong class="source-inline">Person</strong>, you just need to make the changes in <strong class="source-inline">A</strong> or <strong class="source-inline">B</strong>. This is also a bit limiting as there may be cases where type <strong class="source-inline">A</strong> is used by more than one object, and if you make changes, it will break the application. With intersection, you can simply create a type <strong class="source-inline">C</strong> with the changes and update your <strong class="source-inline">Person</strong> type. You can also merge types with common properties. </p>
			<p>Consider a situation where you have a <strong class="source-inline">name</strong> property in <strong class="source-inline">A</strong> and also in <strong class="source-inline">B</strong>. When the types are intersected, you would now have just one <strong class="source-inline">name</strong> property; however, the merged properties must not only be the same in name, but should also be of the same type, otherwise the types will not merge and will result in errors. </p>
			<p>If this is not clear, let's look at a property, <strong class="source-inline">age</strong>. This can be a number in one type and a string in another. The only way you could intersect these types would be to make the properties common, as either would need to be a string or number.</p>
			<p>Imagine that as part of an e-commerce project, you are required to build a shopping cart object that derives its properties from a <strong class="source-inline">Product</strong> object and an <strong class="source-inline">Order</strong> object.</p>
			<p>The following diagram shows the basic properties of each object and the properties of the new <strong class="source-inline">Cart</strong> object that is formed using the <strong class="source-inline">Product</strong> and <strong class="source-inline">Order</strong> objects:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B14508_06_05.jpg" alt="Figure 6.5: Diagram showing the properties of the Cart object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Diagram showing the properties of the Cart object</p>
			<p>In the diagram, we have our parent objects, <strong class="source-inline">Product</strong> and <strong class="source-inline">Order</strong>, that combine to form a child object, <strong class="source-inline">Cart</strong>, with all the properties of its parent objects. Please note that we can have more than two parents in an intersection, but for the sake of this explanation, we will stick to two, as this will allow you to grasp the concept faster. In the upcoming example, we will walk through the process of creating our new <strong class="source-inline">Cart</strong> type in code and a basic use case.</p>
			<p>Imagine you are working on the shopping application. You need to create an object to model the product data you will push to the cart for checking out. We already have a <strong class="source-inline">Product</strong> type for our product data. The <strong class="source-inline">Product</strong> type has most of what we need to display correct information pertaining to our products on the web page. However, we are missing a few things we require when checking a product out. We will address this not by creating a new type of product, but we will create an <strong class="source-inline">Order</strong> type with just the properties we need: <strong class="source-inline">orderId</strong>, <strong class="source-inline">amount</strong>, and <strong class="source-inline">discount</strong>, the last of which is optional as it will not always apply. </p>
			<p>Here is the code for declaration of the <strong class="source-inline">Product</strong> type: </p>
			<p class="source-code-heading">Example02.ts</p>
			<p class="source-code">1 // product type</p>
			<p class="source-code">2 type Product = {</p>
			<p class="source-code">3     name: string, </p>
			<p class="source-code">4     price: number,</p>
			<p class="source-code">5     description: string</p>
			<p class="source-code">6 } </p>
			<p class="source-code">7 </p>
			<p class="source-code">8 // order type</p>
			<p class="source-code">9 type Order = {</p>
			<p class="source-code">10     orderId: string,</p>
			<p class="source-code">11     amount: number,</p>
			<p class="source-code">12     discount?: number </p>
			<p class="source-code">13 }</p>
			<p class="source-code-link">Link to the preceding example: <a href="https://packt.link/DZ7Iz">https://packt.link/DZ7Iz</a></p>
			<p>In the preceding code snippet, we have created our parent types names <strong class="source-inline">Product</strong> and <strong class="source-inline">Order</strong>. Now we need to merge them. This will create the type we need to model our cart data:</p>
			<p class="source-code">14 // Alias Cart of Product intersect Order</p>
			<p class="source-code">15 type Cart = Product &amp; Order;</p>
			<p>We build our cart object by assigning an alias, <strong class="source-inline">Cart</strong>, to our <strong class="source-inline">Product</strong> and <strong class="source-inline">Order</strong> types and using <strong class="source-inline">&amp;</strong> between our two types, as shown in the preceding snippet. We now have a new merged type, <strong class="source-inline">Cart</strong>, that we can use to model our cart data:</p>
			<p class="source-code">16 // cart of type Cart</p>
			<p class="source-code">17 const cart: Cart = {</p>
			<p class="source-code">18     name: "Mango",</p>
			<p class="source-code">19     price: 400,</p>
			<p class="source-code">20     orderId: "x123456",</p>
			<p class="source-code">21     amount: 4,</p>
			<p class="source-code">22     description: "big sweet, full of sugar !!!" </p>
			<p class="source-code">23 }</p>
			<p>The preceding is an example of a cart object declared using the <strong class="source-inline">Cart</strong> type. As you can see, we have access to all our properties and can omit optional ones that may not always apply, such as <strong class="source-inline">discount</strong>. </p>
			<p>If we do not provide all the required properties, the IDE gives a very helpful error message telling us just what we need to do in order to fix the issue:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B14508_06_06.jpg" alt="Figure 6.6: The error message displayed when missing required properties&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: The error message displayed when missing required properties</p>
			<p>Now, let's console out our new cart object: This will display the following output:</p>
			<p class="source-code">{</p>
			<p class="source-code">  name: 'Mango',</p>
			<p class="source-code">  price: 400,</p>
			<p class="source-code">  orderId: 'x123456',</p>
			<p class="source-code">  amount: 4,</p>
			<p class="source-code">  description: 'big, sweet, and full of sugar !!!'</p>
			<p class="source-code">}</p>
			<p>In the next section, you will get some hands-on experience in terms of creating intersection types by performing an exercise in which you will build a prototype user management system.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor162"/>Exercise 6.03: Creating Intersection Types</h2>
			<p>You are working on an e-commerce application; you have been assigned the task of building out the user management system. In the application requirements, the customer has listed the types of user profiles they expect will interact with the system. You will use type intersection to build out your user types. This will allow you to build simple types that can be combined to make more complex types and separate your concerns. This will result in code that is less error-prone and better supported. Here, we name the user types we will build and provide an overview of their functions:</p>
			<ul>
				<li><strong class="bold">Basic user</strong>: This user will have the properties <strong class="source-inline">_id</strong>, <strong class="source-inline">email</strong>, and <strong class="source-inline">token</strong>.</li>
				<li><strong class="bold">Admin user</strong>: This user will have the ability to access pages not accessible to a normal user. This user will have the properties <strong class="source-inline">accessPages</strong> and <strong class="source-inline">lastLogin</strong>. <strong class="source-inline">accessPages</strong> is a string array of pages that this user can access, while <strong class="source-inline">lastLogin</strong> will help us to log the activates of the Admin user.</li>
				<li><strong class="bold">Backup user</strong>: This user has the job of backing up the system and the user properties of <strong class="source-inline">lastBackUp</strong> and <strong class="source-inline">backUpLocation</strong>. <strong class="source-inline">lastBackUp</strong> will let us know what time the system was last backed up, while <strong class="source-inline">backUpLocation</strong> will tell us where the backup files are stored.</li>
				<li><strong class="bold">superUser</strong>: This user is an intersection of the Admin and User types. All users require the properties of a Basic user, but only Admin users require Admin properties. Here, we use type intersection to build the necessary properties we need.</li>
				<li><strong class="bold">BackUpUser</strong>: This user is an intersection of the <strong class="source-inline">Backup</strong> user and <strong class="source-inline">Basic</strong> user types. Once again, we can incorporate into our basic user the necessary complexity this user type requires in order to function.<p class="callout-heading">Note</p><p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/FVvj5">https://packt.link/FVvj5</a>.</p></li>
			</ul>
			<ol>
				<li value="1">Open VS Code and create a new file named <strong class="source-inline">Exercise03.ts</strong>.</li>
				<li>Create a basic <strong class="source-inline">User</strong> type:<p class="source-code">// create user object type</p><p class="source-code">type User = {</p><p class="source-code">    _id: number;</p><p class="source-code">    email: string;</p><p class="source-code">    token: string;</p><p class="source-code">}</p><p>This will be the type we will use as our base for the other user types in our application. Thus, it has all the common user properties that all users will require.</p></li>
				<li>Create an <strong class="source-inline">Admin</strong> user type for users who need to perform the functions of an administrator:<p class="source-code">// create an admin object type</p><p class="source-code">type Admin = {</p><p class="source-code">    accessPages: string[],</p><p class="source-code">    lastLogin: Date</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Backup</strong> user type for users who are responsible for backing up the application data:<p class="source-code">// create backupUser object type</p><p class="source-code">type Backup = {</p><p class="source-code">    lastBackUp: Date,</p><p class="source-code">    backUpLocation: string</p><p class="source-code">}</p></li>
				<li>Using your <strong class="source-inline">User</strong> and <strong class="source-inline">Admin</strong> types, declare a <strong class="source-inline">superuser</strong> object of the <strong class="source-inline">User</strong> type at the <strong class="source-inline">Admin</strong> intersect. Add the required properties. In order to create a superuser, you will have to provide values for the properties of <strong class="source-inline">User</strong> and <strong class="source-inline">Admin</strong>, as shown in the following code block: <p class="source-code">// combine user and admin to create the user object</p><p class="source-code">const superUser: User &amp; Admin = {</p><p class="source-code">    _id: 1,</p><p class="source-code">    email: 'rayon.hunte@gmail.com',</p><p class="source-code">    token: '12345',</p><p class="source-code">    accessPages: [</p><p class="source-code">        'profile', 'adminConsole', 'userReset'</p><p class="source-code">    ],</p><p class="source-code">    lastLogin: new Date() </p><p class="source-code">}; </p><p>In an actual application, this code may be in a login function and the values returned might be from an API on login.</p></li>
				<li>Build a <strong class="source-inline">BackUpUser</strong> type by assigning the alias <strong class="source-inline">BackUpUser</strong> to the intersection of <strong class="source-inline">User</strong> and <strong class="source-inline">Backup</strong>:<p class="source-code">// create BackUpUser type</p><p class="source-code">type BackUpUser = User &amp; Backup</p></li>
				<li>Declare a <strong class="source-inline">backUpUser</strong> object of the <strong class="source-inline">BackUpUser</strong> type and add the requisite properties: <p class="source-code">// create backup user</p><p class="source-code">const backUpUser: BackUpUser = {</p><p class="source-code">    _id: 2,</p><p class="source-code">    email: 'rayon.backup@gmail.com',</p><p class="source-code">    token: '123456',</p><p class="source-code">    lastBackUp: new Date(),</p><p class="source-code">    backUpLocation: '~/backup'</p><p class="source-code">};</p></li>
				<li>Console out your <strong class="source-inline">superUser</strong> and <strong class="source-inline">backupUser</strong> objects:<p class="source-code">// console out superUser props</p><p class="source-code">console.log(superUser);</p><p class="source-code">// console out backup user props</p><p class="source-code">console.log(backUpUser);</p><p>This will print the following output:</p><p class="source-code">{</p><p class="source-code">  _id: 1,</p><p class="source-code">  email: 'rayon.hunte@gmail.com',</p><p class="source-code">  token: '12345',</p><p class="source-code">  accessPages: [ 'profile', 'adminConsole', 'userReset' ],</p><p class="source-code">  lastLogin: 2021-02-25T07:27:57.009Z</p><p class="source-code">}</p><p class="source-code">{</p><p class="source-code">  _id: 2,</p><p class="source-code">  email: 'rayon.backup@gmail.com',</p><p class="source-code">  token: '123456',</p><p class="source-code">  lastBackUp: 2021-02-25T07:27:57.009Z,</p><p class="source-code">  backUpLocation: '~/backup'</p><p class="source-code">}</p></li>
			</ol>
			<p>In the preceding exercise, you built two user types using the <strong class="source-inline">superUser</strong> and <strong class="source-inline">backupUser</strong> intersections that are based on the <strong class="source-inline">User</strong>, <strong class="source-inline">Admin</strong>, and <strong class="source-inline">Backup</strong> types. The use of intersections allows you to keep your core user type simple and can therefore be used as a model for most of your user data. <strong class="source-inline">Admin</strong> and <strong class="source-inline">Backup</strong> are intersected with <strong class="source-inline">User</strong> only when it is necessary to model that specific user case. This is the separation of concerns. Now, any changes made to <strong class="source-inline">User</strong>, <strong class="source-inline">Backup</strong>, or <strong class="source-inline">Admin</strong> will be reflected in all child types. We will now take a look at union types, which is a type functionality. However, unlike intersections, union types provide an <strong class="source-inline">OR</strong> functionality when types are merged.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor163"/>Union Types</h1>
			<p><strong class="bold">Union Types</strong> are similar to intersections as they are a combination of types to form a single type. Union types differ, however, in that they do not merge your types but provide <strong class="source-inline">or</strong> type functionality instead of an <strong class="source-inline">and</strong> type functionality, which was the case with intersection types. This works in a similar way to the ternary operator in JavaScript, where the types you are combining are separated by the <strong class="source-inline">|</strong> pipe. If this is confusing, it will all become clear as we move on to an example. We will also take a look at type guards, which is a pattern that will play a major role in the app use of union types. First, consider the following visual representation of a union type: </p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B14508_06_07.jpg" alt="Figure 6.7: Illustration of a union type assignment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Illustration of a union type assignment</p>
			<p>In the preceding diagram, we have a basic diagram of a union type assignment, where <strong class="source-inline">Age</strong> can be of the <strong class="source-inline">number</strong> or <strong class="source-inline">string</strong> datatypes. You can have union types with more than two options and non-primitive types. This gives you the option to write code that is more dynamic. In the upcoming example, we will extend our age example as mentioned previously and build a basic union type. </p>
			<p>Let's say you're working on an application that needs to validate someone's age. You want to write one function that will process ages from a database that are stored as a number and ages from the web frontend that come in as a string. In a case such as this, you might be tempted to use <strong class="source-inline">any</strong> as a type. However, unions allow us to address this kind of scenario without creating a vector for errors by using <strong class="source-inline">any</strong>:</p>
			<p class="source-code-heading">Example03.ts</p>
			<p class="source-code">1 // basic union type</p>
			<p class="source-code">2 type Age =  number | string;</p>
			<p class="source-code-link">Link to the preceding example: <a href="https://packt.link/EHziL">https://packt.link/EHziL</a>.</p>
			<p>First, we create a union type, <strong class="source-inline">Age</strong>, which can be of the <strong class="source-inline">number</strong> or <strong class="source-inline">string</strong> datatypes, as shown in the preceding syntax. We assign our <strong class="source-inline">Age</strong> alias to our types separated by a pipe, <strong class="source-inline">|</strong>. We could have more than two options, for example, <strong class="source-inline">"number" | "string" | "object"</strong>:</p>
			<p>Now we create a function that will make use of the new type, <strong class="source-inline">Age</strong>, as shown in the preceding snippet:</p>
			<p class="source-code">3  function myAge(age: Age): Age {</p>
			<p class="source-code">4      if (typeof age === "number") {</p>
			<p class="source-code">5          return `my age is ${age} and this a number`;</p>
			<p class="source-code">6      } else if (typeof age === "string"){</p>
			<p class="source-code">7          return `my age is ${age} and this a string`;</p>
			<p class="source-code">8      } else {</p>
			<p class="source-code">9          return `incorrect type" ${typeof(age)}`;</p>
			<p class="source-code">10     }</p>
			<p class="source-code">11 }</p>
			<p>The <strong class="source-inline">myAge</strong> function takes the <strong class="source-inline">Age</strong> type as an argument and returns a formatted string of the <strong class="source-inline">Age</strong> type using an <strong class="source-inline">if …else</strong> loop. We are also making use of a type guard pattern, <strong class="source-inline">typeof</strong>, which allows you to check the type of your argument. This kind of type checking is necessary while using union types as your argument can be of several types, which, in the case of this preceding code snippet, is a string or a number. Each type will need to be processed with a different logic. </p>
			<p>Union types can also be objects; however, in such a case, <strong class="source-inline">typeof</strong> will not be very useful as it will only return the type, which will always be <strong class="source-inline">object</strong>. To resolve such cases, you can check for any unique properties of your object and apply your logic in this way. We will see examples of this as we work through our exercise in the next section.</p>
			<p>Now, let's get back to the example. To ensure that our functions are working as they should, we console out the results by calling them with different argument types (number and string):</p>
			<p class="source-code">console.log(myAge(45));</p>
			<p class="source-code">console.log(myAge("45"));</p>
			<p>This will result in the following output:</p>
			<p class="source-code">my age is 45 and this a number</p>
			<p class="source-code">my age is 45 and this a string</p>
			<p>Let's say that you passed an incorrect argument instead:</p>
			<p class="source-code">console.log(myAge(false));</p>
			<p>You will see the following error message:</p>
			<p class="source-code">error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'Age'.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor164"/>Exercise 6.04: Updating the Products Inventory using an API</h2>
			<p>In the following exercise, we will extend our inventory management example from <em class="italic">Exercise 03</em> by adding an API. This will allow remote users to add and update products in our inventory via an API <strong class="source-inline">PUT</strong> or <strong class="source-inline">POST</strong> request. </p>
			<p>Since the processes of updating and adding a product are so similar, we will write one method to handle both requests and use a union type to allow our method to take both types and remain type safe. This will also mean that we can write less code and encapsulate all related code to the one method, which will make it easy for us or any other developer working on the application to find and resolve errors. </p>
			<p>You could use the <strong class="source-inline">any</strong> type, but then your code would become type insecure, which could lead to bugs and unstable code:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/Qvx6D">https://packt.link/Qvx6D</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <strong class="source-inline">Exercise04.ts</strong>.</li>
				<li>Create three types, <strong class="source-inline">Product</strong>, <strong class="source-inline">Post</strong>, and <strong class="source-inline">Put</strong>, along with the base objects you will require, as shown here:<p class="source-code">type Product = {</p><p class="source-code">    name: string,</p><p class="source-code">    price: number,</p><p class="source-code">    amount: number,</p><p class="source-code">}</p><p class="source-code">type Post = {</p><p class="source-code">    header: string,</p><p class="source-code">    method: string,</p><p class="source-code">    product: Product</p><p class="source-code">}</p><p class="source-code">type Put = {</p><p class="source-code">    header: string,</p><p class="source-code">    method: string,</p><p class="source-code">    product: Product,</p><p class="source-code">    productId: number</p><p class="source-code">}</p><p>We first create a product type that will help us to define what format the product data will take as part of a <strong class="source-inline">Put</strong> or <strong class="source-inline">Post</strong> request. We have also defined <strong class="source-inline">Put</strong> and <strong class="source-inline">Post</strong>, which differ slightly because a <strong class="source-inline">Put</strong> request will need to update a record that already exists. Note that <strong class="source-inline">Put</strong> has the property <strong class="source-inline">productId</strong>.  </p></li>
				<li>Create a union type, <strong class="source-inline">SomeRequest</strong>, which can be either the <strong class="source-inline">Put</strong> or <strong class="source-inline">Post</strong> type:   <p class="source-code">type SomeRequest =  Post | Put</p><p>The data being matched to the union type can be any of the types in the union. Note that unions do not combine types; they simply try to match the data to one of the types in the union, which gives you, the developer, more flexibility.</p></li>
				<li>Create an instance of an array of the <strong class="source-inline">Product</strong> type:<p class="source-code">const products: Product[] = [];</p></li>
				<li>Build a handler function that processes a request of the <strong class="source-inline">SomeRequest</strong> type:<p class="source-code">function ProcessRequest(request: SomeRequest ) {</p><p class="source-code">    if ("productId" in request) { products.forEach(</p><p class="source-code">            (p: Product, i: number) =&gt; {</p><p class="source-code">               products[request.productId] = {</p><p class="source-code">                   ...request.product</p><p class="source-code">               };});        </p><p class="source-code">    } else {</p><p class="source-code">        products.push(request.product);</p><p class="source-code">    }}</p><p>This function will receive a request of the <strong class="source-inline">Put</strong> or <strong class="source-inline">Post</strong> type and add or update an attached product to the <strong class="source-inline">products</strong> array. In order to know whether it should update or add the function, it first checks whether the product has a <strong class="source-inline">productId</strong> argument.  If it does, we will loop through the <strong class="source-inline">Products</strong> array until we find a matching <strong class="source-inline">productId</strong> argument. Then, we use the spread operator to update the product data with the data from the request. If the product does not have a <strong class="source-inline">productId</strong> argument, we then just use the <strong class="source-inline">push</strong> function attached to the array to add the new product to the array.</p></li>
				<li>Declare <strong class="source-inline">apple</strong> and <strong class="source-inline">mango</strong> objects of the <strong class="source-inline">Product</strong> type, as shown here: <p class="source-code">const apple: Product = {</p><p class="source-code">    name: "apple",</p><p class="source-code">    price: 12345,</p><p class="source-code">    amount: 10</p><p class="source-code">}; </p><p class="source-code">const mango: Product = {</p><p class="source-code">    name: "mango",</p><p class="source-code">    price: 66666,</p><p class="source-code">    amount: 15</p><p class="source-code">};</p><p>In a real API, the data would be provided by the user sending it via a request, but for the purposes of this exercise, we have hardcoded some data for you to work with.</p></li>
				<li>Declare <strong class="source-inline">postAppleRequest</strong> and <strong class="source-inline">putMangoRequest</strong> objects of the <strong class="source-inline">Post</strong> and <strong class="source-inline">Put</strong> types:<p class="source-code">const postAppleRequest : Post = {</p><p class="source-code">    header: "zzzzz",</p><p class="source-code">    method: 'new',</p><p class="source-code">    product: apple,</p><p class="source-code">};</p><p class="source-code">const putMangoRequest : Put = {</p><p class="source-code">    header:"ggggg",</p><p class="source-code">    method: 'update',</p><p class="source-code">    product: mango,</p><p class="source-code">    productId: 2</p><p class="source-code">};</p><p>In the preceding code, we have defined our <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> objects. We have attached the product object as a payload of the request. Remember that the function is not checking the product object but the request type, which will tell the function whether it's <strong class="source-inline">POST</strong> or <strong class="source-inline">PUT</strong>.</p></li>
				<li>Call the handler function and pass <strong class="source-inline">postAppleRequest</strong> and <strong class="source-inline">putMangoRequest</strong> as arguments, as shown in the following code snippet:   <p class="source-code">ProcessRequest(postAppleRequest);</p><p class="source-code">ProcessRequest(putMangoRequest);</p><p>In a normal API, when the user makes a <strong class="source-inline">PUT</strong> or <strong class="source-inline">POST</strong> request, the <strong class="source-inline">ProcessRequest</strong> method would be called. We are, however, just simulating an API and making the calls ourselves.</p></li>
				<li>Console out the results:<p class="source-code">console.log(products)</p><p>You will see the following output:</p><p class="source-code">[</p><p class="source-code">  { name: 'apple', price: 12345, amount: 10 },</p><p class="source-code">  &lt;1 empty item&gt;,</p><p class="source-code">  { name: 'mango', price: 66666, amount: 15 }</p><p class="source-code">]</p><p>In the preceding output, we can now see the products that we passed to our methods. This means that our simulated API code using unions works as intended. </p></li>
			</ol>
			<p>Union types, such as intersection types, give you, the developer, more functionality and flexibility when building your applications. In the preceding exercise, we were able to write a function that takes a single argument of two different types and applies logic based on type checking patterns or type guards. In the next section, we will continue the theme of more code flexibility with index types.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor165"/>Index Types</h1>
			<p>Index types allow us to create objects that have flexibility as regards the number of properties they may hold. Let's say you have a type that defines an error message, which can be more than one type, and you want the flexibility to add more types of messages over time. Because objects have a fixed number of properties, we would need to make changes to our message code whenever there was a new message type. Index types allow you to define a signature for your type using an interface, which gives you the ability to have a flexible number of properties. In the following example, we will expand on this in the code:</p>
			<p class="source-code-heading">Example04.ts</p>
			<p class="source-code">1 interface ErrorMessage  {</p>
			<p class="source-code">2    // can only be string | number | symbol</p>
			<p class="source-code">3    [msg: number ]: string;</p>
			<p class="source-code">4     // you can add other properties once they are of the same type</p>
			<p class="source-code">5     apiId: number</p>
			<p class="source-code">6 }</p>
			<p class="source-code-link">Link to the preceding example: <a href="https://packt.link/IqpWH">https://packt.link/IqpWH</a></p>
			<p>First, we create our type signature, as shown in the preceding snippet. Here we have a property name and type, which is the index <strong class="source-inline">[msg: number]</strong> followed by the value type. The name of the <strong class="source-inline">msg</strong> argument can be anything, but as a good coder, you should provide a name that makes sense in the context of the type. Note that your index can only be a number, string, or symbol. </p>
			<p>You can also add other properties to your index, but they must be the same type as the index, as shown in the preceding code snippet, <strong class="source-inline">apiId: number</strong>. Next, we make use of your type by casting it to <strong class="source-inline">errorMessage</strong>. We can now have an error message object with as many properties as we require. There is no need to modify the type as our list of messages grows. We maintain flexibility while keeping our code typed, thereby making it easy to scale and support:</p>
			<p class="source-code">7  // message object of Index type ErrorMessage</p>
			<p class="source-code">8  const errorMessage: ErrorMessage  = {</p>
			<p class="source-code">9       0: "system error",</p>
			<p class="source-code">10      1: "overload",</p>
			<p class="source-code">11      apiId: 12345</p>
			<p class="source-code">12 };</p>
			<p>Now, we console out the new object just to make sure that everything works:</p>
			<p class="source-code">// console out object</p>
			<p class="source-code">console.log(</p>
			<p class="source-code">    errorMessage</p>
			<p class="source-code">);</p>
			<p>You will get the following output once you run the file:</p>
			<p class="source-code">{ '0': 'system error', '1': 'overload', apiId: 12345 }</p>
			<p>If we try to give a property name of an incorrect type, such as a string, we get the kind of error message you might expect: </p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B14508_06_08.jpg" alt="Figure 6.8: Output displaying the type error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Output displaying the type error</p>
			<p>You can, however, use strings that are numbers, for example, and the code will function as before and the output will be the same:</p>
			<p class="source-code">14 // message object of Index type ErrorMessage</p>
			<p class="source-code">15 const errorMessage: ErrorMessage  = {</p>
			<p class="source-code">16    '0': "system error",</p>
			<p class="source-code">17     1: "overload",</p>
			<p class="source-code">18    apiId: 12345 };</p>
			<p>You may think that this will not work given that the value is a string, but it gets converted to a number literal. It will also work the other way around using a number literal that gets converted to a string. Next in our exercise, we will simulate the real-world usage of an index type, building a simple system to process error messages.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor166"/>Exercise 6.05: Displaying Error Messages</h2>
			<p>In this exercise, we will build a system to process error messages. We will also reuse the <strong class="source-inline">ErrorMessage</strong> index type we created in our example. The code in this exercise is somewhat contrived but will serve to help you get a better understanding of index types:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/ZkApY">https://packt.link/ZkApY</a>.</p>
			<ol>
				<li value="1">Open VS Code and create a new file named <strong class="source-inline">Exercise05.ts</strong>.</li>
				<li>Create the <strong class="source-inline">ErrorMessage</strong> type interface from our example if you have not already done so:<p class="source-code">interface ErrorMessage  {</p><p class="source-code">    // can only be string | number | symbol</p><p class="source-code">    [msg: number ]: string;</p><p class="source-code">    // you can add other properties once they are of the same type</p><p class="source-code">    apiId: number</p><p class="source-code">}</p></li>
				<li>Build an <strong class="source-inline">errorCodes</strong> object as an <strong class="source-inline">ErrorMessage</strong> type, as shown here:<p class="source-code">const errorMessage : ErrorMessage = {</p><p class="source-code">    400:"bad request",</p><p class="source-code">    401:"unauthorized",</p><p class="source-code">    403:"forbidden",  apiId: 123456,</p><p class="source-code"> };</p></li>
				<li>Create an error code array as <strong class="source-inline">errorCodes</strong>, as shown here:<p class="source-code">const errorCodes: number [] = [</p><p class="source-code">    400,401,403</p><p class="source-code"> ];</p></li>
				<li>Loop through the <strong class="source-inline">errorCodes</strong> array and console out the error messages:<p class="source-code">errorCodes.forEach(</p><p class="source-code">    (code: number) =&gt;  {</p><p class="source-code">        console.log(</p><p class="source-code">            errorMessage[code]</p><p class="source-code">        );</p><p class="source-code">    }</p><p class="source-code">);</p><p>Once you run the file, you will obtain the following output:</p><p class="source-code">bad request</p><p class="source-code">unauthorized</p><p class="source-code">forbidden</p></li>
			</ol>
			<p>Index types allow you to have flexibility with your type definitions, as you can see in the preceding exercise. If you need to add new codes, you will not need to change your type definition; simply add the new code property to your <strong class="source-inline">errorCode</strong> object. Index types work here because even though the properties for the object are different, they all have the same basic makeup – a number property (key) followed by a string value. </p>
			<p>Now that you have the building blocks for advanced types, you can work through the following activities. The activities will make use of all the skills you have acquired in this chapter.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor167"/>Activity 6.01: Intersection Type</h2>
			<p>Imagine that you are a developer working on a truck builder feature for a custom truck website. You will need to make it possible for customers that come to the site to build a variety of truck types. To that end, you need to build your own intersection type, <strong class="source-inline">PickUptruck</strong>, by combining two types, <strong class="source-inline">Motor</strong> and <strong class="source-inline">Truck</strong>. You can then use your new type, <strong class="source-inline">PickUpTruck</strong>, with a function that returns the type and validates its input with the <strong class="source-inline">PickUpTruck</strong> intersection type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/n4tfL">https://packt.link/n4tfL</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Motor</strong> type, which will house some common properties you may reuse on their own or in combination with other types to describe a vehicle object. You can use the following properties as a starting point: <strong class="source-inline">color</strong>, <strong class="source-inline">doors</strong>, <strong class="source-inline">wheels</strong>, and <strong class="source-inline">fourWheelDrive</strong>. </li>
				<li>Create a <strong class="source-inline">Truck</strong> type with properties common to a truck, for example, <strong class="source-inline">doubleCab</strong> and <strong class="source-inline">winch</strong>.</li>
				<li>Intersect the two types to create a <strong class="source-inline">PickUpTruck</strong> type.</li>
				<li>Build a <strong class="source-inline">TruckBuilder</strong> function that returns our <strong class="source-inline">PickUpTruck</strong> type and also takes <strong class="source-inline">PickUpTruck</strong> as an argument. </li>
				<li>Console out the function return.</li>
				<li>Once you complete the activity, you should obtain the following output:<p class="source-code">{</p><p class="source-code">  color: 'red',</p><p class="source-code">  doors: 4,</p><p class="source-code">  doubleCab: true,</p><p class="source-code">  wheels: 4,</p><p class="source-code">  fourWheelDrive: true,</p><p class="source-code">  winch: true</p><p class="source-code">}</p><p class="callout-heading">Note </p><p class="callout">The solution to this activity is presented via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor409">this link</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor168"/>Activity 6.02: Union Type</h2>
			<p>A logistics company has asked you to develop a feature on their website that will allow customers to choose the way they would like their packages to be shipped – via land or air. You have decided to use union types to achieve this. You can build your own union type called <strong class="source-inline">ComboPack</strong>, which can be either the <strong class="source-inline">LandPack</strong> or <strong class="source-inline">AirPack</strong> type. You can add any properties to your package types that you think will be common to a package. Also, consider using one type literal to identify your package as air or land, and a label property that will be optional. You will then need to construct a class to process your packages. Your class should have a method to identify your package type that takes arguments of the <strong class="source-inline">ComboPack</strong> type and uses your literal property to identify the package type and add the correct label, <strong class="source-inline">air cargo</strong> or <strong class="source-inline">land cargo</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/GQ2ZS">https://packt.link/GQ2ZS</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Build a <strong class="source-inline">LandPack</strong> and an <strong class="source-inline">AirPack</strong> type. Make sure to have a literal to identify the package type.</li>
				<li>Construct a union type, <strong class="source-inline">ComboPack</strong>, which can be <strong class="source-inline">LandPack</strong> or <strong class="source-inline">AirPack</strong>.</li>
				<li>Make a <strong class="source-inline">Shipping</strong> class to process your packages. Make sure to use your literal to identify your package types and modify your package with the correct label for its type.</li>
				<li>Create two package objects of the <strong class="source-inline">AirPack</strong> and <strong class="source-inline">LandPack</strong> types.</li>
				<li>Instantiate your <strong class="source-inline">Shipping</strong> class, process your new objects, and console out the modified objects.<p class="callout-heading">Note </p><p class="callout">The solution to this activity is presented via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor411">this link</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor169"/>Activity 6.03: Index Type</h2>
			<p>Now that you have done such a good job of incorporating the shipping option into the website, the company now needs you to add a feature that will allow their customers to track the status of their packages. It is important to the client that they have the ability to add new package statuses as the company grows, and as shipping methods change, they would like that flexibility.</p>
			<p>Hence, you have decided to build an index type, <strong class="source-inline">PackageStatus</strong>, using an interface signature of the <strong class="source-inline">status</strong> property of the <strong class="source-inline">string</strong> type and a value of the <strong class="source-inline">Boolean</strong> type. You will then construct a <strong class="source-inline">Package</strong> type with some common package properties. You will also include a <strong class="source-inline">packageStatus</strong> property of the <strong class="source-inline">PackageStatus</strong> type. You will use <strong class="source-inline">PackageStatus</strong> to track three statuses of your package: <strong class="source-inline">shipped</strong>, <strong class="source-inline">packed</strong>, and <strong class="source-inline">delivered</strong>, set to <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. You will then construct a class that takes an object of the <strong class="source-inline">Package</strong> type on initialization, contains a method that returns the <strong class="source-inline">status</strong> property, and a method that updates the <strong class="source-inline">status</strong> property, which takes <strong class="source-inline">status</strong> as a string and <strong class="source-inline">Boolean</strong> as a state. </p>
			<p>The method that updates your package should also return your <strong class="source-inline">packageStatus</strong> property.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/2LwHq">https://packt.link/2LwHq</a>.</p>
			<p>Here are some steps that will help you to complete this activity:</p>
			<ol>
				<li value="1">Build your <strong class="source-inline">PackageStatus</strong> index type using an interface with a property of <strong class="source-inline">status</strong> of the <strong class="source-inline">string</strong> type and a value of the <strong class="source-inline">Boolean</strong> type.</li>
				<li>Create a <strong class="source-inline">Package</strong> type that includes a property of the <strong class="source-inline">PackageStatus</strong> type and some common properties of a typical package.</li>
				<li>Make a class to process your <strong class="source-inline">Package</strong> type that takes the <strong class="source-inline">Package</strong> type on initialization, has a method to return your <strong class="source-inline">packageStatus</strong> property, and a method that updates and returns the <strong class="source-inline">packageStatus</strong> property.</li>
				<li>Create a <strong class="source-inline">Package</strong> object called <strong class="source-inline">pack</strong>.</li>
				<li>Instantiate your <strong class="source-inline">PackageProcess</strong> class with your new <strong class="source-inline">pack</strong> object.</li>
				<li>Console out your <strong class="source-inline">pack</strong> status.</li>
				<li>Update your <strong class="source-inline">pack</strong> status and console out your new <strong class="source-inline">pack</strong> status. <p>The expected output is as follows:</p><p class="source-code">{ shipped: false, packed: true, delivered: true }</p><p class="source-code">{ shipped: true, packed: true, delivered: true }</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor413">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we covered advanced types, which allow you to extend beyond your basic types. As applications become more complex and the frontend takes on more functionality, your data models will also become more complex. This chapter showed you how TypeScript advanced types give you the ability to implement strong typing, which will help you develop cleaner and more reliable applications. We covered the building blocks of advanced types – type aliases and literals, and we then moved on to intersection, union, and index types with some practical examples, exercises, and activities. </p>
			<p>You now have the ability to create complex types that will allow you to build types for modern applications and write code that is well supported and scalable. Having reached this point, you now have the tools to take on web frameworks, such as Angular2 and React. You can even use TypeScript on the server side with Node.js. There is much more to advanced types and the topic is quite vast, complex, and abstract in its implementations. However, here in this chapter, you have been equipped with the skills you need to start building applications with advanced types. </p>
		</div>
		<div>
			<div id="_idContainer091" class="Content">
			</div>
		</div>
	</body></html>