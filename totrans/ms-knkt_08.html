<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Plugins and Other Knockout Libraries</h1></div></div></div><p class="calibre8">A big part of effectively working in any area of software is to be familiar with the tools used by the community. It is often better to rely on existing libraries and plugins that have been used and tested in the real world than try to reinvent the wheel on each new project. In this chapter, we will be looking at some of the most popular Knockout plugins:</p><div><ul class="itemizedlist"><li class="listitem">Knockout Validation</li><li class="listitem">Knockout Mapping</li><li class="listitem">Knockout Kendo</li><li class="listitem">KoGrid</li><li class="listitem">Knockout Bootstrap</li><li class="listitem">Knockout Switch-Case</li><li class="listitem">Knockout Projections</li><li class="listitem">Knockout-ES5</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec59" class="calibre1"/>Knockout Validation</h1></div></div></div><p class="calibre8">The validation <a id="id598" class="calibre1"/>of user input is a common enough task that nearly every web application will have at least some need for. By far the most popular Knockout <a id="id599" class="calibre1"/>plugin, with 50 percent more stars on GitHub than the next Knockout related project, Knockout Validation creates several extenders and binding handlers that are designed to simplify HTML form validation.</p><p class="calibre8">The use of the plugin starts with extenders that apply validation logic to observables without replacing them:</p><div><pre class="programlisting">var requiredValue = ko.observable().extend({ required: true });
var multipleValidationValue = ko.observable().extend({
                     required: true,
                     minLength: 3,
                     pattern: {
                          message: 'Hey this doesnt match my pattern',
                          params: '^[A-Z0-9].$'
                     }
                 });</pre></div><p class="calibre8">Binding against validation-extended values is done with the normal <code class="literal">value</code> binding:</p><div><pre class="programlisting">&lt;input data-bind="value: requiredValue" /&gt;</pre></div><p class="calibre8">Knockout Validation modifies the standard value and checked bindings so that they display invalid value warnings. The default display behavior will place a span element that contains any errors after the value-bound input element. The error message <code class="literal">span</code> will be hidden when the value is valid and contain the error message text when invalid.</p><p class="calibre8">This automatic error <a id="id600" class="calibre1"/>insertion can be disabled if you want to manually place the <a id="id601" class="calibre1"/>validation message in the view. To do this, use the <code class="literal">validationMessage</code> binding, which has the same behavior as the inserted span.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec115" class="calibre1"/>Default validation rules</h2></div></div></div><p class="calibre8">Knockout <a id="id602" class="calibre1"/>Validation provides several validation extenders by default, which it calls <strong class="calibre9">rules</strong>. Like normal extenders, multiple validation rules <a id="id603" class="calibre1"/>can be passed in order to extend in a <a id="id604" class="calibre1"/>single call, or they can be chained:</p><div><pre class="programlisting">var myObj = ko.observable().extend({ required: true });
var myObj = ko.observable().extend({ number: true, min: 10, max: 30 });
var myObj = ko.observable().extend({ number: true})
    .extend({ min: 10, max: 30 });</pre></div><p class="calibre8">The default rules cover most of the standard cases for checking values, including—but not limited to—numerical min and max, string length min and max, regex patterns, dates, and value equality.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec116" class="calibre1"/>Configuring validation options</h2></div></div></div><p class="calibre8">Knockout <a id="id605" class="calibre1"/>Validation's behavior is very configurable. Some of the <a id="id606" class="calibre1"/>more useful options include:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">insertMessages</code> (default: <code class="literal">true</code>): If true, a <code class="literal">span</code> will be inserted after an input that is bound to a validated observable.</li><li class="listitem"><code class="literal">errorElementClass</code> (default: <code class="literal">validationElement</code>): This is a class that is applied to elements when validated observables are invalid.</li><li class="listitem"><code class="literal">messagesOnModified</code> (default: <code class="literal">true</code>): If true, validation messages will not get displayed until the validated value has been modified so that they are hidden until a user interacts with the form.</li><li class="listitem"><code class="literal">messageTemplate</code> (default: <code class="literal">null</code>): This is an ID of a script element that will be used as the validation message template instead of inserting the message into a span.</li></ul></div><p class="calibre8">Configuration options <a id="id607" class="calibre1"/>can be set globally by passing an object to <code class="literal">ko.validation.init</code>:</p><div><pre class="programlisting">ko.validation.init({
   insertMessages: false,
   errorElementClass: 'text-danger'
});</pre></div><p class="calibre8">Options can also be set contextually using the <code class="literal">validationOption</code> binding (see the next section) or by passing a <a id="id608" class="calibre1"/>configuration object to <code class="literal">ko.applyBindingsWithValidation</code>:</p><div><pre class="programlisting">ko.applyBindingsWithValidation(viewModel, rootNode, {
   insertMessages: false,
   errorElementClass: 'text-danger'
});</pre></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec117" class="calibre1"/>Validation binding handlers</h2></div></div></div><p class="calibre8">Knockout Validation <a id="id609" class="calibre1"/>adds a few binding handlers to assist in displaying validation errors.</p><p class="calibre8">The <code class="literal">validationMessage</code> binding displays the error message for validated observables when they are <a id="id610" class="calibre1"/>invalid. When the value is valid, the element is hidden:</p><div><pre class="programlisting">&lt;div&gt;
   &lt;input type="text" data-bind="value: someValue"/&gt;
   &lt;p data-bind="validationMessage: someValue"&gt;&lt;/p&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The <code class="literal">validationElement</code> binding is useful for applying attributes and classes to elements. It <a id="id611" class="calibre1"/>sets the title attribute to the validation message, which is useful for showing tooltips, and it sets <code class="literal">errorElementClass</code> (<code class="literal">validationElement</code> by default) as the element's class attribute when the <code class="literal">decorateElement</code> configuration option is true:</p><div><pre class="programlisting">&lt;div&gt;
   &lt;label data-bind="validationElement: someValue"&gt;
     &lt;input type="text" data-bind="value: someValue"/&gt;
   &lt;/label&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The <a id="id612" class="calibre1"/>
<code class="literal">validationOptions</code> binding is similar to a control flow binding in that it applies the specified configuration options to all descendant DOM <a id="id613" class="calibre1"/>nodes. It can take the same object format that the configuration options can take:</p><div><pre class="programlisting">&lt;div data-bind="validationOptions: { insertMessages: false } "&gt;
   &lt;input type="text" data-bind="value: someValue"/&gt;
   &lt;p data-bind="validationMessage: someValue"&gt;&lt;/p&gt;
&lt;/div&gt;</pre></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec118" class="calibre1"/>Creating custom rules</h2></div></div></div><p class="calibre8">Custom rules <a id="id614" class="calibre1"/>can be created both globally so that they can be reused by multiple extenders or inline for use in a single extender. Adding <a id="id615" class="calibre1"/>global validation rules is done by adding a rule object to the <code class="literal">ko.validation.rules</code> object. A rule has two components, <a id="id616" class="calibre1"/>which are the <strong class="calibre9">validator function</strong> and the <strong class="calibre9">default message</strong>:</p><div><pre class="programlisting">ko.validation.rules['contains'] = {
    validator: function (val, substring) {
        return val.indexof(substring) !== -1;
    },
    message: 'The field must contain {0}'
};</pre></div><p class="calibre8">The validator <a id="id617" class="calibre1"/>function receives two arguments: the value of the observable and the value passed to the validation extender. The validation extender can take any valid JavaScript value, including objects and functions.</p><p class="calibre8">Once a validation rule has been added, its extender is created with the following call:</p><div><pre class="programlisting">ko.validation.registerExtenders();</pre></div><p class="calibre8">It can then be used to extend observables:</p><div><pre class="programlisting">var title = ko.observable().extend({ contains: 'Sr.' });</pre></div><p class="calibre8">Inline validation rules work by passing the same validation rule object to the validation extender:</p><div><pre class="programlisting">var title = ko.observable().extend({
   validation: {
       validator: function (val, substring) {
           return val.indexof(substring) !== -1;
       },
       message: 'The field must contain {0}',
       params: 'Sr.'
   }
});</pre></div><p class="calibre8">When using inline validation <a id="id618" class="calibre1"/>rules, the second parameter <a id="id619" class="calibre1"/>to the <code class="literal">validator</code> function is defined with the <code class="literal">params</code> property of the validation rule.</p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">Knockout Validation is a large library with many features and options that have not been discussed in this section. The complete documentation for the Knockout Validation library can be found on its GitHub repository at <a class="calibre1" href="https://github.com/Knockout-Contrib/Knockout-Validation">https://github.com/Knockout-Contrib/Knockout-Validation</a>.</p></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec60" class="calibre1"/>Knockout Mapping</h1></div></div></div><p class="calibre8">The Knockout <a id="id620" class="calibre1"/>Mapping plugin is the answer to projects that want to bind against their server's AJAX responses without manually writing the JavaScript classes in order to convert them into observables. The mapping plugin will convert JavaScript objects or JSON strings into objects with observable properties:</p><div><pre class="programlisting">var mappedViewmodel = ko.mapping.fromJS({
   name: 'Timothy Moran',
   age: 24
});
ko.applyBindings(mappedViewmodel);</pre></div><p class="calibre8">For JSON, take a <a id="id621" class="calibre1"/>look at the following code:</p><div><pre class="programlisting">var serverResponse = "{"name":"Timothy Moran","age":24}";
var mappedViewmodel = ko.mapping.fromJSON(serverResponse);
ko.applyBindings(mappedViewmodel);</pre></div><p class="calibre8">The mapping plugin handles arrays by converting them into <code class="literal">observableArrays</code>. It also creates a copy of objects, allowing a complete object graph from the server to be converted into an observable object.</p><p class="calibre8">Updates against viewmodels created with the mapping plugin can be performed by passing the viewmodel as the second parameter to <code class="literal">fromJS</code> or <code class="literal">fromJSON</code>:</p><div><pre class="programlisting">ko.mapping.fromJS(data, viewModel);</pre></div><p class="calibre8">You can see a simple <a id="id622" class="calibre1"/>example of the mapping plugin in action in the <code class="literal">cp8-mapping</code> branch.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec119" class="calibre1"/>Updating the viewmodel</h2></div></div></div><p class="calibre8">The <code class="literal">fromJS</code> and <a id="id623" class="calibre1"/>
<code class="literal">fromJSON</code> methods can also be used to update <a id="id624" class="calibre1"/>an entire viewmodel in order to <a id="id625" class="calibre1"/>handle future server update responses by passing the viewmodel as the third parameter:</p><div><pre class="programlisting">ko.mapping.fromJS(data, {}, viewModel);</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec120" class="calibre1"/>Unmapping</h2></div></div></div><p class="calibre8">Normally, when sending <a id="id626" class="calibre1"/>data back to the server, you would use <code class="literal">ko.toJS</code> or <code class="literal">ko.toJSON</code> to unwrap the viewmodel into an object with normal JavaScript properties instead of observables ones. Because the mapping plugin adds several properties to <a id="id627" class="calibre1"/>your viewmodel that are intended for internal <a id="id628" class="calibre1"/>use, <code class="literal">ko.toJS</code> will produce a cluttered copy. Instead, you can use <code class="literal">ko.mapping.toJS</code> and <code class="literal">ko.mapping.toJSON</code> to get an unwrapped viewmodel without the added mapping properties.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec121" class="calibre1"/>Mapping options</h2></div></div></div><p class="calibre8">To control how <a id="id629" class="calibre1"/>objects are created or updated by the mapping plugin, options can be passed in when a viewmodel is first created. The mapping plugin will use the <a id="id630" class="calibre1"/>options to build the viewmodel, and then store the options so that they can be used for all future updates:</p><div><pre class="programlisting">var mapping = {
   // options
};

var vm = ko.mapping.fromJS(data, mapping);</pre></div><div><div><div><div><h3 class="title2"><a id="ch08lvl3sec46" class="calibre1"/>Using keys for array updates</h3></div></div></div><p class="calibre8">The <a id="id631" class="calibre1"/>default behavior for updating arrays is to replace any elements that are not a perfect match with the new values. When working with arrays of objects, it is usually expected that the elements will have their values <a id="id632" class="calibre1"/>updated in place. To tell the mapping plugin how to determine that elements in the values to be updated are the same as the old values, a key can be defined:</p><div><pre class="programlisting">var mapping = {
   people: {
      key: function(person) {
         return ko.unwrap(person.id);
      }
   }
};
var vm = ko.mapping.fromJS(data, mapping);</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch08lvl3sec47" class="calibre1"/>Using create for the object construction</h3></div></div></div><p class="calibre8">You can <a id="id633" class="calibre1"/>provide a callback for <a id="id634" class="calibre1"/>individual properties to control their creation. A <a id="id635" class="calibre1"/>common use case is to provide a constructor for the object:</p><div><pre class="programlisting">var mapping = {
   people: {
      key: function(person) { /* same as before */ },
      create: function(options) {
         return new Person(options.data);
      }
   }
};
var vm = ko.mapping.fromJS(data, mapping);</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch08lvl3sec48" class="calibre1"/>Controlling updates</h3></div></div></div><p class="calibre8">Similar to <a id="id636" class="calibre1"/>creation, an update callback can be provided. The <a id="id637" class="calibre1"/>return value will be used as the property's value:</p><div><pre class="programlisting">var mapping = {
   price: {
      update: function (options) {
         return parseMoney(options.data);
      }
   }
};
var vm = ko.mapping.fromJS(data, mapping);</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch08lvl3sec49" class="calibre1"/>Choosing which properties get mapped</h3></div></div></div><p class="calibre8">Mapping options <a id="id638" class="calibre1"/>can specify an array of property names that control various aspects of mapping:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ignore</code>: Mapping <a id="id639" class="calibre1"/>will not include these in the generated viewmodel.</li><li class="listitem"><code class="literal">copy</code>: Mapping will copy the values of these properties directly instead of converting them <a id="id640" class="calibre1"/>into observable properties.</li><li class="listitem"><code class="literal">observe</code>: If present, only the properties in this array will be converted into observable <a id="id641" class="calibre1"/>properties on the viewmodel. This is the inverse of the previous option.</li><li class="listitem"><code class="literal">include</code>: Normally when using <code class="literal">ko.mapping.toJS</code>, only properties that were originally in the mapping will be in the output. Any properties in the <code class="literal">include</code> <a id="id642" class="calibre1"/>array will also be copied into the output even if they weren't in the original viewmodel.</li></ul></div><p class="calibre8">All of these arrays <a id="id643" class="calibre1"/>will be combined with the default values in the <code class="literal">ko.mapping.defaultOptions</code> object. The defaults are all empty by default, but they can be modified:</p><div><pre class="programlisting">ko.mapping.defaultOptions().ignore = ["alwaysIgnoreThis"];
ko.mapping.defaultOptions().copy = ["alwaysCopyThis"];</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch08lvl3sec50" class="calibre1"/>Challenges</h3></div></div></div><p class="calibre8">The Knockout <a id="id644" class="calibre1"/>Mapping plugin is very useful in cases where server responses drive the work being done by the application. When the application needs to work with models, the mapping plugin will not be able to create the viewmodel before the models have been sent by the server. This happens commonly when filling out forms to create new models for the first time. The properties of a viewmodel are also only half the story; business logic will still need to be written for most viewmodels. It can be challenging to write functions or computed properties against properties that are populated <a id="id645" class="calibre1"/>by the mapping plugin, as they are not in the class that will be served as a reference. In very complex cases, the mapping logic for some objects might exceed the same logic for an object defined with normal JavaScript. While this can save time in medium-to-large applications with many server responses, it might not always be the best fit for a project.</p><p class="calibre8">Despite its popularity, it is no longer being maintained on GitHub. However, as of version 3.2, it still works with Knockout.</p><div><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">The documentation <a id="id646" class="calibre1"/>for the mapping plugin is on the official Knockout site at <a class="calibre1" href="http://knockoutjs.com/documentation/plugins-mapping.html">http://knockoutjs.com/documentation/plugins-mapping.html</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec61" class="calibre1"/>Knockout Kendo</h1></div></div></div><p class="calibre8">Kendo UI (<a class="calibre1" href="http://www.telerik.com/kendo-ui">http://www.telerik.com/kendo-ui</a>) is a <a id="id647" class="calibre1"/>popular HTML5 widgets library of Telerik that offers a <a id="id648" class="calibre1"/>large selection of professional-looking <a id="id649" class="calibre1"/>controls. Knockout Kendo is a library of bindings, which allows Knockout viewmodels to use Kendo controls. Knockout Kendo has over 30 bindings, each with a variety of options, which is far too many to cover here. While Knockout Kendo is free, Kendo UI itself is not free and requires you to purchase a license in order to use it.</p><p class="calibre8">Most of the bindings are simple wrappers around the Kendo widgets, offering an API with a few surprises. For <a id="id650" class="calibre1"/>example, here is the <strong class="calibre9">autocomplete</strong> binding, which takes an array of options and an observable that binds the selection:</p><div><pre class="programlisting">&lt;input data-bind="kendoAutoComplete: { data: autocompleteOptions, value: autocompleteValue }" /&gt;&lt;br&gt;</pre></div><p class="calibre8">
<code class="literal">DateTimePicker</code>, which creates two independent selection controls for the date and time, binds against a single observable <code class="literal">Date</code> object:</p><div><pre class="programlisting">&lt;input data-bind="kendoDateTimePicker: startDate" /&gt;</pre></div><p class="calibre8">If you have used Kendo <a id="id651" class="calibre1"/>previously, you will be familiar with the available controls, and Knockout Kendo even has bindings for the non-free Professional UI widgets. You can see a few examples of <a id="id652" class="calibre1"/>Kendo controls in the <code class="literal">cp8-kendo</code> branch.</p><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">You can find the <a id="id653" class="calibre1"/>complete documentation for Knockout Kendo on its GitHub site at <a class="calibre1" href="http://rniemeyer.github.io/knockout-kendo/">http://rniemeyer.github.io/knockout-kendo/</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec62" class="calibre1"/>KoGrid</h1></div></div></div><p class="calibre8">KoGrid is a plugin <a id="id654" class="calibre1"/>that creates a binding that renders tabular data. As its GitHub page notes, it is "a direct knockout port of ng-grid which was originally inspired by KoGrid, which was inspired by SlickGrid." Its history might have been affected by the grandfather paradox.</p><p class="calibre8">In its most basic operation mode, KoGrid can bind against an array of objects, turning their properties into columns and their values into cells:</p><div><pre class="programlisting">var vm = {
      people: ko.observableArray([{name: "Moroni", age: 50},
                                      {name: "Tiancum", age: 43},
                                      {name: "Jacob", age: 27},
                                      {name: "Nephi", age: 29},
                                      {name: "Enos", age: 34}])
   }
&lt;div class="gridStyle" data-bind="koGrid: { data: people }"&gt;&lt;/div&gt;</pre></div><p class="calibre8">You can see this example in the <code class="literal">cp8-kogrid</code> branch. Except for needing to manually specify, through style of CSS, the dimensions of the grid itself, everything else is automatic. You get row sorting by clicking on the columns, the ability to toggle columns visibility, a scrollbar for overflow, item counts, and the columns can be reordered by dragging them. The biggest downside is that the data isn't rendered using a real table element, it's rendered using just a bunch of <code class="literal">div</code> elements.</p><p class="calibre8">Of course, this is just the basic mode of operation. KoGrid comes with most of the features you would expect from a fully baked grid widget:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Column definitions</strong>: This specifies which row properties are displayed as columns.</li><li class="listitem"><strong class="calibre9">Grouping</strong>: This allows the user to select a column to pivot the table on, grouping all of the rows by matching values of the selected column.</li><li class="listitem"><strong class="calibre9">Selected rows</strong>: With this, an observable array can be bound against the selected rows for the table. When the <code class="literal">multiSelect</code> option is false, this can be used to create a master/detail view with the selected row.</li><li class="listitem"><strong class="calibre9">Templates</strong>: This <a id="id655" class="calibre1"/>provides row and cell templates for the grid.</li><li class="listitem"><strong class="calibre9">Themes</strong>: This specifies themes on a per-grid basis through binding options.</li><li class="listitem"><strong class="calibre9">Server-side paging</strong>: This provides callbacks that allow the grid to get data asynchronously from an external source.</li></ul></div><div><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">If you want a binding that outputs real table elements, and you don't need all of the bells and <a id="id656" class="calibre1"/>whistles offered by KoGrid, check out the knockout-table plugin at <a class="calibre1" href="https://github.com/mbest/knockout-table">https://github.com/mbest/knockout-table</a>.</p></div><p class="calibre8">Out of any of these features, templates are probably the most important. While their example page puts the templates in line in the viewmodel code, this is not a recommended practice unless you are loading the string from an external source (such as AJAX or the RequireJS text loader). KoGrid also supports using a script element as a template by referencing its ID, such as Knockout's template system. However, the simplest approach is to use a URL string to refer to an HTML partial file as the template:</p><div><pre class="programlisting">&lt;div data-bind="koGrid: { data: people,
      canSelectRows: false,
      displaySelectionCheckbox: false,
      columnDefs: [
         { field: 'name', displayName: 'Name', width: '*' },
         { field: 'age', displayName: 'Age', width: '*' },	
         { field: '', displayName: ' ', 
            cellTemplate: 'app/deleteButtonCell.html', 
            width: '**' 
         }]}" class="gridStyle"&gt;&lt;/div&gt;</pre></div><p class="calibre8">The preceding example shows you several grid options as well as the column definition that specifies which columns to show. Note that the last column does not have a property but has a template that will show you a delete button instead.</p><p class="calibre8">It is possible to define these options in the viewmodel and pass only a single object to the KoGrid binding; however, this causes the viewmodel to be tightly coupled to its use by a KoGrid, which is a violation of the MVVM pattern. Defining the grid options in the view keeps the viewmodel agnostic with regards to how it is displayed.</p><p class="calibre8">The delete button template will be rendered by KoGrid inside the binding context of the cell:</p><div><pre class="programlisting">&lt;div data-bind="attr: { 'class': 'kgCellText colt' + $index()}"&gt;
   &lt;button class="btn btn-xs btn-danger" data-bind="click: function() { $parent.$userViewModel.remove($parent.entity) }"&gt;Delete&lt;/button&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The complete documentation for cell and row templates will not be covered here, but the preceding template demonstrates several important components.</p><p class="calibre8">To control its width and <a id="id657" class="calibre1"/>position properly, cells need to include the <code class="literal">kgCellText</code> class as well as a 0-indexed class for the column it represents. As the cell will be used inside a column loop, it has access to the special binding context property <code class="literal">$index()</code> in order to get this value.</p><p class="calibre8">The default value for a click binding in Knockout is the current binding context. Inside the cell template, this will be the cell object and not the item from the data array. The bound item can be accessed using <code class="literal">$parent.entity</code>. To get access to the viewmodel, the grid is bound against <code class="literal">$parent.$userViewModel</code>. The <code class="literal">$parent</code> in both these cases is the binding context for the row; when creating row templates, <code class="literal">$data.entity</code> and <code class="literal">$userViewModel</code> can be used to access the same properties.</p><p class="calibre8">You can see an example of this custom template in the <code class="literal">cp8-kogrid-template</code> branch.</p><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">The complete documentation for KoGrid can be found on its GitHub Wiki page at <a class="calibre1" href="https://github.com/Knockout-Contrib/KoGrid/wiki">https://github.com/Knockout-Contrib/KoGrid/wiki</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec63" class="calibre1"/>Knockout Bootstrap</h1></div></div></div><p class="calibre8">Twitter Bootstrap has <a id="id658" class="calibre1"/>several beautiful jQuery-dependent widgets that can be used from JavaScript or in some cases, with their <code class="literal">data-*</code> attributes. If you <a id="id659" class="calibre1"/>are using Knockout, though, some work needs to be done in order to get it to work with observables and to initialize it from binding handlers. Knockout Bootstrap is a popular plugin that addresses this. Unfortunately, at the time of writing this, it hasn't been updated to work with Bootstrap 3 and therefore, some of its features do not work. When working with Knockout 3 and Bootstrap 3, the <strong class="calibre9">ToolTip</strong>, <strong class="calibre9">Popover</strong>, and <strong class="calibre9">Alerts</strong> bindings work correctly, but the <strong class="calibre9">Progress Bar</strong> and <strong class="calibre9">Typeahead</strong> bindings do not work.</p><p class="calibre8">Like Knockout Kendo, if you have used the Bootstrap widgets, the bindings in Knockout Bootstrap should be immediately familiar. The bindings are named after their widgets and take an object with the same properties the jQuery plugin initializers take. When sensible, the properties can be bound against:</p><div><pre class="programlisting">//Tooltip
&lt;p&gt;This is a paragraph with a &lt;span data-bind="tooltip: { title: tooltipText, placement: 'bottom' }"&gt; tooltip span&lt;/span&gt; inside.
&lt;/p&gt;

//Popover
&lt;button class="btn btn-primary" data-bind="popover: {template: 'popoverTemplate', title: 'Oh Yea'}"&gt;
    Launch Simple Popover
&lt;/button&gt;

//Alerts
&lt;div data-bind="foreach: alerts"&gt;
    &lt;div data-bind="alert: $data"&gt;&lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">These can all be seen in the <code class="literal">cp8-knockout-bootstrap</code> branch. One thing to note is that the alert binding does not <a id="id660" class="calibre1"/>remove alerts from the bound array when they <a id="id661" class="calibre1"/>are closed on the UI, though it will show or hide array elements as they are added or removed.</p><div><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">The complete <a id="id662" class="calibre1"/>documentation for Knockout Bootstrap is available at <a class="calibre1" href="http://billpull.com/knockout-bootstrap">http://billpull.com/knockout-bootstrap</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec64" class="calibre1"/>Knockout Switch-Case</h1></div></div></div><p class="calibre8">Despite being a plugin <a id="id663" class="calibre1"/>that targets a single, specific use case, Knockout Switch-Case's popularity on GitHub is evidence that a switch/case control flow <a id="id664" class="calibre1"/>binding is a very useful tool. Instead of writing out a series of <code class="literal">if</code>/<code class="literal">ifnot</code> bindings, a single case-switch binding can be used:</p><div><pre class="programlisting">&lt;div data-bind="switch: orderStatus"&gt;
    &lt;div data-bind="case: 'shipped'"&gt;
        Your order has been shipped. Your tracking number is &lt;span data-bind="text: trackingNumber"&gt;&lt;/span&gt;.
    &lt;/div&gt;
    &lt;div data-bind="case: 'pending'"&gt;
        Your order is being processed. Please be patient.
    &lt;/div&gt;
    &lt;div data-bind="case: 'incomplete'"&gt;
        Your order could not be processed. Please go back and complete the missing data.
    &lt;/div&gt;
    &lt;div data-bind="case: $default"&gt;
        Please call customer service to determine the status of your order.
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The preceding example can be seen in the <code class="literal">cp8-case-switch</code> branch.</p><p class="calibre8">The switch binding can <a id="id665" class="calibre1"/>also act on truthy values. This can be done by <a id="id666" class="calibre1"/>looking for the first matching value in a series:</p><div><pre class="programlisting">&lt;div data-bind="switch: true"&gt;
    &lt;div data-bind="case: trackingNumber"&gt;
        Your order has been shipped.
    &lt;/div&gt;
    &lt;div data-bind="case: isReady"&gt;
        Your order is being processed.
    &lt;/div&gt;
    &lt;div data-bind="casenot: isComplete"&gt;
        Your order has been processed.
    &lt;/div&gt;
    &lt;div data-bind="case: $else"&gt;
        Your order could not be processed.
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">Or, it can be done by serving as a shorthand for a pair of <code class="literal">if/ifnot</code> bindings:</p><div><pre class="programlisting">&lt;div data-bind="switch: isReady"&gt;
    &lt;div data-bind="case: true"&gt;You are ready!&lt;/div&gt;
    &lt;div data-bind="case: false"&gt;You are not ready!&lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The switch-case binding can also be used as a container-less binding in any combination of the preceding cases.</p><p class="calibre8">As you might have noticed, there are also special <code class="literal">$default</code> and <code class="literal">$else</code> options that can be used if no matching <a id="id667" class="calibre1"/>value is found.</p><div><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">The source code for Knockout Switch-Case is available on GitHub at <a class="calibre1" href="https://github.com/mbest/knockout-switch-case">https://github.com/mbest/knockout-switch-case</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec65" class="calibre1"/>Knockout Projections</h1></div></div></div><p class="calibre8">Using a computed <a id="id668" class="calibre1"/>observable to filter or project an observable array is an incredibly common operation; I don't think I've ever seen a Knockout project that didn't do this at least once. Knockout Projections is a plugin that adds a map and filter <a id="id669" class="calibre1"/>function to observable arrays, which creates a computed observable that only recomputes it's callback on dependent elements that have changed instead of re-evaluating every single dependent element.</p><div><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre8">Steven Sanderson introduced this plugin via his blog at <a class="calibre1" href="http://blog.stevensanderson.com/2013/12/03">http://blog.stevensanderson.com/2013/12/03</a>.</p></div><p class="calibre8">To better understand the problem this plugin solves, we are going to look at the example Sanderson uses on his blog to illustrate the differences between a normal computed observable array and an array made with Knockout Projections.</p><p class="calibre8">Consider the following model:</p><div><pre class="programlisting">function Product(data) {
    this.name = ko.observable(data.name);
    this.isSelected = ko.observable(false);
}
function PageViewModel() {
    // Some data, perhaps loaded via an Ajax call
    this.products = ko.observableArray([ /* several Products /* ]);
    this.selectedProducts = ko.computed(function() {
        return this.products().filter(function(product) {
            return product.isSelected();
        });
    }, this);
}</pre></div><p class="calibre8">This <code class="literal">selectedProducts</code> computed is defined using the standard ES5 Array's <code class="literal">filter</code> function, calling <code class="literal">products()</code> returns the underlying JavaScript array. Every time it runs, it will loop over all of the products and return an array of every element with <code class="literal">isSelected() === true</code>. The problem here is that computed observables always rerun when any of their dependencies change; the computed can only perform re-evaluation by running its callback, and has to recheck every single product every time it runs. This does not scale very well; it runs in O(N) time.</p><p class="calibre8">When using Knockout Projections, you will create this same computed using the <code class="literal">filter</code> function on the observable array itself:</p><div><pre class="programlisting">this.selectedProducts = this.products.filter(function(product) {
    return product.isSelected();
});</pre></div><p class="calibre8">This creates a read-only observable array that creates individual dependencies on each product's <code class="literal">isSelected</code> observable. When a product is changed, the callback is run against only that product, and the <code class="literal">selectedProducts</code> array is updated with the change. Performance now has a fixed cost: no matter how large the array gets, the callback will only be run once per <a id="id670" class="calibre1"/>dependency change. The declaring code is also shorter and easier to read!</p><p class="calibre8">Knockout Projections also creates a map function on observables, which runs a callback that produces an array transformation instead of a filter. For example, you can create an observable array of product names that only received updates when individual names were changed:</p><div><pre class="programlisting">this.productNames = this.products.map(function(product) {
    return product.name();
});</pre></div><p class="calibre8">As the read-only arrays created <a id="id671" class="calibre1"/>by filter and map are also observable arrays, these methods can be chained together:</p><div><pre class="programlisting">this.selectedNames = this.selectedProducts.map(function(product) {
    return product.name();
});</pre></div><p class="calibre8">The performance gain from using Knockout Projections is minor in small arrays but significant in larger ones. If <a id="id672" class="calibre1"/>you are working with even medium-sized data sets, using Knockout Projections is a no-brainer.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec66" class="calibre1"/>Knockout-ES5</h1></div></div></div><p class="calibre8">Knockout-ES5 is a plugin <a id="id673" class="calibre1"/>for Knockout that uses JavaScript getters and setters to hide observables behind object properties, allowing your application code to use standard syntax to work with them. Basically, it gets rid of the observable parentheses:</p><p class="calibre8">Take a look at the following code:</p><div><pre class="programlisting">var latestOrder = this.orders()[this.orders().length - 1];
latestOrder.isShipped(true);</pre></div><p class="calibre8">The preceding code becomes this:</p><div><pre class="programlisting">var latestOrder = this.orders[this.orders.length - 1];
latestOrder.isShipped = true;</pre></div><p class="calibre8">If you remember the Durandal observable plugin, it's very similar; they even came out around the same time. The biggest difference between the two is that Durandal's observable plugin performs deep object conversion, and Knockout ES5 performs shallow conversion.</p><p class="calibre8">To convert a viewmodel's properties to observables, call <code class="literal">ko.track</code>:</p><div><pre class="programlisting">function Person(init) {
   var self = this,
      data = init || {};

   self.name = data.name || '';
   self.age = data.age || '';
self.alive = data.alive !== undefined ? data.alive : true;
   self.job = data.job || '';

   ko.track(self);
}</pre></div><p class="calibre8">To optionally specify which properties are to be converted in order to pass an array of names, take a look at the following code:</p><div><pre class="programlisting">ko.track(self, ['name', 'age']);</pre></div><p class="calibre8">Observables that already exist on the model, such as those created with <code class="literal">ko.observable</code> or <code class="literal">ko.computed</code>, are also converted into ES5 properties by <code class="literal">ko.track</code>. Optionally, you can define computed observables using <code class="literal">ko.defineProperty</code>:</p><div><pre class="programlisting">ko.defineProperty(self, 'canRemove', function() {
   return !self.alive;
});</pre></div><p class="calibre8">The third parameter follows <a id="id674" class="calibre1"/>the same rules as the first parameter sent to <code class="literal">ko.computed</code>; a function will be used to create a read-only computed, or an object can be used to supply a read/write function.</p><p class="calibre8">Once observables have been created, you can access them with <code class="literal">ko.getObservable</code>:</p><div><pre class="programlisting">ko.getObservable(self, 'age').subscribe(function(newValue) {
   console.log(self.name + ' age was changed to ' + newValue);
});</pre></div><p class="calibre8">This is useful while applying extenders or adding subscriptions. Extenders can also be applied by creating observables with <code class="literal">ko.observable</code> before calling <code class="literal">ko.track</code>.</p><p class="calibre8">An example of all of these techniques can be seen in the <code class="literal">cp8-es5</code> branch.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec122" class="calibre1"/>Browser support</h2></div></div></div><p class="calibre8">As Knockout-ES5 uses <a id="id675" class="calibre1"/>JavaScript getters and setters, it will not work in browsers that do not support this feature. This is not a feature that can be shimmed or polyfilled with scripts.</p><p class="calibre8">Knockout gets a lot of flak for the syntax that results from the decision to make observable object functions. Going by the popularity of questions on Stack Overflow, it is certainly one of the most confusing aspects to newcomers. The decision to do this was made so that support for older browsers such as Internet Explorer 6, which doesn't support JavaScript getters and setters, was possible. Now that Internet Explorer 6 is finally starting to lose its death grip on the browser market share, this supportability issue is becoming less and less important to web developers. Unfortunately, Internet Explorer didn't add support for ES5 getters and setters until IE 9, which is still a high bar for most projects.</p><p class="calibre8">Realistically, as using Knockout ES5 has such a drastic impact on application syntax, switching to it on a that is project already underway is rarely feasible. Knockout ES5 should only be considered for new projects that do not have an old browser support requirement.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec67" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Narrowing down the plugins and libraries to include in this chapter was difficult. Knockout's Wiki page on GitHub contains a long list of plugins (<a class="calibre1" href="https://github.com/knockout/knockout/wiki/Plugins">https://github.com/knockout/knockout/wiki/Plugins</a>)—far too many to discuss here. If you are working with Knockout, you are encouraged to check out the community offerings, as it could end up saving you a lot of work. Not all of these plugins will be useful to everyone or every project, but hopefully, they give you an idea of what can be done with Knockout and motivate you to share some of your own work with the community.</p><p class="calibre8">In the next chapter, we will be taking a deep dive into Knockout's internals to see how it works.</p></div></body></html>