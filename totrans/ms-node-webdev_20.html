<html><head></head><body>
<div><h1 class="chapternumber">18</h1>
<h1 class="chaptertitle" id="_idParaDest-312">SportsStore: Orders and Validation</h1>
<p class="normal1">In this chapter, we continue to build the SportsStore application by adding support for placing orders, which includes validating the form data provided by the user.</p>
<h1 class="heading" id="_idParaDest-313">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">sportsstore</code> project from <em class="italic">Chapter 17</em>. No changes are required for this chapter. Open a new command prompt, navigate to the <code class="inlinecode">sportsstore</code> folder, and run the command shown in <em class="italic">Listing 18.1</em> to start the development tools.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 18.1: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a new browser window, navigate to <code class="inlinecode">http://localhost:5000</code>, and you will see the product catalog, as shown in <em class="italic">Figure 18.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_18_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 18.1: Running the application</p>
<h1 class="heading" id="_idParaDest-314">Handling orders</h1>
<p class="normal1">The <a id="_idIndexMarker968" class="calibre3"/>data model for handling orders comes in two parts: the <a id="_idIndexMarker969" class="calibre3"/>order and the user profile. The order describes the products that have been selected and provides the shipment status of the order. As noted in <em class="italic">Chapter 16</em>, the SportsStore application doesn’t extend to implementing the payment and fulfillment processes, which are typically handled by integration with separate platforms. </p>
<h2 class="heading1" id="_idParaDest-315">Creating the data model</h2>
<p class="normal1">To get <a id="_idIndexMarker970" class="calibre3"/>started, add a file named <code class="inlinecode">customer_models.ts</code> to the <code class="inlinecode">src/data</code> folder, with the content shown in <em class="italic">Listing 18.2</em>. This is a placeholder to represent customers with just enough functionality to start working on orders. </p>
<p class="packt_figref">Listing 18.2: The contents of the customer_models.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">export interface Customer {
    id?: number;
    name: string;
    email: string;
}
</code></pre>
<p class="normal">To describe orders, add a file named <code class="inlinecode">order_models.ts</code> to the <code class="inlinecode">src/data</code> folder with the content shown in <em class="italic">Listing 18.3</em>.</p>
<p class="packt_figref">Listing 18.3: The contents of the order_models.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Product } from "./catalog_models";
import { Customer } from "./customer_models";
export interface Order {
    id?: number;
    customer?: Customer;
    selections?: ProductSelection[];
    address?: Address;
    shipped: boolean;
}
export interface ProductSelection {
    id?: number;
    productId?: number;
    quantity: number;
    price: number;
}
export interface Address {
    id?: number;
    street: string;
    city: string;
    state: string;
    zip: string;
}
</code></pre>
<p class="normal">The <code class="inlinecode">Order</code> interface describes a single order, with <code class="inlinecode">ProductSelection</code> objects that represent the <a id="_idIndexMarker971" class="calibre3"/>products the user has purchased, including the price at the time of purchase. The customer is represented by a <code class="inlinecode">Customer</code> object and the addresses for shipping and billing are represented by <code class="inlinecode">Address</code> objects. The details required for real online stores vary based on local laws and customs and the type of products being sold, but these interfaces are a reasonable approximation of the basic order characteristics that can be adapted as needed.</p>
<p class="normal">To describe the access to order data, add a file named <code class="inlinecode">order_repository.ts</code> to the <code class="inlinecode">src/data</code> folder, with the content shown in <em class="italic">Listing 18.4</em>.</p>
<p class="packt_figref">Listing 18.4: The contents of the order_repository.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Order } from "./order_models";
export interface OrderRepository {
    getOrder(id: number): Promise&lt;Order| null&gt;;
    getOrders(excludeShipped: boolean): Promise&lt;Order[]&gt;;
    storeOrder(order: Order): Promise&lt;Order&gt;;
}
</code></pre>
<p class="normal">The <code class="inlinecode">getOrder</code> method returns a single order, identified by its <code class="inlinecode">id</code> value. The <code class="inlinecode">getOrders</code> method retrieves all orders, with a parameter that allows shipped orders to be excluded from the results. The <code class="inlinecode">storeOrder</code> method stores or updates an order.</p>
<h2 class="heading1" id="_idParaDest-316">Implementing the model classes</h2>
<p class="normal1">I am<a id="_idIndexMarker972" class="calibre3"/> going to extend the existing Sequelize implementation of the <code class="inlinecode">CatalogRepository</code> interface to implement the methods defined by the <code class="inlinecode">OrderRepository</code> interface, which will allow a single database to store both catalog and order data. Add a file named <code class="inlinecode">customer_models.ts</code> to the <code class="inlinecode">src/data/orm/models</code> folder with the content shown in <em class="italic">Listing 18.5</em>.</p>
<div><p class="normal"><strong class="screentext">One versus Many Databases</strong></p>
<p class="normal">It can be appealing from a design perspective to keep each category of data in its own database, so that catalog data, for example, is stored separately from order or user data. In practice, separate databases are difficult to manage, especially since most categories of data used by an application have some kind of relationship: orders need to refer to products, user accounts need to be associated with orders, and so on. Putting an application’s data in a single database makes it easier to use database features like transactions to ensure data integrity and simplifies correlating data in queries.</p>
<p class="normal">If you decide to use multiple databases, then you assume responsibility for managing transactions across databases, and ensuring that data remains consistent so that relationships between databases are consistent. There are tools available to help, such as distributed transaction managers, for example, but they can be complex and difficult to use.</p>
</div>
<div><p class="normal">My advice, from a purely practical perspective, is to use a single database for all an application’s data whenever possible. When a single database isn’t possible, such as when employee data is stored in a central HR database to which your application has read-only access, then you should pay close attention to how the relationships between data are managed.</p>
</div>
<p class="packt_figref">Listing 18.5: The contents of the customer_models.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { Model, CreationOptional, InferAttributes, InferCreationAttributes }
    from "sequelize";
import { Customer } from "../../customer_models";
export class CustomerModel extends Model&lt;InferAttributes&lt;CustomerModel&gt;,
        InferCreationAttributes&lt;CustomerModel&gt;&gt; implements Customer {
    declare id?: CreationOptional&lt;number&gt;;
    declare name: string;
    declare email: string;
}
</code></pre>
<p class="normal">The <code class="inlinecode">CustomerModel</code> class implements the <code class="inlinecode">Customer</code> interface to allow customer data to <a id="_idIndexMarker973" class="calibre3"/>be stored by Sequelize. To tell Sequelize how to initialize the model class, add a file named <code class="inlinecode">customer_helpers.ts</code> to the <code class="inlinecode">src/data/orm/models</code> folder with the content shown in <em class="italic">Listing 18.6</em>.</p>
<p class="packt_figref">Listing 18.6: The contents of the customer_helpers.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { CustomerModel } from "./customer_models";
export const initializeCustomerModels = (sequelize: Sequelize) =&gt; {
    CustomerModel.init({
        id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true},
        name: { type: DataTypes.STRING},       
        email: { type: DataTypes.STRING }
    }, { sequelize})
}
</code></pre>
<p class="normal">The <code class="inlinecode">initializeCustomerModels</code> function initializes the <code class="inlinecode">CustomerModel</code> class and specifies the SQL datatype and configuration for each model property.</p>
<h3 class="heading2" id="_idParaDest-317">Creating the order models</h3>
<p class="normal1">To <a id="_idIndexMarker974" class="calibre3"/>create the implementations of the interfaces that describe an order, add a file named <code class="inlinecode">order_models.ts</code> to the <code class="inlinecode">server/data/orm/models</code> folder, with the content shown in <em class="italic">Listing 18.7</em>.</p>
<p class="packt_figref">Listing 18.7: The contents of the order_models.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { Model, CreationOptional, ForeignKey, InferAttributes,
    InferCreationAttributes, 
    HasManySetAssociationsMixin} from "sequelize";
import { ProductModel } from "./catalog_models";
import { CustomerModel } from "./customer_models";
import { Address, Order, ProductSelection } from "../../order_models";
export class OrderModel extends Model&lt;InferAttributes&lt;OrderModel&gt;,
        InferCreationAttributes&lt;OrderModel&gt;&gt; implements Order {
    declare id?: CreationOptional&lt;number&gt;;
    declare shipped: boolean;
    declare customerId: ForeignKey&lt;CustomerModel["id"]&gt;;
    declare customer?: InferAttributes&lt;CustomerModel&gt;
    declare addressId: ForeignKey&lt;AddressModel["id"]&gt;;
    declare address?: InferAttributes&lt;AddressModel&gt;;
   
    declare selections?:  InferAttributes&lt;ProductSelectionModel&gt;[];
    declare setSelections:
        HasManySetAssociationsMixin&lt;ProductSelectionModel, number&gt;;
}
export class ProductSelectionModel extends
        Model&lt;InferAttributes&lt;ProductSelectionModel&gt;,
            InferCreationAttributes&lt;ProductSelectionModel&gt;&gt;
        implements ProductSelection {
    declare id?: CreationOptional&lt;number&gt;;
   
    declare productId: ForeignKey&lt;ProductModel["id"]&gt;;
    declare product?: InferAttributes&lt;ProductModel&gt;
    declare quantity: number;
    declare price: number;
    declare orderId: ForeignKey&lt;OrderModel["id"]&gt;;
    declare order?: InferAttributes&lt;OrderModel&gt;;
}
export class AddressModel extends Model&lt;InferAttributes&lt;AddressModel&gt;,
    InferCreationAttributes&lt;AddressModel&gt;&gt; implements Address {
    declare id?: CreationOptional&lt;number&gt;;
    declare street: string;
    declare city: string;
    declare state: string;
    declare zip: string;
}
</code></pre>
<p class="normal">The model<a id="_idIndexMarker975" class="calibre3"/> classes use Sequelize features described in earlier examples and implement the <code class="inlinecode">Order</code>, <code class="inlinecode">ProductSelection</code>, and <code class="inlinecode">Address</code> interfaces. As noted in earlier chapters, it can be a fiddly process to get the data model just right, and I find it easier to define the model classes and the helper code that initializes them at the same time. Add a file named <code class="inlinecode">order_helpers.ts</code> to the <code class="inlinecode">server/data/orm/models</code> folder with the content shown in <em class="italic">Listing 18.8</em>.</p>
<p class="packt_figref">Listing 18.8: The contents of the order_helpers.ts file in the server/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { DataTypes, Sequelize } from "sequelize";
import { OrderModel, ProductSelectionModel, AddressModel }
    from "./order_models";
import { CustomerModel } from "./customer_models";
import { ProductModel } from ".";
const primaryKey = {
    id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true }
};
   
export const initializeOrderModels = (sequelize: Sequelize) =&gt; {
    OrderModel.init({
        ...primaryKey, shipped: DataTypes.BOOLEAN
    }, {sequelize});
    ProductSelectionModel.init({
        ...primaryKey,
        quantity: DataTypes.INTEGER, price: DataTypes.DECIMAL(10, 2)
    }, {sequelize});
    AddressModel.init({
        ...primaryKey,
        street: DataTypes.STRING, city: DataTypes.STRING,
        state: DataTypes.STRING, zip: DataTypes.STRING,
    }, {sequelize});
    OrderModel.belongsTo(CustomerModel, { as: "customer"});
    OrderModel.belongsTo(AddressModel,
        {foreignKey: "addressId", as: "address"});
    OrderModel.belongsToMany(ProductSelectionModel,
        { through: "OrderProductJunction",
            foreignKey: "orderId", as: "selections" });
    ProductSelectionModel.belongsTo(ProductModel, { as: "product"});
}
</code></pre>
<p class="normal">In addition <a id="_idIndexMarker976" class="calibre3"/>to initializing the model classes, the <code class="inlinecode">initializeOrderModels</code> function describes the relationship between them, which shapes the structure of the database tables that will be created to store the data.</p>
<p class="normal">As noted in <em class="italic">Chapter 15</em>, Sequelize adds methods to model classes that allow related data to be managed. This is done using the same mixin technique I used to build up the repository in <em class="italic">Chapter 16</em>. One of the methods that will be created as a consequence of the one-to-many relationship between the <code class="inlinecode">ProductSelectionModel</code> and <code class="inlinecode">OrderModel</code> classes will be named <code class="inlinecode">setSelections</code>, which is why I added this <code class="inlinecode">declare</code> statement to the <code class="inlinecode">OrderModel</code> class:</p>
<pre class="programlisting"><code class="hljs-code">...
declare <strong class="screentext">setSelections</strong>: HasManySetAssociationsMixin&lt;ProductSelectionModel, number&gt;;
...
</code></pre>
<p class="normal"><code class="inlinecode">Sequelize</code> adds methods for all of the model properties, but this is the only one that I need for the SportsStore application. Therefore, it is the only one for which I added a <code class="inlinecode">declare</code> statement. <em class="italic">Listing 18.9</em> invokes the <code class="inlinecode">initializeCustomerModels</code> and <code class="inlinecode">initializeOrderModels</code> functions so that the model classes are initialized alongside <a id="_idIndexMarker977" class="calibre3"/>those used by the product catalog.</p>
<p class="packt_figref">Listing 18.9: Initializing models in the index.ts file in the src/data/orm/models folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize } from "sequelize";
import { initializeCatalogModels } from "./catalog_helpers";
<strong class="screentext">import { initializeCustomerModels } from "./customer_helpers";</strong>
<strong class="screentext">import { initializeOrderModels } from "./order_helpers";</strong>
export { ProductModel, CategoryModel, SupplierModel } from "./catalog_models";
export const initializeModels = (sequelize: Sequelize) =&gt; {
    initializeCatalogModels(sequelize);
   <strong class="screentext"> </strong><strong class="screentext">initializeCustomerModels(sequelize);</strong>
<strong class="screentext">    initializeOrderModels(sequelize);</strong>
}
</code></pre>
<p class="normal">The <code class="inlinecode">initializeModels</code> function now initializes all three categories of model classes used by the application.</p>
<h2 class="heading1" id="_idParaDest-318">Implementing the repository</h2>
<p class="normal1">The<a id="_idIndexMarker978" class="calibre3"/> next step is to create implementations of the methods defined by the <code class="inlinecode">OrderRepository</code> interface. Add a file named <code class="inlinecode">order_queries.ts</code> to the <code class="inlinecode">src/data/orm</code> folder with the content shown in <em class="italic">Listing 18.10</em>. </p>
<p class="packt_figref">Listing 18.10: The contents of the order_queries.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { Attributes, FindOptions } from "sequelize";
import { Order } from "../order_models"
import { BaseRepo, Constructor } from "./core"
import { AddressModel, OrderModel } from "./models/order_models";
import { CustomerModel } from "./models/customer_models";
const queryConfig: FindOptions&lt;Attributes&lt;OrderModel&gt;&gt; = {
    include: [
        { model: AddressModel, as: "address"},
        { model: CustomerModel, as: "customer" }
    ],
    raw: true, nest: true
}
export function AddOrderQueries&lt;TBase
        extends Constructor&lt;BaseRepo&gt;&gt;(Base: TBase)  {
    return class extends Base {
        getOrder(id: number) : Promise&lt;Order | null&gt; {
            return OrderModel.findByPk(id, queryConfig);
        }
        getOrders(excludeShipped: boolean): Promise&lt;Order[]&gt; {
            return OrderModel.findAll(
                excludeShipped ?
                    { ...queryConfig, where: { shipped: false}} : queryConfig
            )           
        }
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">AddOrderQueries</code> function <a id="_idIndexMarker979" class="calibre3"/>returns a class that implements the <code class="inlinecode">getOrder</code> and <code class="inlinecode">getOrders</code> methods required by the <code class="inlinecode">OrderRepository</code> interface. To keep queries consistent, I have used the types provided by Sequelize to describe the options used to query the database. Query options for <code class="inlinecode">OrderModel</code> data are described using the <code class="inlinecode">FindOptions&lt;Attributes&lt;OrderModel&gt;&gt;</code> type. The <code class="inlinecode">queryConfig</code> object uses the <code class="inlinecode">include</code> property to incorporate related <code class="inlinecode">AddressModel</code> and <code class="inlinecode">CustomerModel</code> data in the results and sets the <code class="inlinecode">raw</code> and <code class="inlinecode">nest</code> properties to specify the format of the results. To implement the remaining interface method, add a file named <code class="inlinecode">order_storage.ts</code> to the <code class="inlinecode">src/data/orm</code> folder with the content shown in <em class="italic">Listing 18.11</em>.</p>
<p class="packt_figref">Listing 18.11: The contents of the order_storage.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { Order } from "../order_models"
import { BaseRepo, Constructor } from "./core"
import { AddressModel, OrderModel, ProductSelectionModel }
    from "./models/order_models";
import { CustomerModel } from "./models/customer_models";
export function AddOrderStorage&lt;TBase extends
        Constructor&lt;BaseRepo&gt;&gt;(Base: TBase)  {
    return class extends Base {
        storeOrder(order: Order): Promise&lt;Order&gt; {
            return  this.sequelize.transaction(async (transaction) =&gt; {
                const { id, shipped } = order;
                const [stored] =
                    await OrderModel.upsert({ id, shipped }, {transaction});
               
                if (order.customer) {
                    const [{id}] = await CustomerModel.findOrCreate({
                        where: { email: order.customer.email},
                        defaults: order.customer,
                        transaction
                    });
                    stored.customerId = id;
                }
                if (order.address) {
                   
                    const [{id}] = await AddressModel.findOrCreate({
                        where: { ...order.address },
                        defaults: order.address,
                        transaction
                    });
                    stored.addressId = id;
                }
                await stored.save({transaction});
                if (order.selections) {
                    const sels = await ProductSelectionModel.bulkCreate(
                        order.selections, { transaction});
                    await stored.setSelections(
                        sels, { transaction });
                }
                return stored;
            });
        }
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">Sequelize</code> <code class="inlinecode">upsert</code> method<a id="_idIndexMarker980" class="calibre3"/> is used to update or create the order, customer, and address data. The product selections are stored using the <code class="inlinecode">bulkCreate</code> method, which allows multiple rows to be stored in a single operation, and the <code class="inlinecode">mixin</code> <code class="inlinecode">setSelections</code> method is used to associate the stored product selections with the order. These operations are all performed within the same transaction to ensure data consistency. <em class="italic">Listing 18.12</em> uses the JavaScript <code class="inlinecode">mixin</code> feature to incorporate the order functionality into the combined repository class.</p>
<p class="packt_figref">Listing 18.12: Adding orders to the index.ts file in the src/data/orm folder</p>
<pre class="programlisting"><code class="hljs-code">import { BaseRepo } from "./core";
import { AddQueries } from "./queries";
import { AddStorage } from "./storage";
<strong class="screentext">import { AddOrderQueries</strong><strong class="screentext"> } from "./order_queries";</strong>
<strong class="screentext">import { AddOrderStorage } from "./order_storage";</strong>
<strong class="screentext">const CatalogRepo = AddStorage(</strong><strong class="screentext">AddQueries(BaseRepo));</strong>
<strong class="screentext">const RepoWithOrders = AddOrderStorage(AddOrderQueries(CatalogRepo));</strong>
<strong class="screentext">export const CatalogRepoImpl</strong><strong class="screentext"> = RepoWithOrders;</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">CatalogRepoImpl</code> class exported from this module implements the methods required by the <code class="inlinecode">CatalogRepository</code> and <code class="inlinecode">OrderRepository</code> interfaces. Even though a single class implements all repository methods, I prefer to present the functionality separately to the rest of the application, as shown in <em class="italic">Listing 18.13</em>.</p>
<p class="packt_figref">Listing 18.13: Creating the repository in the index.ts file in the src/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { CatalogRepository } from "./catalog_repository";
import { CatalogRepoImpl} from "./orm";
<strong class="screentext">import { OrderRepository } from "./order_repository";</strong>
<strong class="screentext">const repo = </strong><strong class="screentext">new CatalogRepoImpl();</strong>
<strong class="screentext">export const catalog_repository: CatalogRepository = repo;</strong>
<strong class="screentext">export const order_repository: OrderRepository</strong><strong class="screentext"> = repo;</strong>
</code></pre>
<p class="normal">The<a id="_idIndexMarker981" class="calibre3"/> TypeScript type annotations will ensure that each of the constants exported by this module will present only the methods defined by one of the repository interfaces.</p>
<h1 class="heading" id="_idParaDest-319">Implementing the order flow</h1>
<p class="normal1">Now that <a id="_idIndexMarker982" class="calibre3"/>the data model<a id="_idIndexMarker983" class="calibre3"/> extends to describe and store order data, the next step is to create the workflow that allows orders to be created and stored.</p>
<h2 class="heading1" id="_idParaDest-320">Validating data</h2>
<p class="normal1">The <a id="_idIndexMarker984" class="calibre3"/>process of creating an order requires data from the user, which will be validated before it is used and stored. To install the validation package and its TypeScript descriptions, use a command prompt to run the commands shown in <em class="italic">Listing 18.14</em> in the <code class="inlinecode">sportsstore</code> folder. </p>
<p class="packt_figref">Listing 18.14: Installing the validation packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install validator@13.11.0
npm install --save-dev @types/validator@13.11.5
</code></pre>
<p class="normal">These packages are described in <em class="italic">Table 18.1</em> for quick reference.</p>
<p class="packt_figref">Table 18.1: The validation packages</p>
<table class="table-container" id="table001-15">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">validator</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains validators for common data types.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">@types/validator</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This package contains TypeScript descriptions of the validator API.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">To start the<a id="_idIndexMarker985" class="calibre3"/> validation functionality, create the <code class="inlinecode">src/data/validation</code> folder and add to it a file named <code class="inlinecode">validation_types.ts</code> with the content shown in <em class="italic">Listing 18.15</em>.</p>
<p class="packt_figref">Listing 18.15: The contents of the validation_types.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">export class ValidationStatus {
    private invalid: boolean = false;
    constructor(public readonly value: any) {}
    get isInvalid() : boolean  {
        return this.invalid
    }
    setInvalid(newValue: boolean) {
        this.invalid = newValue || this.invalid;
    }
   
    messages: string[] = [];
}
export type ValidationRule = (status: ValidationStatus)
    =&gt; void | Promise&lt;void&gt;;
export type ValidationRuleSet&lt;T&gt; = {
    [key in keyof Omit&lt;Required&lt;T&gt;, "id"&gt;]: ValidationRule | ValidationRule[];
}
export type ValidationResults&lt;T&gt; = {
    [key in keyof Omit&lt;Required&lt;T&gt;, "id"&gt;]: ValidationStatus;
}
</code></pre>
<p class="normal">The <code class="inlinecode">ValidationStatus</code> class represents the validation status of a single model property, which will allow rules to validate the data. The <code class="inlinecode">ValidationRule</code> type describes a rule that receives a <code class="inlinecode">ValidationStatus</code> object and validates the data value it defines. The validity of a value can be set using the <code class="inlinecode">setInvalid</code> method defined by the <code class="inlinecode">ValidationStatus</code> class, which latches so that once a value has been <a id="_idIndexMarker986" class="calibre3"/>marked as <code class="inlinecode">invalid</code>, it cannot be returned to the <code class="inlinecode">valid</code> state by another rule. </p>
<p class="normal">The <code class="inlinecode">ValidationRuleSet&lt;T&gt;</code> type describes the set of rules that are applied to a model class, <code class="inlinecode">T</code>. Each property defined by the model class must have at least one validation rule. </p>
<p class="normal">The <code class="inlinecode">ValidationResults&lt;T&gt;</code> type describes the validation results for a model object, with a <code class="inlinecode">ValidationStatus</code> object defined for each model property.</p>
<p class="normal">The <code class="inlinecode">ValidationRuleSet&lt;T&gt;</code> and <code class="inlinecode">ValidationResults&lt;T&gt;</code> types use the TypeScript utility types to describe how validation requirements and results are expressed for models:</p>
<pre class="programlisting"><code class="hljs-code">...
 [key in keyof <strong class="screentext">Omit&lt;Required&lt;T&gt;, "id"&gt;</strong>]: ValidationRule | ValidationRule[];
...
</code></pre>
<p class="normal">This incantation tells the TypeScript compiler that properties are required for each property defined by the type <code class="inlinecode">T</code>, including optional properties, except for the property named <code class="inlinecode">id</code>. TypeScript provides a range of useful utility types (described at <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" class="calibre3">https://www.typescriptlang.org/docs/handbook/utility-types.html</a>) that can be used to describe how one type relates to another and, in this case, the effect is that validation requirements and results are comprehensive.</p>
<p class="normal">Add a file named <code class="inlinecode">validator.ts</code> to the <code class="inlinecode">src/data/validation</code> folder with the contents shown in <em class="italic">Listing 18.16</em>.</p>
<p class="packt_figref">Listing 18.16: The contents of the validator.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">import { ValidationResults, ValidationRule, ValidationRuleSet,
    ValidationStatus } from "./validation_types";
export class Validator&lt;T&gt;{
    constructor(public rules: ValidationRuleSet&lt;T&gt;,
        public breakOnInvalid = true) {}
        async validate(data: any): Promise&lt;ValidationResults&lt;T&gt;&gt; {
            const vdata = Object.entries(this.rules).map(async ([key, rules]) =&gt; {
                const status = new ValidationStatus(data?.[key] ?? "");
                const rs = (Array.isArray(rules) ? rules: [rules]);
                for (const r of rs) {
                    if (!status.isInvalid || !this.breakOnInvalid) {
                        await r(status);
                    }
                }
                return [key, status];
            });
            const done = await Promise.all(vdata);
            return Object.fromEntries(done);
        }
    validateOriginal(data: any): ValidationResults&lt;T&gt; {
        const vdata = Object.entries(this.rules).map(([key, rules]) =&gt; {
            const status = new ValidationStatus(data?.[key] ?? "");
            (Array.isArray(rules) ? rules: [rules])
                .forEach(async (rule: ValidationRule) =&gt; {
                    if (!status.isInvalid || !this.breakOnInvalid) {
                        await rule(status);
                    }
            });
            return [key, status];
        });
        return Object.fromEntries(vdata);
    }
}
export function isValid&lt;T&gt;(result: ValidationResults&lt;T&gt;) {
    return Object.values&lt;ValidationStatus&gt;(result)
        .every(r =&gt; r.isInvalid === false);
}
export function getData&lt;T&gt;(result: ValidationResults&lt;T&gt;): T {
    return Object.fromEntries (Object.entries&lt;ValidationStatus&gt;(result)
        .map(([key, status]) =&gt; [key, status.value])) as T;
}
</code></pre>
<p class="normal">The <code class="inlinecode">Validator&lt;T&gt;</code> class<a id="_idIndexMarker987" class="calibre3"/> provides validation for the model type <code class="inlinecode">T</code>. The constructor parameters are a <code class="inlinecode">ValidationRuleSet&lt;T&gt;</code> value that provides the rules to apply and a <code class="inlinecode">boolean</code> argument that specifies whether validation for a property will stop after the rule reports whether a value is invalid, or whether validation will continue to apply all of the rules.</p>
<p class="normal">The <code class="inlinecode">validate</code> method accepts a value to validate, applies the rules, and builds a <code class="inlinecode">ValidationResult&lt;T&gt;</code> object that describes the outcome. <em class="italic">Listing 18.16</em> includes a utility function named <code class="inlinecode">isValid</code> that checks the validation results produced for a value and determines whether all of the properties are valid. The <code class="inlinecode">getData</code> method extracts the data from the validation results, which will be used to ensure that the application only uses properties for which validation rules have been defined and values that have passed validation.</p>
<h3 class="heading2" id="_idParaDest-321">Defining validation rules</h3>
<p class="normal1">To<a id="_idIndexMarker988" class="calibre3"/> create the basic validation rules for properties, add a file named <code class="inlinecode">basic_rules.ts</code> to the <code class="inlinecode">src/data/validation</code> folder with the content shown in <em class="italic">Listing 18.17</em>. </p>
<p class="packt_figref">Listing 18.17: The contents of the basic_rules.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">import validator from "validator";
import { ValidationStatus } from "./validation_types";
export const minLength = (min: number) =&gt; (status: ValidationStatus) =&gt; {
    if (!validator.isLength(status.value, { min })) {
        status.setInvalid(true);
        status.messages.push(`Enter at least ${min} characters`);
    }
};
export const email = (status: ValidationStatus) =&gt; {
    if (!validator.isEmail(status.value)) {
        status.setInvalid(true);
        status.messages.push("Enter an email address");
    }
};
export const required = (status: ValidationStatus) =&gt; {
    if (validator.isEmpty(status.value.toString(), { ignore_whitespace: true})) {
        status.setInvalid(true);
        status.messages.push("A value is required");
    }
};
export const no_op = (status: ValidationStatus) =&gt; { /* do nothing */ }
</code></pre>
<p class="normal">The <code class="inlinecode">minLength</code>, <code class="inlinecode">email</code>, and <code class="inlinecode">required</code> functions ensure that a value has a minimum length, is a <a id="_idIndexMarker989" class="calibre3"/>correctly formatted email address, and that a value isn’t undefined or an empty string. All three functions use the features provided by the <code class="inlinecode">validator</code> package. The <code class="inlinecode">no_op</code> function doesn’t perform any validation and is a consequence of requiring validation rules for every property defined by a model class except the <code class="inlinecode">id</code> property: some properties won’t require validation but must be included in the validation configuration, and the <code class="inlinecode">no_op</code> (short for <em class="italic">no operation</em>) function can be used.</p>
<p class="normal">To describe the validation requirements for the data the user will provide for orders, add a file named <code class="inlinecode">order_rules.ts</code> to the <code class="inlinecode">src/data/validation</code> folder with the content shown in <em class="italic">Listing 18.18</em>.</p>
<p class="packt_figref">Listing 18.18: The contents of the order_rules.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">import { Validator } from "./validator";
import { required, minLength, email, no_op } from "./basic_rules";
import { Address } from "../order_models";
import { Customer } from "../customer_models";
export const CustomerValidator = new Validator&lt;Customer&gt;({
    name: [required, minLength(6)],
    email: email
});
export const AddressValidator = new Validator&lt;Address&gt;({
    street: required,
    city: required,
    state: required,
    zip: no_op
});
</code></pre>
<p class="normal"><em class="italic">Listing 18.18</em> defines the validation rules for the <code class="inlinecode">Customer</code> and <code class="inlinecode">Address</code> model types, which <a id="_idIndexMarker990" class="calibre3"/>will be combined with the contents of the user’s cart to create an order. Notice that the <code class="inlinecode">zip</code> property for addresses uses the <code class="inlinecode">no_op</code> rule, which tells the validator that this property is optional and has no specific validation requirements.</p>
<p class="normal">This is a more comprehensive way to define validation than the approach I used in <em class="italic">Part 2</em> of this book because it uses TypeScript to ensure that validation requirements are specified for every property defined by a type, except for the <code class="inlinecode">id</code> property, which I have omitted because I generally want to let the database figure out what IDs are required for objects. </p>
<p class="normal">When an id value is provided by the client, I will validate it separately from the rest of the data. To complete the validation feature, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">src/data/validation</code> folder with the content shown in <em class="italic">Listing 18.19</em>.</p>
<p class="packt_figref">Listing 18.19: The contents of the index.ts file in the src/data/validation folder</p>
<pre class="programlisting"><code class="hljs-code">export * from "./validation_types";
export * from "./validator";
export * from "./basic_rules";
export * from "./order_rules";
</code></pre>
<p class="normal">This file simply exports the contents of the other files in the validation folder so the contents can be consumed more easily by the rest of the application.</p>
<h2 class="heading1" id="_idParaDest-322">Creating the HTTP handlers</h2>
<p class="normal1">The <a id="_idIndexMarker991" class="calibre3"/>next step is to define the three HTTP handlers that will be used to complete the order process: a <code class="inlinecode">GET</code> handler that renders an HTML form for collecting the user’s details, a <code class="inlinecode">POST</code> handler that receives and validates the user’s details, and a <code class="inlinecode">GET</code> handler that displays a summary message once the order has been completed. Add a file named <code class="inlinecode">orders.ts</code> to the <code class="inlinecode">src/routes </code>folder with the content shown in <em class="italic">Listing 18.20</em>.</p>
<p class="packt_figref">Listing 18.20: The contents of the orders.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { Address } from "../data/order_models";
import { AddressValidator, CustomerValidator, ValidationResults, getData, isValid }
    from "../data/validation";
import { Customer } from "../data/customer_models";
import { createAndStoreOrder } from "./order_helpers";
declare module "express-session" {
    interface SessionData {
       orderData?: {
            customer?: ValidationResults&lt;Customer&gt;,
            address?: ValidationResults&lt;Address&gt;
       }
    }
}
export const createOrderRoutes = (app: Express) =&gt; {
    app.get("/checkout", (req, resp) =&gt; {
        resp.render("order_details", {
            order: req.session.orderData,
        });
    });
    app.post("/checkout", async (req, resp) =&gt; {
        const { customer, address } = req.body;
        const data = req.session.orderData = {
            customer: await CustomerValidator.validate(customer),
            address: await AddressValidator.validate(address)
        };
        if (isValid(data.customer) &amp;&amp; isValid(data.address)
                &amp;&amp; req.session.cart) {
            const order = await createAndStoreOrder(
                getData(data.customer), getData(data.address), req.session.cart
            )
            resp.redirect(`/checkout/${order.id}`);
            req.session.cart = undefined;
            req.session.orderData = undefined;
        } else {
            resp.redirect("/checkout");
        }
    });
    app.get("/checkout/:id", (req, resp) =&gt; {
        resp.render("order_complete", {id: req.params.id});
    })
}
</code></pre>
<p class="normal">The <code class="inlinecode">declare</code> statement tells TypeScript that the session will be used to store an object using the name <code class="inlinecode">orderData</code>, with <code class="inlinecode">customer</code> and <code class="inlinecode">address</code> properties whose values are validation results.</p>
<p class="normal">The<a id="_idIndexMarker992" class="calibre3"/> first handler accepts <code class="inlinecode">GET</code> requests sent to the <code class="inlinecode">/checkout</code> URL and responds by rendering a template named <code class="inlinecode">order_details</code>, passing the <code class="inlinecode">customer</code> and <code class="inlinecode">address</code> data stored in the session as context data. </p>
<p class="normal">This template renders the HTML form, which will be empty the first time the user sends a <code class="inlinecode">GET</code> request because no customer or address data has been stored in the session.</p>
<p class="normal">The second handler accepts <code class="inlinecode">POST</code> requests to the <code class="inlinecode">/checkout</code> URL, where the customer and address data is read from the request and validated, like this:</p>
<pre class="programlisting2"><code class="hljs-code">...
</code></pre>
<pre class="programlisting"><code class="hljs-code">const data = req.session.orderData = {
    customer: await CustomerValidator.<strong class="screentext">validate</strong>(customer),
    address: await AddressValidator.<strong class="screentext">validate</strong>(address)
};
...
</code></pre>
<p class="normal">The <code class="inlinecode">through</code> assignment used in this statement ensures that the validation results are stored in the session and stored in a local constant named <code class="inlinecode">data</code>, just for ease of use.</p>
<p class="normal">If the<a id="_idIndexMarker993" class="calibre3"/> data is invalid, a redirection to the <code class="inlinecode">/checkout</code> URL renders the form but, this time, there will be validation data for the template to display to give the user feedback.</p>
<p class="normal">If the data is valid, then an order is created by calling a function called <code class="inlinecode">createAndStoreOrder</code>, which is defined in <em class="italic">Listing 18.21</em>, and combines the customer and address data with the contents of the user’s cart to create and store an order. The data passed to the <code class="inlinecode">createAndStoreOrder</code> function is extracted from the validation results, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
const order = await createAndStoreOrder(
    <strong class="screentext">getData</strong>(data.customer), <strong class="screentext">getData</strong>(data.address), req.session.cart
)
...
</code></pre>
<p class="normal">This ensures that only the properties defined by the model types are used, which is one of the reasons why the validation types defined earlier in the chapter require validation information for every model property. Once the order is stored, a redirection to the third handler is performed, which includes the ID of the order in the URL, and which can be used to display a confirmation message to the user. The <code class="inlinecode">cart</code>, customer, and address data are removed from the session so that the user can start shopping afresh.</p>
<p class="normal">To define the function that combines the customer, address, and cart data and stores the order, add a file named <code class="inlinecode">order_helpers.ts</code> to the <code class="inlinecode">src/routes</code> folder with the content shown in <em class="italic">Listing 18.21</em>.</p>
<p class="packt_figref">Listing 18.21: The contents of the order_helpers.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { catalog_repository, order_repository } from "../data";
import { Cart } from "../data/cart_models"
import { Customer } from "../data/customer_models"
import { Address, Order } from "../data/order_models"
export const createAndStoreOrder = async (customer: Customer,
        address: Address, cart: Cart): Promise&lt;Order&gt; =&gt; {
    const product_ids = cart.lines.map(l =&gt; l.productId) ?? [];
    const product_details = Object.fromEntries((await
        catalog_repository.getProductDetails(product_ids))
            .map(p =&gt; [p.id ?? 0, p.price ?? 0]));
    const selections = cart.lines.map(l =&gt; ({
        productId: l.productId, quantity: l.quantity,
        price: product_details[l.productId]}));
    return order_repository.storeOrder({   
        customer,address,
        selections, shipped: false
    });
}
</code></pre>
<p class="normal">Example<a id="_idIndexMarker994" class="calibre3"/> applications usually contrive to avoid the messy reality of merging and formatting data, but it is something that should be expected in every project. In this case, the cart data has to be matched up with product prices, which is an awkward process that requires awkward code.</p>
<p class="normal">There is often an “Oh, no!” moment when reaching the point where you realize that the data you have isn’t the data you need, and that additional queries and transforms are required. It can be tempting to go back and smooth out the rough edges in the data model, but my advice is not to do that because it just breaks up the problem so that none of the data models exactly suit their purpose, which leaves little bits of awkwardness all over the place. Instead, my preference is to define each model so that it suits the part of the application that it serves and accept that there will be crunch points where data from one part of the application is bent into the shape required by another part. <em class="italic">Listing 18.22</em> enables the routes required for orders.</p>
<p class="packt_figref">Listing 18.22: Enabling routes in the index.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createCatalogRoutes } from "./catalog";
import { createCartMiddleware, createCartRoutes } from "./cart";
<strong class="screentext">import { createOrderRoutes } from "./orders";</strong>
export const createRoutes = (app: Express) =&gt; {
    createCartMiddleware(app);
    createCatalogRoutes(app);
    createCartRoutes(app);
   <strong class="screentext"> createOrderRoutes(app);</strong>
}
</code></pre>
<h2 class="heading1" id="_idParaDest-323">Creating the templates and helpers</h2>
<p class="normal1">New<a id="_idIndexMarker995" class="calibre3"/> template helpers are required to render the order form. Add a file named <code class="inlinecode">order_helpers.ts</code> to the <code class="inlinecode">src/helpers</code> folder, with the content shown in <em class="italic">Listing 18.23</em>. </p>
<p class="packt_figref">Listing 18.23: The contents of the order_helpers.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">export const toArray = (...args: any[]) =&gt; args.slice(0, -1);
export const lower = (val: string) =&gt; val.toLowerCase();
export const getValue = (val: any, prop: string) =&gt;
    val?.[prop.toLowerCase()] ?? {};
export const get = (val: any) =&gt; val ?? {};
</code></pre>
<p class="normal">The purpose of each helper will be explained as they are used, but they all manipulate data values so they can be included in the template output. <em class="italic">Listing 18.24</em> enables the new helpers.</p>
<p class="packt_figref">Listing 18.24: Adding helpers to the index.ts file in the src/helpers folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { getConfig } from "../config";
import { engine } from "express-handlebars";
import * as env_helpers from "./env";
import * as catalog_helpers from "./catalog_helpers";
import * as cart_helpers from "./cart_helpers";
<strong class="screentext">import * as order_helpers from "./order_helpers";</strong>
const location = getConfig("templates:location");
const config = getConfig("templates:config");
export const createTemplates = (app: Express) =&gt; {
    app.set("views", location);
    app.engine("handlebars", engine({
        ...config,
       <strong class="screentext"> helpers: {...env_helpers, ...catalog_helpers, ...cart_helpers,</strong>
<strong class="screentext">                    ...order_helpers}</strong>
    }));
    app.set("view engine", "handlebars");
}
</code></pre>
<p class="normal">Starting <a id="_idIndexMarker996" class="calibre3"/>with the simplest templates, add a file named <code class="inlinecode">order_complete.handlebars</code> to the <code class="inlinecode">templates</code> folder with the content shown in <em class="italic">Listing 18.25</em>.</p>
<p class="packt_figref">Listing 18.25: The contents of the order_complete.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="text-center m-2"&gt;
    &lt;h2&gt;Thanks!&lt;/h2&gt;
    &lt;p&gt;Thanks for placing order #{{ id }}&lt;/p&gt;
    &lt;p&gt;We'll ship your goods as soon as possible.&lt;/p&gt;
    &lt;a class="btn btn-primary" href="/"&gt;Return to Store&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">This template displays a simple confirmation message once an order has been placed, which includes the order ID value. The remaining templates relate to the form used to collect the customer and address data and present validation feedback. Add a file named <code class="inlinecode">validation_messages.handlebars</code> to the <code class="inlinecode">templates</code> folder, with the content shown in <em class="italic">Listing 18.26</em>.</p>
<p class="packt_figref">Listing 18.26: The contents of the validation_messages.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">{{#each this }}
    &lt;div class="text-danger"&gt;{{ this }}&lt;/div&gt;
{{/each }}
</code></pre>
<p class="normal">The<a id="_idIndexMarker997" class="calibre3"/> template will receive an array of strings that are displayed using the <code class="inlinecode">each</code> expression, referring to the current string value with <code class="inlinecode">this</code>. To create the form elements for the user’s name and email address, which are required for the <code class="inlinecode">Customer</code> data, add a file named <code class="inlinecode">order_details_customer.handlebars</code> to the <code class="inlinecode">templates</code> folder with the content shown in <em class="italic">Listing 18.27</em>.</p>
<p class="packt_figref">Listing 18.27: The contents of the order_details_customer.handlebars in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="m-2"&gt;
    &lt;h3&gt;Your details:&lt;/h3&gt;
    &lt;div class="form-group"&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        {{#with (get order.customer.name) }}
            &lt;input name="customer[name]" class="form-control"
                value="{{ value }}"&gt;
            {{#if invalid}}
                {{&gt; validation_messages messages }}
            {{/if }}
        {{/with }}
    &lt;/div&gt;
        &lt;div class="form-group"&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        {{#with (get order.customer.email)}}
            &lt;input name="customer[email]" class="form-control"
                value="{{ value }}"&gt;
            {{#if invalid }}
                {{&gt; validation_messages messages }}
            {{/if }}
        {{/with}}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">The template duplicates the same set of elements for each value and relies on a combination of template engine features and helpers that require explanation.</p>
<p class="normal">The built-in <code class="inlinecode">with</code> helper is used to change the context, which can simplify nested expressions, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{{#with <strong class="screentext">order.customer.name</strong> }}
    &lt;input name="customer[name]" class="form-control" value="{{ <strong class="screentext">value</strong> }}"&gt;
...
</code></pre>
<p class="normal">The <code class="inlinecode">with</code> helper is<a id="_idIndexMarker998" class="calibre3"/> used to change the context to the <code class="inlinecode">order.customer.name</code> value, so that the <code class="inlinecode">value</code> expression is evaluated as <code class="inlinecode">order.customer.name.value</code>. The <code class="inlinecode">with</code> helper won’t render content if its expression is undefined, which presents a problem the first time that the template is rendered because the user’s session doesn’t contain this value until after the first time the form is evaluated. To solve this, the <code class="inlinecode">get</code> helper defined in <em class="italic">Listing 18.23</em> is used, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{{#with (<strong class="screentext">get order.customer.name</strong>) }}
...
</code></pre>
<p class="normal">The parentheses denote a subexpression, which the template engine evaluates to obtain the argument for the <code class="inlinecode">with</code> helper. The <code class="inlinecode">get</code> helper returns an empty object if a value is not defined, which ensures the content contained by the <code class="inlinecode">with</code> helper is always rendered.</p>
<p class="normal">To create the form elements for the user’s address, add a file named <code class="inlinecode">order_details_address.handlebars</code> to the <code class="inlinecode">templates</code> folder, with the content shown in <em class="italic">Listing 18.28</em>.</p>
<p class="packt_figref">Listing 18.28: The contents of order_details_address.handlebars in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="m-2"&gt;
    &lt;h3&gt;Ship to:&lt;/h3&gt;       
    {{#each (toArray "Street" "City" "State" "Zip") }}
        {{#with (getValue ../order.address this) }}
            &lt;div class="form-group"&gt;
                &lt;label&gt;{{ ../this }}:&lt;/label&gt;
                &lt;input name="address[{{lower ../this}}]" class="form-control"
                    value="{{value}}"&gt;
            &lt;/div&gt;
            {{#unless valid}}
                {{&gt; validation_messages messages }}
            {{/unless}}
        {{/with}}
    {{/each}}
&lt;/div&gt;
</code></pre>
<p class="normal">Unlike the <a id="_idIndexMarker999" class="calibre3"/>previous template, which repeated the same content for each data property, this template generates elements programmatically, using the values in an array:</p>
<pre class="programlisting"><code class="hljs-code">...
{{#each (toArray "Street" "City" "State" "Zip") }}
...
</code></pre>
<p class="normal">The built-in <code class="inlinecode">each</code> helper repeats sections of content but doesn’t have support for literal arrays. This shortcoming is addressed by the <code class="inlinecode">toArray</code> helper, which accepts a series of arguments and combines them into an array that can be processed by the <code class="inlinecode">each</code> helper.</p>
<p class="normal">The built-in <code class="inlinecode">with</code> helper is used to change the context to the data values required for each of the form fields. The <code class="inlinecode">getValue</code> helper is used to produce the value for the <code class="inlinecode">with</code> helper, which is done by looking up a property on a source object. The <code class="inlinecode">with</code> helper changes the context, but it is still possible to get values from the original data by using a navigation expression, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
&lt;input name="address[{{lower ..<strong class="screentext">/this</strong>}}]" class="form-control" value="{{value}}"&gt;
...
</code></pre>
<p class="normal">The <code class="inlinecode">lower</code> helper is used to set the name of the <code class="inlinecode">input</code> element, which is structured using square brackets so that related values are grouped when read by the server from the HTTP request. The overall effect is to create elements whose names are <code class="inlinecode">address[street]</code>, <code class="inlinecode">address[city]</code>, <code class="inlinecode">address[state]</code>, and <code class="inlinecode">address[zip]</code>, which will be passed into a JavaScript object named <code class="inlinecode">address</code> with <code class="inlinecode">street</code>, <code class="inlinecode">city</code>, <code class="inlinecode">state</code>, and <code class="inlinecode">zip</code> properties.</p>
<p class="normal">To combine<a id="_idIndexMarker1000" class="calibre3"/> the customer and address templates, create a file named <code class="inlinecode">order_details.handlebars</code> in the <code class="inlinecode">templates</code> folder, with the content shown in <em class="italic">Listing 18.29</em>.</p>
<p class="packt_figref">Listing 18.29: The contents of the order_details.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;form method="post" action="/checkout"&gt;
    {{&gt; order_details_customer }}
    {{&gt; order_details_address }}
   
    &lt;div class="m-2"&gt;
        &lt;button type="submit" class="btn btn-primary"&gt;Place Order&lt;/button&gt;
        &lt;a href="/cart" class="btn btn-primary"&gt;Back&lt;/a&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p class="normal">The <code class="inlinecode">form</code> element sends a <code class="inlinecode">POST</code> request to the <code class="inlinecode">/checkout</code> URL when the user clicks the <strong class="screentext">Place Order</strong> button. There is also a link styled to appear as a button that directs the user back to the shopping cart.</p>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code>, add an item to the cart, and click the <strong class="screentext">Checkout</strong> button, which will lead the application to present the order details form. Click the <strong class="screentext">Place Order</strong> button to see the validation errors. To complete the order, fill out the form and click the <strong class="screentext">Place Order</strong> button. The sequence is shown in <em class="italic">Figure 18.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_18_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 18.2: Creating an order</p>
<h1 class="heading" id="_idParaDest-324">Fixing the return URL</h1>
<p class="normal1">In the catalog, the<a id="_idIndexMarker1001" class="calibre3"/> user’s preferences for category, page, and page size are preserved using a query string, but these are lost when checking out when data is preserved in the session instead. I don’t care too much about preserving the category and page, because they are temporary choices, but I would like to preserve the page size so that it is used when the user completes an order or cancels the order process.</p>
<p class="normal">I could store all of the user’s choices in a session or use the query string throughout the order process, but I want to preserve these separate approaches because they demonstrate different ways of solving similar problems. With this in mind, I am going to store the user’s preferred page size in the session at the start of the <a id="_idIndexMarker1002" class="calibre3"/>order process and use the value when generating the URLs that will return the user to the catalog.</p>
<p class="normal">The first step is to store the page size as session data when the user transitions from the cart to the ordering process, as shown in <em class="italic">Listing 18.30</em>.</p>
<p class="packt_figref">Listing 18.30: Storing page size in the orders.ts file in the src/routes folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { Address } from "../data/order_models";
import { AddressValidator, CustomerValidator, ValidationResults, getData, isValid }
    from "../data/validation";
import { Customer } from "../data/customer_models";
import { createAndStoreOrder } from "./order_helpers";
declare module "express-session" {
    interface SessionData {
       orderData?: {
            customer?: ValidationResults&lt;Customer&gt;,
            address?: ValidationResults&lt;Address&gt;
       },
      <strong class="screentext"> pageSize?: string;</strong>
    }
}
export const createOrderRoutes = (app: Express) =&gt; {
    app.get("/checkout", (req, resp) =&gt; {
        <strong class="screentext">req.session.pageSize</strong><strong class="screentext"> =</strong>
<strong class="screentext">            req.session.pageSize ?? req.query.pageSize?.toString() ?? "3";</strong>
        resp.render("order_details", {
            order: req.session.orderData,
            <strong class="screentext">page: 1,</strong>
<strong class="screentext">            pageSize: req.session.pageSize</strong>
        });
    });
    app.post("/checkout", async (req, resp) =&gt; {
        const { customer, address } = req.body;
        const data = req.session.orderData = {
            customer: await CustomerValidator.validate(customer),
            address: await AddressValidator.validate(address)
        };
        if (isValid(data.customer) &amp;&amp; isValid(data.address)
                &amp;&amp; req.session.cart) {
            const order = await createAndStoreOrder(
                getData(data.customer), getData(data.address),
                    req.session.cart
            )
            resp.redirect(`/checkout/${order.id}`);
            req.session.cart = undefined;
            req.session.orderData = undefined;
        } else {
            resp.redirect("/checkout");
        }
    });
    app.get("/checkout/:id", (req, resp) =&gt; {
        resp.render("order_complete", {
            id: req.params.id,
            <strong class="screentext">pageSize</strong><strong class="screentext">: req.session.pageSize ?? 3</strong>
        });
    })
}
</code></pre>
<p class="normal"><em class="italic">Listing 18.31</em> adds the <a id="_idIndexMarker1003" class="calibre3"/>return URL to the target of the anchor element that the user clicks to leave the cart summary.</p>
<p class="packt_figref">Listing 18.31: Adding the URL to the cart.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;h2&gt;Your cart&lt;/h2&gt;
&lt;table class="table table-bordered table-striped"&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th class="text-end"&gt;Quantity&lt;/th&gt;&lt;th&gt;Item&lt;/th&gt;
            &lt;th class="text-end"&gt;Price&lt;/th&gt;&lt;th class="text-end"&gt;Subtotal&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        {{#unless cart.lines}}
            &lt;tr&gt;&lt;td colspan="5" class="text-center"&gt;Cart is empty&lt;/td&gt;&lt;/tr&gt;
        {{/unless}}
        {{#each cart.lines}}
            {{&gt; cart_line returnUrl=../returnUrl }}       
        {{/each }}
    &lt;/tbody&gt;
    &lt;tfoot&gt;
        &lt;tr&gt;
            &lt;td colspan="3" class="text-end"&gt;Total:&lt;/td&gt;
            &lt;td class="text-end"&gt;{{ currency cart.total }}&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
&lt;/table&gt;
&lt;div class="text-center"&gt;
    &lt;a class="btn btn-primary" href="{{ returnUrl }}"&gt;Continue Shopping&lt;/a&gt;
    {{#if cart.lines}}
        <strong class="screentext">&lt;a class="btn btn-primary" href="/checkout{{returnUrl}}"&gt;Checkout&lt;/a&gt;</strong>
    {{else}}
        &lt;button class="btn btn-primary" disabled&gt;Checkout&lt;/button&gt;
    {{/if}}
&lt;/div&gt;
</code></pre>
<p class="normal"><em class="italic">Listing 18.32</em> adds the<a id="_idIndexMarker1004" class="calibre3"/> return URL to the <strong class="screentext">Back</strong> button on the <strong class="screentext">Order Details</strong> page.</p>
<p class="packt_figref">Listing 18.32: Adding the URL in the order_details.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;form method="post" action="/checkout"&gt;
    {{&gt; order_details_customer }}
    {{&gt; order_details_address }}
   
    &lt;div class="m-2"&gt;
        &lt;button type="submit" class="btn btn-primary"&gt;Place Order&lt;/button&gt;
        <strong class="screentext">&lt;a </strong><strong class="screentext">href="/cart?returnUrl={{ escapeUrl (navigationUrl )}}"</strong>
<strong class="screentext">            class="btn btn-primary"&gt;Back&lt;/a&gt;</strong>
    &lt;/div&gt;
&lt;/form&gt;
</code></pre>
<p class="normal">The <a id="_idIndexMarker1005" class="calibre3"/>final step is to add the URL to the button the user clicks to return to the catalog once an order has been placed, as shown in <em class="italic">Listing 18.33</em>.</p>
<p class="packt_figref">Listing 18.33: Adding the URL to the order_complete.handlebars file in the templates folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;div class="text-center m-2"&gt;
    &lt;h2&gt;Thanks!&lt;/h2&gt;
    &lt;p&gt;Thanks for placing order #{{ id }}&lt;/p&gt;
    &lt;p&gt;We'll ship your goods as soon as possible.&lt;/p&gt;
   <strong class="screentext"> &lt;a class="btn btn-primary"</strong><strong class="screentext"> href="/?page=1&amp;pageSize={{pageSize}}"&gt;</strong>
        Return to Store
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000</code> and change the page size to <strong class="screentext">6 </strong>items. Add items to the cart and complete the order. Click the <strong class="screentext">Return</strong> <strong class="screentext">to Store</strong> button displayed with the order summary and the page size will be preserved when the catalog is displayed, as shown in <em class="italic">Figure 18.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_18_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 18.3: Fixing the return URL</p>
<h1 class="heading" id="_idParaDest-325">Summary</h1>
<p class="normal1">In this chapter, I continued developing the SportsStore application by adding support for placing orders.</p>
<ul class="calibre4">
<li class="bulletlist">The data model for orders is presented through a separate repository interface but is implemented using the <code class="inlinecode">ORM mixin</code> class.</li>
<li class="bulletlist1">The order data is stored in the same database as the catalog, which simplifies data consistency and makes it easier to use transactions for updates.</li>
<li class="bulletlist1">The data provided by the user is validated before it is stored.</li>
<li class="bulletlist1">The validation system relies on TypeScript to ensure that rules are defined for all data model properties.</li>
<li class="bulletlist1">The session feature is used to store the user’s pagination preferences during the checkout process.</li>
</ul>
<p class="normal">In the next chapter, I will add support for letting users identify themselves using their Google accounts, which is done using the <code class="inlinecode">OAuth</code> protocol.</p>
</div>
</body></html>