["```js\n      control = new function() {\n        this.rotationSpeedX = 0.001;\n        this.rotationSpeedY = 0.001;\n        this.rotationSpeedZ = 0.001;\n      };\n    ```", "```js\n      function addControls(controlObject) {\n        var gui = new dat.GUI();\n        gui.add(controlObject, 'rotationSpeedX', -0.2, 0.2);\n        gui.add(controlObject, 'rotationSpeedY', -0.2, 0.2);\n        gui.add(controlObject, 'rotationSpeedZ', -0.2, 0.2);\n      }\n    ```", "```js\n      function render() {\n        var cube = scene.getObjectByName('cube');\n        cube.rotation.x += control.rotationSpeedX;\n        cube.rotation.y += control.rotationSpeedY;\n        cube.rotation.z += control.rotationSpeedZ;\n        renderer.render(scene, camera);\n        requestAnimationFrame(render); \n      }\n    ```", "```js\n      // create a simple sphere\n      var sphere = new THREE.SphereGeometry(6.5, 20, 20);\n      var sphereMaterial = new THREE.MeshLambertMaterial({\n        color: 0x5555ff\n      });\n      var sphereMesh = new THREE.Mesh(sphere, spherMaterial);\n      sphereMesh.receiveShadow = true;\n      sphereMesh.position.set(0, 1, 0);\n      scene.add(sphereMesh);\n    ```", "```js\n      // add an object as pivot point to the sphere\n      pivotPoint = new THREE.Object3D();\n      sphereMesh.add(pivotPoint);\n    ```", "```js\n      // create a box and add to scene\n      var cubeGeometry = new THREE.BoxGeometry(2, 4, 2);\n      var cubeMaterial = new THREE.MeshLambertMaterial();\n      cubeMaterial.color = new THREE.Color('red');\n      cube = new THREE.Mesh(cubeGeometry, cubeMaterial);\n      // position is relative to it's parent\n      cube.position.set(14, 4, 6);\n      cube.name = 'cube';\n      cube.castShadow = true;\n      // make the pivotpoint the cube's parent.\n      pivotPoint.add(cube);\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        pivotPoint.rotation.x += control.rotationSpeedX;\n        pivotPoint.rotation.y += control.rotationSpeedY;\n        pivotPoint.rotation.z += control.rotationSpeedZ;\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n var mergedGeometry = new THREE.Geometry();\n  for (var i = 0; i < control.numberToAdd; i++) {\n    var cubeGeometry = new THREE.BoxGeometry(\n      4*Math.random(), \n      4*Math.random(), \n      4*Math.random());\n    var translation = new THREE.Matrix4().makeTranslation(\n      100*Math.random()-50, \n      0, 100*Math.random()-50);\n    cubeGeometry.applyMatrix(translation);\n mergedGeometry.merge(cubeGeometry);\n  }\n  var mesh = new THREE.Mesh(mergedGeometry, new THREE.MeshNormalMaterial({\n    opacity: 0.5,\n    transparent: true\n  }));\n  scene.add(mesh);\n```", "```js\n      var depth = 512;\n      var width = 512;\n      var spacingX = 3;\n      var spacingZ = 3;\n      var heightOffset = 2;\n      var canvas = document.createElement('canvas');\n      canvas.width = 512;\n      canvas.height = 512;\n      var ctx = canvas.getContext('2d');\n      var img = new Image();\n      img.src = \"../assets/other/grandcanyon.png\";\n      img.onload = function () {...}\n    ```", "```js\n      // draw on canvas\n      ctx.drawImage(img, 0, 0);\n      var pixel = ctx.getImageData(0, 0, width, depth);\n      var geom = new THREE.Geometry();\n      var output = [];\n      for (var x = 0; x < depth; x++) {\n        for (var z = 0; z < width; z++) {\n          // get pixel\n          // since we're grayscale, we only need one element\n          // each pixel contains four values RGB and opacity\n          var yValue = pixel.data[z * 4 + (depth * x * 4)] / heightOffset;\n          var vertex = new THREE.Vector3(x * spacingX, yValue, z * spacingZ);\n          geom.vertices.push(vertex);\n        }\n      }\n    ```", "```js\n      // we create a rectangle between four vertices, and we do\n      // that as two triangles.\n      for (var z = 0; z < depth - 1; z++) {\n        for (var x = 0; x < width - 1; x++) {\n          // we need to point to the position in the array\n          // a - - b\n          // |  x  |\n          // c - - d\n          var a = x + z * width;\n          var b = (x + 1) + (z * width);\n          var c = x + ((z + 1) * width);\n          var d = (x + 1) + ((z + 1) * width);\n          var face1 = new THREE.Face3(a, b, d);\n          var face2 = new THREE.Face3(d, c, a);\n          geom.faces.push(face1);\n          geom.faces.push(face2);\n        }\n      }\n    ```", "```js\n      geom.computeVertexNormals(true);\n      geom.computeFaceNormals();\n      var mesh = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({color: 0x666666}));\n      scene.add(mesh);\n    ```", "```js\n      <script src=\"img/chroma.min.js\"></script>\n    ```", "```js\n      var scale = chroma.scale(['blue', 'green', red]).domain([0, 50]);\n    ```", "```js\n      face1.color = new THREE.Color(\n        scale(getHighPoint(geom, face1)).hex());\n      face2.color = new THREE.Color(\n        scale(getHighPoint(geom, face2)).hex())\n    ```", "```js\n  control = new function() {\n    this.lookAtCube = function() {\n      cube.lookAt(boxMesh.position);\n    };\n    this.lookAtSphere = function() {\n      cube.lookAt(sphereMesh.position);\n    };\n    this.lookAtTetra = function() {\n      cube.lookAt(tetraMesh.position);\n    };\n  };\n```", "```js\n  <script src=\"img/gentilis_bold.typeface.js\">\n  </script>\n  <script src=\"img/gentilis_regular.typeface.js\">\n  </script>\n  <script src=\"img/optimer_bold.typeface.js\"></script>\n  <script src=\"img/optimer_regular.typeface.js\">\n  </script>\n  <script src=\"img/helvetiker_bold.typeface.js\">\n  </script>\n  <script src=\"img/helvetiker_regular.typeface.js\">\n  </script>\n  <script src= \"../assets/fonts/droid/droid_sans_regular.typeface.js\">\n  </script>\n  <script src= \"../assets/fonts/droid/droid_sans_bold.typeface.js\">\n  </script>\n  <script src= \"../assets/fonts/droid/droid_serif_regular.typeface.js\">\n  </script>\n  <script src=\"img/droid_serif_bold.typeface.js\">\n  </script>\n```", "```js\n  var textGeo = new THREE.TextGeometry(text, params);\n  textGeo.computeBoundingBox();\n  textGeo.computeVertexNormals();\n```", "```js\n  var params = {\n    material: 0,\n    extrudeMaterial: 1,\n    bevelEnabled: control.bevelEnabled,\n    bevelThickness: control.bevelThickness,\n    bevelSize: control.bevelSize,\n    font: control.font,\n    style: control.style,\n    height: control.height,\n    size: control.size,\n    curveSegments: control.curveSegments\n  };\n```", "```js\n  var material = new THREE.MeshFaceMaterial([\n    new THREE.MeshPhongMaterial({\n      color: 0xff22cc,\n      shading: THREE.FlatShading\n    }), // front\n    new THREE.MeshPhongMaterial({\n    color: 0xff22cc,\n    shading: THREE.SmoothShading\n    }) // side\n  ]);\n  var textMesh = new THREE.Mesh(textGeo, material);\n  textMesh.position.x = -textGeo.boundingBox.max.x / 2;\n  textMesh.position.y = -200;\n  textMesh.name = 'text';\n  scene.add(textMesh);\n```", "```js\n      var paramFunction = function(u, v) {\n        var a = 3;\n        var n = 3;\n        var m = 1;\n        var u = u * 4 * Math.PI;\n        var v = v * 2 * Math.PI;\n        var x = (a + Math.cos(n * u / 2.0) * Math.sin(v) - Math.sin(n * u / 2.0) * Math.sin(2 * v)) * Math.cos(m * u / 2.0);\n        var y = (a + Math.cos(n * u / 2.0) * Math.sin(v) - Math.sin(n * u / 2.0) * Math.sin(2 * v)) * Math.sin(m * u / 2.0);\n        var z = Math.sin(n * u / 2.0) * Math.sin(v) + Math.cos(n * u / 2.0) * Math.sin(2 * v);\n        return new THREE.Vector3(x, y, z);\n      }\n    ```", "```js\n      var geom = new THREE.ParametricGeometry(paramFunction, 100, 100);\n      var mat = new THREE.MeshPhongMaterial({\n        color: 0xcc3333a,\n        side: THREE.DoubleSide,\n        shading: THREE.FlatShading\n      });\n      var mesh = new THREE.Mesh(geom, mat);\n      scene.add(mesh);\n    ```", "```js\n      function setupCustomObject() {\n        // First define the object.\n        THREE.FixedBoxGeometry = function ( width, segments) {\n          // first call the parent constructor\n          THREE.Geometry.call( this );\n          this.width = width;\n          this.segments = segments;\n          // we need to set\n          //   - vertices in the parent object\n          //   - faces in the parent object\n          //   - uv mapping in the parent object\n          // normally we'd create them here ourselves\n          // in this case, we just reuse the once\n          // from the boxgeometry.\n          var boxGeometry = new THREE.BoxGeometry(\n            this.width, \n            this.width, \n            this.width, this.segments, this.segments);\n          this.vertices = boxGeometry.vertices;\n          this.faces = boxGeometry.faces;\n          this.faceVertexUvs = boxGeometry.faceVertexUvs;\n        }\n        // define that FixedBoxGeometry extends from \n        // THREE.Geometry\n        THREE.FixedBoxGeometry.prototype= Object.create( THREE.Geometry.prototype );\n      }\n    ```", "```js\n      var cubeGeometry = new THREE.FixedBoxGeometry(3, 5);\n      var cubeMaterial = new THREE.MeshNormalMaterial();\n      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);\n      scene.add(cube);\n    ```", "```js\n  THREE.FixedBoxGeometry.prototype= Object.create( THREE.Geometry.prototype );\n```", "```js\n  THREE.Geometry.call( this );\n```", "```js\n      var numPoints = 100;\n      var start = new THREE.Vector3(-20, 0, 0);\n      var middle = new THREE.Vector3(0, 30, 0);\n      var end = new THREE.Vector3(20, 0, 0);\n    ```", "```js\n      var curveQuad = new THREE.QuadraticBezierCurve3(start, middle, end);\n    ```", "```js\n      var tube = new THREE.TubeGeometry(curveQuad, numPoints, 2, 20, false);\n      var mesh = new THREE.Mesh(tube, new THREE.MeshNormalMaterial({\n        opacity: 0.6,\n        transparent: true\n      }));\n      scene.add(mesh);\n    ```", "```js\n      function loadModel() {\n        var loader = new THREE.JSONLoader();\n        loader.load(\"../assets/models/monkey.js\", function(model, material) {\n          var mesh = new THREE.Mesh(model, material[0]);\n          mesh.scale = new THREE.Vector3(3,3,3);\n          scene.add(mesh);\n        });\n      }\n    ```", "```js\n  <script src=\"img/MTLLoader.js\"></script>\n  <script src=\"img/OBJMTLLoader.js\"></script>\n```", "```js\n      newmtl Cap\n      Ns 96.078431\n      Ka 0.000000 0.000000 0.000000\n      Kd 0.990000 0.120000 0.120000\n      Ks 0.500000 0.500000 0.500000\n      Ni 1.000000\n      d 1.00000\n      illum 2\n      newmtl Minifig\n      Ns 874.999998\n      Ka 0.000000 0.000000 0.000000\n      Kd 0.800000 0.800000 0.800000\n      Ks 0.200000 0.200000 0.200000\n      Ni 1.000000\n      d 1.000000\n      illum 2\n     map_Kd ../textures/Mini-tex.png\n\n    ```", "```js\n      var loader = new THREE.OBJMTLLoader();\n      // based on model from:\n      // http://www.blendswap.com/blends/view/69499\n      loader.load(\"../assets/models/lego.obj\",\n      \"../assets/models/lego.mtl\", \n      function(obj) {\n        obj.translateY(-3);\n        obj.name='lego';\n        scene.add(obj);\n      });\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        var lego = scene.getObjectByName('lego');\n        if (lego) {\n          lego.rotation.y += control.rotationSpeed;\n          lego.scale.set(control.scale, control.scale, control.scale);\n        }\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n      this.doTranslation = function() {\n        // you have two options, either use the\n        // helper function provided by three.js\n        // new THREE.Matrix4().makeTranslation(3,3,3);\n        // or do it yourself\n        var translationMatrix = new THREE.Matrix4(\n          1, 0, 0, control.x,\n          0, 1, 0, control.y,\n          0, 0, 1, control.z,\n          0, 0, 0, 1\n        );\n        cube.applyMatrix(translationMatrix);\n        // or do it on the geometry\n        // cube.geometry applyMatrix(translationMatrix);\n        // cube.geometry.verticesNeedUpdate = true;\n      }\n    ```", "```js\n  this.doScale = function() {\n    var scaleMatrix = new THREE.Matrix4(\n      control.x, 0, 0, 0,\n      0, control.y, 0, 0,\n      0, 0, control.z, 0,\n      0, 0, 0, 1\n    );\n    cube.geometry.applyMatrix(scaleMatrix);\n    cube.geometry.verticesNeedUpdate = true;\n  }\n  this.doShearing = function() {\n    var scaleMatrix = new THREE.Matrix4(\n      1, this.a, this.b, 0,\n      this.c, 1, this.d, 0,\n      this.e, this.f, 1, 0,\n      0, 0, 0, 1\n    );\n    cube.geometry.applyMatrix(scaleMatrix);\n    cube.geometry.verticesNeedUpdate = true;\n  }\n  this.doRotationY = function() {\n    var c = Math.cos(this.theta),\n    s = Math.sin(this.theta);\n    var rotationMatrix = new THREE.Matrix4(\n      c, 0, s, 0,\n      0, 1, 0, 0, -s, 0, c, 0,\n      0, 0, 0, 1\n    );\n    cube.geometry.applyMatrix(rotationMatrix);\n    cube.geometry.verticesNeedUpdate = true;\n  }\n```"]