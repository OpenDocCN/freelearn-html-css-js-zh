<html><head></head><body>


<h1 class="chap2"><a id="page266" class="calibre6"/><a href="toc.xhtml#c07" class="calibre6">C<small class="calibre8">HAPTER</small> 7</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c07" class="calibre6">API Caching</a></h1>

<h1 class="sec" id="s196"><a href="toc.xhtml#s196a" class="calibre6">Introduction</a></h1>
<p class="nonindent">A user opens the browser and tries to access different parts of the application. This causes many API calls to the backend. Normally, with a low count of users, the response would be quick. However, when the data grows in the application and a significant number of users are accessing the data simultaneously, the response time increases. This may lead to poor user experience.</p>
<p class="nonindent">Usually, for a system, when the state of the data does not change frequently, for a given input, the output will mostly be the same unless something changes in data. Till the time, data does not change, the database query is not necessary to fetch the same data repetitively if you can keep a copy of the outcome somewhere. The process of storing this outcome and accessing it when needed is a fundamental concept of caching.</p>
<p class="nonindent">In this chapter, we will learn how to cache the data and use the cached data to serve APIs or save data of the queries so that we do not have to query the database for a certain time or till the time data is unchanged.</p>
<h1 class="sec" id="s197"><a href="toc.xhtml#s197a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will discuss the following topics:</p>
<ul class="bull">
<li class="calibre9">Understanding Caching</li>
<li class="calibre9">Introduction to Redis</li>
<li class="calibre9">Setting Up Redis server</li>
<li class="calibre9">Pros and Cons of Redis/Caching</li>
<li class="calibre9">Using Redis for Caching Data</li>
</ul>
<h1 class="sec" id="s198"><a href="toc.xhtml#s198a" class="calibre6">Understanding Caching</a></h1>
<p class="nonindent">Consider yourself trying to log in to the application. After entering a username and password, the application takes a couple of seconds to validate and then navigate to the homepage. At the homepage, there are many things: project list you are part <a id="page267"/>of, team activities on the project tasks, your high-priority tasks list, and many more. Bringing data for each of them is going to take a good amount of time if the system is busy serving too many requests already.</p>
<p class="nonindent">All of these things on the homepage would require some data to be fetched from the database. The database queries are going to take time every single time you or other users open the application. These database query results can be <em class="calibre4">cached</em>. If cached, whenever the homepage is requested, the database queries would be avoided, and data will be read from the cache and sent in response. This process of caching-retrieving data would make responses faster and improve the user experience.</p>
<p class="nonindent">By definition, caching is a technique to store fetched data, or calculated results in <em class="calibre4">cache</em> so that any future request asking for that data can be served faster. When we need to access the data, the cache will be checked first to see if the desired data is cached or not. If yes, then serve the data from cache. Otherwise, fetch the data, process it if needed, and then store it in cache so that the next request can be served quicker.</p>
<p class="nonindent">Caching is a critical component when it comes to optimization of system performance. It helps to lower the response time or latency, and makes the system highly scalable. Cache can be considered a high-speed data storage system. There are many types of caching: memory cache, disk cache, browser cache, database cache, and so on. For our use-case, we will cache the data needed for API response, and database query results. For the caching, we will use a software called Redis.</p>
<h1 class="sec" id="s199"><a href="toc.xhtml#s199a" class="calibre6">Introduction to Redis</a></h1>
<p class="nonindent">Quoting the content from Redis.io website:</p>
<p class="nonindent"><em class="calibre4">“The open source, in-memory data store used by millions of developers as a database, cache, streaming engine, and message broker.”</em></p>
<p class="nonindent">In simple words, Redis can store various types of data. Most of them are simple Key-Value pairs. It supports various data structures such as strings, hashes, lists, sets, sorted sets, bitmaps, and more. We can store these kinds of data in Redis and access via a key.</p>
<p class="nonindent">Being in-memory by nature makes Redis blazingly fast for read and write operations, thus, making it a popular choice for caching.</p>
<p class="nonindent">Apart from the core data structures which help us store various types of data, Redis also offers features including data replication, persistence, sharding, and transaction capabilities. Redis is adopted by developers for a variety of applications. Redis is used by GitHub, Twitter, snapchat, stackoverflow, and many more. Techstacks.io maintains a list of popular websites which utilize Redis for their use cases.</p>
<p class="nonindent">More on Redis can be learned at - <a href="https://redis.io">https://redis.io</a>.</p>
<h1 class="sec" id="s200"><a id="page268" class="calibre6"/><a href="toc.xhtml#s200a" class="calibre6">Setting Up Redis Server</a></h1>
<p class="nonindent">Let us start by setting up the Redis server. This section will cover the installation for MacOS, Ubuntu(debian), and Rocky Linux.</p>
<h1 class="sec" id="s201"><a href="toc.xhtml#s201a" class="calibre6">Installing Redis Server on Mac OS</a></h1>
<p class="nonindent">The easiest way to install most of the softwares on a Mac is to use <code class="calibre7"><strong class="calibre3">homebrew</strong></code>. If <code class="calibre7"><strong class="calibre3">homebrew</strong></code> is not installed, it can be installed by running:</p>
<p class="code"><code class="calibre7">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</code></p>
<p class="nonindent">This will make available a command named <code class="calibre7"><strong class="calibre3">brew</strong></code> which we can use to install Redis server.</p>
<p class="code"><code class="calibre7">brew install redis</code></p>
<p class="nonindent">Once this completes, the server can be started with:</p>
<p class="code"><code class="calibre7">brew services start redis</code></p>
<p class="nonindent">To verify if Redis is installed or not, we can try running <code class="calibre7"><strong class="calibre3">redis-cli</strong></code> which is a command line interface for accessing Redis.</p>
<p class="code"><code class="calibre7">redis-cli</code></p>
<p class="nonindent">If Redis was successfully installed, it will open a Redis prompt as:</p>
<p class="code"><code class="calibre7">127.0.0.1:6379&gt;</code></p>
<p class="nonindent">If the prompt is visible, Redis is correctly installed and ready for use.</p>
<p class="nonindent">Further, we can do a command <code class="calibre7"><strong class="calibre3">ping</strong></code> which should respond as <code class="calibre7"><strong class="calibre3">PONG</strong></code>. If it does, then everything is working fine.</p>
<p class="code"><code class="calibre7">127.0.0.1:6379&gt; ping</code></p>
<p class="code1"><code class="calibre7">PONG</code></p>
<h1 class="sec" id="s202"><a href="toc.xhtml#s202a" class="calibre6">Installing Redis Server on Ubuntu / Linux</a></h1>
<p class="nonindent">To install the Redis on Ubuntu, we need <code class="calibre7"><strong class="calibre3">lsb-release</strong></code>, <code class="calibre7"><strong class="calibre3">curl</strong></code>, and <code class="calibre7"><strong class="calibre3">gpg</strong></code>. If these are not available already, it can be installed using <code class="calibre7"><strong class="calibre3">apt</strong></code>.</p>
<p class="code"><code class="calibre7">sudo apt install lsb-release curl gpg</code></p>
<p class="nonindent">Now, we need to add the repository where the <code class="calibre7"><strong class="calibre3">redis</strong></code> binaries are available.</p>
<p class="code"><code class="calibre7">curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</code></p>
<p class="code1"><code class="calibre7">echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list</code></p>
<p class="code1"><code class="calibre7"><a id="page269"/>Once the repositories are added, we can install Redis:</code></p>
<p class="code1"><code class="calibre7">sudo apt-get update</code></p>
<p class="code1"><code class="calibre7">sudo apt-get install redis</code></p>
<p class="nonindent">After this, server can be started using:</p>
<p class="code"><code class="calibre7">sudo systemctl start redis</code></p>
<p class="nonindent">Once the server is started, similar to Mac OS, we can verify using <code class="calibre7"><strong class="calibre3">redis-cli</strong></code>.</p>
<h1 class="sec" id="s203"><a href="toc.xhtml#s203a" class="calibre6">Installing Redis Server on Rocky (RHEL-based)</a></h1>
<p class="nonindent">We can simply use the <code class="calibre7"><strong class="calibre3">dnf</strong></code> package manager to install Redis.</p>
<p class="code"><code class="calibre7">sudo dnf update -y</code></p>
<p class="code1"><code class="calibre7">sudo dnf install -y redis</code></p>
<p class="nonindent">Once installed, the service can be started as:</p>
<p class="code"><code class="calibre7">sudo systemctl status redis</code></p>
<p class="nonindent">Finally, we can verify using <code class="calibre7"><strong class="calibre3">redis-cli</strong></code>.</p>
<h1 class="sec" id="s204"><a href="toc.xhtml#s204a" class="calibre6">Pros and Cons of Caching</a></h1>
<p class="nonindent">Before we proceed to use Redis for our purpose, it is important to know about pros and cons that caching brings in. Caching is a crucial technique but it comes with certain advantages and disadvantages, which we should keep in mind while implementing it in the application.</p>
<h1 class="sec" id="s205"><a href="toc.xhtml#s205a" class="calibre6">Pros of Caching</a></h1>
<p class="nonindent">Some of the major benefits of caching are as follows:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Performance improvement</strong>: Caching significantly reduces the time needed to access data, which makes the responses to the end user faster. Thus, it provides better and faster application performance and an improved user experience.</li>
<li class="calibre9"><strong class="calibre3">Reduced load</strong>: If implemented properly, most of the data is now served from cache which reduces the load on the application. This way, the application can serve more requests and operate more efficiently.</li>
<li class="calibre9"><strong class="calibre3"><a id="page270"/>Cost effectiveness</strong>: With caching in place, a single server can handle a larger number of requests efficiently. Consider if a server without caching was able to handle 100 requests per minute, and with caching, it can serve 1000 requests per minute. We do not need to put in more servers when the user load increases. Not only server costs, but the operational costs are also lowered due to decreased load and reduced bandwidth consumption.</li>
<li class="calibre9"><strong class="calibre3">Reduced network traffic</strong>: The caching server can be installed locally to the application or on another server. If done locally, it can reduce the network traffic. However, it must be seen if both application and caching server can stay on the same machine, without making the resource consumption high, such as memory and CPU.</li>
</ul>
<h1 class="sec" id="s206"><a href="toc.xhtml#s206a" class="calibre6">Cons of Caching</a></h1>
<p class="nonindent">Some cons to be kept in mind and to be careful while doing development are:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Stale data</strong>: It is important to ensure cache consistency. If the data is old, there should be effective cache invalidation strategies in place to remove old and invalid data from cache. Consider an example where you update your profile by updating your phone number. The application had already cached the user entity, which keeps your profile data in cache. When there is an update for the cached entity, the old data must be removed from cache and the new data must be placed in it.
<p class="nonindent">It is very important to be careful while storing data in cache. At all points where the data might not be valid anymore, it should either be removed or replaced with the updated data. Sometimes, when data update is not always possible, the TTL kind of feature can be utilized. TTL stands for time to live. Usually, all caching systems provide this feature. This allows us to set a time for which the data should be in cache. Once the time expires, the data will be invalidated automatically.</p></li>
<li class="calibre9"><strong class="calibre3">Resource consumption</strong>: If there is a lot of data in the application, it is important to decide what we are caching. Only the data which is needed most frequently should be cached. Otherwise, memory, disk space, and other resources can be a concern in a resource-constrained environment.</li>
<li class="calibre9"><strong class="calibre3">Cache Miss</strong>: When we try to access some data and it is not found in cache, then it is called a Cache Miss. It is important to know how it is handled. If data is not found in cache, the application must revert to the original data source. Also, when the data is fetched from the original source, it should be placed in cache to serve future requests faster. 
<p class="nonindent">Handling a situation like Cache Miss is critical, as it may be expensive in terms of both time and resources. If there are too many requests in place and if there are too many Cache Miss, it will lead to an inefficient application.</p></li>
<li class="calibre9"><strong class="calibre3"><a id="page271"/>Data synchronization issues</strong>: For distributed environments, keeping the cached data and original data source as synchronous can be a challenge. It gets bigger if there are multiple caches.</li>
<li class="calibre9"><strong class="calibre3">Complexity</strong>: Overall, implementing caching can add more complexity to the system. It may also lead to additional development efforts as well as testing and maintenance efforts.</li>
</ul>
<h1 class="sec" id="s207"><a href="toc.xhtml#s207a" class="calibre6">Using Redis for Caching</a></h1>
<p class="nonindent">In our project management system, so far, we have implemented several modules: users, roles, projects, and tasks. Consider this application being in use by an organization of 100,000 users. At the start of the office, typically 9 am, people are going to login and access their projects to learn about their tasks and make progress. If we cache a few things, the response time would improve and the user experience would be better.</p>
<p class="nonindent">There are many strategies to caching such as on demand caching, and proactive caching. Proactive caching would be when we cache something at the application start without any user requests. This caching is done anticipating future requests. On the other hand, whenever something is accessed and it is a cache miss situation, caching at this moment would be on-demand. In case of on-demand caching, initially there would not be any records, and an object would be cached only after a cache miss.</p>
<p class="nonindent">In our application, we could do a mix of both strategies. When the application starts, we can cache all users, roles, projects, and their tasks. There could be some specific cases when the data we want to cache is not a straightforward database query result, for example, if you want a count of projects and similarly counts of tasks in all projects, respectively. These values would be results of some function which we can cache. In this section, we will see how we can cache both types of data we are interested in caching.</p>
<p class="nonindent">Overall, we want to store the data as:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Objects</strong>: essentially JSON objects of projects, tasks, users, and so on.</li>
<li class="calibre9"><strong class="calibre3">Numbers</strong>: counts of projects, tasks, users, and so on.</li>
</ul>
<p class="nonindent">There can be more.</p>
<h1 class="sec" id="s208"><a href="toc.xhtml#s208a" class="calibre6">Updating Project Dependencies</a></h1>
<p class="nonindent">First of all, we need to update the project dependencies, that is, node modules in our case. The only package that we need is Redis. Let us install Redis using <code class="calibre7"><strong class="calibre3">npm</strong></code> <code class="calibre7"><strong class="calibre3">install</strong></code>:</p>
<p class="code"><code class="calibre7">npm install redis</code></p>
<p class="nonindent">It is better to install type definitions for Redis as well so that while doing development we get proper code hints.</p>
<p class="code"><code class="calibre7"><a id="page272"/>npm install --save-dev @types/redis</code></p>
<p class="nonindent">After Redis package is available, we can use it as following example:</p>
<p class="code"><code class="calibre7">import { createClient, RedisClient } from 'redis';</code></p>
<p class="code"><code class="calibre7">const client: RedisClient = createClient();</code></p>
<p class="code"><code class="calibre7">client.on('connect', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('Connected to Redis');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">client.set('key'</code>, <code class="calibre7">'value', (err, reply) =&gt; {</code></p>
<p class="code2"><code class="calibre7">if (err) throw err;</code></p>
<p class="code2"><code class="calibre7">console.log(reply); // OK</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">client.get('key', (err, reply) =&gt; {</code></p>
<p class="code2"><code class="calibre7">if (err) throw err;</code></p>
<p class="code2"><code class="calibre7">console.log(reply); // value</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">client.quit();</code></p>
<p class="nonindent">In the preceding example, we are importing the <code class="calibre7"><strong class="calibre3">createClient</strong></code> function and <code class="calibre7"><strong class="calibre3">RedisClient</strong></code> for type. Next, a client is created using <code class="calibre7"><strong class="calibre3">createClient()</strong></code> function call and using <code class="calibre7"><strong class="calibre3">client.on()</strong></code> function we try to connect to the Redis server.</p>
<p class="nonindent">In the example discussed, we used callbacks, but we could also use async-await.</p>
<p class="nonindent">Using <code class="calibre7"><strong class="calibre3">client.set()</strong></code>, we can set a key-value pair. This will store the key-value to the Redis server acting as a caching server here. When needed, we can get the value of the key using <code class="calibre7"><strong class="calibre3">client.get()</strong></code>.</p>
<p class="nonindent">Here, we are storing a simple string <code class="calibre7"><strong class="calibre3">'value'</strong></code>, and if we want to store an object, we will have to convert the object to string using <code class="calibre7"><strong class="calibre3">JSON.stringify()</strong></code> and store it as string. All of this is because Redis does not support JSON objects as values straightforwardly. To make Redis store JSON objects, we need to set up a Redis Module named <code class="calibre7"><strong class="calibre3">RedisJSON</strong></code>. This module provides native JSON capabilities to Redis.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">RedisJSON</strong></code> module is available at GitHub: <code class="calibre7"><strong class="calibre3">https://github.com/RedisJSON/RedisJSON</strong></code>.</p>
<p class="nonindent"><a id="page273"/>We need to either clone this repository or download the repository zip file. Before continuing further, ensure that Rust is installed.</p>
<p class="nonindent">If not available, rust can be installed using:</p>
<p class="code"><code class="calibre7">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
<p class="nonindent">After this step completes, we can verify the installation by checking the rust version.</p>
<p class="code"><code class="calibre7">rustc --version</code></p>
<p class="nonindent">Once installed, we can begin building the <code class="calibre7"><strong class="calibre3">RedisJSON</strong></code>. Navigate to the downloaded repository and run the following command:</p>
<p class="code"><code class="calibre7">cargo build –release</code></p>
<p class="nonindent">This will create the module in <code class="calibre7"><strong class="calibre3">target/release/librejson.so</strong></code>. If the file is missing, then something went wrong and try building again.</p>
<p class="nonindent">We need to modify the Redis configuration typically located at <code class="calibre7"><strong class="calibre3">/etc/redis/redis.conf</strong></code> or <code class="calibre7"><strong class="calibre3">/usr/local/etc/redis.conf</strong></code> and add enable to the <code class="calibre7"><strong class="calibre3">redisjson.so</strong></code> module.</p>
<p class="nonindent"><strong class="calibre3">On linux</strong></p>
<p class="code"><code class="calibre7">loadmodule /path/to/redisjson.so</code></p>
<p class="nonindent"><strong class="calibre3">On Mac</strong></p>
<p class="code"><code class="calibre7">loadmodule /path/to/rejson.dylib</code></p>
<p class="nonindent">Once the module is loaded, restart Redis to enable it.</p>
<h1 class="sec" id="s209"><a href="toc.xhtml#s209a" class="calibre6">Cache Utility</a></h1>
<p class="nonindent">Since we’re dealing with a large number of entities to cache, using a cache utility class can be beneficial. This class would ideally provide functions for both setting and retrieving cached values.</p>
<p class="nonindent">Once we have the cache utility class, we can simply import it where we need and use the functions directly. Let us create a file <code class="calibre7"><strong class="calibre3">cache_util.ts</strong></code> which would have the following code:</p>
<p class="code"><code class="calibre7">// cache_util.ts</code></p>
<p class="code1"><code class="calibre7">import * as redis from 'redis';</code></p>
<p class="code"><code class="calibre7">export class CacheUtil {</code></p>
<p class="code2a"><code class="calibre7"> // redis client instance</code></p>
<p class="code2"><code class="calibre7"> private static client = redis.createClient();</code></p>
<p class="code2a"><code class="calibre7"><a id="page274"/>constructor() {</code></p>
<p class="code3"><code class="calibre7">CacheUtil.client.connect();</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code2"><code class="calibre7"> public static async get(cacheName: string, key: string) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">const data = await CacheUtil.client.json.get(`${cacheName}:${key}`);</code></p>
<p class="code4"><code class="calibre7">return data;</code></p>
<p class="code3"><code class="calibre7">} catch (err) {</code></p>
<p class="code4"><code class="calibre7">console.error(`Error getting cache: ${err}`);</code></p>
<p class="code4"><code class="calibre7">return null;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code2a"><code class="calibre7"> public static async set(cacheName: string, key: string, value) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">await CacheUtil.client.json.set(`${cacheName}:${key}`, '.', value);</code></p>
<p class="code3"><code class="calibre7">} catch (err) {</code></p>
<p class="code4"><code class="calibre7">console.error(`Error setting cache: ${err}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code2a"><code class="calibre7"> public static async remove(cacheName: string, key: string) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">await CacheUtil.client.del(`${cacheName}:${key}`);</code></p>
<p class="code3"><code class="calibre7">} catch (err) {</code></p>
<p class="code4"><code class="calibre7">console.error(`Error deleting cache: ${err}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The function <code class="calibre7"><strong class="calibre3">set()</strong></code> can be used to set a key-value in cache and the <code class="calibre7"><strong class="calibre3">get()</strong></code> function can be used to retrieve the values. Notice how we are using <code class="calibre7"><strong class="calibre3">client.json.get()</strong></code> and <code class="calibre7"><strong class="calibre3">client.json.set()</strong></code> to actually get and set the values. Both set and get functions are made static so that we can simply use those without initializing the class every time.</p>
<p class="nonindent"><a id="page275"/>We can now initialize the class once and use it everywhere. We need to do so in order to connect the Redis client to the server. Without making a call to <code class="calibre7"><strong class="calibre3">CacheUtil.client.connect()</strong></code> the application will throw an error as: The client is closed.</p>
<p class="nonindent">Now, when the cache utility is ready, let us initialize it in <code class="calibre7"><strong class="calibre3">main.ts</strong></code>.</p>
<p class="code"><code class="calibre7">// main.ts</code></p>
<p class="code"><code class="calibre7">// initialise the cache utility</code></p>
<p class="code1"><code class="calibre7">new CacheUtil();</code></p>
<p class="nonindent">This will make a call to the constructor and connect the client to the Redis server.</p>
<h1 class="sec" id="s210"><a href="toc.xhtml#s210a" class="calibre6">Caching Entities</a></h1>
<p class="nonindent">We previously discussed two entity caching approaches: on-demand and proactive. For on demand caching, we can update all of our controllers’ functions to first check if the data needed is in the cache or not. The following example shows how the <code class="calibre7"><strong class="calibre3">getOneHandler</strong></code> of <code class="calibre7"><strong class="calibre3">users_controller</strong></code> which is responsible for returning a user for a given user id:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async getOneHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_details_user')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">// check user is in cache</code></p>
<p class="code3"><code class="calibre7"><strong class="calibre3">const userFromCache = await CacheUtil.get(</strong>'<strong class="calibre3">User</strong>'<strong class="calibre3">, req.params.id);</strong></code></p>
<p class="code3"><code class="calibre7">if (userFromCache) {</code></p>
<p class="code4"><code class="calibre7">res.status(200).json({ statusCode: 200, status: 'success', data: userFromCache });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">} else {</code></p>
<p class="code4"><code class="calibre7">// get user from db</code></p>
<p class="code4"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code4"><code class="calibre7">const result = await service.findOne(req.params.id);</code></p>
<p class="code4"><code class="calibre7">if (result.statusCode === 200) {</code></p>
<p class="code5"><code class="calibre7">delete result.data.password;</code></p>
<p class="code5"><code class="calibre7">// set user in cache</code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">CacheUtil.set(</strong>'<strong class="calibre3">User</strong>'<strong class="calibre3">, req.params.id, result.data);</strong></code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="nonindent"><a id="page276"/>In the function, we are making a call to <code class="calibre7"><strong class="calibre3">CacheUtil.get()</strong></code> for cacheName <code class="calibre7"><strong class="calibre3">'User'</strong></code> and the key is the <code class="calibre7"><strong class="calibre3">user_id</strong></code> which is supplied in the request parameters. There is a chance that the requested user is not present in the cache so it must be checked if the returned value <code class="calibre7"><strong class="calibre3">userFromCache</strong></code> is null or not. If it is null, then we should take the regular course and fetch the user from the database. If a user is present in the database, then we should also save that to the cache. The following line making a call to <code class="calibre7"><strong class="calibre3">CacheUtil.set()</strong></code> is doing that for us:</p>
<p class="code"><code class="calibre7"><strong class="calibre3">CacheUtil.set('User', req.params.id, result.data);</strong></code></p>
<p class="nonindent">This way, all of the functions can be updated to check cache before making an actual database query. For cases when delete api is called, the value in cache must also be removed. If the value is not removed, future API calls to get the user by <code class="calibre7"><strong class="calibre3">user_id</strong></code> will return a value which does not exist in the database anymore.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">delete</strong></code> function can be updated as:</p>
<p class="code"><code class="calibre7">public async deleteHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7"> if (!hasPermission(req.user.rights, 'delete_user')) {</code></p>
<p class="code3"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code2"><code class="calibre7"> const service = new UsersService();</code></p>
<p class="code2"><code class="calibre7"> const result = await service.delete(req.params.id);</code></p>
<p class="code2a"><code class="calibre7"> // remove user from cache</code></p>
<p class="code2"><code class="calibre7"> <strong class="calibre3">CacheUtil.remove(</strong>'<strong class="calibre3">User</strong>'<strong class="calibre3">, req.params.id);</strong></code></p>
<p class="code2a"><code class="calibre7"> res.status(result.statusCode).json(result);</code></p>
<p class="code2"><code class="calibre7"> return;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">A call to <code class="calibre7"><strong class="calibre3">CacheUtil.remove()</strong></code> will remove the user from cache.</p>
<p class="nonindent"><a id="page277"/>Caching using this on-demand approach ensures the frequently used data stays in cache and the data which is not used does not fill up the cache. However, in this case, there will always be a cache miss when the data is requested for the first time.</p>
<h1 class="sec" id="s211"><a href="toc.xhtml#s211a" class="calibre6">Building Cache at Startup</a></h1>
<p class="nonindent">Sometimes, it is good to fill the cache when the application starts. This may help in preventing some cache miss since the data requested will be there in the cache. Let us update <code class="calibre7"><strong class="calibre3">UsersUtil</strong></code> to add a function <code class="calibre7"><strong class="calibre3">putAllUsersInCache()</strong></code> which will fetch all of the users from the database and put them in the cache.</p>
<p class="code"><code class="calibre7">// function to put all users in cache</code></p>
<p class="code1"><code class="calibre7">public static async putAllUsersInCache() {</code></p>
<p class="code2"><code class="calibre7"> const userService = new UsersService();</code></p>
<p class="code2"><code class="calibre7"> const result = await userService.findAll({});</code></p>
<p class="code2"><code class="calibre7"> if (result.statusCode === 200) {</code></p>
<p class="code3"><code class="calibre7">const users = result.data;</code></p>
<p class="code3"><code class="calibre7">users.forEach(i =&gt; {</code></p>
<p class="code4"><code class="calibre7">CacheUtil.set('User', i.user_id, i);</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code3"><code class="calibre7">console.log(`All users are put in cache`);</code></p>
<p class="code2"><code class="calibre7"> }else{</code></p>
<p class="code3"><code class="calibre7">console.log(`Error while putAllUsersInCache() =&gt; ${result.message}`);</code></p>
<p class="code3"><code class="calibre7">console.log(result);</code></p>
<p class="code2"><code class="calibre7"> }</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">This function is making a call to <code class="calibre7"><strong class="calibre3">findAll()</strong></code> using <code class="calibre7"><strong class="calibre3">userService</strong></code> to get all of the users from the database and if the result of the query is a success, putting the users in the cache using <code class="calibre7"><strong class="calibre3">forEach</strong></code>.</p>
<p class="nonindent">We can call this function from <code class="calibre7"><strong class="calibre3">main.ts</strong></code>.</p>
<p class="code"><code class="calibre7">// Proactive cache update</code></p>
<p class="code1"><code class="calibre7">setTimeout(() =&gt; {</code></p>
<p class="code2"><code class="calibre7"> UsersUtil.putAllUsersInCache();</code></p>
<p class="code1"><code class="calibre7">}, 1000 * 10 );</code></p>
<p class="nonindent">When an application starts, it may require time to establish connections to databases, caching servers, and perform other initializations. It is wise to allow sufficient time for these connections and initializations to complete before commencing other operations to ensure smooth functioning of the application. Hence, we have put some delay (10 seconds here) using <code class="calibre7"><strong class="calibre3">setTimeout</strong></code>.</p>
<p class="nonindent"><a id="page278"/>Similar to <code class="calibre7"><strong class="calibre3">UsersUtil</strong></code>, other entity utils can be modified to add a function and then we can make a call to those functions from <code class="calibre7"><strong class="calibre3">main.ts</strong></code>. It is not necessary that those functions be called from the <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file. We can put those elsewhere, for example, <code class="calibre7"><strong class="calibre3">CacheUtil</strong></code> and call <code class="calibre7"><strong class="calibre3">CacheUtil</strong></code> from <code class="calibre7"><strong class="calibre3">main.ts</strong></code> to <code class="calibre7"><strong class="calibre3">init</strong></code> the caching. Likewise, it can be another function than <code class="calibre7"><strong class="calibre3">putAllXXToCache</strong></code>.</p>
<h1 class="sec1" id="s212"><a href="toc.xhtml#s212a" class="calibre6">Consideration when Using Redis</a></h1>
<p class="nonindent">Despite being a powerful in-memory data store, there are some challenges when it comes to using Redis. The following points discusses some of the challenges:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Memory Limitation</strong>
<p class="nonindent">Since it is an in-memory data store, it offers faster access but is limited by the system capacity. If you have a large dataset and the target is to minimize the cost then it could be a drawback.</p></li>
<li class="calibre9"><strong class="calibre3">Data Security</strong>
<p class="nonindent">Redis, by default, is not encrypted. Although, it supports a simple password based authentication but does not have built-in support for SSL/TLS encryption. Securing data for REST APIs requires additional tools.</p></li>
<li class="calibre9"><strong class="calibre3">Limited ways to Query data</strong>
<p class="nonindent">Redis querying capabilities are limited compared to a traditional database system. However, by implementing some additional logic at application level, complex queries can be performed.</p></li>
<li class="calibre9"><strong class="calibre3">Single-threaded nature</strong>
<p class="nonindent">Redis servers are single-threaded in nature. Most of the machines these days are multi-core and Redis cannot utilize more than one core. However, newer Redis versions put slow queries to separate threads but the requests to Redis servers are still handled by a single thread only.</p></li>
<li class="calibre9"><strong class="calibre3">Hosting Cost on Cloud</strong></li>
</ul>
<p class="nonindent">All major cloud platforms offer Redis as a service. AWS <code class="calibre7"><strong class="calibre3">Elasticache</strong></code>, Azure Cache for Redis are some examples. These offerings can be expensive for large datasets.</p>
<p class="nonindent">If Redis does not perform well for your use case, other options such as Memcached, Apache Kafka, and others can also be explored.</p>
<h1 class="sec" id="s213"><a id="page279" class="calibre6"/><a href="toc.xhtml#s213a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">Caching can improve the user experience and greatly enhance the performance of an application while also making it more stable and scalable. In this chapter, we got familiar with the concepts of caching along with setting up Redis, a popular choice for caching for any size of the application. We learned and implemented the two caching strategies: on demand and proactive caching.</p>
<p class="nonindent">In the next chapter, we will implement the notification module while learning another aspect of Redis: Message Queue.</p>
<h1 class="sec" id="s214"><a href="toc.xhtml#s214a" class="calibre6">Multiple Choice Questions</a></h1>
<ol class="num">
<li class="calibre9">What is the primary goal of implementing caching in an application?
<ol class="alfa">
<li class="calibre9">To increase data processing time.</li>
<li class="calibre9">To store user passwords securely.</li>
<li class="calibre9">To reduce the time needed to access data.</li>
<li class="calibre9">To increase network traffic.</li></ol></li>
<li class="calibre9">What is a significant benefit of caching for handling database queries?
<ol class="alfa">
<li class="calibre9">It increases the load on the application server.</li>
<li class="calibre9">It helps in avoiding database queries by fetching data from the cache.</li>
<li class="calibre9">It decreases the application’s performance.</li>
<li class="calibre9">It consumes more bandwidth.</li></ol></li>
<li class="calibre9">Which of the following is not a pro of caching?
<ol class="alfa">
<li class="calibre9">Performance improvement.</li>
<li class="calibre9">Reduced load on the application.</li>
<li class="calibre9">Increased network traffic.</li>
<li class="calibre9">Cost effectiveness.</li></ol></li>
<li class="calibre9">What does TTL stand for in the context of caching?
<ol class="alfa">
<li class="calibre9">Time To Launch</li>
<li class="calibre9">Time To Live</li>
<li class="calibre9"><a id="page280"/>Total Time Limit</li>
<li class="calibre9">Time To Load</li></ol></li>
<li class="calibre9">What is a ‘<em class="calibre4">cache miss</em>’?
<ol class="alfa">
<li class="calibre9">When data is successfully retrieved from the cache.</li>
<li class="calibre9">When data is not found in the cache.</li>
<li class="calibre9">When the cache is fully utilized.</li>
<li class="calibre9">When the cache fails to save data.</li></ol></li>
<li class="calibre9">What is a key challenge in caching for distributed environments?
<ol class="alfa">
<li class="calibre9">Simplifying user interfaces.</li>
<li class="calibre9">Reducing the number of users.</li>
<li class="calibre9">Keeping cached data and original data source synchronized.</li>
<li class="calibre9">Decreasing the server costs.</li></ol></li>
<li class="calibre9">What is an advantage of building cache at startup?
<ol class="alfa">
<li class="calibre9">It increases the cache size unnecessarily.</li>
<li class="calibre9">It ensures frequently requested data is immediately available.</li>
<li class="calibre9">It slows down the application startup.</li>
<li class="calibre9">It requires less development effort.</li></ol></li>
<li class="calibre9">Which software is used for caching in the described scenario?
<ol class="alfa">
<li class="calibre9">MySQL</li>
<li class="calibre9">Redis</li>
<li class="calibre9">MongoDB</li>
<li class="calibre9">Oracle</li></ol></li>
</ol>
<h1 class="sec1" id="s215"><a href="toc.xhtml#s215a" class="calibre6">Answers</a></h1>
<ol class="num">
<li class="calibre9">c</li>
<li class="calibre9">b</li>
<li class="calibre9">c</li>
<li class="calibre9">b</li>
<li class="calibre9"><a id="page281"/>b</li>
<li class="calibre9">c</li>
<li class="calibre9">b</li>
<li class="calibre9">b</li>
</ol>
<h1 class="sec" id="s216"><a href="toc.xhtml#s216a" class="calibre6">Further Readings</a></h1>
<p class="nonindent"><a href="https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/">https://www.geeksforgeeks.org/caching-system-design-concept-for-beginners/</a></p>
<p class="nonindent"><a href="https://redis.io">https://redis.io</a></p>
<p class="nonindent"><a href="https://redis.io/docs/data-types/json/">https://redis.io/docs/data-types/json/</a></p>
<p class="nonindent"><a href="https://www.npmjs.com/package/redis">https://www.npmjs.com/package/redis</a></p>

</body></html>