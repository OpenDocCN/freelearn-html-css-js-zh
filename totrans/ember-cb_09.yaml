- en: Chapter 9. Real-Life Tasks with Ember.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 使用 Ember.js 的实际任务
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using services with a component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务与组件
- en: Managing basic authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理基本认证
- en: Using **OAuth2** with Ember Simple Auth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **OAuth2** 与 Ember Simple Auth
- en: Using Liquid Fire to create transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Liquid Fire 创建过渡
- en: Working with HTML5 drag and drop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 HTML5 拖放一起工作
- en: Learning Bootstrap with Ember.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ember.js 学习 Bootstrap
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When developing a web application, you'll run into some tricky situations. You
    might need to set up authentication or animations or add transitions. You may
    need to figure out how to use Bootstrap in your application. These scenarios happen
    all the time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 web 应用程序时，你可能会遇到一些棘手的情况。你可能需要设置认证或动画或添加过渡。你可能需要弄清楚如何在你的应用程序中使用 Bootstrap。这些场景经常发生。
- en: In this chapter, we'll go over some more common real-life tasks and some recipes
    that you can use to make life easier when working with Ember.js.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些更常见的实际任务和一些你可以用来使使用 Ember.js 的工作更轻松的食谱。
- en: Using services with a component
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务与组件
- en: In Ember.js, a service is a singleton object that holds state. In other words,
    it can be shared throughout an Ember application and doesn't change. For example,
    session data, APIs that talk to a server, and **WebSockets** are good candidates
    for services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ember.js 中，一个服务是一个单例对象，它持有状态。换句话说，它可以在 Ember 应用程序中共享并且不会改变。例如，会话数据、与服务器通信的
    API 和 **WebSockets** 是很好的服务候选者。
- en: In this recipe, we'll create and inject a service into a component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建并将一个服务注入到组件中。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Dependency injection**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**'
- en: Services and dependency injection go hand in hand. **Dependency Injection**
    (**DI**) occurs when we take objects and inject them into other objects during
    instantiation. This means that we take a service and inject it into our routes,
    controllers, and components. This is an important framework concept and should
    not be overused. Having too many injected services would break the separation
    of concerns design principle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 服务和依赖注入密不可分。**依赖注入**（**DI**）发生在我们将对象在实例化过程中注入到其他对象中时。这意味着我们取一个服务并将其注入到我们的路由、控制器和组件中。这是一个重要的框架概念，不应过度使用。注入过多的服务会破坏关注点分离的设计原则。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, generate these files:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中，生成以下文件：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These files will be used to create our application. The service will hold a
    property and method that returns data.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些文件将被用来创建我们的应用程序。该服务将包含一个属性和一个返回数据的方法。
- en: 'Begin by editing the `start.js` service:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始编辑 `start.js` 服务：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the `services` file. It has an `isOn` property and a method called `importantInfo`
    that returns a string. In this example, we want access to this information in
    our component, `comp-info`, so that it can be displayed.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `services` 文件。它有一个 `isOn` 属性和一个名为 `importantInfo` 的方法，该方法返回一个字符串。在这个例子中，我们想在我们的组件
    `comp-info` 中访问这些信息，以便它可以被显示。
- en: 'Edit the component `comp-info.js` file and add a new action that uses the `start`
    services information:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑组件 `comp-info.js` 文件并添加一个新的动作，该动作使用 `start` 服务的信息：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The most important thing in the component is the `start` property. We can inject
    the `start` service into the component using `Ember.inject.service()`. By convention,
    the name of the property must match the name of the service being injected. In
    our example, the `start` service will be injected.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在组件中，最重要的是 `start` 属性。我们可以使用 `Ember.inject.service()` 将 `start` 服务注入到组件中。按照惯例，属性的名称必须与注入的服务名称匹配。在我们的例子中，`start`
    服务将被注入。
- en: The `pressMe` action toggles the `isOn` property of the `start` service. We
    then `set` the text returned from the `importantInfo` method in the `message`
    property so that it can be displayed in the template.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pressMe` 动作切换 `start` 服务的 `isOn` 属性。然后我们在 `message` 属性中 `set` 从 `importantInfo`
    方法返回的文本，以便可以在模板中显示。'
- en: 'Add `button` to the template information for the component:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向组件的模板信息中添加 `button`：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the component, all we are doing is adding an action to the button and displaying
    a message.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在组件中，我们只是给按钮添加了一个动作并显示了一条消息。
- en: 'Add the `comp-info` component to the application template file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `comp-info` 组件添加到应用程序模板文件中：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the template will display the component that was just created.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在模板将显示刚刚创建的组件。
- en: Start the Ember server, and it will look as follows:![How to do it...](img/00062.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器，它将如下所示：![如何操作...](img/00062.jpeg)
- en: Pressing the button will toggle the `isOn` property. As you can see from this
    example, the service information was accessed by the component and displayed to
    the template.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下按钮将切换`isOn`属性。正如您从本例中可以看到的，组件通过服务访问了信息并将其显示到模板中。
- en: 'Create `initializer` that injects the service into all the components:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`initializer`，将服务注入到所有组件中：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ember.js initializers are created when the application is started. It's a good
    place to preload data or set up the application state. The `app` argument, in
    the `initialize` function, is also known as `Ember.Application`. It serves as
    a registry for dependency declaration. Factories (classes) can be registered and
    injected into the application. The `service:start` is the key for the `start`
    service that we created earlier. Once a factory is registered, it can be injected
    anywhere in the application. As the `start` service has already been created,
    there is no need to register it.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember.js初始化器在应用程序启动时创建。这是一个预加载数据或设置应用程序状态的不错的地方。在`initialize`函数中的`app`参数也被称为`Ember.Application`。它作为依赖声明的注册表。可以注册和注入到应用程序中的工厂（类）。`service:start`是我们之前创建的`start`服务的键。一旦注册了工厂，它就可以在应用程序的任何地方注入。由于`start`服务已经创建，因此不需要注册它。
- en: The `app.inject` takes three arguments. The first is the type to be injected.
    The second is the `name` of the service, `start`. Finally, the `service:start`
    factory is created.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app.inject`接受三个参数。第一个是要注入的类型。第二个是服务的`name`，即`start`。最后，创建`service:start`工厂。'
- en: 'Update the component so that it no longer injects the `start` service as it''s
    already available via the dependency injection:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新组件，使其不再注入`start`服务，因为它已经通过依赖注入可用：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `start` service is commented out so it's no longer available. The rest of
    the component remains the same as the service can still be retrieved using `this.get('start')`.
    This is due to the fact that we injected it into all the components in the initializer.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start`服务已被注释掉，因此不再可用。组件的其他部分保持不变，因为仍然可以使用`this.get(''start'')`检索服务。这是由于我们在初始化器中将它注入到了所有组件中。'
- en: Run the server again and the template loaded will remain the same with the same
    functionality.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行服务器，加载的模板将保持相同，并且具有相同的功能。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Services are long-lived Ember objects that can be used in different parts of
    your application. They are good to use with sessions, WebSockets, geolocation,
    logging, and more. They can be made available to the rest of the application using
    `Ember.inject.service`, which is a method that can retrieve services and make
    them available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是长期存在的Ember对象，可以在应用程序的不同部分使用。它们与会话、WebSockets、地理位置、日志记录等一起使用时很好。可以使用`Ember.inject.service`将它们提供给应用程序的其他部分，这是一个可以检索服务并使其可用的方法。
- en: DI can be used to inject services into many different parts of the Ember application.
    Ember's architecture uses factories that are registered by `Ember.Application`.
    We can inject into all routes, components, and controllers using the `Application.inject`
    method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DI可以用来将服务注入到Ember应用程序的许多不同部分。Ember的架构使用由`Ember.Application`注册的工厂。我们可以使用`Application.inject`方法将服务注入到所有路由、组件和控制台中。
- en: Managing basic authentication
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理基本认证
- en: In any real-world Ember application, at some point, you'll need to deal with
    authentication. For example, users might need to send their credentials to identify
    themselves to the server, or authenticated users may need access to protected
    parts of the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何实际的Ember应用程序中，在某个时候，您将需要处理认证。例如，用户可能需要向服务器发送他们的凭据以识别自己，或者认证用户可能需要访问应用程序的保护部分。
- en: An important aspect of authentication is protecting information based on the
    logged in user. This can be done by creating sessions with the use of tokens.
    In this recipe, we'll create a simple token-based authentication with an Express
    server. This will help us understand the basics. In the next section, we'll go
    over using OAuth2 with Ember Simple Auth.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 认证的一个重要方面是基于登录用户保护信息。这可以通过使用令牌创建会话来完成。在本食谱中，我们将使用Express服务器创建一个简单的基于令牌的认证。这将帮助我们理解基础知识。在下一节中，我们将介绍使用OAuth2与Ember
    Simple Auth。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new application, generate these files:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新应用程序中，生成以下文件：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will generate all the scaffolding that we need for our application. The
    `students` route will be protected. It will only populate information from the
    server if the user is authenticated.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成我们应用程序所需的所有脚手架。`students` 路径将被保护。它将只在用户认证后从服务器获取信息。
- en: The `ember g server index` command will generate a node Express mock server
    for us. In the previous chapters, we used Ember CLI Mirage to do all our mock
    tests. The Express server generated by Ember is not as powerful. However, it will
    be easier to set up our fake server and authentication example. Be aware that
    when deploying an Ember application to production, the Ember server will not be
    included. It will, however, automatically start when running the `ember serve`
    command.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ember g server index` 命令将为我们生成一个 node Express 模拟服务器。在前面的章节中，我们使用 Ember CLI
    Mirage 来进行所有模拟测试。由 Ember 生成的 Express 服务器并不那么强大。然而，它将更容易设置我们的模拟服务器和认证示例。请注意，当将
    Ember 应用程序部署到生产环境时，Ember 服务器将不会包含在内。然而，当运行 `ember serve` 命令时，它将自动启动。'
- en: 'Create a new service called session that will handle our authentication and
    keep track of authenticated users:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 session 的新服务，该服务将处理我们的认证并跟踪已认证的用户：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This service will be injected into our login controller. This will keep track
    of authenticated users and send Ajax requests to the server. The `authenticate`
    method accepts the login name and password. These values are sent to the server
    using an HTTP `POST` method to `/token`. If the login information is correct,
    a token is returned and saved. If not, an error will be returned. We'll deal with
    the error in the login controller later.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此服务将被注入到我们的登录控制器中。这将跟踪已认证的用户并向服务器发送 Ajax 请求。`authenticate` 方法接受登录名和密码。这些值将使用
    HTTP `POST` 方法发送到 `/token`。如果登录信息正确，将返回并保存令牌。如果不正确，将返回错误。我们将在登录控制器中稍后处理此错误。
- en: The `token` property will be used to keep track whether the user is authenticated
    or not.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将使用 `token` 属性来跟踪用户是否已认证。
- en: 'Update the Express server `index.js` file. Add a route for `token`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Express 服务器 `index.js` 文件。为 `token` 添加一个路由：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is our node Express server. It will run when we start the Ember server.
    When the HTTP `POST` `/token` request is sent to the server, it will check the
    body `username` and `password`. For this example, we'll just hardcode them as
    `'erik'` and `'secretcode'`. If these match, it returns `access_token`. If not,
    it returns an invalid message.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们的 node Express 服务器。它将在我们启动 Ember 服务器时运行。当向服务器发送 HTTP `POST` `/token` 请求时，它将检查正文
    `username` 和 `password`。对于此示例，我们将直接将它们硬编码为 `'erik'` 和 `'secretcode'`。如果这些匹配，它将返回
    `access_token`。如果不匹配，它将返回无效消息。
- en: The access token will be saved in the session service. We can use this token
    to authenticate future requests to the server.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问令牌将被保存在 session 服务中。我们可以使用此令牌来认证对服务器的未来请求。
- en: 'Update the `application.js` file. Add a new authorization header:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `application.js` 文件。添加一个新的授权头：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our application, accessing the students route will trigger a request to
    the server. The server will respond to authenticated users only. The server expects
    an authorization bearer header with every Ember Data request. We can do this using
    the `headers` `computed` property and returning the `Authorization: Bearer` header
    with the secret token from the service. Every request to the server, using Ember
    Data, will send this header.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在我们的应用程序中，访问学生路由将触发对服务器的请求。服务器只会对已认证的用户做出响应。服务器期望每个 Ember Data 请求都带有授权 bearer
    头。我们可以使用 `headers` `computed` 属性，并返回来自服务的 `Authorization: Bearer` 头和密钥令牌。使用 Ember
    Data 向服务器发送的每个请求都将发送此头。'
- en: 'Update the Express server index information in order to return information
    to the application if the token matches:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Express 服务器索引信息，以便在令牌匹配时将信息返回给应用程序：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Above `app.post`, you can add `app.get` for the `students` route. Ember will
    trigger this HTTP GET request whenever it enters the `/students` route. The server
    will check whether the request header has the secret code. If it matches, it returns
    the proper JSON data for the `students` route. If not, it returns a 401 error.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `app.post` 之上，你可以为 `students` 路径添加 `app.get`。每当 Ember 进入 `/students` 路径时，它将触发这个
    HTTP GET 请求。服务器将检查请求头是否包含密钥代码。如果匹配，它将返回 `students` 路径的正确 JSON 数据。如果不匹配，它将返回 401
    错误。
- en: 'Verify the route and model information for students:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证学生路由和模型信息：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Earlier, we generated this file with two properties, `name` and `age`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前，我们使用两个属性 `name` 和 `age` 生成此文件：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The students route will send an HTTP GET request to `/students` to retrieve
    the students model. As we defined the application to use the REST adapter, Ember
    will expect the data in the REST format:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学生路由将向 `/students` 发送一个 HTTP GET 请求以检索学生模型。由于我们定义应用程序使用 REST 适配器，Ember 将期望数据以
    REST 格式：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The students template uses the `each` helper to iterate through the model returned
    from the server. It displays each `name` and `age`.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生模板使用 `each` 辅助函数遍历从服务器返回的模型。它显示每个 `name` 和 `age`。
- en: 'Add the login username and property information to the login template:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将登录用户名和属性信息添加到登录模板中：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This template uses the `input` helper for the `loginName` and `password` properties.
    The button triggers the `authenticate` action.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模板使用 `input` 辅助函数为 `loginName` 和 `password` 属性。按钮触发 `authenticate` 动作。
- en: 'Update the login controller to handle the `authenticate` action:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新登录控制器以处理 `authenticate` 动作：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The controller has several properties. It retrieves the session information
    service and uses the `authenticate` method to send the login information to the
    server. The `authenticate` method returns a promise. If it's successful, the application
    transitions to the `students` route. If it's not successful, an error is displayed
    in an alert box. In this example, we are using the ES6 arrow function. The `()=>`
    arrow function is a little shorter than using a function expression and it also
    lexically binds this variable.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制器有几个属性。它检索会话信息服务并使用 `authenticate` 方法将登录信息发送到服务器。`authenticate` 方法返回一个承诺。如果成功，应用程序将过渡到
    `students` 路由。如果不成功，将在警告框中显示错误。在此示例中，我们使用了 ES6 箭头函数。`()=>` 箭头函数比使用函数表达式要短一些，并且它还词法绑定此变量。
- en: 'Update the index with a link to log in:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在索引中添加一个链接以登录：
- en: '[PRE17]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is just a simple link to the login route.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是一个简单的登录路由链接。
- en: Start the server and navigate to the login route. You'll see the following image:![How
    to do it...](img/00063.jpeg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器并导航到登录路由。您将看到以下图像：![如何操作...](img/00063.jpeg)
- en: To log in, enter the username `'erik'` and password `'password'`. After clicking
    `Login`, an HTTP POST request will be sent to the server with the name and password
    information. The Express server that we had set up earlier will respond with the
    token, and the session service will save it. The application will then transition
    to the students route. The following screen will be displayed:![How to do it...](img/00064.jpeg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要登录，请输入用户名 `'erik'` 和密码 `'password'`。点击 `登录` 后，将带有用户名和密码信息的 HTTP POST 请求发送到服务器。我们之前设置的
    Express 服务器将响应令牌，会话服务将保存它。然后，应用程序将过渡到学生路由。以下屏幕将显示：![如何操作...](img/00064.jpeg)
- en: When this route loads, an HTTP GET request will be sent to `/students`. The
    Express server will check to make sure that the authorization bearer header has
    the correct secret code. It then will respond with the JSON data that Ember will
    display.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当此路由加载时，将向 `/students` 发送一个 HTTP GET 请求。Express 服务器将检查以确保授权载体头包含正确的密钥代码。然后，它将响应
    Ember 将显示的 JSON 数据。
- en: If the username or password does not match, the following alert box will be
    displayed:![How to do it...](img/00065.jpeg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户名或密码不匹配，将显示以下警告框：![如何操作...](img/00065.jpeg)
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Token-based authentication requires the client to send over credentials to the
    server. If authorized, the server then sends back a token that the client saves
    and uses on subsequent requests to the server. If the token is not present, the
    server may not return data to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证要求客户端向服务器发送凭据。如果授权，服务器随后将发送一个令牌，客户端将其保存并用于随后的服务器请求。如果令牌不存在，服务器可能不会向客户端返回数据。
- en: This recipe is a simple example of using authentication. It lacks proper error
    handling and session persistence. Nevertheless, it gives you an idea of how authentication
    works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方是使用认证的简单示例。它缺少适当的错误处理和会话持久性。尽管如此，它为您提供了认证是如何工作的一个想法。
- en: Using OAuth2 with Ember Simple Auth
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 和 Ember Simple Auth
- en: OAuth2 specifies authorization flows for web applications. We can use it with
    Ember to secure our application and provide data to only those users that are
    authorized. In this recipe, we'll look at using OAuth2 with **Ember Simple Auth**
    (**ESA**), a robust add-on for Ember.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 为网络应用程序指定了授权流程。我们可以使用它与 Ember 保护我们的应用程序，并只为授权用户提供数据。在此配方中，我们将查看如何使用 OAuth2
    与 **Ember Simple Auth**（**ESA**），这是一个强大的 Ember 扩展。
- en: ESA will handle our client-side session and authentication and send the requests
    to the server. It's very customizable and extensible. Although it can be complicated,
    just like our last recipe, we'll create a protected students route that can be
    accessed by authorized users only.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ESA将处理我们的客户端会话和认证，并将请求发送到服务器。它非常可定制和可扩展。尽管它可能很复杂，就像我们上一个食谱一样，我们将创建一个只能由授权用户访问的保护学生路由。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purposes of this example, we''ll need an OAuth2 server. Setting up
    an OAuth2 server is beyond the scope of this recipe. There are several OAuth2
    libraries out there that you can use to set one up. I recommend the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我们需要一个OAuth2服务器。设置OAuth2服务器超出了本食谱的范围。有多个OAuth2库可供使用来设置一个服务器。我推荐以下：
- en: '**Rails**: [https://github.com/doorkeeper-gem/doorkeeper](https://github.com/doorkeeper-gem/doorkeeper)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rails**: [https://github.com/doorkeeper-gem/doorkeeper](https://github.com/doorkeeper-gem/doorkeeper)'
- en: '**Express**: [https://github.com/thomseddon/node-oauth2-server](https://github.com/thomseddon/node-oauth2-server)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Express**: [https://github.com/thomseddon/node-oauth2-server](https://github.com/thomseddon/node-oauth2-server)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new Ember application, run the generator command to create the required
    files:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的Ember应用程序中，运行生成器命令以创建所需的文件：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will generate the scaffolding that we need to begin our application. The
    last command installs the add-on for ESA.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成我们开始应用程序所需的脚手架。最后一个命令安装了ESA的插件。
- en: We'll begin by setting up the Ember Simple Auth authenticator and authorizer
    for OAuth2\. We need to set this up so that a user can authenticate with the server.
    Create two new directories in the `app` folder called `authenticators` and `authorizers`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先设置Ember Simple Auth认证器和授权器以支持OAuth2。我们需要设置它，以便用户可以与服务器进行认证。在`app`文件夹中创建两个新的目录，分别命名为`authenticators`和`authorizers`。
- en: 'Add a new file called `oauth2-custom.js` to the `authenticators` directory
    and `application.js` to the `authorizers` folder. Add this code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`authenticators`目录中添加一个名为`oauth2-custom.js`的新文件，并在`authorizers`文件夹中添加`application.js`。添加以下代码：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `authenticators` file is used by ESA whenever a user logs in. We can overwrite
    anything in the authenticator if needed. The `makeRequest` method is used to send
    messages to the server. By default, ESA will make an HTTP `POST` request to `/token`
    with the username and password in the form field.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户登录时，ESA会使用`authenticators`文件。如果需要，我们可以覆盖认证器中的任何内容。`makeRequest`方法用于向服务器发送消息。默认情况下，ESA将使用包含用户名和密码的表单字段的HTTP
    `POST`请求发送到`/token`。
- en: 'Unfortunately, many OAuth2 servers require a header called `Authorization`
    `Basic` with a secret client ID and client secret when authenticating for the
    first time with a server. To fix this, we can extend the `makeRequest` method
    with our own Ajax request. This will be used when we log in:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，许多OAuth2服务器在首次使用服务器进行认证时需要名为`Authorization` `Basic`的头部，其中包含秘密客户端ID和客户端密钥。为了解决这个问题，我们可以通过我们的自定义Ajax请求扩展`makeRequest`方法。这将在我们登录时使用：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `authorizers` file is used by ESA to tell which type of authentication we
    are using. In this example, we are using Oauth2 as defined by `OAuth2Bearer.extend()`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`authorizers`文件由ESA使用，以告诉我们使用哪种类型的认证。在本例中，我们使用`OAuth2Bearer.extend()`定义的Oauth2。'
- en: 'Update the adapter and add the ESA data adapter mixin to the `application.js`
    file in the `adapters` folder:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新适配器并将ESA数据适配器混入添加到`adapters`文件夹中的`application.js`文件：
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The adapter tells Ember to make all requests to the `/api` namespace. The ESA
    `DataAdapterMixin` is used to define the authorizer that the application will
    use. In this case, all Ember Data requests will use the OAuth2 application authorizer
    that we defined earlier. In other words, any request sent to the server using
    Ember Data will include the session data token, if it exists.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 适配器告诉Ember将所有请求发送到`/api`命名空间。ESA的`DataAdapterMixin`用于定义应用程序将使用的授权器。在这种情况下，所有Ember
    Data请求都将使用我们之前定义的OAuth2应用程序授权器。换句话说，任何使用Ember Data发送到服务器的请求，如果存在，都将包含会话数据令牌。
- en: 'Let''s update our login-comp component template:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新我们的`login-comp`组件模板：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will submit the `login` and `password` to the `authenticate` action setup
    in our component.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将提交`login`和`password`到我们在组件中设置的`authenticate`操作。
- en: 'Update the login page component with the `authenticate` action:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新登录页面组件的`authenticate`操作：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we are using ESA, we have access to a `session` service. This `session` service
    has an `authenticate` method that uses `authenticator` that we created earlier.
    In the preceding code, we used the `this.get()` method to get `login` and `password`
    from our template. We then called the `authenticate` method on our service, passing
    in our `authenticator`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使用欧空局（ESA），我们可以访问一个 `session` 服务。这个 `session` 服务有一个 `authenticate` 方法，它使用我们之前创建的
    `authenticator`。在上面的代码中，我们使用 `this.get()` 方法从我们的模板中获取 `login` 和 `password`。然后我们在我们的服务上调用
    `authenticate` 方法，并传入我们的 `authenticator`。
- en: If the server returns a successful message, then we call `transition`, a method
    that is passed to the component. If not, an alert box pops up telling the user
    that their login was not successful.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果服务器返回成功消息，那么我们调用 `transition` 方法，这是一个传递给组件的方法。如果不成功，则弹出一个警告框告诉用户他们的登录不成功。
- en: 'Add the login page component to the login template, and update the login controller:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将登录页面组件添加到登录模板中，并更新登录控制器：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This calls the login component and passes in the parent action, `loggedIn`:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这调用登录组件并传入父级动作 `loggedIn`：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This action transitions the application to the `students` route. It's triggered
    only with a successful login. It's also the name of the action passed in the login
    page component.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个动作将应用过渡到 `students` 路由。它仅在成功登录时触发。它也是传递给登录页面组件的动作的名称。
- en: 'Update the students controller, route, and template:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新学生控制器、路由和模板：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The template displays the information from the server using the `each` helper.
    A `logout` button action will log the user out:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模板使用 `each` 辅助函数显示来自服务器的信息。一个 `logout` 按钮动作将用户登出：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `logout` action invalidates the session. Invalidating the session revokes
    the token so that it is no longer available:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`logout` 动作使会话无效。使会话无效将吊销令牌，使其不再可用：'
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This route returns all the information for the `student` model. You'll notice
    that `AuthenticatedRouteMixin` is added. This tells Ember to make this route available
    only if it's authenticated by the server. If it's not, it will route back to the
    application.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个路由返回 `student` 模型的所有信息。你会注意到添加了 `AuthenticatedRouteMixin`。这告诉 Ember 只有在服务器认证后，这个路由才是可用的。如果没有认证，它将路由回应用。
- en: 'Add the application mixin to the application route:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序混合添加到应用程序路由：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ESA's `ApplicationRouteMixin` will catch any errors and transition to the login
    route.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 欧空局（ESA）的 `ApplicationRouteMixin` 将捕获任何错误并过渡到登录路由。
- en: 'Update the index template with a link to the login route:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用链接到索引模板中的登录路由：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `link-to` helper links to the `login` route.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`link-to` 辅助函数链接到 `login` 路由。'
- en: 'Start the Ember server and OAuth2 server:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Ember 服务器和 OAuth2 服务器：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `--proxy` argument tells Ember to proxy all server requests to `localhost`
    at port `3000`. We'll assume, in this example, that the OAuth2 server is running
    on port `3000` in your local box.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--proxy` 参数告诉 Ember 将所有服务器请求代理到 `localhost` 的 `3000` 端口。在这个例子中，我们将假设 OAuth2
    服务器正在你的本地机器上的 `3000` 端口上运行。'
- en: 'A successful login will look like this:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功登录看起来像这样：
- en: '![How to do it...](img/00066.jpeg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/00066.jpeg)'
- en: 'It will then redirect to the students route. This route will send a request
    to the server with an authorization bearer request with the correct token. It
    will receive the student data so that it can be displayed to the user:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，它将重定向到学生路由。这个路由将向服务器发送一个带有正确令牌的授权携带请求。它将接收学生数据，以便将其显示给用户：
- en: '![How to do it...](img/00067.jpeg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/00067.jpeg)'
- en: Accessing this route without being logged in causes redirection to the login
    page.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未登录就访问此路由，将导致重定向到登录页面。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Ember Simple Auth add-on manages the session, authentication, authorization,
    persistence, and communication with a server. It has its own built-in session
    service that makes it easy to manage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ember Simple Auth 插件管理会话、身份验证、授权、持久化和与服务器的通信。它有一个内置的会话服务，这使得管理变得容易。
- en: OAuth2 is a specification of a type of flow when doing authentication in web
    apps. As Ember is a single-page application, there is not much security on the
    application side. It must rely on a server to authenticate and manage tokens.
    ESA makes this possible by handling all the work needed to send and communicate
    with the server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 是在 Web 应用中进行身份验证时的一种流类型的规范。由于 Ember 是单页应用，应用端的安全性不高。它必须依赖于服务器来进行身份验证和管理令牌。ESA
    通过处理与服务器发送和通信所需的所有工作来实现这一点。
- en: Using Liquid Fire to create transitions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Liquid Fire 创建过渡
- en: '**Ember Liquid Fire** is an add-on for Ember that handles animations and transitions.
    It''s a toolkit of sorts that splits its responsibilities between template headers,
    transition maps, and transitions.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ember Liquid Fire** 是一个处理动画和转换的 Ember 插件。它是一种工具包，将责任分割为模板标题、转换映射和转换。'
- en: In this recipe, we'll create a few transitions to see how this add-on works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建几个转换来查看这个插件是如何工作的。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a new Ember application, generate these files:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的 Ember 应用程序中，生成以下文件：
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will generate the scaffolding for the `tut1` and `tut2` routes as well
    as install the `liquid-fire` add-on.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为 `tut1` 和 `tut2` 路由生成脚手架，并安装 `liquid-fire` 插件。
- en: 'Create a new `transitions.js` file in the root of the `app` folder. Add a few
    transitions:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹的根目录中创建一个新的 `transitions.js` 文件。添加一些转换：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Liquid Fire requires a transitions map file. There are a number of predefined
    transitions that you have available:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Liquid Fire 需要一个转换映射文件。有多个预定义的转换可供使用：
- en: '`toLeft`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLeft`'
- en: '`toRight`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toRight`'
- en: '`toUp`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUp`'
- en: '`toDown`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toDown`'
- en: '`crossFade`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crossFade`'
- en: '`fade`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fade`'
- en: Each one behaves as you would expect. The `toLeft` transition will create a
    transition animation where the page moves from left to right. The `toRight` transition
    is the exact opposite. You can also create your own animations if needed.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每一个都表现得像您预期的那样。`toLeft` 转换将创建一个从左到右移动页面的转换动画。`toRight` 转换则正好相反。如果需要，您也可以创建自己的动画。
- en: The map tells us which transitions to use when moving from one route to another.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个映射告诉我们从一条路由移动到另一条路由时应该使用哪些转换。
- en: 'Update the application template with the Liquid Fire outlet:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Liquid Fire 输出更新应用程序模板：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To use Liquid Fire transitions, we must use `liquid-outlet`. This is used when
    transitioning between routes. Here are all the template helpers available:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用 Liquid Fire 转换，我们必须使用 `liquid-outlet`。这用于在路由之间进行转换。以下是所有可用的模板助手：
- en: '`{{#liquid-outlet}}`: This transitions between routes'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#liquid-outlet}}`：在路由之间进行转换'
- en: '`{{#liquid-with}}`: This transitions between models or contexts in a single
    route'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#liquid-with}}`：在单个路由中在模型或上下文之间进行转换'
- en: '`{{#liquid-bind}}`: This updates to simple bound values'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#liquid-bind}}`：这更新到简单的绑定值'
- en: '`{{#liquid-if}}`: This switches between true and false branches in a `#if`
    statement'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#liquid-if}}`：在 `#if` 语句中在 true 和 false 分支之间切换'
- en: '`{{#liquid-spacer}}`: This provides a smoothly growing/shrinking container
    that animates whenever the contained **Document Object Model** (**DOM**) mutates'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{#liquid-spacer}}`：这提供了一个平滑增长/缩小的容器，当包含的 **文档对象模型** (**DOM**) 发生变化时，它会进行动画处理'
- en: 'In the index template file, add a link to the `tut1` route:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在索引模板文件中，添加一个链接到 `tut1` 路由：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `link-to` helper transitions to the `tut1` route. The liquid outlet will
    display the `tut1` route when it renders.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`link-to` 助手转换到 `tut1` 路由。当渲染时，液体输出将显示 `tut1` 路由。'
- en: 'Update the `tut1` and `tut2` route templates:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `tut1` 和 `tut2` 路由模板：
- en: '[PRE36]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All this does is have a link to the second route `tut2`:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些只是有一个链接到第二个路由 `tut2`：
- en: '[PRE37]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This has a link back to `tut1`.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这有一个链接回到 `tut1`。
- en: Run the server and you'll see the transitions as you click on the links:![How
    to do it...](img/00068.jpeg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器，您将在点击链接时看到转换：![如何做到这一点...](img/00068.jpeg)
- en: This is what it looks like mid-transition using crossfade from the application
    route to the `tut1` route.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在转换过程中使用交叉淡入从应用程序路由到 `tut1` 路由时的样子。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Liquid Fire is a versatile add-on for Ember that brings transitions and animation
    to life. It uses a simple transition map and template helpers to make things easier.
    Under the hood, Liquid Fire uses many tricks to make these animations possible.
    It's extensible, so you can create your own transitions as well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Liquid Fire 是 Ember 的一个多功能插件，它为 Ember 带来了生命力和动画。它使用简单的转换映射和模板助手来简化操作。在底层，Liquid
    Fire 使用许多技巧来实现这些动画。它是可扩展的，因此您可以创建自己的转换。
- en: Working with HTML5 drag and drop
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML5 拖放
- en: Drag and drop is a part of the HTML5 standard. It allows the user to grab objects
    in the DOM and drop them at different locations. Any element can be draggable
    if the browser supports it. Most modern browsers do.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放是 HTML5 标准的一部分。它允许用户在 DOM 中抓取对象并将它们拖放到不同的位置。如果浏览器支持，任何元素都可以被拖放。大多数现代浏览器都支持。
- en: In this recipe, we'll see an example of dragging an IMG file to a drop zone
    on the screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到一个例子，将 IMG 文件拖动到屏幕上的拖放区域。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a new application, generate these files:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的应用程序中，生成以下文件：
- en: '[PRE38]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `drag-drop-zone` component will represent the area where each item will
    be dropped. The `drag-drop` component will be the item to be dropped.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`drag-drop-zone`组件将代表每个项目将被放置的区域。`drag-drop`组件将是将被放置的项目。'
- en: 'Edit the `drag-drop-zone.js` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`drag-drop-zone.js`文件：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This component has a few special events attached to it. Ember has built-in events
    for `dragLeave`, `dragOver`, and `drop`. These will fire whenever items are dragged
    on top of the component. Remember that all components render as `div` tags. We
    can use the `classNames` property to add more classes.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此组件附加了一些特殊事件。Ember内置了`dragLeave`、`dragOver`和`drop`事件。每当项目被拖到组件上时，这些事件都会触发。记住，所有组件都以`div`标签的形式渲染。我们可以使用`classNames`属性添加更多类。
- en: The `classNameBindings` property allows classes to be added to the component
    as if they were properties. In other words, `dragClass` can be set dynamically
    in the component. We'll use this to change the color of the `drop` zone when items
    are dragged over it. When items are dropped, the `drop` event is triggered.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`classNameBindings`属性允许将类添加到组件中，就像它们是属性一样。换句话说，`dragClass`可以在组件中动态设置。我们将使用它来改变当项目被拖过时`drop`区域的颜色。当项目被放置时，将触发`drop`事件。'
- en: 'Update the drag drop component:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新拖放组件：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As mentioned earlier, normally, components render as a `div` tag. However, we
    can change this using the `tagName` property. In the `drag-drop` component, we
    are creating an `image` tag. The `dragStart` event available in Ember. In this
    example, we are setting the data to the target ID.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，通常，组件以`div`标签的形式渲染。然而，我们可以使用`tagName`属性来改变这一点。在`drag-drop`组件中，我们正在创建一个`image`标签。在Ember中可用`dragStart`事件。在这个例子中，我们将数据设置为目标ID。
- en: To drag items in HTML5, you must have a `draggable` attribute on the tag. It
    also must be set to `true`. We'll use `attributeBindings` to make this possible.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在HTML5中拖动项目，必须在标签上有一个`draggable`属性。它也必须设置为`true`。我们将使用`attributeBindings`来实现这一点。
- en: 'Update the `app.css` file:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.css`文件：
- en: '[PRE41]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is some basic `css` that creates a border around the `drop` zone and changes
    the color to `red` when an item is about to be dropped.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一些基本的`css`，它为`drop`区域创建了一个边框，并在项目即将被放置时将颜色改为`red`。
- en: 'The last step is to add the components to the application template file:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将组件添加到应用程序模板文件中：
- en: '[PRE42]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will render the two components to the application template.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将渲染两个组件到应用程序模板中。
- en: Render the page and you'll see the picture and dropzone:![How to do it...](img/00069.jpeg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染页面，您将看到图片和`dropzone`：![如何操作...](img/00069.jpeg)
- en: 'You can drag the picture into the box:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将图片拖入框中：
- en: '![How to do it...](img/00070.jpeg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/00070.jpeg)'
- en: The box will turn red before the item is dropped and back to black after it's
    dropped.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在项目放置之前，框会变成红色，在放置后恢复为黑色。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The HTML5 standard allows dragging and dropping elements. Ember has several
    built-in events that we can use in components and controllers. The `dragLeave`,
    `dragOver`, `drop`, and `dragStart` methods can all be used to capture events
    to allow dragging and dropping.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5标准允许拖放元素。Ember在组件和控制器中提供了几个内置事件，我们可以使用这些事件来捕获事件以允许拖放。`dragLeave`、`dragOver`、`drop`和`dragStart`方法都可以用来捕获事件。
- en: Learning Bootstrap with Ember.js
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ember.js学习Bootstrap
- en: Bootstrap, formerly known as Twitter Bootstrap, is a popular, free, and open
    source collection of tools to create websites and applications. It contains several
    templates for typography, forms, buttons, and navigation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap，以前称为Twitter Bootstrap，是一个流行的、免费的、开源的工具集合，用于创建网站和应用。它包含多个模板，用于排版、表单、按钮和导航。
- en: You can use Bootstrap to make nice and simple user interfaces. In this recipe,
    we'll use it to create a drop-down menu.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Bootstrap创建漂亮且简单的用户界面。在这个菜谱中，我们将使用它来创建一个下拉菜单。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In a new Ember application, use Bower to install the latest version of Bootstrap:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的Ember应用程序中，使用Bower安装Bootstrap的最新版本：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This uses Bower's frontend package manager to install Bootstrap. It will be
    saved as a development dependency in the `bower.json` file.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使用Bower的前端包管理器来安装Bootstrap。它将被保存为`bower.json`文件中的开发依赖项。
- en: 'Update the `ember-cli-build.js` file and add the libraries for Ember Bootstrap:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ember-cli-build.js`文件并添加Ember Bootstrap库：
- en: '[PRE44]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `app.import` statement takes the asset path as the first and only argument.
    This is standard for non-AMD assets. Once this is loaded, we can use Bootstrap
    anywhere in our application.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app.import`语句将资产路径作为第一个也是唯一的参数。这对于非AMD资产是标准的。一旦加载，我们就可以在应用程序的任何地方使用Bootstrap。'
- en: 'Add a drop-down button to the application template:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下拉按钮添加到应用程序模板中：
- en: '[PRE45]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will add a drop-down button.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将添加一个下拉按钮。
- en: Start the server and you'll see the rendered button:![How to do it...](img/00071.jpeg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器，你将看到渲染后的按钮：![如何操作...](img/00071.jpeg)
- en: After clicking on the button, the menu will be displayed.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击按钮后，菜单将会显示。
- en: 'Let''s install the Bootstrap Ember add-on and comment out `app.imports` in
    the `ember-cli-build.js` file:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安装 Bootstrap Ember 附加组件，并在 `ember-cli-build.js` 文件中取消注释 `app.imports`：
- en: '[PRE46]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Ember Bootstrap is an add-on that includes all the normal `css` and icon assets
    in your project. It also includes a set of native Ember components. It does not
    use the Bootstrap JavaScript file:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember Bootstrap 是一个附加组件，它包含了项目中所有的正常 `css` 和图标资产。它还包括一组本地的 Ember 组件。它不使用 Bootstrap
    JavaScript 文件：
- en: '[PRE47]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we are using the add-on, we must comment out the Bootstrap files. They are
    already included.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用附加组件，我们必须在 `Bootstrap` 文件中取消注释。它们已经被包含在内。
- en: 'Update the application template file using the new Ember Bootstrap components:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的 Ember Bootstrap 组件更新应用程序模板文件：
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All the Ember Bootstrap components start with `bs`. The `{{bs-dropdown}}` component
    creates a drop-down menu that displays links to the user.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有 Ember Bootstrap 组件都以 `bs` 开头。`{{bs-dropdown}}` 组件创建一个下拉菜单，显示用户链接。
- en: Using Ember Bootstrap can be a little cleaner and easier than installing Bootstrap
    with Bower.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 Ember Bootstrap 可能会比使用 Bower 安装 Bootstrap 更干净、更简单。
- en: Load the server and you'll see the following image:![How to do it...](img/00072.jpeg)
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载服务器，你将看到以下图片：![如何操作...](img/00072.jpeg)
- en: This is using Ember Bootstrap to create a menu.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在使用 Ember Bootstrap 创建菜单。
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Bootstrap is a versatile set of tools that can help you design a frontend quickly.
    Ember accepts assets using a library called Broccoli. Broccoli is an asset pipeline—it
    helps build the application. The `app.import` statement is used to bring AMD and
    non-AMD assets in the application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一套多功能的工具集，可以帮助你快速设计前端。Ember 使用名为 Broccoli 的库来接受资产。Broccoli 是一个资产管道——它帮助构建应用程序。`app.import`
    语句用于将 AMD 和非 AMD 资产引入应用程序。
- en: On the other hand, the Ember Bootstrap library can also be used. It has easy-to-use
    components built-in that make it easy to add buttons and menus.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Ember Bootstrap 库也可以使用。它内置了易于使用的组件，使得添加按钮和菜单变得简单。
