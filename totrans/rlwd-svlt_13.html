<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor187"/>13</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor188"/>Using Transitions</h1>
<p>Transitions are<a id="_idIndexMarker496"/> essential in creating smooth and engaging user experiences. By defining how elements appear, disappear, or change within a user interface, transitions can turn ordinary interactions into captivating experiences that leave lasting impressions on users.</p>
<p>Over the next three chapters, we will explore the topic of transitions in Svelte, beginning with a comprehensive understanding of how to use transitions in Svelte.</p>
<p>In this chapter, we will start by learning how to add transitions to elements in Svelte. We will explore the different transition directives and learn how to customize the transitions.</p>
<p>After that, we will discuss when and how the transitions are being played. We will look at different scenarios, such as where there’s a mix of elements with and without transitions, or when the elements are within nested logical blocks.</p>
<p>To truly master transitions, it’s important to understand the inner workings of the Svelte transition system. We will conclude the chapter by examining the underlying mechanics and offering insights that will help you optimize your use of transitions in your projects.</p>
<p>By the end of this chapter, you will have a solid foundation in Svelte transitions, allowing you to create engaging and dynamic user interfaces with ease.</p>
<p>This chapter includes sections on the following:</p>
<ul>
<li>How to add transitions to elements</li>
<li>When the transitions for the elements are played</li>
<li>How transitions work under the hood</li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor189"/>Technical requirements</h1>
<p>You can find the code used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13</a>.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Adding transitions to elements</h1>
<p>Svelte <a id="_idIndexMarker497"/>provides a simple and powerful way to add transitions to your application elements. The framework offers built-in transition functions that can be easily applied to elements, allowing for smooth animations and seamless user experiences. You can also define your own custom transitions, which we will learn about in the next chapter.</p>
<p>Transitions in Svelte are applied to elements when the elements are mounted or unmounted from the DOM. This ensures that elements appear and disappear gracefully, rather than just abruptly popping in and out of view.</p>
<p>To add a transition to an element in Svelte, you can use the <code>transition:</code> directive with the desired transition function. Here’s an example of adding a transition to an element:</p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fade&gt;some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, we imported <code>fade</code> from <code>svelte/transition</code> and applied it to the <code>&lt;</code><code>div&gt;</code> element.</p>
<p>What you will see with the preceding code is that when the <code>&lt;div&gt;</code> element is mounted onto the DOM, the <code>&lt;div&gt;</code> element will smoothly fade in. When the <code>&lt;div&gt;</code> element is unmounted from the DOM, the <code>&lt;div&gt;</code> element will smoothly fade out.</p>
<p>The <code>transition:</code> directive sets the transitions played when the element is both mounted onto the DOM and unmounted from the DOM. If you want to have finer control over which transitions are played as the element is mounted or unmounted, you can use the <code>in:</code> and <code>out:</code> directives instead:</p>
<pre class="source-code">
&lt;script&gt;
  import { fade, blur } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fade out:blur&gt;some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, we applied <code>fade</code> as the in transition and <code>blur</code> as the out transition. When the <code>&lt;div&gt;</code> element is mounted onto the DOM, the <code>&lt;div&gt;</code> element will <a id="_idIndexMarker498"/>smoothly fade in. When the <code>&lt;div&gt;</code> element is unmounted from the DOM, the <code>&lt;div&gt;</code> element will smoothly blur out.</p>
<p>Thus, the <code>transition:</code> directive is essentially a shorthand for both <code>in:</code> and <code>out:</code> transitions. In other words, the transitions applied to the two elements in the following snippet are functionally identical:</p>
<pre class="source-code">
&lt;div transition:blur&gt;some text here&lt;/div&gt;</pre> <p>So, the preceding code snippet is similar to the following code snippet:</p>
<pre class="source-code">
&lt;div in:blur out:blur&gt;some text here&lt;/div&gt;</pre> <p>From the preceding examples, we have seen two of Svelte’s built-in transitions, <code>fade</code> and <code>blur</code> – let us look at more of them!</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>Svelte’s built-in transitions</h2>
<p>Svelte’s <a id="_idIndexMarker499"/>built-in transitions are exported from the <code>svelte/transition</code> module.</p>
<p>The following list provides an overview of Svelte’s built-in transitions:</p>
<ul>
<li><code>fade</code>: This<a id="_idIndexMarker500"/> transition smoothly fades an element in or out, adjusting its opacity over time</li>
<li><code>blur</code>: The <code>blur</code> transition <a id="_idIndexMarker501"/>gradually applies or removes a blur effect on an element</li>
<li><code>slide</code>: The <code>slide</code> transition<a id="_idIndexMarker502"/> makes an element slide smoothly in or out of view</li>
<li><code>fly</code>: The <code>fly</code> transition <a id="_idIndexMarker503"/>makes an element smoothly translate from a specified <code>x</code> and <code>y</code> offset</li>
<li><code>scale</code>: This<a id="_idIndexMarker504"/> transition causes an element to grow or shrink in size while appearing or disappearing</li>
<li><code>draw</code>: The<a id="_idIndexMarker505"/> <code>draw</code> transition creates a drawing or erasing effect on SVG paths</li>
</ul>
<p>As you go through the list of built-in transitions, you may notice that some of these transitions rely on user-specified values. For example, the <code>fly</code> transition depends on the specified <code>x</code> and <code>y</code> offset from which the element should fly when transitioning in.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor192"/>Customizing a transition</h2>
<p>To make<a id="_idIndexMarker506"/> use of these transitions with their required values, you can pass a configuration object containing the necessary properties to the transition directive:</p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fly={{ x: 200, y: 100 }}&gt;Content goes here&lt;/div&gt;</pre> <p>In the preceding code snippet, we apply the <code>fly</code> transition with the specified <code>x</code> and <code>y</code> offsets, indicating that the element will fly in from 200 pixels to the right and 100 pixels down. By providing the appropriate values, you can achieve a wide range of customized transition effects in your Svelte components.</p>
<p>This approach can be particularly useful when you want an element to fly to a different location as it transitions out, compared to the location from which it flies in during the transition.</p>
<p>Instead of using the <code>transition:</code> directive and having only one configuration for both in and out transitions, you can separate it into the <code>in:</code> and <code>out:</code> directives and pass different configuration objects to each directive.</p>
<p>An example of this can be seen in the following code snippet:</p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 200, y: 100 }} out:fly={{ x: -200, y: 50 }}&gt;Content goes here&lt;/div&gt;</pre> <p>The <code>&lt;div&gt;</code> element flies in from 200 pixels to the right and 100 pixels down, while it flies out 200 pixels to the left and 50 pixels down. By separating the <code>transition:</code> directive into <code>in:</code> and <code>out:</code> directives, you can control the in and out transition with different configuration objects, having more intricate transition effects in your Svelte components.</p>
<p>In addition <a id="_idIndexMarker507"/>to custom configurations specific to each transition, all of Svelte’s built-in transitions accept <code>delay</code>, <code>duration</code>, and <code>easing</code> as part of the transition configuration. These parameters allow you to control the timing of your animations, providing greater flexibility in designing your user interface.</p>
<p>The <code>delay</code> parameter determines the waiting time before the transition begins while the <code>duration</code> parameter specifies how long the transition lasts. By modifying these values, you can coordinate when a transition begins and how long each transition takes, creating more complex and engaging animations.</p>
<p>Here is an example of adjusting the <code>delay</code> and <code>duration</code> values of a <code>fade</code> transition:</p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fade=<code>fade</code> transition will start with a 500 ms delay after it is mounted onto the DOM, and the transition will last for 1000 ms.</p>
<p>On the other hand, <code>easing</code> is a function that is responsible for controlling the pacing of the animation. By adjusting the <code>easing</code> function, you can create animations that start slow and end fast, start fast and end slow, or follow a custom pattern, giving you even more control over the look and feel of your animations.</p>
<p>Svelte comes with a collection of built-in <code>easing</code> functions, which can be imported from <code>svelte/easing</code>. These <code>easing</code> functions can then be applied to transitions, as seen in the following code:</p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
  import { quadInOut } from 'svelte/easing';
&lt;/script&gt;
&lt;div transition:fade=<code>fade</code> transition uses the <code>quadInOut</code> <code>easing</code> function, which causes the animation to start slowly, accelerate, and then end slowly. By incorporating different <code>easing</code> functions into your transitions, you can create a variety of animations for your application.</p>
<h3>Exercise – discovering Svelte’s built-in transitions</h3>
<p>As a <a id="_idIndexMarker509"/>practice exercise, try to visit the official <a id="_idIndexMarker510"/>Svelte documentation and identify the list of configurable properties for each built-in transition.</p>
<p>To get you started, here is a list of Svelte’s built-in transitions:</p>
<ul>
<li><code>fade</code></li>
<li><code>blur</code></li>
<li><code>fly</code></li>
<li><code>slide</code></li>
<li><code>scale</code></li>
<li><code>draw</code></li>
</ul>
<p>We know that transitions are played when elements are mounted or unmounted from the DOM, but when and how exactly are the transitions played?</p>
<p>Let us explore the timing and manner in which the transitions are played in the next section.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>When are the transitions played?</h1>
<p>The<a id="_idIndexMarker511"/> transitions in Svelte are played when elements are added or removed from the DOM.</p>
<p><code>in:</code> transitions are executed when an element is added to the DOM. This usually occurs when a component is initialized or when a condition that controls the element’s rendering becomes <code>true</code>.</p>
<p>For <a id="_idIndexMarker512"/>example, in an <code>{#if}</code> block, when the <code>if</code> condition turns from falsy to truthy, the elements inside the <code>{#if}</code> block are added to the DOM. All the <code>in:</code> transitions applied to these elements will be <strong class="bold">played simultaneously</strong> as soon as the elements are inserted into the DOM:</p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade&gt;some content&lt;/div&gt;
  &lt;div transition:blur&gt;more content&lt;/div&gt;
{/if}</pre> <p>In the preceding code snippet, as <code>condition</code> turns to <code>true</code>, both <code>&lt;div&gt;</code> elements will be inserted into the DOM. As soon as both <code>&lt;div&gt;</code> elements are inserted, both the <code>fade</code> and <code>blur</code> transitions will start playing simultaneously. Whether both the <code>fade</code> and <code>blur</code> transitions end at the same time depends on the specified duration for each transition.</p>
<p>Conversely, <code>out:</code> transitions are executed when an element is removed from the DOM. This can happen when a component is destroyed, or when a condition that controls the element’s rendering becomes <code>false</code>.</p>
<p>The transition begins as soon as the element is scheduled for removal from the DOM. After the transition is complete, the element is removed from the DOM.</p>
<p>Let us illustrate this with an example:</p>
<pre class="source-code">
{#if condition}
  &lt;div out:fade&gt;some content&lt;/div&gt;
  &lt;div transition:blur&gt;more content&lt;/div&gt;
{/if}</pre> <p>In the preceding code snippet, when <code>condition</code> turns to <code>false</code>, both the <code>&lt;div&gt;</code> elements remain in the DOM, even though the condition is no longer true. This is because the <code>out:</code> transition needs to be played on both <code>&lt;div&gt;</code> elements before they are removed from the DOM. If the <code>&lt;div&gt;</code> elements were removed from the DOM immediately, they would no longer be visible to users, rendering any subsequent <code>out:</code> transitions ineffective and invisible.</p>
<p>Both <code>fade</code> and <code>blur</code> transitions will play simultaneously on both the <code>&lt;div&gt;</code> elements as <code>out:</code> transitions. Similar to the <code>in:</code> transition, the duration of each transition depends on the specified duration for each transition.</p>
<p>Once all <a id="_idIndexMarker513"/>the <code>out:</code> transitions have finished playing, both <code>&lt;div&gt;</code> elements will be removed from the DOM together, making the DOM state consistent with the updated value of <code>condition</code>.</p>
<p>In the previous examples explaining when <code>in:</code> and <code>out:</code> transitions are played, all elements within the <code>{#if}</code> block had transitions applied to them, resulting in the transitions being played simultaneously in all the elements in the <code>{#if}</code> block. But, what happens if not all elements inside the <code>{#if}</code> block have transitions applied? Let’s discuss that next.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor194"/>Handling mixed transition and static elements</h2>
<p>When <a id="_idIndexMarker514"/>some elements inside an <code>{#if}</code> block have transitions applied and others do not, Svelte handles each element differently based on the specified transitions.</p>
<p>Let’s consider an example:</p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade&gt;Element with fade transition&lt;/div&gt;
  &lt;div&gt;Static element without transition&lt;/div&gt;
  &lt;div transition:slide&gt;Element with slide transition&lt;/div&gt;
{/if}</pre> <p>In this example, when <code>condition</code> becomes <code>true</code>, the elements with transitions applied will animate as they are inserted into the DOM, while the static element without a transition will simply appear without any animation.</p>
<p>Based on the preceding code snippet, the second <code>&lt;div&gt;</code> element will be inserted and visible on the DOM immediately, as the first and third <code>&lt;div&gt;</code> elements fade and slide in, respectively.</p>
<p>Similarly, when <code>condition</code> turns to <code>false</code>, the elements with <code>out</code><code>:</code> transitions (in this case, only the third <code>&lt;div&gt;</code> element, since the <code>transition:</code> directive implies both <code>in:</code> and <code>out:</code> transition) will play their respective out transitions.</p>
<p>Based on <a id="_idIndexMarker515"/>the preceding code snippet, you will see that both the first and second <code>&lt;div&gt;</code> elements remain unchanged, and the slide transition is played on the third <code>&lt;div&gt;</code> element. All elements within the <code>{#if}</code> block will only be removed from the DOM together after all the <code>out:</code> transitions have finished playing.</p>
<p>In summary, when you have a mix of elements with and without transitions inside the same logical block, all the elements will be added into and removed from the DOM at the same time. Svelte animates only the elements with transitions applied, while the static elements without transitions will be inserted or removed without any animations.</p>
<p>So far, we have only seen examples using the <code>{#if}</code> block as a means of adding or removing elements, but there are other logical blocks in Svelte that can also be used.</p>
<p>Let us look at what they are.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor195"/>Other Svelte logical blocks for transitions</h2>
<p>The <code>{#if}</code> block adds or<a id="_idIndexMarker516"/> removes elements based on the <code>if</code> condition. In addition to the <code>{#if}</code> block, there are other logical blocks in Svelte that provide opportunities for applying transitions when adding or removing elements, such as <code>{#each}</code>, <code>{#await}</code>, and <code>{#key}</code>. These blocks can also have transitions applied to the elements they contain, providing a wide range of possibilities for animating your user interface.</p>
<p>For example, the <code>{#each}</code> block is used to iterate over a list of items and render elements for each item. You can apply transitions to the elements within an <code>{#each}</code> block in a similar way as you would with an <code>{#if}</code> block. Let’s look at an example of that:</p>
<pre class="source-code">
{#each items as item (item.id)}
  &lt;div in:fade out:slide&gt;{item.name}&lt;/div&gt;
{/each}</pre> <p>In this example, as new items are added or removed from the <code>items</code> array, the elements within the <code>{#each}</code> block will have their respective <code>in:</code> and <code>out:</code> transitions played. When there is a new item in the <code>items</code> array, the new <code>&lt;div&gt;</code> element will fade into the end of the list. When an element is removed from the <code>items</code> array, the respective <code>&lt;div&gt;</code> element will slide out of the list. Using transitions in a list allows you to create a dynamic and engaging user experience, providing clear visual cues when items are added to or removed from the list.</p>
<p>Similarly, you <a id="_idIndexMarker517"/>can use transitions with <code>{#await}</code> and <code>{#key}</code> blocks to create visually appealing animations while managing the addition and removal of elements in various scenarios.</p>
<p>The <code>transition:</code>, <code>in:</code>, and <code>out:</code> directives can be applied to any elements, and elements within the same logical block will be added or removed at the same time. This also holds true for nested logical blocks.</p>
<p>For example, let us consider the following code snippet:</p>
<pre class="source-code">
{#if condition}
  &lt;p transition:blur&gt;paragraph 1&lt;/p&gt;
  {#each items as item (item.id)}
    &lt;div transition:fade&gt;{item.name}&lt;/div&gt;
  {/each}
  &lt;p&gt;paragraph 2&lt;/p&gt;
{/if}</pre> <p>When <code>condition</code> changes from <code>false</code> to <code>true</code>, the following happens:</p>
<ul>
<li>The first <code>&lt;p&gt;</code> element with the <code>blur</code> transition will animate as it is inserted into the DOM</li>
<li>Simultaneously, for each item in the <code>items</code> array, the <code>&lt;div&gt;</code> elements with the <code>fade</code> transition will animate as they are inserted into the DOM</li>
<li>The last <code>&lt;p&gt;</code> element, which does not have any transition, will simply appear in the DOM without animation</li>
</ul>
<p>Conversely, when <code>condition</code> changes from <code>true</code> to <code>false</code>, the following happens:</p>
<ul>
<li>The first <code>&lt;p&gt;</code> element with the <code>blur</code> transition will animate</li>
<li>Simultaneously, for each item in the <code>items</code> array, the <code>&lt;div&gt;</code> elements with the <code>fade</code> transition will animate</li>
<li>The last <code>&lt;p&gt;</code> element, which does not have a transition, will remain unchanged</li>
<li>Once all the transitions in the <code>&lt;p&gt;</code> element and all the <code>&lt;div&gt;</code> elements in the <code>{#each}</code> block have finished, both the <code>&lt;p&gt;</code> and <code>&lt;div&gt;</code> elements will be removed from the DOM together</li>
</ul>
<p>By using transitions in combination with nested logical blocks, you can create intricate animations that enhance the user experience.</p>
<p>By default, transitions are only played when the nearest logical block causes an addition or removal of the element. However, we can change this behavior with the <code>global</code> modifier.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor196"/>The global modifier</h2>
<p>Transitions<a id="_idIndexMarker518"/> being played only when the nearest logical block causes an addition or removal of the element helps limit the number of simultaneous animations, making the user experience more focused and less overwhelming. This is called the <em class="italic">local</em> mode; that is, transitions are only applied for local changes.</p>
<p>To change<a id="_idIndexMarker519"/> this <a id="_idIndexMarker520"/>behavior, we can apply the <code>global</code> modifier. The <code>global</code> modifier, when applied to the <code>transition:</code>, <code>in:</code>, and <code>out:</code> directives, ensures that the animation is played whenever the element is added or removed.</p>
<p>To apply the <code>global</code> modifier, simply suffix the directive with <code>|global</code>, like this:</p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade|global&gt;some text here&lt;/div&gt;
{/if}</pre> <p>As per the preceding example, before applying the <code>global</code> modifier, the <code>fade</code> animation was only being played when the nearest logical block, the <code>{#if}</code> block, triggered the insertion or removal of the <code>&lt;div&gt;</code> element. This means that if another parent logical block caused the addition or removal of the element, the animation would not be played. With the <code>global</code> modifier, the transition will be played whenever the <code>&lt;div&gt;</code> element is added or removed, irrespective of which logical block causes it.</p>
<p>To elaborate further, let us look at the following nested <code>{#if}</code> block example:</p>
<pre class="source-code">
{#if condition1}
  &lt;div transition:fade&gt;first div&lt;/div&gt;
  {#if condition2}
    &lt;div transition:fade&gt;second div&lt;/div&gt;
    &lt;div transition:fade|global&gt;third div&lt;/div&gt;
  {/if}
{/if}</pre> <p>Let us<a id="_idIndexMarker521"/> start with <code>condition1</code> as <code>false</code> and <code>condition2</code> as <code>true</code>.</p>
<p>When <code>condition1</code> turns <code>true</code>, the three <code>&lt;div&gt;</code> elements will be inserted into the DOM together. Since <code>condition2</code> has always been <code>true</code>, at this point, the <code>{#if}</code> block that causes all the <code>&lt;div&gt;</code> elements to be inserted is the one with <code>condition1</code>.</p>
<p>The first <code>&lt;div&gt;</code> element will fade in because its nearest logical block, <code>{#if condition1}</code>, is responsible for the insertion of the <code>&lt;</code><code>div&gt;</code> element.</p>
<p>The <a id="_idIndexMarker522"/>second <code>&lt;div&gt;</code> element will be immediately visible on the screen without playing the <code>fade</code> transition. This is because, by default, the transition is in <em class="italic">local</em> mode, and its nearest logical block, <code>{#if condition2}</code>, is not the cause of the <code>&lt;div&gt;</code> element being inserted at this point.</p>
<p>The third <code>&lt;div&gt;</code> element will fade in simultaneously with the first <code>&lt;div&gt;</code> element. Because the <code>&lt;div&gt;</code> element has the <code>|global</code> modifier applied to its transition, it doesn’t matter which logical block is responsible for its insertion. The transition will play regardless of the specific logical block that causes the <code>&lt;div&gt;</code> element to be inserted.</p>
<p>Now what if <code>condition1</code> turns from <code>true</code> to <code>false</code>?</p>
<p>The same logic applies; therefore, the second <code>&lt;div&gt;</code> element will remain unchanged, and only the first and third <code>&lt;div&gt;</code> elements will fade out. Once the fade transition has finished, all three <code>&lt;div&gt;</code> elements will be removed from the DOM.</p>
<p>In the scenarios we have walked through, the second <code>&lt;div&gt;</code> element’s <code>fade</code> transition has not been played yet. So, when will the <code>fade</code> transition of the second <code>&lt;div&gt;</code> element be played?</p>
<p>To understand when the <code>fade</code> transition of the second <code>&lt;div&gt;</code> element will be played, let’s consider the situation where <code>condition1</code> remains <code>true</code> and <code>condition2</code> changes from <code>false</code> to <code>true</code>.</p>
<p>When <code>condition1</code> is <code>true</code> and <code>condition2</code> changes from <code>false</code> to <code>true</code>, the second <code>&lt;div&gt;</code> element will be inserted into the DOM. Since its nearest logical block, <code>{#if condition2}</code>, is now responsible for the insertion, the <code>transition:fade</code> transition will be played.</p>
<p>As you can<a id="_idIndexMarker523"/> see, with the <code>global</code> modifier, we can <a id="_idIndexMarker524"/>change when transitions are played in response to changes. Instead of playing the transition only when they are relevant to specific conditions affecting the elements, we can change it to be played all the time.</p>
<p class="callout-heading">Difference between Svelte 3 and Svelte 4</p>
<p class="callout">As we’ve explained earlier, Svelte transitions are in <em class="italic">local</em> mode by default. However, this is only changed in Svelte 4, where in Svelte 3 it is the other way around. In Svelte 3, transitions are in <em class="italic">global</em> mode by default, and you would need to apply the <code>local</code> modifier to the transition to change it to <em class="italic">local</em> mode.</p>
<p>So far, we have covered how to add a transition to an element, using the <code>transition:</code>, <code>in:</code>, and <code>out:</code> directives. We have learned when and how the transitions are played. Before we end the chapter, let us dive deeper into the inner workings of transitions in Svelte to better understand their mechanics.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>How Svelte transition works under the hood</h1>
<p>Before we delve into <a id="_idIndexMarker525"/>the inner workings of Svelte transitions, let us first briefly discuss the general methods for creating animations on the web. Understanding these fundamental concepts provides a solid foundation for grasping how Svelte transitions work.</p>
<p>In general, you can create animations using either CSS or JavaScript.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor198"/>Creating animations with CSS</h2>
<p>To<a id="_idIndexMarker526"/> create animations using CSS, you can use the CSS <code>animation</code> property<a id="_idIndexMarker527"/> along with the <code>@keyframes</code> rules. The <code>@keyframes</code> rule is used to define a sequence of styles, specifying the CSS styles at each keyframe (from 0% to 100%) during the animation.</p>
<p>See this, for example:</p>
<pre class="source-code">
@keyframes example {
  0% {
    opacity: 1;
    transform: scale(1);
  }
  100% {
    opacity: 0;
    transform: scale(1.75);
  }
}</pre> <p>In the <a id="_idIndexMarker528"/>preceding code snippet, we defined an animation <a id="_idIndexMarker529"/>keyframe named <code>example</code> that changes the opacity from 100% to 0% and the scale from 1 to 1.75 simultaneously.</p>
<p>To apply the <code>example</code> animation to an element, we use the CSS <code>animation</code> property:</p>
<pre class="source-code">
&lt;div style="animation: example 4s 1s 1;"&gt;Animated element&lt;/div&gt;</pre> <p>In the preceding code snippet, we set the animation to the <code>example</code> animation keyframe, with a duration of four seconds, a delay of one second, and only play the animation exactly once.</p>
<p>The <code>@keyframes</code> rule is versatile. We have fine-grained control over the intermediate steps of the animation sequence through <code>@keyframes</code> declarations. Combining it with the <code>animation</code> property, we control how the animation would look, and when and how long it will play.</p>
<p>The advantages of using CSS to create animations are that it does not involve JavaScript, and the browser can optimize for the CSS animation on its own. This saves JavaScript bandwidth, and as a result, the animation can run smoothly even if you have intensive JavaScript tasks running concurrently. This ensures a better performance and user experience, as the animations remain responsive and fluid even under heavy processing loads.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor199"/>Creating animations with JavaScript</h2>
<p>Creating <a id="_idIndexMarker530"/>animation using JavaScript involves manipulating<a id="_idIndexMarker531"/> the DOM elements’ styles and properties dynamically.</p>
<p>As an example, let us write a fade-in animation using JavaScript.</p>
<p>To achieve this, we need to gradually change the element’s opacity from <code>0</code> to <code>1</code>. To set a <code>&lt;div&gt;</code> element’s opacity to <code>0</code> in JavaScript, we set it directly through the element’s <code>style.opacity</code> property:</p>
<pre class="source-code">
div.style.opacity = 0;</pre> <p>In the preceding code snippet, we assumed that we have obtained a reference to the <code>&lt;div&gt;</code> element, which we have stored in the variable named <code>div</code>. We then set the opacity of the <code>&lt;div&gt;</code> element to <code>0</code> through the <code>div</code> variable.</p>
<p>To animate the opacity of an element from one value to another, you would need to update the styles at regular intervals over a specified duration of time.</p>
<p>Instead of setting a fixed interval through <code>setInterval</code>, the interval for updating styles is usually achieved using the <code>requestAnimationFrame</code> method. <code>requestAnimationFrame</code> is a browser method that optimizes the animation performance by calling the specified function before the next repaint occurs. <code>requestAnimationFrame</code> helps ensure that your animations run smoothly and efficiently by allowing the browser to determine the best time to update the styles, avoiding unnecessary work or redundant repaints.</p>
<p>Here is an example of using <code>requestAnimationFrame</code> to create an animation:</p>
<pre class="source-code">
let start;
const duration = 4000; // 4 seconds
function loop(timestamp) {
  if (!start) start = timestamp;
  // get the progress in percentage
  const progress = (timestamp – start) / duration;
  // Update the DOM element's styles based on progress
  if (progress &gt; 1) {
    div.style.opacity = 0;
    div.style.transform = 'scale(1.75)';
  } else {
    div.style.opacity = 1 – progress;
    const scale = 1 + progress * 0.75;
    div.style.transform = `scale(${scale})`;
    // continue animating, schedule the next loop
    requestAnimationFrame(loop);
  }
}
// Start the animation
requestAnimationFrame(loop);</pre> <p>In the <a id="_idIndexMarker532"/>preceding code snippet, we schedule the <code>loop</code> function<a id="_idIndexMarker533"/> in the next animation frame until the progress is finished. We calculate <code>progress</code> as the percentage of time passed over the total duration of the animation. With the value of <code>progress</code>, we calculate the opacity and the scale of the <code>&lt;</code><code>div&gt;</code> element.</p>
<p>In this example, the end result of using JavaScript animation with <code>requestAnimationFrame</code> is the same as the end result achieved with the examples of using CSS animations from the previous section.</p>
<p>The <code>&lt;div&gt;</code> element starts at opacity <code>1</code> and scale <code>1</code> at the beginning of the animation and ends up with opacity <code>0</code> and scale <code>1.75</code> at the end of the animation.</p>
<p>Using JavaScript for animations offers more control over the animation logic, enabling you to create complex and interactive animations that can respond to user input or other events.</p>
<p>However, one <a id="_idIndexMarker534"/>of the downsides of using JavaScript for animations is that it can be more resource-intensive as the animations rely on the browser’s JavaScript engine to process and execute<a id="_idIndexMarker535"/> the animation logic.</p>
<p>Now that we have learned about the two different approaches to creating animations on the web, which one does the Svelte transition use?</p>
<p>The answer is both.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor200"/>Animating transitions in Svelte</h2>
<p>Although<a id="_idIndexMarker536"/> all of Svelte’s built-in transitions use CSS for animating, Svelte is capable of animating transitions using both CSS and JavaScript.</p>
<p>To animate the transition through CSS, Svelte generates a one-time-only <code>@keyframes</code> rule for each element, based on the transition and the specified configuration object.</p>
<p>Let us look at a <code>fly</code> transition as an example:</p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 50, y: 30 }}&gt;Some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, the <code>fly</code> transition is applied to a <code>&lt;div&gt;</code> element. In response to that, Svelte generates a <code>@keyframes</code> rule that looks like this:</p>
<pre class="source-code">
@keyframes fly-in-unique-id {
  0% {
    transform: translate(50px, 30px);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0);
    opacity: 1;
  }
}</pre> <p>This generated <code>@keyframes</code> rule will be applied to the element for the duration of the transition. The <code>unique-id</code> part of the keyframe name ensures that each generated keyframe is unique and doesn’t interfere with other elements.</p>
<p>Based on<a id="_idIndexMarker537"/> the specified <code>duration</code> and <code>delay</code> of the transition, Svelte will calculate the appropriate timing for the animation and apply the generated <code>@keyframes</code> rule to the element, using the CSS <code>animation</code> property. The element will then animate according to the specified <code>transition</code>, <code>duration</code>, and <code>delay</code>.</p>
<p>For example, in the following code snippet, we have a <code>fly</code> transition applied to a <code>&lt;div&gt;</code> element with a specified duration of 500 ms and a delay of 200 ms:</p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 50, y: 30, duration: 500, delay: 200 }}&gt;Some text here&lt;/div&gt;</pre> <p>To animate the <code>fly</code> transition in the preceding code snippet, Svelte will generate the corresponding keyframe animation, and apply the generated keyframe animation to the element with the specified duration and delay:</p>
<pre class="source-code">
div.style.animation = 'fly-in-unique-id 500ms 200ms 1';</pre> <p>It is also possible to animate a transition using JavaScript.</p>
<p>Svelte will schedule a loop through <code>requestAnimationFrame</code> to run the animation throughout the specified duration.</p>
<p>We won’t delve further into the specifics of how the <code>requestAnimationFrame</code> loop works with the animation at this point. In the next chapter, we will explore the creation of custom transitions using JavaScript, which will provide a deeper understanding of how the <code>requestAnimationFrame</code> loop interacts with animations and how to <a id="_idIndexMarker538"/>effectively utilize it for smooth, engaging transitions. Stay tuned to learn more about crafting your own unique animations with Svelte.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor201"/>Summary</h1>
<p>In this chapter, we learned how to add a transition onto an element. We explored the <code>transition:</code>, <code>in:</code>, and <code>out:</code> directives, and how to customize them.</p>
<p>Following that, we looked at when and how the transitions are played. We discussed how the transitions are played when we have a mix of elements with and without transitions, and also how the transitions are played when used inside elements within nested logical blocks.</p>
<p>Last but not least, we dug deeper into how the transition animations are played by Svelte.</p>
<p>With this knowledge, you can now confidently apply transitions into elements when working with Svelte. This will allow you to enhance the interactivity and visual appeal of your applications, thereby providing a more engaging user experience.</p>
<p>In the next chapter, we will look beyond the built-in transitions and will explore the creation of custom transitions.</p>
</div>
</div></body></html>