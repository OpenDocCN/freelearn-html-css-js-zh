<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor187"/>13</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor188"/>Using Transitions</h1>
<p>Transitions are<a id="_idIndexMarker496"/> essential in creating smooth and engaging user experiences. By defining how elements appear, disappear, or change within a user interface, transitions can turn ordinary interactions into captivating experiences that leave lasting impressions <span class="No-Break">on users.</span></p>
<p>Over the next three chapters, we will explore the topic of transitions in Svelte, beginning with a comprehensive understanding of how to use transitions <span class="No-Break">in Svelte.</span></p>
<p>In this chapter, we will start by learning how to add transitions to elements in Svelte. We will explore the different transition directives and learn how to customize <span class="No-Break">the transitions.</span></p>
<p>After that, we will discuss when and how the transitions are being played. We will look at different scenarios, such as where there’s a mix of elements with and without transitions, or when the elements are within nested <span class="No-Break">logical blocks.</span></p>
<p>To truly master transitions, it’s important to understand the inner workings of the Svelte transition system. We will conclude the chapter by examining the underlying mechanics and offering insights that will help you optimize your use of transitions in <span class="No-Break">your projects.</span></p>
<p>By the end of this chapter, you will have a solid foundation in Svelte transitions, allowing you to create engaging and dynamic user interfaces <span class="No-Break">with ease.</span></p>
<p>This chapter includes sections on <span class="No-Break">the following:</span></p>
<ul>
<li>How to add transitions <span class="No-Break">to elements</span></li>
<li>When the transitions for the elements <span class="No-Break">are played</span></li>
<li>How transitions work under <span class="No-Break">the hood</span></li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor189"/>Technical requirements</h1>
<p>You can find the code used in this chapter on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Adding transitions to elements</h1>
<p>Svelte <a id="_idIndexMarker497"/>provides a simple and powerful way to add transitions to your application elements. The framework offers built-in transition functions that can be easily applied to elements, allowing for smooth animations and seamless user experiences. You can also define your own custom transitions, which we will learn about in the <span class="No-Break">next chapter.</span></p>
<p>Transitions in Svelte are applied to elements when the elements are mounted or unmounted from the DOM. This ensures that elements appear and disappear gracefully, rather than just abruptly popping in and out <span class="No-Break">of view.</span></p>
<p>To add a transition to an element in Svelte, you can use the <strong class="source-inline">transition:</strong> directive with the desired transition function. Here’s an example of adding a transition to <span class="No-Break">an element:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fade&gt;some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, we imported <strong class="source-inline">fade</strong> from <strong class="source-inline">svelte/transition</strong> and applied it to the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>What you will see with the preceding code is that when the <strong class="source-inline">&lt;div&gt;</strong> element is mounted onto the DOM, the <strong class="source-inline">&lt;div&gt;</strong> element will smoothly fade in. When the <strong class="source-inline">&lt;div&gt;</strong> element is unmounted from the DOM, the <strong class="source-inline">&lt;div&gt;</strong> element will smoothly <span class="No-Break">fade out.</span></p>
<p>The <strong class="source-inline">transition:</strong> directive sets the transitions played when the element is both mounted onto the DOM and unmounted from the DOM. If you want to have finer control over which transitions are played as the element is mounted or unmounted, you can use the <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> <span class="No-Break">directives instead:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fade, blur } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fade out:blur&gt;some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, we applied <strong class="source-inline">fade</strong> as the in transition and <strong class="source-inline">blur</strong> as the out transition. When the <strong class="source-inline">&lt;div&gt;</strong> element is mounted onto the DOM, the <strong class="source-inline">&lt;div&gt;</strong> element will <a id="_idIndexMarker498"/>smoothly fade in. When the <strong class="source-inline">&lt;div&gt;</strong> element is unmounted from the DOM, the <strong class="source-inline">&lt;div&gt;</strong> element will smoothly <span class="No-Break">blur out.</span></p>
<p>Thus, the <strong class="source-inline">transition:</strong> directive is essentially a shorthand for both <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> transitions. In other words, the transitions applied to the two elements in the following snippet are <span class="No-Break">functionally identical:</span></p>
<pre class="source-code">
&lt;div transition:blur&gt;some text here&lt;/div&gt;</pre> <p>So, the preceding code snippet is similar to the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;div in:blur out:blur&gt;some text here&lt;/div&gt;</pre> <p>From the preceding examples, we have seen two of Svelte’s built-in transitions, <strong class="source-inline">fade</strong> and <strong class="source-inline">blur</strong> – let us look at more <span class="No-Break">of them!</span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>Svelte’s built-in transitions</h2>
<p>Svelte’s <a id="_idIndexMarker499"/>built-in transitions are exported from the <span class="No-Break"><strong class="source-inline">svelte/transition</strong></span><span class="No-Break"> module.</span></p>
<p>The following list provides an overview of Svelte’s <span class="No-Break">built-in transitions:</span></p>
<ul>
<li><strong class="source-inline">fade</strong>: This<a id="_idIndexMarker500"/> transition smoothly fades an element in or out, adjusting its opacity <span class="No-Break">over time</span></li>
<li><strong class="source-inline">blur</strong>: The <strong class="source-inline">blur</strong> transition <a id="_idIndexMarker501"/>gradually applies or removes a blur effect on <span class="No-Break">an element</span></li>
<li><strong class="source-inline">slide</strong>: The <strong class="source-inline">slide</strong> transition<a id="_idIndexMarker502"/> makes an element slide smoothly in or out <span class="No-Break">of view</span></li>
<li><strong class="source-inline">fly</strong>: The <strong class="source-inline">fly</strong> transition <a id="_idIndexMarker503"/>makes an element smoothly translate from a specified <strong class="source-inline">x</strong> and <span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break"> offset</span></li>
<li><strong class="source-inline">scale</strong>: This<a id="_idIndexMarker504"/> transition causes an element to grow or shrink in size while appearing <span class="No-Break">or disappearing</span></li>
<li><strong class="source-inline">draw</strong>: The<a id="_idIndexMarker505"/> <strong class="source-inline">draw</strong> transition creates a drawing or erasing effect on <span class="No-Break">SVG paths</span></li>
</ul>
<p>As you go through the list of built-in transitions, you may notice that some of these transitions rely on user-specified values. For example, the <strong class="source-inline">fly</strong> transition depends on the specified <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> offset from which the element should fly when <span class="No-Break">transitioning in.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor192"/>Customizing a transition</h2>
<p>To make<a id="_idIndexMarker506"/> use of these transitions with their required values, you can pass a configuration object containing the necessary properties to the <span class="No-Break">transition directive:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fly={{ x: 200, y: 100 }}&gt;Content goes here&lt;/div&gt;</pre> <p>In the preceding code snippet, we apply the <strong class="source-inline">fly</strong> transition with the specified <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> offsets, indicating that the element will fly in from 200 pixels to the right and 100 pixels down. By providing the appropriate values, you can achieve a wide range of customized transition effects in your <span class="No-Break">Svelte components.</span></p>
<p>This approach can be particularly useful when you want an element to fly to a different location as it transitions out, compared to the location from which it flies in during <span class="No-Break">the transition.</span></p>
<p>Instead of using the <strong class="source-inline">transition:</strong> directive and having only one configuration for both in and out transitions, you can separate it into the <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> directives and pass different configuration objects to <span class="No-Break">each directive.</span></p>
<p>An example of this can be seen in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 200, y: 100 }} out:fly={{ x: -200, y: 50 }}&gt;Content goes here&lt;/div&gt;</pre> <p>The <strong class="source-inline">&lt;div&gt;</strong> element flies in from 200 pixels to the right and 100 pixels down, while it flies out 200 pixels to the left and 50 pixels down. By separating the <strong class="source-inline">transition:</strong> directive into <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> directives, you can control the in and out transition with different configuration objects, having more intricate transition effects in your <span class="No-Break">Svelte components.</span></p>
<p>In addition <a id="_idIndexMarker507"/>to custom configurations specific to each transition, all of Svelte’s built-in transitions accept <strong class="source-inline">delay</strong>, <strong class="source-inline">duration</strong>, and <strong class="source-inline">easing</strong> as part of the transition configuration. These parameters allow you to control the timing of your animations, providing greater flexibility in designing your <span class="No-Break">user interface.</span></p>
<p>The <strong class="source-inline">delay</strong> parameter determines the waiting time before the transition begins while the <strong class="source-inline">duration</strong> parameter specifies how long the transition lasts. By modifying these values, you can coordinate when a transition begins and how long each transition takes, creating more complex and <span class="No-Break">engaging animations.</span></p>
<p>Here is an example of adjusting the <strong class="source-inline">delay</strong> and <strong class="source-inline">duration</strong> values of a <span class="No-Break"><strong class="source-inline">fade</strong></span><span class="No-Break"> transition:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
&lt;/script&gt;
&lt;div transition:fade=<strong class="bold">{{ delay: 500, duration: 1000 }}</strong>&gt;Content goes here&lt;/div&gt;</pre> <p>In the preceding code snippet, the <strong class="source-inline">fade</strong> transition will start with a 500 ms delay after it is mounted onto the DOM, and the transition will last for <span class="No-Break">1000 ms.</span></p>
<p>On the other hand, <strong class="source-inline">easing</strong> is a function that is responsible for controlling the pacing of the animation. By adjusting the <strong class="source-inline">easing</strong> function, you can create animations that start slow and end fast, start fast and end slow, or follow a custom pattern, giving you even more control over the look and feel of <span class="No-Break">your animations.</span></p>
<p>Svelte comes with a collection of built-in <strong class="source-inline">easing</strong> functions, which can be imported from <strong class="source-inline">svelte/easing</strong>. These <strong class="source-inline">easing</strong> functions can then be applied to transitions, as seen in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fade } from 'svelte/transition';
  import { quadInOut } from 'svelte/easing';
&lt;/script&gt;
&lt;div transition:fade=<strong class="bold">{{ easing: quadInOut }}</strong>&gt;Content goes here&lt;/div&gt;</pre> <p>In the <a id="_idIndexMarker508"/>preceding code snippet, the <strong class="source-inline">fade</strong> transition uses the <strong class="source-inline">quadInOut</strong> <strong class="source-inline">easing</strong> function, which causes the animation to start slowly, accelerate, and then end slowly. By incorporating different <strong class="source-inline">easing</strong> functions into your transitions, you can create a variety of animations for <span class="No-Break">your application.</span></p>
<h3>Exercise – discovering Svelte’s built-in transitions</h3>
<p>As a <a id="_idIndexMarker509"/>practice exercise, try to visit the official <a id="_idIndexMarker510"/>Svelte documentation and identify the list of configurable properties for each <span class="No-Break">built-in transition.</span></p>
<p>To get you started, here is a list of Svelte’s <span class="No-Break">built-in transitions:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">fade</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">blur</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">fly</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">slide</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">scale</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">draw</strong></span></li>
</ul>
<p>We know that transitions are played when elements are mounted or unmounted from the DOM, but when and how exactly are the <span class="No-Break">transitions played?</span></p>
<p>Let us explore the timing and manner in which the transitions are played in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>When are the transitions played?</h1>
<p>The<a id="_idIndexMarker511"/> transitions in Svelte are played when elements are added or removed from <span class="No-Break">the DOM.</span></p>
<p><strong class="source-inline">in:</strong> transitions are executed when an element is added to the DOM. This usually occurs when a component is initialized or when a condition that controls the element’s rendering <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
<p>For <a id="_idIndexMarker512"/>example, in an <strong class="source-inline">{#if}</strong> block, when the <strong class="source-inline">if</strong> condition turns from falsy to truthy, the elements inside the <strong class="source-inline">{#if}</strong> block are added to the DOM. All the <strong class="source-inline">in:</strong> transitions applied to these elements will be <strong class="bold">played simultaneously</strong> as soon as the elements are inserted into <span class="No-Break">the DOM:</span></p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade&gt;some content&lt;/div&gt;
  &lt;div transition:blur&gt;more content&lt;/div&gt;
{/if}</pre> <p>In the preceding code snippet, as <strong class="source-inline">condition</strong> turns to <strong class="source-inline">true</strong>, both <strong class="source-inline">&lt;div&gt;</strong> elements will be inserted into the DOM. As soon as both <strong class="source-inline">&lt;div&gt;</strong> elements are inserted, both the <strong class="source-inline">fade</strong> and <strong class="source-inline">blur</strong> transitions will start playing simultaneously. Whether both the <strong class="source-inline">fade</strong> and <strong class="source-inline">blur</strong> transitions end at the same time depends on the specified duration for <span class="No-Break">each transition.</span></p>
<p>Conversely, <strong class="source-inline">out:</strong> transitions are executed when an element is removed from the DOM. This can happen when a component is destroyed, or when a condition that controls the element’s rendering <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>The transition begins as soon as the element is scheduled for removal from the DOM. After the transition is complete, the element is removed from <span class="No-Break">the DOM.</span></p>
<p>Let us illustrate this with <span class="No-Break">an example:</span></p>
<pre class="source-code">
{#if condition}
  &lt;div out:fade&gt;some content&lt;/div&gt;
  &lt;div transition:blur&gt;more content&lt;/div&gt;
{/if}</pre> <p>In the preceding code snippet, when <strong class="source-inline">condition</strong> turns to <strong class="source-inline">false</strong>, both the <strong class="source-inline">&lt;div&gt;</strong> elements remain in the DOM, even though the condition is no longer true. This is because the <strong class="source-inline">out:</strong> transition needs to be played on both <strong class="source-inline">&lt;div&gt;</strong> elements before they are removed from the DOM. If the <strong class="source-inline">&lt;div&gt;</strong> elements were removed from the DOM immediately, they would no longer be visible to users, rendering any subsequent <strong class="source-inline">out:</strong> transitions ineffective <span class="No-Break">and invisible.</span></p>
<p>Both <strong class="source-inline">fade</strong> and <strong class="source-inline">blur</strong> transitions will play simultaneously on both the <strong class="source-inline">&lt;div&gt;</strong> elements as <strong class="source-inline">out:</strong> transitions. Similar to the <strong class="source-inline">in:</strong> transition, the duration of each transition depends on the specified duration for <span class="No-Break">each transition.</span></p>
<p>Once all <a id="_idIndexMarker513"/>the <strong class="source-inline">out:</strong> transitions have finished playing, both <strong class="source-inline">&lt;div&gt;</strong> elements will be removed from the DOM together, making the DOM state consistent with the updated value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">condition</strong></span><span class="No-Break">.</span></p>
<p>In the previous examples explaining when <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> transitions are played, all elements within the <strong class="source-inline">{#if}</strong> block had transitions applied to them, resulting in the transitions being played simultaneously in all the elements in the <strong class="source-inline">{#if}</strong> block. But, what happens if not all elements inside the <strong class="source-inline">{#if}</strong> block have transitions applied? Let’s discuss <span class="No-Break">that next.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor194"/>Handling mixed transition and static elements</h2>
<p>When <a id="_idIndexMarker514"/>some elements inside an <strong class="source-inline">{#if}</strong> block have transitions applied and others do not, Svelte handles each element differently based on the <span class="No-Break">specified transitions.</span></p>
<p>Let’s consider <span class="No-Break">an example:</span></p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade&gt;Element with fade transition&lt;/div&gt;
  &lt;div&gt;Static element without transition&lt;/div&gt;
  &lt;div transition:slide&gt;Element with slide transition&lt;/div&gt;
{/if}</pre> <p>In this example, when <strong class="source-inline">condition</strong> becomes <strong class="source-inline">true</strong>, the elements with transitions applied will animate as they are inserted into the DOM, while the static element without a transition will simply appear without <span class="No-Break">any animation.</span></p>
<p>Based on the preceding code snippet, the second <strong class="source-inline">&lt;div&gt;</strong> element will be inserted and visible on the DOM immediately, as the first and third <strong class="source-inline">&lt;div&gt;</strong> elements fade and slide <span class="No-Break">in, respectively.</span></p>
<p>Similarly, when <strong class="source-inline">condition</strong> turns to <strong class="source-inline">false</strong>, the elements with <strong class="source-inline">out</strong><strong class="source-inline">:</strong> transitions (in this case, only the third <strong class="source-inline">&lt;div&gt;</strong> element, since the <strong class="source-inline">transition:</strong> directive implies both <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> transition) will play their respective <span class="No-Break">out transitions.</span></p>
<p>Based on <a id="_idIndexMarker515"/>the preceding code snippet, you will see that both the first and second <strong class="source-inline">&lt;div&gt;</strong> elements remain unchanged, and the slide transition is played on the third <strong class="source-inline">&lt;div&gt;</strong> element. All elements within the <strong class="source-inline">{#if}</strong> block will only be removed from the DOM together after all the <strong class="source-inline">out:</strong> transitions have <span class="No-Break">finished playing.</span></p>
<p>In summary, when you have a mix of elements with and without transitions inside the same logical block, all the elements will be added into and removed from the DOM at the same time. Svelte animates only the elements with transitions applied, while the static elements without transitions will be inserted or removed without <span class="No-Break">any animations.</span></p>
<p>So far, we have only seen examples using the <strong class="source-inline">{#if}</strong> block as a means of adding or removing elements, but there are other logical blocks in Svelte that can also <span class="No-Break">be used.</span></p>
<p>Let us look at what <span class="No-Break">they are.</span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor195"/>Other Svelte logical blocks for transitions</h2>
<p>The <strong class="source-inline">{#if}</strong> block adds or<a id="_idIndexMarker516"/> removes elements based on the <strong class="source-inline">if</strong> condition. In addition to the <strong class="source-inline">{#if}</strong> block, there are other logical blocks in Svelte that provide opportunities for applying transitions when adding or removing elements, such as <strong class="source-inline">{#each}</strong>, <strong class="source-inline">{#await}</strong>, and <strong class="source-inline">{#key}</strong>. These blocks can also have transitions applied to the elements they contain, providing a wide range of possibilities for animating your <span class="No-Break">user interface.</span></p>
<p>For example, the <strong class="source-inline">{#each}</strong> block is used to iterate over a list of items and render elements for each item. You can apply transitions to the elements within an <strong class="source-inline">{#each}</strong> block in a similar way as you would with an <strong class="source-inline">{#if}</strong> block. Let’s look at an example <span class="No-Break">of that:</span></p>
<pre class="source-code">
{#each items as item (item.id)}
  &lt;div in:fade out:slide&gt;{item.name}&lt;/div&gt;
{/each}</pre> <p>In this example, as new items are added or removed from the <strong class="source-inline">items</strong> array, the elements within the <strong class="source-inline">{#each}</strong> block will have their respective <strong class="source-inline">in:</strong> and <strong class="source-inline">out:</strong> transitions played. When there is a new item in the <strong class="source-inline">items</strong> array, the new <strong class="source-inline">&lt;div&gt;</strong> element will fade into the end of the list. When an element is removed from the <strong class="source-inline">items</strong> array, the respective <strong class="source-inline">&lt;div&gt;</strong> element will slide out of the list. Using transitions in a list allows you to create a dynamic and engaging user experience, providing clear visual cues when items are added to or removed from <span class="No-Break">the list.</span></p>
<p>Similarly, you <a id="_idIndexMarker517"/>can use transitions with <strong class="source-inline">{#await}</strong> and <strong class="source-inline">{#key}</strong> blocks to create visually appealing animations while managing the addition and removal of elements in <span class="No-Break">various scenarios.</span></p>
<p>The <strong class="source-inline">transition:</strong>, <strong class="source-inline">in:</strong>, and <strong class="source-inline">out:</strong> directives can be applied to any elements, and elements within the same logical block will be added or removed at the same time. This also holds true for nested <span class="No-Break">logical blocks.</span></p>
<p>For example, let us consider the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
{#if condition}
  &lt;p transition:blur&gt;paragraph 1&lt;/p&gt;
  {#each items as item (item.id)}
    &lt;div transition:fade&gt;{item.name}&lt;/div&gt;
  {/each}
  &lt;p&gt;paragraph 2&lt;/p&gt;
{/if}</pre> <p>When <strong class="source-inline">condition</strong> changes from <strong class="source-inline">false</strong> to <strong class="source-inline">true</strong>, the <span class="No-Break">following happens:</span></p>
<ul>
<li>The first <strong class="source-inline">&lt;p&gt;</strong> element with the <strong class="source-inline">blur</strong> transition will animate as it is inserted into <span class="No-Break">the DOM</span></li>
<li>Simultaneously, for each item in the <strong class="source-inline">items</strong> array, the <strong class="source-inline">&lt;div&gt;</strong> elements with the <strong class="source-inline">fade</strong> transition will animate as they are inserted into <span class="No-Break">the DOM</span></li>
<li>The last <strong class="source-inline">&lt;p&gt;</strong> element, which does not have any transition, will simply appear in the DOM <span class="No-Break">without animation</span></li>
</ul>
<p>Conversely, when <strong class="source-inline">condition</strong> changes from <strong class="source-inline">true</strong> to <strong class="source-inline">false</strong>, the <span class="No-Break">following happens:</span></p>
<ul>
<li>The first <strong class="source-inline">&lt;p&gt;</strong> element with the <strong class="source-inline">blur</strong> transition <span class="No-Break">will animate</span></li>
<li>Simultaneously, for each item in the <strong class="source-inline">items</strong> array, the <strong class="source-inline">&lt;div&gt;</strong> elements with the <strong class="source-inline">fade</strong> transition <span class="No-Break">will animate</span></li>
<li>The last <strong class="source-inline">&lt;p&gt;</strong> element, which does not have a transition, will <span class="No-Break">remain unchanged</span></li>
<li>Once all the transitions in the <strong class="source-inline">&lt;p&gt;</strong> element and all the <strong class="source-inline">&lt;div&gt;</strong> elements in the <strong class="source-inline">{#each}</strong> block have finished, both the <strong class="source-inline">&lt;p&gt;</strong> and <strong class="source-inline">&lt;div&gt;</strong> elements will be removed from the <span class="No-Break">DOM together</span></li>
</ul>
<p>By using transitions in combination with nested logical blocks, you can create intricate animations that enhance the <span class="No-Break">user experience.</span></p>
<p>By default, transitions are only played when the nearest logical block causes an addition or removal of the element. However, we can change this behavior with the <span class="No-Break"><strong class="source-inline">global</strong></span><span class="No-Break"> modifier.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor196"/>The global modifier</h2>
<p>Transitions<a id="_idIndexMarker518"/> being played only when the nearest logical block causes an addition or removal of the element helps limit the number of simultaneous animations, making the user experience more focused and less overwhelming. This is called the <em class="italic">local</em> mode; that is, transitions are only applied for <span class="No-Break">local changes.</span></p>
<p>To change<a id="_idIndexMarker519"/> this <a id="_idIndexMarker520"/>behavior, we can apply the <strong class="source-inline">global</strong> modifier. The <strong class="source-inline">global</strong> modifier, when applied to the <strong class="source-inline">transition:</strong>, <strong class="source-inline">in:</strong>, and <strong class="source-inline">out:</strong> directives, ensures that the animation is played whenever the element is added <span class="No-Break">or removed.</span></p>
<p>To apply the <strong class="source-inline">global</strong> modifier, simply suffix the directive with <strong class="source-inline">|global</strong>, <span class="No-Break">like this:</span></p>
<pre class="source-code">
{#if condition}
  &lt;div in:fade|global&gt;some text here&lt;/div&gt;
{/if}</pre> <p>As per the preceding example, before applying the <strong class="source-inline">global</strong> modifier, the <strong class="source-inline">fade</strong> animation was only being played when the nearest logical block, the <strong class="source-inline">{#if}</strong> block, triggered the insertion or removal of the <strong class="source-inline">&lt;div&gt;</strong> element. This means that if another parent logical block caused the addition or removal of the element, the animation would not be played. With the <strong class="source-inline">global</strong> modifier, the transition will be played whenever the <strong class="source-inline">&lt;div&gt;</strong> element is added or removed, irrespective of which logical block <span class="No-Break">causes it.</span></p>
<p>To elaborate further, let us look at the following nested <strong class="source-inline">{#if}</strong> <span class="No-Break">block example:</span></p>
<pre class="source-code">
{#if condition1}
  &lt;div transition:fade&gt;first div&lt;/div&gt;
  {#if condition2}
    &lt;div transition:fade&gt;second div&lt;/div&gt;
    &lt;div transition:fade|global&gt;third div&lt;/div&gt;
  {/if}
{/if}</pre> <p>Let us<a id="_idIndexMarker521"/> start with <strong class="source-inline">condition1</strong> as <strong class="source-inline">false</strong> and <strong class="source-inline">condition2</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
<p>When <strong class="source-inline">condition1</strong> turns <strong class="source-inline">true</strong>, the three <strong class="source-inline">&lt;div&gt;</strong> elements will be inserted into the DOM together. Since <strong class="source-inline">condition2</strong> has always been <strong class="source-inline">true</strong>, at this point, the <strong class="source-inline">{#if}</strong> block that causes all the <strong class="source-inline">&lt;div&gt;</strong> elements to be inserted is the one <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">condition1</strong></span><span class="No-Break">.</span></p>
<p>The first <strong class="source-inline">&lt;div&gt;</strong> element will fade in because its nearest logical block, <strong class="source-inline">{#if condition1}</strong>, is responsible for the insertion of the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>The <a id="_idIndexMarker522"/>second <strong class="source-inline">&lt;div&gt;</strong> element will be immediately visible on the screen without playing the <strong class="source-inline">fade</strong> transition. This is because, by default, the transition is in <em class="italic">local</em> mode, and its nearest logical block, <strong class="source-inline">{#if condition2}</strong>, is not the cause of the <strong class="source-inline">&lt;div&gt;</strong> element being inserted at <span class="No-Break">this point.</span></p>
<p>The third <strong class="source-inline">&lt;div&gt;</strong> element will fade in simultaneously with the first <strong class="source-inline">&lt;div&gt;</strong> element. Because the <strong class="source-inline">&lt;div&gt;</strong> element has the <strong class="source-inline">|global</strong> modifier applied to its transition, it doesn’t matter which logical block is responsible for its insertion. The transition will play regardless of the specific logical block that causes the <strong class="source-inline">&lt;div&gt;</strong> element to <span class="No-Break">be inserted.</span></p>
<p>Now what if <strong class="source-inline">condition1</strong> turns from <strong class="source-inline">true</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">?</span></p>
<p>The same logic applies; therefore, the second <strong class="source-inline">&lt;div&gt;</strong> element will remain unchanged, and only the first and third <strong class="source-inline">&lt;div&gt;</strong> elements will fade out. Once the fade transition has finished, all three <strong class="source-inline">&lt;div&gt;</strong> elements will be removed from <span class="No-Break">the DOM.</span></p>
<p>In the scenarios we have walked through, the second <strong class="source-inline">&lt;div&gt;</strong> element’s <strong class="source-inline">fade</strong> transition has not been played yet. So, when will the <strong class="source-inline">fade</strong> transition of the second <strong class="source-inline">&lt;div&gt;</strong> element <span class="No-Break">be played?</span></p>
<p>To understand when the <strong class="source-inline">fade</strong> transition of the second <strong class="source-inline">&lt;div&gt;</strong> element will be played, let’s consider the situation where <strong class="source-inline">condition1</strong> remains <strong class="source-inline">true</strong> and <strong class="source-inline">condition2</strong> changes from <strong class="source-inline">false</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
<p>When <strong class="source-inline">condition1</strong> is <strong class="source-inline">true</strong> and <strong class="source-inline">condition2</strong> changes from <strong class="source-inline">false</strong> to <strong class="source-inline">true</strong>, the second <strong class="source-inline">&lt;div&gt;</strong> element will be inserted into the DOM. Since its nearest logical block, <strong class="source-inline">{#if condition2}</strong>, is now responsible for the insertion, the <strong class="source-inline">transition:fade</strong> transition will <span class="No-Break">be played.</span></p>
<p>As you can<a id="_idIndexMarker523"/> see, with the <strong class="source-inline">global</strong> modifier, we can <a id="_idIndexMarker524"/>change when transitions are played in response to changes. Instead of playing the transition only when they are relevant to specific conditions affecting the elements, we can change it to be played all <span class="No-Break">the time.</span></p>
<p class="callout-heading">Difference between Svelte 3 and Svelte 4</p>
<p class="callout">As we’ve explained earlier, Svelte transitions are in <em class="italic">local</em> mode by default. However, this is only changed in Svelte 4, where in Svelte 3 it is the other way around. In Svelte 3, transitions are in <em class="italic">global</em> mode by default, and you would need to apply the <strong class="source-inline">local</strong> modifier to the transition to change it to <span class="No-Break"><em class="italic">local</em></span><span class="No-Break"> mode.</span></p>
<p>So far, we have covered how to add a transition to an element, using the <strong class="source-inline">transition:</strong>, <strong class="source-inline">in:</strong>, and <strong class="source-inline">out:</strong> directives. We have learned when and how the transitions are played. Before we end the chapter, let us dive deeper into the inner workings of transitions in Svelte to better understand <span class="No-Break">their mechanics.</span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>How Svelte transition works under the hood</h1>
<p>Before we delve into <a id="_idIndexMarker525"/>the inner workings of Svelte transitions, let us first briefly discuss the general methods for creating animations on the web. Understanding these fundamental concepts provides a solid foundation for grasping how Svelte <span class="No-Break">transitions work.</span></p>
<p>In general, you can create animations using either CSS <span class="No-Break">or JavaScript.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor198"/>Creating animations with CSS</h2>
<p>To<a id="_idIndexMarker526"/> create animations using CSS, you can use the CSS <strong class="source-inline">animation</strong> property<a id="_idIndexMarker527"/> along with the <strong class="source-inline">@keyframes</strong> rules. The <strong class="source-inline">@keyframes</strong> rule is used to define a sequence of styles, specifying the CSS styles at each keyframe (from 0% to 100%) during <span class="No-Break">the animation.</span></p>
<p>See this, <span class="No-Break">for example:</span></p>
<pre class="source-code">
@keyframes example {
  0% {
    opacity: 1;
    transform: scale(1);
  }
  100% {
    opacity: 0;
    transform: scale(1.75);
  }
}</pre> <p>In the <a id="_idIndexMarker528"/>preceding code snippet, we defined an animation <a id="_idIndexMarker529"/>keyframe named <strong class="source-inline">example</strong> that changes the opacity from 100% to 0% and the scale from 1 to <span class="No-Break">1.75 simultaneously.</span></p>
<p>To apply the <strong class="source-inline">example</strong> animation to an element, we use the CSS <span class="No-Break"><strong class="source-inline">animation</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
&lt;div style="animation: example 4s 1s 1;"&gt;Animated element&lt;/div&gt;</pre> <p>In the preceding code snippet, we set the animation to the <strong class="source-inline">example</strong> animation keyframe, with a duration of four seconds, a delay of one second, and only play the animation <span class="No-Break">exactly once.</span></p>
<p>The <strong class="source-inline">@keyframes</strong> rule is versatile. We have fine-grained control over the intermediate steps of the animation sequence through <strong class="source-inline">@keyframes</strong> declarations. Combining it with the <strong class="source-inline">animation</strong> property, we control how the animation would look, and when and how long it <span class="No-Break">will play.</span></p>
<p>The advantages of using CSS to create animations are that it does not involve JavaScript, and the browser can optimize for the CSS animation on its own. This saves JavaScript bandwidth, and as a result, the animation can run smoothly even if you have intensive JavaScript tasks running concurrently. This ensures a better performance and user experience, as the animations remain responsive and fluid even under heavy <span class="No-Break">processing loads.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor199"/>Creating animations with JavaScript</h2>
<p>Creating <a id="_idIndexMarker530"/>animation using JavaScript involves manipulating<a id="_idIndexMarker531"/> the DOM elements’ styles and <span class="No-Break">properties dynamically.</span></p>
<p>As an example, let us write a fade-in animation <span class="No-Break">using JavaScript.</span></p>
<p>To achieve this, we need to gradually change the element’s opacity from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. To set a <strong class="source-inline">&lt;div&gt;</strong> element’s opacity to <strong class="source-inline">0</strong> in JavaScript, we set it directly through the element’s <span class="No-Break"><strong class="source-inline">style.opacity</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
div.style.opacity = 0;</pre> <p>In the preceding code snippet, we assumed that we have obtained a reference to the <strong class="source-inline">&lt;div&gt;</strong> element, which we have stored in the variable named <strong class="source-inline">div</strong>. We then set the opacity of the <strong class="source-inline">&lt;div&gt;</strong> element to <strong class="source-inline">0</strong> through the <span class="No-Break"><strong class="source-inline">div</strong></span><span class="No-Break"> variable.</span></p>
<p>To animate the opacity of an element from one value to another, you would need to update the styles at regular intervals over a specified duration <span class="No-Break">of time.</span></p>
<p>Instead of setting a fixed interval through <strong class="source-inline">setInterval</strong>, the interval for updating styles is usually achieved using the <strong class="source-inline">requestAnimationFrame</strong> method. <strong class="source-inline">requestAnimationFrame</strong> is a browser method that optimizes the animation performance by calling the specified function before the next repaint occurs. <strong class="source-inline">requestAnimationFrame</strong> helps ensure that your animations run smoothly and efficiently by allowing the browser to determine the best time to update the styles, avoiding unnecessary work or <span class="No-Break">redundant repaints.</span></p>
<p>Here is an example of using <strong class="source-inline">requestAnimationFrame</strong> to create <span class="No-Break">an animation:</span></p>
<pre class="source-code">
let start;
const duration = 4000; // 4 seconds
function loop(timestamp) {
  if (!start) start = timestamp;
  // get the progress in percentage
  const progress = (timestamp – start) / duration;
  // Update the DOM element's styles based on progress
  if (progress &gt; 1) {
    div.style.opacity = 0;
    div.style.transform = 'scale(1.75)';
  } else {
    div.style.opacity = 1 – progress;
    const scale = 1 + progress * 0.75;
    div.style.transform = `scale(${scale})`;
    // continue animating, schedule the next loop
    requestAnimationFrame(loop);
  }
}
// Start the animation
requestAnimationFrame(loop);</pre> <p>In the <a id="_idIndexMarker532"/>preceding code snippet, we schedule the <strong class="source-inline">loop</strong> function<a id="_idIndexMarker533"/> in the next animation frame until the progress is finished. We calculate <strong class="source-inline">progress</strong> as the percentage of time passed over the total duration of the animation. With the value of <strong class="source-inline">progress</strong>, we calculate the opacity and the scale of the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>In this example, the end result of using JavaScript animation with <strong class="source-inline">requestAnimationFrame</strong> is the same as the end result achieved with the examples of using CSS animations from the <span class="No-Break">previous section.</span></p>
<p>The <strong class="source-inline">&lt;div&gt;</strong> element starts at opacity <strong class="source-inline">1</strong> and scale <strong class="source-inline">1</strong> at the beginning of the animation and ends up with opacity <strong class="source-inline">0</strong> and scale <strong class="source-inline">1.75</strong> at the end of <span class="No-Break">the animation.</span></p>
<p>Using JavaScript for animations offers more control over the animation logic, enabling you to create complex and interactive animations that can respond to user input or <span class="No-Break">other events.</span></p>
<p>However, one <a id="_idIndexMarker534"/>of the downsides of using JavaScript for animations is that it can be more resource-intensive as the animations rely on the browser’s JavaScript engine to process and execute<a id="_idIndexMarker535"/> the <span class="No-Break">animation logic.</span></p>
<p>Now that we have learned about the two different approaches to creating animations on the web, which one does the Svelte <span class="No-Break">transition use?</span></p>
<p>The answer <span class="No-Break">is both.</span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor200"/>Animating transitions in Svelte</h2>
<p>Although<a id="_idIndexMarker536"/> all of Svelte’s built-in transitions use CSS for animating, Svelte is capable of animating transitions using both CSS <span class="No-Break">and JavaScript.</span></p>
<p>To animate the transition through CSS, Svelte generates a one-time-only <strong class="source-inline">@keyframes</strong> rule for each element, based on the transition and the specified <span class="No-Break">configuration object.</span></p>
<p>Let us look at a <strong class="source-inline">fly</strong> transition as <span class="No-Break">an example:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 50, y: 30 }}&gt;Some text here&lt;/div&gt;</pre> <p>In the preceding code snippet, the <strong class="source-inline">fly</strong> transition is applied to a <strong class="source-inline">&lt;div&gt;</strong> element. In response to that, Svelte generates a <strong class="source-inline">@keyframes</strong> rule that looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
@keyframes fly-in-unique-id {
  0% {
    transform: translate(50px, 30px);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0);
    opacity: 1;
  }
}</pre> <p>This generated <strong class="source-inline">@keyframes</strong> rule will be applied to the element for the duration of the transition. The <strong class="source-inline">unique-id</strong> part of the keyframe name ensures that each generated keyframe is unique and doesn’t interfere with <span class="No-Break">other elements.</span></p>
<p>Based on<a id="_idIndexMarker537"/> the specified <strong class="source-inline">duration</strong> and <strong class="source-inline">delay</strong> of the transition, Svelte will calculate the appropriate timing for the animation and apply the generated <strong class="source-inline">@keyframes</strong> rule to the element, using the CSS <strong class="source-inline">animation</strong> property. The element will then animate according to the specified <strong class="source-inline">transition</strong>, <strong class="source-inline">duration</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">delay</strong></span><span class="No-Break">.</span></p>
<p>For example, in the following code snippet, we have a <strong class="source-inline">fly</strong> transition applied to a <strong class="source-inline">&lt;div&gt;</strong> element with a specified duration of 500 ms and a delay of <span class="No-Break">200 ms:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { fly } from 'svelte/transition';
&lt;/script&gt;
&lt;div in:fly={{ x: 50, y: 30, duration: 500, delay: 200 }}&gt;Some text here&lt;/div&gt;</pre> <p>To animate the <strong class="source-inline">fly</strong> transition in the preceding code snippet, Svelte will generate the corresponding keyframe animation, and apply the generated keyframe animation to the element with the specified duration <span class="No-Break">and delay:</span></p>
<pre class="source-code">
div.style.animation = 'fly-in-unique-id 500ms 200ms 1';</pre> <p>It is also possible to animate a transition <span class="No-Break">using JavaScript.</span></p>
<p>Svelte will schedule a loop through <strong class="source-inline">requestAnimationFrame</strong> to run the animation throughout the <span class="No-Break">specified duration.</span></p>
<p>We won’t delve further into the specifics of how the <strong class="source-inline">requestAnimationFrame</strong> loop works with the animation at this point. In the next chapter, we will explore the creation of custom transitions using JavaScript, which will provide a deeper understanding of how the <strong class="source-inline">requestAnimationFrame</strong> loop interacts with animations and how to <a id="_idIndexMarker538"/>effectively utilize it for smooth, engaging transitions. Stay tuned to learn more about crafting your own unique animations <span class="No-Break">with Svelte.</span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor201"/>Summary</h1>
<p>In this chapter, we learned how to add a transition onto an element. We explored the <strong class="source-inline">transition:</strong>, <strong class="source-inline">in:</strong>, and <strong class="source-inline">out:</strong> directives, and how to <span class="No-Break">customize them.</span></p>
<p>Following that, we looked at when and how the transitions are played. We discussed how the transitions are played when we have a mix of elements with and without transitions, and also how the transitions are played when used inside elements within nested <span class="No-Break">logical blocks.</span></p>
<p>Last but not least, we dug deeper into how the transition animations are played <span class="No-Break">by Svelte.</span></p>
<p>With this knowledge, you can now confidently apply transitions into elements when working with Svelte. This will allow you to enhance the interactivity and visual appeal of your applications, thereby providing a more engaging <span class="No-Break">user experience.</span></p>
<p>In the next chapter, we will look beyond the built-in transitions and will explore the creation of <span class="No-Break">custom transitions.</span></p>
</div>
</div></body></html>