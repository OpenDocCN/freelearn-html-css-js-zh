- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript and TypeScript Primer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers come to the world of web app development via many paths and are not
    always grounded in the basic technologies that web apps rely on. In this chapter,
    I introduce the basic features of JavaScript and TypeScript. This is not a comprehensive
    guide to either language, but it addresses the essentials, and it will give you
    the knowledge you need to get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prepare for this chapter, create a folder named `primer` in a convenient
    location. Navigate to the `primer` folder and run the command shown in *Listing
    3.1*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.1: Preparing the project folder'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the command shown in *Listing 3.2* in the `primer` folder to install the
    development packages that are used in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.2: Installing the development package'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `nodemon` package will be used at the start of the chapter to monitor and
    execute JavaScript files. The `tsc-watc1h` package does the same thing for TypeScript
    files, and the `typescript` package contains the TypeScript compiler. The `@tsconfig/node20`
    package contains configuration settings for the TypeScript compiler for use in
    Node.js projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `scripts` section in the `package.json` file as shown in *Listing
    3.3*, which will make it easier to use the development packages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.3: Replacing the scripts section in the package.json file in the
    primer folder'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add a file named `tsconfig.json` to the `primer` folder with the content shown
    in *Listing 3.4*, which creates a basic configuration for the TypeScript compiler
    suitable for a Node.js project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.4: The contents of the tsconfig.json file in the primer folder'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add a file named `index.js` to the `primer` folder with the content shown in
    *Listing 3.5*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.5: The contents of the index.js file in the primer folder'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the command shown in *Listing 3.6* in the `primer` folder to start monitoring
    and executing JavaScript files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.6: Starting the development tools'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The monitor will generate output similar to the following and will include
    the message written by the statement in *Listing 3.5*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any change to the `index.js` file will be detected by the `nodemon` package
    and will be executed by the Node.js runtime.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript confusion
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is an incredible language that has been the engine of transformation
    for web application development. I love JavaScript and will extol its virtues
    to anyone foolish enough to ask; it is one of the most fluid and expressive languages
    I have used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: That said, JavaScript is a little odd and it causes confusion. At first glance,
    JavaScript looks like any other programming language, which gives programmers
    new to the language a sense of confidence. That confidence does not last, and
    it is only a matter of time until the separate searches on Stack Overflow begin.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript isn’t like other mainstream languages. To see the most confusing
    features, replace the contents of the `index.js` file with the code shown in *Listing
    3.7*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 与其他主流语言不同。要看到最令人困惑的特性，将 `index.js` 文件的内容替换为 *清单 3.7* 中显示的代码。
- en: 'Listing 3.7: Replacing the contents of the index.js file in the primer folder'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.7：替换 primer 文件夹中 index.js 文件的内容
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the changes and the contents of the file will be executed, producing the
    following results:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改后，文件的内容将被执行，产生以下结果：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are two calls to a function named `sum`, and JavaScript allows different
    types to be used as the function arguments. The first call uses two number values
    (`10` and `10`). The second call uses a number value (`10`) and a string value
    (`"10"`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个对名为 `sum` 的函数的调用，JavaScript 允许使用不同的类型作为函数参数。第一个调用使用两个数字值（`10` 和 `10`）。第二个调用使用一个数字值（`10`）和一个字符串值（`"10"`）。
- en: JavaScript is *dynamically typed*, which means that variables are not restricted
    to a specific type of value, and any type of value can be assigned to any variable,
    including function parameters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是 *动态类型*，这意味着变量不受特定类型值的限制，任何类型的值都可以分配给任何变量，包括函数参数。
- en: 'If you look at the output produced by *Listing 3.7*, you will see that the
    function results are oddly different and have different types:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 *清单 3.7* 生成的输出，你会看到函数结果异常不同，并且具有不同的类型：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JavaScript is also *weakly typed*, which means that values will be implicitly
    converted so they can be used together, through a process known as *type coercion*.
    This can be a convenient feature, but it can lead to unexpected results because
    values are coerced in different ways based on the operation that is performed.
    When the `+` operator is applied to a pair of `number` values, JavaScript adds
    the two values together to produce a `number` value. If the `+` operator is applied
    to a `string` and `number` value, then JavaScript converts the `number` value
    to `string` and concatenates the values to produce a `string` result. This is
    why `"10" + 10` produces the `string` result `1010`, but `10 + 10` produces the
    number result `20`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也是 *弱类型*，这意味着值将被隐式转换，以便它们可以一起使用，这个过程称为 *类型强制转换*。这可以是一个方便的特性，但它可能导致意外的结果，因为值根据执行的操作以不同的方式被强制转换。当
    `+` 运算符应用于一对 `number` 值时，JavaScript 将两个值相加以产生一个 `number` 值。如果 `+` 运算符应用于 `string`
    和 `number` 值，那么 JavaScript 将 `number` 值转换为 `string` 并连接值以产生一个 `string` 结果。这就是为什么
    `"10" + 10` 产生 `string` 结果 `1010`，而 `10 + 10` 产生数字结果 `20`。
- en: Using the JavaScript features to express type expectations
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 特性表达类型预期
- en: The way that JavaScript handles data types can be confusing, especially when
    first using the language, but the behavior is consistent and predictable once
    you understand what’s happening.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 处理数据类型的方式可能会令人困惑，尤其是在初次使用该语言时，但一旦你理解了发生了什么，其行为就是一致和可预测的。
- en: A bigger issue is that it can be difficult to communicate the assumptions and
    expectations used to write JavaScript code. The `sum` function is incredibly simple,
    but with more complex functions, it can be difficult to figure out which data
    types are expected and which data types will be returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更大的问题是，可能很难传达编写 JavaScript 代码时使用的假设和预期。`sum` 函数非常简单，但更复杂的函数可能会很难确定预期的数据类型和返回的数据类型。
- en: JavaScript provides features for checking types, which can be used to enforce
    type expectations, as shown in *Listing 3.8*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了检查类型的特性，可以用来强制类型预期，如 *清单 3.8* 所示。
- en: 'Listing 3.8: Checking types in the index.js file in the primer folder'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.8：在 primer 文件夹中的 index.js 文件中检查类型
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `typeof` keyword is used to check that both parameters are `number` values
    and uses the `throw` keyword to create an error if any other type is received.
    When the code is executed, the first call to the `sum` function works, but the
    second fails:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typeof` 关键字检查两个参数都是 `number` 值，并在接收到任何其他类型时使用 `throw` 关键字创建错误。当代码执行时，对 `sum`
    函数的第一个调用是成功的，但第二个调用失败了：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These kinds of type checks are effective but they are only applied when the
    JavaScript code is executed, and that means that thorough testing is required
    to ensure that the `sum` function isn’t invoked with the wrong types.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这类类型检查是有效的，但它们仅在 JavaScript 代码执行时应用，这意味着需要进行彻底的测试，以确保 `sum` 函数没有被错误类型调用。
- en: Using JavaScript to check type expectations
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 检查类型预期
- en: TypeScript doesn’t change the way that the JavaScript type system works but
    it does make it easier to express and enforce type expectations, so that type
    mismatches can be found and resolved more easily. Add a file named `index.ts`
    to the `primer` folder with the content shown in *Listing 3.9*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 并没有改变 JavaScript 类型系统的工作方式，但它确实使表达和强制类型期望变得更加容易，因此可以更容易地找到并解决类型不匹配。将一个名为
    `index.ts` 的文件添加到 `primer` 文件夹中，其内容如 *列表 3.9* 所示。
- en: 'Listing 3.9: The contents of the index.ts file in the primer folder'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9：primer 文件夹中 index.ts 文件的内容
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use `Control+C` to stop the `npm` command that executes JavaScript code, and
    run the command shown in *Listing 3.10* in the `primer` folder to start the command
    that runs TypeScript.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Control+C` 停止执行 JavaScript 代码的 `npm` 命令，并在 `primer` 文件夹中运行 *列表 3.10* 中显示的命令以启动运行
    TypeScript 的命令。
- en: 'Listing 3.10: Starting the TypeScript tools'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10：启动 TypeScript 工具
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The TypeScript compiler processes the contents of the `index.ts` file and generates
    the following error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器处理 `index.ts` 文件的内容并生成以下错误：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `sum` function parameters are decorated with *type annotations*, which tell
    the TypeScript compiler that the `sum` function expects to receive only `number`
    values. The compiler inspects the values used as arguments when the function is
    invoked and reports an error because one of the arguments is not `number`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 函数的参数被添加了 *类型注解*，这告诉 TypeScript 编译器 `sum` 函数期望只接收 `number` 类型的值。编译器检查函数调用时使用的参数值，并报告错误，因为其中一个参数不是
    `number` 类型。'
- en: '**Note**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If you are using Visual Studio Code, you may see an error displayed in the editor
    window with the message *Cannot redeclare block-scoped variable*. This happens
    when the TypeScript and JavaScript files are both open for editing. If you close
    the JavaScript file, the error will disappear.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio Code，你可能会在编辑器窗口中看到一个错误，显示消息 *Cannot redeclare block-scoped
    variable*。这发生在 TypeScript 和 JavaScript 文件都打开进行编辑时。如果你关闭 JavaScript 文件，错误将会消失。
- en: Using a type union
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型联合
- en: Using a single type, such as `number`, in an annotation makes JavaScript behave
    more like other programming languages but restricts some of the flexibility of
    the dynamic JavaScript type system. JavaScript code can be written to intentionally
    support multiple types, as shown in *Listing 3.11*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在注解中使用单个类型，如 `number`，会使 JavaScript 的行为更像其他编程语言，但会限制动态 JavaScript 类型系统的某些灵活性。JavaScript
    代码可以编写来有意支持多种类型，如 *列表 3.11* 所示。
- en: Listing 3.11\. Supporting multiple types in the index.ts file in the primer
    folder
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11\. 在 primer 文件夹中的 index.ts 文件中支持多种类型
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `sum` function checks to see whether the `second` parameter is a string
    value and, if it is, uses the built-in `Number.parseInt` function to convert it
    to a `number` value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 函数会检查第二个参数是否为字符串值，如果是，则使用内置的 `Number.parseInt` 函数将其转换为 `number` 值。'
- en: This has caused a mismatch between the capabilities of the function and the
    type annotations applied to the parameters, and so the compiler produces the same
    error as for *Listing 3.10*. The mismatch can be resolved using a *type union*,
    as shown in *Listing 3.12*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了函数的功能与应用于参数的类型注解之间的不匹配，因此编译器产生与 *列表 3.10* 相同的错误。这种不匹配可以使用 *类型联合* 来解决，如 *列表
    3.12* 所示。
- en: 'Listing 3.12: Using a type union in the index.ts file in the primer folder'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12：在 primer 文件夹中的 index.ts 文件中使用类型联合
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A bar (the `|` character) is used to combine types, so that `number | string`
    tells the compiler that the `second` parameter can be a `number` value or a `string`
    value. The TypeScript checks all uses of the `sum` function and finds that all
    of the types used as arguments match the type annotations. The code produces the
    following output when it is executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用竖线（`|` 字符）来组合类型，因此 `number | string` 告诉编译器第二个参数可以是 `number` 值或 `string` 值。TypeScript
    检查 `sum` 函数的所有使用情况，并发现所有用作参数的类型都与类型注解匹配。代码执行时产生以下输出：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The TypeScript compiler is clever and uses JavaScript features like the `typeof`
    keyword to figure out how types are being used. *Listing 3.13* changes the implementation
    of the `sum` function so that `string` values are no longer treated separately
    from `number` values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器非常聪明，它使用 `typeof` 关键字等 JavaScript 特性来了解类型的使用情况。*列表 3.13* 修改了 `sum`
    函数的实现，使得 `string` 值不再与 `number` 值分开处理。
- en: 'Listing 3.13: Changing the function in the index.ts file in the primer folder'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13：在 primer 文件夹中的 index.ts 文件中更改函数
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The TypeScript compiler knows that JavaScript will do different things when
    it applies the addition operator to two `number` values or `string` and `number`,
    which means that this statement produces an ambiguous result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器知道当 JavaScript 将加法运算符应用于两个 `number` 值或 `string` 和 `number` 时，JavaScript
    会执行不同的操作，这意味着这个语句会产生一个歧义的结果：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'TypeScript is designed to avoid ambiguity, and the compiler will generate the
    following error when compiling the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的设计目的是为了避免歧义，当编译代码时，编译器将生成以下错误：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The purpose of TypeScript is only to highlight potential problems, not to enforce
    any particular solution to a problem. The code in *Listing 3.13* is legal JavaScript,
    but the TypeScript compiler has generated an error because there is a mismatch
    between the type annotations applied to the parameters and the way that the parameter
    values are used inside the `sum` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的目的仅仅是突出潜在的问题，而不是强制执行任何特定的解决方案。*列表 3.13* 中的代码是合法的 JavaScript，但 TypeScript
    编译器生成了错误，因为在 `sum` 函数内部使用参数值的方式与应用于参数的类型注解之间存在不匹配。
- en: One way to resolve this problem is to return to the code in *Listing 3.12*,
    which is sensible if the `sum` function wants to process `number` and `string`
    values without type coercion. An alternative is to tell the compiler that the
    ambiguity is intentional, as shown in *Listing 3.14*, which is sensible if type
    coercion is required.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是回到 *列表 3.12* 中的代码，如果 `sum` 函数想要在不进行类型强制转换的情况下处理 `number` 和 `string`
    值，这是合理的。另一种方法是告诉编译器歧义是故意的，如 *列表 3.14* 所示，如果需要类型强制转换，这是合理的。
- en: 'Listing 3.14: Resolving ambiguity in the index.ts file in the primer folder'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.14：在 primer 文件夹中的 index.ts 文件中解决歧义
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `as` keyword tells the TypeScript compiler that its knowledge of the `second`
    value is incomplete and that it should treat it as a type that I specify. In this
    case, I have specified the `any` type, which has the effect of telling the TypeScript
    that ambiguity is expected and prevents it from producing an error. This code
    produces the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`as` 关键字告诉 TypeScript 编译器其对 `second` 值的了解不完整，并且应该将其视为我指定的类型。在这种情况下，我指定了 `any`
    类型，这相当于告诉 TypeScript 预期存在歧义，并阻止它产生错误。此代码产生以下输出：'
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `as` keyword should be used with caution because the TypeScript compiler
    is sophisticated and usually has a good understanding of how data types are being
    used. Equally, using the `any` type can be dangerous because it essentially stops
    the TypeScript compiler from checking types. When you tell the TypeScript compiler
    that you know more about the code, then you need to make sure that you are right;
    otherwise, you will return to the runtime error issue that led to the introduction
    of TypeScript in the first place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应该谨慎使用 `as` 关键字，因为 TypeScript 编译器非常复杂，通常对数据类型的使用有很好的理解。同样，使用 `any` 类型可能是危险的，因为它本质上阻止
    TypeScript 编译器检查类型。当你告诉 TypeScript 编译器你对代码了解得更多时，你需要确保你是正确的；否则，你将回到导致 TypeScript
    最初引入的运行时错误问题。
- en: Understanding the basic TypeScript/JavaScript features
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的 TypeScript/JavaScript 功能
- en: Now that you understand the relationship between TypeScript and JavaScript,
    it is time to describe the basic language features you will need to follow the
    examples in this book. This is not a comprehensive guide to either TypeScript
    or JavaScript, but it should be enough to get you started.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 TypeScript 和 JavaScript 之间的关系，是时候描述你将需要遵循本书示例的基本语言特性了。这不是 TypeScript
    或 JavaScript 的全面指南，但应该足够让你开始。
- en: Defining variables and constants
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义变量和常量
- en: The `let` keyword is used to define variables, and the `const` keyword is used
    to define a constant value that will not change, as shown in *Listing 3.15*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 关键字定义变量，使用 `const` 关键字定义一个不会改变的常量值，如 *列表 3.15* 所示。
- en: 'Listing 3.15: Defining variables and constants in the index.ts file in the
    primer folder'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15：在 primer 文件夹中的 index.ts 文件中定义变量和常量
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The TypeScript compiler infers the type of each variable or constant from the
    value it is assigned and will generate an error if a value of a different type
    is assigned. Types can be specified explicitly, as shown in *Listing 3.16*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器从分配给每个变量或常量的值推断其类型，如果分配了不同类型的值，将生成错误。类型可以显式指定，如 *列表 3.16* 所示。
- en: Listing 3.16\. Specifying types in the index.ts file in the primer folder
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16\. 在 primer 文件夹中的 index.ts 文件中指定类型
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Dealing with unassigned and null values
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未分配和 null 值
- en: In JavaScript, variables that have been defined but not assigned a value are
    assigned the special value `undefined`, whose type is `undefined`, as shown in
    *Listing 3.17*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，已定义但未赋值的变量将被赋予特殊值 `undefined`，其类型为 `undefined`，如 *清单 3.17* 所示。
- en: 'Listing 3.17: Defining a variable without a value in the index.ts file in the
    primer folder'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.17*：在 primer 文件夹中的 index.ts 文件中定义无值的变量'
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code produces the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生以下输出：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This behavior may seem nonsensical in isolation, but it is consistent with the
    rest of JavaScript, where values have types, and any value can be assigned to
    a variable. JavaScript also defines a separate special value, `null`, which can
    be assigned to variables to indicate no value or result, as shown in *Listing
    3.18*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为单独看起来可能有些不合逻辑，但它与 JavaScript 的其余部分保持一致，其中值有类型，任何值都可以赋给变量。JavaScript 还定义了一个单独的特殊值
    `null`，可以赋给变量以表示无值或结果，如 *清单 3.18* 所示。
- en: 'Listing 3.18: Assigning null in the index.ts file in the primer folder'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.18*：在 primer 文件夹中的 index.ts 文件中赋值 null'
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I can generally provide a robust defense of the way that JavaScript features
    work, but there is an oddity of the `null` value that makes little sense, which
    can be seen in the output this code produces:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常可以提供对 JavaScript 功能工作方式的稳健辩护，但 `null` 值的奇怪之处使得输出显得有些说不通，这可以从此代码产生的输出中看到：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The oddity is that the type of the special `null` value is `object`. This JavaScript
    quirk dates back to the first version of JavaScript and hasn’t been addressed
    because so much code has been written that depends on it. Leaving aside this inconsistency,
    when the TypeScript compiler processes the code, it determines that values of
    different types are assigned to the `place` variable and infers the variable’s
    type as `any`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，特殊 `null` 值的类型是 `object`。这个 JavaScript 的怪癖可以追溯到 JavaScript 的第一个版本，并且由于大量代码依赖于它，所以一直没有得到解决。抛开这种不一致性，当
    TypeScript 编译器处理代码时，它会确定不同类型的值被分配给 `place` 变量，并推断变量的类型为 `any`。
- en: The `any` type allows values of any type to be used, which effectively disables
    the TypeScript compiler’s type checks. A type union can be used to restrict the
    values that can be used, while still allowing `undefined` and `null` to be used,
    as shown in *Listing 3.19*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 类型允许使用任何类型的值，这实际上禁用了 TypeScript 编译器的类型检查。可以使用类型联合来限制可以使用的值，同时仍然允许使用 `undefined`
    和 `null`，如 *清单 3.19* 所示。'
- en: 'Listing 3.19: Using a type union in the index.ts file in the primer folder'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.19*：在 primer 文件夹中的 index.ts 文件中使用类型联合'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This type union allows the `place` variable to be assigned `string` values or
    `undefined` or `null`. Notice that `null` is specified by value in the type union.
    This listing produces the same output as *Listing 3.18*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型联合允许 `place` 变量被赋予 `string` 值或 `undefined` 或 `null`。注意，类型联合中指定了 `null` 的值。此清单产生的输出与
    *清单 3.18* 相同。
- en: Using the JavaScript primitive types
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 原始类型
- en: 'JavaScript defines a small set of commonly used primitive types: `string`,
    `number`, `boolean`, `undefined`, and `null`. This may seem like a short list,
    but JavaScript manages to fit a lot of flexibility into these types. (There are
    also `symbol` and `bigint` types, but these are relatively new additions to JavaScript
    and are not as widely used and not used in this book.)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 定义了一组常用原始类型：`string`、`number`、`boolean`、`undefined` 和 `null`。这似乎是一个简短的列表，但
    JavaScript 成功地将大量灵活性融入到这些类型中。（还有 `symbol` 和 `bigint` 类型，但这些是 JavaScript 中相对较新的添加，并且使用得不太广泛，本书中也没有使用。）
- en: Working with booleans
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理布尔值
- en: 'The `boolean` type has two values: `true` and `false`. *Listing 3.20* shows
    both values being used, but this type is most useful when used in conditional
    statements, such as an `if` statement. There is no output from this listing.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型有两个值：`true` 和 `false`。*清单 3.20* 展示了这两个值的使用，但此类型在条件语句（如 `if` 语句）中使用时最有用。此清单没有输出。'
- en: 'Listing 3.20: Defining boolean values in the index.ts file in the primer folder'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.20*：在 primer 文件夹中的 index.ts 文件中定义 boolean 值'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Working with strings
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理字符串
- en: You define `string` values using either the double or single quote characters,
    as shown in *Listing 3.21*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用双引号或单引号字符定义 `string` 值，如 *清单 3.21* 所示。
- en: 'Listing 3.21: Defining string variables in the index.ts file in the primer
    folder'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.21*：在 primer 文件夹中的 index.ts 文件中定义字符串变量'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The quote characters you use must match. You can’t start a string with a single
    quote and finish with a double quote, for example. There is no output from this
    listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用的引号必须匹配。例如，您不能以单引号开始字符串并以双引号结束。此清单没有输出。
- en: Using template strings
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板字符串
- en: A common programming task is to combine static content with data values to produce
    a string that can be presented to the user. JavaScript supports *template strings*,
    which allow data values to be specified in line with static content, as shown
    in *Listing 3.22*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的编程任务是结合静态内容和数据值以生成可以呈现给用户的字符串。JavaScript 支持 *模板字符串*，允许在静态内容中指定数据值，如 *清单 3.22*
    所示。
- en: 'Listing 3.22: Using a template string in the index.ts file in the primer folder'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.22*：在 primer 文件夹中的 index.ts 文件中使用模板字符串'
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Template strings begin and end with backticks (the `` ` `` character), and
    data values are denoted by curly braces preceded by a dollar sign. This string,
    for example, incorporates the value of the `place` variable and its type into
    the template string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串以反引号（`` ` `` 字符）开始和结束，数据值由美元符号前缀的括号表示。例如，此字符串将 `place` 变量的值及其类型合并到模板字符串中：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This example produces the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例产生以下输出：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Working with numbers
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理数字
- en: The `number` type is used to represent both *integer* and *floating-point* numbers,
    as shown in *Listing 3.23*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 类型用于表示整数和浮点数，如 *清单 3.23* 所示。'
- en: 'Listing 3.23: Defining number values in the index.ts file in the primer folder'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.23*：在 primer 文件夹中的 index.ts 文件中定义数字值'
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You don’t have to specify which kind of number you are using. You just express
    the value you require, and JavaScript will act accordingly. In the listing, I
    have defined an integer value, defined a floating-point value, and prefixed a
    value with `0x` to denote a hexadecimal value. *Listing 3.23* doesn’t produce
    any output.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需指定使用哪种类型的数字。您只需表达所需的价值，JavaScript 将相应地处理。在清单中，我定义了一个整数值，定义了一个浮点数值，并在值前加上
    `0x` 以表示十六进制值。*清单 3.23* 不会产生任何输出。
- en: Working with null and undefined values
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 null 和 undefined 值
- en: The `null` and `undefined` values have no features, such as properties or methods,
    but the unusual approach taken by JavaScript means that you can only assign these
    values to variables whose type is a union that includes `null` or `undefined`,
    as shown in *Listing 3.24*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 和 `undefined` 值没有特性，例如属性或方法，但 JavaScript 采取的异常方法意味着您只能将这些值分配给类型为包含 `null`
    或 `undefined` 的联合类型的变量，如 *清单 3.24* 所示。'
- en: 'Listing 3.24: Assigning null and undefined values in the index.ts file in the
    primer folder'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.24*：在 primer 文件夹中的 index.ts 文件中分配 null 和 undefined 值'
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The TypeScript compiler will infer the type of the `person1` variable as `string`
    because that is the type of the value assigned to it. This variable cannot be
    assigned the `null` or `undefined` value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器会将 `person1` 变量的类型推断为 `string`，因为分配给它的值的类型是 `string`。此变量不能分配 `null`
    或 `undefined` 值。
- en: The `person2` variable is defined with a type annotation that specifies `string`
    or `undefined` values. This variable can be assigned `undefined` but not `null`,
    as `null` is not part of the type union. *Listing 3.24* doesn’t produce any output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`person2` 变量使用类型注解定义，指定 `string` 或 `undefined` 值。此变量可以分配 `undefined` 但不能分配
    `null`，因为 `null` 不是类型联合的一部分。*清单 3.24* 不会产生任何输出。'
- en: Using the JavaScript operators
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 运算符
- en: JavaScript defines a largely standard set of operators, the most useful of which
    are described in the following sections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 定义了一个相当标准的运算符集，其中最有用的将在以下章节中描述。
- en: Using conditional statements
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: Many of the JavaScript operators are used in conjunction with conditional statements.
    In this book, I tend to use `if/else`, but JavaScript also supports `switch` statements,
    and *Listing 3.25* shows the use of both, which will be familiar if you have worked
    with pretty much any programming language.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 JavaScript 运算符都与条件语句一起使用。在这本书中，我倾向于使用 `if/else`，但 JavaScript 也支持 `switch`
    语句，*清单 3.25* 展示了两种语句的使用，如果您几乎与任何编程语言都合作过，这将很熟悉。
- en: 'Listing 3.25: Using the if/else and switch conditional statements in the index.ts
    file in the primer folder'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.25*：在 primer 文件夹中的 index.ts 文件中使用 if/else 和 switch 条件语句'
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The results from the listing are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单的结果如下：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The equality operator vs. the identity operator
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等式运算符与身份运算符
- en: In JavaScript, the equality operator (`==`) will attempt to coerce (convert)
    operands to the same type to assess equality. This can be a useful feature, but
    it is widely misunderstood and often leads to unexpected results. *Listing 3.26*
    shows the equality operator in action.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，等价运算符（`==`）将尝试将操作数转换为相同的类型以评估相等性。这可以是一个有用的功能，但它被广泛误解，并且经常导致意外的结果。*清单3.26*显示了等价运算符的作用。
- en: 'Listing 3.26: Using the equality operator in the index.ts file in the primer
    folder'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3.26：在入门文件夹中的index.ts文件中使用等价运算符
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output from this code is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JavaScript is converting the two operands into the same type and comparing them.
    In essence, the equality operator tests that values are the same, irrespective
    of their type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript会将两个操作数转换为相同的类型并比较它们。本质上，等价运算符测试值是否相同，而不管它们的类型如何。
- en: If you want to test to ensure that the values *and* the types are the same,
    then you need to use the identity operator (`===`, three equals signs, rather
    than the two of the equality operator), as shown in *Listing 3.27*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保值和类型都相同，那么你需要使用身份运算符（`===`，三个等号，而不是等价运算符的两个等号），如*清单3.27*所示。
- en: 'Listing 3.27: Using the identity operator in the index.ts file in the primer
    folder'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3.27：在入门文件夹中的index.ts文件中使用身份运算符
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, the identity operator will consider the two variables to be
    different. This operator doesn’t coerce types. The result from this code is as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，身份运算符将认为两个变量是不同的。这个运算符不会强制类型转换。这段代码的结果如下：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To demonstrate how JavaScript works, I had to use the `any` type when declaring
    the `firstVal` and `secondVal` variables because TypeScript restricts the use
    of the equality operator so that it can be used only on two values of the same
    type. *Listing 3.28* removes the variable type annotations and allows TypeScript
    to infer the types from the assigned values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示JavaScript的工作原理，我不得不在声明`firstVal`和`secondVal`变量时使用`any`类型，因为TypeScript限制了等价运算符的使用，使其只能用于相同类型的两个值。*清单3.28*移除了变量类型注释，并允许TypeScript从分配的值中推断类型。
- en: 'Listing 3.28: Removing the type annotations in the index.ts file in the primer
    folder'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3.28：在入门文件夹中的index.ts文件中移除类型注释
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The TypeScript compiler detects that the variable types are not the same and
    generates the following error:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器检测到变量类型不同，并生成以下错误：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Understanding Truthy and Falsy Values**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解真值和假值**'
- en: An important consequence of type coercion is JavaScript *truthiness*. A *truthy*
    value is one that evaluates to `true` when coerced to a Boolean value, and a *falsy*
    value is one that evaluates to `false` when coerced to a Boolean value. Every
    value is truthy except `false`, `0`, `-0`, `""` (the empty string), `null`, `undefined`,
    and `NaN`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换的一个重要后果是JavaScript的*真值*。一个*真值*是在转换为布尔值时评估为`true`的值，而一个*假值*是在转换为布尔值时评估为`false`的值。除了`false`、`0`、`-0`、`""`（空字符串）、`null`、`undefined`和`NaN`之外，每个值都是真值。
- en: 'This feature is often used to check that a variable has been assigned a value
    and you will see many examples in later chapters, like this expression:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能通常用于检查一个变量是否已分配了值，你将在后面的章节中看到许多例子，就像这个表达式一样：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is a useful way to see if a value has been assigned value, especially
    when querying a database or processing data received from the user. Don’t be tempted
    to use an expression like this one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种查看值是否已分配值的有用方法，尤其是在查询数据库或处理从用户接收到的数据时。不要被这种表达式所诱惑：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this expression, the type coercion is applied to the `true` value and not
    whatever value has been assigned to `customer`, which is unlikely to produce the
    expected result.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，类型转换应用于`true`值，而不是分配给`customer`的任何值，这不太可能产生预期的结果。
- en: Using the null and nullish coalescing operators
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用null和nullish合并运算符
- en: The logical OR operator (`||`) has been traditionally used as a null coalescing
    operator in JavaScript, allowing a fallback value to be used in place of `null`
    or `undefined` values, as shown in *Listing 3.29*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或运算符（`||`）在JavaScript中传统上被用作空合并运算符，允许使用回退值代替`null`或`undefined`值，如*清单3.29*所示。
- en: 'Listing 3.29: Using the null coalescing operator in the index.ts file in the
    primer folder'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3.29：在入门文件夹中的index.ts文件中使用null合并运算符
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `||` operator returns the left-hand operand if it evaluates as truthy and
    returns the right-hand operand otherwise. When the operator is applied to `val1`,
    the right-hand operand is returned because no value has been assigned to the variable,
    meaning that it is `undefined`. When the operator is applied to `val2`, the left-hand
    operand is returned because the variable has been assigned the string `London`,
    which evaluates as truthy. This code produces the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`||` 操作符如果左侧操作数评估为真值则返回左侧操作数，否则返回右侧操作数。当操作符应用于 `val1` 时，返回右侧操作数，因为没有为变量赋值，意味着它是
    `undefined`。当操作符应用于 `val2` 时，返回左侧操作数，因为变量已被赋值为字符串 `London`，这评估为真值。此代码产生以下输出：'
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The problem with using the `||` operator this way is that truthy and falsy values
    can produce unexpected results, as shown in *Listing 3.30*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 `||` 操作符的问题在于，真值和假值可能会产生意外的结果，如 *列表 3.30* 所示。
- en: 'Listing 3.30: An unexpected null coalescing result in the index.ts file in
    the primer folder'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.30：在 primer 文件夹中的 index.ts 文件中意外的空合并运算结果
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The new coalescing operation returns the fallback value, even though the `val3`
    variable is neither `null` nor `undefined`, because `0` evaluates as falsy. The
    code produces the following results:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 新的合并操作返回回退值，即使 `val3` 变量既不是 `null` 也不是 `undefined`，因为 `0` 被评估为假值。代码产生以下结果：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The nullish coalescing operator (`??`) addresses this issue by returning the
    right-hand operand only if the left-hand operand is `null` or `undefined`, as
    shown in *Listing 3.31*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 空合并操作符（`??`）通过仅在左侧操作数为 `null` 或 `undefined` 时返回右侧操作数来解决此问题，如 *列表 3.31* 所示。
- en: 'Listing 3.31: Using the nullish coalescing operator in the index.ts file in
    the primer folder'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.31：在 primer 文件夹中的 index.ts 文件中使用空合并操作符
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The nullish operator doesn’t consider truthy and falsy outcomes and looks only
    for the `null` and `undefined` values. This code produces the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 空操作符不考虑真值和假值结果，只查找 `null` 和 `undefined` 值。此代码产生以下输出：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the optional chaining operator
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可选链操作符
- en: As explained earlier, TypeScript won’t allow `null` or `undefined` to be assigned
    to variables unless they have been defined with a suitable type union. Furthermore,
    TypeScript will only allow methods and properties defined by all of the types
    in the union to be used.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TypeScript 不会允许将 `null` 或 `undefined` 赋值给变量，除非它们已经被定义为合适的类型联合。此外，TypeScript
    只允许使用联合中所有类型定义的方法和属性。
- en: This combination of features means that you have to guard against `null` or
    `undefined` values before you can use the features provided by any other type
    in a union, as demonstrated in *Listing 3.32*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能组合意味着在使用联合中任何其他类型提供的功能之前，您必须保护 `null` 或 `undefined` 值，如 *列表 3.32* 所示。
- en: 'Listing 3.32: Guarding against null or undefined values in the index.ts file
    in the primer folder'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.32：在 primer 文件夹中的 index.ts 文件中防止 `null` 或 `undefined` 值
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To invoke the `toFixed` method, I have to make sure that the `count` variable
    hasn’t been assigned `null` or `undefined`. The TypeScript compiler understands
    the meaning of the expressions in the `if` statement and knows that excluding
    `null` and `undefined` values means that the value assigned to `count` must be
    `number`, meaning that the `toFixed` method can be used safely. This code produces
    the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `toFixed` 方法，我必须确保 `count` 变量没有被赋值为 `null` 或 `undefined`。TypeScript 编译器理解
    `if` 语句中的表达式含义，并且知道排除 `null` 和 `undefined` 值意味着分配给 `count` 的值必须是 `number` 类型，这意味着可以安全地使用
    `toFixed` 方法。此代码产生以下输出：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The optional chaining operator (the `?` character) simplifies the guarding process,
    as shown in *Listing 3.33*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链操作符（`?` 字符）简化了保护过程，如 *列表 3.33* 所示。
- en: 'Listing 3.33: Using the optional chaining operator in the index.ts file in
    the primer folder'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.33：在 primer 文件夹中的 index.ts 文件中使用可选链操作符
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The operator is applied between the variable and the method call and will return
    `undefined` if the value is `null` or `undefined`, preventing the method from
    being invoked:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符应用于变量和方法调用之间，如果值是 `null` 或 `undefined`，则返回 `undefined`，从而防止调用方法：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the value isn’t `null` or `undefined`, then the method call will proceed
    as normal. The result from an expression that includes the optional chaining operator
    is a type union of undefined and the result from the method. In this case, the
    union will be `string |` `undefined` because the `toFixed` method returns `string`.
    The code in *Listing 3.33* produces the following output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不是`null`或`undefined`，则方法调用将按正常进行。包含可选链操作符的表达式的结果是`undefined`和方法的返回值的类型联合。在这种情况下，联合将是`string
    | undefined`，因为`toFixed`方法返回`string`。*清单 3.33*中的代码会产生以下输出：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Defining and using functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和使用函数
- en: When Node.js processes a JavaScript file, it executes the statements in the
    order in which they have been defined. In common with most languages, JavaScript
    allows statements to be grouped into a function, which won’t be executed until
    a statement that invokes the function is executed, as shown in *Listing 3.34*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 处理 JavaScript 文件时，它会按照定义的顺序执行语句。与大多数语言类似，JavaScript 允许将语句组合成一个函数，该函数不会执行，直到执行调用该函数的语句，如*清单
    3.34*所示。
- en: 'Listing 3.34: Defining a function in the index.ts file in the primer folder'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.34*：在 primer 文件夹中的 index.ts 文件中定义一个函数'
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Functions are defined with the `function` keyword and are given a name. If
    a function defines parameters, then TypeScript requires type annotations, which
    are used to enforce consistency in the use of the function. The function in *Listing
    3.34* is named `writeValue`, and it defines a parameter that will accept `string`
    or `null` values. The statement inside of the function isn’t executed until the
    function is executed. The code in *Listing 3.34* produces the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用`function`关键字定义，并赋予一个名称。如果一个函数定义了参数，TypeScript 要求类型注解，这些注解用于强制函数使用的统一性。*清单
    3.34*中的函数名为`writeValue`，它定义了一个可以接受`string`或`null`值的参数。函数内部的语句只有在函数执行时才会执行。*清单
    3.34*中的代码会产生以下输出：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Defining optional function parameters
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可选函数参数
- en: By default, TypeScript will allow functions to be invoked only when the number
    of arguments matches the number of parameters the function defines. This may seem
    obvious if you are used to other mainstream languages, but a function can be called
    with any number of arguments in JavaScript, regardless of how many parameters
    have been defined. The `?` character is used to denote an optional parameter,
    as shown in *Listing 3.35*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，TypeScript 允许函数仅在参数数量与函数定义的参数数量相匹配时被调用。如果你习惯了其他主流语言，这可能会显得很直观，但在 JavaScript
    中，无论定义了多少个参数，函数都可以用任意数量的参数来调用。`?` 字符用于表示可选参数，如*清单 3.35*所示。
- en: 'Listing 3.35: Defining an optional parameter in the index.ts file in the primer
    folder'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.35*：在 primer 文件夹中的 index.ts 文件中定义一个可选参数'
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `?` operator has been applied to the `val` parameter, which means that the
    function can be invoked with zero or one argument. Within the function, the parameter
    type is `string | undefined`, because the value will be undefined if the function
    is invoked without an argument.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 操作符已应用于`val`参数，这意味着函数可以不带参数或带一个参数被调用。在函数内部，参数类型是`string | undefined`，因为如果函数不带参数被调用，其值将是`undefined`。'
- en: '**Note**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'Don’t confuse `val?: string`, which is an optional parameter, with `val: string
    | undefined`, which is a type union of `string` and `undefined`. The type union
    requires the function to be invoked with an argument, which may be the value `undefined`,
    whereas the optional parameter allows the function to be invoked without an argument.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '不要将`val?: string`（这是一个可选参数）与`val: string | undefined`（这是`string`和`undefined`的类型联合）混淆。类型联合要求函数调用时必须带有一个参数，这个参数可能是`undefined`的值，而可选参数允许函数不带参数被调用。'
- en: 'The code in *Listing 3.35* produces the following output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.35*中的代码会产生以下输出：'
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Defining default parameter values
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义默认参数值
- en: Parameters can be defined with a default value, which will be used when the
    function is invoked without a corresponding argument. This can be a useful way
    to avoid dealing with `undefined` values, as shown in *Listing 3.36*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给参数定义一个默认值，当函数不带相应参数被调用时，将使用这个默认值。这是一种避免处理`undefined`值的有用方法，如*清单 3.36*所示。
- en: 'Listing 3.36: Defining a default parameter value in the index.ts file in the
    primer folder'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.36*：在 primer 文件夹中的 index.ts 文件中定义一个默认参数值'
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The default value will be used when the function is invoked without an argument.
    This means that the type of the parameter in the example will always be `string`,
    so I don’t have to check for `undefined` values. The code in *Listing 3.36* produces
    the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数在没有参数的情况下被调用时，将使用默认值。这意味着示例中参数的类型始终是 `string`，因此我不必检查 `undefined` 值。*列表 3.36*
    中的代码产生以下输出：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Defining rest parameters
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义剩余参数
- en: '*Rest parameters* are used to capture any additional arguments when a function
    is invoked with additional arguments, as shown in *Listing 3.37*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*剩余参数* 用于在函数调用时捕获任何额外的参数，如*列表 3.37* 所示。'
- en: 'Listing 3.37: Using a rest parameter in the index.ts file in the primer folder'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.37：在 primer 文件夹中的 index.ts 文件中使用剩余参数
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The rest parameter must be the last parameter defined by the function, and
    its name is prefixed with an ellipsis (three periods, `...`). The rest parameter
    is an array to which any extra arguments will be assigned. In the listing, the
    function prints out each extra argument to the console, producing the following
    results:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数必须是函数定义中的最后一个参数，并且其名称前缀为省略号（三个点，`...`）。剩余参数是一个数组，任何额外的参数都将被分配到这个数组中。在列表中，该函数将每个额外的参数打印到控制台，产生以下结果：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Defining functions that return results
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义返回结果的函数
- en: You can return results from functions by declaring the return data type and
    using the `return` keyword within the function body, as shown in *Listing 3.38*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明返回数据类型并在函数体中使用 `return` 关键字从函数中返回结果，如*列表 3.38* 所示。
- en: 'Listing 3.38: Returning a result in the index.ts file in the primer folder'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.38：在 primer 文件夹中的 index.ts 文件中返回结果
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The new function defines one parameter, which is `string`, and returns a result,
    which is also a `string`. The type of the result is defined using a type annotation
    after the parameters:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数定义了一个参数，即 `string`，并返回一个结果，也是一个 `string`。结果类型使用参数后的类型注解定义：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'TypeScript will check the use of the `return` keyword to ensure that the function
    returns a result and that the result is of the expected type. This code produces
    the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将检查 `return` 关键字的用法，以确保函数返回一个结果，并且结果类型符合预期。此代码产生以下输出：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using functions as arguments to other functions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数作为其他函数的参数使用
- en: JavaScript functions are values, which means you can use one function as the
    argument to another, as demonstrated in *Listing 3.39*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数是值，这意味着你可以将一个函数作为另一个函数的参数使用，如*列表 3.39* 所示。
- en: 'Listing 3.39: Using a function as an argument to another function in the index.ts
    file in the primer folder'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.39：在 primer 文件夹中的 index.ts 文件中将函数作为另一个函数的参数使用
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `writeCity` function defines a parameter called `f`, which is a function
    that it invokes to get the value to insert into the string that it writes out.
    TypeScript requires the function parameter to be described so that the types of
    its parameters and results are declared:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeCity` 函数定义了一个名为 `f` 的参数，这是一个它调用来获取要插入到它写入的字符串中的值的函数。TypeScript 要求函数参数必须这样描述，以便声明其参数和结果类型：'
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is the *arrow syntax*, also known as *fat arrow syntax* or *lambda expression
    syntax*. There are three parts to an arrow function: the input parameters surrounded
    by parentheses, then an equal sign and a greater-than sign (the “arrow”), and
    finally, the function result. The parameter function doesn’t define any parameters,
    so the parentheses are empty. This means that the type of parameter `f` is a function
    that accepts no parameters and returns a `string` result. The parameter function
    is invoked within a template string:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *箭头语法*，也称为 *胖箭头语法* 或 *lambda 表达式语法*。箭头函数有三个部分：括号内的输入参数，然后是一个等号和一个大于号（“箭头”），最后是函数结果。参数函数没有定义任何参数，因此括号是空的。这意味着参数
    `f` 的类型是一个不接受任何参数并返回 `string` 结果的函数。参数函数在模板字符串中被调用：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Only functions with the specified combination of parameters and result can
    be used as an argument to `writeCity`. The `getUKCapital` function has the correct
    characteristics:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有指定参数和结果组合的函数才能用作 `writeCity` 的参数。`getUKCapital` 函数具有正确的特征：
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Notice that only the name of the function is used as the argument. If you follow
    the function name with parentheses, `writeCity(getUKCapital())`, then you are
    telling JavaScript to invoke the `getUKCapital` function and pass the result to
    the `writeCity` function. TypeScript will detect that the result from the `getUKCapital`
    function doesn’t match the parameter type defined by the `writeCity` function
    and will produce an error when the code is compiled. The code in *Listing 3.39*
    produces the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里只使用了函数的名称作为参数。如果你在函数名称后跟括号，`writeCity(getUKCapital())`，那么你是在告诉 JavaScript
    调用 `getUKCapital` 函数并将结果传递给 `writeCity` 函数。TypeScript 将检测 `getUKCapital` 函数的结果与
    `writeCity` 函数定义的参数类型不匹配，并在代码编译时产生错误。*列表 3.39*中的代码产生以下输出：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Defining functions using the arrow syntax
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用箭头语法定义函数
- en: The arrow syntax can also be used to define functions, which is a useful way
    to define functions inline, as shown in *Listing 3.40*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头语法也可以用来定义函数，这是一种在行内定义函数的有用方法，如*列表 3.40*所示。
- en: 'Listing 3.40: Defining an arrow function in the index.ts file in the primer
    folder'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.40：在 primer 文件夹中的 index.ts 文件中定义箭头函数
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This inline function receives no parameters and returns the literal string
    value `Paris`, defining a function that can be used as an argument to the `writeCity`
    function. The code in *Listing 3.40* produces the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此行内函数不接受任何参数，并返回字面字符串值 `Paris`，定义了一个可以作为 `writeCity` 函数参数使用的函数。*列表 3.40*中的代码产生以下输出：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Understanding value closure
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解值闭包
- en: Functions can access values that are defined in the surrounding code, using
    a feature called *closure*, as demonstrated in *Listing 3.41*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以使用称为 *闭包* 的功能访问在周围代码中定义的值，如*列表 3.41*所示。
- en: 'Listing 3.41: Using a closure in the index.ts file in the primer folder'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.41：在 primer 文件夹中的 index.ts 文件中使用闭包
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The new arrow function returns the value of the variable named `myCity`, which
    is defined in the surrounding code. This is a powerful feature that means you
    don’t have to define parameters on functions to pass around data values, but caution
    is required because it is easy to get unexpected results when using common variable
    names like `counter` or `index`, where you may not realize that you are reusing
    a variable name from the surrounding code. This example produces the following
    output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 新的箭头函数返回名为 `myCity` 的变量的值，该变量在周围的代码中定义。这是一个强大的功能，意味着你不需要在函数上定义参数来传递数据值，但需要注意，因为在使用像
    `counter` 或 `index` 这样的常用变量名时，很容易得到意外的结果，你可能没有意识到你正在重用周围代码中的变量名。此示例产生以下输出：
- en: '[PRE77]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Working with arrays
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数组
- en: JavaScript arrays work like arrays in most other programming languages. *Listing
    3.42* demonstrates how to create and populate an array.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数组在大多数其他编程语言中的工作方式类似于数组。*列表 3.42*演示了如何创建和填充一个数组。
- en: 'Listing 3.42: Creating and populating an array in the index.ts file in the
    primer folder'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.42：在 primer 文件夹中的 index.ts 文件中创建和填充数组
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: I have created a new and empty array using the literal syntax, which uses square
    brackets, and assigned the array to a variable named `myArray`. In the subsequent
    statements, I assign values to various index positions in the array. (There is
    no output from this listing.)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用字面语法创建了一个新的空数组，使用方括号，并将其分配给名为 `myArray` 的变量。在后续语句中，我将值分配到数组的各个索引位置。（此列表没有输出。）
- en: 'There are a couple of things to note in this example. First, I didn’t need
    to declare the number of items in the array when I created it. JavaScript arrays
    will resize themselves to hold any number of items. The second point is that I
    didn’t have to declare the data types that the array would hold. Any JavaScript
    array can hold any mix of data types. In the example, I have assigned three items
    to the array: `number`, `string`, and `boolean`. The TypeScript compiler infers
    the type of the array as `any[]`, denoting an array that can hold values of all
    types. The example can be written with the type annotation shown in *Listing 3.43*.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，有两点需要注意。首先，我在创建数组时不需要声明项目数量。JavaScript 数组会自动调整大小以容纳任何数量的项目。第二点是，我无需声明数组将持有的数据类型。任何
    JavaScript 数组都可以持有任何类型的数据混合。在示例中，我已将三个项目分配给数组：`number`、`string` 和 `boolean`。TypeScript
    编译器推断数组的类型为 `any[]`，表示可以持有所有类型值的数组。此示例可以用*列表 3.43*中显示的类型注解来编写。
- en: 'Listing 3.43: Using a type annotation in the index.ts file in the primer folder'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.43：在 primer 文件夹中的 index.ts 文件中使用类型注解
- en: '[PRE79]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Arrays can be restricted to values with specific types, as shown in *Listing
    3.44*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以被限制为具有特定类型的值，如*清单 3.44*所示。
- en: 'Listing 3.44: Restricting array value types in the index.ts file in the primer
    folder'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.44：在 primer 文件夹中的 index.ts 文件中限制数组值类型
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The type union restricts the array so that it can hold only `number`, `string`,
    and `boolean` values. Notice that I have put the type union in parentheses because
    the union `number | string | boolean[]` denotes a value that can be assigned `number`,
    a `string`, or an array of `boolean` values, which is not what is intended.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 类型联合限制了数组，使其只能包含`number`、`string`和`boolean`值。请注意，我将类型联合放在括号中，因为联合`number | string
    | boolean[]`表示一个可以分配`number`、`string`或布尔值数组的值，这并不是预期的。
- en: Arrays can be defined and populated in a single statement, as shown in *Listing
    3.45*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以在单个语句中定义和填充，如*清单 3.45*所示。
- en: 'Listing 3.45: Populating a new array in the index.ts file in the primer folder'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.45：在 primer 文件夹中的 index.ts 文件中填充新的数组
- en: '[PRE81]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If you omit the type annotation, TypeScript will infer the array type from the
    values used to populate the array. You should rely on this feature with caution
    for arrays that are intended to hold multiple types because it requires that the
    full range of types is used when creating the array.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了类型注解，TypeScript 将从用于填充数组的值中推断数组类型。你应该谨慎地使用此功能，因为对于打算包含多种类型的数组，它要求在创建数组时使用完整的类型范围。
- en: Reading and modifying the contents of an array
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和修改数组的内 容
- en: You read the value at a given index using square braces (`[` and `]`), placing
    the index you require between the braces, as shown in *Listing 3.46*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用方括号（`[`和`]`）读取给定索引的值，将所需的索引放在括号之间，如*清单 3.46*所示。
- en: 'Listing 3.46: Reading the data from an array index in the index.ts file in
    the primer folder'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.46：在 primer 文件夹中的 index.ts 文件中读取数组索引的数据
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The TypeScript compiler infers the type of values in the array so that the
    type of the `val` variable in *Listing 3.46* is `number | string | boolean`. This
    code produces the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器推断数组中值的类型，因此*清单 3.46*中`val`变量的类型是`number | string | boolean`。这段代码产生了以下输出：
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can modify the data held in any position in a JavaScript array simply by
    assigning a new value to the index, as shown in *Listing 3.47*. The TypeScript
    compiler will check that the type of the value you assign matches the array element
    type.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地分配一个新的值到索引来修改 JavaScript 数组中任何位置的数据，如*清单 3.47*所示。TypeScript 编译器将检查你分配的值的类型是否与数组元素类型匹配。
- en: 'Listing 3.47: Modifying the contents of an array in the index.ts file in the
    primer folder'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.47：在 primer 文件夹中的 index.ts 文件中修改数组的内容
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In this example, I have assigned a `string` to position `0` in the array, a
    position that was previously held by a `number`. This code produces the following
    output:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将一个`string`赋值给了数组的`0`位置，这个位置之前被一个`number`占据。这段代码产生了以下输出：
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Enumerating the contents of an array
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举数组的内 容
- en: You enumerate the content of an array using a `for` loop or the `forEach` method,
    which receives a function that is called to process each element in the array.
    *Listing 3.48* shows both approaches.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for`循环或`forEach`方法枚举数组的内 容，`forEach`方法接收一个函数，该函数被调用来处理数组中的每个元素。*清单 3.48*展示了这两种方法。
- en: 'Listing 3.48: Enumerating the contents of an array in the index.ts file in
    the primer folder'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.48：在 primer 文件夹中的 index.ts 文件中枚举数组的内 容
- en: '[PRE86]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The JavaScript `for` loop works just the same way as loops in many other languages.
    You determine how many elements there are in the array using its `length` property.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的`for`循环与其他许多语言中的循环工作方式相同。你使用其`length`属性确定数组中有多少个元素。
- en: 'The function passed to the `forEach` method is given two arguments: the value
    of the current item to be processed and the position of that item in the array.
    In this listing, I have used an arrow function as the argument to the `forEach`
    method, which is the kind of use for which they excel (and you will see used throughout
    this book). The output from the listing is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`forEach`方法的函数提供了两个参数：要处理的当前项的值和该项在数组中的位置。在这个列表中，我使用了箭头函数作为`forEach`方法的参数，这是箭头函数擅长的用法（你将在本书中看到其使用）。列表的输出如下：
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Using the spread operator
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用展开运算符
- en: The spread operator is used to expand an array so that its contents can be used
    as function arguments or combined with other arrays. In *Listing 3.49*, I used
    the spread operator to expand an array so that its items can be combined into
    another array.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符用于展开数组，以便其内容可以用作函数参数或与其他数组组合。在 *列表 3.49* 中，我使用了扩展运算符来展开数组，以便其项可以组合到另一个数组中。
- en: 'Listing 3.49: Using the spread operator in the index.ts file in the primer
    folder'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.49：在 primer 文件夹中的 index.ts 文件中使用扩展运算符
- en: '[PRE88]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The spread operator is an ellipsis (a sequence of three periods), and it causes
    the array to be unpacked:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符是一个省略号（三个点的序列），它会导致数组被展开：
- en: '[PRE89]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Using the spread operator, I can specify `myArray` as an item when I define
    `otherArray`, with the result that the contents of the first array will be unpacked
    and added as items to the second array. This example produces the following results:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展运算符，我可以在定义 `otherArray` 时将 `myArray` 指定为一个项，结果是将第一个数组的所有内容展开并添加到第二个数组中作为项。此示例产生以下结果：
- en: '[PRE90]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Working with objects
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的处理
- en: JavaScript objects are a collection of properties, each of which has a name
    and value. The simplest way to create an object is to use the literal syntax,
    as shown in *Listing 3.50*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象是一组属性集合，每个属性都有一个名称和值。创建对象的最简单方法是使用文字符号，如 *列表 3.50* 所示。
- en: 'Listing 3.50: Creating an object in the index.ts file in the primer folder'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.50：在 primer 文件夹中的 index.ts 文件中创建对象
- en: '[PRE91]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The literal syntax uses braces to contain a list of property names and values.
    Names are separated from their values with colons and from other properties with
    commas. Two objects are defined in *Listing 3.50* and assigned to variables named
    `hat` and `boots`. The properties defined by the object can be accessed through
    the variable name, as shown in this statement:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 文字符号语法使用大括号来包含属性名称和值的列表。名称与它们的值之间用冒号分隔，与其他属性之间用逗号分隔。在 *列表 3.50* 中定义了两个对象，分别命名为
    `hat` 和 `boots`。通过变量名可以访问对象定义的属性，如下所示：
- en: '[PRE92]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The code in *Listing 3.50* produces the following output:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3.50* 中的代码产生以下输出：'
- en: '[PRE93]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Understanding literal object types
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文字对象类型
- en: When the TypeScript compiler encounters a literal object, it infers its type,
    using the combination of property names and the values to which they are assigned.
    This combination can be used in type annotations, allowing the shape of objects
    to be described as, for example, function parameters, as shown in *Listing 3.51*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TypeScript 编译器遇到文字对象时，它会推断其类型，使用属性名称及其分配的值组合。这个组合可以用在类型注解中，允许描述对象的形状，例如，作为函数参数，如
    *列表 3.51* 所示。
- en: 'Listing 3.51: Describing an object type in the index.ts file in the primer
    folder'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.51：在 primer 文件夹中的 index.ts 文件中描述对象类型
- en: '[PRE94]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The type annotation specifies that the `product` parameter can accept objects
    that define a `string` property called `name`, and a `number` property named `price`.
    This example produces the same output as *Listing 3.50*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解指定 `product` 参数可以接受定义了名为 `name` 的 `string` 属性和名为 `price` 的 `number` 属性的对象。此示例产生的输出与
    *列表 3.50* 相同。
- en: A type annotation that describes a combination of property names and types just
    sets out a minimum threshold for objects, which can define additional properties
    and can still conform to the type, as shown in *Listing 3.52*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解描述属性名称和类型的组合，仅为对象设定了一个最小阈值，可以定义额外的属性，并且仍然符合类型，如 *列表 3.52* 所示。
- en: Listing 3.52\. Adding a property in the index.ts file in the primer folder
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.52\. 在 primer 文件夹中的 index.ts 文件中添加属性
- en: '[PRE95]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The listing adds a new property to the objects assigned to the `boots` variable,
    but since the object defines the properties described in the type annotation,
    this object can still be used as an argument to the `printDetails` function. This
    example produces the same output as *Listing 3.50*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表添加了一个新属性到分配给 `boots` 变量的对象中，但由于该对象定义了类型注解中描述的属性，因此该对象仍然可以用作 `printDetails`
    函数的参数。此示例产生的输出与 *列表 3.50* 相同。
- en: Defining optional properties in a type annotation
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在类型注解中定义可选属性
- en: A question mark can be used to denote an optional property, as shown in *Listing
    3.53*, allowing objects that don’t define the property to still conform to the
    type.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用问号来表示可选属性，如 *列表 3.53* 所示，允许不定义该属性的对象仍然符合类型。
- en: Listing 3.53 Defining an optional property in the index.ts file in the primer
    folder
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.53 在 primer 文件夹中的 index.ts 文件中定义可选属性
- en: '[PRE96]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The type annotation adds an optional `category` property, which is marked as
    optional. This means that the type of the property is `string | undefined`, and
    the function can test to see if a `category` value has been provided. This code
    produces the following output:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解添加了一个可选的 `category` 属性，该属性被标记为可选。这意味着该属性的 类型是 `string | undefined`，函数可以检查是否提供了
    `category` 值。此代码生成了以下输出：
- en: '[PRE97]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Defining classes
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: Classes are templates used to create objects, providing an alternative to the
    literal syntax. Support for classes is a recent addition to the JavaScript specification
    and is intended to make working with JavaScript more consistent with other mainstream
    programming languages. *Listing 3.54* defines a class and uses it to create objects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 类是用于创建对象的模板，提供了一种替代字面量语法的方案。类对 JavaScript 规范的支持是最近添加的，目的是使使用 JavaScript 与其他主流编程语言更加一致。*列表
    3.54* 定义了一个类，并使用它来创建对象。
- en: 'Listing 3.54: Defining a class in the index.ts file in the primer folder'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.54：在 primer 文件夹中的 index.ts 文件中定义一个类
- en: '[PRE98]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: JavaScript classes will be familiar if you have used another mainstream language
    such as Java or C#. The `class` keyword is used to declare a class, followed by
    the name of the class, which is `Product` in this example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过其他主流语言，如 Java 或 C#，那么 JavaScript 类将很熟悉。`class` 关键字用于声明一个类，后跟类的名称，在这个例子中是
    `Product`。
- en: The `constructor` function is invoked when a new object is created using the
    class, and it provides an opportunity to receive data values and do any initial
    setup that the class requires. In the example, the constructor defines `name`,
    `price`, and `category` parameters that are used to assign values to properties
    defined with the same names.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类创建新对象时，会调用 `constructor` 函数，这提供了一个接收数据值和执行类所需的任何初始设置的机会。在示例中，构造函数定义了 `name`、`price`
    和 `category` 参数，这些参数用于将值分配给具有相同名称的属性。
- en: 'The `new` keyword is used to create an object from a class, like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 关键字用于从类创建对象，如下所示：'
- en: '[PRE99]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This statement creates a new object using the `Product` class as its template.
    `Product` is used as a function in this situation, and the arguments passed to
    it will be received by the `constructor` function defined by the class. The result
    of this expression is a new object that is assigned to a variable called `hat`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句使用 `Product` 类作为模板创建了一个新对象。在这种情况下，`Product` 被用作一个函数，传递给它的参数将由类定义的 `constructor`
    函数接收。这个表达式的结果是分配给名为 `hat` 的变量的新对象。
- en: 'Notice that the objects created from the class can still be used as arguments
    to the `printDetails` function. Introducing a class has changed the way that objects
    are created, but those objects have the same combination of property names and
    types and still match the type annotation for the function parameters. The code
    in *Listing 3.54* produces the following output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从类创建的对象仍然可以用作 `printDetails` 函数的参数。引入类改变了对象创建的方式，但这些对象具有相同的属性名称和类型组合，并且仍然符合函数参数的类型注解。*列表
    3.54* 中的代码生成了以下输出：
- en: '[PRE100]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Adding methods to a class
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将方法添加到类中
- en: I can simplify the code in the example by moving the functionality defined by
    the `printDetails` function into a method defined by the `Product` class, as shown
    in *Listing 3.55*.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过将 `printDetails` 函数定义的功能移动到由 `Product` 类定义的方法中来简化示例中的代码，如 *列表 3.55* 所示。
- en: 'Listing 3.55: Defining a method in the index.ts file in the primer folder'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.55：在 primer 文件夹中的 index.ts 文件中定义一个方法
- en: '[PRE101]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Methods are invoked through the object, like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通过对象调用，如下所示：
- en: '[PRE102]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The method accesses the properties defined by the object through the `this`
    keyword:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通过 `this` 关键字访问对象定义的属性：
- en: '[PRE103]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This example produces the following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成了以下输出：
- en: '[PRE104]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Access controls and simplified constructors
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制和简化构造函数
- en: TypeScript provides support for access controls using the `public`, `private`,
    and `protected` keywords. The `public` class gives unrestricted access to the
    properties and methods defined by a class, meaning they can be accessed by any
    other part of the application. The `private` keyword restricts access to features
    so they can be accessed only within the class that defines them. The `protected`
    keyword restricts access so that features can be accessed within the class or
    a subclass.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript通过使用`public`、`private`和`protected`关键字提供对访问控制的支撑。`public`类允许对由类定义的属性和方法无限制访问，这意味着它们可以被应用程序的任何其他部分访问。`private`关键字限制了特性的访问，使得它们只能在被定义的类内部访问。`protected`关键字限制了访问，使得特性可以在类或其子类内部访问。
- en: By default, the features defined by a class are accessible by any part of the
    application, as though the `public` keyword has been applied. You won’t see the
    access control keywords applied to methods and properties in this book because
    access controls are not essential in a web application. But there is a related
    feature that I use often, which allows classes to be simplified by applying the
    access control keyword to the constructor parameters, as shown in *Listing 3.56*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，由类定义的特性可以通过应用程序的任何部分访问，就像已经应用了`public`关键字一样。在这本书中，您不会看到对方法和属性应用了访问控制关键字，因为在Web应用程序中访问控制不是必需的。但有一个我经常使用的相关特性，它允许通过将访问控制关键字应用于构造函数参数来简化类，如*清单3.56*所示。
- en: 'Listing 3.56: Simplifying the class in the index.ts file in the primer folder'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3.56*：简化primer文件夹中index.ts文件中的类'
- en: '[PRE105]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Adding one of the access control keywords to a constructor parameter has the
    effect of creating a property with the same name, type, and access level. So,
    adding the `public` keyword to the `price` parameter, for example, creates a `public`
    property named `price`, which can be assigned `number` values. The value received
    through the constructor is used to initialize the property. This is a useful feature
    that eliminates the need to copy parameter values to initialize properties. The
    code in *Listing 3.56* produces the same output as *Listing 3.53*, and only the
    way that the `name`, `price`, and `category` properties are defined has changed.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数参数中添加一个访问控制关键字的效果是创建一个具有相同名称、类型和访问级别的属性。例如，将`public`关键字添加到`price`参数，将创建一个名为`price`的`public`属性，它可以分配`number`类型的值。通过构造函数接收的值用于初始化属性。这是一个有用的特性，消除了复制参数值以初始化属性的需要。*清单3.56*中的代码产生与*清单3.53*相同的输出，只是`name`、`price`和`category`属性的定义方式发生了变化。
- en: Using class inheritance
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类继承
- en: Classes can inherit behavior from other classes using the `extends` keyword,
    as shown in *Listing 3.57*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以使用`extends`关键字从其他类继承行为，如*清单3.57*所示。
- en: 'Listing 3.57: Using class inheritance in the index.ts file in the primer folder'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3.57*：在primer文件夹中index.ts文件中使用类继承'
- en: '[PRE106]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `extends` keyword is used to declare the class that will be inherited from,
    known as the *superclass* or *base class*. In the listing, `DiscountProduct` inherits
    from `Product`. The `super` keyword is used to invoke the superclass’s constructor
    and methods. `DiscountProduct` builds on the `Product` functionality to add support
    for a price reduction, producing the following results:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`关键字用于声明将要继承的类，称为*超类*或*基类*。在清单中，`DiscountProduct`从`Product`继承。`super`关键字用于调用超类的构造函数和方法。`DiscountProduct`基于`Product`的功能添加了对价格折扣的支持，产生以下结果：'
- en: '[PRE107]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Checking object types
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象类型
- en: When applied to an object, the `typeof` function will return `object`. To determine
    whether an object has been derived from a class, the `instanceof` keyword can
    be used, as shown in *Listing 3.58*.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于一个对象时，`typeof`函数将返回`object`。为了确定一个对象是否是从一个类派生出来的，可以使用`instanceof`关键字，如*清单3.58*所示。
- en: 'Listing 3.58: Checking an object type in the index.ts file in the primer folder'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3.58*：在primer文件夹中index.ts文件中检查对象类型'
- en: '[PRE108]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `instanceof` keyword is used with an object value and a class, and the
    expression returns `true` if the object was created from the class or a superclass.
    The code in *Listing 3.58* produces the following output:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`关键字与一个对象值和一个类一起使用，如果对象是由该类或其超类创建的，表达式将返回`true`。*清单3.58*中的代码产生以下输出：'
- en: '[PRE109]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Working with JavaScript modules
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript模块
- en: JavaScript modules are used to break up an application into separate files.
    At runtime, the dependencies between modules are resolved, the files containing
    the modules are loaded, and the code they contain is executed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块用于将应用程序拆分为单独的文件。在运行时，模块之间的依赖关系被解析，包含模块的文件被加载，它们包含的代码被执行。
- en: Creating and using modules
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用模块
- en: Each TypeScript or JavaScript file that you add to a project is treated as a
    module. To demonstrate, I created a folder called `modules` in the `primer` folder,
    added to it a file called `name.ts`, and added the code shown in *Listing 3.59*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到项目中的每个 TypeScript 或 JavaScript 文件都被视为一个模块。为了演示，我在 `primer` 文件夹中创建了一个名为 `modules`
    的文件夹，并向其中添加了一个名为 `name.ts` 的文件，并在 *列表 3.59* 中展示了相应的代码。
- en: 'Listing 3.59: The contents of the name.ts file in the modules folder'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.59：模块文件夹中 name.ts 文件的内容
- en: '[PRE110]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The classes, functions, and variables defined in a JavaScript or TypeScript
    file can be accessed only within that file by default. The `export` keyword is
    used to make features accessible outside of the file so that they can be used
    by other parts of the application. In *Listing 3.59*, I have applied the `export`
    keyword to the `Name` class, which means it is available to be used outside of
    the module.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 或 TypeScript 文件中定义的类、函数和变量默认情况下只能在该文件内部访问。使用 `export` 关键字可以使功能在文件外部可用，以便其他应用程序部分可以使用它们。在
    *列表 3.59* 中，我应用了 `export` 关键字到 `Name` 类，这意味着它可以在模块外部使用。
- en: Next, add a file named `weather.ts` to the `modules` folder with the code shown
    in *Listing 3.60*. This module exports a class named `WeatherLocation`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `modules` 文件夹中添加一个名为 `weather.ts` 的文件，其内容如 *列表 3.60* 所示。此模块导出一个名为 `WeatherLocation`
    的类。
- en: 'Listing 3.60: The contents of the weather.ts file in the modules folder'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.60：模块文件夹中 weather.ts 文件的内容
- en: '[PRE111]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `import` keyword is used to declare a dependency on the features that a
    module provides. In *Listing 3.61*, I have used the `Name` and `WeatherLocation`
    classes in the `index.ts` file, which means I have to use the `import` keyword
    to declare a dependency on them and the modules they come from.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `import` 关键字来声明对模块提供的功能的依赖。在 *列表 3.61* 中，我在 `index.ts` 文件中使用了 `Name` 和 `WeatherLocation`
    类，这意味着我必须使用 `import` 关键字来声明对这些类及其来源模块的依赖。
- en: 'Listing 3.61: Importing specific types in the index.ts file in the primer folder'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.61：在 primer 文件夹中的 index.ts 文件中导入特定的类型
- en: '[PRE112]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This is the way that I use the `import` keyword in most of the examples in this
    book. The keyword is followed by curly braces that contain a comma-separated list
    of the features that the code in the current files depends on, followed by the
    `from` keyword, followed by the module name. In this case, I have imported the
    `Name` and `WeatherLocation` classes from the modules in the `modules` folder.
    Notice that the file extension is not included when specifying the module.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我在这本书的大部分示例中使用 `import` 关键字的方式。关键字后面跟着大括号，其中包含当前文件中代码所依赖的特性的逗号分隔列表，然后是 `from`
    关键字，最后是模块名称。在这种情况下，我从 `modules` 文件夹中的模块中导入了 `Name` 和 `WeatherLocation` 类。请注意，在指定模块时，不包括文件扩展名。
- en: 'When the `index.ts` file is compiled, the TypeScript compiler detects the dependency
    on the code in the `name.ts` and `weather.ts` files, so that pure JavaScript versions
    of the modules are created. During execution, Node.js detects the dependencies
    in the `index.js` file and resolves them using the `name.js` and `weather.js`
    files that the compiler creates, producing the following output:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `index.ts` 文件被编译时，TypeScript 编译器检测到对 `name.ts` 和 `weather.ts` 文件中代码的依赖，因此创建了模块的纯
    JavaScript 版本。在执行过程中，Node.js 检测到 `index.js` 文件中的依赖，并使用编译器创建的 `name.js` 和 `weather.js`
    文件来解析这些依赖，产生以下输出：
- en: '[PRE113]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Consolidating module contents
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并模块内容
- en: In later examples, especially the SportsStore application in *Part 3*, I consolidate
    the contents of module folders so that all of the important features can be imported
    in a single statement, even though they are defined in separate code files. To
    see how this works, add a file named `index.ts` to the `modules` folder, with
    the content shown in *Listing 3.62*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的示例中，特别是在 *第 3 部分* 中的 SportsStore 应用程序中，我将模块文件夹的内容合并起来，以便所有重要功能都可以在单个语句中导入，尽管它们定义在不同的代码文件中。要查看这是如何工作的，请向
    `modules` 文件夹中添加一个名为 `index.ts` 的文件，其内容如 *列表 3.62* 所示。
- en: 'Listing 3.62: The contents of the index.ts file in the modules folder'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.62：模块文件夹中 index.ts 文件的内容
- en: '[PRE114]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `index.ts` file contains `export` statements for the features defined in
    each code file. This allows these features to be imported by specifying the name
    of the containing folder, without specifying individual files, as shown in *Listing
    3.63*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.ts` 文件包含每个代码文件中定义的特性的 `export` 语句。这允许通过指定包含文件夹的名称来导入这些特性，而不需要指定单个文件，如
    *列表 3.63* 所示。'
- en: 'Listing 3.63: Importing a module folder in the index.ts file in the primer
    folder'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.63：在 primer 目录中的 `index.ts` 文件中导入模块文件夹
- en: '[PRE115]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This listing produces the same output as *Listing 3.61*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表产生的输出与 *列表 3.61* 相同。
- en: '**Understanding Module Resolution**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解模块解析**'
- en: 'You will see two different ways of specifying modules in the `import` statements
    in this book. The first is a relative module, in which the name of the module
    is prefixed with `./`, like this example from *Listing 3.60*:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中 `import` 语句中看到两种指定模块的方式。第一种是相对模块，其中模块的名称前缀为 `./`，如 *列表 3.60* 中的此示例所示：
- en: '[PRE116]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This statement specifies a module located relative to the file that contains
    the `import` statement. In this case, since no filename has been specified, it
    is the `index.ts` file in the `modules` directory that will be loaded. The other
    type of import is nonrelative. Here is an example of a nonrelative `import` you
    will see in later chapters:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句指定了一个相对于包含 `import` 语句的文件所在的模块。在这种情况下，由于没有指定文件名，所以将加载 `modules` 目录中的 `index.ts`
    文件。另一种导入类型是非相对的。以下是在后续章节中你会看到的非相对 `import` 的示例：
- en: '[PRE117]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The module in this `import` statement doesn’t start with `./`, and the dependency
    is resolved by looking for a package in the `node_modules` folder. In this case,
    the dependency is on a feature provided by the `express` package, which is introduced
    in *Chapter 5*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `import` 语句中的模块不以 `./` 开头，依赖关系通过在 `node_modules` 文件夹中查找包来解决。在这种情况下，依赖关系依赖于
    `express` 包提供的功能，该包在 *第五章* 中介绍。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I described the basic TypeScript and JavaScript features to
    provide a foundation for the chapters that follow.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了基本的 TypeScript 和 JavaScript 功能，为后续章节提供基础。
- en: JavaScript is a dynamically typed and weakly typed language, which is an uncommon
    combination in modern programming languages.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型和弱类型语言，这在现代编程语言中是不常见的组合。
- en: Values of any type can be assigned to variables, constants, and function parameters.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型的值都可以分配给变量、常量和函数参数。
- en: JavaScript will coerce (convert) values to other types to perform comparisons
    and other operations.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 会将值强制转换为其他类型以执行比较和其他操作。
- en: TypeScript is a superset of JavaScript that allows developers to clearly express
    their assumptions about data types when writing code.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的超集，允许开发者在编写代码时清晰地表达他们对数据类型的假设。
- en: TypeScript doesn’t change the JavaScript type system and TypeScript files are
    compiled into pure JavaScript.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 并不改变 JavaScript 的类型系统，TypeScript 文件被编译成纯 JavaScript。
- en: 'In the next chapter, I will describe one of the fundamental concepts that is
    critical for understanding Node.js and its role in web applications: concurrency.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述一个对于理解 Node.js 及其在 Web 应用程序中的角色至关重要的基本概念：并发。
