- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript and TypeScript Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers come to the world of web app development via many paths and are not
    always grounded in the basic technologies that web apps rely on. In this chapter,
    I introduce the basic features of JavaScript and TypeScript. This is not a comprehensive
    guide to either language, but it addresses the essentials, and it will give you
    the knowledge you need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prepare for this chapter, create a folder named `primer` in a convenient
    location. Navigate to the `primer` folder and run the command shown in *Listing
    3.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.1: Preparing the project folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 3.2* in the `primer` folder to install the
    development packages that are used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.2: Installing the development package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `nodemon` package will be used at the start of the chapter to monitor and
    execute JavaScript files. The `tsc-watc1h` package does the same thing for TypeScript
    files, and the `typescript` package contains the TypeScript compiler. The `@tsconfig/node20`
    package contains configuration settings for the TypeScript compiler for use in
    Node.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `scripts` section in the `package.json` file as shown in *Listing
    3.3*, which will make it easier to use the development packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.3: Replacing the scripts section in the package.json file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Add a file named `tsconfig.json` to the `primer` folder with the content shown
    in *Listing 3.4*, which creates a basic configuration for the TypeScript compiler
    suitable for a Node.js project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.4: The contents of the tsconfig.json file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add a file named `index.js` to the `primer` folder with the content shown in
    *Listing 3.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.5: The contents of the index.js file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 3.6* in the `primer` folder to start monitoring
    and executing JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.6: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The monitor will generate output similar to the following and will include
    the message written by the statement in *Listing 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any change to the `index.js` file will be detected by the `nodemon` package
    and will be executed by the Node.js runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript confusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is an incredible language that has been the engine of transformation
    for web application development. I love JavaScript and will extol its virtues
    to anyone foolish enough to ask; it is one of the most fluid and expressive languages
    I have used.
  prefs: []
  type: TYPE_NORMAL
- en: That said, JavaScript is a little odd and it causes confusion. At first glance,
    JavaScript looks like any other programming language, which gives programmers
    new to the language a sense of confidence. That confidence does not last, and
    it is only a matter of time until the separate searches on Stack Overflow begin.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript isn’t like other mainstream languages. To see the most confusing
    features, replace the contents of the `index.js` file with the code shown in *Listing
    3.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.7: Replacing the contents of the index.js file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the changes and the contents of the file will be executed, producing the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are two calls to a function named `sum`, and JavaScript allows different
    types to be used as the function arguments. The first call uses two number values
    (`10` and `10`). The second call uses a number value (`10`) and a string value
    (`"10"`).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is *dynamically typed*, which means that variables are not restricted
    to a specific type of value, and any type of value can be assigned to any variable,
    including function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the output produced by *Listing 3.7*, you will see that the
    function results are oddly different and have different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript is also *weakly typed*, which means that values will be implicitly
    converted so they can be used together, through a process known as *type coercion*.
    This can be a convenient feature, but it can lead to unexpected results because
    values are coerced in different ways based on the operation that is performed.
    When the `+` operator is applied to a pair of `number` values, JavaScript adds
    the two values together to produce a `number` value. If the `+` operator is applied
    to a `string` and `number` value, then JavaScript converts the `number` value
    to `string` and concatenates the values to produce a `string` result. This is
    why `"10" + 10` produces the `string` result `1010`, but `10 + 10` produces the
    number result `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JavaScript features to express type expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way that JavaScript handles data types can be confusing, especially when
    first using the language, but the behavior is consistent and predictable once
    you understand what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: A bigger issue is that it can be difficult to communicate the assumptions and
    expectations used to write JavaScript code. The `sum` function is incredibly simple,
    but with more complex functions, it can be difficult to figure out which data
    types are expected and which data types will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript provides features for checking types, which can be used to enforce
    type expectations, as shown in *Listing 3.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.8: Checking types in the index.js file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` keyword is used to check that both parameters are `number` values
    and uses the `throw` keyword to create an error if any other type is received.
    When the code is executed, the first call to the `sum` function works, but the
    second fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of type checks are effective but they are only applied when the
    JavaScript code is executed, and that means that thorough testing is required
    to ensure that the `sum` function isn’t invoked with the wrong types.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript to check type expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript doesn’t change the way that the JavaScript type system works but
    it does make it easier to express and enforce type expectations, so that type
    mismatches can be found and resolved more easily. Add a file named `index.ts`
    to the `primer` folder with the content shown in *Listing 3.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.9: The contents of the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use `Control+C` to stop the `npm` command that executes JavaScript code, and
    run the command shown in *Listing 3.10* in the `primer` folder to start the command
    that runs TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.10: Starting the TypeScript tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler processes the contents of the `index.ts` file and generates
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `sum` function parameters are decorated with *type annotations*, which tell
    the TypeScript compiler that the `sum` function expects to receive only `number`
    values. The compiler inspects the values used as arguments when the function is
    invoked and reports an error because one of the arguments is not `number`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio Code, you may see an error displayed in the editor
    window with the message *Cannot redeclare block-scoped variable*. This happens
    when the TypeScript and JavaScript files are both open for editing. If you close
    the JavaScript file, the error will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Using a type union
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a single type, such as `number`, in an annotation makes JavaScript behave
    more like other programming languages but restricts some of the flexibility of
    the dynamic JavaScript type system. JavaScript code can be written to intentionally
    support multiple types, as shown in *Listing 3.11*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.11\. Supporting multiple types in the index.ts file in the primer
    folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `sum` function checks to see whether the `second` parameter is a string
    value and, if it is, uses the built-in `Number.parseInt` function to convert it
    to a `number` value.
  prefs: []
  type: TYPE_NORMAL
- en: This has caused a mismatch between the capabilities of the function and the
    type annotations applied to the parameters, and so the compiler produces the same
    error as for *Listing 3.10*. The mismatch can be resolved using a *type union*,
    as shown in *Listing 3.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.12: Using a type union in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A bar (the `|` character) is used to combine types, so that `number | string`
    tells the compiler that the `second` parameter can be a `number` value or a `string`
    value. The TypeScript checks all uses of the `sum` function and finds that all
    of the types used as arguments match the type annotations. The code produces the
    following output when it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler is clever and uses JavaScript features like the `typeof`
    keyword to figure out how types are being used. *Listing 3.13* changes the implementation
    of the `sum` function so that `string` values are no longer treated separately
    from `number` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.13: Changing the function in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler knows that JavaScript will do different things when
    it applies the addition operator to two `number` values or `string` and `number`,
    which means that this statement produces an ambiguous result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript is designed to avoid ambiguity, and the compiler will generate the
    following error when compiling the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of TypeScript is only to highlight potential problems, not to enforce
    any particular solution to a problem. The code in *Listing 3.13* is legal JavaScript,
    but the TypeScript compiler has generated an error because there is a mismatch
    between the type annotations applied to the parameters and the way that the parameter
    values are used inside the `sum` function.
  prefs: []
  type: TYPE_NORMAL
- en: One way to resolve this problem is to return to the code in *Listing 3.12*,
    which is sensible if the `sum` function wants to process `number` and `string`
    values without type coercion. An alternative is to tell the compiler that the
    ambiguity is intentional, as shown in *Listing 3.14*, which is sensible if type
    coercion is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.14: Resolving ambiguity in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as` keyword tells the TypeScript compiler that its knowledge of the `second`
    value is incomplete and that it should treat it as a type that I specify. In this
    case, I have specified the `any` type, which has the effect of telling the TypeScript
    that ambiguity is expected and prevents it from producing an error. This code
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `as` keyword should be used with caution because the TypeScript compiler
    is sophisticated and usually has a good understanding of how data types are being
    used. Equally, using the `any` type can be dangerous because it essentially stops
    the TypeScript compiler from checking types. When you tell the TypeScript compiler
    that you know more about the code, then you need to make sure that you are right;
    otherwise, you will return to the runtime error issue that led to the introduction
    of TypeScript in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic TypeScript/JavaScript features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the relationship between TypeScript and JavaScript,
    it is time to describe the basic language features you will need to follow the
    examples in this book. This is not a comprehensive guide to either TypeScript
    or JavaScript, but it should be enough to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables and constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `let` keyword is used to define variables, and the `const` keyword is used
    to define a constant value that will not change, as shown in *Listing 3.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.15: Defining variables and constants in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler infers the type of each variable or constant from the
    value it is assigned and will generate an error if a value of a different type
    is assigned. Types can be specified explicitly, as shown in *Listing 3.16*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.16\. Specifying types in the index.ts file in the primer folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with unassigned and null values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, variables that have been defined but not assigned a value are
    assigned the special value `undefined`, whose type is `undefined`, as shown in
    *Listing 3.17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.17: Defining a variable without a value in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This behavior may seem nonsensical in isolation, but it is consistent with the
    rest of JavaScript, where values have types, and any value can be assigned to
    a variable. JavaScript also defines a separate special value, `null`, which can
    be assigned to variables to indicate no value or result, as shown in *Listing
    3.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.18: Assigning null in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I can generally provide a robust defense of the way that JavaScript features
    work, but there is an oddity of the `null` value that makes little sense, which
    can be seen in the output this code produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The oddity is that the type of the special `null` value is `object`. This JavaScript
    quirk dates back to the first version of JavaScript and hasn’t been addressed
    because so much code has been written that depends on it. Leaving aside this inconsistency,
    when the TypeScript compiler processes the code, it determines that values of
    different types are assigned to the `place` variable and infers the variable’s
    type as `any`.
  prefs: []
  type: TYPE_NORMAL
- en: The `any` type allows values of any type to be used, which effectively disables
    the TypeScript compiler’s type checks. A type union can be used to restrict the
    values that can be used, while still allowing `undefined` and `null` to be used,
    as shown in *Listing 3.19*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.19: Using a type union in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This type union allows the `place` variable to be assigned `string` values or
    `undefined` or `null`. Notice that `null` is specified by value in the type union.
    This listing produces the same output as *Listing 3.18*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JavaScript primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript defines a small set of commonly used primitive types: `string`,
    `number`, `boolean`, `undefined`, and `null`. This may seem like a short list,
    but JavaScript manages to fit a lot of flexibility into these types. (There are
    also `symbol` and `bigint` types, but these are relatively new additions to JavaScript
    and are not as widely used and not used in this book.)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `boolean` type has two values: `true` and `false`. *Listing 3.20* shows
    both values being used, but this type is most useful when used in conditional
    statements, such as an `if` statement. There is no output from this listing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.20: Defining boolean values in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Working with strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You define `string` values using either the double or single quote characters,
    as shown in *Listing 3.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.21: Defining string variables in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The quote characters you use must match. You can’t start a string with a single
    quote and finish with a double quote, for example. There is no output from this
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: Using template strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common programming task is to combine static content with data values to produce
    a string that can be presented to the user. JavaScript supports *template strings*,
    which allow data values to be specified in line with static content, as shown
    in *Listing 3.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.22: Using a template string in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Template strings begin and end with backticks (the `` ` `` character), and
    data values are denoted by curly braces preceded by a dollar sign. This string,
    for example, incorporates the value of the `place` variable and its type into
    the template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Working with numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `number` type is used to represent both *integer* and *floating-point* numbers,
    as shown in *Listing 3.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.23: Defining number values in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to specify which kind of number you are using. You just express
    the value you require, and JavaScript will act accordingly. In the listing, I
    have defined an integer value, defined a floating-point value, and prefixed a
    value with `0x` to denote a hexadecimal value. *Listing 3.23* doesn’t produce
    any output.
  prefs: []
  type: TYPE_NORMAL
- en: Working with null and undefined values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `null` and `undefined` values have no features, such as properties or methods,
    but the unusual approach taken by JavaScript means that you can only assign these
    values to variables whose type is a union that includes `null` or `undefined`,
    as shown in *Listing 3.24*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.24: Assigning null and undefined values in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler will infer the type of the `person1` variable as `string`
    because that is the type of the value assigned to it. This variable cannot be
    assigned the `null` or `undefined` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `person2` variable is defined with a type annotation that specifies `string`
    or `undefined` values. This variable can be assigned `undefined` but not `null`,
    as `null` is not part of the type union. *Listing 3.24* doesn’t produce any output.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JavaScript operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript defines a largely standard set of operators, the most useful of which
    are described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditional statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the JavaScript operators are used in conjunction with conditional statements.
    In this book, I tend to use `if/else`, but JavaScript also supports `switch` statements,
    and *Listing 3.25* shows the use of both, which will be familiar if you have worked
    with pretty much any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.25: Using the if/else and switch conditional statements in the index.ts
    file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from the listing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The equality operator vs. the identity operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript, the equality operator (`==`) will attempt to coerce (convert)
    operands to the same type to assess equality. This can be a useful feature, but
    it is widely misunderstood and often leads to unexpected results. *Listing 3.26*
    shows the equality operator in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.26: Using the equality operator in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript is converting the two operands into the same type and comparing them.
    In essence, the equality operator tests that values are the same, irrespective
    of their type.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test to ensure that the values *and* the types are the same,
    then you need to use the identity operator (`===`, three equals signs, rather
    than the two of the equality operator), as shown in *Listing 3.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.27: Using the identity operator in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the identity operator will consider the two variables to be
    different. This operator doesn’t coerce types. The result from this code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate how JavaScript works, I had to use the `any` type when declaring
    the `firstVal` and `secondVal` variables because TypeScript restricts the use
    of the equality operator so that it can be used only on two values of the same
    type. *Listing 3.28* removes the variable type annotations and allows TypeScript
    to infer the types from the assigned values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.28: Removing the type annotations in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler detects that the variable types are not the same and
    generates the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Understanding Truthy and Falsy Values**'
  prefs: []
  type: TYPE_NORMAL
- en: An important consequence of type coercion is JavaScript *truthiness*. A *truthy*
    value is one that evaluates to `true` when coerced to a Boolean value, and a *falsy*
    value is one that evaluates to `false` when coerced to a Boolean value. Every
    value is truthy except `false`, `0`, `-0`, `""` (the empty string), `null`, `undefined`,
    and `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is often used to check that a variable has been assigned a value
    and you will see many examples in later chapters, like this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a useful way to see if a value has been assigned value, especially
    when querying a database or processing data received from the user. Don’t be tempted
    to use an expression like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this expression, the type coercion is applied to the `true` value and not
    whatever value has been assigned to `customer`, which is unlikely to produce the
    expected result.
  prefs: []
  type: TYPE_NORMAL
- en: Using the null and nullish coalescing operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logical OR operator (`||`) has been traditionally used as a null coalescing
    operator in JavaScript, allowing a fallback value to be used in place of `null`
    or `undefined` values, as shown in *Listing 3.29*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.29: Using the null coalescing operator in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `||` operator returns the left-hand operand if it evaluates as truthy and
    returns the right-hand operand otherwise. When the operator is applied to `val1`,
    the right-hand operand is returned because no value has been assigned to the variable,
    meaning that it is `undefined`. When the operator is applied to `val2`, the left-hand
    operand is returned because the variable has been assigned the string `London`,
    which evaluates as truthy. This code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The problem with using the `||` operator this way is that truthy and falsy values
    can produce unexpected results, as shown in *Listing 3.30*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.30: An unexpected null coalescing result in the index.ts file in
    the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The new coalescing operation returns the fallback value, even though the `val3`
    variable is neither `null` nor `undefined`, because `0` evaluates as falsy. The
    code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The nullish coalescing operator (`??`) addresses this issue by returning the
    right-hand operand only if the left-hand operand is `null` or `undefined`, as
    shown in *Listing 3.31*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.31: Using the nullish coalescing operator in the index.ts file in
    the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The nullish operator doesn’t consider truthy and falsy outcomes and looks only
    for the `null` and `undefined` values. This code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using the optional chaining operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained earlier, TypeScript won’t allow `null` or `undefined` to be assigned
    to variables unless they have been defined with a suitable type union. Furthermore,
    TypeScript will only allow methods and properties defined by all of the types
    in the union to be used.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of features means that you have to guard against `null` or
    `undefined` values before you can use the features provided by any other type
    in a union, as demonstrated in *Listing 3.32*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.32: Guarding against null or undefined values in the index.ts file
    in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the `toFixed` method, I have to make sure that the `count` variable
    hasn’t been assigned `null` or `undefined`. The TypeScript compiler understands
    the meaning of the expressions in the `if` statement and knows that excluding
    `null` and `undefined` values means that the value assigned to `count` must be
    `number`, meaning that the `toFixed` method can be used safely. This code produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The optional chaining operator (the `?` character) simplifies the guarding process,
    as shown in *Listing 3.33*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.33: Using the optional chaining operator in the index.ts file in
    the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator is applied between the variable and the method call and will return
    `undefined` if the value is `null` or `undefined`, preventing the method from
    being invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value isn’t `null` or `undefined`, then the method call will proceed
    as normal. The result from an expression that includes the optional chaining operator
    is a type union of undefined and the result from the method. In this case, the
    union will be `string |` `undefined` because the `toFixed` method returns `string`.
    The code in *Listing 3.33* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Defining and using functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Node.js processes a JavaScript file, it executes the statements in the
    order in which they have been defined. In common with most languages, JavaScript
    allows statements to be grouped into a function, which won’t be executed until
    a statement that invokes the function is executed, as shown in *Listing 3.34*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.34: Defining a function in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions are defined with the `function` keyword and are given a name. If
    a function defines parameters, then TypeScript requires type annotations, which
    are used to enforce consistency in the use of the function. The function in *Listing
    3.34* is named `writeValue`, and it defines a parameter that will accept `string`
    or `null` values. The statement inside of the function isn’t executed until the
    function is executed. The code in *Listing 3.34* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Defining optional function parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, TypeScript will allow functions to be invoked only when the number
    of arguments matches the number of parameters the function defines. This may seem
    obvious if you are used to other mainstream languages, but a function can be called
    with any number of arguments in JavaScript, regardless of how many parameters
    have been defined. The `?` character is used to denote an optional parameter,
    as shown in *Listing 3.35*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.35: Defining an optional parameter in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `?` operator has been applied to the `val` parameter, which means that the
    function can be invoked with zero or one argument. Within the function, the parameter
    type is `string | undefined`, because the value will be undefined if the function
    is invoked without an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t confuse `val?: string`, which is an optional parameter, with `val: string
    | undefined`, which is a type union of `string` and `undefined`. The type union
    requires the function to be invoked with an argument, which may be the value `undefined`,
    whereas the optional parameter allows the function to be invoked without an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in *Listing 3.35* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Defining default parameter values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameters can be defined with a default value, which will be used when the
    function is invoked without a corresponding argument. This can be a useful way
    to avoid dealing with `undefined` values, as shown in *Listing 3.36*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.36: Defining a default parameter value in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value will be used when the function is invoked without an argument.
    This means that the type of the parameter in the example will always be `string`,
    so I don’t have to check for `undefined` values. The code in *Listing 3.36* produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Defining rest parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rest parameters* are used to capture any additional arguments when a function
    is invoked with additional arguments, as shown in *Listing 3.37*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.37: Using a rest parameter in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest parameter must be the last parameter defined by the function, and
    its name is prefixed with an ellipsis (three periods, `...`). The rest parameter
    is an array to which any extra arguments will be assigned. In the listing, the
    function prints out each extra argument to the console, producing the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Defining functions that return results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can return results from functions by declaring the return data type and
    using the `return` keyword within the function body, as shown in *Listing 3.38*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.38: Returning a result in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The new function defines one parameter, which is `string`, and returns a result,
    which is also a `string`. The type of the result is defined using a type annotation
    after the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript will check the use of the `return` keyword to ensure that the function
    returns a result and that the result is of the expected type. This code produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Using functions as arguments to other functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript functions are values, which means you can use one function as the
    argument to another, as demonstrated in *Listing 3.39*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.39: Using a function as an argument to another function in the index.ts
    file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeCity` function defines a parameter called `f`, which is a function
    that it invokes to get the value to insert into the string that it writes out.
    TypeScript requires the function parameter to be described so that the types of
    its parameters and results are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the *arrow syntax*, also known as *fat arrow syntax* or *lambda expression
    syntax*. There are three parts to an arrow function: the input parameters surrounded
    by parentheses, then an equal sign and a greater-than sign (the “arrow”), and
    finally, the function result. The parameter function doesn’t define any parameters,
    so the parentheses are empty. This means that the type of parameter `f` is a function
    that accepts no parameters and returns a `string` result. The parameter function
    is invoked within a template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Only functions with the specified combination of parameters and result can
    be used as an argument to `writeCity`. The `getUKCapital` function has the correct
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that only the name of the function is used as the argument. If you follow
    the function name with parentheses, `writeCity(getUKCapital())`, then you are
    telling JavaScript to invoke the `getUKCapital` function and pass the result to
    the `writeCity` function. TypeScript will detect that the result from the `getUKCapital`
    function doesn’t match the parameter type defined by the `writeCity` function
    and will produce an error when the code is compiled. The code in *Listing 3.39*
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Defining functions using the arrow syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arrow syntax can also be used to define functions, which is a useful way
    to define functions inline, as shown in *Listing 3.40*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.40: Defining an arrow function in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This inline function receives no parameters and returns the literal string
    value `Paris`, defining a function that can be used as an argument to the `writeCity`
    function. The code in *Listing 3.40* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Understanding value closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can access values that are defined in the surrounding code, using
    a feature called *closure*, as demonstrated in *Listing 3.41*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.41: Using a closure in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The new arrow function returns the value of the variable named `myCity`, which
    is defined in the surrounding code. This is a powerful feature that means you
    don’t have to define parameters on functions to pass around data values, but caution
    is required because it is easy to get unexpected results when using common variable
    names like `counter` or `index`, where you may not realize that you are reusing
    a variable name from the surrounding code. This example produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript arrays work like arrays in most other programming languages. *Listing
    3.42* demonstrates how to create and populate an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.42: Creating and populating an array in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: I have created a new and empty array using the literal syntax, which uses square
    brackets, and assigned the array to a variable named `myArray`. In the subsequent
    statements, I assign values to various index positions in the array. (There is
    no output from this listing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to note in this example. First, I didn’t need
    to declare the number of items in the array when I created it. JavaScript arrays
    will resize themselves to hold any number of items. The second point is that I
    didn’t have to declare the data types that the array would hold. Any JavaScript
    array can hold any mix of data types. In the example, I have assigned three items
    to the array: `number`, `string`, and `boolean`. The TypeScript compiler infers
    the type of the array as `any[]`, denoting an array that can hold values of all
    types. The example can be written with the type annotation shown in *Listing 3.43*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.43: Using a type annotation in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Arrays can be restricted to values with specific types, as shown in *Listing
    3.44*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.44: Restricting array value types in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The type union restricts the array so that it can hold only `number`, `string`,
    and `boolean` values. Notice that I have put the type union in parentheses because
    the union `number | string | boolean[]` denotes a value that can be assigned `number`,
    a `string`, or an array of `boolean` values, which is not what is intended.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be defined and populated in a single statement, as shown in *Listing
    3.45*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.45: Populating a new array in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If you omit the type annotation, TypeScript will infer the array type from the
    values used to populate the array. You should rely on this feature with caution
    for arrays that are intended to hold multiple types because it requires that the
    full range of types is used when creating the array.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and modifying the contents of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You read the value at a given index using square braces (`[` and `]`), placing
    the index you require between the braces, as shown in *Listing 3.46*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.46: Reading the data from an array index in the index.ts file in
    the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler infers the type of values in the array so that the
    type of the `val` variable in *Listing 3.46* is `number | string | boolean`. This
    code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You can modify the data held in any position in a JavaScript array simply by
    assigning a new value to the index, as shown in *Listing 3.47*. The TypeScript
    compiler will check that the type of the value you assign matches the array element
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.47: Modifying the contents of an array in the index.ts file in the
    primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I have assigned a `string` to position `0` in the array, a
    position that was previously held by a `number`. This code produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating the contents of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You enumerate the content of an array using a `for` loop or the `forEach` method,
    which receives a function that is called to process each element in the array.
    *Listing 3.48* shows both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.48: Enumerating the contents of an array in the index.ts file in
    the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript `for` loop works just the same way as loops in many other languages.
    You determine how many elements there are in the array using its `length` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function passed to the `forEach` method is given two arguments: the value
    of the current item to be processed and the position of that item in the array.
    In this listing, I have used an arrow function as the argument to the `forEach`
    method, which is the kind of use for which they excel (and you will see used throughout
    this book). The output from the listing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Using the spread operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator is used to expand an array so that its contents can be used
    as function arguments or combined with other arrays. In *Listing 3.49*, I used
    the spread operator to expand an array so that its items can be combined into
    another array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.49: Using the spread operator in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The spread operator is an ellipsis (a sequence of three periods), and it causes
    the array to be unpacked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the spread operator, I can specify `myArray` as an item when I define
    `otherArray`, with the result that the contents of the first array will be unpacked
    and added as items to the second array. This example produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Working with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript objects are a collection of properties, each of which has a name
    and value. The simplest way to create an object is to use the literal syntax,
    as shown in *Listing 3.50*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.50: Creating an object in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The literal syntax uses braces to contain a list of property names and values.
    Names are separated from their values with colons and from other properties with
    commas. Two objects are defined in *Listing 3.50* and assigned to variables named
    `hat` and `boots`. The properties defined by the object can be accessed through
    the variable name, as shown in this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in *Listing 3.50* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Understanding literal object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the TypeScript compiler encounters a literal object, it infers its type,
    using the combination of property names and the values to which they are assigned.
    This combination can be used in type annotations, allowing the shape of objects
    to be described as, for example, function parameters, as shown in *Listing 3.51*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.51: Describing an object type in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The type annotation specifies that the `product` parameter can accept objects
    that define a `string` property called `name`, and a `number` property named `price`.
    This example produces the same output as *Listing 3.50*.
  prefs: []
  type: TYPE_NORMAL
- en: A type annotation that describes a combination of property names and types just
    sets out a minimum threshold for objects, which can define additional properties
    and can still conform to the type, as shown in *Listing 3.52*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.52\. Adding a property in the index.ts file in the primer folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The listing adds a new property to the objects assigned to the `boots` variable,
    but since the object defines the properties described in the type annotation,
    this object can still be used as an argument to the `printDetails` function. This
    example produces the same output as *Listing 3.50*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining optional properties in a type annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A question mark can be used to denote an optional property, as shown in *Listing
    3.53*, allowing objects that don’t define the property to still conform to the
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.53 Defining an optional property in the index.ts file in the primer
    folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The type annotation adds an optional `category` property, which is marked as
    optional. This means that the type of the property is `string | undefined`, and
    the function can test to see if a `category` value has been provided. This code
    produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Defining classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes are templates used to create objects, providing an alternative to the
    literal syntax. Support for classes is a recent addition to the JavaScript specification
    and is intended to make working with JavaScript more consistent with other mainstream
    programming languages. *Listing 3.54* defines a class and uses it to create objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.54: Defining a class in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript classes will be familiar if you have used another mainstream language
    such as Java or C#. The `class` keyword is used to declare a class, followed by
    the name of the class, which is `Product` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` function is invoked when a new object is created using the
    class, and it provides an opportunity to receive data values and do any initial
    setup that the class requires. In the example, the constructor defines `name`,
    `price`, and `category` parameters that are used to assign values to properties
    defined with the same names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new` keyword is used to create an object from a class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This statement creates a new object using the `Product` class as its template.
    `Product` is used as a function in this situation, and the arguments passed to
    it will be received by the `constructor` function defined by the class. The result
    of this expression is a new object that is assigned to a variable called `hat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the objects created from the class can still be used as arguments
    to the `printDetails` function. Introducing a class has changed the way that objects
    are created, but those objects have the same combination of property names and
    types and still match the type annotation for the function parameters. The code
    in *Listing 3.54* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Adding methods to a class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can simplify the code in the example by moving the functionality defined by
    the `printDetails` function into a method defined by the `Product` class, as shown
    in *Listing 3.55*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.55: Defining a method in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods are invoked through the object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The method accesses the properties defined by the object through the `this`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Access controls and simplified constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript provides support for access controls using the `public`, `private`,
    and `protected` keywords. The `public` class gives unrestricted access to the
    properties and methods defined by a class, meaning they can be accessed by any
    other part of the application. The `private` keyword restricts access to features
    so they can be accessed only within the class that defines them. The `protected`
    keyword restricts access so that features can be accessed within the class or
    a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the features defined by a class are accessible by any part of the
    application, as though the `public` keyword has been applied. You won’t see the
    access control keywords applied to methods and properties in this book because
    access controls are not essential in a web application. But there is a related
    feature that I use often, which allows classes to be simplified by applying the
    access control keyword to the constructor parameters, as shown in *Listing 3.56*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.56: Simplifying the class in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Adding one of the access control keywords to a constructor parameter has the
    effect of creating a property with the same name, type, and access level. So,
    adding the `public` keyword to the `price` parameter, for example, creates a `public`
    property named `price`, which can be assigned `number` values. The value received
    through the constructor is used to initialize the property. This is a useful feature
    that eliminates the need to copy parameter values to initialize properties. The
    code in *Listing 3.56* produces the same output as *Listing 3.53*, and only the
    way that the `name`, `price`, and `category` properties are defined has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Using class inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes can inherit behavior from other classes using the `extends` keyword,
    as shown in *Listing 3.57*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.57: Using class inheritance in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extends` keyword is used to declare the class that will be inherited from,
    known as the *superclass* or *base class*. In the listing, `DiscountProduct` inherits
    from `Product`. The `super` keyword is used to invoke the superclass’s constructor
    and methods. `DiscountProduct` builds on the `Product` functionality to add support
    for a price reduction, producing the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Checking object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When applied to an object, the `typeof` function will return `object`. To determine
    whether an object has been derived from a class, the `instanceof` keyword can
    be used, as shown in *Listing 3.58*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.58: Checking an object type in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instanceof` keyword is used with an object value and a class, and the
    expression returns `true` if the object was created from the class or a superclass.
    The code in *Listing 3.58* produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Working with JavaScript modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript modules are used to break up an application into separate files.
    At runtime, the dependencies between modules are resolved, the files containing
    the modules are loaded, and the code they contain is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each TypeScript or JavaScript file that you add to a project is treated as a
    module. To demonstrate, I created a folder called `modules` in the `primer` folder,
    added to it a file called `name.ts`, and added the code shown in *Listing 3.59*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.59: The contents of the name.ts file in the modules folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The classes, functions, and variables defined in a JavaScript or TypeScript
    file can be accessed only within that file by default. The `export` keyword is
    used to make features accessible outside of the file so that they can be used
    by other parts of the application. In *Listing 3.59*, I have applied the `export`
    keyword to the `Name` class, which means it is available to be used outside of
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a file named `weather.ts` to the `modules` folder with the code shown
    in *Listing 3.60*. This module exports a class named `WeatherLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.60: The contents of the weather.ts file in the modules folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `import` keyword is used to declare a dependency on the features that a
    module provides. In *Listing 3.61*, I have used the `Name` and `WeatherLocation`
    classes in the `index.ts` file, which means I have to use the `import` keyword
    to declare a dependency on them and the modules they come from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.61: Importing specific types in the index.ts file in the primer folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This is the way that I use the `import` keyword in most of the examples in this
    book. The keyword is followed by curly braces that contain a comma-separated list
    of the features that the code in the current files depends on, followed by the
    `from` keyword, followed by the module name. In this case, I have imported the
    `Name` and `WeatherLocation` classes from the modules in the `modules` folder.
    Notice that the file extension is not included when specifying the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `index.ts` file is compiled, the TypeScript compiler detects the dependency
    on the code in the `name.ts` and `weather.ts` files, so that pure JavaScript versions
    of the modules are created. During execution, Node.js detects the dependencies
    in the `index.js` file and resolves them using the `name.js` and `weather.js`
    files that the compiler creates, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Consolidating module contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In later examples, especially the SportsStore application in *Part 3*, I consolidate
    the contents of module folders so that all of the important features can be imported
    in a single statement, even though they are defined in separate code files. To
    see how this works, add a file named `index.ts` to the `modules` folder, with
    the content shown in *Listing 3.62*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.62: The contents of the index.ts file in the modules folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The `index.ts` file contains `export` statements for the features defined in
    each code file. This allows these features to be imported by specifying the name
    of the containing folder, without specifying individual files, as shown in *Listing
    3.63*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 3.63: Importing a module folder in the index.ts file in the primer
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This listing produces the same output as *Listing 3.61*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding Module Resolution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see two different ways of specifying modules in the `import` statements
    in this book. The first is a relative module, in which the name of the module
    is prefixed with `./`, like this example from *Listing 3.60*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement specifies a module located relative to the file that contains
    the `import` statement. In this case, since no filename has been specified, it
    is the `index.ts` file in the `modules` directory that will be loaded. The other
    type of import is nonrelative. Here is an example of a nonrelative `import` you
    will see in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The module in this `import` statement doesn’t start with `./`, and the dependency
    is resolved by looking for a package in the `node_modules` folder. In this case,
    the dependency is on a feature provided by the `express` package, which is introduced
    in *Chapter 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I described the basic TypeScript and JavaScript features to
    provide a foundation for the chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed and weakly typed language, which is an uncommon
    combination in modern programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of any type can be assigned to variables, constants, and function parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript will coerce (convert) values to other types to perform comparisons
    and other operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript that allows developers to clearly express
    their assumptions about data types when writing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript doesn’t change the JavaScript type system and TypeScript files are
    compiled into pure JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next chapter, I will describe one of the fundamental concepts that is
    critical for understanding Node.js and its role in web applications: concurrency.'
  prefs: []
  type: TYPE_NORMAL
