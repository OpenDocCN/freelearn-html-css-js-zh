<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Real-World Functional Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the preceding chapter of this book, we have learned about functional programming and functional reactive programming. <span>We</span> tried to avoid using external libraries, because o<span>ur main goal was to understand </span><span>the techniques, patterns, and principles of the functional programming and functional-reactive programming paradigms.</span></p>
<p class="mce-root"><span>In this chapter, w</span>e are going to learn about the following topics:</p>
<ul>
<li>Composing with Ramda</li>
<li>Currying and partial application with Ramda</li>
<li>Lenses with Ramda</li>
<li>Working with Immutable.js</li>
<li>Working with Immer</li>
<li>Working with Funfix</li>
</ul>
<p><span>We are going to revisit once more some of the main concepts that we have explored throughout this book. However, this time, our focus will not be to understand these concepts (it is assumed that we already do). Instead, we are going to focus on the usage of some production-ready functional programming libraries, such as Ramda or Immutable.js.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Ramda</h1>
                </header>
            
            <article>
                
<p>Ramda is an open source functional programming library that which includes many utility functions that can help us to put some of the main functional programming techniques into practice. Ramda can be compared to other libraries, such as Lodash or Underscore. However, the Ramda API is much more influenced by the functional programming principle than these other libraries. For example, Ramda has been designed in a way that makes composability and immutability two of the main characteristics of its components.</p>
<p>We can install Ramda using the following <strong>npm</strong> command:</p>
<pre><strong>npm install ramda @types/ramda</strong></pre>
<p>In the following sections, we are going to learn how to use Ramda to implement function compositions and lenses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composition</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we declared a higher-order function named <kbd>compose</kbd>, which allows us to compose two functions:</p>
<pre>const compose = &lt;T&gt;(f: (x: T) =&gt; T, g: (x: T) =&gt; T) =&gt; (x: T) =&gt; f(g(x));</pre>
<p>The <kbd>compose</kbd> function allowed us to demonstrate how function composition works, but it had some limitations. For example, the compose function only takes one generic type, parameter <kbd>T</kbd>, which means that we can only compose two unary functions, <kbd>f</kbd> and <kbd>g</kbd>, that take one argument of type <kbd>T</kbd>:</p>
<pre>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const trimAndCapitalize = compose(trim, capitalize);<br/>const result = trimAndCapitalize(" hello world ");<br/>console.log(result); // "HELLO WORLD"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In a real-world application, we may need to compose two functions <kbd>f</kbd> and <kbd>g</kbd> that take an argument of two different types <kbd>T1</kbd> and <kbd>T2</kbd>. The following code snippet uses the <kbd>compose</kbd> function from Ramda instead of the one that we declared <span>previously</span>:</p>
<pre>import R from "ramda";<br/><br/>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const trimAndCapitalize = R.compose(trim, capitalize);<br/>const result = trimAndCapitalize(" hello world ");<br/>console.log(result); // "HELLO WORLD"</pre>
<p>The <kbd>compose</kbd> function from Ramda is a much better alternative for real-world applications because it has been used in hundreds of projects and tested with thousands of functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Partial application and currying</h1>
                </header>
            
            <article>
                
<p>We have also learned that the functional composition only works with unary functions and that if we wish to compose functions, that are not unary, such as binary functions we can use function partial application to invoke one of the function with only some of its arguments and generate new functions that take the remaining arguments. Finally, we also learned that we can use currying to transform a given function into a function that can be partially applied:</p>
<pre>function curry3&lt;T1, T2, T3, T4&gt;(fn: (a: T1, b: T2, c: T3) =&gt; T4) {<br/>    return (a: T1) =&gt; (b: T2) =&gt; (c: T3) =&gt; fn(a, b, c);<br/>}<br/><br/>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const trimAndCapitalize = R.compose(trim, capitalize);<br/>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);<br/><br/>const curriedReplace = curry3(replace);<br/><br/>const trimCapitalizeAndReplace = compose(<br/>    trimAndCapitalize,<br/>    curriedReplace("/")("-")<br/>);<br/><br/>const result = trimCapitalizeAndReplace(" 13/feb/1989 ");<br/>console.log(result); // "13-FEB-1989"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code snippet uses the <kbd>curry3</kbd> function to transform a ternary function into a function that can be partially applied. Again, in a real-world application, it is not recommended to create a custom implementation, and we should try to use a battle-tested library instead. Fortunately, we are not going to need to search around for very long because Ramda includes a function named <kbd>curry</kbd> that can be used to achieve just what we want: </p>
<pre>import R from "ramda";<br/><br/>const trim = (s: string) =&gt; s.trim();<br/>const capitalize = (s: string) =&gt; s.toUpperCase();<br/>const replace = (s: string, f: string, r: string) =&gt; s.split(f).join(r);<br/><br/>const trimCapitalizeAndReplace = R.compose(<br/> R.compose(trim, capitalize),<br/> R.curry(replace)("/")("-")<br/>);<br/><br/>const result = trimCapitalizeAndReplace(" 13/feb/1989 ");<br/>console.log(result); // "13-FEB-1989"</pre>
<p>The preceding code snippet declares three functions in a way that is completely agnostic of Ramda. We then use the Ramda utility functions, <kbd>compose</kbd> and <kbd>curry</kbd>, to generate a new function named <kbd>trimCapitalizeAndReplace</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lenses</h1>
                </header>
            
            <article>
                
<p>We learned about lenses in some of the previous chapters. In one of the last examples, we implemented lenses in a way that is very close to the implementation provided by Ramda.</p>
<p>We implemented a higher-order function named <kbd>lens</kbd> that can be used to create a <kbd>Lens</kbd> implementation. The <kbd>lens</kbd> function takes two functions that must implement the <kbd>Prop</kbd> and <kbd>Assoc</kbd> interfaces:</p>
<pre>interface Lens&lt;T1, T2&gt; {<br/>    get(o: T1): T2;<br/>    set(o: T2, v: T1): T1;<br/>}<br/><br/>type Prop&lt;T, K extends keyof T&gt; = (o: T) =&gt; T[K];<br/>type Assoc&lt;T, K extends keyof T&gt; = (v: T[K], o: T) =&gt; T;<br/><br/>const lens = &lt;T1, K extends keyof T1&gt;(<br/>    getter: Prop&lt;T1, K&gt;,<br/>    setter: Assoc&lt;T1, K&gt;,<br/>): Lens&lt;T1, T1[K]&gt; =&gt; {<br/>    return {<br/>        get: (obj: T1) =&gt; getter(obj),<br/>        set: (val: T1[K], obj: T1) =&gt; setter(val, obj),<br/>    };<br/>}<br/><br/>const view = &lt;T1, T2&gt;(lens: Lens&lt;T1, T2&gt;, obj: T1) =&gt; lens.get(obj);<br/><br/>const set = &lt;T1, K extends keyof T1&gt;(<br/>    lens: Lens&lt;T1, T1[K]&gt;,<br/>    val: T1[K],<br/>    obj: T1<br/>) =&gt; lens.set(val, obj);</pre>
<p class="mce-root">We can then create a <kbd>Lens</kbd> implementation passing the <kbd>Assoc</kbd> and <kbd>Prop</kbd> implementations to the <kbd>Lens</kbd> function:</p>
<pre>class Street {<br/><br/>    public readonly num: number;<br/>    public readonly name: string;<br/><br/>    public constructor(num: number, name: string) {<br/>        this.num = num;<br/>        this.name = name;<br/>    }<br/><br/>}<br/><br/>class Address {<br/><br/>    public readonly city: string;<br/>    public readonly street: Street;<br/><br/>    public constructor(city: string, street: Street) {<br/>        this.city = city;<br/>        this.street = street;<br/>    }<br/><br/>}<br/><br/>const propStreet: Prop&lt;Address, "street"&gt; = (o: Address) =&gt; o.street;<br/><br/>const assocStreet: Assoc&lt;Address, "street"&gt; = (v: Address["street"], o: Address) =&gt; {<br/>    return new Address(o.city, v);<br/>};<br/><br/>const streetLens = lens(propStreet, assocStreet);</pre>
<p><span>Once we have a <kbd>Lens</kbd> instance, we can use the </span><kbd>set</kbd><span> and </span><kbd>view</kbd><span> functions to <kbd>read</kbd> and <kbd>set</kbd> the value of a property in an immutable object:</span></p>
<pre><br/><br/>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const street = view(streetLens, address);<br/><br/>const address2 = set(<br/>    streetLens,<br/>    new Street(<br/>        address.street.num,<br/>        R.toUpper(address.street.name)<br/>    ),<br/>    address<br/>);</pre>
<p>Now that we know the basics about Ramda, we can implement the preceding code snippet once more using some of its utility functions. Ramda includes the following utility functions, among others:</p>
<ul>
<li>The <kbd>prop</kbd> <span>function allows us to declare a property getter. It expects the name of a property as an argument.</span></li>
<li>The <kbd>assoc</kbd> <span>function allows us to declare a property setter. It expects the name of a property as an argument.</span></li>
<li>The <kbd>lens</kbd> <span>function allows us to declare a lens instance. It expects a property getter (<kbd>prop</kbd>) and setter (<kbd>assoc</kbd>) as arguments.</span></li>
<li>The <kbd>lensProp</kbd> function allows us to declare a lens instance. It expects the name of a property as an argument.</li>
<li>The <kbd>view</kbd> <span>function allows us to get the value of a property in an object. It expects a lens instance and an object as arguments.</span></li>
<li>The <kbd>set</kbd> function <span>allows us to set the value of a property in an object. It expects a lens instance, a new value, and an object as arguments.</span></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the following code snippet, we use the <kbd>lensProp</kbd>, <kbd>view</kbd>, and <kbd>set</kbd> functions: </p>
<pre>import R from "ramda";<br/><br/>class Street {<br/><br/>    public readonly num: number;<br/>    public readonly name: string;<br/><br/>    public constructor(num: number, name: string) {<br/>        this.num = num;<br/>        this.name = name;<br/>    }<br/><br/>}<br/><br/>class Address {<br/><br/>    public readonly city: string;<br/>    public readonly street: Street;<br/><br/>    public constructor(city: string, street: Street) {<br/>        this.city = city;<br/>        this.street = street;<br/>    }<br/><br/>}<br/><br/>const streetLens = R.lensProp("street");<br/><br/>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);<br/><br/>const street = R.view&lt;Address, Street&gt;(streetLens, address);<br/><br/>const address2 = R.set&lt;Address, Street&gt;(<br/>    streetLens,<br/>    new Street(<br/>        address.street.num,<br/>        R.toUpper(address.street.name)<br/>    ),<br/>    address<br/>);</pre>
<p>Use of the <kbd>prop</kbd> and <kbd>assoc</kbd> functions are not required in most cases thanks to the <kbd>lensProp</kbd> instead of the <kbd>lens</kbd> function.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Immutable.js</h1>
                </header>
            
            <article>
                
<p>In the preceding chapters, we also learned about immutability and the benefits of using immutable data objects. We learned that we can use the <kbd>readonly</kbd> keyword to declare immutable objects:</p>
<pre>class Street {<br/><br/>    public readonly num: number;<br/>    public readonly name: string;<br/><br/>    public constructor(num: number, name: string) {<br/>        this.num = num;<br/>        this.name = name;<br/>    }<br/><br/>}<br/><br/>class Address {<br/><br/>    public readonly city: string;<br/>    public readonly street: Street;<br/><br/>    public constructor(city: string, street: Street) {<br/>        this.city = city;<br/>        this.street = street;<br/>    }<br/><br/>}</pre>
<p>We also learned that working with immutable objects can sometimes be very verbose and tedious and that lenses can help us to overcome these difficulties. We are now going to learn about a library that can help us to declare immutable objects. The library is known as <strong>Immutable.js</strong>, and it also includes an API similar tot he lenses API. We can install Immutable.js using the following command:</p>
<pre><strong>npm install immutable</strong></pre>
<p>We can define type-safe immutable classes with Immutable.js, using the <kbd>Record</kbd> type as follows:</p>
<pre>import { Record } from "immutable";<br/><br/>interface StreetInterface {<br/>    num: number;<br/>    name: string;<br/>}<br/><br/>const StreetRecord = Record({<br/>    num: 0,<br/>    name: ""<br/>});<br/><br/>class Street extends StreetRecord implements StreetInterface {<br/>    constructor(props: StreetInterface) {<br/>        super(props);<br/>    }<br/>}</pre>
<p>We are going to define one more immutable class named <kbd>Address</kbd>. The <kbd>Address</kbd> class contains an instance of the <kbd>Street</kbd> class:</p>
<pre>interface AddressInterface {<br/>    city: string;<br/>    street: Street;<br/>}<br/><br/>const AddressRecord = Record({<br/>    city: "",<br/>    street: new Street({<br/>        num: 0,<br/>        name: ""<br/>    })<br/>});<br/><br/>class Address extends AddressRecord implements AddressInterface {<br/>    constructor(props: AddressInterface) {<br/>        super(props);<br/>    }<br/>}</pre>
<p>To create an instance of an immutable class, we need to pass all the required properties as a plain object:</p>
<pre>const address = new Address({<br/>    city: "Lonson",<br/>    street: new Street({<br/>        num: 1,<br/>        name: "rathbone square"<br/>    })<br/>});</pre>
<p class="mce-root"/>
<p>When we declare an immutable class with Immutable.js, the class inherits some methods that behave like a lens. We can use the <kbd>get</kbd> method to get the value of a property and the <kbd>set</kbd> method to create a new immutable instance using an updated value:</p>
<pre>const street = address.get("street");<br/>const street2 = street.set("name", "Rathbone square");<br/>const address2 = address.set("street", street2);<br/><br/>console.log(<br/>    address.toJS(),<br/>    address2.toJS()<br/>);</pre>
<p>Declaring an immutable class with Immutable.js is more tedious than declaring them with the <kbd>readonly</kbd> access modifier, but we get lenses as a built-in feature in exchange for our effort.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Immer</h1>
                </header>
            
            <article>
                
<p>We are going to take a look at another popular immutability library. The library is known as <strong>Immer</strong>, and it can be installed using the following <kbd>npm</kbd> command:</p>
<pre><strong>npm install immer</strong></pre>
<p>Immer allows us to define immutable classes using the <kbd>readonly</kbd> access modifier. This means that we can also create instances of our classes using a standard class constructor:</p>
<pre>import produce from "immer";<br/><br/>class Street {<br/><br/>    public readonly num: number;<br/>    public readonly name: string;<br/><br/>    public constructor(num: number, name: string) {<br/>        this.num = num;<br/>        this.name = name;<br/>    }<br/><br/>}<br/><br/>class Address {<br/><br/>    public readonly city: string;<br/>    public readonly street: Street;<br/><br/>    public constructor(city: string, street: Street) {<br/>        this.city = city;<br/>        this.street = street;<br/>    }<br/><br/>}<br/><br/>const address = new Address(<br/>    "London",<br/>    new Street(1, "rathbone square")<br/>);</pre>
<p>Immer can generate a new version of an immutable object using a method named <kbd>produce</kbd>. The <kbd>produce</kbd> function takes the current version of an immutable object as its first argument. The second argument is a callback function that takes one argument known as the draft state. The draft state is a mutable version of the initial version and, within the callback function, we can mutate it as much as we want:</p>
<pre>const address2 = produce(address, draftAddress =&gt; {<br/>    draftAddress.street.name = "Rathbone square";<br/>});</pre>
<p>The <kbd>produce</kbd> function returns a new immutable object without mutating the original object. The Immer API can be considered superior to the Immutable.js API, because it imposes fewer constraints in our class declarations and constructors. Immer is not based on lenses and allows us to work with immutable objects using an innovative approach that utilizes proxies internally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Funfix</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Funfix</strong> is a collection of functional programming utility functions. Funfix can be compared with Ramda. Just like Ramda, Funfix can be used to compose functions or partially apply functions. However, in this section, we are going to focus on the usage of some of the Funfix features that are related to some of the data types that we previously explored in Chapter 7, <em>Category Theory</em>.</p>
<p class="mce-root">We are going to start by installing Funfix:</p>
<pre><strong>npm install funfix @types/funfix</strong></pre>
<p>The examples that we are going to implement in this section are going to require a couple of additional <kbd>npm</kbd> modules. We are going to use <kbd>node-fetch</kbd> to send HTTP requests from a Node.js application. We are also going to use some of the Node.js core modules, which means that we are going to need the type definitions for Node.js as well:</p>
<pre><strong>npm install node-fetch @type/node-fetch @types/node</strong></pre>
<p>In our first Funfix example, we are going to define a monad named <kbd>argsIO</kbd> using the <kbd>IO.of</kbd> factory method. As we learned in the previous chapters, a monad is a functor, and a functor is a container. In this case, the container contains a function that performs an I/O operation: reading the command-line arguments (<kbd>process.argv</kbd>). <span>The </span><kbd>IO</kbd><span> type is used to store a function that describes some computation with side effects, such as reading some data from a file or mutating the elements in the <strong>Document Object Model</strong> (<strong>DOM</strong>). Describing actions in this way allows for <kbd>IO</kbd> instances to be composed and passed around, while keeping functions pure and maintaining referential transparency. </span></p>
<p>We are also going to declare two functions named <kbd>readFile</kbd> and <kbd>stdoutWrite</kbd>. Both of these functions return a monad instance, and both monads contain I/O operations. The first one reads a file from the filesystem, and the second one prints some information in the standard output:</p>
<pre>import * as R from "ramda";<br/>import * as fs from "fs";<br/>import { IO } from "funfix";<br/><br/>const argsIO = IO.of(() =&gt; R.tail(R.tail(process.argv))[0]);<br/>const readFile = (filename: string) =&gt; IO.of(() =&gt; fs.readFileSync(filename, "utf8"));<br/>const stdoutWrite = (data: string) =&gt; IO.of(() =&gt; process.stdout.write(data));<br/><br/>const loudCat = argsIO.chain(readFile)<br/>     .map(R.toUpper)<br/>     .chain(stdoutWrite);<br/><br/>try {<br/>   loudCat.run();<br/>} catch(e) {<br/>   console.log(e);<br/>}</pre>
<p>The preceding code snippet also declares a monad named <kbd>loudCat</kbd> using the <kbd>chain</kbd> method to pass the command line arguments to the file reading operation and the <kbd>map</kbd> method to transform the file contents into upper case. Finally, it uses the <kbd>chain</kbd> method one last time to pass the uppercase text to the standard output.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One of the main characteristics of monads in Funfix is that they are lazily evaluated, and all of the preceding operations don't take place until we invoke the <kbd>run</kbd> method. If everything goes well, we can pass the name of a file using the command-line interface:</p>
<pre><strong>node example.js test.txt</strong> </pre>
<p>The uppercase contents of the file should be displayed on the standard output. The following example uses the <kbd>node-fetch</kbd> module to send an HTTP request. The function that performs the HTTP request is contained by a monad. This time, the monad is not created by the <kbd>IO.of</kbd> factory function because it is created with the <kbd>IO.async</kbd> factory function instead. We use <span>the </span><kbd>IO.async</kbd><span> factory function because it is required by Funfix when an asynchronous operation is wrapped by a monad. </span>The example also uses the <kbd>Either</kbd> type, which is another Functor and monad. It can be used to wrap a value that can be of two possible values:</p>
<pre>import { IO, Success, Failure, Either, Left, Right } from "funfix";<br/>import fetch from "node-fetch";<br/><br/>interface Todo {<br/>    userId: number;<br/>    id: number;<br/>    title: string;<br/>    completed: boolean;<br/>}<br/><br/>const getTodos = IO.async&lt;Either&lt;Error, Todo[]&gt;&gt;((ec, cb) =&gt; {<br/>   fetch(<br/>       "https://jsonplaceholder.typicode.com/todos"<br/>   ).then(response =&gt; {<br/>       return response.json().then(<br/>           (json: Todo[]) =&gt; cb(Success(Right(json)))<br/>       )<br/>   })<br/>   .catch(err =&gt; cb(Failure(Left(err))));<br/>});<br/><br/>const logTodos = getTodos.map((either) =&gt; {<br/>   return either.map(todos =&gt; todos.map(t =&gt; console.log(t.title)));<br/>});<br/><br/>logTodos.run();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The error-handling logic is very simple because the <kbd>map</kbd> method of the <kbd>Either</kbd> type only maps the values when the type of its value is not an error. Just as before, the entire logic is lazily evaluated and nothing really happens until we invoke the <kbd>run</kbd> method in the <kbd>logTodos</kbd> monad.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we have learned how to use some real-world functional programming libraries, including Ramda, Fundix, Immer, and Immutable.js. Throughout this book, we have learned about the main characteristics, principles, patterns, and principles of the functional programming and functional-reactive programming paradigm. These concepts provide you with a set of powerful tools that will help you to useapplications that are easier to reason about, more testable, and easier to maintain.</p>
<p class="mce-root">I hope that you enjoy this book and that you are eager to continue your functional programming-learning journey. In the appendices, you will find a guide that can be used to discover new functional libraries and additional functional programming concepts that you can explore on your own if you wish to learn more.</p>


            </article>

            
        </section>
    </body></html>