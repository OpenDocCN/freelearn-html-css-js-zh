- en: Application Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, a system resource, or simply a resource, is any physical
    or virtual component of limited availability within a computer system. Every device
    connected to a computer system is a resource. Every internal system component
    is also a resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how we can manage the available resources
    of a system efficiently to achieve great application performance. We will learn
    about the different kinds of resources, performance factors, and performance profiling
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter starts by introducing some core performance concepts, such as latency
    or bandwidth, and continues showcasing how to measure and monitor performance
    as part of the continuous integration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already learned in previous chapters, we can use TypeScript to generate
    JavaScript code that can be executed in many different environments. In this chapter,
    we are going to learn about performance profiling and optimization techniques,
    which are mainly applicable to the development of web applications. We are going
    to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance and resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspects of performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU and GPU profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are about to learn how to perform some performance analysis tasks; however,
    before that, we need to install a few tools in our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, we need to install Google Chrome. We can download it
    at [https://www.google.com/chrome/browser/desktop/index.html](https://www.google.com/chrome/browser/desktop/index.html).
    We are going to learn how to use the Google Chrome developer tools to perform
    some performance analysis tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you didn''t install Node.js in the previous chapters, you can visit [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to download the installer for your operating system. There are two main versions
    of Node.js available: **Long Term Support** (**LTS**) and **Current**. We recommend
    using the LTS version.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance and resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get our hands dirty doing some performance analysis, we must first
    spend some time understanding some core concepts and aspects of performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good application is one that has a set of desirable characteristics, which
    includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the course of this book so far, we have learned a lot about maintainability
    and reusability. In this chapter, we will focus on performance, which is closely
    related to reliability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The term performance refers to the amount of useful work accomplished compared
    with the time and resources used. A resource is a physical (such as CPU, RAM,
    GPU HDD, and so on) or virtual (such as CPU times, RAM regions, files, and so
    on) component with limited availability. Because the availability of a resource
    is limited, each resource is shared between processes. When a process finishes
    using a resource, it must release it before any other process can use it. Managing
    available resources in an efficient manner will help reduce the time other processes
    spend waiting for the resources to become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we work on a web application, we need to keep in mind that the following
    resources will have limited availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central Processing Unit** (**CPU**): This carries out the instructions of
    a computer program by performing the basic arithmetic, logical, control, and input/output
    (I/O) operations specified by the instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics Processor Unit** (**GPU**): This is a specialized processor used
    in the manipulation and alteration of memory to accelerate the creation of images
    in a frame buffer. A frame buffer is an area of the RAM used to hold the frame
    of data that is continuously being sent to the screen. The GPU is used when we
    create applications that use the WebGL API or when we use CSS animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random Access Memory** (**RAM**): This allows data items to be read and written
    in approximately the same amount of time, regardless of the order in which data
    items are accessed. When we declare a variable, it will be stored in RAM; when
    the variable is out of the scope, it will be removed from RAM by the garbage collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hard Disk Drive** (**HDD**) and **Solid-State Drive** (**SSD**): Both of
    these resources are data storage devices used to store and retrieve data. Frontend
    web applications don''t usually use persistent data storage extensively. However,
    we should keep in mind that whenever we store an object in a persistent manner
    (such as cookies, local storage, IndexedDB and so on), the performance of our
    application will be affected by the availability of the HDD or SSD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network throughput**: This determines how much actual data can be sent per
    unit of time across a network. The network throughput is determined by factors
    such as the network latency or bandwidth (we will discover more about these factors
    later in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common performance metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance can be affected by the availability of multiple types of physical
    and virtual devices. This explains the existence of multiple performance metrics
    (factors to measure performance). Some popular performance metrics include availability,
    response time, processing speed, latency, bandwidth, and scalability. These measurement
    mechanisms are usually directly related to one of the general resources (such
    as CPU, network throughput and so on) that were listed in the preceding section.
    We will now look at each of these performance metrics in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a system is not available at some stage, even if it is only partially unavailable,
    we will perceive it as bad performance. The availability of a system can be improved
    by improving its reliability, maintainability, and testability. If the system
    is easy to test and maintain, it will also be easy to increase its reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Response time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The response time is the amount of time that it takes to respond to a request
    for a service. A service here does not refer to a web service; a service can be
    any unit of work. The response time is influenced by the network throughput can
    be divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wait time**: The amount of time that the requests will spend waiting for
    other requests that took place earlier to be completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service time**: The amount of time that it takes for the service (unit of
    work) to be completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmission time**: Once the unit of work has been completed, the response
    will be sent back to the requester. The time that it takes for the response to
    be transmitted is known as the transmission time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing speed (also known as clock rate) refers to the frequency at which
    a processing unit (CPU or GPU) runs. An application contains many units of work.
    Each unit of work is composed of instructions for the processor; usually, the
    processors can perform an instruction in each clock tick. Since a few clock ticks
    are required for an operation to be completed, the higher the clock rate (processing
    speed), the more instructions that will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we mention bandwidth in this chapter, we will be referring to the network
    bandwidth. The bandwidth, or data transfer rate, is the amount of data that can
    be carried from one point to another in a given time. The network bandwidth is
    usually expressed in bits per second.
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Latency is a term we can apply to many elements in a system; however, when working
    on web applications, we will use this term to refer to network latency. Network
    latency indicates any delay that occurs in data communication over the network.
  prefs: []
  type: TYPE_NORMAL
- en: High latency creates bottlenecks in the communication bandwidth. The impact
    of latency on network bandwidth can be temporary or persistent, based on the cause
    of the delays. High latency can be caused by problems in the medium (cables or
    wireless signals), problems with routers and gateways, and anti-virus, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance can be affected by many factors. Some of these factors can
    degrade the network throughput. For example, a high packet loss, latency, and
    jitter will reduce the network throughput, while a high bandwidth will increase
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is the ability of a system to handle a growing amount of work. A
    system with good scalability will be able to pass some performance tests, such
    as spike or stress testing. We will learn more about performance tests (such as
    spike and stress) later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance analysis (also known as performance profiling) is the observation
    and study of the usage of the available system resources by an application. We
    will perform profiling to identify performance issues in our applications. A different
    performance profiling process with specific tools will be carried out for each
    type of resource. For example, CPU profiling can be performed using the system
    monitor of our OS.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how to use the Google Chrome's developer tools to perform
    some network profiling tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by analyzing network performance. Not so long ago, to
    be able to analyze the network performance of an application, we would have to
    write a small network logging application from scratch. Fortunately, today, things
    are much easier thanks to the arrival of the performance timing API.
  prefs: []
  type: TYPE_NORMAL
- en: The performance timing API allows us to access detailed network timing data
    for each loaded resource. You can learn more about it at [http://www.w3.org/TR/resource-timing/](http://www.w3.org/TR/resource-timing/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the network timing data points that the API
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff3aa358-6f64-411c-a247-470e819248c2.png)'
  prefs: []
  type: TYPE_IMG
- en: network timing data points
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the performance timing API via the `window` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The performance attribute in the `window` object has some properties (`memory`,
    `navigation`, and `timing`) and methods (`clearMarks`, `clearMeasures`, and `getEntries`).
    We can use the `getEntries` function to access an array which contains the taming
    data points of each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entity in the array is an instance of `PerformanceResourceTiming`, which
    contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the timing data points in the preceding format may not be useful
    if they are not presented in a visual way. Fortunately, there are some tools that
    can help us to analyze it with ease. We will now learn about some of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: The first tool is a browser extension called **performance-bookmarklet**. This
    extension is open source and is available for Chrome and Firefox. The extension
    download links can be found at [https://github.com/micmro/performance-bookmarklet](https://github.com/micmro/performance-bookmarklet).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see one of the graphs generated by the
    extension. The graphs display the performance typing API information visually,
    allowing us to spot performance issues with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/246869e0-dffa-4839-95be-4a472ef40d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can use the network panel in the Chrome developer tools to
    perform network performance profiling. To access the network panel, open Google
    Chrome, navigate to View | Developer, and then navigate to Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aa43eaa-4586-49d1-a68d-9f55838aa5e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Windows and Linux users can access the developer tools by pressing the *F12*
    key. OS X users can access it using the *Alt* + *Cmd* + *I* shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the developer tools are visible, we can access the Network tab by clicking
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3374dcfe-1dbd-4321-b75e-1086358fb8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Network tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the Network tab will lead us to a screen like the one seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69fcde60-1409-4553-b926-ad0a26b4bbef.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can observe, the information is presented in a table in which each file
    loaded is displayed as a row. On the right-hand side, we can see the timeline
    column. The timeline displays the performance timing API in a visual way, just
    like the performance-bookmarklet extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two very important elements in the timeline column are the red and blue vertical
    lines. These lines let us know when the `DOMContentLoaded` event is triggered
    (blue line), after which the `onLoad` event is triggered (red line):'
  prefs: []
  type: TYPE_NORMAL
- en: The blue line indicates when the `DOMContentLoaded` event was fired. The `DOMContentLoaded`
    event is fired when the engine has completed parsing of the main document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The red line indicates when the `onLoad` event was fired. The `onLoad` event
    is fired when all the page''s resources have been loaded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/adb6b47f-9afb-4587-8ada-c6bcb938a946.png)'
  prefs: []
  type: TYPE_IMG
- en: We can examine which requests were completed when these events were fired to
    get an idea of the overall page responsiveness and loading times.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hover over one of the cells of the timing column, we will be able to
    see each of the performance timing API data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebc2a7b9-1ddc-47a4-bf0c-9d6c4747703c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is interesting to know that this developer tool reads this information using
    the performance timing API. We will now learn more about the meaning of each of
    the data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Performance timing API data point** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Stalled/Blocking | The amount of time spent waiting by the request before
    it can be sent; there is a maximum number of open TCP connections for an origin.
    When the limit is reached, some requests will display blocking time, rather than
    stalled time. There is a maximum of 6 TCP connections to the same origin (domain
    address). |'
  prefs: []
  type: TYPE_TB
- en: '| Proxy negotiation | The amount of time spent negotiating a connection with
    a proxy server. |'
  prefs: []
  type: TYPE_TB
- en: '| DNS lookup | The amount of time spent resolving a DNS address; resolving
    a DNS requires a full round-trip to do the DNS server for each domain on the page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Initial connection / connecting | The amount of time spent establishing a
    connection. |'
  prefs: []
  type: TYPE_TB
- en: '| SSL | The amount of time spent establishing an SSL connection. |'
  prefs: []
  type: TYPE_TB
- en: '| Request sent / sending | The amount of time spent issuing the network request;
    typically, a fraction of a millisecond. |'
  prefs: []
  type: TYPE_TB
- en: '| Waiting (TTFB) | The amount of time spent waiting for the initial byte to
    be received—**time to first byte** (**TTFB**); the TTFB can be used to find out
    the latency of a round trip to the server in addition to the time spent waiting
    for the server to deliver the response. |'
  prefs: []
  type: TYPE_TB
- en: '| Content download / downloading | The amount of time spent waiting for the
    response data to be received. |'
  prefs: []
  type: TYPE_TB
- en: Please refer to the official Google Chrome documentation at [https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation](https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation)
    to learn more about the timing API.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance and user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how we can analyze network performance, it is time to identify
    the performance goals we should aim for. Numerous studies have proved that it
    is important to keep loading times as low as possible to achieve a great **user
    experience** (**UX**). The Akamai study, published in September 2009, interviewed
    1,048 online shoppers and found that:'
  prefs: []
  type: TYPE_NORMAL
- en: 47 percent of people expect a web page to load in two seconds or less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 40 percent of people will abandon a web page if it takes more than three seconds
    to load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 52 percent of online shoppers claim that quick page loads are important for
    their loyalty to a site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14 percent of people will start shopping at a different site if page loads are
    slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23 percent of people will stop shopping or even walk away from their computer
    if page loads are slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64 percent of shoppers who are dissatisfied with their site visit will go somewhere
    else to shop next time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read the full Akamai study at [https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp](https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp).
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding study conclusions, we should assume that network performance
    matters. Our priority should be to try to improve the loading speed of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to improve the performance of a site to ensure that it loads in less
    than two seconds, we might make a common mistake: trying to get the `onLoad` event
    to be triggered in under two seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While triggering the `onLoad` event as early as possible will probably improve
    the network performance of an application, it doesn''t mean that the user experience
    will be equally improved. The `onLoad` event is insufficient in determining performance.
    We can demonstrate this by comparing the loading performance of the Twitter and
    Amazon websites. As we can see in the following screenshot, users can engage with
    Amazon much sooner than with Twitter. Even though the `onLoad` event is the same
    on both sites, the user experience is drastically different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be19ba8b-7883-49bc-81ac-7ef457d1a54a.png)'
  prefs: []
  type: TYPE_IMG
- en: Twitter and Amazon websites
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example demonstrates why it is important to try to load the web
    contents in such a way that the user engagement can begin as early as possible.
    One way to achieve this is by ensuring that we only load the minimum necessary
    assets on initial page load. We can then asynchronously load all the secondary
    assets.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working with
    Functions,* to learn more about asynchronous programming with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Network performance best practices and rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to analyze the performance of a web application is by using a best
    practices tool for network performance, such as the **Google PageSpeed Insights**
    application or the **Yahoo YSlow** application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google PageSpeed Insights can be used online or as a Google Chrome extension.
    To try this tool, we can visit the online version at [https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/)
    and insert the URL of the web application that we want to analyze. In just a few
    seconds, we will get a report like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8f32bde-7fba-4fd7-8d95-86ab32bf222c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The report contains some effective recommendations that will help us to improve
    network performance and overall user experience of our web applications. Google
    PageSpeed Insights uses the following rules to rate the speed of a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid landing page redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve server response time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage browser caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minify resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize CSS delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritize visible content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove render-blocking JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use asynchronous scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we click on the score of one of the rules, we will be able to see recommendations
    and details that will help us to understand what is wrong and what we need to
    do to increase the score achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, Yahoo YSlow is available as a browser extension, a Node.js
    module, and a PhantomJS plugin, among other options. We can find the right version
    for our needs at [http://yslow.org/](http://yslow.org/). YSlow generates a report
    that will provide us with a general score and a detailed score of the website,
    like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0155934-8539-4b7b-92e2-a0c6b6e99541.png)'
  prefs: []
  type: TYPE_IMG
- en: 'YSlow uses the following set of rules to rate the speed of a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a content delivery network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid empty `src` or `href`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an expires or a cache-control header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GZIP components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put stylesheets at the top
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put scripts at the bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid CSS expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make JavaScript and CSS external
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce DNS lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minify JavaScript and CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove duplicate scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure ETags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make Ajax cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GET for Ajax requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the number of DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent 404 errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce cookie size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cookie-free domains for components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not scale images in HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make `favicon.ico` small and cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we click on the score of one of the rules, we will see some recommendations
    and details that will help us to understand what is wrong and what we need to
    do to increase the score achieved for one particular rule.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about network performance optimization, please look
    at the book *High Performance Browser Networking* by *Ilya Grigorik*.
  prefs: []
  type: TYPE_NORMAL
- en: GPU performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering elements in a web application is sometimes accelerated by the GPU.
    The GPU is specialized in the processing of graphics-related instructions and
    can, therefore, deliver a much better performance than the CPU when it comes to
    graphics. For example, CSS3 animations in modern web browsers are accelerated
    by the GPU, while the CPU performs JavaScript animations. In the past, the only
    way to achieve some animations was via JavaScript. But today, we should avoid
    its usage when possible and use CSS3 instead.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, direct access to the GPU from a web browser has become possible
    thanks to the WebGL API. This API allows web developers to create 3D games and
    other highly visual 3D applications powered by the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: Frames per second (FPS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will not go into much detail about the performance of 3D applications, because
    it is an extensive field and we could write an entire book about it. However,
    we will learn about an important concept that can be applied to any web application:
    **frames per second** (**FPS**), or frame rate. When the web application is displayed
    on the screen, it is done at several images (frames) per second. A low frame rate
    can be detrimental to the overall user experience when perceived by the users.
    A lot of research has been carried out on this topic, and 60 frames per second
    seem to be the optimum frame rate for great user experience. It is also worth
    mentioning that maintaining a constant frame rate, even if it is a low one like
    30 FPS, is considered better than an inestable frame rate.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we develop a web application, we should look at the frame rate and
    try to prevent it from dropping below 40 FPS, which is especially important for
    animations and user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Google Chrome to monitor the FPS in our web applications. We need
    to open the development tools (*Ctrl* + *Shift* + *I*), click on the upper-right
    icon next to the *X* icon with the tooltip *Customize and control devtools*. We
    can then select More tools | Rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f53648c6-4db3-45e8-a298-cae3f78393cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding instructions will display a new panel with the title Rendering.
    We must then enable the FPS meter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b0a2407-5332-4366-89f1-beb3791046cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The FPS meter should be displayed in the upper-right corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c826d45d-00fb-4ac2-9075-7197592357e5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The FPS counter allows us to see the number of frames per second and the GPU
    memory being consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Some advanced WebGL applications may require an in-depth performance analysis.
    For such cases, Chrome provides the Trace Event Profiling Tool. If you wish to
    learn more about this tool, visit the official page at [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).
  prefs: []
  type: TYPE_NORMAL
- en: CPU performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To analyze the usage of the processing time, we will examine the call stack
    of our application. We will examine each of the functions invoked and how long
    it takes to complete their execution. We can access all this information by opening
    the Profiles tab in the Google Chrome developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad3e72f1-efae-46b7-956e-b1a6ed0b2d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this tab, we can select Collect JavaScript CPU Profile and then click on
    the Start button to start recording the CPU usage. Being able to select when we
    want to start and stop recording the CPU usage helps us select the specific functions
    that we want to analyze. If, for example, we want to analyze a function named
    `foo`, all we need to do is start recording the CPU usage, invoke the `foo` function,
    and stop recording. A timeline like the one in the following screenshot will then
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3aec896-894c-4cad-bf08-92bde38c6d32.png)'
  prefs: []
  type: TYPE_IMG
- en: Timeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The timeline displays the functions invoked in chronological order (horizontal
    axis). The timeline also displays the call stack of these functions (vertical
    axis). When we hover over one of these functions, we will be able to see its details
    in the lower-left corner of the timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/762a4b61-4079-4882-99a2-678adad39ee5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The details include the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: The name of the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Self-time: The time spent on the completion of the current invocation of the
    function; we will consider the time spent in the execution of the statements within
    the function, not including any functions that it called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Total time: The total time spent on the completion of the current invocation
    of the function; we will consider the time spent in the execution of the statements
    within the function, including functions that it called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aggregated self-time: The time for all invocations of the function across the
    recording, not including functions called by this function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aggregated total time: The time for all invocations of the function across
    the recording, including functions called by this function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have learned in the previous chapters, all the JavaScript code is executed
    in one single thread at runtime; for this reason, when a function is executed,
    no other function can be executed. When the execution of a function takes too
    long to be completed, the application becomes unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this problem by reducing the amount of time required by the long-running
    function. We can use the CPU profile report to identify which functions are consuming
    too much processing time. Once we have identified these functions, we can refactor
    them to try to improve the application responsiveness. Some common improvements
    include using an asynchronous execution flow when possible, and reducing the size
    of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Memory performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare a variable, it is allocated in the RAM. Sometime after, the
    variable is out of the scope; it is cleared from memory by the garbage collector.
    Sometimes, we can generate a scenario in which a variable never goes out of scope.
    If the variable never goes out of scope, it will never be cleared from the memory.
    This can eventually lead to some serious memory leaking issues. A **memory leak**
    is the continuous loss of available memory.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with memory leaks, we can take advantage of the Google Chrome developer
    tools to identify the cause of the problem with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we might wonder is whether our application has memory
    leaks. We can find out by visiting the timeline and clicking on the upper-left
    icon to start recording the resource usage. Once we stop recording, a timeline
    graph like the one in the following screenshot will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60105d50-7848-450b-b035-9809e999a5a3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the timeline, we can select Memory to see the memory usage (Used JS Heap)
    over time (blue line in the screenshot). In the preceding example, we can see
    a notable drop towards the end of the line. That is a good sign because it indicates
    that most of the used memory has been cleared when the page has finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: The memory leaks can also take place after loading; in that case, we can use
    the application for a while and observe how the memory usage varies in the graph
    to identify the cause of the leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to detect memory leaks is by observing the memory allocations.
    We can access this information by recording the heap allocations in the Memory
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c5511ce-333a-4a34-a810-275a1916df3a.png)'
  prefs: []
  type: TYPE_IMG
- en: The report will be displayed after we have recorded some usage of the resources.
    We can do this by selecting Record allocation timeline and clicking on the Stake
    snapshot button. We then need to stop recording by clicking on the red dot displayed
    on the upper-left side of the development tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory allocation report will display a timeline like the one in the following
    screenshot. Each of the blue lines is a memory allocation that took place during
    the recorded period. The height of the line represents the amount of memory used.
    As we can see, the memory is almost cleared completely around the eighth second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9ebd42f-221a-4b8d-8fbb-d97dc4182f41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on one of the blue lines, we will be able to navigate through all
    the variables that were stored in memory when the allocation took place and examine
    their values. It is also possible to take a memory snapshot at any given point
    from the Profiles tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66c927aa-c944-4602-9031-03aac884446a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This feature is particularly useful when we are debugging and we want to see
    the memory usage at a breakpoint. The memory snapshot works like the details view
    in the previously explained allocations view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/439f929c-a983-4265-a3e7-2aae4a9729f3.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the memory snapshot allows us to
    navigate through all the variables that were stored in memory when the snapshot
    was taken and examine their values.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages with a low level of abstraction have low-level memory
    management mechanisms. On the other hand, in languages with a higher level of
    abstraction, such as C# or JavaScript, the memory is automatically allocated and
    freed by a process known as the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript garbage collector does a great job when it comes to memory management,
    but it doesn't mean that we don't need to care about memory management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Independent of which programming language we are working with, the memory life
    cycle pretty much follows the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate the memory you need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the memory (read/write)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release the allocated memory when it is not needed anymore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The garbage collector will try to release the allocated memory when is not
    needed anymore, using a variation of an algorithm known as the **mark-and-sweep
    algorithm**. The garbage collector performs periodical scans to identify objects
    that are out of the scope and can be freed from the memory. The scan is divided
    into two phases: the first one is known as a **mark,** because the garbage collector
    will flag or mark the items that can be freed from memory. During the second phase,
    known as a **sweep**, the garbage collector will free the memory consumed by the
    items marked in the previous phase.'
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector is usually able to identify when an item can be cleared
    from the memory; but we, as developers, must try to ensure that objects get out
    of scope when we don't need them anymore. If a variable never gets out of the
    scope, it will be allocated in memory forever, potentially leading to a severe
    memory leak issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of references pointing to an item in memory will prevent it from
    being freed from memory. For this reason, most cases of memory leaks can be fixed
    by ensuring that there are no permanent references to variables. Here are a few
    rules that can help us to prevent potential memory leak issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to clear intervals when you don't need them anymore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to clear event listeners when you don't need them anymore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that when you create a closure, the inner function will remember the
    context in which it was declared, which means that there will be some extra items
    allocated in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that when using object composition, if circular references are created,
    you can end up having some variables that will never be cleared from memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to mention that Node.js processes assume that there will be
    at least 1.5 GB of RAM available, which can cause some problems when the system
    has less than 1.5 GB of RAM available because the garbage collector will not try
    to free any unused memory until the process has consumed almost 1.5 GB of RAM.
    If only 1 GB is available, the process will crash, because we will run out of
    memory before the garbage collector tries to clean the unused memory. We can solve
    this problem using the `max_old_space_size` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Performance analysis in Node.js applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to use the Google Chrome development tools to analyze frontend
    application. However, the same tools can also be used to analyze backend applications
    powered by Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Google Chrome development tools to analyze a Node.js application,
    we need to start the Node.js application using the `--inspect` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then we need to visit the `chrome://inspect` URL using Google Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, we should be able to see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0badd2f-5691-485a-9243-42c56c9458ca.png)'
  prefs: []
  type: TYPE_IMG
- en: We then need to click on the inspect link, which should be available under the
    Remote Target section. A new window should be opened then. The window will display
    the Google Chrome developer tools, ready to analyze the Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use the **Node.js V8 --inspector Manager** (**NiM**) extension
    for Google Chrome, which allows us to access the Node.js inspector more easily.
    You can download the extension by visiting [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj).
  prefs: []
  type: TYPE_NORMAL
- en: Performance automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how we can automate many of the performance
    optimization tasks, from concatenation and compression of contents to the automation
    of the performance monitoring and performance testing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After analyzing the performance of our application, we will start working on
    some performance optimizations. Many of these optimizations involve the concatenation
    and compression of some of the application's components.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have to create a new version of the concatenated and compressed
    contents every time one of the original components (not concatenated and not compressed)
    changes. Because these include many highly repetitive tasks, we can use tools
    like Gulp or Webpack to perform many of these tasks for us.
  prefs: []
  type: TYPE_NORMAL
- en: We can use these tools to concatenate and compress components, optimize images,
    generate a cache manifest file, and perform many other performance optimization
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about Gulp and Webpack, refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Performance monitoring automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that we can automate many of the performance optimization tasks
    using the Gulp task runner. Similarly, we can also automate the performance monitoring
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To monitor the performance of an existing application, we will need to collect
    some data that will allow us to compare the application performance over time.
    Depending on how we collect the data, we can identify three different types of
    performance monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real user monitoring** (**RUM**): This is a type of solution used to capture
    performance data from real user visits. The collection of data is performed by
    a small JavaScript code snippet loaded in the browser. This type of solution can
    help us to collect data and discover performance trends and patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulated browsers**: This type of solution is used to capture performance
    data from simulated browsers, which is the cheaper option, but it is limited,
    because simulated browsers cannot offer as accurate a representation of the real
    user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-browser monitoring**: This is used to capture performance data of real
    browsers. This information provides a more accurate representation of the real
    user experience, as the data is collected using exactly what a user would see
    if he or she visited the site with the given environment (browser, geographic
    location, and network throughput).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web browsers can be configured to generate **HTTP Archive** (**HAR**) files.
    A HAR file uses a common format for recording HTTP tracing information. This file
    contains a variety of information, but, for our purposes, it has a record of each
    object being loaded by a browser.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple scripts available online that showcase how to collect the
    data. One of the examples, `netsniff.js`, exports the network traffic in HAR format.
    The `netsniff.js` file (and other examples) can be found at [https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js](https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have generated the HAR files, we can use another application to see
    the collected performance information in a visual timeline. This application is
    called HAR Viewer and can be found at [https://github.com/janodvarko/harviewer](https://github.com/janodvarko/harviewer).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could write a custom script or Gulp task to read the HAR files
    and break the automated build if the application performance doesn't meet our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to run the YSlow performance analysis report and integrate
    it with the automated build.
  prefs: []
  type: TYPE_NORMAL
- en: If you are considering using RUM, look at the New Relic solutions at [http://newrelic.com/](http://newrelic.com/)
    or Google Analytics at [http://www.google.com/analytics/](http://www.google.com/analytics/).
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to improve the performance of an application is to write automated
    performance tests. These tests can be used to guarantee that the system meets
    a set of performance goals. There are multiple types of performance testing, but
    some of the most common ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load testing**: This is the most basic form of performance testing. We can
    use a load test to understand the behavior of the system under a specific expected
    load (number of concurrent users, number of transactions, and duration).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress testing**: This is normally used to understand the maximum capacity
    limits of an application. This kind of test determines if an application can handle
    an extreme number of requests. Stress testing is not useful when working on a
    client-side application. However, it can be helpful when working on a Node.js
    application, since Node.js applications can have many simultaneous users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soak testing**: Also known as endurance testing. This kind of test is like
    the stress test, but instead of using an extreme load, it uses the expected load
    for a continued period. It is a common practice to collect memory usage data during
    this kind of test to detect potential memory leaks. This kind of test helps us
    to tell if the performance suffers degradation after a continued period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spike testing**: This is also like the stress test, but instead of using
    an extreme time load during a continued period, it uses sudden intervals of the
    extreme and expected load. This kind of test helps us to determine if an application
    can handle dramatic changes in load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration testing**: This is used to determine the effects of configuration
    changes to the performance and behavior of an application. A common example would
    be experimenting with different methods of load balancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding how to use the available resources efficiently will help us to
    create better applications. Similarly, understanding how to handle runtime errors
    will help us to improve the overall quality of our applications. Exception handling
    in TypeScript involves three main language elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Error class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a runtime error takes place, an instance of the `Error` class is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create custom errors in a couple of different ways. The easiest way
    to achieve it is by passing a string as an argument to the `Error` class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need more customizable and advanced control over custom exceptions, we
    can use inheritance to achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have declared a class named `Exception`, which
    inherits from the `Error` class. In the class constructor, we have set the prototype
    explicitly. This is a requirement since TypeScript 2.1, caused by some limitations.
    You can learn more details about this limitation at [https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work).
  prefs: []
  type: TYPE_NORMAL
- en: The try...catch statements and throw statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `catch` clause contains statements that specify what to do if an exception
    is thrown in the `try` block. We should perform some operations in the `try` block
    and, if they fail, the program execution flow will move from the `try` block to
    the `catch` block. Additionally, there is an optional block known as `finally`,
    which is executed after both the `try` and `catch` (if there was an `exception`
    in the `catch`) blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to mention that in the majority of programming languages,
    including TypeScript, throwing and catching exceptions is an expensive operation
    regarding resource consumption. We should use these statements if we need them,
    but sometimes it is necessary to avoid them because they can potentially negatively
    affect the performance of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned what performance is and how the availability
    of resources can influence it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned how to use some tools to analyze the way a TypeScript application
    uses available resources. These tools allow us to spot some possible issues, such
    as a low frame rate, memory leaks, and high loading times. We have also discovered
    that we can automate many kinds of the performance optimization tasks as well
    as the performance monitoring and testing processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we are going to learn how we can automate the testing
    process of our TypeScript applications to achieve great application maintainability
    and reliability.
  prefs: []
  type: TYPE_NORMAL
