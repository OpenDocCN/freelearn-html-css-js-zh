- en: Chapter 3. Making Data Useful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, d3.js is a data manipulation library. We're going to take a look
    at making our datasets useful with both d3.js and plain old JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a quick dip into functional programming to bring everyone up to
    speed. You can skip this part if you use Haskell, Scala, or Lisp, or already write
    JavaScript in a functional style.
  prefs: []
  type: TYPE_NORMAL
- en: We continue loading external data, taking a closer look at the scales I can't
    stop writing about, and finish with some temporal and geographic data.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about data functionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the functional design of d3.js, we have to start thinking of our code
    and data with a functional mindset.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that JavaScript almost counts as a functional language; there
    are enough features to get the benefits of a functional style, and also provides
    enough freedom to do things imperatively or in an object-oriented way. The bad
    news is that, unlike real functional languages, the environment gives no guarantee
    about our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll go through the basics of functional-style coding and
    look at wrangling the data so that it's easier to work with. If you want to try
    proper functional programming, I suggest looking at Haskell and *Learn You a Haskell
    for Great Good* available at [http://learnyouahaskell.com/](http://learnyouahaskell.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind functional programming is simple—compute by relying only on
    function arguments. Simple, but the consequences are far reaching.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest consequence is that we don't have to rely on state, which in turn
    gives us referential transparency. This means functions executed with the same
    parameters will always give the same results regardless of when or how they're
    called.
  prefs: []
  type: TYPE_NORMAL
- en: In practice this means we design the code and dataflow, that is, get data as
    input, execute a sequence of functions that pass changed data down the chain,
    and eventually get a result.
  prefs: []
  type: TYPE_NORMAL
- en: You've already seen this in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Our dataset started and ended as an array of values. We performed some actions
    for each item and we relied only on the current item when deciding what to do.
    We also had the current index, so we could cheat a little with an imperative approach
    by looking ahead and behind in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript comes with a slew of array-manipulation functions. We'll focus on
    those which are more functional in nature, the iteration methods.
  prefs: []
  type: TYPE_NORMAL
- en: A smart man once told me you can model any algorithm by using `map` and `reduce`.
    But he was wrong. What you need is recursion, a way to add two arrays together,
    the ability to get the first and second element of an array, an equality comparator,
    and a way to decide if something is a value or an array. In fact that's how LISP
    is defined.
  prefs: []
  type: TYPE_NORMAL
- en: But you will get pretty far with `map`, `reduce`, and `filter` in combination
    with their predicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map` command applies a function on every element of an array and returns
    a new array with changed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reduce` function uses a combining function and a starting value to collapse
    an array into a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` function goes through an array and keeps elements for which the
    predicate returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Two more useful functions are `.every()` and `.some()`, which are true if every
    or some items in the array are true. Sometimes, using `.forEach()` instead of
    `.map()` is better because `forEach` operates on the original array instead of
    creating a copy, which is important for working with large arrays and is mainly
    used for the side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are relatively new to JavaScript, whereas `map` and `filter`
    have existed since JavaScript 1.7, and `reduce` since 1.8; these are also a part
    of the emerging ECMAScript 6 standard and, thus, not supported on older browsers.
    You can use libraries, such as underscore.js or one of the various es6 shims to
    support older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Data functions of d3.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: d3.js comes with plenty of its own array functions. They mostly have to do with
    handling data; it comprises calculating averages, ordering, bisecting arrays,
    and many helper functions for associative arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Let's play with data functions and draw an unsolved mathematical problem named
    Ulam spiral. Discovered in 1963, it reveals patterns in the distribution of prime
    numbers on a two-dimensional plane. So far, nobody has found a formula that explains
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We'll construct the spiral by simulating Ulam's pen-and-paper method; we'll
    write natural numbers in a spiraling pattern, and then remove all non-primes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of numbers we''ll draw dots. The first stage in our experiment will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data functions of d3.js](img/0007OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Doesn't look like much, but that's only the first 5,000 primes in a spiral.
    Notice the diagonals? Some can be described with polynomials, which brings interesting
    implications about predicting prime numbers and by extension, the safety of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the algorithm that generates a list of numbers and their spiraling
    coordinates on a grid. We start with some helpful variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We defined a `spiral` function that takes a single upper-bound argument, `n`.
    The function starts with four directions of travel and some variables for our
    algorithm. The combination of `min` and `max` known coordinates will tell us when
    to turn; `x` and `y` will be the current position, whereas `direction` will tell
    us which part of the spiral we're tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add the algorithm itself to the bottom of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`d3.range()` generates an array of numbers between the two arguments that we
    iterate with `forEach`. Each iteration adds a new `{x: x, y: y, n: i}` triplet
    to the spiral array. The rest is just using `min` and `max` to change the direction
    on the spiral''s corners. Yes it''s repetitive, but we don''t always have to be
    clever.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to draw stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a `dot` generator and two functions to help us turn grid coordinates
    from the `spiral` function into pixel positions. `l` is the length and width of
    a square in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid the dirty work of calculating primes by getting a list online.
    I found a list at [http://www.mathsisfun.com/](http://www.mathsisfun.com/) and
    placed it on GitHub next to the code examples at [https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/primes-to-100k.txt).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We load the primes as a text file, split it into lines, use `.slice()` to get
    the first `5000` elements, then turn them into numbers using `.map(Number)`. We'll
    use `l` to tell the `x` and `y` functions how big the grid is.
  prefs: []
  type: TYPE_NORMAL
- en: We call `spiral` with the largest prime on our list, (`d3.max()`), to generate
    the spiraling sequence of numbers and then use `.filter()` to remove all non-primes
    from the spiral when feeding them into the drawing code.
  prefs: []
  type: TYPE_NORMAL
- en: We used `_.indexOf` of underscore.js to search for primes because it uses binary
    search and makes our code faster. The caveat is that we have to know our list
    is ordered. You can get underscore.js from [http://underscorejs.org](http://underscorejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: My aging machine still takes about two seconds to draw the interesting pixelated
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make it more interesting by visualizing the density of primes. We'll define
    a grid with larger squares, and then color them depending on how many dots they
    contain. Squares will be red when there are fewer primes than median, and green
    when there are more. The shading will tell us how far they are from the median.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll use the `nest` structure of d3.js to define a new grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We scale by a factor of `8`, that is, each new square contains 64 of the old
    squares.
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.nest()` is handy for turning data into nested dictionaries according to
    a key. The first `.key()` function creates our columns; every `x` is mapped to
    the corresponding `x` of the new grid. The second `.key()` function does the same
    for `y`. We then use `.rollup()` to turn the resulting lists into a single value,
    a count of the dots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data goes in with `.map()` and we get a structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Not very self-explanatory, but that's a collection of columns containing rows.
    The (`0`, `0`) square contains `5` primes, (`-1`, `0`) contains `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the median and the number of shades, we need those counts in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We map through the keys of our regions (`x` coordinates) to get a list of values
    for each column, and then use `d3.merge()` to flatten the resulting array of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.median()` gives us the middle value of our array and `d3.extent()` gives
    us the lowest and highest number, which we used to calculate the number of shades
    we needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we walk the coordinates again to color the new grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our image looks like one of those Chiptunes album covers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data functions of d3.js](img/0007OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Loading data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest features of d3.js is that it can asynchronously load external
    data without any help from third-party libraries or a programmer. We've already
    glanced at data loading, but it's time to take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we want to load data externally is that bootstrapping large datasets
    into the page with predefined variables isn't very practical. Loading hundreds
    of kilobytes of data takes a while and doing so asynchronously lets the rest of
    the page render in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make HTTP requests, d3.js uses XMLHttpRequests (XHR for short). This limits
    us to a single domain because of the browser''s security model, but we can do
    cross-domain requests if the server sends an `Access-Control-Allow-Origin: *`
    header.'
  prefs: []
  type: TYPE_NORMAL
- en: The core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the core of all this loading, is the humble `d3.xhr()`, the manual way of
    issuing an XHR request.
  prefs: []
  type: TYPE_NORMAL
- en: It takes a URL and an optional callback. If present, the callback will immediately
    trigger the request and receives data as an argument once the request finishes.
  prefs: []
  type: TYPE_NORMAL
- en: If there's no callback, we get to tweak the request; everything from the headers
    to the request method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a request you might have to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will send a GET request expecting a JSON response and tell the server we're
    an example. One way to shorten this is by defining a callback immediately, but
    then you can't define custom headers or listen for other request events.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is convenience functions. We'll be using these throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: d3.js comes with several convenience functions that use `d3.xhr()` behind the
    scenes, and parse the response before giving it back to us. This lets us limit
    our workflow to calling the appropriate function and defining a callback, which
    takes an `error` and a `data` argument. d3.js is nice enough to let us throw caution
    to the wind and use callbacks with a single `data` argument that will be undefined
    in case of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a choice of data formats such as TEXT, JSON, XML, HTML, CSV, and TSV.
    JSON and CSV/TSV are used the most: JSON for small structured data, and CSV/TSV
    for large data dumps where we want to conserve space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of our code will follow this kind of pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scales are functions that map a domain to a range. Yeah, yeah, I keep saying
    that, but there really isn't much more to say.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we use them is to avoid math. This makes our code shorter, easier
    to understand, and more robust as mistakes in high school mathematics are some
    of the hardest bugs to track down.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't just spent four years listening to mathematics at school, a function's
    domain are those values where it is defined (the input), and the range are those
    values it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is borrowed from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scales](img/0007OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **X** is the domain, **Y** is the range, and arrows are the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a bunch of code to implement this manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also do it with a dictionary, but `d3.scale` will always be more
    elegant and flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Much better!
  prefs: []
  type: TYPE_NORMAL
- en: Scales come in three types; ordinal scales have a discrete domain, quantitative
    scales have a continuous domain, and time scales have a time-based continuous
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinal scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ordinal scales are the simplest, essentially just a dictionary where keys are
    the domain and values are the range.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we defined an ordinal scale by explicitly setting
    both the input domain and the output range. If we don't define a domain, it's
    inferred from use, but that can give unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: A cool thing about ordinal scales is that having a range smaller than the domain
    makes the scale cycle values. Furthermore, we'd get the same result if the range
    was just `['red', 'yellow', 'green']`. But, cutting a continuous interval into
    chunks can make an even better range, histograms, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the three scales we need, and generate some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our data is just a list of numbers going upto `30`, and the `colors` scale is
    from [Chapter 2](ch02.html "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer
    on DOM, SVG, and CSS*. It is a predefined ordinal scale with an undefined domain
    and a range of ten colors.
  prefs: []
  type: TYPE_NORMAL
- en: Then we defined two scales that split our drawing into equal parts. `points`
    uses `.rangePoints()` to distribute `30` equally-spaced points along the height
    of our drawing. We set the edge padding with a factor of `1.0`, which sets the
    distance from the last point to the edge to half the distance between the points.
    End points are moved inwards from the range edge using `point_distance*padding/2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordinal scales](img/0007OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`bands` uses `.rangeBands()` to divide the width into `30` equal bands with
    a padding factor of `0.1` between bands. This time we''re setting the distance
    between bands, using `step*padding`, and a third argument would set edge padding
    using `step*outerPadding`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordinal scales](img/0007OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll use code you already know from [Chapter 2](ch02.html "Chapter 2. A Primer
    on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*, to draw two lines using
    these scales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To get the positions for each dot or rectangle, we called the scales as functions
    and used `bands.rangeBand()` to get the rectangle width.
  prefs: []
  type: TYPE_NORMAL
- en: 'The picture looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ordinal scales](img/0007OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quantitative scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantitative scales come in a few different flavors, but they all share a common
    characteristic that the input domain is continuous. Instead of a set of discrete
    values, a continuous scale can be modeled with a simple function. The seven types
    of quantitative scales are linear, identity, power, log, quantize, quantile, and
    threshold. They define different transformations of the input domain. The first
    four have a continuous output range while the latter three map to a discrete range.
  prefs: []
  type: TYPE_NORMAL
- en: To see how they behave, we'll use all these scales to manipulate the `y` coordinate
    when drawing the `weierstrass` function; the first discovered function that is
    continuous everywhere but differentiable nowhere. This means that even though
    you can draw the function without lifting your pen, you can never define the angle
    you're drawing at (calculate a derivative).
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a drawing area and the `weierstrass` function as found on Wikipedia
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A drawing function will help us avoid code repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We generate some data, get the `extent` of the `weierstrass` function, and
    use a linear scale for `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Continuous range scales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can draw using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We defined a linear scale with the domain encompassing all the values returned
    by the `weierstrass` function, and a range from zero to the drawing width. The
    scale will use linear interpolation to translate between the input and the output,
    and will even predict values that fall outside its domain. If we don't want that
    happening, we can use `.clamp()`. Using more than two numbers in the domain and
    range, we can create a polylinear scale where each section behaves like a separate
    linear scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linear scale creates the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous range scales](img/0007OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add the other continuous scales in one fell swoop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We keep re-using the same `line` definition, changing the scale used for `y`,
    except for the `power` scale, because changing `x` makes a better example.
  prefs: []
  type: TYPE_NORMAL
- en: We also took into account that `log` is only defined on positive numbers, but
    you usually wouldn't use it for periodic functions anyway. It's much better at
    showing large and small numbers on the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our picture looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous range scales](img/0007OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `identity` scale is orange and wiggles around by barely a pixel because
    the data we feed into the function only goes from -0.5 to 0.5, the `power` scale
    is green, and the `logarithmic` scale is red.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete range scales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The interesting scales for our comparison are `quantize` and `threshold`. The
    `quantize` scale cuts the input domain into equal parts and maps them to values
    in the output range, while `threshold` scales let us map arbitrary domain sections
    to discrete values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `quantize` scale will divide the `weierstrass` function into discrete values
    between 1 and 2 with a step of 0.5 (-1, -0.5, 0, and so on), and threshold will
    map values smaller than -1 to -50, -1 to 0, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discrete range scales](img/0007OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't understand time. You might think you do, but you don't.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this in mind next time you want to add 3,600 seconds to a timestamp to
    advance it by an hour, or basically `now+24*3600` is tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: Time is a complicated beast. An hour can last 3600 seconds or 3599 seconds,
    if there's a leap second. Tomorrow can be 23 to 25 hours away, months range from
    28 to 31 days, and a year can be 365 or 366 days. Some decades have fewer days
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: Considering many datasets are closely tied to time, this can become a big problem.
    Just how do you handle time?
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, d3.js comes with a bunch of time-handling features.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a new formatter by giving `d3.time.format()` a format string.
    You can then use it for parsing strings into `Date` objects and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole language is explained in the documentation of d3.js, but let''s look
    at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We defined a new formatter with `d3.time.format()` (year-month-day), then parsed
    a date as they often appear in datasets. This gave us a proper `date` object with
    default values for hours, minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same formatter works the other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can find the full ISO standard time formatter at `d3.time.format.iso`. That
    often comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Time arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also get a full suite of time arithmetic functions that work with JavaScript''s
    `Date` objects and follow a few simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.time.interval`, where `interval` can be a `second`, `minute`, `hour`, and
    so on. It returns a new time interval. For instance, `d3.time.hour` will be an
    hour long.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`d3.time.interval`(`Date`), is an alias for `interval.floor()`, which rounds
    `Date` down so that more specific units than the `interval` are set to zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`interval.offset`(`Date`, `step`), will move the date by a specified number
    of steps to the correct unit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`interval.range`(`Date_start`, `Date_stop`), will return every `interval` between
    the two specified dates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`d3.time.intervals`, where an `interval` is `seconds`, `minutes`, `hours`,
    and so on. They are helpful aliases for `interval.range`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For instance, if you want to find the time an hour from now, you''d do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And find out it's getting really late and you should stop writing books about
    JavaScript, and go to bed.
  prefs: []
  type: TYPE_NORMAL
- en: Geography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other useful data types are geospatial coordinates, often used for weather or
    population data; anything where you want to draw a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'd3.js gives us three tools for geographic data: paths produce the final pixels,
    projections turn sphere coordinates into Cartesian coordinates, and streams speed
    things up.'
  prefs: []
  type: TYPE_NORMAL
- en: The main data format we'll use is TopoJSON, a more compact extension of GeoJSON,
    created by Mike Bostock. In a way, TopoJSON is to GeoJSON what DivX is to video.
    While GeoJSON uses the JSON format to encode geographical data with points, lines,
    and polygons, TopoJSON instead encodes basic features with arcs and re-uses them
    to build more and more complex features. As a result, files can be as much as
    80 percent smaller than when we use GeoJSON.
  prefs: []
  type: TYPE_NORMAL
- en: Getting geodata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, unlike many other datasets, geodata can't be found just lying around the
    Internet. Especially not in a fringe format such as TopoJSON. We'll find some
    data in Shapefile or GeoJSON formats, and then use the `topojson` command-line
    utility to transform them into TopoJSON. Finding detailed data can be difficult,
    but is not impossible, look for your country's census bureau. For instance, the
    US Census Bureau has many useful datasets available at [http://www.census.gov/geo/www/cob/index.html](http://www.census.gov/geo/www/cob/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Natural Earth is another magnificent resource for geodata at different levels
    of detail. The biggest advantage is that different layers (oceans, countries,
    roads, and so on) are carefully made to fit together without discrepancies and
    are frequently updated. You can find the datasets at [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's prepare some data for the next example. Go to [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/)
    and download the `ocean`, `land`, `rivers and lake centerlines`, and `land boundary
    lines` datasets at 50m detail level, and the `urban areas` dataset at 10m. You'll
    find them in the **Downloads** tab. The files are also in the examples on GitHub
    available at [https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data](https://github.com/Swizec/d3.js-book-examples/tree/master/ch3/data).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the five files. We'll combine them into three TopoJSON files to save the
    request time, three big files are quicker than five small files, and we prefer
    TopoJSON because of the smaller file size.
  prefs: []
  type: TYPE_NORMAL
- en: We'll merge categorically so that we can reuse the files later; one for water
    data, another for land data, and a third for cultural data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to install `topojson`, which needs node.js. Follow the installation
    instructions for your computer on `nodejs.org`, then open a terminal, and run
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`npm` is node''s built-in package manager. It downloads and installs the `topojson`
    library globally. You might have to run this as a super user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we transform the files with three simple commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `topojson` library transforms shape files into TopoJSON files and merges
    the files we wanted. We specified where to put the results with `-o`; the other
    arguments were source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve generated three files: `water.json`, `land.json`, and `cultural.json`.
    Feel free to look at them, but they aren''t very human-friendly.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing geographically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`d3.geo.path()` is going to be the work horse of our geographic drawings. It''s
    similar to the SVG path generators we learned about earlier, except it draws geographic
    data and is smart enough to decide whether to draw a line or an area.'
  prefs: []
  type: TYPE_NORMAL
- en: To flatten spherical objects such as planets into a 2D image, `d3.geo.path()`
    uses projections. Different kinds of projections are designed to showcase different
    things about the data, but the end result is you can completely change what the
    map looks like, just by changing the projection or moving its focal point.
  prefs: []
  type: TYPE_NORMAL
- en: With the right projection you can even make the data of Europe look like the
    U.S. Rather unfortunately then, the default projection is `albersUsa` designed
    specifically to draw the standard map of U.S.
  prefs: []
  type: TYPE_NORMAL
- en: Let's draw a map of the world, centered and zoomed into Europe because that's
    where I'm from. We'll make it navigable in [Chapter 4](ch04.html "Chapter 4. Making
    Things Move"), *Making Things Move*.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to add some things to our standard HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an empty `style` definition above the main div; we''ll use it later to
    make our map look better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need two more JavaScript files right after d3.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These load the TopoJSON parser and a queue utility to help us load more than
    one dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue in our JavaScript file with a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a geographic `projection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `equirectangular` projection is one of the twelve projections that come
    with d3.js, and is perhaps the most common projection we're used to seeing ever
    since high school.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with `equirectangular` is that it doesn't preserve areas or represent
    the earth's surface all that well. A full discussion of projecting a sphere onto
    a two dimensional surface would take too much time, so I suggest looking at the
    Wikipedia page of d3.js and the visual comparison of all the projections implemented
    in the projection plugin. It is available at [https://github.com/mbostock/d3/wiki/Geo-Projections](https://github.com/mbostock/d3/wiki/Geo-Projections).
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines define where our map is centered and how zoomed in it is.
    By fiddling I got all three values latitude of `8`, longitude of `56`, and a scaling
    factor of `800`. Play around to get a different look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we load our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We're using Mike Bostock's `queue` library to run the three loading operations
    in sequence. Each will use `d3.json` to load and parse the data, and when they're
    all done, `queue` will call `draw` with the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more thing before we start drawing; a function that adds a feature
    to the map, which will help us reduce code repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a collection of objects and a key to choose which object
    to display. `topojson.object()` translates a TopoJSON topology into a GeoJSON
    one for `d3.geo.path()`.
  prefs: []
  type: TYPE_NORMAL
- en: Whether it's more efficient to transform to GeoJSON than transferring data in
    the target representation depends on your use case. Transforming data takes some
    computational time, but transferring megabytes instead of kilobytes can make a
    big difference in responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a new `d3.geo.path()`, and tell it to use our projection.
    Other than generating the SVG path string, `d3.geo.path()` can also calculate
    different properties of our feature, such as the area (`.area()`) and the bounding
    box (`.bounds()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our `draw` function takes the error returned from loading data, and the three
    datasets then lets `add_to_map` do the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some styling to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Refreshing the page will reveal some oceans.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing geographically](img/0007OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We add four more `add_to_map` calls to the `draw` function to fill in the other
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some style definitions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a slowly rendering world map zoomed into Europe, displaying the
    world''s urban areas as blots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing geographically](img/0007OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are many reasons why it's so slow. We transform between TopoJSON and GeoJSON
    on every call to `add_to_map`. Even when using the same dataset, we're using data
    that's too detailed for such a zoomed out map, and we render the whole world to
    look at a tiny part. We traded flexibility for rendering speed.
  prefs: []
  type: TYPE_NORMAL
- en: Using geography as a base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Geography isn't just about drawing maps. A map is usually a base we build to
    show some data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn this into a map of the world's airports. I wanted to make a map of
    the routes between airports at first, but it looked too crowded.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is fetching the `airports.dat` and `routes.dat` datasets from
    [http://openflights.org/data.html](http://openflights.org/data.html). You can
    also find it in the examples on GitHub at [https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat](https://github.com/Swizec/d3.js-book-examples/blob/master/ch3/data/airports.dat).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to `add_airlines()` at the bottom of `draw`. We''ll use it to load
    more data and draw the airports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The function loads the two datasets, and then calls `draw_airlines` to draw
    them. We use `d3.text` instead of `d3.csv` because the files don't have a header
    line so we have to parse them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `draw_airlines`, we first wrangle the data into JavaScript objects, airports
    into a dictionary by `id`, and routes into a mapping of source to the target airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `d3.csv.parseRows` to parse CSV files into arrays and manually turned
    them into dictionaries. The array indices aren''t very legible unfortunately,
    but they make sense when you look at the raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The radius of each airport circle will show how many routes are leaving from
    it. So, we need a scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We took an array of route counts and turned it into a linear scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can draw the airports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The tricky part is that we used the same `projection` we gave to `d3.geo.path()`
    to turn airport positions into circle coordinates. We avoided the `cx` and `cy`
    attributes so that we can take advantage of `projection` working on two coordinates
    at once. By now, everything else should be familiar from [Chapter 2](ch02.html
    "Chapter 2. A Primer on DOM, SVG, and CSS"), *A Primer on DOM, SVG, and CSS*.
  prefs: []
  type: TYPE_NORMAL
- en: Airports without routes will be very small dots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later we add some more CSS to our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using geography as a base](img/0007OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've made it through the chapter on data!
  prefs: []
  type: TYPE_NORMAL
- en: We really got to the core of what d3.js is about, that is, data wrangling. The
    part about functional programming hopefully inspired you to take up functional-style
    programming, if you were still on the fence. Learning about data wrangling we
    saw some interesting properties of prime numbers, learned all about loading external
    data, and effectively used scales to avoid calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we made a cool map to learn how simple geographic data can be once
    you get a hand on a good source and transform it into a better format.
  prefs: []
  type: TYPE_NORMAL
