["```js\n<Input name=\"username\" />\n<Input name=\"password\" />\n<Checkbox label=\"Show Password\" />\n<Button>Submit</Button>\n```", "```js\nconst state = {\n  nameValue: '',\n  nameError: null,\n  passwordValue: '',\n  passwordError: null,\n  revealPassword: false,\n  submitDisabled: true,\n}\n```", "```js\n<!-- Input.svelte -->\n<script>\n  export let nameValue = '';\n</script>\n<input bind:value={nameValue} />\n```", "```js\n<!-- Button.svelte -->\n<script>\n  export let submitDisabled = false;\n</script>\n<button disabled={submitDisabled}>Submit</button>\n```", "```js\nconst state = {\n  nameValue: '',\n  submitDisabled: true,\n};\n```", "```js\n<script>\n  import { writable } from 'svelte/store';\n  const state = writable({\n    nameValue: '',\n    nameError: null,\n    passwordValue: '',\n    passwordError: null,\n    revealPassword: false,\n    submitDisabled: true,\n  });\n</script>\n```", "```js\n<script>\n  const state = writable({ name: 'Svelte' });\n</script>\n<Input {state} />\n```", "```js\n<script>\n  // import state object defined in './state.js'\n  import { state } from './state.js';\n</script>\n```", "```js\n<script>\n  let state = {…}\n</script>\n<ShoppingCart cart={$state.cart} />\n<ProductDetails product={$state.product} />\n<ProductRatings ratings={$state.ratings} />\n```", "```js\n<script>\n  let cartState = {…};\n  let productState = {…};\n  let ratingState = {…};\n</script>\n<ShoppingCart cart={$cartState} />\n<ProductDetails product={$productState} />\n<ProductRatings ratings={$cartState, would not trigger an update on the <ProductDetails /> and <ProductRatings /> components.\nSo, if you have big state objects and you find components update unnecessarily and the performance of your application is impacted by it, then consider breaking these big state objects down into smaller state objects.\nBut what if the state object is still big, yet the different values in the state objects are closely related and you are unable to break it apart into smaller state objects? Well, there is still hope, which leads us to our third tip.\nTip 3 – derive a smaller state object from a bigger state object\nIf state values are related to each other and so you can’t break a big state object into smaller state objects, we can create smaller state objects that derive from the big state object. Let me show you some code to explain this clearly.\nLet’s say that you have a state object, `userInfo`, that has two closely related state values, `$userInfo.personalDetails` and `$userInfo.socials`, as shown here:\n\n```", "```js\n\n You may realize that one part of the `userInfo` state object doesn’t change as often as the other. But whenever any part of `userInfo` changes, all the components that use either the `$userInfo.personalDetails` or `$userInfo.socials` state values will be updated.\nTo ensure that components using only `$userInfo.socials` are updated exclusively when `$userInfo.socials` changes, one way would be to break the state object into smaller, more focused state objects, like so:\n\n```", "```js\n\n As you can see, you now have two separate state objects, `userPersonalDetails` and `userSocials`.\nBut this would mean that places where you previously updated the `userInfo` state object would have to change since `userInfo` is now split into two separate state objects.\nHere is how you would change the code:\n\n```", "```js\n\n So, the question now is this: Is there an alternative to not having to change this, yet being able to update the components that use `$userInfo.socials` only when `$``userInfo.socials` changes?\nI believe I’ve leaked the answer already. The alternative is to derive a new state object. In the following code snippet, I am deriving a new `userSocials` state object from the `userInfo` state object:\n\n```", "```js\n\n The component that uses `$userSocials` will only update whenever the `userSocial` state changes. The `userSocial` state changes only when the `$userInfo.socials` changes. So, when the component uses `$userSocials` instead of `$userInfo.socials`, it will not update when any other part of the `userInfo` state object changes.\nI believe that seeing is believing, and it will be much clearer to see and interact with an example to get this idea forward. So, I’ve prepared some demo examples at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social), and you can try them out and see what I mean.\nLet’s quickly recap the three tips:\n\n*   Whenever the state update logic is complex and convoluted, introduce some state management libraries to enforce simpler and unidirectional data flows\n*   If the state object gets too big, and state changes update more components than needed, break the state object into smaller state objects\n*   If you can’t split a Svelte store state object, consider deriving it into a smaller state object\n\nSo, we’ve gone through my three general tips for managing complex stores in a Svelte application; let’s now elaborate more on my first tip on how to use state management libraries with Svelte.\nUsing state management libraries with Svelte\nIf you google *State management library for frontend development*, at the time of writing, you will get list after list of libraries, such as Redux, XState, MobX, Valtio, Zustand, and many more.\nThese libraries have their own take on how states should be managed, each with different design considerations and design constraints. For the longevity of the content of this book, we are not going to compare and analyze each of them since these libraries will change and evolve over time and potentially be replaced by newer alternatives.\nIt is worth noting that some of the state management libraries are written for a specific web framework. For example, at the time of writing, the Jōtai library ([https://jotai.org/](https://jotai.org/)) is written specifically for React, which means you can only use Jōtai if you write your web application in React.\nOn the other hand, there are framework-agnostic state management libraries. An example is XState ([https://xstate.js.org/](https://xstate.js.org/)), which can be used by any web framework as the XState team has created packages such as `@xstate/svelte` to work with Svelte, `@xstate/react` for the React framework, `@xstate/vue` for Vue, and many more.\nWhile the `@xstate/svelte` package is tailored for seamless integration of XState in Svelte, not all state management libraries offer this level of compatibility. Nevertheless, there are several other state management libraries that you can use in Svelte, and integrating them is straightforward. In fact, I will provide some examples to showcase how simple it is to integrate these libraries in Svelte and utilize Svelte’s first-class capabilities for working with stores.\nOne such state management library that works seamlessly with Svelte is Valtio ([https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio)), a minimalist library that turns objects into self-aware proxy states. We are going to explore how we can use Valtio in Svelte, by turning Valtio’s proxy state into a Svelte store and using the Svelte store’s `$`-prefixed syntax to subscribe to the proxy state changes and access the proxy state value.\nExample – using Valtio as a Svelte store\nBefore we start talking about how to use Valtio in Svelte, let’s look at how to use Valtio on its own.\nUsing Valtio\nValtio turns the object you pass to it into a self-aware proxy state. In the following code snippet, we create a Valtio state named `state` through the `proxy()` method:\n\n```", "```js\n\n To update the proxy state, you can make changes to it the same way you would to a normal JavaScript object. For example, we can increment the value of `state.count` by mutating the value directly, as follows:\n\n```", "```js\n\n To be notified of modifications in the proxy state, we can use Valtio’s `subscribe` method, as illustrated here:\n\n```", "```js\n\n In this case, every time we modify the state, the callback function passed into the `subscribe` method will be called, and we will see a new log in the console, printing `'state` `object changed'`.\nValtio also allows you to subscribe only to a portion of a state. For example, in the following snippet, we subscribe only to the changes made to `state.count`:\n\n```", "```js\n\n Since in this case, we are subscribing only to the changes made to `state.count`, then modifying `state.text` would not see a `'state count changed'` log added to the console as the change to `state.text` is not subscribed.\nThe Valtio proxy state is meant for tracking update changes. To read the latest value of the proxy state, we should use the `snapshot()` method to create a snapshot object, as follows:\n\n```", "```js\n\n Using Valtio as a Svelte store\nNow that we’ve learned about basic Valtio operations and concepts, let’s create a simple counter application to see how we can use Valtio in Svelte. Firstly, we create a proxy state for our counter application:\n\n```", "```js\n\n Here, I am creating two counters, `count1` and `count2`, which will later allow us to experiment with subscribing to a specific portion of the proxy state. This way, we can observe whether our application updates only when one of the counters changes.\nAlso, we are creating the proxy state in a separate file, `data.js`, rather than declaring it inside a Svelte component; this way, we can import the state separately in each Svelte component later on.\nIn addition, let’s create two functions to increment the counters:\n\n```", "```js\n\n Now, let’s import the proxy state into our Svelte component; I have created two buttons to increment each counter separately:\n\n```", "```js\n\n If you try clicking on the buttons, you’ll realize that they are not working as expected— the counters are not incrementing.\nHowever, if you add the following code to `data.js` and click on the button, the console will print out the current value of the counters, indicating that the counters are incrementing successfully:\n\n```", "```js\n\n As you can see, the counters are updating as expected. The issue, therefore, does not lie in the inability to increment the counters, but rather in the failure to display the changes on the screen. It is possible that Svelte is not recognizing the changes to the counters, and therefore, it is not updating the elements to show the latest value of the counters.\nSo, what can we do to make Svelte aware of the changes to Valtio’s proxy state?\nOne approach would be to use a Svelte store, as it provides a mechanism for Svelte components to react to changes in data. We can turn Valtio’s proxy state into a Svelte store. Then, by subscribing to the store, Svelte will be aware of the changes to the state and will update the elements accordingly.\nThis approach of converting states from other state management libraries into a Svelte store in order to take advantage of Svelte’s built-in update mechanism is very common. It allows developers to use their preferred state management solution while still taking advantage of Svelte’s reactive capabilities.\nSo, let’s see how we can turn Valtio’s proxy state into a Svelte store. To start off, I am creating a function called `valtioStateToSvelteStore`:\n\n```", "```js\n\n Before creating the Svelte store from the Valtio proxy state, let’s have a quick recap on what the Svelte store contract is. The Svelte store contract dictates that a Svelte store should have a `subscribe` method and an optional `set` method. The `subscribe` method takes a callback function as its only parameter, which will be called whenever the store’s value changes, and returns an `unsubscribe` function to stop further notifications.\nSo, let’s define the `subscribe` method in the returned object of the `valtioStateToSvelteStore` function, like so:\n\n```", "```js\n\n The initial value of the Svelte store can be defined by calling the callback function synchronously with the value of the proxy state:\n\n```", "```js\n\n Our next step is to subscribe to changes in the Valtio proxy state:\n\n```", "```js\n\n Based on the Svelte store contract, within the `subscribe` method, we need to return a function to unsubscribe the callback function from the Svelte store. In our code, the reason we return the return value of the `subscribe` function from Valtio in our `subscribe` method is that the return value of Valtio’s `subscribe` function is a function to unsubscribe from the proxy state.\nA function to unsubscribe from changes is just what we need. Isn’t this convenient?\nIt’s no coincidence that most state management libraries provide methods for subscribing to state changes and unsubscribing from them, just like what we need to define a Svelte store. This is because both Svelte stores and state management libraries are designed based on the Observer pattern we discussed in [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121). In summary, to turn a state management library’s state into a Svelte store, we need to understand how the library works and how its APIs translate into the Svelte store contract.\nNow that we have a function to transform a Valtio’s proxy state into a Svelte store, let’s try to use it by running the following code:\n\n```", "```js\n\n Clicking on any button in the component, you will see that the counter works perfectly fine now.\nSo, this is how we turn a Valtio proxy state into a Svelte store.\nThe next thing I would like to explore is creating a Svelte store that subscribes only to partial updates of the Valtio proxy state. By selecting only a specific portion of the state to monitor, we can ensure that the Svelte store updates only when a particular part of the state changes.\nBefore we do that, let’s add a few more lines to show you what I mean:\n\n```", "```js\n\n As you click on either of the increment buttons, you will notice that both reactive statements are called, indicating that `$store` is updated whenever either `count1` or `count2` is updated.\nAs discussed in the third tip earlier in the chapter, if state changes cause unnecessary code to run, we can derive a smaller state from the original state to only subscribe to partial updates. So, let’s do that:\n\n```", "```js\n\n Here, instead of turning `state` into a Svelte store, we are turning `state.count1` into a Svelte store. This allows us to create separate Svelte stores that only subscribe to a portion of the proxy state.\nThis should work, but unfortunately, it doesn’t. The reason for this has nothing to do with our code but with the data structure of our state. `state.count1` is a primitive value, which Valtio is unable to subscribe to.\nTo work around this, I’m going to change the data type of `state.count1` from a primitive value to an object:\n\n```", "```js\n\n In the preceding code snippet, we changed `state.count1` to an object with a property called `value`. We still keep the code of deriving the `count1` Svelte store from the `state.count1` proxy state. So, now, the derived Svelte store of `count1` would be an object, and to get the value of the count, we will be referring to `$count1.value` instead of `$count1`:\n\n```", "```js\n\n```"]