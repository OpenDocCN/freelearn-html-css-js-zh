<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-236">
    <a id="_idTextAnchor243">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-237">
    <a id="_idTextAnchor244">
    </a>
    
     Testing with Node.js
    
   </h1>
   <p>
    
     Testing enables you to identify bugs in your code quickly and efficiently.
    
    
     Test cases should be written to verify that each piece of code yields the expected output or results.
    
    
     The added benefit is that these tests can act as a form of documentation for the expected behaviors of
    
    
     
      your applications.
     
    
   </p>
   <p>
    
     Unit testing is a type of testing where individual units of code are tested.
    
    
     Small unit tests provide a granular specification for your program to test against.
    
    
     Ensuring your code base is covered by unit tests aids the development, debugging, and refactoring process by providing a baseline measure of behavior and quality.
    
    
     Having a comprehensive test suite can lead to identifying bugs sooner, which can save time and money since the earlier a bug is found, the cheaper it is
    
    
     
      to fix.
     
    
   </p>
   <p>
    
     This chapter will start by introducing some key techniques with the test runner built into recent versions of Node.js.
    
    
     We’ll also explore some popular testing frameworks.
    
    
     Testing frameworks provide components and utilities such as test runners for running automated tests.
    
    
     The later recipes in this chapter will introduce other testing concepts – including
    
    <strong class="bold">
     
      stubbing
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      user interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      UI
     
    </strong>
    
     ) testing, and how to configure
    
    <strong class="bold">
     
      continuous integration
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       CI
      
     </strong>
    
    
     
      ) testing.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Testing
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        node:test
       
      </strong>
     
    </li>
    <li>
     
      Testing
     
     
      
       with Jest
      
     
    </li>
    <li>
     
      Stubbing
     
     
      
       HTTP requests
      
     
    </li>
    <li>
     
      
       Using Puppeteer
      
     
    </li>
    <li>
     
      Configuring
     
     
      
       CI tests
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-238">
    <a id="_idTextAnchor245">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter assumes that you have Node.js installed, preferably the latest version of Node.js 22.
    
    
     You’ll also need access to an editor and browser of your choice.
    
    
     Throughout the recipes, we’ll be installing modules from the public
    
    
     <strong class="source-inline">
      
       npm
      
     </strong>
    
    
     
      registry.
     
    
   </p>
   <p>
    
     The code for the recipes is available in the book’s GitHub repository (
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     ) in the
    
    
     <strong class="source-inline">
      
       Chapter08
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-239">
    <a id="_idTextAnchor246">
    </a>
    
     Testing with node:test
    
   </h1>
   <p>
    
     Node.js introduced a built-in test runner
    
    <a id="_idIndexMarker609">
    </a>
    
     in version 18 as an experimental feature, subsequently making it stable in version 20.
    
    
     This addition marked a significant shift in the Node.js runtime development philosophy away from the “small core” to adding more utilities into the
    
    
     
      runtime itself.
     
    
   </p>
   <p>
    
     The decision to include a built-in test runner was influenced by a broader industry trend toward including more built-in tooling in programming languages and runtimes.
    
    
     This shift is partly in response to concerns about security, such as the risks associated with dependency vulnerabilities.
    
    
     By providing a native test solution, Node.js aims to make testing a first-class citizen within its environment, reducing the potential attack surface provided by third-party
    
    
     
      test runners.
     
    
   </p>
   <p>
    
     The built-in test runner in Node.js does not have as extensive an API as is provided by the many common and popular test frameworks, such as Jest.
    
    
     It was designed to be a minimal and lightweight, yet functional, testing utility without the overhead of additional features
    
    
     
      and configurations.
     
    
   </p>
   <p>
    
     This tutorial will guide you through the basics of using the Node.js built-in test runner, demonstrating how it can be leveraged to perform effective testing in your projects without the need for a third-party
    
    
     
      test framework.
     
    
   </p>
   <h2 id="_idParaDest-240">
    <a id="_idTextAnchor247">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we’ll create and use a basic calculator application to demonstrate the fundamentals of unit testing with the built-in
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module.
    
    
     Throughout
    
    <a id="_idIndexMarker610">
    </a>
    
     the recipe, we’ll be using the
    
    <strong class="bold">
     
      ECMAScript Module
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ESM
     
    </strong>
    
     ) syntax covered in
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li>
     
      Let’s first create a directory to work in and initialize our
     
     
      
       project directory:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir testing-with-node</strong>
<strong class="bold">$ cd testing-with-node</strong></pre>
    </li>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        calculator.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch calculator.mjs</strong></pre>
    </li>
    <li>
     
      Now, we can add
     
     <a id="_idIndexMarker611">
     </a>
     
      the following to
     
     <strong class="source-inline">
      
       calculator.mjs
      
     </strong>
     
      to create our
     
     
      
       calculator program:
      
     
     <pre class="source-code">
export const add = (number1, number2) =&gt; {
    return number1 + number2;
};
export const subtract = (number1, number2) =&gt; {
    return number1 - number2;
};
export const multiply = (number1, number2) =&gt; {
    return number1 * number2;
};
export const divide = (number1, number2) =&gt; {
    return number1 / number2;
};</pre>
    </li>
   </ol>
   <p>
    
     Now that we have our project directory set up and an application ready to test, we can move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-241">
    <a id="_idTextAnchor248">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be adding
    
    <a id="_idIndexMarker612">
    </a>
    
     unit tests using the built-in
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module for the small calculator application we created in the
    
    <em class="italic">
     
      Getting
     
    </em>
    
     <em class="italic">
      
       ready
      
     </em>
    
    
     
      section.
     
    
   </p>
   <ol>
    <li>
     
      The first step is to ensure we’re using a version of Node.js where the
     
     <strong class="source-inline">
      
       node --test
      
     </strong>
     
      command is available.
     
     
      Enter the following command in your terminal and expect to see the test
     
     
      
       runner execute:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test</strong>
ℹ tests 0
ℹ suites 0
ℹ pass 0
ℹ fail 0
ℹ cancelled 0
ℹ skipped 0
ℹ todo 0
ℹ duration_ms 3.212584</pre>
    </li>
    <li>
     
      Now, we should create a file named
     
     <strong class="source-inline">
      
       calculator.test.mjs
      
     </strong>
     
      , which will contain
     
     
      
       our tests:
      
     
     <pre class="source-code">
<strong class="bold">$ touch calculator.test.mjs</strong></pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       calculator.test.mjs
      
     </strong>
     
      , we first need to import the
     
     
      <strong class="source-inline">
       
        node:test
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
import test from 'node:test';
import assert from 'node:assert';</pre>
    </li>
    <li>
     
      Next, we can import the
     
     <strong class="source-inline">
      
       add()
      
     </strong>
     
      function from our
     
     <strong class="source-inline">
      
       calculator.js
      
     </strong>
     
      program.
     
     
      We’ll only import and test the
     
     <strong class="source-inline">
      
       add()
      
     </strong>
     
      function as
     
     
      
       an example:
      
     
     <pre class="source-code">
import { add } from './calculator.mjs';</pre>
    </li>
    <li>
     
      It can be useful to organize our tests with subtests.
     
     
      To demonstrate this, we’ll create a test parent for the
     
     <strong class="source-inline">
      
       add()
      
     </strong>
     
      function, which we’ll later add our
     
     
      
       subtests to:
      
     
     <pre class="source-code">
test('add', async (t) =&gt; {
});</pre>
    </li>
    <li>
     
      Now, we can write our first test case
     
     <a id="_idIndexMarker613">
     </a>
     
      as a subtest.
     
     
      Our first test will pass integer test values to the
     
     <strong class="source-inline">
      
       add()
      
     </strong>
     
      function and confirm that we get the expected results.
     
     
      Add
     
     
      
       the following:
      
     
     <pre class="source-code">
test('add', async (t) =&gt; {
<strong class="bold">  await t.test('add integers', () =&gt; {</strong>
<strong class="bold">    assert.equal(add(1, 2), 3);</strong>
<strong class="bold">    assert.equal(add(2, 3), 5);</strong>
<strong class="bold">    assert.equal(add(3, 4), 7);</strong>
<strong class="bold">  });</strong>
});</pre>
    </li>
    <li>
     
      Run the tests with the
     
     <strong class="source-inline">
      
       node --test
      
     </strong>
     
      command in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test</strong></pre>
    </li>
    <li>
     
      Next, we can add a second subtest.
     
     
      This time, we’ll pass the numbers as strings rather than integers.
     
     
      This test is expected to fail as our
     
     <strong class="source-inline">
      
       calculator.mjs
      
     </strong>
     
      program does not contain logic to transform string input into integers.
     
     
      Add the following beneath the
     
     
      
       first subtest:
      
     
     <pre class="source-code">
await t.test('add strings', () =&gt; {
  assert.equal(add('1', '2'), 3);
});</pre>
    </li>
    <li>
     
      Now, we can run the tests by entering the following command in our
     
     
      
       terminal window:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test</strong></pre>
    </li>
    <li>
     
      Expect to see the following
     
     <a id="_idIndexMarker614">
     </a>
     
      output indicating that the first test passed and the second
     
     
      
       test failed:
      
     
     <pre class="source-code">
▶ add
  ✔ add integers (0.442953ms)
  ✖ add strings (1.909008ms)
    AssertionError [ERR_ASSERTION]: '12' == 3
        at TestContext.&lt;anonymous&gt; (file:///Users/beth/Node.js-Cookbook/testing-with-node/calculator.test.mjs:14:12)
        at Test.runInAsyncScope (node:async_hooks:206:9)
        at Test.run (node:internal/test_runner/test:639:25)
        at Test.start (node:internal/test_runner/test:550:17)
...</pre>
    </li>
   </ol>
   <p>
    
     We’ve learned how we can write unit tests for our application using the
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module.
    
    
     We’ve executed
    
    <a id="_idIndexMarker615">
    </a>
    
     these tests and produced a
    
    <strong class="bold">
     
      Test Anything Protocol
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TAP
     
    </strong>
    
     ) summary of the
    
    
     
      test results.
     
    
   </p>
   <h2 id="_idParaDest-242">
    <a id="_idTextAnchor249">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the provided example utilizing the
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     built-in module for Node.js, we start by importing the necessary modules using the ESM syntax.
    
    
     This includes
    
    <strong class="source-inline">
     
      test
     
    </strong>
    
     from
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     for testing framework functionalities,
    
    <strong class="source-inline">
     
      assert
     
    </strong>
    
     from
    
    <strong class="source-inline">
     
      node:assert
     
    </strong>
    
     for assertions, and the
    
    <strong class="source-inline">
     
      add()
     
    </strong>
    
     function from a local module,
    
    <strong class="source-inline">
     
      calculator.mjs
     
    </strong>
    
     , which is the function
    
    
     
      under test.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     It’s crucial to import the
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module by using the
    
    <strong class="source-inline">
     
      node:
     
    </strong>
    
     scheme prefix, like this:
    
    <strong class="source-inline">
     
      const test = require('node:test');
     
    </strong>
    
     .
    
    
     This module is one of the first to only be exposed via the
    
    <strong class="source-inline">
     
      node:
     
    </strong>
    
     prefix.
    
    
     Attempting to import it without the
    
    <strong class="source-inline">
     
      node:
     
    </strong>
    
     prefix, as in
    
    <strong class="source-inline">
     
      const test = require('test');
     
    </strong>
    
     , will result in
    
    
     
      an error.
     
    
   </p>
   <p>
    
     The tests are structured
    
    <a id="_idIndexMarker616">
    </a>
    
     using the
    
    <strong class="source-inline">
     
      test()
     
    </strong>
    
     function, where each test case is encapsulated within an asynchronous function.
    
    
     Within each test, subtests are defined using
    
    <strong class="source-inline">
     
      await t.test(...)
     
    </strong>
    
     , which helps organize the tests hierarchically and manage multiple assertions or setup processes cleanly within one test block.
    
    
     For asserting conditions,
    
    <strong class="source-inline">
     
      assert.strictEqual()
     
    </strong>
    
     is employed to compare the expected and actual outcomes, ensuring that both type and value
    
    
     
      are equal.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      node:assert
     
    </strong>
    
     module in Node.js provides a set of assertion functions for verifying invariants, primarily used for writing tests.
    
    
     Key assertions include
    
    <strong class="source-inline">
     
      assert.strictEqual()
     
    </strong>
    
     , which checks for strict equality between the expected and actual values, and
    
    <strong class="source-inline">
     
      assert.deepStrictEqual()
     
    </strong>
    
     , which performs a deep equality comparison of objects and arrays.
    
    
     The module also offers
    
    <strong class="source-inline">
     
      assert.ok()
     
    </strong>
    
     to test if a value is
    
    <strong class="bold">
     
      truthy
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      assert.rejects()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      assert.doesNotReject()
     
    </strong>
    
     for handling promises that should or should not reject.
    
    
     This suite of assertions allows developers to enforce expected behaviors and values in code.
    
    
     A full list of available assertions is detailed
    
    <a id="_idIndexMarker617">
    </a>
    
     in the Node.js assert module
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/docs/latest/api/assert.html#assert">
     
      
       https://nodejs.org/docs/latest/api/assert.html#assert
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To run these tests, the script is executed directly with Node.js by running
    
    <strong class="source-inline">
     
      node --test
     
    </strong>
    
     in the command line.
    
    
     This approach directly outputs the test results to the console, indicating which tests have passed or failed.
    
    
     This method of using Node.js’s built-in testing tools simplifies the testing process by eliminating the need for external libraries – reducing overhead and minimizing
    
    
     
      third-party dependencies.
     
    
   </p>
   <p>
    
     In the recipe, our test results were output using the
    
    <strong class="source-inline">
     
      spec
     
    </strong>
    
     format.
    
    
     When
    
    <a id="_idIndexMarker618">
    </a>
    
     using the
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module with a
    
    <strong class="bold">
     
      terminal interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TTY
     
    </strong>
    
     ), the default output reporter is set to
    
    <strong class="source-inline">
     
      spec
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      spec
     
    </strong>
    
     reporter formats test results in a human-readable manner.
    
    
     If the standard output is not a TTY, the module defaults to using the
    
    <strong class="source-inline">
     
      tap
     
    </strong>
    
     reporter, which outputs the test results in
    
    
     
      TAP format.
     
    
   </p>
   <p>
    
     It’s possible to specify alternate test reporter output using the
    
    <strong class="source-inline">
     
      --test-reporter
     
    </strong>
    
     command-line flag.
    
    
     Details of the available reporters
    
    <a id="_idIndexMarker619">
    </a>
    
     can be found in the Node.js
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters">
     
      
       https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-243">
    <a id="_idTextAnchor250">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     To further enhance your understanding of the core
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module, let’s explore the default file patterns the test runner uses to locate and execute tests, along with additional features that streamline the
    
    
     
      testing process.
     
    
   </p>
   <h3>
    
     Understanding Node.js default test file patterns
    
   </h3>
   <p>
    
     The Node.js test runner
    
    <a id="_idIndexMarker620">
    </a>
    
     automatically finds and runs test files based on their names by looking for files that match specific patterns – essentially, indicators that a file is a test.
    
    
     The patterns use wildcards (
    
    <strong class="source-inline">
     
      *
     
    </strong>
    
     ) and optional groups (
    
    <strong class="source-inline">
     
      ?(...)
     
    </strong>
    
     ) to include various filenames and extensions.
    
    
     The double asterisk (
    
    <strong class="source-inline">
     
      **
     
    </strong>
    
     ) means that Node.js searches all directories and subdirectories, so no matter where your test files are, they’ll be found as long as they match
    
    
     
      the patterns.
     
    
   </p>
   <p>
    
     Here are common patterns the Node.js test runner searches for
    
    
     
      by default:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       **/*.test.?(c|m)js
      
     </strong>
     
      : This finds files ending with
     
     <strong class="source-inline">
      
       .test.js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       .test.cjs
      
     </strong>
     
      , or
     
     <strong class="source-inline">
      
       .test.mjs
      
     </strong>
     
      in
     
     
      
       any directory
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       **/*-test.?(c|m)js
      
     </strong>
     
      : Like the first pattern, but for files ending with
     
     <strong class="source-inline">
      
       -test.js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       -test.cjs
      
     </strong>
     
      ,
     
     
      
       or
      
     
     
      <strong class="source-inline">
       
        -test.mjs
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       **/*_test.?(c|m)js
      
     </strong>
     
      catches files ending with
     
     <strong class="source-inline">
      
       _test.js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       _test.cjs
      
     </strong>
     
      ,
     
     
      
       or
      
     
     
      <strong class="source-inline">
       
        _test.mjs
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       **/test-*.?(c|m)js
      
     </strong>
     
      looks for files starting with
     
     <strong class="source-inline">
      
       test-
      
     </strong>
     
      and ending with
     
     <strong class="source-inline">
      
       .js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       .cjs
      
     </strong>
     
      ,
     
     
      
       or
      
     
     
      <strong class="source-inline">
       
        .mjs
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       **/test.?(c|m)js
      
     </strong>
     
      matches files named exactly
     
     <strong class="source-inline">
      
       test.js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       test.cjs
      
     </strong>
     
      ,
     
     
      
       or
      
     
     
      <strong class="source-inline">
       
        test.mjs
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       **/test/**/*.?(c|m)js
      
     </strong>
     
      digs into any
     
     <strong class="source-inline">
      
       test
      
     </strong>
     
      directory and finds files with
     
     <strong class="source-inline">
      
       .js
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       .cjs
      
     </strong>
     
      , or
     
     <strong class="source-inline">
      
       .mjs
      
     </strong>
     
      extensions in
     
     
      
       any subdirectory
      
     
    </li>
   </ul>
   <p>
    
     To make sure Node.js can find and run your tests without extra configuration, it is advisable to name your test files
    
    <a id="_idIndexMarker621">
    </a>
    
     following these patterns.
    
    
     It keeps your project organized and aligns with common
    
    
     
      Node.js practices.
     
    
   </p>
   <h3>
    
     Filtering tests
    
   </h3>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     module, there
    
    <a id="_idIndexMarker622">
    </a>
    
     are several options for filtering tests to manage which ones are executed during a test run.
    
    
     This flexibility is useful for focusing on specific tests during development
    
    
     
      or debugging:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Skipping tests
      
     </strong>
     
      : Tests can be skipped
     
     <a id="_idIndexMarker623">
     </a>
     
      using the
     
     <strong class="source-inline">
      
       skip
      
     </strong>
     
      option or the test contexts
     
     <strong class="source-inline">
      
       skip()
      
     </strong>
     
      method.
     
     
      This is useful for temporarily disabling a test without removing it from the code base.
     
     
      For example, marking a test with
     
     <strong class="source-inline">
      
       { skip: true }
      
     </strong>
     
      or using
     
     <strong class="source-inline">
      
       t.skip()
      
     </strong>
     
      within the
     
     <strong class="source-inline">
      
       test()
      
     </strong>
     
      function will prevent
     
     
      
       its execution:
      
     
     <pre class="source-code">
test('add strings', { skip : true }, () =&gt; {
  assert.equal(add('1', '2'), 3);
});</pre>
    </li>
    <li>
     <strong class="bold">
      
       Marking tests as todo
      
     </strong>
     
      : When a test is not yet implemented
     
     <a id="_idIndexMarker624">
     </a>
     
      or if it’s known to be flaky, it can be marked as
     
     <strong class="source-inline">
      
       todo
      
     </strong>
     
      .
     
     
      These tests will still run, but their failures won’t count against the test suite’s success.
     
     
      Using the
     
     <strong class="source-inline">
      
       { todo: true }
      
     </strong>
     
      option or
     
     <strong class="source-inline">
      
       t.todo()
      
     </strong>
     
      can annotate these
     
     
      
       tests effectively.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Focusing on specific tests
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       { only: true }
      
     </strong>
     
      option is used
     
     <a id="_idIndexMarker625">
     </a>
     
      to focus on running specific tests, skipping all others not marked with this option.
     
     
      This is particularly useful when needing to isolate a test for scrutiny without running the
     
     
      
       entire suite.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Filtering by test name
      
     </strong>
     
      : Using the
     
     <strong class="source-inline">
      
       --test-name-pattern
      
     </strong>
     
      command-line option, tests can
     
     <a id="_idIndexMarker626">
     </a>
     
      be filtered by their names.
     
     
      This is useful when you want to run a subset of tests that match a specific naming pattern or convention.
     
     
      Patterns are treated as regular expressions.
     
     
      For example, running the test suite with
     
     <strong class="source-inline">
      
       --test-name-pattern="add"
      
     </strong>
     
      would only execute tests with
     
     <strong class="source-inline">
      
       "add"
      
     </strong>
     
      in
     
     
      
       their name.
      
     
    </li>
   </ul>
   <h3>
    
     Collecting code coverage
    
   </h3>
   <p>
    <strong class="bold">
     
      Code coverage
     
    </strong>
    
     is a key metric used to evaluate
    
    <a id="_idIndexMarker627">
    </a>
    
     the extent to which
    
    <a id="_idIndexMarker628">
    </a>
    
     source code is executed during testing, helping developers identify untested parts of their code base.
    
    
     In Node.js, enabling code coverage is straightforward, but it’s important to note that this feature is
    
    
     
      currently experimental.
     
    
   </p>
   <p>
    
     You can enable it by launching
    
    <a id="_idIndexMarker629">
    </a>
    
     Node.js with the
    
    <strong class="source-inline">
     
      --experimental-test-coverage
     
    </strong>
    
     command-line flag.
    
    
     This setup automatically collects coverage statistics, which are reported after all tests are completed.
    
    
     Coverage for Node.js core modules and files within
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directories is not included in
    
    
     
      the report.
     
    
   </p>
   <p>
    
     It’s possible to control which lines are included for code coverage by
    
    
     
      using annotations:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       /* node:coverage disable */
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       /* node:coverage enable */
      
     </strong>
     
      , which exclude specific lines or blocks of code from
     
     
      
       being counted
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       /* node:coverage ignore next */
      
     </strong>
     
      to exclude the
     
     
      
       following line
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       /* node:coverage ignore next n */
      
     </strong>
     
      to exclude the following
     
     
      <strong class="source-inline">
       
        n
       
      </strong>
     
     
      
       lines
      
     
    </li>
   </ul>
   <p>
    
     Coverage results can be summarized by built-in reporters such as
    
    <strong class="source-inline">
     
      tap
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      spec
     
    </strong>
    
     , or detailed through the
    
    <strong class="source-inline">
     
      lcov
     
    </strong>
    
     reporter, which generates a
    
    <strong class="source-inline">
     
      lcov
     
    </strong>
    
     file suitable for
    
    
     
      in-depth analysis.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The current implementation of
    
    <strong class="source-inline">
     
      --experimental-test-coverage
     
    </strong>
    
     has limitations, such as the absence of source map support and the inability to exclude specific files or directories from the
    
    
     
      coverage report.
     
    
   </p>
   <p>
    
     To collect code coverage in the example from the recipe, you can run the
    
    
     
      following command:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ node --test --experimental-test-coverage</strong></pre>
   <p>
    
     Expect to see output like
    
    
     
      the following:
     
    
   </p>
   <div><div><img alt="Figure 8.1 – Terminal window showing a node:test code coverage report" src="img/B19212_08_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1 – Terminal window showing a node:test code coverage report
    
   </p>
   <h2 id="_idParaDest-244">
    <a id="_idTextAnchor251">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Testing with Jest
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Configuring Continuous Integration tests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Writing module code
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-245">
    <a id="_idTextAnchor252">
    </a>
    
     Testing with Jest
    
   </h1>
   <p>
    
     Jest is a widely adopted open source JavaScript
    
    <a id="_idIndexMarker630">
    </a>
    
     testing framework developed by Facebook.
    
    
     It is particularly favored for testing React applications, though its versatility extends to Node.js
    
    <a id="_idIndexMarker631">
    </a>
    
     environments.
    
    
     Jest is an opinionated testing framework with a host of
    
    
     
      bundled features.
     
    
   </p>
   <p>
    
     In this guide, we will explore how to effectively write and structure tests using Jest.
    
    
     You’ll learn the key principles of Jest and how to set up your testing environment.
    
    
     Additionally, we’ll explore Jest’s capabilities in measuring and reporting test coverage to help you understand how well your code base is covered
    
    
     
      by tests.
     
    
   </p>
   <h2 id="_idParaDest-246">
    <a id="_idTextAnchor253">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We will be using Jest to test a program
    
    <a id="_idIndexMarker632">
    </a>
    
     that provides some text
    
    
     
      utility functions.
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create and initialize our
     
     
      
       project directory:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir testing-with-jest</strong>
<strong class="bold">$ cd testing-with-jest</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      We need a program to test.
     
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        textUtils.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch textUtils.js</strong></pre>
    </li>
    <li>
     
      Add the following code
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        textUtils.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
function lowercase (str) {
  return str.toLowerCase();
}
function uppercase (str) {
  return str.toUpperCase();
}
function capitalize (str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() +
    str.slice(1).toLowerCase();
}
module.exports = { lowercase, uppercase, capitalize };</pre>
    </li>
    <li>
     
      We’ll also create a test file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        textUtils.test.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch textUtils.test.js</strong></pre>
    </li>
   </ol>
   <p>
    
     Now that we’ve got our directory
    
    <a id="_idIndexMarker633">
    </a>
    
     and files initialized, we’re ready to move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-247">
    <a id="_idTextAnchor254">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will learn how to write and structure various tests
    
    
     
      with Jest.
     
    
   </p>
   <ol>
    <li>
     
      First, we need to install Jest as a
     
     
      
       development dependency:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install --save-dev jest</strong></pre>
    </li>
    <li>
     
      We’ll also update our
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      test script in our
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      file to call the
     
     <strong class="source-inline">
      
       jest
      
     </strong>
     
      test runner.
     
     
      Change the
     
     <strong class="source-inline">
      
       "test"
      
     </strong>
     
      script field to
     
     
      
       the following:
      
     
     <pre class="source-code">
  "scripts": {
    "test": <strong class="bold">"jest"</strong>
  }</pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       textUtils.test.js
      
     </strong>
     
      , we first need to import our
     
     <strong class="source-inline">
      
       textUtils.js
      
     </strong>
     
      module to enable us to test it.
     
     
      Add the following line to the top of the
     
     
      
       test file:
      
     
     <pre class="source-code">
const { lowercase, uppercase, capitalize } =
  require('./textUtils');</pre>
    </li>
    <li>
     
      Add a Jest
     
     <strong class="source-inline">
      
       describe()
      
     </strong>
     
      block.
     
     
      Jest
     
     <strong class="source-inline">
      
       describe()
      
     </strong>
     
      blocks are used to group and structure our tests.
     
     
      Add
     
     
      
       the following:
      
     
     <pre class="source-code">
describe('textUtils', () =&gt; {
});</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       describe()
      
     </strong>
     
      block, we can start adding our test cases.
     
     
      We use Jest’s
     
     <strong class="source-inline">
      
       test()
      
     </strong>
     
      syntax to define each test.
     
     
      Our test will use Jest’s assertion syntax to verify that when we call our
     
     <strong class="source-inline">
      
       lowercase()
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       uppercase()
      
     </strong>
     
      functions they produce the expected results.
     
     
      Add the following code within the
     
     <strong class="source-inline">
      
       describe()
      
     </strong>
     
      block to create
     
     <a id="_idIndexMarker634">
     </a>
     
      the three
     
     
      
       test cases:
      
     
     <pre class="source-code">
  test('converts "HELLO WORLD" to all lowercase', ()
    =&gt; {
      expect(lowercase('HELLO WORLD')).toBe('hello
        world');
  });
  test('converts "hello world" to all uppercase', ()
    =&gt; {
      expect(uppercase('hello world')).toBe('HELLO
        WORLD');
  });
  test('capitalizes the first letter of "hello"', ()
    =&gt; {
      expect(capitalize('hello')).toBe('Hello');
  });</pre>
    </li>
    <li>
     
      Now, we can run our tests.
     
     
      We can run the test by entering the
     
     <strong class="source-inline">
      
       npm test
      
     </strong>
     
      command in our terminal.
     
     
      Jest will print a summary of our
     
     
      
       test results:
      
     
     <pre class="source-code">
<strong class="bold">$ npm test</strong>
&gt; testing-with-jest@1.0.0 test
&gt; jest
 PASS  ./textUtils.test.js
  textUtils
    ✓ converts "HELLO WORLD" to all lowercase (2 ms)
    ✓ converts "hello world" to all uppercase (1 ms)
    ✓ capitalizes the first letter of "hello"
Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        0.342 s, estimated 1 s
Ran all test suites.</pre>
    </li>
    <li>
     
      Jest provides a built-in code coverage
     
     <a id="_idIndexMarker635">
     </a>
     
      feature.
     
     
      Running this will show us which lines of our program have been covered by the test case.
     
     
      You can enable coverage reporting by passing the
     
     <strong class="source-inline">
      
       --coverage
      
     </strong>
     
      flag to the Jest executable.
     
     
      Enter the following command in your terminal to reference the installed Jest executable and report
     
     
      
       code coverage:
      
     
     <pre class="source-code">
<strong class="bold">$ ./node_modules/jest/bin/jest.js --coverage</strong></pre>
     <p class="list-inset">
      
       Expect to see the
      
      
       
        following output:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 8.2 – Terminal window showing a Jest code coverage report" src="img/B19212_08_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2 – Terminal window showing a Jest code coverage report
    
   </p>
   <p class="list-inset">
    
     Note that the code coverage
    
    <a id="_idIndexMarker636">
    </a>
    
     report states we’ve not covered line 8 in textUtils.js.
    
    
     Note that depending on your code formatting, the specific line number may change.
    
    
     With this information, we can add a test case to satisfy
    
    
     
      this line.
     
    
   </p>
   <ol>
    <li value="8">
     
      Add the following test case to
     
     <strong class="source-inline">
      
       textUtils.test.js
      
     </strong>
     
      to cover the
     
     
      
       missing line:
      
     
     <pre class="source-code">
  test('return empty string as it is', () =&gt; {
    expect(capitalize('')).toBe('');
  });</pre>
    </li>
    <li>
     
      Now, you can rerun the code coverage report with the following command and expect to see our code is now
     
     
      
       100% covered:
      
     
     <pre class="source-code">
<strong class="bold">$ ./node_modules/jest/bin/jest.js --coverage</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve now created a test for our
    
    <strong class="source-inline">
     
      textUtils.js
     
    </strong>
    
     module using Jest and learned how to generate code
    
    
     
      coverage reports.
     
    
   </p>
   <h2 id="_idParaDest-248">
    <a id="_idTextAnchor255">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The first line of our
    
    <strong class="source-inline">
     
      textUtils.test.js
     
    </strong>
    
     file imports our
    
    <strong class="source-inline">
     
      textUtils.js
     
    </strong>
    
     module, allowing
    
    <a id="_idIndexMarker637">
    </a>
    
     us to call it
    
    
     
      when testing.
     
    
   </p>
   <p>
    
     We organized our tests using Jest’s
    
    <strong class="source-inline">
     
      describe()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      test()
     
    </strong>
    
     functions.
    
    
     The
    
    <strong class="source-inline">
     
      describe()
     
    </strong>
    
     function is used to define a collection of tests.
    
    
     The
    
    <strong class="source-inline">
     
      describe()
     
    </strong>
    
     method takes two parameters.
    
    
     The first is a name for the test group, and the second parameter is a callback function, which can contain test cases or nested
    
    
     <strong class="source-inline">
      
       describe()
      
     </strong>
    
    
     
      blocks.
     
    
   </p>
   <p>
    
     Jest’s
    
    <strong class="source-inline">
     
      test()
     
    </strong>
    
     syntax is used to define a test case.
    
    
     The
    
    <strong class="source-inline">
     
      test()
     
    </strong>
    
     method accepts two parameters.
    
    
     The first is the test name, and the second is a callback function that contains the
    
    
     
      test logic.
     
    
   </p>
   <p>
    
     The test logic for this program had just one line, which asserts that when we call
    
    <strong class="source-inline">
     
      uppercase('hello world')
     
    </strong>
    
     , a
    
    <strong class="source-inline">
     
      HELLO WORLD
     
    </strong>
    
     value is returned as expected.
    
    
     The assertion uses Jest’s
    
    <strong class="source-inline">
     
      Expect
     
    </strong>
    
     bundled assertion library (
    
    <a href="https://www.npmjs.com/package/expect">
     
      https://www.npmjs.com/package/expect
     
    </a>
    
     ).
    
    
     We used the
    
    <strong class="source-inline">
     
      toBe()
     
    </strong>
    
     assertion from the
    
    <strong class="source-inline">
     
      Expect
     
    </strong>
    
     library to equate the
    
    
     
      two values.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      Expect
     
    </strong>
    
     exposes many assertion methods, including
    
    <strong class="source-inline">
     
      toBe()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      toContain()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      toThrow()
     
    </strong>
    
     , and others.
    
    
     A full list of assertions is defined in the
    
    <strong class="source-inline">
     
      Expect
     
    </strong>
    
     section of Jest’s API
    
    
     
      documentation
     
    
    <a href="https://jestjs.io/docs/en/expect.html#methods">
     
      
       https://jestjs.io/docs/en/expect.html#methods
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     It’s also possible to invert assertions by adding
    
    <strong class="source-inline">
     
      .not
     
    </strong>
    
     to our statements, as in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
  expect(uppercase('hello')).not.toBe('hello');</pre>
   <p>
    
     To run our test cases, we call the
    
    <strong class="source-inline">
     
      jest
     
    </strong>
    
     test runner, which is located within our
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     directory.
    
    
     The Jest executable runs the tests, automatically looking for files containing
    
    <strong class="source-inline">
     
      test.js
     
    </strong>
    
     .
    
    
     The runner executes our tests and then generates an output summary of
    
    
     
      the results.
     
    
   </p>
   <p>
    
     In the final step of the recipe, we enabled Jest’s code coverage reporting.
    
    
     Code coverage is a measure of how many lines of our program code are touched when executing our tests.
    
    
     100% code coverage means that every line of your program is covered by the test suite.
    
    
     This helps you easily detect bugs introduced by code changes.
    
    
     Some developers and organizations set acceptable thresholds for code coverage and put restrictions in place so that the code coverage
    
    <a id="_idIndexMarker638">
    </a>
    
     percentage cannot
    
    
     
      be regressed.
     
    
   </p>
   <h2 id="_idParaDest-249">
    <a id="_idTextAnchor256">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Jest provides more features
    
    <strong class="bold">
     
      out of the box
     
    </strong>
    
     (
    
    <strong class="bold">
     
      OOTB
     
    </strong>
    
     ) than some of the other popular Node.js test libraries.
    
    
     Let’s look at a couple
    
    
     
      of them.
     
    
   </p>
   <h3>
    
     Setup and teardown
    
   </h3>
   <p>
    
     Jest provides setup
    
    <a id="_idIndexMarker639">
    </a>
    
     and teardown functionality for tests.
    
    
     Setup steps can be run before each or all tests using the
    
    <strong class="source-inline">
     
      beforeEach()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      beforeAll()
     
    </strong>
    
     functions respectively.
    
    
     Similarly, teardown steps can be run after each or all tests with the
    
    <strong class="source-inline">
     
      afterEach()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      afterAll()
     
    </strong>
    
     
      functions respectively.
     
    
   </p>
   <p>
    
     The following pseudocode demonstrates how these functions can
    
    
     
      be used:
     
    
   </p>
   <pre class="source-code">
describe('test', () =&gt; {
  beforeAll(() =&gt; {
    // Runs once before all tests
  });
  beforeEach(() =&gt; {
    // Runs before each test
  });
  afterEach(() =&gt; {
    // Runs after each test
  });
  afterAll(() =&gt; {
    // Runs after all tests
  });
});</pre>
   <h3>
    
     Mocking with Jest
    
   </h3>
   <p>
    
     Mocks enable you to test
    
    <a id="_idIndexMarker640">
    </a>
    
     the interaction of your code or functions without having to execute the code.
    
    
     Mocks are often used in cases where your tests rely on third-party services or APIs, and you do not want to send real requests to these services when running
    
    <a id="_idIndexMarker641">
    </a>
    
     your test suite.
    
    
     There are benefits to
    
    <strong class="bold">
     
      mocking
     
    </strong>
    
     , including faster execution of test suites and ensuring your tests are not going to be impacted by
    
    
     
      network conditions.
     
    
   </p>
   <p>
    
     Jest provides mocking functionality OOTB.
    
    
     We can use a mock to verify that our function has been called with the correct parameters, without executing
    
    
     
      the function.
     
    
   </p>
   <p>
    
     For example, we could change the test from the recipe to mock the
    
    <strong class="source-inline">
     
      uppercase()
     
    </strong>
    
     module with the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
describe('uppercase', () =&gt; {
  test('uppercase hello returns HELLO', () =&gt; {
    uppercase = jest.fn(() =&gt; 'HELLO');
    const result = uppercase('hello');
    expect(uppercase).toHaveBeenCalledWith('hello');
    expect(result).toBe('HELLO');
  });
});</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      jest.fn(() =&gt; 'HELLO');
     
    </strong>
    
     method returns a new mock function.
    
    
     We assign this to a variable named
    
    <strong class="source-inline">
     
      uppercase
     
    </strong>
    
     .
    
    
     The parameter is a callback function that returns the string
    
    <strong class="source-inline">
     
      'HELLO'
     
    </strong>
    
     – this is to demonstrate how we can simulate a function’s
    
    
     
      return value.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      .toHaveBeenCalled()
     
    </strong>
    
     method from
    
    <strong class="source-inline">
     
      Expect
     
    </strong>
    
     verifies that our mock function was called with the correct parameter.
    
    
     If, for some reason, you cannot execute a function in your test suite, you can use mocks to validate that the function
    
    <a id="_idIndexMarker642">
    </a>
    
     is being called with the
    
    
     
      correct parameters.
     
    
   </p>
   <h3>
    
     Testing asynchronous code
    
   </h3>
   <p>
    
     Testing asynchronous code
    
    <a id="_idIndexMarker643">
    </a>
    
     is essential in ensuring that Node.js applications
    
    <a id="_idIndexMarker644">
    </a>
    
     perform as expected, especially when dealing with operations such as API calls, database transactions, or any processes that depend on promise resolution or callbacks.
    
    
     Jest provides a clear and straightforward way to handle these asynchronous operations in your tests, ensuring they complete before
    
    
     
      making assertions.
     
    
   </p>
   <p>
    
     One of the most common methods to test asynchronous code in Jest is by using the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax along with Jest’s
    
    <strong class="source-inline">
     
      .resolves
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      .rejects
     
    </strong>
    
     matchers.
    
    
     For example, consider a
    
    <strong class="source-inline">
     
      fetchData()
     
    </strong>
    
     function that returns a promise resolving to
    
    
     
      some data:
     
    
   </p>
   <pre class="source-code">
function fetchData() {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; resolve('hello'), 1000);
    });
}</pre>
   <p>
    
     You can write a Jest test to verify that
    
    <strong class="source-inline">
     
      fetchData()
     
    </strong>
    
     resolves to the
    
    
     
      expected value:
     
    
   </p>
   <pre class="source-code">
test('data is hello', async () =&gt; {
    await expect(fetchData()).resolves.toBe('hello');
});</pre>
   <p>
    
     This test will wait for the
    
    <strong class="source-inline">
     
      fetchData()
     
    </strong>
    
     promise to resolve, thanks to the
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     keyword, and then check that the resolved value
    
    
     
      matches
     
    
    
     <strong class="source-inline">
      
       'hello'
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Alternatively, if you’re working with asynchronous code that uses callbacks, you can use Jest’s
    
    <strong class="source-inline">
     
      done()
     
    </strong>
    
     callback to handle
    
    
     
      this pattern:
     
    
   </p>
   <pre class="source-code">
function fetchDataCallback(callback) {
    setTimeout(() =&gt; { callback('hello');  }, 1000);
}
test('the data is hello', done =&gt; {
    function callback(data) {
        try {
            expect(data).toBe('hello');
            done();
        } catch (error) {
            done(error);
        }
    }
    fetchDataCallback(callback);
});</pre>
   <p>
    
     In this test,
    
    <strong class="source-inline">
     
      done()
     
    </strong>
    
     is called once the callback receives data, signaling to Jest that the test is complete.
    
    
     If there is an error in your expectation, calling
    
    <strong class="source-inline">
     
      done()
     
    </strong>
    
     with an
    
    <strong class="source-inline">
     
      error
     
    </strong>
    
     argument
    
    <a id="_idIndexMarker645">
    </a>
    
     allows Jest to handle
    
    <a id="_idIndexMarker646">
    </a>
    
     the
    
    
     
      error properly.
     
    
   </p>
   <h2 id="_idParaDest-250">
    <a id="_idTextAnchor257">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Configuring Continuous Integration tests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Writing module code
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-251">
    <a id="_idTextAnchor258">
    </a>
    
     Stubbing HTTP requests
    
   </h1>
   <p>
    
     It is common for the Node.js applications
    
    <a id="_idIndexMarker647">
    </a>
    
     you’re building to rely on and consume an external service or API.
    
    
     When unit testing, you do not typically want your test to send a request to an external service.
    
    
     Requests to the external service you’re consuming are metered or rate-limited, and you do not want your test cases to consume
    
    
     
      the allowance.
     
    
   </p>
   <p>
    
     It’s also possible that your tests would require access to service credentials.
    
    
     This means every developer on the project would need access to those credentials before they could run the
    
    
     
      test suite.
     
    
   </p>
   <p>
    
     To be able to unit test your code
    
    <a id="_idIndexMarker648">
    </a>
    
     without sending a request to an external service, you can fake a request and response.
    
    
     This concept is known as stubbing.
    
    
     Stubbing can be used
    
    <a id="_idIndexMarker649">
    </a>
    
     to mimic API calls, without sending the request.
    
    
     Stubbing comes with the additional benefit of reducing any request latency, potentially making the tests run faster than if they were to send
    
    
     
      real requests.
     
    
   </p>
   <p>
    
     The test concepts of stubbing and mocking are often confused.
    
    
     Stubbing provides predefined responses to isolate the unit under test, while mocking also verifies interactions by ensuring methods are called with
    
    
     
      certain parameters.
     
    
   </p>
   <p>
    
     In the recipe, we will be using Sinon.js, which is a library that provides
    
    
     
      stubbing functionality.
     
    
   </p>
   <h2 id="_idParaDest-252">
    <a id="_idTextAnchor259">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To get started, let’s set up our directories and files for
    
    
     
      this recipe.
     
    
   </p>
   <ol>
    <li>
     
      Create a directory and initialize
     
     
      
       the project:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir stubbing-http-requests</strong>
<strong class="bold">$ cd stubbing-http-requests</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Now, we’ll create a program that sends a request to a third-party service.
     
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        github.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch github.mjs</strong></pre>
    </li>
    <li>
     
      In our
     
     <strong class="source-inline">
      
       github.mjs
      
     </strong>
     
      file, we’ll send an HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request to the
     
     <strong class="source-inline">
      
       https://api.github.com/users/
      
     </strong>
     
      endpoint.
     
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        github.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
export async function getGitHubUser(username) {
  const response = await
    fetch(`https://api.github.com/users/${username}`);
  return response.json();
}</pre>
    </li>
   </ol>
   <p>
    
     Now that we have a program that sends an HTTP request to the GitHub API, we can move on to the recipe steps, where we’ll learn how to stub
    
    
     
      the request.
     
    
   </p>
   <h2 id="_idParaDest-253">
    <a id="_idTextAnchor260">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going
    
    <a id="_idIndexMarker650">
    </a>
    
     to learn how to stub an HTTP request within our tests.
    
    
     But we first need to create a test case.
    
    
     We’ll use
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     to save having to install an additional
    
    
     
      test framework.
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        github.test.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch github.test.mjs</strong></pre>
    </li>
    <li>
     
      Add the following to
     
     <strong class="source-inline">
      
       github.test.mjs
      
     </strong>
     
      to create a test case using
     
     <strong class="source-inline">
      
       node:test
      
     </strong>
     
      for the
     
     <strong class="source-inline">
      
       getGithubUser()
      
     </strong>
     
      function.
     
     
      This will send a real request to the
     
     
      
       GitHub API:
      
     
     <pre class="source-code">
import * as assert from 'node:assert';
import { test } from 'node:test';
import { getGitHubUser } from './github.mjs';
test('Get GitHub user by username', async (t) =&gt; {
  const githubUser = await getGitHubUser('octokit');
  assert.strictEqual(githubUser.id, 3430433);
  assert.strictEqual(githubUser.login, 'octokit');
  assert.strictEqual(githubUser.name, 'Octokit');
});</pre>
    </li>
    <li>
     
      We can run the test to check that
     
     
      
       it passes:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test --test-reporter=tap</strong>
TAP version 13
# Subtest: Get GitHub user by username
ok 1 - Get GitHub user by username
  ---
  duration_ms: 279.80306
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 426.372579</pre>
    </li>
    <li>
     
      Now, we can move
     
     <a id="_idIndexMarker651">
     </a>
     
      on to the
     
     <a href="https://www.npmjs.com/package/sinon">
      
       stubbing.
      
      
       We first
      
      
      
      
       need to instal
      
     </a>
     
      l
     
     <strong class="source-inline">
      
       sinon
      
     </strong>
     
      (
     
     <a href="https://www.npmjs.com/package/sinon">
      
       https://www.npmjs.com/package/sinon
      
     </a>
     
      ) as a
     
     
      
       development dependency:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install --save-dev sinon</strong></pre>
    </li>
    <li>
     
      Then, in
     
     <strong class="source-inline">
      
       github.test.mjs
      
     </strong>
     
      , we need to import
     
     <strong class="source-inline">
      
       sinon
      
     </strong>
     
      .
     
     
      Add the following just below the line where the
     
     <strong class="source-inline">
      
       node:test
      
     </strong>
     
      module
     
     
      
       is imported:
      
     
     <pre class="source-code">
import sinon from 'sinon';</pre>
    </li>
    <li>
     
      To be able to stub the request, we need to store the output from the real request to the GitHub API.
     
     
      In this case, we’ll create a
     
     <strong class="source-inline">
      
       fakeResponse
      
     </strong>
     
      constant to return just the values
     
     <a id="_idIndexMarker653">
     </a>
     
      we’re verifying.
     
     
      Add the following to the start of the
     
     
      
       test case:
      
     
     <pre class="source-code">
  const fakeResponse = Promise.resolve({
    json: () =&gt; Promise.resolve({
      id: 3430433,
      login: 'octokit',
      name: 'Octokit'
    })
  });</pre>
    </li>
    <li>
     
      Next, we need to add a line that instructs the test to use the stubbed
     
     <strong class="source-inline">
      
       fetch()
      
     </strong>
     
      function instead of the
     
     
      
       real function:
      
     
     <pre class="source-code">
  sinon.stub(global, 'fetch').returns(fakeResponse);</pre>
    </li>
    <li>
     
      After we’ve made our
     
     <strong class="source-inline">
      
       getGitHubUser('octokit')
      
     </strong>
     
      call in the test case, we should restore the original
     
     <strong class="source-inline">
      
       fetch()
      
     </strong>
     
      method so that it can be used by other tests or code.
     
     
      We can do this using
     
     <strong class="source-inline">
      
       sinon.restore();
      
     </strong>
     
      .
     
     
      Add this below the line where we
     
     
      
       call
      
     
     
      <strong class="source-inline">
       
        getGitHubUser('octokit')
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Your full
     
     <strong class="source-inline">
      
       github.test.mjs
      
     </strong>
     
      file should now look like
     
     
      
       the following:
      
     
     <pre class="source-code">
import * as assert from 'node:assert';
import { test } from 'node:test';
<strong class="bold">import sinon from 'sinon';</strong>
import { getGitHubUser } from './github.mjs';
test('Get GitHub user by username', async (t) =&gt; {
<strong class="bold">  const fakeResponse = Promise.resolve({</strong>
<strong class="bold">    json: () =&gt; Promise.resolve({</strong>
<strong class="bold">      id: 3430433,</strong>
<strong class="bold">      login: 'octokit',</strong>
<strong class="bold">      name: 'Octokit'</strong>
<strong class="bold">    })</strong>
<strong class="bold">  });</strong>
<strong class="bold">  sinon.stub(global, 'fetch').returns(fakeResponse);</strong>
  const githubUser = await getGitHubUser('octokit');
<strong class="bold">  sinon.restore();</strong>
  assert.strictEqual(githubUser.id, 3430433);
  assert.strictEqual(githubUser.login, 'octokit');
  assert.strictEqual(githubUser.name, 'Octokit');
});</pre>
    </li>
    <li>
     
      Let’s rerun the tests
     
     <a id="_idIndexMarker654">
     </a>
     
      and check whether they still pass now that we’re mocking
     
     
      
       the request:
      
     
     <pre class="source-code">
<strong class="bold">$ node --test --test-reporter=tap</strong>
TAP version 13
# Subtest: Get GitHub user by username
ok 1 - Get GitHub user by username
  ---
  duration_ms: 2.510738
  ...
1..1
# tests 1
# suites 0
# pass 1
# fail 0
# cancelled 0
# skipped 0
# todo 0
# duration_ms 129.078933</pre>
    </li>
   </ol>
   <p>
    
     Note the
    
    <strong class="source-inline">
     
      duration_ms
     
    </strong>
    
     value of this test
    
    <a id="_idIndexMarker655">
    </a>
    
     run is reduced – this is because we are not sending a real request over
    
    
     
      the network.
     
    
   </p>
   <p>
    
     We’ve now learned how to stub an API request
    
    
     
      using Sinon.js.
     
    
   </p>
   <h2 id="_idParaDest-254">
    <a id="_idTextAnchor261">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, Sinon.js is used to simulate the behavior of a function that fetches user data from GitHub’s API.
    
    
     Instead of executing an actual network request, which can be slow and consume limited API request quotas, we substitute the global
    
    <strong class="source-inline">
     
      fetch()
     
    </strong>
    
     method with a “stub.”
    
    
     This
    
    <strong class="source-inline">
     
      stub()
     
    </strong>
    
     function is designed to resolve with a predetermined object that represents a GitHub
    
    
     
      user’s data.
     
    
   </p>
   <p>
    
     Initially, the necessary modules and utilities are imported:
    
    <strong class="source-inline">
     
      node:assert
     
    </strong>
    
     for assertions,
    
    <strong class="source-inline">
     
      node:test
     
    </strong>
    
     to define the test case, and
    
    <strong class="source-inline">
     
      sinon
     
    </strong>
    
     for creating a stub.
    
    
     We also import the
    
    <strong class="source-inline">
     
      getGitHubUser()
     
    </strong>
    
     function we plan
    
    
     
      to test.
     
    
   </p>
   <p>
    
     Sinon.js is used to create a stub for the global
    
    <strong class="source-inline">
     
      fetch()
     
    </strong>
    
     function.
    
    
     The stub is designed to return a fake response that resembles what would be expected from the actual GitHub API.
    
    
     This fake response is a
    
    <em class="italic">
     
      promise
     
    </em>
    
     that resolves to an object with a
    
    <strong class="source-inline">
     
      json()
     
    </strong>
    
     method.
    
    
     This, in turn, returns a promise that resolves to an object containing the
    
    <strong class="source-inline">
     
      id
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      login
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     properties of our test GitHub user – mimicking the format of the GitHub
    
    
     
      API response.
     
    
   </p>
   <p>
    
     When
    
    <strong class="source-inline">
     
      getGitHubUser()
     
    </strong>
    
     is invoked with the
    
    <strong class="source-inline">
     
      octokit
     
    </strong>
    
     username, the stubbed
    
    <strong class="source-inline">
     
      fetch()
     
    </strong>
    
     function intercepts the call and returns a fake response.
    
    
     As a result,
    
    <strong class="source-inline">
     
      getGitHubUser
     
    </strong>
    <strong class="source-inline">
     
      ()
     
    </strong>
    
     processes this response as if it were a real one from the API but without incurring network latency.
    
    
     After the simulated API call, the actual
    
    <strong class="source-inline">
     
      user
     
    </strong>
    
     object is awaited and then checked against the expected values to confirm that the
    
    <strong class="source-inline">
     
      getGitHubUser()
     
    </strong>
    
     function handles the response
    
    
     
      as expected.
     
    
   </p>
   <p>
    
     After the assertions,
    
    <strong class="source-inline">
     
      sinon.restore()
     
    </strong>
    
     is called, which reinstates the original
    
    <strong class="source-inline">
     
      fetch()
     
    </strong>
    
     method.
    
    
     This ensures that subsequent tests or other parts of the code base are not affected by the stubbing of the
    
    <strong class="source-inline">
     
      fetch()
     
    </strong>
    
     method in this test.
    
    
     This practice ensures the isolation of the test and prevents side effects on
    
    
     
      other tests.
     
    
   </p>
   <p>
    
     This recipe provided a high-level view
    
    <a id="_idIndexMarker656">
    </a>
    
     of the stubbing process by demonstrating how to stub a single method with Sinon.js.
    
    
     Stubbing can be used to replace any part of the system under test, from individual functions to entire modules, which can be particularly useful in a microservice architecture where services may depend on responses from
    
    
     
      other services.
     
    
   </p>
   <h2 id="_idParaDest-255">
    <a id="_idTextAnchor262">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Testing with Jest
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Configuring Continuous Integration tests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-256">
    <a id="_idTextAnchor263">
    </a>
    
     Using Puppeteer
    
   </h1>
   <p>
    
     UI testing is a technique
    
    <a id="_idIndexMarker657">
    </a>
    
     used to identify issues with
    
    <strong class="bold">
     
      graphical UIs
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GUIs
     
    </strong>
    
     ), particularly in web
    
    <a id="_idIndexMarker658">
    </a>
    
     applications.
    
    
     Although Node.js is primarily a server-side platform, it is frequently used to develop web applications, where UI testing plays a
    
    
     
      critical role.
     
    
   </p>
   <p>
    
     For example, if you have an application containing an HTML form, you could use UI testing to validate that the HTML form contains the correct set of input fields.
    
    
     UI testing can also validate interactions with the interface – such as simulating button clicks or
    
    
     
      hyperlink activations.
     
    
   </p>
   <p>
    
     Puppeteer is an open source library that provides a headless Chromium instance, which can be programmatically interacted with to automate UI tests.
    
    
     It is particularly useful for Node.js environments because of its native support and ease
    
    
     
      of integration.
     
    
   </p>
   <p>
    
     n the recipe, we will
    
    <a id="_idIndexMarker659">
    </a>
    
     use Puppeteer (
    
    <a href="https://pptr.dev/">
     
      https://pptr.dev/
     
    </a>
    
     ) to perform UI testing on the
    
    <strong class="source-inline">
     
      http://example.com/
     
    </strong>
    
     website.
    
    
     However, other popular alternatives for UI testing in Node.js include Selenium, Cypress, and Playwright.
    
    
     While the high-level principle and purpose of each of these tools are similar, each tool has its strengths and can be chosen based on specific needs such as cross-browser testing, ease of setup, and
    
    
     
      integration capabilities.
     
    
   </p>
   <h2 id="_idParaDest-257">
    <a id="_idTextAnchor264">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Prepare your development
    
    <a id="_idIndexMarker660">
    </a>
    
     environment for Puppeteer by setting up a new project directory and creating an initial
    
    
     
      test file.
     
    
   </p>
   <ol>
    <li>
     
      Create a directory and initialize our
     
     
      
       project directory:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir using-puppeteer</strong>
<strong class="bold">$ cd using-puppeteer</strong>
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      Next, we’ll create our UI
     
     
      
       test file:
      
     
     <pre class="source-code">
<strong class="bold">$ touch test.js</strong></pre>
    </li>
   </ol>
   <p>
    
     Now that we have our project directory initialized, we’re ready to move on to the
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-258">
    <a id="_idTextAnchor265">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn how to test a web page using Puppeteer.
    
    
     We’re going to verify that we receive the expected content from
    
    <strong class="source-inline">
     
      https://example.com
     
    </strong>
    
     .
    
    
     We’ll use the Node.js core
    
    <strong class="source-inline">
     
      assert
     
    </strong>
    
     library for the
    
    
     
      assertion logic.
     
    
   </p>
   <ol>
    <li>
     
      The first step is to install the
     
     <strong class="source-inline">
      
       puppeteer
      
     </strong>
     
      module.
     
     
      We’ll install the
     
     <strong class="source-inline">
      
       puppeteer
      
     </strong>
     
      module as a development dependency as it’ll only be used
     
     
      
       for testing:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install --save-dev puppeteer</strong></pre>
     <p class="list-inset">
      
       Note that this may take a long time as it is downloading the Chromium
      
      
       
        headless browser.
       
      
     </p>
    </li>
    <li>
     
      Next, we’ll open
     
     <strong class="source-inline">
      
       test.js
      
     </strong>
     
      and add the following lines to import both the
     
     <strong class="source-inline">
      
       assert
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        puppeteer
       
      </strong>
     
     
      
       modules:
      
     
     <pre class="source-code">
const assert = require('node:assert');
const puppeteer = require('puppeteer');</pre>
    </li>
    <li>
     
      Next, we’ll create an asynchronous function named
     
     <strong class="source-inline">
      
       runTest()
      
     </strong>
     
      , which will hold all our
     
     
      
       test logic:
      
     
     <pre class="source-code">
async function runTest() {
}</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       runTest()
      
     </strong>
     
      function, we need to launch Puppeteer.
     
     
      Do this by adding the following line, which calls Puppeteer’s
     
     
      <strong class="source-inline">
       
        launch()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
  const browser = await puppeteer.launch();</pre>
    </li>
    <li>
     
      Next, also inside the
     
     <strong class="source-inline">
      
       runTest()
      
     </strong>
     
      function, we need to create a new Puppeteer
     
     
      
       browser page:
      
     
     <pre class="source-code">
  const page = await browser.newPage();</pre>
    </li>
    <li>
     
      We can now instruct Puppeteer to load a URL.
     
     
      We do this by calling the
     
     <strong class="source-inline">
      
       goto()
      
     </strong>
     
      function on the
     
     
      <strong class="source-inline">
       
        page
       
      </strong>
     
     
      
       object:
      
     
     <pre class="source-code">
  await page.goto('https://example.com');</pre>
    </li>
    <li>
     
      Now that we’ve got a handle to the web page (
     
     <strong class="source-inline">
      
       https://example.com
      
     </strong>
     
      ), we can extract values from the web page by calling Puppeteer’s
     
     <strong class="source-inline">
      
       $eval()
      
     </strong>
     
      function.
     
     
      We supply the
     
     <strong class="source-inline">
      
       $eval()
      
     </strong>
     
      function the
     
     <strong class="source-inline">
      
       h1
      
     </strong>
     
      tag, indicating that we want to abstract the
     
     <strong class="source-inline">
      
       h1
      
     </strong>
     
      element and a callback function.
     
     
      The callback function will return the
     
     <strong class="source-inline">
      
       innerText
      
     </strong>
     
      value of the
     
     <strong class="source-inline">
      
       h1
      
     </strong>
     
      element.
     
     
      Add the following line to extract the
     
     
      <strong class="source-inline">
       
        h1
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
  const title = await page.$eval('h1', (el) =&gt;
    el.innerText);</pre>
    </li>
    <li>
     
      Now, we can add our assertion.
     
     
      We expect the title to be
     
     <strong class="source-inline">
      
       "Example Domain"
      
     </strong>
     
      .
     
     
      Add the following assertion statement.
     
     
      We’ll also add a
     
     <strong class="source-inline">
      
       console.log()
      
     </strong>
     
      statement to output the value – you wouldn’t typically do this in a real test case to avoid noise in
     
     <strong class="source-inline">
      
       STDOUT
      
     </strong>
     
      , but it will help us see what
     
     
      
       is happening:
      
     
     <pre class="source-code">
  console.log('Title value:', title);
  assert.equal(title, 'Example Domain');</pre>
    </li>
    <li>
     
      We need to call
     
     <strong class="source-inline">
      
       browser.close()
      
     </strong>
     
      ; otherwise, Puppeteer
     
     <a id="_idIndexMarker661">
     </a>
     
      will continue emulating, and the Node.js process will never exit.
     
     
      Within the
     
     <strong class="source-inline">
      
       runTest()
      
     </strong>
     
      function, add the
     
     
      
       following line:
      
     
     <pre class="source-code">
  browser.close();</pre>
    </li>
    <li>
     
      Finally, we just need to call our
     
     <strong class="source-inline">
      
       runTest()
      
     </strong>
     
      function.
     
     
      Add the following to the bottom of
     
     <strong class="source-inline">
      
       test.js
      
     </strong>
     
      , outside of the
     
     
      <strong class="source-inline">
       
        runTest()
       
      </strong>
     
     
      
       function:
      
     
     <pre class="source-code">
 runTest();</pre>
    </li>
    <li>
     
      We’re now ready to run the test.
     
     
      Enter the following command in your terminal to run
     
     
      
       the test:
      
     
     <pre class="source-code">
<strong class="bold">$ node test.js</strong>
Title value: Example Domain</pre>
    </li>
   </ol>
   <p>
    
     We’ve now created our first UI test
    
    
     
      using Puppeteer.
     
    
   </p>
   <h2 id="_idParaDest-259">
    <a id="_idTextAnchor266">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we used Puppeteer to create a test that verifies that the
    
    <strong class="source-inline">
     
      https://example.com
     
    </strong>
    
     web page returns the heading
    
    <strong class="source-inline">
     
      'Example Domain'
     
    </strong>
    
     within an
    
    <strong class="source-inline">
     
      h1
     
    </strong>
    
     HTML element tag.
    
    
     Most of the Puppeteer APIs are asynchronous, so we used the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     syntax throughout
    
    
     
      the recipe.
     
    
   </p>
   <p>
    
     When we call
    
    <strong class="source-inline">
     
      puppeteer.launch()
     
    </strong>
    
     , Puppeteer initializes a new headless Chrome instance that we can interact with via JavaScript.
    
    
     As testing with Puppeteer has the overhead of a headless Chrome instance, using it for testing can be less performant than other types of tests.
    
    
     However, as Puppeteer is interacting with Chrome under the hood, it provides a very close simulation of how end users interact with a
    
    
     
      web application.
     
    
   </p>
   <p>
    
     Once Puppeteer was launched, we initialized a
    
    <strong class="source-inline">
     
      page
     
    </strong>
    
     object by calling the
    
    <strong class="source-inline">
     
      newPage()
     
    </strong>
    
     method on the
    
    <strong class="source-inline">
     
      browser
     
    </strong>
    
     object.
    
    
     The
    
    <strong class="source-inline">
     
      page
     
    </strong>
    
     object is used to represent a web page.
    
    
     On the
    
    <strong class="source-inline">
     
      page
     
    </strong>
    
     object, we then called the
    
    <strong class="source-inline">
     
      goto()
     
    </strong>
    
     method, which is used to tell Puppeteer which URL should be loaded for
    
    
     
      that object.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      $eval()
     
    </strong>
    
     method is called on the
    
    <strong class="source-inline">
     
      page
     
    </strong>
    
     object to extract values from the web page.
    
    
     In the recipe, we passed the
    
    <strong class="source-inline">
     
      $eval()
     
    </strong>
    
     method
    
    <strong class="source-inline">
     
      h1
     
    </strong>
    
     as the first parameter.
    
    
     This instructs Puppeteer to identify and extract the HTML
    
    <strong class="source-inline">
     
      &lt;h1&gt;
     
    </strong>
    
     element.
    
    
     The second parameter is a callback function, which extracts the
    
    <strong class="source-inline">
     
      innerText
     
    </strong>
    
     value of the
    
    <strong class="source-inline">
     
      &lt;h1&gt;
     
    </strong>
    
     element.
    
    
     For
    
    <strong class="source-inline">
     
      http://example.com
     
    </strong>
    
     , this extracted the
    
    <strong class="source-inline">
     
      'Example
     
    </strong>
    
     <strong class="source-inline">
      
       Domain'
      
     </strong>
    
    
     
      value.
     
    
   </p>
   <p>
    
     At the end of the
    
    <strong class="source-inline">
     
      runTest()
     
    </strong>
    
     function, we called the
    
    <strong class="source-inline">
     
      browser.close()
     
    </strong>
    
     method to instruct Puppeteer to end the Chrome emulation.
    
    
     This was necessary since Puppeteer will continue emulating Chrome with the Node.js process
    
    
     
      never exiting.
     
    
   </p>
   <p>
    
     This is a simplistic example, but it serves
    
    <a id="_idIndexMarker662">
    </a>
    
     as a foundation for understanding how UI testing automation works.
    
    
     This test script is easily extendable, allowing the simulation of more complex user interactions such as form submissions, navigation, and
    
    
     
      error handling.
     
    
   </p>
   <h2 id="_idParaDest-260">
    <a id="_idTextAnchor267">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     It’s also possible to run Puppeteer in non-headless mode.
    
    
     You can do this by passing a parameter to the
    
    
     <strong class="source-inline">
      
       launch()
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <pre class="source-code">
   const browser = await puppeteer.launch({
        headless: false
    });</pre>
   <p>
    
     In this mode, when you run your tests, you will see the Chromium UI and can follow your tests while they are executing.
    
    
     This can be useful when debugging your
    
    
     
      Puppeteer tests.
     
    
   </p>
   <h2 id="_idParaDest-261">
    <a id="_idTextAnchor268">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Testing with Jest
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Configuring Continuous Integration tests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-262">
    <a id="_idTextAnchor269">
    </a>
    
     Configuring Continuous Integration tests
    
   </h1>
   <p>
    
     CI is a development practice
    
    <a id="_idIndexMarker663">
    </a>
    
     where developers regularly merge their code to a source repository.
    
    
     To maintain the integrity of the source code, automated tests will often be run before each code change
    
    
     
      is accepted.
     
    
   </p>
   <p>
    
     GitHub is one of the most widely used source code repository hosts.
    
    
     With GitHub, when you wish to merge a change into the main Git
    
    <a id="_idIndexMarker664">
    </a>
    
     branch or repository, you open a
    
    <strong class="bold">
     
      pull request
     
    </strong>
    
     (
    
    <strong class="bold">
     
      PR
     
    </strong>
    
     ).
    
    
     GitHub provides features for you to configure checks that should run on each PR.
    
    
     It’s common, and good practice, to require a PR to have a passing run of the application’s or module’s unit tests before it can
    
    
     
      be accepted.
     
    
   </p>
   <p>
    
     There are many CI products that can enable the execution of your unit tests (GitHub Actions, Travis CI, and many others).
    
    
     Most of these programs come with a limited free tier for casual developers and paid commercial plans for businesses
    
    
     
      and enterprises.
     
    
   </p>
   <p>
    
     In this recipe, we will learn how to configure GitHub Actions to run our
    
    
     
      Node.js tests.
     
    
   </p>
   <h2 id="_idParaDest-263">
    <a id="_idTextAnchor270">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     For this recipe, you’ll need a GitHub account.
    
    
     If you’re unfamiliar with Git and GitHub, refer to the
    
    <em class="italic">
     
      Scaffolding a module
     
    </em>
    
     recipe in
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To be able to configure GitHub Actions to run unit tests, we first need to create a GitHub repository and some example
    
    
     
      unit tests.
     
    
   </p>
   <ol>
    <li>
     
      Create a new GitHub repository via
     
     <a href="https://github.com/new">
      
       https://github.com/new
      
     </a>
     
      .
     
     
      Name the new repository
     
     <strong class="source-inline">
      
       enabling-actions
      
     </strong>
     
      .
     
     
      Also, add the
     
     <em class="italic">
      
       Node
      
     </em>
     <strong class="source-inline">
      
       .gitignore
      
     </strong>
     
      template via the
     
     
      
       drop-down menu.
      
     
    </li>
    <li>
     
      Clone your GitHub repository with the following command, replacing
     
     <strong class="source-inline">
      
       &lt;username&gt;
      
     </strong>
     
      with your
     
     
      
       GitHub username:
      
     
     <pre class="source-code">
<strong class="bold">$ git clone https://github.com/&lt;username&gt;/enabling-actions.git</strong>
Cloning into 'enabling-actions'...
remote: Enumerating objects: 3, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), done.</pre>
    </li>
    <li>
     
      We now need to initialize
     
     <a id="_idIndexMarker665">
     </a>
     
      our project with
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      and install the
     
     <strong class="source-inline">
      
       tape
      
     </strong>
     
      
       test library:
      
     
     <pre class="source-code">
<strong class="bold">$ cd enabling-actions</strong></pre>
    </li>
    <li>
     
      We also need to create a test.
     
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        test.mjs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch test.mjs</strong></pre>
    </li>
    <li>
     
      Add the following to
     
     <strong class="source-inline">
      
       test.mjs
      
     </strong>
     
      to create our
     
     
      
       unit tests:
      
     
     <pre class="source-code">
import { strictEqual } from 'node:assert';
import { test } from 'node:test';
test('test integer addition', async (t) =&gt; {
  strictEqual(1 + 1, 2, '1 + 1 should equal 2');
});
test('test string addition', async (t) =&gt; {
  // This test is expected to fail because "11" is not numerically 2
  strictEqual('1' + '1', 2, 'Concatenation of "1" and
    "1" does not equal 2');
});</pre>
    </li>
    <li>
     
      Now that we have our project initialized and some unit tests, we can move on to configuring
     
     
      
       GitHub Actions.
      
     
    </li>
   </ol>
   <h2 id="_idParaDest-264">
    <a id="_idTextAnchor271">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to learn
    
    <a id="_idIndexMarker666">
    </a>
    
     how to configure CI to run our unit tests when a new change is pushed to our
    
    
     
      GitHub repository.
     
    
   </p>
   <ol>
    <li>
     
      We need to create a GitHub Actions workflow file in our repository.
     
     
      Create a
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        github/workflows
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
$ mkdir -p .github/workflows
$ touch .github/workflows/test.yml</pre>
    </li>
    <li>
     
      Add the following to the
     
     <strong class="source-inline">
      
       test.yml
      
     </strong>
     
      file.
     
     
      This will instruct GitHub Actions to run our tests using Node.js 20.
     
     
      Be aware that YAML files are sensitive to both whitespace
     
     
      
       and indentation:
      
     
     <pre class="source-code">
name: Node.js CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [ 20.x ]
    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    - run: node --test</pre>
    </li>
    <li>
     
      Now, we’re ready to commit
     
     <a id="_idIndexMarker667">
     </a>
     
      our code.
     
     
      Enter the following in your terminal to commit
     
     
      
       the code:
      
     
     <pre class="source-code">
<strong class="bold">$ git add .github/ test.mjs</strong>
<strong class="bold">$ git commit --message "add workflows and test"</strong>
<strong class="bold">$ git push origin main</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       https://github.com/&lt;username&gt;/enabling-actions
      
     </strong>
     
      in your browser and confirm your code has been pushed to the repository.
     
     
      Expect it to look like
     
     
      
       the following:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.3 – GitHub UI showing the code in the enabling-actions repository" src="img/B19212_08_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3 – GitHub UI showing the code in the enabling-actions repository
    
   </p>
   <ol>
    <li value="5">
     
      Once the test run
     
     <a id="_idIndexMarker668">
     </a>
     
      has completed, GitHub Actions will indicate that the build is failing.
     
     
      This is intentional, as we purposely created a test case that is expected to fail.
     
     
      This is indicated by a red cross icon.
     
     
      When clicking this icon, we’ll see more details about the
     
     
      
       test run:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.4 – Failed GitHub Actions build modal" src="img/B19212_08_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4 – Failed GitHub Actions build modal
    
   </p>
   <ol>
    <li value="6">
     
      Click
     
     <strong class="bold">
      
       Details
      
     </strong>
     
      , and it’ll take you to the
     
     <strong class="bold">
      
       Actions
      
     </strong>
     
      tab for that
     
     
      
       test run:
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 8.5 – GitHub Actions build log" src="img/B19212_08_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.5 – GitHub Actions build log
    
   </p>
   <p>
    
     Observe that we can see the specific
    
    <a id="_idIndexMarker669">
    </a>
    
     step that failed,
    
    <strong class="bold">
     
      Run node --test
     
    </strong>
    
     .
    
    
     You should be able to click on each step to expand and view
    
    
     
      the logs.
     
    
   </p>
   <p>
    
     We’ve successfully enabled GitHub Actions CI on our
    
    
     
      GitHub repository.
     
    
   </p>
   <h2 id="_idParaDest-265">
    <a id="_idTextAnchor272">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the GitHub Actions workflow configuration for a Node.js application, we outlined a specific CI process designed to automate testing upon commits and PRs to the main branch.
    
    
     Here’s a detailed breakdown of how the workflow functions, illustrated with code snippets from the
    
    
     <strong class="source-inline">
      
       test.yml
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     The workflow starts with the definition of event triggers under the
    
    <strong class="source-inline">
     
      on
     
    </strong>
    
     key in the YAML file.
    
    
     It is set to activate on
    
    <strong class="source-inline">
     
      push
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      pull_request
     
    </strong>
    
     events specifically targeting the
    
    
     <strong class="source-inline">
      
       main
      
     </strong>
    
    
     
      branch:
     
    
   </p>
   <pre class="source-code">
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]</pre>
   <p>
    
     This snippet ensures that any code pushed to
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     or any PRs made to
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     will initiate the
    
    
     
      CI process.
     
    
   </p>
   <p>
    
     Next, we define the job environment
    
    <a id="_idIndexMarker670">
    </a>
    
     and specify the Node.js versions to test against using a matrix strategy.
    
    
     This approach allows testing across multiple versions, enhancing
    
    
     
      compatibility verification:
     
    
   </p>
   <pre class="source-code">
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        <strong class="bold">node-version: [20.x, 22.x]</strong></pre>
   <p>
    
     When we use the test matrix to test across multiple versions, we can expect to see an interface similar to
    
    
     
      the following:
     
    
   </p>
   <div><div><img alt="Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22" src="img/B19212_08_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      runs-on: ubuntu-latest
     
    </strong>
    
     step specifies that the job should run on the latest available version of Ubuntu.
    
    
     The
    
    <strong class="source-inline">
     
      matrix.node-version
     
    </strong>
    
     is initially set to test on Node.js 20, but it’s extended to also include Node.js 22, demonstrating how easily additional versions can be incorporated into the
    
    
     
      testing strategy.
     
    
   </p>
   <p>
    
     Following the environment
    
    <a id="_idIndexMarker671">
    </a>
    
     setup, the workflow includes steps to check out the code, setup Node.js, install dependencies, and
    
    
     
      run tests:
     
    
   </p>
   <pre class="source-code">
    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    - run: node --test</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      actions/checkout@v4
     
    </strong>
    
     step checks out the repository contents into the GitHub Actions runner, allowing the workflow to access the code.
    
    
     The
    
    <strong class="source-inline">
     
      actions/setup-node@v4
     
    </strong>
    
     step configures the runner to use a specific version of Node.js as defined by
    
    
     
      the matrix.
     
    
   </p>
   <p>
    
     By integrating these steps, the GitHub Actions
    
    <a id="_idIndexMarker672">
    </a>
    
     workflow automates the testing process, ensuring that all new code integrated into the
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     branch has passed through a rigorous testing process.
    
    
     This not only ensures code quality but also helps in identifying issues early in the development cycle, making it easier to manage and
    
    
     
      fix them.
     
    
   </p>
   <p class="callout-heading">
    
     GitHub branch protection
    
   </p>
   <p class="callout">
    
     It’s possible to configure GitHub to block PRs until they have a passing build/CI run.
    
    
     This can be configured in the settings of your GitHub repository.
    
    
     For information
    
    <a id="_idIndexMarker673">
    </a>
    
     on how to configure branch protection, refer
    
    
     
      to
     
    
    <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches">
     
      
       https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     GitHub Actions, as with the alternative CI providers, offers a powerful and flexible platform for automating workflows across a wide range of development tasks.
    
    
     While this tutorial focused on setting up a CI workflow for a typical Node.js application, the scope of GitHub Actions extends far beyond this, allowing for a multitude of
    
    
     
      complex workflows.
     
    
   </p>
   <h2 id="_idParaDest-266">
    <a id="_idTextAnchor273">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Testing with node:test
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Scaffolding a module
      
     </em>
     
      recipe in
     
     <a href="B19212_05.xhtml#_idTextAnchor139">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>