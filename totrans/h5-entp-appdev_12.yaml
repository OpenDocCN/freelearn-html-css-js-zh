- en: 'Chapter 12. Finishing Up: Testing Your App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 完成工作：测试您的应用
- en: While the subject of testing could span whole books and there are many books
    on the subject indeed, we will offer a framework for testing HTML5 enterprise
    applications as well as an outline of cogent topics that will serve as a point
    of departure for further study. Different testing tools come with their own particular
    set of idioms; we will cover the concepts underlying those idioms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试的主题可能涵盖整本书，实际上也确实有许多关于这个主题的书籍，但我们将提供一个测试HTML5企业应用的框架，以及一系列有说服力的主题概要，这些主题将作为进一步研究的起点。不同的测试工具都带有它们自己的特定习语；我们将涵盖这些习语背后的概念。
- en: 'This chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Unit testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Browser testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: Continuous integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Types of testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'Testing can happen on many different levels. From the code level to integration
    and even testing individual functions of the user-facing implementation of an
    enterprise application, there are numerous tools and techniques to test your application.
    In particular, we will cover the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以在许多不同的层面上进行。从代码级别到集成，甚至测试企业应用程序面向用户的实现中的单个功能，都有许多工具和技术可以测试您的应用程序。特别是，我们将涵盖以下内容：
- en: Unit testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Functional testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Browser testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Black box versus white box testing**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒与白盒测试**'
- en: Testing is often talked about within the context of black box versus white box
    testing. This is a useful metaphor in understanding testing at different levels.
    With black box testing, you look at your application as a black box knowing nothing
    of its internals—typically from the perspective of a user of the system. You simply
    execute functionality of the application and test whether the expected outcomes
    match the actual outcomes. White box differs from black box testing in that you
    know the internals of the application upfront and can thus pinpoint failures directly
    and test for specific conditions. In this case, you simply feed in data into specific
    parts of the system and test whether the expected output matches the actual output.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常在黑盒测试与白盒测试的背景下讨论。这是一个有用的隐喻，有助于理解不同层次的测试。在黑盒测试中，您将您的应用程序视为一个黑盒，对其内部一无所知——通常是从系统用户的角度来看。您只需执行应用程序的功能，并测试预期的结果是否与实际结果相符。白盒测试与黑盒测试的不同之处在于，您事先了解应用程序的内部结构，因此可以直接定位故障并测试特定条件。在这种情况下，您只需向系统的特定部分输入数据，并测试预期的输出是否与实际输出相符。
- en: Unit testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: The first level of testing is at the code level. When you are testing specific
    and individual units of code on whether they meet their stated goals, you are
    unit testing. Unit testing is often talked about in conjunction with test-driven
    development, the practice of writing unit tests first and then writing the minimal
    amount of code necessary to pass those tests. Having a suite of unit tests against
    your code and employing test-driven processes—when done right—can keep your code
    focused and help to ensure the stability of your enterprise application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一级是在代码级别。当您在测试特定的和单个代码单元是否达到其声明的目标时，您正在进行单元测试。单元测试通常与测试驱动开发一起讨论，这是一种先编写单元测试，然后编写通过这些测试所需的最少代码的实践。对您的代码有一套单元测试并采用测试驱动流程——如果做得正确——可以使您的代码保持专注，并有助于确保企业应用程序的稳定性。
- en: 'Typically, unit tests are set up in a separate folder in your codebase. Each
    test case is composed of the following parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单元测试是在代码库中的单独文件夹中设置的。每个测试用例由以下部分组成：
- en: Setup to build the test conditions under which the code or module is being tested
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置构建测试条件，以便在测试代码或模块
- en: An instantiation and invocation of the code or module being tested
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的代码或模块的实例化和调用
- en: A verification of the results returned
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证返回的结果
- en: Setting up your unit test
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置您的单元测试
- en: You usually start by setting up your test data. For example, if you are testing
    a piece of code that requires an authenticated account, you might consider creating
    a set of test users of your enterprise application. It is advisable that your
    test data be coupled with your test so that your tests are not dependent on your
    system being in a specific state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常从设置测试数据开始。例如，如果您正在测试需要认证账户的代码片段，您可能需要考虑创建一组企业应用的测试用户。建议您的测试数据与测试相关联，这样您的测试就不会依赖于系统处于特定状态。
- en: Invoking your target
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用您的目标
- en: Once you have set up your test data and the conditions in which the code you
    are testing needs to run, you are ready to invoke it. This can be as simple as
    invoking a method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了测试数据和测试代码需要运行的条件，你就可以调用它了。这可以简单到调用一个方法。
- en: Mocking is a very important concept to understand when unit testing. Consider
    a set of unit tests for a business logic module that has a dependency on some
    external application programming interface (API). Now imagine if the API goes
    down. The tests would fail. While it is nice to get an indication that the API
    you are dependent upon is having issues, a failing unit test because of this is
    misleading because the goal of the unit test is to test the business logic rather
    than external resources on which you are dependent. This is where mock objects
    come into the picture. Mock objects are stubs that replicate the interface of
    a resource. They are set up to always return the same data the external resource
    would under normal conditions. This way you are isolating your test to just the
    unit of code you are testing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是单元测试时需要理解的一个重要概念。考虑一个业务逻辑模块的单元测试集，该模块依赖于某些外部应用程序编程接口（API）。现在想象一下，如果API崩溃了，测试将失败。虽然得到一个指示，表明你依赖的API存在问题是很不错的，但因为这个原因而失败的单元测试是误导性的，因为单元测试的目标是测试业务逻辑，而不是你依赖的外部资源。这就是模拟对象出现的地方。模拟对象是复制资源接口的存根。它们被设置为在正常条件下总是返回外部资源会返回的相同数据。这样，你就可以将测试隔离到正在测试的代码单元。
- en: Mocking employs a pattern called dependency injection or inversion of control.
    Sure, the code you are testing may be dependent on an external resource. Yet how
    will you swap it in a mock resource? Code that is easy to unit test allows you
    to pass in or "inject" these dependencies when invoking it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟使用了一种称为依赖注入或控制反转的模式。当然，你正在测试的代码可能依赖于外部资源。然而，你将如何用模拟资源替换它？易于单元测试的代码允许你在调用它时传入或“注入”这些依赖。
- en: Dependency injection is a design pattern where code that is dependent on an
    external resource has that dependency passed into it thereby decoupling your code
    from that dependency. The following code snippet is difficult to test since the
    dependency is encapsulated into the function being tested. We are at an impasse.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种设计模式，其中依赖于外部资源的代码将这种依赖传递给它，从而将你的代码与这种依赖解耦。以下代码片段难以测试，因为依赖被封装在正在测试的函数中。我们陷入了僵局。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following new code snippet uses dependency injection to circumvent the
    problem by instantiating the dependency and passing it into the function being
    tested:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下新的代码片段使用依赖注入通过实例化依赖并将其传递给正在测试的函数来绕过问题：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In general, this is good practice not just for unit testing but for keeping
    your code clean and easy to manage. Instantiating a dependency once and injecting
    where it is needed makes it easier to change that dependency if the need occurs.
    There are many mocking frameworks available including JsMockito ([http://jsmockito.org/](http://jsmockito.org/))
    for JavaScript and Mockery ([https://github.com/padraic/mockery](https://github.com/padraic/mockery))
    for PHP.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这不仅是单元测试的良好实践，而且对于保持代码干净和易于管理也是好的。一旦实例化依赖，并在需要的地方注入它，如果需要，就更容易更改该依赖。有许多模拟框架可用，包括JavaScript的JsMockito
    ([http://jsmockito.org/](http://jsmockito.org/)) 和PHP的Mockery ([https://github.com/padraic/mockery](https://github.com/padraic/mockery))。
- en: Verifying the results
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证结果
- en: 'Once you have invoked the code being tested, you need to capture the results
    and verify them. Verification comes in the form of assertions. Every unit testing
    framework comes with its own set of assertion methods, but the concept is the
    same: take a result and test it against an expectation. You can assert whether
    two things are equal. You can assert whether two things are not equal. You can
    assert whether a result is a valid number of a string. You can assert whether
    one value is greater than another. The general idea is you are testing actual
    data against your hypothesis. Assertions usually bubble up to the framework''s
    reporting module and are manifested as a list of passed or failed tests.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你调用了正在测试的代码，你需要捕获结果并验证它们。验证以断言的形式出现。每个单元测试框架都附带自己的断言方法集，但概念是相同的：取一个结果并测试它是否符合预期。你可以断言两个事物是否相等。你可以断言两个事物是否不相等。你可以断言结果是否是有效的数字或字符串。你可以断言一个值是否大于另一个值。一般想法是，你正在测试实际数据是否符合你的假设。断言通常会上升到框架的报告模块，并以通过或失败的测试列表的形式体现。
- en: Frameworks and tools
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架和工具
- en: A bevy of tools have arisen in the past few years that aid in unit testing of
    JavaScript. What follows is a brief survey of notable frameworks and tools used
    to unit test JavaScript code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，出现了许多辅助 JavaScript 单元测试的工具。以下是对一些显著的框架和工具的简要概述，这些工具用于对 JavaScript 代码进行单元测试。
- en: JsTestDriver
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JsTestDriver
- en: JsTestDriver is a framework built at Google for unit testing. It has a server
    that runs on multiple browsers on a machine and will allow you to execute test
    cases in the Eclipse IDE.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JsTestDriver 是一个由 Google 构建的用于单元测试的框架。它有一个在机器上的多浏览器上运行的服务器，并允许你在 Eclipse IDE
    中执行测试用例。
- en: '![JsTestDriver](img/5689_12_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![JsTestDriver](img/5689_12_01.jpg)'
- en: This screenshot shows the results of JsTestDriver. When run, it executes all
    tests configured to run and displays the results.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了 JsTestDriver 的结果。当运行时，它执行所有配置为运行的测试，并显示结果。
- en: More information about JsTestDriver can be found at [http://code.google.com/p/js-test-driver/](http://code.google.com/p/js-test-driver/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JsTestDriver 的更多信息，请参阅 [http://code.google.com/p/js-test-driver/](http://code.google.com/p/js-test-driver/)。
- en: QUnit
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QUnit
- en: QUnit is a JavaScript unit testing framework created by John Resig of jQuery
    fame. To use it, you need to create only a test harness web page and include the
    QUnit library as a script reference. There is even a hosted version of the library.
    Once included, you need to only invoke the test method, passing in a function
    and a set of assertions. It will then generate a nice report.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: QUnit 是由 jQuery 闻名的人物 John Resig 创建的 JavaScript 单元测试框架。要使用它，你需要创建一个测试 harness
    网页，并将 QUnit 库作为脚本引用包含在内。甚至还有一个托管版本的库。一旦包含，你只需要调用测试方法，传入一个函数和一组断言。然后它将生成一份漂亮的报告。
- en: '![QUnit](img/5689_12_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![QUnit](img/5689_12_02.jpg)'
- en: Although QUnit has no dependencies and can test standard JavaScript code, it
    is oriented around jQuery. More information about QUnit can be found at [http://qunitjs.com/](http://qunitjs.com/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 QUnit 没有依赖项，可以测试标准 JavaScript 代码，但它围绕 jQuery 展开。有关 QUnit 的更多信息，请参阅 [http://qunitjs.com/](http://qunitjs.com/)。
- en: Sinon.JS
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sinon.JS
- en: Often coupled with QUnit, Sinon.JS introduces the concept of spying wherein
    it records function calls, the arguments passed in, the return value, and even
    the value of the `this` object. You can also create fake objects such as fake
    servers and fake timers to make sure your code tests in isolation and your tests
    run as quickly as possible. This is particularly useful when you need to make
    fake AJAX requests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与 QUnit 配合使用，Sinon.JS 引入了监视的概念，其中它记录函数调用、传入的参数、返回值，甚至 `this` 对象的值。你还可以创建假对象，如假服务器和假定时器，以确保你的代码在隔离环境中进行测试，并且测试尽可能快地运行。这在需要执行假
    AJAX 请求时尤其有用。
- en: More information about Sinon.JS can be found at [http://sinonjs.org/](http://sinonjs.org/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Sinon.JS 的更多信息，请参阅 [http://sinonjs.org/](http://sinonjs.org/)。
- en: Jasmine
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jasmine
- en: Jasmine is a testing framework based on the concept of behavior-driven development.
    Much akin to test-driven development, it extends it by infusing domain-driven
    design principles and seeks to frame unit tests back to user-oriented behavior
    and business value. Jasmine as well as other behavior-driven design based frameworks
    build test cases—called specs—using as much English as possible so that when a
    report is generated, it reads more naturally than a conventional unit test report.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个基于行为驱动开发概念进行测试的框架。它与测试驱动开发非常相似，通过引入领域驱动设计原则来扩展它，并试图将单元测试框架回归到面向用户的行为和业务价值。Jasmine
    以及其他基于行为驱动的框架使用尽可能多的英语来构建测试用例——称为规范——以便在生成报告时，其阅读起来比传统的单元测试报告更自然。
- en: More information about Jasmine can be found at [http://pivotal.github.com/jasmine/](http://pivotal.github.com/jasmine/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Jasmine 的更多信息，请参阅 [http://pivotal.github.com/jasmine/](http://pivotal.github.com/jasmine/)。
- en: Functional testing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Selenium has become the name in website functional testing. Its browser automation
    capabilities allow you to record test cases in your favorite web browser and run
    them across multiple browsers. When you have this, you can automate your browser
    tests, integrate them with your build and continuous integration server, and run
    them simultaneously to get quicker results when you need them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 已经成为网站功能测试的代名词。它的浏览器自动化功能允许你在你喜欢的网络浏览器中记录测试用例，并在多个浏览器上运行它们。当你拥有这些工具时，你可以自动化你的浏览器测试，将它们与你的构建和持续集成服务器集成，并在需要时同时运行以获得更快的测试结果。
- en: Selenium includes the Selenium IDE, a utility for recording and running Selenium
    scripts. Built as a Firefox add-on, it allows you to create Selenium test cases
    by loading and clicking on web pages in Firefox. You can easily record what you
    do in the browser and replay it. You can then add tests to determine whether actual
    behavior matches expected behavior. It is very useful for quickly creating simple
    test cases for a web application. Information on installing it can be found at
    [http://seleniumhq.org/docs/02_selenium_ide.html](http://seleniumhq.org/docs/02_selenium_ide.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 包含 Selenium IDE，这是一个用于记录和运行 Selenium 脚本的实用工具。作为一个 Firefox 插件构建，它允许你在
    Firefox 中加载和点击网页来创建 Selenium 测试用例。你可以轻松地记录你在浏览器中的操作并回放它们。然后你可以添加测试来确定实际行为是否与预期行为匹配。这对于快速创建
    Web 应用的简单测试用例非常有用。有关安装信息，请参阅 [http://seleniumhq.org/docs/02_selenium_ide.html](http://seleniumhq.org/docs/02_selenium_ide.html)。
- en: The following screenshot shows the Selenium IDE. Click on the red circle graphic
    on the right-hand side to set it to record, and then browse to [http://google.com](http://google.com)
    in the browser window and search for "html5". Click on the red circle graphic
    to stop recording. You can then add assertions to test whether certain properties
    of the page match expectations. In this case, we are asserting that the text of
    the first link in the search results is for the Wikipedia page for HTML5\. When
    we run our test, we see that it passes (of course, if the search results for "html5"
    on Google change, then this particular test will fail).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Selenium IDE。点击右侧的红色圆形图形以开始记录，然后在浏览器窗口中浏览到 [http://google.com](http://google.com)
    并搜索 "html5"。点击红色圆形图形以停止记录。然后你可以添加断言来测试页面的某些属性是否与预期匹配。在这种情况下，我们正在断言搜索结果中第一个链接的文本是
    HTML5 的维基百科页面。当我们运行测试时，我们看到它通过了（当然，如果 Google 上 "html5" 的搜索结果发生变化，那么这个特定的测试将失败）。
- en: '![Functional testing](img/5689_12_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![功能测试](img/5689_12_03.jpg)'
- en: Selenium includes WebDriver, an API that allows you to drive a browser natively
    either locally or remotely. Coupled with its automation capabilities, WebDriver
    can run tests against browsers on multiple remote machines to achieve greater
    scale.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 包含 WebDriver，这是一个 API，允许你本地或远程原生地驱动浏览器。结合其自动化功能，WebDriver 可以在多台远程机器上的浏览器上运行测试，以实现更大的规模。
- en: 'For our MovieNow application, we will set up functional testing by using the
    following components:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 MovieNow 应用程序，我们将通过以下组件设置功能测试：
- en: The Selenium standalone server
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium 独立服务器
- en: The php-webdriver connector from Facebook
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Facebook 的 php-webdriver 连接器
- en: PHPUnit
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit
- en: The Selenium standalone server
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium 独立服务器
- en: 'The Selenium standalone server routes requests to the HTML5 application. It
    needs to be started for the tests to run. It can be deployed anywhere, but by
    default it is accessed at `http://localhost:4444/wd/hub`. You can download the
    latest version of the standalone server at [http://code.google.com/p/selenium/downloads/list](http://code.google.com/p/selenium/downloads/list)
    or you can fire up the version included in the sample code under the `test/lib`
    folder. To start the server, execute the following line via the command line (you
    will need to have Java installed on your machine):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 独立服务器将请求路由到 HTML5 应用程序。为了运行测试，它需要启动。它可以部署在任何地方，但默认情况下，它可以通过 `http://localhost:4444/wd/hub`
    访问。你可以在 [http://code.google.com/p/selenium/downloads/list](http://code.google.com/p/selenium/downloads/list)
    下载独立服务器的最新版本，或者你可以启动 `test/lib` 文件夹中包含的示例代码中的版本。要启动服务器，请在命令行中执行以下行（你需要在你的机器上安装
    Java）：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `#` indicates the version number.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`#` 表示版本号。
- en: 'You should see something akin to the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '![The Selenium standalone server](img/5689_12_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium 独立服务器](img/5689_12_04.jpg)'
- en: At this point, it is listening for connections. You will see log messages here
    as you run your tests. Keep this window open.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，它正在监听连接。当你运行测试时，你将在这里看到日志消息。请保持此窗口打开。
- en: The php-webdriver connector from Facebook
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自 Facebook 的 php-webdriver 连接器
- en: The php-webdriver connector serves as a library for WebDriver in PHP. It gives
    you the ability to make and inspect web requests using drivers for all the major
    web browsers as well as HtmlUnit. Thus it allows you to create test cases against
    any web browser. You can download it at [https://github.com/facebook/php-webdriver](https://github.com/facebook/php-webdriver).
    We have included the files in the `webdriver` folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: php-webdriver 连接器作为 WebDriver 在 PHP 中的库。它允许您使用所有主要网络浏览器的驱动程序以及 HtmlUnit 来创建和检查网络请求。因此，它允许您针对任何网络浏览器创建测试用例。您可以在
    [https://github.com/facebook/php-webdriver](https://github.com/facebook/php-webdriver)
    下载它。我们已将文件包含在 `webdriver` 文件夹中。
- en: PHPUnit
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPUnit
- en: 'PHPUnit is a unit testing framework that provides the constructs necessary
    for running our tests. It has the plumbing necessary for building and validating
    test cases. Any unit testing framework will work with Selenium; we have chosen
    PHPUnit since it is lightweight and works well with PHP. You can download and
    install PHPUnit any number of ways (you can go to [http://www.phpunit.de/manual/current/en/installation.html](http://www.phpunit.de/manual/current/en/installation.html)
    for more information on installing it). We have included the `phpunit.phar` file
    in the `test/lib` folder for your convenience. You can simply run it by executing
    the following via the command line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit 是一个单元测试框架，它为我们提供了运行测试所需的构造。它具有构建和验证测试用例所需的管道。任何单元测试框架都可以与 Selenium 一起工作；我们选择了
    PHPUnit，因为它轻量级且与 PHP 工作良好。您可以通过多种方式下载和安装 PHPUnit（有关安装的更多信息，您可以访问 [http://www.phpunit.de/manual/current/en/installation.html](http://www.phpunit.de/manual/current/en/installation.html)）。我们已将
    `phpunit.phar` 文件包含在 `test/lib` 文件夹中，以便您方便使用。您可以通过在命令行中执行以下操作来简单地运行它：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To begin, we will add some PHP files to the `test` folder. The first file is
    `webtest.php`. Create this file and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `test` 文件夹添加一些 PHP 文件。第一个文件是 `webtest.php`。创建此文件并添加以下代码：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `WebTest` class integrated WebDriver into PHPUnit via the php-webdriver
    connector. This will serve as the base class for all of our test cases. As you
    can see, it starts with the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTest` 类通过 php-webdriver 连接器将 WebDriver 集成到 PHPUnit 中。这将成为我们所有测试用例的基类。如您所见，它以以下内容开始：'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a reference to `__init__.php` in the php-webdriver files. This brings
    in all the classes needed for WebDriver. In the constructor, `WebTest` initializes
    the driver and session objects used in all test cases. In the destructor, it cleans
    up its connections.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 php-webdriver 文件夹中的 `__init__.php` 的引用。这引入了 WebDriver 所需的所有类。在构造函数中，`WebTest`
    初始化所有测试用例中使用的驱动程序和会话对象。在析构函数中，它清理其连接。
- en: 'Now that we have everything set up, we can create our first functional test.
    Add a file called `generictest.php` to the `test` folder. We will import `WebTest`
    and extend that class as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，我们可以创建我们的第一个功能测试。将名为 `generictest.php` 的文件添加到 `test` 文件夹中。我们将导入
    `WebTest` 并扩展该类，如下所示：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside of the `GenericTest` class, add the following test case:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GenericTest` 类内部，添加以下测试用例：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will open a connection to our application (feel free to change the URL to
    wherever you are running your HTML5 application), wait 5 seconds for the initial
    AJAX to load, and then test for whether the `movies-near-me` div is populated
    with data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开到我们应用程序的连接（您可以将 URL 更改为您运行 HTML5 应用程序的地方），等待 5 秒以加载初始 AJAX，然后测试 `movies-near-me`
    div 是否已填充数据。
- en: 'To run this test, go to the command line and execute the following lines:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此测试，请转到命令行并执行以下行：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下内容：
- en: '![PHPUnit](img/5689_12_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![PHPUnit](img/5689_12_05.jpg)'
- en: 'This indicates that the test is passed. Congratulations! Now let us see it
    fail. Add the following test case:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示测试已通过。恭喜！现在让我们看看它失败的情况。添加以下测试用例：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rerun PHPUnit and you should see something akin to the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行 PHPUnit，您应该会看到类似以下的内容：
- en: '![PHPUnit](img/5689_12_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![PHPUnit](img/5689_12_06.jpg)'
- en: As you can see, it was expecting `'Some Title'` but actually found `'MovieNow'`.
    Now that we have gotten you started, we will let you create your own tests. Refer
    to [http://www.phpunit.de/manual/3.7/en/index.html](http://www.phpunit.de/manual/3.7/en/index.html)
    for guidance on the different assertions you can make using PHPUnit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它预期的是 `'Some Title'`，但实际上找到的是 `'MovieNow'`。现在我们已经让您开始了，我们将让您创建自己的测试。有关使用
    PHPUnit 可以做出的不同断言的指南，请参阅 [http://www.phpunit.de/manual/3.7/en/index.html](http://www.phpunit.de/manual/3.7/en/index.html)。
- en: More information about Selenium can be found at [http://seleniumhq.org/](http://seleniumhq.org/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Selenium 的信息可以在 [http://seleniumhq.org/](http://seleniumhq.org/) 找到。
- en: Browser testing
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: With all the talk of browser compatibility in earlier chapters, one pass at
    testing HTML5 enterprise applications must involve actually looking at the application
    on different web browsers. Thankfully, many web browsers are offered on multiple
    platforms. Google Chrome, Mozilla Firefox, and Opera all have versions that will
    install easily on Windows, Mac OSX, and flavors of Linux such as Ubuntu. Safari
    has versions for Windows and Mac OSX, and there are ways to install it on Linux
    with some tweaking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面章节中关于浏览器兼容性的讨论中，对HTML5企业应用程序的测试必须涉及在不同网络浏览器上实际查看应用程序。幸运的是，许多网络浏览器都提供了适用于多个平台的版本。Google
    Chrome、Mozilla Firefox 和 Opera 都有适用于Windows、Mac OSX以及Ubuntu等Linux变种的版本，可以轻松安装。Safari有适用于Windows和Mac
    OSX的版本，并且有方法通过一些调整在Linux上安装。
- en: Nevertheless, Internet Explorer can only run on Windows. One way to work around
    this limitation is to install virtualization software. Virtualization allows you
    to run an entire operating system virtually within a host operating system. It
    allows you to run Windows applications on Mac OSX or Linux applications on Windows.
    There are a number of notable virtualization packages including VirtualBox, VMWare
    Fusion, Parallels, and Virtual PC.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Internet Explorer 只能在Windows上运行。一种绕过这种限制的方法是安装虚拟化软件。虚拟化允许您在宿主操作系统内虚拟运行整个操作系统。它允许您在Mac
    OSX上运行Windows应用程序或在Windows上运行Linux应用程序。包括VirtualBox、VMWare Fusion、Parallels 和
    Virtual PC在内的许多虚拟化软件包都很有名。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Although Virtual PC runs only on Windows, Microsoft does offer a set of prepackaged
    virtual hard drives that include specific versions of Internet Explorer for testing
    purposes. See the following URLs for details: [http://www.microsoft.com/en-us/download/details.aspx?id=11575](http://www.microsoft.com/en-us/download/details.aspx?id=11575).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Virtual PC只运行在Windows上，但微软确实提供了一套预包装的虚拟硬盘，包括用于测试目的的特定版本的Internet Explorer。有关详细信息，请参阅以下URL：[http://www.microsoft.com/en-us/download/details.aspx?id=11575](http://www.microsoft.com/en-us/download/details.aspx?id=11575)。
- en: Another common way to test for compatibility is to use web-based browser virtualization.
    There are a number of services such as BrowserStack ([http://www.browserstack.com/](http://www.browserstack.com/)),
    CrossBrowserTesting ([http://crossbrowsertesting.com/](http://crossbrowsertesting.com/)),
    and Sauce Labs ([https://saucelabs.com/](https://saucelabs.com/)) that offer a
    service whereby you can enter a URL and see it rendered in an assortment of web
    browsers and platforms (including mobile) virtually through the web. Many of them
    even work through a proxy to allow you to view, test, and debug web applications
    running on your local machine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的测试兼容性的方法是使用基于网络的浏览器虚拟化。有许多服务，如BrowserStack ([http://www.browserstack.com/](http://www.browserstack.com/))、CrossBrowserTesting
    ([http://crossbrowsertesting.com/](http://crossbrowsertesting.com/)) 和 Sauce Labs
    ([https://saucelabs.com/](https://saucelabs.com/))，提供了一种服务，您可以通过输入一个URL，在多种网络浏览器和平台上（包括移动设备）虚拟地查看其渲染效果。其中许多服务甚至可以通过代理工作，让您查看、测试和调试在本地机器上运行的网络应用程序。
- en: Continuous integration
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: With any testing solution, it is important to create and deploy your builds
    and run your tests in an automated fashion. Continuous integration solutions like
    Hudson, Jenkins, CruiseControl, and TeamCity allow you to accomplish this. They
    merge code from multiple developers, and run a number of automated functions from
    deploying modules to running tests. They can be invoked to run on a schedule basis
    or can be triggered by events such as a commitment of code to a code repository
    via a post-commit hook.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何测试解决方案中，创建和部署您的构建以及以自动化方式运行测试都是非常重要的。像Hudson、Jenkins、CruiseControl 和 TeamCity
    这样的持续集成解决方案可以帮助您实现这一点。它们合并来自多个开发者的代码，并运行一系列自动化功能，从部署模块到运行测试。它们可以按计划运行，也可以通过事件触发，例如通过post-commit钩子将代码提交到代码库。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered several types of testing in this chapter including unit testing,
    functional testing, and browser testing. For each type of testing, there are many
    tools to help you make sure that your enterprise application runs in a stable
    way, most of which we covered bar a few. Because every minute change to your application
    code has the potential to destabilize it, we must assume that that every change
    does. To ensure that your enterprise applications remain stable and with minimal
    defect, having a testing strategy in place with a rich suite of tests—from unit
    to functional—combined with a continuous integration server running those tests
    is essential. One must, of course, weigh the investment in time for writing and
    executing tests against the time needed for writing production code, but the savings
    in long-term maintenance costs can make that investment worthwhile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多种测试类型，包括单元测试、功能测试和浏览器测试。对于每种测试类型，都有许多工具可以帮助你确保你的企业应用程序以稳定的方式运行，其中大部分我们已经介绍，只有少数例外。因为你的应用程序代码的每一分钟更改都有可能使其不稳定，我们必须假设每一次更改都可能导致不稳定。为了确保你的企业应用程序保持稳定并且缺陷最小，拥有一个包含从单元到功能的丰富测试套件的测试策略，并结合运行这些测试的持续集成服务器是至关重要的。当然，必须权衡编写和执行测试所需的时间与编写生产代码所需的时间，但长期维护成本的节省可以使这种投资变得值得。
- en: In the next chapter, we will cover techniques to ensure your enterprise application
    runs at peak performance including a discussion on profiling.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍确保你的企业应用程序以最佳性能运行的技巧，包括对性能分析技术的讨论。
