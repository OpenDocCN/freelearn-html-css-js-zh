- en: Mastering Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml)<q>, Functional Programming
    Fundamentals</q>, we learned about some of the most fundamental functional programming
    concepts. Functions are one of the fundamental building blocks of any TypeScript
    application, and they are powerful enough to warrant an entire chapter being dedicated
    to them in order to explore their potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to master the usage of functions. The chapter
    starts with a quick recap of a number of basic concepts and then moves on to some
    less commonly known function features and use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function types**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function declarations and function expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Named and anonymous functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with parameters**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with optional parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with default parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with rest parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized overloading signature
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Function scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately-invoked functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag functions and tagged templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that it is possible to explicitly declare the type of an element
    in our application by using optional type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous function, we specified the type of parameter `name` (`string`)
    and its return type (`string`). Sometimes, we will need to specify the types of
    the function, as opposed to specifying the types of its components (arguments
    or returned value). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared the `greetUnnamed` variable and its
    type. The `greetUnnamed` type is a function type that takes a string variable
    called `name` as its only parameter and returns a string after being invoked.
    After declaring the variable, a function, whose type must be equal to the variable
    type, is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also declare the `greetUnnamed` type and assign a function to it in
    the same line, rather than declaring it in two separate lines, as we did in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous example, the preceding code snippet also declares
    a variable, `greetUnnamed`, and its type. `greetUnnamed`  is a function type that
    takes a string variable called `name` as its only parameter and will return a
    string after being invoked. We will assign a function to this variable in the
    same line in which it is declared. The type of the assigned function must match
    the variable type.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have declared the type of the `greetUnnamed`  variable
    and then assigned a function as its value. The type of function can be inferred
    from the assigned function and, for this reason, it is unnecessary to add a redundant
    type annotation. We have done this to facilitate your understanding of this section,
    but it is important to mention that adding redundant type annotations can make
    our code harder to read, and is considered a bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: Named and anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as in JavaScript, TypeScript functions can be created either as a named
    function or as an anonymous function, which allows us to choose the most appropriate
    approach for an application, whether we are building a list of functions in an
    API or a one-off function to hand over to another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, in TypeScript, we can add types
    to each of the parameters and then to the function itself to add a `return` type.
    TypeScript can infer the `return` type by looking at the `return` statements,
    so we can also optionally leave this off in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative syntax for functions that use the `=>` operator after
    the `return` type and don''t use the `function` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have learned about this alternative syntax, we can return to the
    previous example in which we were assigning an anonymous function to the `greet` variable.
    We can now add type annotations to the `greet` variable to match the `anonymous`
    function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the arrow function (`=>`) syntax changes the way the `this` operator
    works when working with classes. We will learn more about this in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet demonstrates how to use type annotations to force
    a variable to be a function with a specific signature. These kinds of annotation
    are commonly used when we annotate a `callback` (a function used as an argument
    of another function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are declaring a function named `add` that takes
    two numbers and a `callback` as a function. The type annotations will force the
    `callback` to return `void` and take a number as its only argument.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations and function expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we introduced the possibility of declaring functions
    with (a named function) or without (an unnamed or anonymous function) explicitly
    indicating their name, but we didn't mention that we were also using two different
    types of function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the named function, `greetNamed`, is a **function
    declaration** while `greetUnnamed` is a **function expression**. For the time
    being, please ignore the first two lines, which contain two `console.log` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We might think that the preceding functions are identical, but they behave differently.
    The JavaScript interpreter can evaluate a function declaration as it is being
    parsed. On the other hand, the `function` expression is part of an assignment
    and will not be evaluated until the assignment has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The primary cause of the different behavior of these functions is a process
    known as variable **hoisting**. We will learn more about the variable hoisting
    process in the *Function scope and hoisting *section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the TypeScript compiler can detect this error and throw a compilation-time
    error. However, if we compile the preceding TypeScript code snippet into JavaScript,
    ignore the compilation errors, and try to execute it in a web browser, we will
    observe that the first `console.log` call works. This is the case because JavaScript
    knows about the declaration function and can parse it before the program is executed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the second alert statement will throw an exception, to indicate that
    `greetUnnamed` is not a function. The exception is thrown because the `greetUnnamed`
    assignment must be completed before the function can be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Working with function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to work with function parameters
    in multiple scenarios, including `optional` parameters, `default` parameters,
    and `rest` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas in function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trailing commas are commas that are used after the final argument of a function.
    Using a comma after the last parameter of a function can be useful because it
    is very common to forget a comma when we modify an existing function by adding
    additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following function only takes one parameter and doesn''t use
    trailing commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Some time after the initial implementation, we might be required to add a parameter
    to the previous function. A common mistake is to declare the new parameter and
    forget to add a comma after the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a trailing comma in the first version of the function could have helped
    us to prevent this common mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a trailing comma eliminates the possibility of forgetting the comma when
    adding a new argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript will throw an error if we forget a comma, so trailing commas are
    not needed as much as they are when working with JavaScript. Trailing commas are
    optional, but using them is considered good practice by many JavaScript and TypeScript
    engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike JavaScript, the TypeScript compiler will throw an error if we attempt
    to invoke a function without providing the exact number and types of parameters
    that its signature declares. Let''s look at a code sample to demonstrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is called `add` and will take three numbers as parameters,
    named `foo`, `bar`, and `foobar`. If we attempt to invoke this function without
    providing exactly three numbers, we will get a compilation error indicating that
    the supplied parameters do not match the function''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are scenarios in which we might want to be able to call the function without
    providing all of its arguments. TypeScript features optional parameters in functions
    to help us to increase the flexibility of our functions and overcome such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can indicate to the TypeScript compiler that we want a function''s parameter
    to be optional by appending the character `?` to its name. Let''s update the previous
    function to transform the required parameter, `foobar`, into an optional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we have changed the `foobar` parameter name into `foobar?` and are
    checking the `foobar` type inside the function to identify whether the parameter
    was supplied as an argument to the function. After implementing these changes,
    the TypeScript compiler will allow us to invoke the function without errors when
    we supply two or three arguments to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the optional parameters must always be located
    after the requisite parameters in the function's parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function has some optional parameters, we must check whether an argument
    has been passed to the function (just like we did in the previous example) to
    prevent potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of scenarios in which it would be more useful to provide
    a default value for a parameter when it is not supplied than to make it an optional
    parameter. Let''s rewrite the `add` function (from the previous section) using
    the inline `if` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing wrong with the preceding function, but we can improve its
    readability by providing a default value for the `foobar` parameter instead of
    using an `optional` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate that a `function` parameter is optional, we need to provide a default
    value using the `=` operator when declaring the function''s signature. After compiling
    the preceding examples, the TypeScript compiler will generate an `if` statement
    in the JavaScript output to set a default value for the `foobar` parameter if
    it is not passed as an argument to the `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is great because the TypeScript compiler generated the code required to
    prevent potential runtime errors for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `void 0` parameter is used by the TypeScript compiler to check whether
    a variable is equal to undefined. While most developers use the `undefined` variable
    to perform this kind of check, most compilers use `void 0` because it will always
    evaluate as undefined. Checking against `undefined` is less secure because its
    value could have been modified, as demonstrated by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Just like `optional` parameters, `default` parameters must always be located
    after any required parameters in the function's parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with rest parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to use `optional` and `default` parameters to increase
    the number of ways that we can invoke a function. Let''s return to the previous
    example one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have learned how to invoke the `add` function with two or three parameters,
    but what if we wanted to allow other developers to pass four or five parameters
    to our function? We would have to add two extra `default` or `optional` parameters.
    And what if we wanted to allow them to pass as many parameters as they need? The
    solution to this possible scenario is the use of `rest` parameters. The `rest`
    parameter syntax allows us to represent an indefinite number of arguments as an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we have replaced the `function`
    parameters `foo`, `bar`, and `foobar`, with just one parameter named `foo`. Note
    that the name of the parameter `foo` is preceded by an ellipsis (a set of three
    periods—not the actual ellipsis character). A `rest` parameter must be of an array
    type, or we will get a compilation error. We can now invoke the `add` function
    with as many parameters as we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although there is no specific limit in the theoretical maximum number of arguments
    that a function can take, there are, of course, practical limits. These limits
    are entirely implementation-dependent and, most likely, will also depend exactly
    on how we are calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions have a built-in object called the `arguments` object. This
    object is available as a local variable named arguments. The `arguments` variable
    contains an object such as an array, which includes the arguments used when the
    function was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` object exposes some of the methods and properties provided by
    a standard array, but not all of them. Refer to the complete reference at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)
    to learn more about its peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the JavaScript output, we will notice that TypeScript iterates
    the `arguments` object to add the values to the `foo` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can argue that this is an extra, unnecessary iteration over the function''s
    parameters. Even though it is hard to imagine this further iteration becoming
    a performance issue, if you think that this could be a problem in terms of the
    performance of your application, you may want to consider avoiding the use of
    `rest` parameters and use an array as the only parameter of the function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes an array of numbers as its only parameter. The
    invocation API will be a little bit different from the `rest` parameters, but
    we will effectively avoid the extra iteration over the function''s argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the parameter-related features that we have
    explored in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Trailing commas | `,` | Used to facilitate adding additional parameters to
    an existing function at a later time. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional parameters | `?` | Used to describe optional arguments. When the
    argument is missed, the value of the parameter is `undefined`. |'
  prefs: []
  type: TYPE_TB
- en: '| Default parameters | `=` | Used to describe optional arguments. When the
    argument is missed, the value of the parameter takes a default value. |'
  prefs: []
  type: TYPE_TB
- en: '| Rest parameters | `...` | Used to describe functions with an unknown number
    of arguments. |'
  prefs: []
  type: TYPE_TB
- en: In the following section, we are going to learn about function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function, or method, overloading is the ability to create multiple methods
    with the same name and a different number of parameters or types. In TypeScript,
    we can overload a function by specifying all function signatures (known as **overload
    signatures**) of a function, followed by a signature (known as the **implementation
    signature**). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding example, we have overloaded the function test
    three times by adding a signature that takes a `string` as its only parameter,
    another function that takes a `number`, and a final signature that takes a `Boolean`
    as its unique parameter. It is important to note that all function signatures
    must be compatible; so, if, for example, one of the signatures tries to return
    a `number` while another tries to return a `string`, we will get a compilation
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Please note that this restriction can be overcome by using a specialized overloaded
    signature, as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation signature must be compatible with all the overloaded signatures,
    always be the last in the list, and take any or a union type as the type of its
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking the function by providing arguments that don''t match any of the types
    declared by the overload signatures will lead to a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Specialized overloading signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a specialized signature to create multiple methods with the same
    name and number of parameters, but a different return type. To create a specialized
    signature, we must indicate the type of function parameter using a string. The
    string literal is used to identify which of the function overloads is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared three **specialized overloaded signatures**
    and one **non-specialized signature** for the function named `createElement`.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a specialized signature in an object, it must be assignable
    to at least one non-specialized signature in the same object. This can be observed
    in the preceding example, as the `createElement` property belongs to a type that
    contains three specialized signatures, all of which are assignable to the non-specialized
    signature in the type.
  prefs: []
  type: TYPE_NORMAL
- en: When writing overloaded declarations, we must list the non-specialized signature
    last.
  prefs: []
  type: TYPE_NORMAL
- en: Function scope and hoisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low-level languages, such as C, have low-level memory management features. In
    programming languages with a higher level of abstraction, such as TypeScript,
    values are allocated when variables are created, and automatically cleared from
    memory when they are no longer used. The process that cleans the memory is known
    as **garbage** **collection** and is performed by the JavaScript runtime garbage
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector does a great job, but it is a mistake to assume that it
    will always prevent us from facing a memory leak. The garbage collector will clear
    a variable from the memory whenever the variable is out of scope. It is important
    to understand how the TypeScript scope works in order for us to understand the
    life cycle of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages use the structure of the program source code to determine
    what variables we are referring to (**lexical scoping**), while others use the
    runtime state of the program stack to determine what variable we are referring
    to (**dynamic scoping**). Most modern programming languages use lexical scoping
    (including TypeScript). Lexical scoping tends to be dramatically easier to understand
    for both humans and analysis tools than dynamic scoping.
  prefs: []
  type: TYPE_NORMAL
- en: 'While, in most lexical-scoped programming languages, variables are scoped to
    a block (a section of code delimited by curly braces `{}`), in TypeScript (and
    JavaScript) variables are scoped to a function, as demonstrated by the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function, named `foo`, contains an `if` structure. We have declared
    a numeric variable named `bar` inside the `if` statement, and later we have attempted
    to show the value of the `bar` variable using the `log` function.
  prefs: []
  type: TYPE_NORMAL
- en: We might think that the preceding code sample would throw an error in the fifth
    line because the `bar` variable should be out of scope when the `log` function
    is invoked. However, if we invoke the `foo` function, the `log` function will
    be able to display the variable `bar` without errors because all variables inside
    a function will be within the scope of the entire function body, even if they
    are inside another block of code (except a function block).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram displays the lexical scope at the function level (left),
    and the lexical scope at the block level (right). As we can see, there is only
    one function, but there are two blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bc4b27a-d287-41ef-84f8-4d0f8ba48f01.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code snippet might seem confusing, but it is easy to understand
    once we know that, at runtime, all the variable declarations are moved to the
    top of a function before the function is executed. This behavior is known as **hoisting**.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is compiled to JavaScript and then executed—this means that a TypeScript
    application is a JavaScript application at runtime and, for this reason, when
    we refer to the TypeScript runtime, we are talking about the JavaScript runtime.
    We will learn in depth about the runtime in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*,
    The Runtime – The Event Loop and The this Operator,* and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*,
    The Runtime – Closures and Prototypes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the preceding code snippet is executed, the runtime will move the declaration
    of the `bar` variable to the top of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This explains why it is possible to use a variable before it is declared. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have declared a function, `foo`, and, in its
    body, we have assigned the value `0` to a variable named `bar`. At this point,
    the variable has not been declared. In the second line, we are declaring the `bar`
    variable and its type. In the last line, we are displaying the value of the `bar`
    variable using the `alert` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since declaring a variable anywhere inside a function (except another function)
    is equivalent to declaring it at the top of the function, the `foo` function is
    transformed into the following at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Developers with a background in programming languages with block scope, such
    as Java or C#, are not used to function scope and it is one of the most criticized
    characteristics of JavaScript. The people in charge of the development of the
    ECMAScript 6 specification are aware of this, and, as a result, they have introduced
    the keywords `let` and `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `let` keyword allows us to set the scope of a variable to a block (`if`,
    `while`, `for`, and so on) rather than a function. We can update the first example
    in this section to showcase how the `let` keyword works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `bar` variable is now declared using the `let` keyword, and, as a result,
    it is only accessible inside the `if` block. The variable is not hoisted to the
    top of the `foo` function and cannot be accessed by the `alert` function outside
    the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'While variables defined with `const` follow the same scope rules as variables
    declared with `let`, they can''t be reassigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to compile the preceding code snippet, we will get an error because
    the `bar` variable is not accessible outside the `if` statement (just like when
    we used the `let` keyword), and a new error occurs when we try to assign a new
    value to the `bar` variable. The second error is caused because it is not possible
    to assign a new value to a constant variable once the variable has already been
    initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Variables declared with the `const` keyword cannot be reassigned, but are not
    immutable. When we say that a variable is immutable, we mean that it cannot be
    modified. We will learn more about immutability in [Chapter 9](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml)*,
    Functional-Reactive Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately-invoked functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **immediately-invoked function expression** (**IIFE**) is a design pattern
    that produces a lexical scope using function scoping. IIFE can be used to avoid
    variable hoisting from within blocks or to prevent us from polluting the global
    scope, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have wrapped the declaration of a variable (`foo`)
    with an IIFE. The `foo` variable is scoped to the IIFE function and is not available
    in the global scope, which explains the error when trying to access it on the
    last line.
  prefs: []
  type: TYPE_NORMAL
- en: The `bar` variable is global. Therefore, it can be accessed from within and
    from outside the IIFE function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a variable to the IIFE to have better control over the creation
    of variables outside its scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, IIFE can help us to simultaneously allow public access to methods
    while retaining privacy for variables defined within the function. Let''s look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a class named `Counter`, which has a private numerical attribute
    named `_i`. The class also has methods to get and set the value of the `_i` private
    property.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, TypeScript and JavaScript developers usually name private variables
    with names preceded by the underscore character (`_`).
  prefs: []
  type: TYPE_NORMAL
- en: We have also created an instance of the `Counter` class and invoked the methods
    `set`, `get`, and `increment` to observe that everything is working as expected.
    If we attempt to access the `_i` property in an instance of `Counter`, we will
    get an error because the variable is private.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile the preceding TypeScript code (only the class definition) and
    examine the JavaScript code generated, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This generated JavaScript code will work perfectly in most scenarios, but if
    we execute it in a browser and try to create an instance of `Counter` and access
    its property `_i`, we will not get any errors because TypeScript will not generate
    runtime private properties for us. Occasionally, we will need to write our classes
    in such a way that some properties are private at runtime, for example, if we
    release a library that will be used by JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use IIFE to simultaneously allow public access to methods while
    retaining privacy for variables defined within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, everything is almost identical to TypeScript's generated
    JavaScript, except that the variable `_i` is now an object in the `Counter` closure
    instead of a property of the `Counter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure remembers the environment (variables
    in the scope) in which it was created. We will discover more about closures in
    [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*, The Runtime – Closures
    and Prototypes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the generated JavaScript output in a browser and try to invoke the
    `_i` property directly, we will notice that the property is now private at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, we will need to have precise control over scope and closures,
    and our code will end up looking much more like JavaScript. If we write our application
    components (classes, modules, and so on) to be consumed by other TypeScript components,
    we will rarely have to worry about implementing runtime private properties. We
    will look in depth at the TypeScript runtime in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*,
    The Runtime – The Event Loop and The this Operator,* and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*,
    The Runtime – Closures and Prototypes.*
  prefs: []
  type: TYPE_NORMAL
- en: Tag functions and tagged templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use template strings such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can use a template string to create a special kind of function known as a
    **tag function**.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a `tag` function to extend or modify the standard behavior of template
    strings. When we apply a `tag` function to a template string, the template string
    becomes a tagged template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a `tag` function named `htmlEscape`. To use a `tag`
    function, we must use the name of the function, followed by a template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A `tag` template must return a string and take the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A `TemplateStringsArray`, which contains all the static literals in the template
    string (`<h1>` and `</h1>` in the preceding example), is passed as the first argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TemplateStringsArray` type is declared by the `lib.d.ts` file. The `lib.d.ts`
    file contains the type declarations of the native JavaScript and browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: A `rest` parameter is passed as the second parameter. The `rest` parameter contains
    all the values in the template string (name and surname in the preceding example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature of a `tag` function appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `htmlEscape` tag function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The template string contains values and literals. The `htmlEscape` function
    iterates through them and ensures that the HTML code is escaped in the values
    to avoid possible code injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of using a tagged function is that it allows us to create custom
    template string processors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot about functions. We have learned about
    different kinds of functions, such as named and anonymous function, and function
    declarations and function expressions. We also learned how to declare different
    types of function signatures as well as how to work with function arguments in
    multiple scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about asynchronous programming techniques.
    We will learn why functions play a very fundamental role in the TypeScript and
    JavaScript asynchronous programming model.
  prefs: []
  type: TYPE_NORMAL
