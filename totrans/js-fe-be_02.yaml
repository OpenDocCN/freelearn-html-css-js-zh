- en: '*Chapter 1*: Exploring the Core Concepts of JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript language was created (in the mid-1990s) to be executed in internet
    browsers, in order to make websites more fluid. It was originally used to control
    what was entered into input forms. For example, it was used to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the entry of numeric characters in a field – and only numeric ones. Other
    characters, for example, letters, had to be rejected in this case. This made it
    possible, thanks to the JavaScript language included in the browser, not to validate
    the entry of the form and avoid sending data to the server, which would have indicated
    an entry error in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the mandatory fields of the form were all entered, by checking all
    the fields before sending the form fields to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two examples (among many others) show that it is desirable to have a language
    that checks the validity of the data entered by the user before sending this data
    to the server. This avoids data transfers from the browser to the server, in the
    event that the data entered is not correct. For more complex checks, such as checking
    that two people do not have the same identifier, this can continue to be done
    on the server because it has access to all existing identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The goal was, therefore, at the beginning of JavaScript, to have the browser
    check as many things as possible and then transmit the information entered to
    the server in order to process it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, an internal browser language was created: the JavaScript language,
    whose name contained a very popular word at the time – “Java” (even though the
    two languages Java and JavaScript had nothing to do with each other).'
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, developers have had the idea of also associating it with the
    server side, to use the same language on the client side and on the server side.
    This allowed the creation of the Node.js server, which is widely used today.
  prefs: []
  type: TYPE_NORMAL
- en: Whether client-side or server-side, the JavaScript language uses a basic syntax
    that allows you to write your own programs. This is what we are going to discover
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables used in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a JavaScript program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring variables in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing conditions for conditional tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating processing loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop in JavaScript, and write and then run the programs in this book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A text editor for computer programs, for example, Notepad++, Sublime Text, EditPlus,
    or Visual Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet browser, for example, Chrome, Firefox, Safari, or Edge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PHP server, for example, XAMPP or WampServer. The PHP server will be used
    to execute JavaScript programs containing `import` statements in HTML pages because
    these `import` statements only work on an HTTP server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Node.js server: The Node.js server will be created through Node.js installation.
    We will also install and use the MongoDB database to associate the Node.js server
    with a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter on GitHub at: [https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%201.zip).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now begin our discovery of JavaScript, by studying the different types
    of variables it offers us.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variables used in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any language, JavaScript allows you to create variables that will be used
    to manipulate data. JavaScript is a very simple language so, for example, data
    types are very basic. We will thus have the following as the main data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Numerical values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a quick look at these different types of data.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numerical values can be positive or negative and even in decimal form (for example,
    0, -10, 10.45). All mathematical numbers called real numbers comprise numerical
    values or data points.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are of course the two Boolean values—true or false—that are found in
    most languages. These values are used to express conditions: if the condition
    is true, then we perform a particular process, otherwise, we perform an alternative
    one. The result of the condition is therefore a true or false value, which is
    symbolized by the two values `true` and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to express conditions in the *Writing conditions* section, later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Character strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Character strings refer to values such as `"a"`, `"abc"`, or `"Hello, how are
    you?"`. An empty character string will be represented by `""` (consecutive quotes
    with nothing inside). Note that you can use double quotes (`"`) or single quotes
    (`'`). Thus, the string `"abc"` can also be written as `'abc'` (with single quotes).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays, such as `[10, "abc", -36]`, can contain values of any type, like here
    where we have both numeric values and character strings. An empty array will be
    represented by `[]`, which means that it contains no value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values stored in an array are accessed by means of an index, varying from
    0 (to access the first element placed in the array) to the length of the array
    minus 1 (to access the last element of the array). So, if the array `[10, "abc",
    -36]` is represented, for example, by the variable `tab`, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tab[0]` will allow access to the first element of the array: `10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tab[1]` will allow access to the second element of the array: `"abc"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tab[2]` will allow access to the third and last element of the array: `-36`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that it is possible to add elements to an array, even if it is empty. So,
    if we access index 3 of the previous array `tab`, we can write `tab[3] = "def"`.
    The array `tab` will therefore now be `[10, "abc", -36, "def"]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects are similar to arrays. They are used to store arbitrary information,
    for example, the values `43`, `"Clinton"`, and `"Bill"`. But unlike arrays that
    use indexes, you must specify a name to access each of these values. This name
    is called the key, which thus allows access to the value it represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose that the previous value `43` is that of a person’s age, while
    `"Clinton"` is their last name, and `"Bill"` is their first name. We would then
    write the object in the following form: `{ age: 43, lastname: "Clinton", firstname:
    "Bill" }`. The definition of the object is done by means of braces, and what is
    indicated inside is pairs of data of the form `key: value` separated by commas.
    This writing format is also called **JavaScript Object Notation** (**JSON**) format.'
  prefs: []
  type: TYPE_NORMAL
- en: So, if the previous object is associated with the variable `person`, we can
    access their age by writing `person["age"]` (which will therefore be `43` here),
    but we can also write `person.age`, which will also be `43`. Similarly, we can
    also write `person.lastname` or `person["lastname"]` and `person.firstname` or
    `person["firstname"]` to access the person’s last name and first name, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The key is also called a property of the object. Thus, the `age` key is also
    called the `age` property. We can choose any name for the key; you just have to
    indicate the key and then use it under this name. So, if you specify `age` as
    a property in the `person` object, you must use the term `age` in the expressions
    `person.age` or `person["age"]`; otherwise it will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you write `person[age]` instead of `person["age"]`, JavaScript
    considers `age` to be a variable with a previously defined value, which it is
    not here and therefore cannot work in this case. You would have to set the `age`
    variable to have the value `"age"` for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of an array are ordered according to their index (starting from
    0, then 1, and so on), while the elements contained in an object are ordered according
    to the keys indicated for each element. But even though the `lastname` key is
    listed in the `person` object before the `firstname` key, this does not differentiate
    the object `{ age: 43, lastname: "Clinton", firstname: "Bill" }` from the object
    `{ firstname: "Bill", lastname: "Clinton", age: 43 }` because the order in which
    keys are written to an object is irrelevant.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are empty objects, such as those containing no key (therefore
    no value). We write an empty object in the form `{ }`, indicating nothing is inside.
    We can then add one or more keys to an object, even if it is initially empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the main variable types used in JavaScript, let’s see
    how to use them to define variables in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Running a JavaScript program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a language that can be executed in a browser (Edge, Chrome, Firefox,
    Safari, and so on) or on a server with Node.js installed. Let’s see how to write
    JavaScript programs for these two types of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Running a JavaScript program in a browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run a JavaScript program in a browser, you must insert the JavaScript code
    into an HTML file. This HTML file will then be displayed in the browser, which
    will cause the execution of the JavaScript code included in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript code can be specified in the HTML file in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to write it between the `<script>` and `</script>` tags, directly
    in the HTML file. The `<script>` tag indicates the beginning of the JavaScript
    code, while the `</script>` tag indicates the end of it. Anything written between
    these two tags is considered JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is to write the JavaScript code in an external file and then
    include this external file in the HTML file. The external file is included in
    the HTML file by means of a `<script>` tag in which the `src` attribute is indicated,
    the value of which is the name of the JavaScript file that will be included in
    the HTML page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at these two ways of writing the JavaScript code that will
    run in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript code between the <script> and </script> tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A file with an `.html` extension is used; for example, the `index.html` file.
    This file is a traditional HTML file, in which we have inserted the `<script>`
    and `</script>` tags, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have inserted the `<script>` tag (and its ending `</script>`) in the `<head>`
    section of the HTML page. The `<meta>` tag is used to indicate the encoding characters
    to use. In the preceding code, we have used `utf-8` so that accented characters
    can be displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code inserted here is rudimentary. We use the `alert()` function,
    which displays a dialog box on the browser screen, displaying the text of the
    message indicated in the first parameter of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this HTML file, simply move it (by dragging and dropping) from the file
    manager to any browser; for example, Firefox. The following screen is then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Displaying a message in the browser window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Displaying a message in the browser window
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code present in the `<script>` tag ran when the HTML page was
    loaded. The message indicated in the `alert()` function is therefore displayed.
    A click on the **OK** button validates the message displayed and continues the
    execution of the JavaScript code. As we can see, there is nothing more in the
    program; the program ends immediately by displaying a blank page on the screen
    (because no HTML code is inserted into the page).
  prefs: []
  type: TYPE_NORMAL
- en: Writing JavaScript code to an external file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than integrating the JavaScript code directly into the HTML file, we
    can put it in an external file, then insert this file into our HTML file by indicating
    its name in the `src` attribute of the `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first write the file that will contain the JavaScript code. This file
    has the file extension `.js` and will be named `codejs.js`, for example, and will
    be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: codejs.js file (in the same directory as index.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `codejs.js` file contains the JavaScript code that we had previously inserted
    between the `<script>` and `</script>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `index.html` file is modified to include the `codejs.js` file using the
    `src` attribute of the `<script>` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `<script>` and `</script>` tags. They are contiguous (that
    is, they have no spaces or newlines between them), which is necessary for this
    code to work.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of our examples, we will mainly use the insertion of the JavaScript
    code directly in the code of the HTML file, but the use of an external file would
    produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explain another way to display messages, without blocking the program
    as before with the `alert(message)` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the console.log() method instead of the alert() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `alert()` function used earlier displays a window on the HTML page, and
    the JavaScript program hangs waiting for the user to click the **OK** button in
    the window. Thus, the function requires the intervention of the user to continue
    the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative makes it possible to use a display without blocking the execution
    of the program. This is the display in the console, using the `console.log()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `console.log()` form of writing means that we use the `log()` method, which
    is associated with the `console` object. This will be explained in detail in the
    following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the program again using the `console.log()` method instead of the
    `alert()` function. The `index.html` file will be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html file using console.log() method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The use of comments in the JavaScript program requires placing `//` before what
    needs to be commented out (on the same line). You can also comment out several
    lines by enclosing them with `/*` at the beginning and `*/` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run this program by pressing the *F5* key on the keyboard to refresh the
    window. A white screen will appear, with no message.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the message is only displayed in the console. The console is only visible
    if you press the *F12* key (and can be removed by pressing *F12* again).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can go to the site [https://balsamiq.com/support/faqs/browserconsole/](https://balsamiq.com/support/faqs/browserconsole/),
    which explains how to display the console in the event that the *F12* key is inoperative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what you will see when the console is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Message displayed in the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Message displayed in the console
  prefs: []
  type: TYPE_NORMAL
- en: The message is displayed in the lower part of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to run a JavaScript program in a browser, let’s
    move on to learning how to run a JavaScript program on a Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: Running a JavaScript program on a Node.js server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run a JavaScript program on a Node.js server, you must first install the
    Node.js server. To install, simply go to [https://nodejs.org/](https://nodejs.org/)
    and download and install the server. Note that if you are using macOS, Node.js
    is already installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify the correct installation of Node.js by just opening a shell and
    typing the command `node -h` in it. Node.js is correctly installed if the command
    help appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – node -h command that displays help'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – node -h command that displays help
  prefs: []
  type: TYPE_NORMAL
- en: Once Node.js is installed, it can run any JavaScript program you want. All you
    have to do is create a file containing JavaScript code, for example, `testnode.js`.
    The contents of this file will be executed by the server using the `node testnode.js`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple example of a JavaScript file that can be executed by
    Node.js: It displays a message in the server console. The server console here
    represents the command interpreter in which you type the command to execute the
    `testnode.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: testnode.js file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let’s type the command `node testnode.js` in the preceding terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Running a Node.js program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Running a Node.js program
  prefs: []
  type: TYPE_NORMAL
- en: We see that the message is displayed directly in the command interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we have written JavaScript code that runs both on
    the client side (the browser) and on the server side. The question that can be
    asked is: can the same code run in exactly the same way on the client side and
    on the server side?'
  prefs: []
  type: TYPE_NORMAL
- en: Differences between JavaScript code written for the browser and the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the two pieces of code are similar, we cannot say that they are the
    same, because the issues to be managed are different in the two cases. Indeed,
    on the client side, we will mainly want to manage the user interface with JavaScript,
    while on the server side, we will rather want to manage files or databases. So,
    the libraries to use in these two cases will not be the same.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we find in both cases the same basic language, which is the
    JavaScript language that we will be describing now.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables of the types previously described under the *Types of variables used
    in JavaScript* section, as we know, consist of numerical values, Boolean values,
    character strings, arrays, and objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a weakly typed language, which means that you can change the type
    of a variable at any time. For example, a numeric variable can be transformed
    into a character string, or even become an array.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not advisable to make such voluntary changes in our programs,
    and it is prudent to maintain the type of a variable throughout the program, for
    comprehension. However, it is important to know that JavaScript allows changing
    variable types. A variant of JavaScript called *TypeScript* provides more security
    by preventing these type changes for variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s learn how to define a variable. We will do so using one of the following
    keywords: `const`, `var`, or `let`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the const keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` keyword is used to define a variable whose value will be constant.
    Any subsequent attempt to change the value will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the constant variable `c1` having the value `12`. Let’s try to
    modify the value by assigning it a new value: an error will be displayed in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To say that we are defining a constant variable is an abuse of language. We
    should rather say that we are defining a constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a constant value (index.html file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After implementing the preceding code, we will also see the error displayed
    in the console (if the console is not visible, it can be displayed by pressing
    the *F12* key) of the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Error when modifying a constant value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Error when modifying a constant value
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding figure, the first display of the constant `c1`
    displays the value `const` keyword should not be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Using the var keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to define a variable (whose value can be modified) is to use the
    `var` keyword. Let’s see how using the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: Definitions of several variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We defined the variables `a`, `b`, `s1`, and `firstname` by preceding them with
    the keyword `var` and assigning them a default value. The variable `c` corresponds
    to the addition of the variables `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The name of a variable consists of alphanumeric characters but must start with
    an alphabetic character. Lowercase and uppercase are important in writing the
    variable name (variables’ names are case sensitive). Thus, the variable `a` is
    different from the variable `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the previous program is displayed in the browser console (if
    it is not visible, it must be displayed by pressing the *F12* key):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Using the var keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.6_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Using the var keyword
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see a result that may seem surprising. Indeed,
    the direct calculation of `a + b` produces the display of **1256** the first time,
    then **68** the second time.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, when we write `console.log("a + b = " + a + b);` the fact that we’ve
    started to display characters by writing `"a + b = "` means that JavaScript will
    interpret the rest of the display in the form of a character string; in particular,
    the values `a` and `b`, which follow on the line. So, the values `a` and `b` are
    no longer interpreted as numeric values, but as the character strings `12` and
    `56`. When these character strings are connected by the `+` operator, this does
    not correspond to addition but to concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the calculation of the variable `c` does not involve character strings,
    so the result of `a + b` here is equal to the sum of the values of the variables
    `a` and `b`, therefore **68**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same program can be run on the Node.js server. To do so, we would
    write it in our `testnode.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: testnode.js file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then execute the preceding code with the `node testnode.js` command.
    The result displayed under Node.js is similar to that displayed in the browser
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Running the program under Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.7_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Running the program under Node.js
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the `const` and `var` keywords for defining variables; all
    that remains is for us to learn how to use the `let` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Using the let keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the use of the `let` keyword and see the difference from the `var`
    keyword, we must use braces in our programs. Braces are used to create program
    blocks in which instructions are inserted, in particular after the conditional
    `if` and `else` instructions (which we will see in the *Writing conditions* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a simple `if(true)` condition that is always `true`: the code included
    in the braces following the condition is therefore always executed:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html file including a condition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined the variable `a` outside of any braces.
    This variable will therefore be accessible everywhere (in and out of braces) as
    soon as it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: The variables `b` and `c` are defined within braces following the condition.
    Variable `b` is defined using `var`, while variable `c` is defined using the `let`
    keyword. The difference between the two variables is visible as soon as you exit
    the block of braces. Indeed, the variable `c` (defined by `let`) is no longer
    known outside the block of braces where it is defined, unlike the variable `b`
    (defined by `var`), which is accessible even outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be checked by running the program in the browser as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – The variable c defined by let is inaccessible outside the block
    where it is defined'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.8_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – The variable c defined by let is inaccessible outside the block
    where it is defined
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same program gives a similar result on the Node.js server, as
    can be seen in the following screen: the variable `c` defined by `let` in a block
    becomes unknown outside the block.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – The same results on the Node.js server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.9_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – The same results on the Node.js server
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding screen, the variable `c`, defined by `let` in
    a block, becomes unknown outside the block.
  prefs: []
  type: TYPE_NORMAL
- en: What if we don’t use var or let to define a variable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible not to use the `var` or `let` keywords to define a variable.
    We can simply write the variable’s name followed by its value (separated by the
    sign `=`). Let’s see how using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables without specifying var or let
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, where the variables are initialized without being
    preceded by `var` or `let`, these variables are global variables. As soon as they
    are initialized, they become accessible everywhere else in the program. This will
    become apparent when we study the functions in the *Using functions* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly advised to use as few global variables as possible in the programs,
    as this complicates the design and debugging of the programs that contain them.
  prefs: []
  type: TYPE_NORMAL
- en: What is an uninitialized variable worth?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the preceding variables was declared by initializing its value, with
    the `=` sign, which is the assignment sign. Let’s see what happens if we don’t
    assign any value to the variable, but just declare it using `var` or `let` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of variables without initialization
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined two variables, `a` and `b` – one using
    `var`, the other using `let`. Neither of the two variables has an initial value
    (that is, they’re not followed by an `=` sign).
  prefs: []
  type: TYPE_NORMAL
- en: The result displayed in this case for these uninitialized variables is a JavaScript
    value called `undefined`. This corresponds to the value of a variable that does
    not yet have a value. The `undefined` value is an important keyword in the JavaScript
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The variables `a` and `b` are not initialized, and it is necessary to declare
    them using `var` or `let`. Indeed, you cannot simply write `a;` or `b;` as this
    would cause a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the preceding program in the browser and observe the results displayed
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – An uninitialized variable is undefined'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.10_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – An uninitialized variable is undefined
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `undefined` value is also associated with an uninitialized variable if using
    server-side JavaScript with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to define variables in JavaScript. To create useful JavaScript
    programs, you have to write sequences of instructions. One of the most used instructions
    allows you to write conditional tests with the `if` statement, which we will talk
    about next.
  prefs: []
  type: TYPE_NORMAL
- en: Writing conditions for conditional tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript obviously allows you to write conditions in programs. The condition
    is expressed through the `if (condition)` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: If the condition is `true`, the statement (or block in braces) that follows
    is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the condition is `false`, the statement (or block) following the `else` keyword
    (if present) will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms of writing instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the following forms to express the conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Forms of conditional expressions with if (condition)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Forms of conditional expressions with if (condition) … else …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the process to be executed includes several instructions, these instructions
    are grouped together in a block surrounded by braces. A block can consist of only
    one statement, even if, as in this case, the block is optional (no need for braces).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the following program in the `testnode.js` file, which we will
    execute using the `node testnode.js` command in a command interpreter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: testnode.js file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the condition is expressed in the form `a == 12`. Indeed,
    it is customary to test the equality between two values by means of the sign `=`
    repeated twice successively (hence `==`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We use `==` for equality, `!=` for difference, `>` or `>=` to check superiority,
    and `<` or `<=` to check inferiority.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, since the variable `a` is `12`, the following result
    can be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Using conditional tests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.11_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – Using conditional tests
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assign the value `13` to the variable `a`, the `else` part of the statement
    will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Running the else part of the test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.12_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Running the else part of the test
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to execute one part of the code or another depending on a condition.
    Let’s now study how to write more complex conditions than those written previously.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions used to write conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The condition written previously is a simple test of equality between two values.
    But the test to write can sometimes be more complex. The goal is to have the final
    result of the condition, which is `true` or `false`, which will then make it possible
    for the system to decide the next course of action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The condition is written in Boolean form with the *OR* keyword (written as
    `||`) or with the *AND* keyword (written as `&&`). Parentheses between the different
    conditions may be necessary to express the final condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Condition expressed with “or”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, since the variable `b` is greater than 50, the condition
    is `true`, as seen in *Figure 1.13*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In an *OR* condition, it suffices that one of the conditions is `true` for the
    final condition to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In an *AND* condition, all the conditions must be `true` for the final condition
    to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Condition with or'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.13_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Condition with or
  prefs: []
  type: TYPE_NORMAL
- en: By default, the condition expressed in `if(condition)` is compared with the
    value `true`. We can sometimes prefer to compare with the value `false`. In this
    case, it suffices to precede the condition with the sign `!`, which corresponds
    to a negation of the following condition.
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes necessary to chain several tests in a row, depending on the
    results of the previous tests. We then have a succession of tests, called cascade
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Nested test suites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to chain tests in the processes to be performed. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: Test nesting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The `else` part is composed of several statements and is grouped in a block
    surrounded by braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Test nesting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.14_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – Test nesting
  prefs: []
  type: TYPE_NORMAL
- en: We learned about writing conditions in JavaScript programs. We are now going
    to learn how to write processing loops, which make it possible to write the instructions
    in the program only once. These instructions can, however, be executed as many
    times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating processing loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is sometimes necessary to repeat an instruction (or a block of instructions)
    several times. Rather than writing it several times in the program, we put it
    in a processing loop. These instructions will be repeated as many times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of processing loops are possible in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Loops with the `while()` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops with the `for()` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at these two types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: Loops with while()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `while(condition)` instruction allows you to repeat the instruction (or
    the block of instructions) that follows. As long as the condition is `true`, the
    statement (or block) is executed. It stops when the condition becomes `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this `while()` statement, let’s display the numbers from `0` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying numbers from 0 to 5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `console.log()` instruction is written only once in the program,
    but as it is inserted in a loop (`while()` instruction), it will be repeated as
    many times as the condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `i` allows you to manage the condition in the loop. The variable
    `i` is incremented by 1 (by `i++`) at each pass through the loop, and we stop
    when the value `5` is exceeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Displaying numbers from 0 to 5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.15_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.15 – Displaying numbers from 0 to 5
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that this program works in a similar way on the client side,
    that is to say in a web browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying digits 0–5 in a browser console
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is displayed similarly in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Displaying numbers from 0 to 5 in the browser console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.16_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.16 – Displaying numbers from 0 to 5 in the browser console
  prefs: []
  type: TYPE_NORMAL
- en: Loops with for()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another widely used form of loop is one with a `for()` statement. It simplifies
    the writing of the previous loop by reducing the number of instructions to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the same program as before to display the numbers from 0 to 5 using
    a `for()` statement instead of the `while()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, a single line replaces several lines as
    in the previous instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for()` statement has three parts, separated by a `;`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first corresponds to the initialization instruction. Here, it is the declaration
    of the variable `i` initialized to `0` (which is the beginning of the loop).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second corresponds to the condition: as long as this condition is `true`,
    the statement (or the block that follows) is executed. Here, the condition corresponds
    to the fact that the variable `i` has not exceeded the final value `5`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third corresponds to an instruction executed after each pass through the
    loop. Here, we increment the variable `i` by 1\. This ensures that at some point,
    the condition will be `false`, in order to exit the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s verify that it works identically to the `while()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Loop with the for() statement'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.17_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.17 – Loop with the for() statement
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to write sequences of statements that will be
    executed multiple times, using the `while()` and `for()` statements. Now let’s
    look at how to group statements together, using what are called functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function is used to give a name to a block of instructions so that it can
    be used in different places in the program. In general, in a function, we group
    a set of instructions that are used to carry out a particular task, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the list of the first 10 integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the sum of the first 10 numbers (from 0 to 9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the sum of the first N numbers (from 0 to N-1). In this case, `N`
    would be a parameter of the function because it can change with each call (or
    use) of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions described above are very simple but show that the role of functions
    is to encapsulate any process by summarizing in one sentence what is expected
    of this process. The name given to the function symbolizes the action expected
    in return, which allows the developer to easily understand the sequence of instructions
    (including for an external developer who has not participated in the development).
    Let’s discuss the three functions we listed one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Function displaying the list of the first 10 integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s write the first function, which displays the list of the first 10 integers.
    We will call this function `display_10_first_integers()`. The name must be as
    explicit as possible because a JavaScript program is composed of many functions
    whose names must be unique in the program (if two function names are the same,
    only the last one is taken into account because it overwrites the former).
  prefs: []
  type: TYPE_NORMAL
- en: A function is defined using the keyword `function`, followed by the name of
    the function, followed by parentheses. Then, we indicate in the braces that follow
    the instructions that make up the function. It is this instruction block that
    will be executed each time the function is called in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the function `display_10_first_integers()`, which displays the
    first 10 integers:'
  prefs: []
  type: TYPE_NORMAL
- en: Display first 10 integers with a function (testnode.js file)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The function is defined using the `function` keyword, followed by the function
    name and parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The function statements are grouped in the block that follows between the braces.
    We find as instructions the previous `for()` loop, but it could also be the `while()`
    loop, which works in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this program assuming it’s included in the `testnode.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Using a function to display numbers from 1 to 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.18_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.18 – Using a function to display numbers from 1 to 10
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding figure, the screen remains blank as no display
    is registered in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we have simply defined the function, but we must also use it, that
    is, call it in our program. You can call it as many times as you want – this is
    the purpose of functions: we should be able to call (or use) them at any time.
    But it must be done at least once; otherwise, it is useless, as seen in the preceding
    figure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the function call following the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition and call of the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Call of the display_10_first_integers() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.19_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.19 – Call of the display_10_first_integers() function
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the function can be called in several places of the program.
    Let’s see how in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Successive calls to the display_10_first_integers() function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the function is called three times in succession, which
    displays the list of the first 10 integers as many times. The order of the calls
    is indicated before each list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Successive calls to the display_10_first_integers() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.20_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.20 – Successive calls to the display_10_first_integers() function
  prefs: []
  type: TYPE_NORMAL
- en: Function calculating the sum of the first 10 integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now want to create a function that calculates the sum of the first 10 integers,
    that is, `1+2+3+4+5+6+7+8+9+10`. The result is `55`. This will allow us to show
    how a function can return a result to the outside (that is, to the program that
    uses it). Here, the function should return `55`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call the function `add_10_first_integers()`. This can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Function that adds the first 10 integers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: We define the `total` variable in the function. This variable is a local variable
    to the function because it is defined using the `var` or `let` keyword. This allows
    this `total` variable to not be the same as the one defined outside the function,
    even if the names are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the `total` variable in the function was not defined using the `var` or `let`
    keyword, it would create a so-called global variable that would be directly accessible
    even outside the function. This is not good programming because you want to use
    global variables as little as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The function uses a `for()` loop to add the first 10 integers, then returns
    that total using the `return` keyword. This keyword makes it possible to make
    accessible, outside the function, the value of any variable, in our example, the
    `total` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the previous program. We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Calculation of the sum of the first 10 integers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.21_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.21 – Calculation of the sum of the first 10 integers
  prefs: []
  type: TYPE_NORMAL
- en: Function calculating the sum of the first N integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous function is not very useful because it always returns the same
    result. A more useful function would be to calculate the sum of the first `N`
    integers, knowing that `N` can be different each time the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`N` would in this case be a parameter of the function. Its value is indicated
    in parentheses when using the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call the `add_N_first_integers()`function to calculate this sum. The `N`
    parameter would be indicated in parentheses following the function name. A function
    can use several parameters, and it suffices to indicate them in succession, separated
    by a comma. In our example, a single parameter is enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the `add_N_first_integers(n)`function and use that to calculate
    the sum of the first 10, then 25, then 100 integers. The values 10, 25, and 100
    will be used as parameters during successive calls to the function and will replace
    the parameter `n` indicated in the definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: Function that adds the first N integers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The `add_N_first_integers(n)` function is very similar to the `add_10_first_integers()`
    function written earlier. It uses the parameter `n` indicated between the parentheses
    and does not loop from `0` to `10` as before, but from `0` to `n`. Depending on
    the value of `n` that will be used when calling the function, the loop will thus
    be different, and the result returned by the function as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling the function, it passes the parameters `10`, `25`, then `100`
    as desired. The result is returned by the function’s `total` variable, and then
    used by the `total_10`, `total_25`, and `total_100` variables outside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22 – Calculation of the sum of the first 10, then 25, then 100 integers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.22_B17416.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.22 – Calculation of the sum of the first 10, then 25, then 100 integers
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic features of JavaScript have been covered in this chapter: variables
    with different types, conditional tests, loops, and functions. They are used on
    the client side and on the server side.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a look at some more in-depth features of JavaScript,
    such as object-oriented programming with JavaScript.
  prefs: []
  type: TYPE_NORMAL
