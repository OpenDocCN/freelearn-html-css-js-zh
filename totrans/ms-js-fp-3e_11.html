<html><head></head><body>
		<div><h1 id="_idParaDest-204" class="chapter-number"><a id="_idTextAnchor204"/>11</h1>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor205"/>Implementing Design Patterns – The Functional Way</h1>
			<p>In <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, we saw several functional techniques to solve different problems. However, programmers used to employing OOP may find that we have missed some well-known formulas and solutions often used in imperative coding. Since design patterns are well known, and programmers will likely already be aware of how they are applied in other languages, it’s important to look at how a functional implementation would be done.</p>
			<p>In this chapter, we shall consider the solutions provided by <strong class="bold">design patterns</strong> that are common in OOP, to see their equivalent in FP. This will help you transition from OOP to a more functional approach and learn more about FP’s power and methods, by seeing alternative solutions to problems.</p>
			<p>In particular, we will study the following topics:</p>
			<ul>
				<li>The concept of <em class="italic">design patterns</em> and what they apply to</li>
				<li>A few OOP standard patterns and what alternatives we have in FP if we need one</li>
				<li>The <em class="italic">Observer</em> pattern, which leads to <em class="italic">reactive programming</em>, a declarative way of dealing with events</li>
				<li>FP design patterns, not related to the OOP ones</li>
			</ul>
			<p>In this chapter, we won’t be worrying much about typing and TypeScript because we’ll want to focus on the patterns, minimizing and abstracting everything else.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor206"/>Understanding design patterns</h1>
			<p>One of the most relevant books in software engineering is <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> (1994), written by the <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>) – Erich Gamma, Richard <a id="_idIndexMarker846"/>Helm, Ralph Johnson, and John Vlissides. This book presented <a id="_idIndexMarker847"/>about two dozen OOP patterns and has been recognized as highly important in computer science.</p>
			<p><em class="italic">Patterns</em> are actually a concept in architectural design, originally defined by an architect, Christopher Alexander. Still, in software terms, a <em class="italic">design pattern</em> is a generally applicable, reusable solution to a commonly-seen problem in software design. Rather than a specific finished and coded design, it’s a description of a solution (the word <em class="italic">template</em> is also used) that can solve a given problem that appears in many contexts. Given their advantages, design patterns are best practices that can be used by developers working with different kinds of systems, programming languages, and environments.</p>
			<p>The GoF book obviously focused on OOP, and some patterns within cannot be recommended for or applied in FP. Other patterns are unnecessary or irrelevant because functional languages already provide standard solutions to the corresponding object-oriented problems. Even given this difficulty, since most programmers have been exposed to OOP design patterns and usually try to apply them even in other contexts such as FP, it makes sense to consider the original problems and then take a look at how a new solution can be produced. The standard object-based solutions may not apply, but the problems can still stand, so seeing how to solve them is still valid.</p>
			<p>Patterns are often described in terms of<a id="_idIndexMarker848"/> four essential, basic elements:</p>
			<ul>
				<li>A simple, short <em class="italic">name,</em> used to describe the problem, its solutions, and its consequences. The name helps when talking with colleagues, explaining a design decision, or describing a specific implementation.</li>
				<li>The <em class="italic">context</em> to which<a id="_idIndexMarker849"/> the pattern applies – specific situations that require a solution, possibly with additional conditions that must be met.</li>
				<li>A <em class="italic">solution</em> that lists the<a id="_idIndexMarker850"/> elements (classes, objects, functions, relationships, and so on) that you’ll need to solve the given situation.</li>
				<li>The <em class="italic">consequences</em> (results and<a id="_idIndexMarker851"/> trade-offs) if you apply the pattern. You may derive some gains from the solution, but it may also imply some losses.</li>
			</ul>
			<p>In this chapter, we will assume that you are already aware of the design patterns we will describe and use, so we will only provide a few details about them. Rather, we will focus on how FP either makes a problem irrelevant (because there is an obvious way of applying functional techniques to solve it) or solves it in some fashion.</p>
			<p>Also, we won’t be going over all of the GoF patterns; we’ll just focus on the ones that are the most interesting, that is, those that bring out more differences when FP is applied compared to when OOP is applied.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor207"/>Design pattern categories</h2>
			<p>According to their focus, design patterns are usually grouped into several distinct categories. The first three in the following list are the ones that appeared in the original GoF book, but more categories have<a id="_idIndexMarker852"/> since been added. They are as follows:</p>
			<ul>
				<li><strong class="bold">Behavioral design patterns</strong> have to do with interactions and communications between objects. Rather than focusing on how objects are created or built, the <a id="_idIndexMarker853"/>key consideration is how to connect them so that they can cooperate when performing a complex task, preferably in a way that provides well-known advantages, such as diminished coupling or enhanced cohesiveness.</li>
				<li><strong class="bold">Creational design patterns</strong> deal with ways to create objects in a manner suitable for the current problem. With<a id="_idIndexMarker854"/> them, you can decide between several alternative objects, so the <a id="_idIndexMarker855"/>program can work differently, depending on parameters that may be known at compilation time or runtime.</li>
				<li><strong class="bold">Structural design patterns</strong> have to do with the composition of objects, forming larger structures from many individual parts and implementing relationships between objects. Some<a id="_idIndexMarker856"/> of the patterns imply inheritance or implementation of interfaces, whereas others <a id="_idIndexMarker857"/>use different mechanisms, all geared toward being able to dynamically change the way objects are composed at runtime.</li>
				<li><strong class="bold">Concurrency patterns</strong> deal with <a id="_idIndexMarker858"/>multithreaded programming. Although FP is generally quite<a id="_idIndexMarker859"/> appropriate for this (given, for example, the lack of assignments and side effects), since we are working with JavaScript, these patterns are not very relevant to us.</li>
				<li><strong class="bold">Architectural patterns</strong> are more high-level oriented, with a broader scope than the previous patterns we’ve listed, and provide general solutions to software architecture<a id="_idIndexMarker860"/> problems. As is, we<a id="_idIndexMarker861"/> aren’t considering such problems in this book, so we won’t deal with these either.</li>
			</ul>
			<p>The categories are not really fixed or set in stone. Fifteen years after the original GoF book, three of its authors (see the <em class="italic">Design Patterns 15 Years Later: An Interview with Erich Gamma, Richard Helm, and Ralph Johnson</em> article at <a href="http://www.informit.com/articles/article.aspx?p=1404056">www.informit.com/articles/article.aspx?p=1404056</a>) suggested a new list of categories – <em class="italic">Core</em>, <em class="italic">Creational</em> (similar to the original category, but adding the <em class="italic">Dependency Injection</em> pattern, which we’ll study later on), <em class="italic">Peripheral</em>, and <em class="italic">Other</em>.</p>
			<p class="callout-heading">Old good practices</p>
			<p class="callout">Coupling and <a id="_idIndexMarker862"/>cohesiveness are terms that were in use even before OOP came into vogue; they date back to the late 1960s when the <em class="italic">Structured Design</em> book by Larry Constantine came out. Coupling measures the interdependence between any two modules, and cohesiveness has to<a id="_idIndexMarker863"/> do with the degree to which all module components really belong together. Low coupling and high cohesiveness are worthy goals for software design because they imply that related things are nearby and unrelated ones are separate.</p>
			<p>Following along these lines, you could also classify design patterns as <em class="italic">object patterns</em> (which concern the dynamic relationships <a id="_idIndexMarker864"/>between objects) and <em class="italic">class patterns</em> that deal with <a id="_idIndexMarker865"/>the relationships between classes and subclasses (which are defined statically at compile time). We won’t be worrying much about this classification because our point of view has more to do with behaviors and functions, rather than classes and objects.</p>
			<p>As mentioned earlier, we can now readily observe that these categories are heavily oriented toward OOP, and the first three directly mention objects. However, without the loss of generality, we will look beyond the definitions, remember what problem we were trying to solve, and then look into analogous solutions with FP, which, if not 100% equivalent to the OOP ones, will in spirit solve the same problem in a parallel way. Let’s move on and start by considering why we want to deal with patterns at all!</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor208"/>Do we need design patterns?</h2>
			<p>An interesting <a id="_idIndexMarker866"/>point of view says that design patterns are only needed to patch the shortcomings of programming languages. The rationale is that if you can solve a problem with a given programming language in a simple, direct, and straightforward way, then you may not need a design pattern at all. (For example, if your language doesn’t provide recursion, you would have to implement it on your own; otherwise, you can just use it without further ado.) However, studying patterns lets you think about different ways of solving problems, so that’s a point in their favor.</p>
			<p>In any case, it’s interesting for OOP developers to understand why FP helps solve some problems without needing further tools. In the next section, we shall consider several well-known design patterns and examine why we don’t need them or how we can easily implement them. It’s also a fact that we have already applied several patterns earlier in the text, so we’ll also point out those examples.</p>
			<p>We won’t try, however, to express or convert all design patterns into FP terms. For example, the Singleton pattern basically requires a single, global object, which is sort of opposed to everything that functional programmers are used to. Given our approach to FP (remember <em class="italic">Sorta Functional Programming</em> (SFP), from<a id="_idIndexMarker867"/> the first chapter of this book?), we won’t mind either, and if a Singleton is required, we may consider using it, even though FP doesn’t have an appropriate equivalent. (And, as we’ll see soon enough, every time you import from a module you’re using a Singleton!)</p>
			<p>Finally, it must be said that our point of view may affect what is considered a pattern and what isn’t. What may be a pattern to some may be considered a trivial detail for others. We will find some such situations, given that FP lets us solve some particular problems in easy ways, and<a id="_idIndexMarker868"/> we have already seen examples of that in previous chapters.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor209"/>Object-oriented design patterns</h1>
			<p>In this section, we’ll review some of the GoF design patterns, check whether they are pertinent to FP, and study how to implement them. Of course, some design patterns don’t get an FP solution. As<a id="_idIndexMarker869"/> an example, there’s no equivalent for a Singleton, which implies the foreign concept of a globally accessed object. Additionally, while it’s true that you may no longer need OOP-specific patterns, developers will still think in terms of those. Also, since we’re not going fully functional, if some OOP pattern fits, why not use it even if it’s not fully functional?</p>
			<p>We will be considering the following:</p>
			<ul>
				<li><strong class="bold">Façade</strong> and <strong class="bold">Adapter</strong> to provide new<a id="_idIndexMarker870"/> interfaces to <a id="_idIndexMarker871"/>other code</li>
				<li><strong class="bold">Decorator</strong> (also known as <strong class="bold">Wrapper</strong>) to add new<a id="_idIndexMarker872"/> functionality to existing code</li>
				<li><strong class="bold">Strategy</strong>, <strong class="bold">Template</strong>, and <strong class="bold">Command</strong> to let <a id="_idIndexMarker873"/>you fine-tune <a id="_idIndexMarker874"/>algorithms by<a id="_idIndexMarker875"/> passing functions as parameters</li>
				<li><strong class="bold">Dependency Injection</strong> to help in <a id="_idIndexMarker876"/>decoupling components and simplify testing</li>
				<li><strong class="bold">Observer</strong>, which leads to<a id="_idIndexMarker877"/> reactive programming, a declarative way of dealing with events</li>
				<li>Other patterns that do not so fully match the corresponding OOP ones</li>
			</ul>
			<p>Let’s begin our study by analyzing a couple of similar patterns that let you use your code in somewhat different ways.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor210"/>Facade and Adapter</h2>
			<p>Out of these two patterns, let’s<a id="_idIndexMarker878"/> start with the Facade or, more correctly, Façade. This is meant to solve the problem of providing a different interface to the methods of a class or to <a id="_idIndexMarker879"/>a library. The idea is to provide<a id="_idIndexMarker880"/> a new interface to a system that makes it easier to use. You might say that a Façade provides a better <a id="_idIndexMarker881"/>control panel to access certain functionalities, removing difficulties for the user.</p>
			<p class="callout-heading">S or K?</p>
			<p class="callout"><em class="italic">Façade</em> or <em class="italic">facade</em>? The original word is an architectural term meaning <em class="italic">the front of a building</em> and comes from the French language. According to this source and the usual sound of the cedilla (ç) character, its pronunciation is a bit like <em class="italic">fuh-sahd</em>. The other spelling probably has to do with the lack of international characters in keyboards and poses the following problem – shouldn’t you read it as <em class="italic">fah-Kade</em>? You may see this problem as the reverse of <em class="italic">Celtic</em>, which is pronounced as <em class="italic">Keltic</em>, changing the <em class="italic">s</em> sound to a <em class="italic">k</em> sound.</p>
			<p>The main problem we want to solve is using external code more easily. (Of course, if it were your code, you could handle such problems directly; we must assume you cannot – or shouldn’t – Insert space try to modify that other code. This would be the case when you use any library available over the web, for example.) The key is to implement a module that will provide an interface that better suits your needs. Your code will use your module and won’t directly interact with the original code.</p>
			<p>Suppose that you want to do Ajax calls, and your only possibility is using some hard library with a really complex interface. With modules, you might write something like the following, working with an imagined, hard-to-use Ajax library:</p>
			<pre class="source-code">
// simpleAjax.js
import * as hard from "hardajaxlibrary";
// import the other library that does Ajax calls
// but in a hard, difficult way, requiring complex code
const convertParamsToHardStyle = (params) =&gt; {
  // do some internal steps to convert params
  // into whatever the hard library may require
};
const makeStandardUrl = (url) =&gt; {
  // make sure the URL is in the standard
  // way for the hard library
};
const getUrl = (url, params, callback) =&gt; {
  const xhr = hard.createAnXmlHttpRequestObject();
  hard.initializeAjaxCall(xhr);
  const standardUrl = makeStandardUrl(url);
  hard.setUrl(xhr, standardUrl);
  const convertedParams = convertParamsToHardStyle(params);
  hard.setAdditionalParameters(params);
  hard.setCallback(callback);
  if (hard.everythingOk(xhr)) {
    hard.doAjaxCall(xhr);
  } else {
    throw new Error("ajax failure");
  }
};
const postUrl = (url, params, callback) =&gt; {
  // some similarly complex code
  // to do a POST using the hard library
};
export { getUrl, postUrl };
// the only methods that will be seen</pre>
			<p>Now, if you need to do <code>GET</code> or <code>POST</code>, instead of having to go through all of the complications of <a id="_idIndexMarker882"/>the provided complex Ajax library, you <a id="_idIndexMarker883"/>can use the new façade that<a id="_idIndexMarker884"/> provides a simpler way of working. Developers would write <code>import {getUrl, postUrl} from "simpleAjax"</code> and work more reasonably.</p>
			<p>Nowadays, with <code>import</code>/<code>export</code> support in <a id="_idIndexMarker885"/>browsers, code will work as shown previously. Before that (or for backward-compatibility reasons) the implementation would require the <a id="_idIndexMarker886"/>usage of an <strong class="bold">Immediately Invoked Function Expression</strong> (<strong class="bold">IIFE</strong>), as covered in the <em class="italic">Immediate invocation</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, using a <strong class="bold">revealing module</strong> pattern. The way to implement the <a id="_idIndexMarker887"/>pattern would then be as follows:</p>
			<pre class="source-code">
const simpleAjax = (function () {
  const hard = require("hardajaxlibrary");
  const convertParamsToHardStyle = (params) =&gt; {
    // ...
  };
  const makeStandardUrl = (url) =&gt; {
    // ...
  };
  const getUrl = (url, params, callback) =&gt; {
    // ...
  };
  const postUrl = (url, params, callback) =&gt; {
    // ...
  };
  return { getUrl, postUrl };
})();</pre>
			<p>The reason for the <em class="italic">revealing module</em> name <a id="_idIndexMarker888"/>should now be apparent. With the preceding code, because of the JavaScript scope rules, the only visible attributes of <code>simpleAjax</code> will be <code>simpleAjax.getUrl</code> and <code>simpleAjax.postUrl</code>; using an IIFE lets us implement the<a id="_idIndexMarker889"/> module (and, hence, the façade) safely, making <a id="_idIndexMarker890"/>implementation<a id="_idIndexMarker891"/> details private.</p>
			<p class="callout-heading">Of modules and singletons</p>
			<p class="callout">In modern JavaScript, modules are a case of the Singleton pattern. (In math, a “singleton” is a set with just one element.) If you import a module in several different places of your code, all references will be to the same object, precisely as the Singleton pattern requires in object-oriented code.</p>
			<p>Now, the Adapter pattern<a id="_idIndexMarker892"/> is similar, insofar as it is also meant to define a new interface. However, while<a id="_idIndexMarker893"/> Façade defines a new interface to old code, Adapter is used when you need to implement an old interface for new code, so it will match what you already have. If you are working with modules, it’s clear that the same type of solution that worked for Façade will work here, so we don’t have to study it in detail. Now, let’s continue with a well-known pattern, <a id="_idTextAnchor211"/>which we saw earlier in this book!</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor212"/>Decorator or Wrapper</h2>
			<p>The Decorator pattern (also known as Wrapper) is useful when you want to add additional responsibilities or<a id="_idIndexMarker894"/> functionalities to an object in a <a id="_idIndexMarker895"/>dynamic way. Let’s consider a simple example, which we will illustrate with some React code. (Don’t worry if you do not know this framework; the example will be easy to understand. The idea of using React is because it can take advantage of this pattern very well. Also, we have already seen pure JavaScript higher-order function examples, so it’s good to see something new.) Suppose we want to show some elements on the screen, and for debugging purposes, we want to show a thin red border around an object. How can you do it?</p>
			<p>If you were using OOP, you would have to create a new subclass with the extended functionality. For this particular example, you might provide some attribute with the name of some CSS class that would provide the required style, but let’s keep our focus on OOP; using CSS won’t always solve this software design problem, so we want a more general solution. The new subclass would know how to show itself with a border, and you’d use this subclass whenever you wanted an object’s border to be visible.</p>
			<p>With our experience with higher-order functions, we can solve this differently by <em class="italic">wrapping</em> the original function within another one, which would provide extra functionality.</p>
			<p>Note that we have already seen some examples of wrapping in the <em class="italic">Wrapping functions – keeping behavior</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, Producing Functions</em>. For example, in that section, we saw how to wrap functions to produce new versions that could log their input and output, provide timing information, or even memorize calls to avoid future delays. On this occasion, we are applying the concept to decorate a visual component, but the principle remains the same.</p>
			<p>Let’s define a simple React component, <code>ListOfNames</code>, that can display a heading and a list of people, and for the latter, we will use a <code>FullNameDisplay</code> component. The code for those elements <a id="_idIndexMarker896"/>would be as shown in the following fragment:</p>
			<pre class="source-code">
const FullNameDisplay = ({ first, last }) =&gt; {
  return (
    &lt;div&gt;
      First Name: &lt;b&gt;{first}&lt;/b&gt;
      &lt;br /&gt;
      Last Name: &lt;b&gt;{last}&lt;/b&gt;
    &lt;/div&gt;
  );
};
const ListOfNames = ({ people, heading }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;{heading}&lt;/h1&gt;
      &lt;ul&gt;
        {people.map((v) =&gt; (
          &lt;FullNameDisplay first={v.first} last={v.last} /&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</pre>
			<p>The <code>ListOfNames</code> component uses mapping to create a <code>FullNameDisplay</code> component to show<a id="_idIndexMarker897"/> data for each person. The logic for our application could then be the following:</p>
			<pre class="source-code">
import { createRoot } from "react-dom/client";
const GANG_OF_FOUR = [
  { first: "Erich", last: "Gamma" },
  { first: "Richard", last: "Helm" },
  { first: "Ralph", last: "Johnson" },
  { first: "John", last: "Vlissides" }
];
const FullNameDisplay = ...
const ListOfNames = ...
const rootElement = document.getElementById("root");
const root = createRoot(rootElement);
root.render(
  &lt;ListOfNames people={GANG_OF_FOUR} heading="GoF" /&gt;
);</pre>
			<p class="callout-heading">Do as I say...</p>
			<p class="callout">In real life, you wouldn’t<a id="_idIndexMarker898"/> put all the code for every component in the same single source code file – and you would probably have a few CSS files. However, for our example, having everything in one place and using inline styles is enough, so bear with me and keep in mind the saying <em class="italic">“Do as I say, not as </em><em class="italic">I do.”</em></p>
			<p>We can quickly test<a id="_idIndexMarker899"/> the result in the online React sandbox at <a href="http://codesandbox.io/">codesandbox.io/</a>; google <code>react online sandbox</code> if you want other options. The<a id="_idIndexMarker900"/> interface design isn’t much to talk about (so please don’t criticize my poor web page!) because we are interested in design patterns right now; refer to <em class="italic">Figure 11</em><em class="italic">.1</em>, given as follows:</p>
			<div><div><img src="img/Figure_11.1_B19301.jpg" alt="Figure 11.1 – The original version of our components shows a (not much to speak about) list of names"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The original version of our components shows a (not much to speak about) list of names</p>
			<p>In React, inline<a id="_idIndexMarker901"/> components are written in JSX (inline HTML style) and compiled into objects, which are later transformed into HTML code to be displayed. Whenever the <code>render()</code> method is called, it returns a structure of objects. So, we will write a function that will take a component as a parameter and return a new JSX, a wrapped object. In our case, we’d like to wrap the original component within <code>&lt;div&gt;</code> with the required border:</p>
			<pre class="source-code">
const makeVisible = (component) =&gt; {
  return (
    <strong class="bold">&lt;div style={{ border: "1px solid red" }}&gt;</strong>
      {component}
    <strong class="bold">&lt;/div&gt;</strong>
  );
};</pre>
			<p>If you wish, you can make this function aware of whether it’s executing in development mode or production; in the<a id="_idIndexMarker902"/> latter case, it would simply return the original component argument without any <a id="_idIndexMarker903"/>change, but let’s not worry about that now.</p>
			<p>We now have to change <code>ListOfNames</code> to use wrapped components; the new version would be as follows:</p>
			<pre class="source-code">
const ListOfNames = ({ people, heading }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;{heading}&lt;/h1&gt;
      &lt;ul&gt;
        {people.map((v) =&gt;
<strong class="bold">          makeVisible(&lt;FullNameDisplay</strong>
<strong class="bold">            first={v.first}</strong>
<strong class="bold">            last={v.last} /&gt;)</strong>
        )}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</pre>
			<p>The decorated version of the code works as expected: each of the <code>ListOfNames</code> components is<a id="_idIndexMarker904"/> now wrapped in another component that adds the desired border to them; refer to <em class="italic">Figure 11</em><em class="italic">.2</em>, given as follows:</p>
			<div><div><img src="img/Figure_11.2_B19301.jpg" alt="Figure 11.2 – The decorated ListOfNames component is still nothing much to look at, but now it shows an added border"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The decorated ListOfNames component is still nothing much to look at, but now it shows an added border</p>
			<p>In earlier chapters, we<a id="_idIndexMarker905"/> saw how to decorate a function, wrapping it inside of another function, so it would perform extra code and add a few functionalities. Here, we saw how to apply the same solution style to provide a <em class="italic">higher-order component</em> (as it’s called in <a id="_idIndexMarker906"/>React parlance), wrapped in an extra <code>&lt;div&gt;</code> to provide some visually distinctive details.</p>
			<p class="callout-heading">A Redux decorator</p>
			<p class="callout">If you have used Redux and the <code>react-redux</code> package, you may note that the latter’s <code>connect()</code> method is also<a id="_idIndexMarker907"/> a decorator in the same sense; it receives a component class, and returns a new component class, connected to the store, for usage in your forms. Refer to <a href="http://github.com/reduxjs/react-redux">github.com/reduxjs/react-redux</a> for more details.</p>
			<p>Let’s move to a different set of patterns that will let us change how functions perform.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor213"/>Strategy, Template, and Command</h2>
			<p>The Strategy pattern applies<a id="_idIndexMarker908"/> whenever you want to <a id="_idIndexMarker909"/>have the ability to change a class, method, or function, possibly in a dynamic way, by changing the way it actually does whatever it’s expected to do. For<a id="_idIndexMarker910"/> example, a GPS application might want to find a<a id="_idIndexMarker911"/> route between two places by applying different strategies if the person is on foot, rides a bicycle, or goes by car. In that case, the fastest or the shortest routes might be desired. The problem is the same, but different algorithms must be applied, depending on the given condition.</p>
			<p>Does this sound familiar? If so, it is because we have already met a similar problem. When we wanted to sort a set of strings in different ways, in <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, we needed a way to specify how the ordering was to be applied or, equivalently, how to compare two given strings and determine which had to go first. Depending on the language, we had to sort applying different comparison methods.</p>
			<p>Before trying an FP solution, let’s consider more ways of implementing our routing function. You could make do by having a big enough piece of code, which would receive an argument declaring which algorithm to use, plus the starting and ending points. With these arguments, the function could do a switch or something similar to apply the correct path-finding logic. The code would be roughly equivalent to the following fragment:</p>
			<pre class="source-code">
function findRoute(byMeans, fromPoint, toPoint) {
  switch (byMeans) {
    case "foot":
    /*
    find the shortest road for a walking person
    */
    case "bicycle":
    /*
    find a route apt for a cyclist
    */
    case "car-fastest":
    /*
    find the fastest route for a car driver
    */
    case "car-shortest":
    /*
    find the shortest route for a car driver
    */
    default:
    /*
    plot a straight line, or throw an error,
    or whatever suits you
    */
  }
}</pre>
			<p>This kind of solution is not desirable, and your function is the sum of many distinct other functions, which doesn’t offer a high level of cohesion. If your language doesn’t support lambda functions (as was the case with Java, for example, until Java 8 came out in 2014), the OOP solution for this requires defining classes that implement the different strategies you may want, creating an appropriate object, and passing it around.</p>
			<p>With FP in JavaScript, implementing strategies is trivial; instead of using a variable such as <code>byMeans</code> to switch, you provide a route-finding function (<code>routeAlgorithm()</code> in the following code) that will implement the desired path logic:</p>
			<pre class="source-code">
function findRoute(routeAlgorithm, fromPoint, toPoint) {
  return routeAlgorithm(fromPoint, toPoint);
}</pre>
			<p>You would still have to implement all of the desired strategies (there’s no way around that) and decide which function to pass to <code>findRoute()</code>, but now that function is independent of the routing logic, and if you wanted to add new routing algorithms, you wouldn’t touch <code>findRoute()</code>.</p>
			<p>If you consider<a id="_idIndexMarker912"/> the Template pattern, the difference is <a id="_idIndexMarker913"/>that Strategy allows you to <a id="_idIndexMarker914"/>use completely different ways of achieving an outcome, while Template provides an overarching algorithm (or template) in which some implementation details are left to methods to be specified. In the same way, you can provide functions to implement the Strategy pattern; you can also provide them for a Template pattern.</p>
			<p>Finally, the Command pattern also <a id="_idIndexMarker915"/>benefits from the <a id="_idIndexMarker916"/>ability to be able to pass functions as arguments. This pattern is meant to be enabled to encapsulate a request as an object, so for different requests, you have differently parameterized objects. Given that we can pass functions as arguments to other functions, there’s no need for the enclosing object.</p>
			<p>We also saw a similar use of this pattern back in the <em class="italic">A React-Redux reducer</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a><em class="italic">, Starting Out with Functions</em>. There, we defined a table, each of whose entries was a callback that was called whenever needed. We could directly say that the Command pattern is just an <strong class="bold">object-oriented</strong> (OO) replacement for plain functions working as callbacks.</p>
			<p>Let’s now consider a related pattern, Dependency Injection, that will also let us change how a method or function works.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor214"/>Dependency Injection</h2>
			<p>In basic terms, Dependency<a id="_idIndexMarker917"/> Injection is a pattern in which an object or function<a id="_idIndexMarker918"/> receives any other objects or functions that it needs to do its job, leading to less coupling and more flexibility. With this technique, a service can work in multiple environments or with different configurations, and changing it may be achieved without having to modify its code.</p>
			<p>To make things clearer, let’s consider a service, implemented in Node plus Express, that gets a request, interacts with other entities (maybe it queries a database, accesses some file buckets, posts a message to a message queue, calls some other services, etc.) and eventually builds a response to send back. What’s wrong with this? A quick answer would be “<em class="italic">Nothing!</em>” because it works, and it’s how many services are implemented. However, digging a bit further, we<a id="_idIndexMarker919"/> may decide the answer should be “<em class="italic">Everything</em>!” Why?</p>
			<p>With any piece of code, there always <a id="_idIndexMarker920"/>are three primary concerns:</p>
			<ul>
				<li><em class="italic">Is it understandable?</em> Our service’s code may be hard to follow because it mixes business logic concerns with implementation details, concerning secondary matters such as how to query the database and access the buckets.</li>
				<li><em class="italic">Is it maintainable?</em> If we wonder how simple it may be to change our service’s code, the question is how many reasons for change there may be. A change in business logic is always a possibility; that’s essential. However, other changes (using Redis instead of MySQL or adding records to a database table instead of sending messages to a queue) that aren’t related to the service’s business objectives would also require changes in code.</li>
				<li><em class="italic">Is it testable?</em> We may or may not need to maintain the code (and, indeed, if any changes are needed, that would be in the future), but we have to test our code today. How would we go about it? Would it be easy?</li>
			</ul>
			<p>The last item is the one we care about now. All the interactions with other entities are clearly impure functions, so we could set up our tests in three ways.</p>
			<ul>
				<li>We could work with separate, special environments. Each developer would need to have a complete environment (with databases, queues, servers, etc.) so code can run as in reality. To do a test, the developer should first set everything up in a known fashion and then check whether the database got modified correctly, if the right messages were sent, and so on. All this is possible but costly, hard to set up, and mainly slow – before each test, you have to reset everything, and after each test, you have to check everything.</li>
				<li>We could work with fully mocked external entities. Tools such as Jest or Jasmine allow us to mock entities, so our code, instead of dealing with actual databases, queues, services, and so on would (transparently) interact with mocks that mimic the needed behaviors. This is much more efficient (because no real environments are needed, no actual databases get updated, no messages are really sent, and so on), but <a id="_idIndexMarker921"/>simulating all the required behaviors is still a lot of work.</li>
				<li>We can make the service less impure first! We saw this approach back in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Behaving Properly</em>, which allows us to easily write tests.</li>
			</ul>
			<p>Let’s now get to actual <a id="_idIndexMarker922"/>details and consider a possible service.</p>
			<h3>Implementing a service</h3>
			<p>Imagine we <a id="_idIndexMarker923"/>have an endpoint that responds to <code>GET /client/:id</code> requests by searching for the client in a database and posting a message to a queue after the search.</p>
			<p>We’ll code our service in terms of <em class="italic">ports</em> (interfaces) and <em class="italic">adapters</em> (interface implementations) that it will receive. In our case, ports will (abstractly) define how our service is meant to interact with other entities, and adapters will (concretely) implement the needed functionality. With this in mind, we will be able to provide different adapters, allowing flexibility for different environments. In a production environment, we’ll provide adapters that work, access databases, post messages, and so on, but for testing, we’ll be able to inject mock adapters with trivial “do nothing” fake implementations.</p>
			<p class="callout-heading">An architecture by any other name</p>
			<p class="callout">This architectural style is naturally known as “Ports and Adapters,” but it also goes by “Hexagonal Architecture” – a much catchier name! Don’t try to figure out why the word “hexagonal” is used; it just refers to hexagons being used to represent services in diagrams, and nothing else!</p>
			<p>Let’s see how this would work. If our service needs to look for a client by its ID in a database, we must define a suitable interface, a “find client” port. We could define the following:</p>
			<pre class="source-code">
type <strong class="bold">FindClientPort</strong> = (
  id: number
) =&gt; Promise&lt;ClientType | null&gt;;</pre>
			<p>This definition says that our port will receive a numerical ID as an argument and return a promise that will either<a id="_idIndexMarker924"/> resolve to a <code>ClientType</code> object or <code>null</code>. (We cannot specify semantic aspects, but it sounds likely that the returned <a id="_idIndexMarker925"/>object will be the client, if found; <code>null</code> would represent a failed search.) We also require an actual implementation:</p>
			<pre class="source-code">
const findClientFromDBAdapter: <strong class="bold">FindClientPort</strong> = async (
  id: number
) =&gt; {
  // access the database, do the search, etc., and
  // return a promise to get the client from DB
};</pre>
			<p>Naming is important; the port definition does not say where the client will come from, but the adapter does. We could have different adapters that would look for clients in other places (a key store, a spreadsheet, or the filesystem), but they would all implement the same interface.</p>
			<p>Of course, given our service definition, we’ll also need a port and adapter for sending messages. How would we now write our service? The code would be as follows:</p>
			<pre class="source-code">
function getClientService(id: number,
  { findClient, sendMsg } =
<strong class="bold">  { findClient: findClientFromDBAdapter,</strong>
<strong class="bold">    sendMsg: sendMsgToMQAdapter }</strong>) {
  ...
}</pre>
			<p>What are we doing? Our service receives <code>id</code> and an optional object providing two adapters. If this object is omitted, our service will use default adapters that work with a database and a message queue. In our server, the code dealing with the <code>/client/:id</code> endpoint would use <code>getClientService(req.params.id)</code> and, thus, work with an actual<a id="_idIndexMarker926"/> database and a message queue. But how will we test our service? That’s what we need <a id="_idIndexMarker927"/>to see now.</p>
			<h3>Testing a service</h3>
			<p>In the previous<a id="_idIndexMarker928"/> section, we saw how to call our service in production. However, for testing, we would do things differently, such as the following:</p>
			<pre class="source-code">
findClientMock = jest.fn().mockResolvedValue(...);
sendMsgMock = jest.fn().mockReturnValue(...);
result = await getClientService(22,
  <strong class="bold">{ findClient: findClientMock,</strong>
<strong class="bold">    sendMsg: sendMsgMock }</strong>);
expect(findClientMock).toHaveBeenCalledWith(22);
expect(sendMsgMock).toHaveBeenCalledWith(...);
expect(result).toMatchObject(...);</pre>
			<p>We would first define a couple of mock functions; <code>findClientMock</code> would simulate a search in the database, and <code>sendMsgMock</code> would return whatever a successful message-sending operation would return. We can now call our <code>getClientService()</code> with the mocks, and we would then verify that the (mock) adapters were used properly and that the service returns the correct answer.</p>
			<p>Let’s now move on to a classic pattern that implies a new term, <em class="italic">reactive programming</em>, which is being thrown around a lot these days.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor215"/>Observers and reactive programming</h2>
			<p>The idea of the Observer <a id="_idIndexMarker929"/>pattern is to define a link between entities so that when one changes, all dependent entities are updated automatically. An <em class="italic">observable</em> can publish changes to its state, and its observer (which subscribed to the observable) will be notified of such changes.</p>
			<p class="callout-heading">No observables for now</p>
			<p class="callout">There is a proposal for adding observables to JavaScript (see <a href="http://github.com/tc39/proposal-observable">github.com/tc39/proposal-observable</a>), but as of January 2023, it’s still stuck at stage one, with no activity since late 2020. Hence, for the time being, using a library will still be mandatory.</p>
			<p>There’s an extension to<a id="_idIndexMarker930"/> this concept called <strong class="bold">reactive programming</strong>, which involves asynchronous streams of events (such as mouse clicks or keypresses) or data (from APIs or WebSockets), and different parts of the application subscribing to observe such streams by passing callbacks that will get called whenever something new appears.</p>
			<p>We won’t be implementing reactive programming on our own; instead, we’ll use RxJS, a JavaScript implementation of Reactive Extensions (<em class="italic">ReactiveX</em>), initially developed by Microsoft. RxJS is widely used in the Angular framework and can also be used in other frontend frameworks, such as React or Vue, or the backend with Node.js. Learn more about RxJS at <a href="http://rxjs-dev.firebaseapp.com">rxjs-dev.firebaseapp.com</a> and <a href="http://www.learnrxjs.io">www.learnrxjs.io</a>.</p>
			<p>The techniques we will be <a id="_idIndexMarker931"/>showing in these sections are, confusingly, called both <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> to process those streams and pick which events to process and how. Okay, this may be confusing now, so bear with me and let’s see some concepts first, and after that, some examples of FRP – or whatever you want to call it! We will be seeing the following:</p>
			<ul>
				<li>Several basic concepts and terms you’ll need to work with FRP</li>
				<li>Some of the many available operators you’ll use</li>
				<li>A couple of examples – detecting multi-clicks and providing typeahead searches</li>
			</ul>
			<p>Let’s proceed to analyze each item, starting with the basic ideas you need to know.</p>
			<h3>Basic concepts and terms</h3>
			<p>Using FRP requires getting used to several new terms, so let’s begin with a short glossary:</p>
			<ul>
				<li><code>$</code>; see <a href="http://angular.io/guide/rx-library#naming-conventions">angular.io/guide/rx-library#naming-conventions</a>.</li>
				<li><code>next()</code>, <code>error()</code>, and <code>complete()</code>, which will be called by the observable when a value is available, when there’s an error, and when the stream is ended respectively.</li>
				<li><code>map()</code>, <code>filter()</code>, and so on, from <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>) that let you apply transformations to a stream in a declarative way.</li>
				<li><code>pipeline()</code> function we developed in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>.</li>
				<li><code>subscribe()</code> method, providing an observer.</li>
			</ul>
			<p>An interesting way of looking at observables is that they <a id="_idIndexMarker938"/>complete the lower row of this table – check it out. You will probably be quite familiar with the <em class="italic">Single</em> column, but maybe not with the <em class="italic">Multiple</em> one:</p>
			<table id="table001" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><strong class="bold">Single</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Multiple</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Pull</strong></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>Function</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>Iterator</code></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Push</strong></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>Promise</code></p>
						</td>
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>Observable</code></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>How do we interpret this table? The rows distinguish between pull (you call something) and push (you get called), and the columns represent how many values you get – one or many. With these descriptions, we can see the following:</p>
			<ul>
				<li>A <code>function</code> is called and returns a single value</li>
				<li>A <code>promise</code> calls your code (a callback in the <code>then()</code> method), also with a single value</li>
				<li>An <code>iterator</code> returns a new value each time it’s called – at least until the sequence is over</li>
				<li>An <code>observable</code> calls your code (provided you <code>subscribe()</code> to the observable) for each value in the stream</li>
			</ul>
			<p>Observables and promises <a id="_idIndexMarker939"/>can be compared a bit more:</p>
			<ul>
				<li>They are <a id="_idIndexMarker940"/>both mostly <code>async</code> in nature, and your callback will be called at an indefinite future time</li>
				<li>Promises cannot be canceled, but you can <code>unsubscribe()</code> from an observable</li>
				<li>Promises start executing the moment you create them; observables are lazy, and nothing happens until an observer does <code>subscribe()</code> to them</li>
			</ul>
			<p>The real power of observables derives from the variety of operators you can use; let’s see some of them.</p>
			<h3>Operators for observables</h3>
			<p>Basically, operators are just functions. Creation operators can be used to create observables out of many <a id="_idIndexMarker941"/>different sources, and pipeable operators can be applied to modify a stream, producing a new observable; we’ll see many families of these, but for complete lists and descriptions, you should access <a href="http://www.learnrxjs.io/learn-rxjs/operators">www.learnrxjs.io/learn-rxjs/operators</a> and <a href="http://rxjs.dev/guide/operators">rxjs.dev/guide/operators</a>.</p>
			<p>Also, we won’t be covering how to install RxJS; see <a href="http://rxjs.dev/guide/installation">rxjs.dev/guide/installation</a> for all the possibilities. In particular, in our examples, meant for a browser, we’ll be installing RxJS from a CDN, which creates a global <code>rxjs</code> variable, similar to jQuery’s <code>$</code> or Lodash’s <code>_</code> variables.</p>
			<p>Let’s begin by creating observables, and then move on to transforming them. For creation, some of the several operators you can use are explained in the following table:</p>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Operator</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Usage</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>Ajax</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates an observable for an Ajax request, for which we’ll emit the response that is returned</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>from</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Produces an observable out of an array, an iterable, or a promise</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>fromEvent</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Turns events (for example, mouse clicks) into an observable sequence</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>interval</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Emits values at periodic intervals</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>of</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Generates a sequence out of a given set of values</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>range</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Produces a sequence of values in a range</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><code>timer</code></p>
						</td>
						<td class="No-Table-Style">
							<p>After an initial delay, emits values periodically</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>To give an elementary example, the following three observables will all produce a sequence of values from 1 to 10, and we’ll be seeing more practical examples a bit later in this chapter:</p>
			<pre class="source-code">
const obs1$ = from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
const obs2$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
const obs3$ = range(1, 10);</pre>
			<p>The available pipeable operators are way too many for this section, so we’ll just go over some families and describe<a id="_idIndexMarker942"/> their basic idea, with one or two particular mentions. The following table lists the most common families, with their most often used operators:</p>
			<table id="table003" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Family</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><strong class="bold">Combination</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>These operators allow us to join information from several distinct observables, including the following:</p>
							<ul>
								<li><code>concat()</code> to put observables in a queue one after the other</li>
								<li><code>merge()</code> to create a single observable out of many</li>
								<li><code>pairWise()</code> to emit the previous value and the current one as an array</li>
								<li><code>startWith()</code> to inject a value in an observable</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><strong class="bold">Conditional</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>These produce values depending on conditions and include the following:</p>
							<ul>
								<li><code>defaultIfEmpty()</code> emits a value if an observable doesn’t emit anything before completing</li>
								<li><code>every()</code> emits true if all values satisfy a predicate and emits false otherwise</li>
								<li><code>iif()</code> subscribes to one of two observables, depending on a condition, such as the ternary <code>?</code> operator</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><strong class="bold">Error handling</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>These (obviously!) apply to error conditions and include the following:</p>
							<ul>
								<li><code>catchError()</code> to gracefully process an error from an observable</li>
								<li><code>retry()</code> and <code>retryWhen()</code> to retry an observable sequence (most likely, one linked to HTTP requests)</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><strong class="bold">Filtering</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Probably the most important family, providing many operators to process sequences by selecting which elements will get processed or dismissed, by applying different types of conditions for your selection. Some of the more common ones include the following:</p>
							<ul>
								<li><code>debounce()</code> and <code>debounceTime()</code> to deal with values too close together in time</li>
								<li><code>distinctUntilChanged()</code> to only emit when the new value is diﬀerent from the last</li>
								<li><code>filter()</code> to only emit values that satisfy a given predicate</li>
								<li><code>find()</code> to emit only the ﬁrst value that satisﬁes a condition</li>
								<li><code>first()</code> and <code>last()</code> to pick only the ﬁrst or last values of a sequence</li>
								<li><code>skip()</code> plus <code>skipUntil()</code> and <code>skipWhile()</code> to discard values</li>
								<li><code>take()</code> and <code>takeLast()</code> to pick a given number of values from the beginning or end of a sequence</li>
								<li><code>takeUntil()</code> and <code>takeWhile()</code> to pick values and more</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="Table-Paragraph"><strong class="bold"><a id="_idTextAnchor216"/></strong><strong class="bold">Transforming</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>The other very commonly used family, which includes operators to transform the values in a sequence. Some of the many possibilities include these:</p>
							<ul>
								<li><code>buffer()</code> and <code>bufferTime()</code> to collect values and emit them as an array</li>
								<li><code>groupBy()</code> to group values together based on some property</li>
								<li><code>map()</code> to apply a given mapping function to every element in the sequence</li>
								<li><code>partition()</code> to split an observable into two, based on a given predicate</li>
								<li><code>pluck()</code> to pick only some attributes from each element</li>
								<li><code>reduce()</code> to reduce a sequence of values to a single one</li>
								<li><code>scan()</code> works like <code>reduce()</code> but emits all intermediate values</li>
								<li><code>toArray()</code> collects all values and emits them as a single array</li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Utilities</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A sundry collection of operators with different functions, including the following:</p>
							<ul>
								<li><code>tap()</code> to perform a side eﬀect, similar to what we saw in the <em class="italic">Tapping into a ﬂow</em> section in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em></li>
								<li><code>delay()</code> to delay sequence values for some time</li>
								<li><code>finalize()</code> to call a function when an observable completes or produces an error</li>
								<li><code>repeat()</code> is just like <code>retry()</code> but for normal (that is, non-error) cases</li>
								<li><code>timeout()</code> to produce an error if no value is produced before a given duration</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Wow, that’s a lot of operators! We have excluded many, and you could even write your own, so be sure to look at the<a id="_idIndexMarker943"/> documentation. By the way, understanding operators is easier with marble diagrams; we won’t be using them here, but read <a href="http://reactivex.io/documentation/observable.html">reactivex.io/documentation/observable.html</a> for a basic explanation, and then check out <a href="http://rxmarbles.com">rxmarbles.com</a> for many interactive examples of operators and how they function.</p>
			<p>Let’s finish this section with a couple of examples of the possibility of application for your own coding.</p>
			<h3>Detecting multi-clicks</h3>
			<p>Suppose you decided, for some reason or another, that users should be able to triple-click or four-click on<a id="_idIndexMarker944"/> something, and the number of clicks would somehow be meaningful and produce some kind of result. Browsers do very well detecting single- or double-clicks and letting you respond to them, but triple- (or more) clicks aren’t available so easily.</p>
			<p>However, we can make do with a bit of FRP. Let’s start with a truly basic layout, including a text span that the user should click. The code is given here:</p>
			<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Multiple click example&lt;/title&gt;
    &lt;script
      type="text/javascript"
      src="img/rxjs.umd.js"
    &gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;span id="mySpan"
      &gt;Click this text many times (quickly)&lt;/span
    &gt;
    &lt;script&gt;
      // our code goes here...
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>This is as plain as can be; you just get a text on screen, urging you to multi-click it. See <em class="italic">Figure 11</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_11.3_B19301.jpg" alt="Figure 11.3 – A very plain screen to test detecting triple-clicks"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – A very plain screen to test detecting triple-clicks</p>
			<p>To detect these multi-clicks, we’ll need<a id="_idIndexMarker945"/> some RxJS functions, so let’s start with those:</p>
			<pre class="source-code">
const { fromEvent, pipe } = rxjs;
const { buffer, filter } = rxjs.operators;</pre>
			<p>We will use these functions soon enough. How do we detect triple- (or more) clicks? Let’s go straight on to the code given here:</p>
			<pre class="source-code">
const spanClick$ = fromEvent(
  document.getElementById("mySpan"),
  "click"
);
spanClick$
  .pipe(
    buffer(spanClick$.pipe(debounceTime(250))),
    map((list) =&gt; list.length),
    filter((x) =&gt; x &gt;= 3)
  )
  .subscribe((e) =&gt; {
    console.log(`${e} clicks at ${new Date()}`);
  });
/*
5 clicks at Fri Feb 03 2023 18:08:42 GMT-0300
3 clicks at Fri Feb 03 2023 18:08:45 GMT-0300
6 clicks at Fri Feb 03 2023 18:08:47 GMT-0300
4 clicks at Fri Feb 03 2023 18:08:51 GMT-0300
*/</pre>
			<p>The logic is simple:</p>
			<ol>
				<li>We create an observable with <code>fromEvent()</code> to listen to mouse clicks on our span.</li>
				<li>Now, a tricky point – we use <code>buffer()</code> to join together many events, which come from applying <code>debounceTime()</code> to the sequence of clicks, so all clicks that happen within<a id="_idIndexMarker946"/> an interval of 250 milliseconds will get grouped into a single array.</li>
				<li>We then apply <code>map()</code> to transform each array of clicks into just its length – after all, we care about how many clicks there were, not their specific details.</li>
				<li>We finish by filtering out values under <code>3</code>, so only longer sequences of clicks will be processed.</li>
				<li>The subscription just logs the clicks, but in your application, it should do something more relevant.</li>
			</ol>
			<p>If you wanted, you could detect multi-clicks by hand, writing your own code; see <em class="italic">Question 11.3</em> in the <em class="italic">Questions</em> section. Let’s finish with a longer example and do some typeahead searches, invoking some external API.</p>
			<h3>Providing typeahead searches</h3>
			<p>Let’s do another <a id="_idIndexMarker947"/>web example: typeahead searches. The usual setup is that there is some sort of textbox, the user types in it, and the web page queries an API to provide ways of completing the search. The important thing is when and how to do the search, and try to avoid unnecessary calls to the backend server whenever possible. A (totally basic) HTML page could be as follows (see <em class="italic">Figure 11</em><em class="italic">.4</em> later in this section):</p>
			<pre class="source-code">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Cities search&lt;/title&gt;
    &lt;script
      type="text/javascript"
      src="img/rxjs.umd.js"
    &gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Find cities:
    &lt;input type="text" id="myText" /&gt;
    &lt;br /&gt;
    &lt;h4&gt;Some cities...&lt;/h4&gt;
    &lt;div id="myResults"&gt;&lt;/div&gt;
    &lt;script&gt;
      // typeahead code goes here...
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>We now have a single textbox in which the user will type and an area below that in which we’ll show whatever the API<a id="_idIndexMarker948"/> provides. We’ll use the GeoDB Cities API (see <a href="http://geodb-cities-api.wirefreethought.com">geodb-cities-api.wirefreethought.com</a>), which provides many search options, to search for cities starting with whatever the user has typed. To get it out of our way, let’s look at the <code>getCitiesOrNull()</code> function, which will return a promise for search results (if something was typed in) or <code>null</code> (no cities, if nothing was typed in). The results of this promise will be used to fill the <code>myResults</code> division on the page. Let’s see how<a id="_idIndexMarker949"/> this works out in code:</p>
			<pre class="source-code">
const URL = `http://` +
  `geodb-free-service.wirefreethought.com/v1/geo/cities`;
const getCitiesOrNull = (text) =&gt; {
  if (text) {
    const citySearchUrl =
      `${URL}?` +
      `hateoasMode=false&amp;` +
      `sort=-population&amp;` +
      `namePrefix=${encodeURIComponent(text)}`;
    return;
    fetch(citySearchUrl);
  } else {
    return Promise.resolve(null);
  }
};</pre>
			<p>The code is simple – if some text was provided, we generate the URL for the cities’ search and use <code>fetch()</code> to get the API data. With this done, let’s see how to generate the needed observable. We will need some RxJS functions, so first, let’s have some definitions:</p>
			<pre class="source-code">
const { fromEvent, pipe } = rxjs;
const {
  debounceTime,
  distinctUntilChanged,
  filter,
  map,
  reduce,
  switchMap,
} = rxjs.operators;</pre>
			<p>We will be using all of these <a id="_idIndexMarker950"/>functions later. Now, we can write the code to do the typeahead:</p>
			<pre class="source-code">
const textInput$ = fromEvent(
  document.getElementById("myText"),
  "input"
).pipe(
  map((e) =&gt; e.target.value),
  debounceTime(200),
  filter((w) =&gt; w.length === 0 || w.length &gt; 3),
  distinctUntilChanged(),
  switchMap((w) =&gt; getCitiesOrNull(w))
);</pre>
			<p>This requires going step by step:</p>
			<ol>
				<li value="1">We use the <code>fromEvent()</code> constructor to observe input events (every time the user types something) from the <code>myText</code> input field.</li>
				<li>We use <code>map()</code> to get the event’s target value, the complete text of the input field.</li>
				<li>We use <code>debounceTime(200)</code> so that the observable won’t emit until the user has been 0.2 seconds (200 milliseconds) without typing – what’s the use of calling the API if the user isn’t done with their query?</li>
				<li>We then use <code>filter()</code> to discard the input if it was only one, two, or three characters long because that’s not long enough for our search. We accept empty strings (so we’ll empty the results area) and strings four or more characters long.</li>
				<li>Then, we use <code>distinctUntilChanged()</code>, so if the search string is the same as before (the user possibly added a character but quickly backspaced, deleting it), nothing will be emitted.</li>
				<li>Finally, we change <code>switchMap()</code> to cancel the previous subscription to the observable and create a new one using <code>getCitiesOrNull()</code>.</li>
			</ol>
			<p>How do we use this? We subscribe<a id="_idIndexMarker951"/> to the observable, and when we get results, we use them to display values. A possible sample code follows:</p>
			<pre class="source-code">
textInput$.subscribe(async (fetchResult) =&gt; {
  domElem = document.getElementById("myResults");
  if (fetchResult !== null) {
    result = await fetchResult.json();
    domElem.innerHTML = result.data
      .map((x) =&gt; `${x.city}, ${x.region}, ${x.country}`)
      .join("&lt;br /&gt;");
  } else {
    domElem.innerHTML = "";
  }
});</pre>
			<p>An important point – the promise is resolved, and the final value of the sequence is, hence, whatever the promise produced. If the result isn’t <code>null</code>, we get an array of cities, and we use <code>map()</code> and <code>join()</code> to produce the (very basic!) HTML output; otherwise, we empty the results area.</p>
			<p>Let’s try it out. If you start <a id="_idIndexMarker952"/>typing, nothing will happen until you reach at least four characters and pause a bit (see <em class="italic">Figure 11</em><em class="italic">.4</em>, as follows):</p>
			<div><div><img src="img/Figure_11.4_B19301.jpg" alt="Figure 11.4 – Our search for cities doesn’t trigger for less than four characters"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Our search for cities doesn’t trigger for less than four characters</p>
			<p>When you reach four characters and pause for a moment, the observable will emit an event, and we’ll do a first search – in this case, for cities with names starting with <code>MONT</code> (see <em class="italic">Figure 11</em><em class="italic">.5</em>):</p>
			<div><div><img src="img/Figure_11.5_B19301.jpg" alt="Figure 11.5 – After reaching four characters, searches will be ﬁred"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – After reaching four characters, searches will be ﬁred</p>
			<p>Finally, as you add more characters, new API calls will be made, refining the search (see <em class="italic">Figure 11</em><em class="italic">.6</em>).</p>
			<div><div><img src="img/Figure_11.6_B19301.jpg" alt="Figure 11.6 – Further characters are used to reﬁne the search"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Further characters are used to reﬁne the search</p>
			<p>What can we learn from these examples? Using observables for events lets us achieve a good separation of concerns regarding event production and event consumption, and the declarative style of the stream process makes the data flow clearer. Note that even the HTML code has<a id="_idIndexMarker953"/> no reference to click methods or anything like that; the complete code is separate from that.</p>
			<p>We have now seen most of the interesting patterns; let’s finish with some other ones, which may or may not be exactly equivalent to their classic OOP partners.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor217"/>Other patterns</h2>
			<p>Let’s end this section by glancing at some other patterns where the equivalence may or may not be so good:</p>
			<ul>
				<li><strong class="bold">Currying and partial application</strong> (which we saw in <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>: This can be seen as approximately equivalent to a <em class="italic">Factory</em> for functions. Given a general function, you can produce<a id="_idIndexMarker954"/> specialized cases by fixing one or more arguments, which is, in essence, what a Factory does – speak about functions and not objects.</li>
				<li><code>map()</code> or <code>reduce()</code>): These can be considered an application of the<a id="_idIndexMarker955"/> Iterator pattern. The traversal of the container’s elements is decoupled from the container itself. You can also provide different <code>map()</code> methods for different objects to traverse all kinds of data structures.</li>
				<li><strong class="bold">Persistent data structures</strong>: As mentioned in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, these allow for the<a id="_idIndexMarker956"/> implementation of the Memento pattern. The central idea is, given an object, to be able to go back to a previous state. As we saw, each updated version of a data structure doesn’t affect the previous one(s), so you could easily add a mechanism to provide an earlier state and <em class="italic">roll back</em> to it.</li>
				<li>A <code>find()</code> to determine which processor will handle the request (the desired one is the first in the list that accepts the request) and then simply doing the required process.</li>
			</ul>
			<p>Remember the warning at the beginning – with these patterns, the match with FP techniques may not be as perfect as with others that we have previously seen. However, the idea is to show that some common FP patterns can be applied and will produce the same results as the OOP solutions, despite having different implementations.</p>
			<p>Now, after having seen several OOP equivalent patterns, let’s move on to more specific FP ones.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor218"/>Functional design patterns</h1>
			<p>Having seen several OOP <a id="_idIndexMarker958"/>design patterns, it may seem a cheat to say that there’s no approved, official, or even remotely generally accepted similar list of patterns for FP. There are, however, several problems for which there are standard FP solutions, which can be considered design patterns on their own, and we have already covered most of them in this book.</p>
			<p>What are the candidates for a possible list of patterns? Let’s attempt to prepare one – but remember that it’s just a personal view. Also, I’ll admit that I’m not trying to mimic the usual style of pattern definition; I’ll just be mentioning a general problem and refer to the way FP in JavaScript can solve it, and I won’t be aiming for nice, short, and memorable names for the patterns either:</p>
			<ul>
				<li><code>filter()</code>, <code>map()</code>, and <code>reduce()</code>, as we saw in this chapter and previously in <a href="B19301_05.xhtml#_idTextAnchor084"><em class="italic">Chapter 5</em></a>, <em class="italic">Programming Declaratively</em>, is a way to remove complexity from the problem. (The usual <code>MapReduce</code> web framework is an extension of this concept, which allows for distributed processing among several servers, even if the implementation and details aren’t exactly the same.) Instead of performing looping and processing as a single step, you should think about the problem as a sequence of steps, applied in order, and doing transformations until obtaining the final, desired result.</li>
			</ul>
			<p class="callout-heading">Looping in other ways</p>
			<p class="callout">JavaScript also includes <em class="italic">iterators</em>, another way of looping through a collection. Using iterators isn’t particularly functional, but you may want to look at them, since they may be able to simplify some situations. Read more at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols</a>.</p>
			<ul>
				<li><strong class="bold">Lazy evaluation with thunks</strong>: The idea of lazy evaluation is not doing any calculations until they <a id="_idIndexMarker960"/>are actually needed. In some programming languages, this is built in. However, in JavaScript (and most imperative languages), <em class="italic">eager evaluation</em> is applied, in which an expression is evaluated as soon as it is bound to some variable. (Another way of saying this is that JavaScript is a <em class="italic">strict programming language</em>, with a <em class="italic">strict paradigm</em>, which only allows calling a function if all of its parameters have been completely evaluated.) This sort of evaluation is required when you need to specify the order of evaluation with precision, mainly because such evaluations may have side effects.</li>
			</ul>
			<p>In FP, which is more declarative and pure, you can delay such evaluation with <em class="italic">thunks</em> (which we used in the <em class="italic">Trampolines and thunks</em> section of <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a><em class="italic">, Designing Functions</em>) by passing a thunk that will calculate the needed value only when it’s needed, but not earlier.</p>
			<p class="callout-heading">Generating more results</p>
			<p class="callout">You may also want to look at JavaScript generators, another way of delaying evaluation, though not particularly related to FP. Read more about them at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator</a>. The combination of generators and promises is called an <code>async</code> function, which may be of interest to you; refer to <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a>.</p>
			<ul>
				<li><strong class="bold">Persistent data structures for immutability</strong>: Having immutable data structures, as we saw in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, is mandatory<a id="_idIndexMarker961"/><a id="_idIndexMarker962"/> when working with certain frameworks, and in general, it is recommended because it helps to reason about a program or to debug it. (Earlier in this chapter, we also mentioned how the <em class="italic">Memento</em> OOP pattern can be implemented in this fashion.) Whenever you have to represent structured data, the FP solution of using a persistent data structure helps in many ways.</li>
				<li><code>null</code> before trying to access the corresponding object). This pattern aims to wrap a value within an object or function, so direct manipulation won’t be possible, and checks can be managed more functionally. We’ll refer to more of this in <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building </em><em class="italic">Better Containers</em>.</li>
			</ul>
			<p>As we have said, the power of FP is such that, instead of having a couple of dozen standard design patterns (and that’s only in the GoF book; if you read other texts, the list grows!), there isn’t yet a standard or acknowledged list of functional patterns.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor219"/>Summary</h1>
			<p>In this chapter, we have made a bridge from the OO way of thinking and the usual patterns we use when coding that way to the FP style, by showing how we can solve the same basic problems but relatively more easily than with classes and objects. We have seen several common design patterns, and we’ve seen that the same concepts apply in FP, even if implementations may vary, so now you have a way to apply those well-known solution structures to your JavaScript coding.</p>
			<p>In <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, we will be working with a potpourri of FP concepts, giving you even more ideas about tools you can use. I promised that this book wouldn’t be deeply theoretical but, rather, more practical, and we’ll try to keep it this way, even if some of the presented concepts may seem abstruse or remote.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor220"/>Questions</h1>
			<p>11.1 <strong class="bold">Decorating methods, the future way</strong>: In <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we wrote a decorator to enable logging for any function. Currently, method decorators are being considered for upcoming versions of JavaScript: refer to <a href="http://tc39.github.io/proposal-decorators">tc39.github.io/proposal-decorators</a> for more information on that. (A Stage 2 Draft means that inclusion of this feature in the standard is likely, although there may be some additions or small changes. TypeScript provides decorators today, but warns that <em class="italic">“Decorators are an experimental feature that may change in future releases”</em>; see more at <a href="http://www.typescriptlang.org/docs/handbook/decorators.html">www.typescriptlang.org/docs/handbook/decorators.html</a>.) Study the following code and take a look at what makes the next code tick:</p>
			<pre class="source-code">
const logging = (target, name, descriptor) =&gt; {
  const savedMethod = descriptor.value;
  descriptor.value = function (...args) {
    console.log(`entering ${name}: ${args}`);
    try {
      const valueToReturn = savedMethod.bind(this)(...args);
      console.log(`exiting ${name}: ${valueToReturn}`);
      return valueToReturn;
    } catch (thrownError) {
      console.log(`exiting ${name}: threw ${thrownError}`);
      throw thrownError;
    }
  };
  return descriptor;
};</pre>
			<p>A working example would be as follows:</p>
			<pre class="source-code">
class SumThree {
  constructor(z) {
    this.z = z;
  }
<strong class="bold">  @logging</strong>
  sum(x, y) {
    return x + y + this.z;
  }
}
new SumThree(100).sum(20, 8);
// entering sum: 20,8
// exiting sum: 128</pre>
			<p>The following are some questions about the code for <code>logging()</code>:</p>
			<ul>
				<li>What’s the need for the <code>savedMethod</code> variable?</li>
				<li>Why do we use <code>function()</code> when assigning a new <code>descriptor.value</code>, instead of an arrow function?</li>
				<li>Why is <code>.</code><code>bind()</code> used?</li>
				<li>What is <code>descriptor</code>?</li>
			</ul>
			<p>11.2 <code>addBar()</code> function, which will add some mixins to the <code>Foo</code> class so that the code will run as shown. The created <code>fooBar</code> object should have two attributes (<code>fooValue</code> and <code>barValue</code>) and two methods (<code>doSomething()</code> and <code>doSomethingElse()</code>) that simply show some text and properties, as shown here:</p>
			<pre class="source-code">
class Foo {
  constructor(fooValue) {
    this.fooValue = fooValue;
  }
  doSomething() {
    console.log("something: foo... ", this.fooValue);
  }
}
<strong class="bold">const addBar = (BaseClass) =&gt; {</strong>
<strong class="bold">  /*</strong>
<strong class="bold">  your code goes here</strong>
<strong class="bold">  */</strong>
<strong class="bold">};</strong>
const fooBar = new (addBar(Foo))(22, 9);
fooBar.doSomething();
// something: foo... 22
fooBar.somethingElse();
// something else: bar... 9
console.log(Object.keys(fooBar));
// ["fooValue", "barValue"]</pre>
			<p>Could you include a third mixin, <code>addBazAndQux()</code>, so that <code>addBazAndQux(addBar(Foo))</code> would add even more attributes and methods to <code>Foo</code>?</p>
			<p>11.3 <strong class="bold">Multi-clicking by hand</strong>: Can you write your own multi-click detection code, which should work exactly as in our example?</p>
			<p>11.4 <code>false</code> values first and <code>true</code> values last?</p>
			<p>11.5 <strong class="bold">Finding routes, objectively</strong>: Working in an object-oriented fashion, the route-finding problem would have been solved in another way, involving classes and subclasses. How? (Tip: the answer to this question is a pattern we have mentioned in this chapter.)</p>
		</div>
	</body></html>