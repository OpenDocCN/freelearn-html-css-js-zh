<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Testing Backbone Applications</h1></div></div></div><p>It does not matter if you are an experienced programmer, it's very normal that you will commit mistakes in your code at some point in time. Nobody is perfect and errors happen all the time in software development. Your work as a developer is to minimize the number of defects that are in your software.</p><p>Errors can occur from <a id="id313" class="indexterm"/>different sources; an unexpected input, an error that is not handled properly, a change in a third-party plugin, a memory issue, and so on. Your code should be prepared to deal with these kind of things.</p><p>In the software industry, the rule of thumb is to always test your code. When you test your applications, the final product has a better quality as many defects have been detected and corrected before the users notice it.</p><p>Tests are not just undertaken to prevent bugs in the software. The following is a list of benefits that you get when you do the testing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Improves end-product quality</li><li class="listitem" style="list-style-type: disc">Makes you confident with your application</li><li class="listitem" style="list-style-type: disc">Allows you to refactor pieces of code safely</li><li class="listitem" style="list-style-type: disc">Preserves functionality</li><li class="listitem" style="list-style-type: disc">Simulates errors and improves your error handling code</li><li class="listitem" style="list-style-type: disc">Improves your code, forcing you to make testable code</li></ul></div><p>If you have never tested your software, now you have good reasons to start doing it. <code class="literal">Make</code> testing can slow down your development process at the start; however, you will see the benefits in the mid time.</p><p>In this chapter, you will learn the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which tools are available to test frontend applications</li><li class="listitem" style="list-style-type: disc">What and how to test Backbone applications</li><li class="listitem" style="list-style-type: disc">How to apply best practices for application testing</li><li class="listitem" style="list-style-type: disc">How to run your tests automatically</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Testing tools</h1></div></div></div><p>A<a id="id314" class="indexterm"/> testing tool can <a id="id315" class="indexterm"/>be a library or framework that helps you to write tests for your applications and evaluate the results. Under testing tools, you can find the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Testing libraries</strong>: This <a id="id316" class="indexterm"/>gives you a hook and functions to describe tests</li><li class="listitem" style="list-style-type: disc"><strong>Assertion libraries</strong>: This <a id="id317" class="indexterm"/>gives you functions to make expectations</li><li class="listitem" style="list-style-type: disc"><strong>Test runners</strong>: This <a id="id318" class="indexterm"/>discovers and runs your tests</li><li class="listitem" style="list-style-type: disc"><strong>Test coverage</strong>: This <a id="id319" class="indexterm"/>tells you which parts of your code are tested and which are not</li><li class="listitem" style="list-style-type: disc"><strong>Test reports</strong>: This <a id="id320" class="indexterm"/>makes reports in different formats such as HTML and JSON</li><li class="listitem" style="list-style-type: disc"><strong>Mocking, stubbing, faking tools</strong>: These<a id="id321" class="indexterm"/> give you<a id="id322" class="indexterm"/> ways to <a id="id323" class="indexterm"/>make fake objects with predictable behavior</li><li class="listitem" style="list-style-type: disc"><strong>Module mocking</strong>: This <a id="id324" class="indexterm"/>replaces a required module with a fake module and is useful to isolate modules</li><li class="listitem" style="list-style-type: disc"><strong>Stress tools</strong>: This <a id="id325" class="indexterm"/>makes many requests to the applications in order to see how it behaves in high demand circumstances</li><li class="listitem" style="list-style-type: disc"><strong>Browser testing</strong>: This <a id="id326" class="indexterm"/>emulates a user making inputs in the application as a whole</li></ul></div><p>Explaining and showing how all these tools work is out of scope of this book. In this chapter, you will work with testing libraries, asserting libraries, testing runners, and mocking.</p><p>For JavaScript, there are many testing libraries available for you; however, two of them are more popular at the moment of writing this book: <code class="literal">Jasmine</code> and <code class="literal">Mocha</code>.</p><p>
<code class="literal">Mocha</code> is a small library that allows you to write tests harness, it does not have any assertion functions by itself. What it means is that you should integrate <code class="literal">Mocha</code> with an assertion library of your choice; a very popular choice is to use a combination of Mocha and Chai.js.</p><p>
<code class="literal">Jasmine</code> is more like a framework, it provides an API that is very similar to Mocha; however, it includes assertion functions. Therefore, it is simpler to use as you do not need to create an extra step.</p><p>For this book, we will use Jasmine as it is the most popular testing tool and is easier to start working with. In the same way as Mocha, you can use Jasmine as a test runner and select different types of reports.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Getting started with Jasmine</h1></div></div></div><p>To write tests, you <a id="id327" class="indexterm"/>should create two things: test suites and specs. A spec (short for specification) is a piece of functionality that you are testing from your code; for example, if your code is calculating tax of 5% for $100.00, you would expect it to be $5. A test suite is a set of expectations that are grouped under a topic. In the preceding example, the test suite can be "Invoice totals calculation".</p><p>To start<a id="id328" class="indexterm"/> working with Jasmine, you should install it from npm, as follows:</p><div><pre class="programlisting">
<strong>$ npm install --save-dev jasmine</strong>
</pre></div><p>Then, you can start writing your tests. With Jasmine, you have two functions: <code class="literal">describe()</code> to create test suites and <code class="literal">it()</code> to make specs:</p><div><pre class="programlisting">// specs/mathSpec.js	
describe('Basic mathematicfunctions', () =&gt; {
it('should result 4 the sum of 2 + 2', () =&gt; {
  });

it('should result 1 the substract of 3 - 2', () =&gt; {
  });

it('should result 3 the division of 9 / 3', () =&gt; {
  });

it('should throw an error when divide by zero', () =&gt; {
  });
});</pre></div><p>The preceding code defines a test suite for a hypothetical set of math functions. Notice how in the <code class="literal">describe()</code> function, you should write a text that tells the people what is the context of the tests; while<a id="id329" class="indexterm"/> in the <code class="literal">it()</code> function, the text should tells what are you testing.</p><p>Now, let's build the <code class="literal">math</code> functions for the test suite, as follows:</p><div><pre class="programlisting">// app/js/math.js
var math = {
sum(a, b) {
return a + b;
  },

substract(a, b) {
return a - b;
  },

divide(a, b) {
if (b === 0) {
throw new Error('Can not divide by zero');
    }

return a / b;
  }
};

module.exports = math;</pre></div><p>The <code class="literal">math</code> object has the necessary functions to pass the test suite; however, to actually test the <code class="literal">math</code> object, you will need to make a set of expectations.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec46"/>Expectations</h2></div></div></div><p>Expectations <a id="id330" class="indexterm"/>are functions that compare the output of a function with an expected output. In the following example, we call the <code class="literal">sum()</code> function with an input of <code class="literal">2</code> and <code class="literal">2</code>. We are expecting that the result should be <code class="literal">4</code>:</p><div><pre class="programlisting">expect(sum(2, 2)).toEqual(4);</pre></div><p>The <code class="literal">toEqual()</code>expectation function compares whether the output of the function and the expected value are equal; if both are the same, the test will pass, otherwise, it will fail. The following table shows the most common expectations in Jasmine, consult the documentation for a complete set of available expectation functions:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Expectation function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">toEqual</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The values should be exactly equal</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">expect('hello')</code>
</p>
<p>
<code class="literal">.toEqual('hello')</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">toMatch</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value will be RegEx matched</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">expect('Hello')</code>
</p>
<p>
<code class="literal">   .toMatch(/[Hh]ello/)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">toBeTruthy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value should be a truth value</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">expect(true)</code>
</p>
<p>
<code class="literal">  .toBeTruthy();</code>
</p>
<p>
<code class="literal">expect(100)</code>
</p>
<p>
<code class="literal">  .toBeTruthy();</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">toBeFalsy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value should be a false value</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">expect(false)</code>
</p>
<p>
<code class="literal">  .toBeFalsy();</code>
</p>
<p>
<code class="literal">expect(null)</code>
</p>
<p>
<code class="literal">  .toBeFalsy();</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">toThrowError</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This verifies that the function that is called throws an error</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">expect(function() {</code>
</p>
<p>
<code class="literal">math.divide(1, 0);</code>
</p>
<p>
<code class="literal">}).toThrowError();</code>
</p>
</td></tr></tbody></table></div><p>After adding all the <a id="id331" class="indexterm"/>expectations to the example test suite that we have, the code should be something as follows:</p><div><pre class="programlisting">// spec/mathSpec.js
var math = require('../app/js/math');

describe('Basic mathematic functions', () =&gt; {
it('should result 4 the sum of 2 + 2', () =&gt; {
expect(math.sum(2, 2)).toBe(4);
  });

it('should result 1 the substract of 3 - 2', () =&gt; {
expect(math.substract(3, 2)).toBe(1);
  });

it('should result 3 the division of 9 / 3', () =&gt; {
expect(math.divide(9, 3)).toBe(3);
  });

it('should throw an error when divide by zero', () =&gt; {
expect(() =&gt;math.divide(9, 0)).toThrowError();
  });
});</pre></div><p>To run the test suite, you should first configure the Jasmine test runner. To do this, you should create a script:</p><div><pre class="programlisting">// spec/run.js
var Jasmine = require('jasmine');
var jasmine = new Jasmine();

jasmine.loadConfig({
spec_dir: 'spec',
spec_files: [
    '**/*[sS]pec.js'
  ]
});

jasmine.execute();</pre></div><p>Jasmine will look <a id="id332" class="indexterm"/>for tests under the <code class="literal">spec/</code>directory, it will look for all those files that end with <code class="literal">spec.js</code> or <code class="literal">Spec.js</code>. As our test file is named <code class="literal">mathSpec.js</code>, the Jasmine test runner will load and run it, as shown in the following:</p><div><pre class="programlisting">
<strong>$ node spec/run.js</strong>
<strong>Started</strong>
<strong>....</strong>


<strong>4 specs, 0 failures</strong>
<strong>Finished in 0.008 seconds</strong>
</pre></div><p>You can see what happens if the test fails; for example, you change the sum test to <code class="literal">5</code> instead of <code class="literal">4</code>:</p><div><pre class="programlisting">
<strong>$ node spec/run.js</strong>
<strong>Started</strong>
<strong>F...</strong>

<strong>Failures:</strong>
<strong>1) Basic mathematic functions should result 4 the sum of 2 + 2</strong>
<strong>  Message:</strong>
<strong>    Expected 4 to be 5.</strong>
<strong>  Stack:</strong>
<strong>    Error: Expected 4 to be 5.</strong>
<strong>at Object.&lt;anonymous&gt;(/path/to/your/project/spec/mathSpec.js:5:28)</strong>

<strong>4 specs, 1 failure</strong>
<strong>Finished in 0.009 seconds</strong>
</pre></div><p>Now, if you make a mistake, Jasmine will tell you what's wrong. Notice how Jasmine will inform you about the error:</p><div><blockquote class="blockquote"><p><em>"Basic mathematic functions should result 4 the sum of 2 + 2"</em></p></blockquote></div><p>Then, it tells <a id="id333" class="indexterm"/>you that it was expecting <code class="literal">5</code> and instead received <code class="literal">4</code>. Please note that it is very important what messages you put in the <code class="literal">describe()</code> and <code class="literal">it()</code> functions as they will help you to quickly diagnose what's wrong.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec47"/>Testing asynchronous code</h2></div></div></div><p>When <a id="id334" class="indexterm"/>you need to test a code that is asynchronous like an Ajax call, you will need to make an extra step. When you write the <code class="literal">it()</code> function, you should pass a <code class="literal">done</code> argument and Jasmine will put a callback function there, which you should call when the test is done.</p><p>To illustrate this, let's simulate an asynchronous task that sum two numbers, as follows:</p><div><pre class="programlisting">var math = {
  // ...

asyncSum(a, b, callback) {
    // Will respond after 1.5 seconds.
setTimeout(function() {
callback(a + b);
    }, 1500);
  },

  // ...
};</pre></div><p>Following the JavaScript standard, the <code class="literal">syncSum()</code> function receives a third argument, which is the callback function that will be called when the sum is ready. In the following example, the callback function will be called after 1,500 milliseconds:</p><div><pre class="programlisting">math.asyncSum(2, 2, result =&gt; {
  // After 1500ms result will be equal to 4
});</pre></div><p>To make a test with this function, we <a id="id335" class="indexterm"/>should pass a <code class="literal">done</code> callback to the <code class="literal">it()</code> function:</p><div><pre class="programlisting">it('sums two numbers asynchronously', done =&gt; {
math.asyncSum(2, 2, function(result) {
expect(result).toEqual(4);
done();
  });
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Karma test runner</h1></div></div></div><p>Karma is a <a id="id336" class="indexterm"/>popular test runner for JavaScript, it works with many other testing libraries and frameworks such as Jasmine and Mocha. The Node test runner that comes with Jasmine is fine; however, Karma adds superpowers to the equation.</p><p>With Karma, you can run your tests on real web browsers such as Google Chrome, Firefox, Opera, and so on. Once Karma is set and running, it will take care of lookup for the files to test, run it, and then give you a report.</p><p>You will need to install Karma before starting to work with it:</p><div><pre class="programlisting">
<strong>$ npm install --save-dev karma karma-jasmine karma-browserify karma-chrome-launcher karma-spec-reporter</strong>
</pre></div><p>Then, you can configure Karma with a script named <code class="literal">karma.conf.js</code>:</p><div><pre class="programlisting">// Karma configuration
// http://karma-runner.github.io/0.12/config/configuration-file.html

module.exports = function(config) {
  'use strict';

config.set({
    // enable / disable watching file and executing tests whenever
    // any file changes
autoWatch: true,

    // base path, that will be used to resolve files and exclude
basePath: '',

    // testing framework to use (jasmine/mocha/qunit/...)
frameworks: ['browserify', 'jasmine'],

    // list of files / patterns to load in the browser
files: [
      'spec/**/*Spec.js'
    ],

    // preprocess matching files before serving them to 
    // the browser available preprocessors:
    // https://npmjs.org/browse/keyword/karma-preprocesso
preprocessors: {
      'spec/**/*Spec.js': ['browserify']
    },

    // Cobfigure how to bundle the test files with Browserify
browserify: {
debug: true,
transform: ['jstify'],
extensions: ['.js', '.tpl']
    },

    // report on console and growl if available
    //
    // More info about growl notifications on
    // http://mattn.github.io/growl-for-linux/
    // http://growl.info/
reporters: ['spec'],

    // list of files / patterns to exclude
exclude: [],

    // web server port
port: 9876,

    // enable / disable colors in the output (reporters and logs)
colors: true,

    // level of logging
    // possible values:
    // LOG_DISABLE || LOG_ERROR || LOG_WARN || 
    // LOG_INFO || LOG_DEBUG
logLevel: config.LOG_INFO,

    // Continuous Integration mode
    // if true, it capture browsers, run tests and exit
singleRun: false,

    // Start these browsers, currently available:
    // - Chrome
    // - ChromeCanary
    // - Firefox
    // - Opera
    // - Safari (only Mac)
    // - PhantomJS
    // - IE (only Windows)
browsers: ['Chrome']
});
};</pre></div><p>The <code class="literal">files</code> field tells to<a id="id337" class="indexterm"/> Karma which files will be tested in the <code class="literal">glob</code> format. The <code class="literal">preprocessors</code> field tells to Karma whether the files selected from the <code class="literal">files</code> field should be preprocessed before running the tests. As we are using Browserify to manage the dependencies, we should preprocess the files with Browserify in order to create a test bundle.</p><p>You can choose how you want Karma to report the test status to you. The <code class="literal">reporters</code> field makes this possible, you can search for more reporters available; however, the <code class="literal">spec</code> reporter is one of the most used.</p><p>Once Karma is configured, you can run the tests that we have with Karma instead of the Jasmine test runner:</p><div><pre class="programlisting">
<strong>$ ./node_modules/karma/bin/karma start </strong>
</pre></div><p>You can automatize how you run Karma with Gulp, after all that's its job:</p><div><pre class="programlisting">
<strong>// configuration of Gulp</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>What and how to test Backbone applications</h1></div></div></div><p>Backbone library has<a id="id338" class="indexterm"/> different components, each one with its own intentions and responsibilities, that's why you have to test them differently. Keep it in mind that you should only test your code and not the Backbone built-in functionalities.</p><p>In the next sections, you will see what are the parts of your Backbone applications and how to test them; we will start from simple things and then go for more complex ones. Then, you will learn how to<a id="id339" class="indexterm"/> isolate modules to only test one module at time.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Testing models and collections</h1></div></div></div><p>The most basic <a id="id340" class="indexterm"/>test is to ensure that models and <a id="id341" class="indexterm"/>collections have the right properties <a id="id342" class="indexterm"/>set in order to prevent accidental changes in its properties. In the<a id="id343" class="indexterm"/> case of models, you can test the default values when a new contact is created and verify that the <code class="literal">url</code> attribute is right:</p><div><pre class="programlisting">// spec/apps/contacts/models/contactSpec.js
var Contact = require('../../../../app/js/apps/contacts/models/contact');

describe('Contact model', () =&gt; {
describe('creating a new contact', () =&gt; {
it('has the default values', () =&gt; {
var contact = new Contact();

expect(contact.get('name')).toEqual('');
expect(contact.get('phone')).toEqual('');
expect(contact.get('email')).toEqual('');
expect(contact.get('address1')).toEqual('');
expect(contact.get('address2')).toEqual('');
expect(contact.get('avatar')).toEqual(null);
    });
  });

it('has the rigthurl', () =&gt; {
var contact = new Contact();
expect(contact.url()).toEqual('/api/contacts');
  });
});</pre></div><p>For collections, you can verify that the <code class="literal">url</code> is right:</p><div><pre class="programlisting">// spec/apps/contacts/collections/contactCollectionSpec.js
varContactCollection = require('../../../../app/js/apps/contacts/collections/contactCollection');

describe('Contac collection', () =&gt; {
it('has the rigthurlRoot', () =&gt; {
var collection = new ContactCollection();
expect(collection.url).toEqual('/api/contacts');
  });
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Testing views</h1></div></div></div><p>Views<a id="id344" class="indexterm"/> manage the relationship between data (such as, models or collections) and the user interactions (DOM). In the case of views, you should test for the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rendering: Given a model or collection, you should verify that the output HTML is the right one</li><li class="listitem" style="list-style-type: disc">Events: This verifies that the DOM events are handled correctly</li><li class="listitem" style="list-style-type: disc">Model changes: If the model changes something, the view should be in sync</li></ul></div><p>For this<a id="id345" class="indexterm"/> example, we are going to test the <code class="literal">ContactForm</code> view; the responsibility of this view is to show a form to the user and then get the user input to update a model.</p><p>When making test on views, it is recommended to use a fake model and not the original <code class="literal">Contact</code> model. The main reason for this is to isolate the <code class="literal">ContactView</code> object so that if a test fails, you will know that the error is isolated in the view and does not depend on the <code class="literal">Contact</code> model.</p><p>You can start testing whether the rendered HTML is right, as follows:</p><div><pre class="programlisting">var Backbone = require('backbone');
var ContactForm = require('../../../../app/js/apps/contacts/views/contactForm');

describe('Contact form', () =&gt; {
var fakeContact;

beforeEach(() =&gt; {
fakeContact = new Backbone.Model({
name: 'John Doe',
facebook: 'https://www.facebook.com/john.doe',
twitter: '@john.doe',
github: 'https://github.com/johndoe',
google: 'https://plus.google.com/johndoe'
    });
  });

it('has the rigth class', () =&gt; {
var view = new ContactForm({model: fakeContact});
expect(view.className).toEqual('form-horizontal');
  });

it('renders the rigth HTML', () =&gt; {
var view = new ContactForm({model: fakeContact});

view.render();

expect(view.$el.html()).toContain(fakeContact.get('name'));
expect(view.$el.html()).toContain(fakeContact.get('twitter'));
expect(view.$el.html()).toContain(fakeContact.get('github'));
expect(view.$el.html()).toContain(fakeContact.get('google'));
expect(view.$el.html())
.toContain(fakeContact.get('facebook'));
  });
});</pre></div><p>Note how<a id="id346" class="indexterm"/> in the <a id="id347" class="indexterm"/>test, we are looking in the output HTML if contains a specific text on it. You can use specific selectors instead:</p><div><pre class="programlisting">expect(view.$el.find('#name').val())
.toContain(fakeContact.get('name'));</pre></div><p>However, it is not recommended to do this in unstable applications as the design can quickly change and the tests will fail even if the name is on the screen:</p><div><img src="img/B01962_08_01.jpg" alt="Testing views"/><div><p>Figure 8.1 Jasmine testing functions</p></div></div><p>Figure 8.1 illustrates <a id="id348" class="indexterm"/>the relationship between the <code class="literal">beforeEach()</code>, <code class="literal">afterEach()</code>, and <code class="literal">it()</code> functions. When you define one or more <code class="literal">beforeEach()</code> functions in <code class="literal">describe()</code>, then all the <code class="literal">beforeEach()</code> functions will always be executed before the <code class="literal">it()</code> functions. This feature is very useful as you can ensure the same initial conditions for each test.</p><p>In the<a id="id349" class="indexterm"/> example test suite for the <code class="literal">ContactForm</code> object, we are ensuring that <code class="literal">fakeContact</code> always has the same attributes; if you change something in the model under an <code class="literal">it()</code> function, the next function will always get a clean <code class="literal">fakeContact</code> model to test.</p><p>The <code class="literal">ContactForm</code> object has a <strong>Save</strong> button that triggers a <code class="literal">form:save</code> event when it is clicked; to test this, you can listen for the event on a Jasmine <strong>spy function</strong>. A spy function is<a id="id350" class="indexterm"/> a function that does nothing but record when and how it is called. Then, you can use it to make expectation in it:</p><div><pre class="programlisting">it('triggers a form:save event when save button is cliecked', () =&gt; {
var view = new ContactForm({model: fakeContact});
var callback = jasmine.createSpy('callback');

view.on('form:save', callback);
view.render();

// Emulate a user click
view.$el.find('#save').trigger('click');

expect(callback).toHaveBeenCalled();
});</pre></div><p>The <code class="literal">createSpy()</code> method <a id="id351" class="indexterm"/>of Jasmine creates a spy function that will be used as the event handler for the <code class="literal">from:save</code> event. Then, it emulates a click event on the save button and tests whether the <code class="literal">callback</code> function was called.</p><p>We can go a <a id="id352" class="indexterm"/>step forward and check whether the function is called with the model as argument:</p><div><pre class="programlisting">expect(callback).toHaveBeenCalledWith(mockContact);</pre></div><p>Now is time to test when the user makes the input in the form and then click the <strong>Save</strong> button; what we are expecting from it is that the model changes with the input values:</p><div><pre class="programlisting">it('updates the model when the save button is clicked', () =&gt; {
var view = new ContactForm({model: fakeContact});
var callback = jasmine.createSpy('callback');
varexpectedValues = {
name: 'Jane Doe',
facebook: 'https://www.facebook.com/example',
twitter: '@example',
github: 'https://github.com/example',
google: 'https://plus.google.com/example'
  };

view.on('form:save', callback);
view.render();

  // Change the input fields
  view.$el.find('#name').val(expectedValues.name);
view.$el.find('#facebook').val(expectedValues.facebook);
view.$el.find('#twitter').val(expectedValues.twitter);
view.$el.find('#github').val(expectedValues.github);
view.$el.find('#google').val(expectedValues.google);

  // Emulate a change events on all input fields
view.$el.find('input').trigger('change');

  // Emulate a user click
view.$el.find('#save').trigger('click');

// Get the argument passed to the callback function
var callArgs = callback.calls.argsFor(0);
var model = callArgs[0];

expect(model.get('name')).toEqual(expectedValues.name);
expect(model.get('facebook')).toEqual(expectedValues.facebook);
expect(model.get('twitter')).toEqual(expectedValues.twitter);
expect(model.get('github')).toEqual(expectedValues.github);
expect(model.get('google')).toEqual(expectedValues.google);
});</pre></div><p>In this test, we<a id="id353" class="indexterm"/> are <a id="id354" class="indexterm"/>changing the values in the input fields and then clicking the save button in the form. The <code class="literal">callback</code> spy function records how the <code class="literal">form:save</code> event is triggered and extracts the argument passed to it. We can use this argument to test whether the model was updated as expected.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Testing controllers</h1></div></div></div><p>Controllers <a id="id355" class="indexterm"/>are more complex than test as they have more dependencies than the models, collections, and views. If you explore the code <a id="id356" class="indexterm"/>on these objects, you will see that the only dependencies that they have are Backbone and Underscore.</p><p>You can test the controllers with all its dependencies, which means that while testing the <code class="literal">ContactEditor</code> controller, you will be testing all the views and models attached to it as the module requires these objects.</p><p>That's not good for unit testing as you will end up with integration tests instead. If the <code class="literal">Contact</code> model has a defect, then <code class="literal">ContactEditor</code> will fail, even if it does not have any error in it.</p><p>You need to isolate the modules from the mess of other modules. Keep in mind that you should trust your libraries as they will already have their test suites. We need a mechanism to fake the dependencies of a module.</p><p>With dependency injection, you can overwrite the <code class="literal">require()</code> function, instead of loading the script that points, in order to use a fake object. This will guarantee that the code that is being tested is isolated and its behavior is predictable for unit testing.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec48"/>Mocking dependencies</h2></div></div></div><p>There are<a id="id357" class="indexterm"/> two main choices to mock dependencies in Node: <code class="literal">rewire</code> and <code class="literal">proxyquireify</code>; with these libraries, you can overwrite the original dependencies of a module in order to use a fake version instead.</p><p>With Browserify, you should have <code class="literal">proxyquireify</code>. Install it with npm, as follows:</p><div><pre class="programlisting">
<strong>$ npm install --save-dev proxyquirefy</strong>
</pre></div><p>Once the library is installed, we need to add a proper configuration in the Karma configuration file:</p><div><pre class="programlisting">// ...

browserify: {
debug: true,
plugin: ['proxyquireify/plugin'],
transform: ['jstify'],
extensions: ['.js', '.tpl']
},

// ...</pre></div><p>You should initialize <code class="literal">proxyquireify</code> before using it. As <code class="literal">proxyquireify</code> overwrites the original <code class="literal">require()</code> function, it should be initialized before being used. The initialization function returns a function object that is similar to the original <code class="literal">require()</code> function; however, with the the extra functionality of fake dependencies, as shown in the following:</p><div><pre class="programlisting">var proxyquire = require('proxyquireify')(require);</pre></div><p>The <code class="literal">proxyquire</code> object can be used to load modules:</p><div><pre class="programlisting">var ContactViewer = proxyquire('./contacts/contactViewer');</pre></div><p>When you load a module with <code class="literal">proxyquireify</code>, you can use a second argument to overwrite the original dependencies. It is an object where the keys are the name of the dependencies and the values are the object that will substitute the original dependency:</p><div><pre class="programlisting">var targetFile = '../../app/js/apps/contacts/contactViewer';
var fakes = {
'./views/ContactView': Backbone.View
}
var ContactViewer = proxyquire(targetFile, fakes);</pre></div><p>This configuration <a id="id358" class="indexterm"/>will replace the <code class="literal">ContactView</code> object with an empty <code class="literal">Backbone.View</code> object so that when testing the <code class="literal">ContactViewer</code> object, the module will not load the original <code class="literal">ContactView</code> module.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec49"/>Fake objects</h2></div></div></div><p>A <a id="id359" class="indexterm"/>fake object is a simple object that has the same functions as an original one; however, with a predictable behavior so that you can use fake objects to isolate the module under test. For example, all our controllers depend on the <code class="literal">App</code> object to work; however, it is not a good idea to use the real <code class="literal">App</code> object for the purpose of testing. If the <code class="literal">App</code> object has an error, then the controller test will fail.</p><p>A fake for the <code class="literal">App</code> object is as shown in the following:</p><div><pre class="programlisting">// spec/fakes/app.js
'use strict';

var fakeRouter = {
navigate: jasmine.createSpy()
};

var FakeApp = {
router:  fakeRouter,

notifySuccess(message) {
this.lastSuccessMessage= message;
  },

notifyError(message) {
this.lastErrorMessage = message;
  },

reset() {
deletethis.lastSuccessMessage;
deletethis.lastErrorMessage;
this.router.navigate = jasmine.createSpy();
  }
};

_.extend(FakeApp, Backbone.Events);

module.exports = FakeApp;</pre></div><p>This simple<a id="id360" class="indexterm"/> object can simulate to be the real <code class="literal">App</code> object, as you can see the object does nothing; however, it will be useful in the next section for testing the <code class="literal">ContactEditor</code> controller.</p><p>Regions can also be faked in order to remove all the overheads of the original region:</p><div><pre class="programlisting">// spec/fakes/region.js
'use strict';

class FakeRegion {
show(view) {
view.render();
  }
}

module.exports = FakeRegion;</pre></div><p>It is very simple, just to render the view that is passed to it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Testing ContactEditor</h2></div></div></div><p>The <a id="id361" class="indexterm"/>
<code class="literal">ContactEditor</code> controller's <a id="id362" class="indexterm"/>responsibility is to render the necessary views in order to allow the user to update or create new contacts. It is closely related to many views and the <code class="literal">Contact</code> model.</p><p>We are going to use <code class="literal">proxyquireify</code> to isolate the <code class="literal">ContactEditor</code> controller and instead of using the real objects, we will fake most of them. The first test is to check whether the subapplication is rendered in the right region:</p><div><pre class="programlisting">// spec/apps/contacts/contactEditor.js
var proxyquery = require('proxyquireify')(require);
var Backbone = require('backbone');

var FakeRegion = require('../../fakes/region');
var fakes = {
'./views/contactPreview': Backbone.View,
'./views/phoneListView': Backbone.View,
'./views/emailListView': Backbone.View,
'./collections/phoneCollection': Backbone.Collection,
'./collections/emailCollection': Backbone.Collection
};

var ContactEditor = proxyquery('../../../app/js/apps/contacts/contactEditor', fakes);

describe('Contact editor', () =&gt; {
var fakeContact;
var editor;
var region;

beforeEach(() =&gt; {
region = new FakeRegion();
editor = new ContactEditor({region});
fakeContact = new Backbone.Model({
name: 'John Doe',
facebook: 'https://www.facebook.com/john.doe',
twitter: '@john.doe',
github: 'https://github.com/johndoe',
google: 'https://plus.google.com/johndoe'
    });
  });

describe('showing a contact editor', () =&gt; {
it('renders the editor in the given region', () =&gt; {
spyOn(region, 'show').and.callThrough();
editor.showEditor(fakeContact);
expect(region.show).toHaveBeenCalled();
    });
  });
});</pre></div><p>We are faking<a id="id363" class="indexterm"/> almost all the views of the <code class="literal">ContactEditor</code> controller, we don't need the real views as we are not testing the output HTML, that's a job for view testing. The only view that is not faked is the <code class="literal">FormLayout</code> view:</p><div><pre class="programlisting">// spec/fakes/formLayout.js
'use strict';

var Common = require('../../app/js/common');

class FakeFormLayout extends Common.Layout {
constructor(options) {
super(options);
this.template = '&lt;div class="phone-list-container" /&gt;' +
                    '&lt;div class="email-list-container" /&gt;';

this.regions = {
phones: '.phone-list-container',
emails: '.email-list-container'
    };
  }
}

module.exports = FakeFormLayout;</pre></div><p>Then add the fake, as follows:</p><div><pre class="programlisting">var FakeFormLayout = require('../../fakes/formLayout');

var fakes = {
'./views/contactPreview': Backbone.View,
'./views/phoneListView': Backbone.View,
'./views/emailListView': Backbone.View,
'./views/contactForm': FakeFormLayout,
'./collections/phoneCollection': Backbone.Collection,
'./collections/emailCollection': Backbone.Collection
};

// ...</pre></div><p>In the <code class="literal">ContactEditor</code> controller, we<a id="id364" class="indexterm"/> are listening for <code class="literal">avatar:selected</code> of the <code class="literal">ContactPreview</code> view, we should ensure that the event is handled correctly. However, we have a problem, we cannot access the view instance. To make the controller testable, it is a common practice to put the views as attributes of the controller, as shown in the following code:</p><div><pre class="programlisting">class ContactEditor {
  // ...

showEditor(contact) {
    // Data
var phonesData = contact.get('phones') || [];
var emailsData = contact.get('emails') || [];
this.phones = new PhoneCollection(phonesData);
this.emails = new EmailCollection(emailsData);

    // Create the views
this.layout = new ContactFormLayout({model: contact});
this.phonesView = new PhoneListView({
collection: this.phones
});
this.emailsView = new EmailListView({
collection: this.emails
});
this.contactForm = new ContactForm({model: contact});
this.contactPreview = new ContactPreview({
controller: this,
model: contact
    });

    // Render the views
this.region.show(this.layout);
this.layout.getRegion('form').show(this.contactForm);
this.layout.getRegion('preview').show(this.contactPreview);
this.contactForm.getRegion('phones').show(this.phonesView);
this.contactForm.getRegion('emails').show(this.emailsView);

this.listenTo(this.contactForm, 'form:save',
this.saveContact);
this.listenTo(this.contactForm, 'form:cancel', this.cancel);
this.listenTo(this.contactForm, 'phone:add', this.addPhone);
this.listenTo(this.contactForm, 'email:add', this.addEmail);

this.listenTo(this.phonesView, 'item:phone:deleted', 
(view, phone) =&gt; {
this.deletePhone(phone);
    });
this.listenTo(this.emailsView, 'item:email:deleted',
 (view, email) =&gt; {
this.deleteEmail(email);
    });

    // When avatar is selected, we can save it inmediatly if the
    // contact already exists on the server, otherwise just
    // remember the file selected
this.listenTo(this.contactPreview, 'avatar:selected',
blob =&gt; {
this.avatarSelected = blob;

if (!contact.isNew()) {
this.uploadAvatar(contact);
      }
    });
  }

  // ...
}</pre></div><p>With this change, we <a id="id365" class="indexterm"/>can make the proper test, it verifies that the <code class="literal">avatarSelected</code> property is set when the <code class="literal">contactPreview</code> view selects an image:</p><div><pre class="programlisting">it('binds the avatar:selected event in the contact preview', () =&gt; {
var expectedBlob = new Blob(['just text'], {
type: 'text/plain'
});

editor.showEditor(fakeContact);
// Fake the uploadAvatar method to prevent side effects
editor.uploadAvatar = jasmine.createSpy();

editor.contactPreview.trigger('avatar:selected', expectedBlob);
expect(editor.avatarSelected).toEqual(expectedBlob);
});</pre></div><p>The core functionality of the <code class="literal">ContactEditor</code> controller is to save the contact properly when the user clicks on the <strong>Save</strong> button, as follows:</p><div><pre class="programlisting">describe('Contact editor', () =&gt; {
  // ...
describe('saving a contact', () =&gt; {
beforeEach(() =&gt; {
jasmine.Ajax.install();

      // Fake the contact url, it is not important here
      fakeContact.url = '/fake/contact';

      // Fake upload avatar, we are not testing this feature
editor.uploadAvatar = function(contact, options) {
options.success();
      };

editor.showEditor(fakeContact);
    });

afterEach(() =&gt; {
jasmine.Ajax.uninstall();
FakeApp.reset();
    });
  }
}</pre></div><p>In this test case, the <a id="id366" class="indexterm"/>controller will call the <code class="literal">save()</code> method in the model to save the contact and Backbone will make an Ajax call to the server. When you are testing, you should not make real server connections as that will make your tests slow and prone to failing.</p><p>With the <code class="literal">jasmine-ajax</code> plugin, you can fake the Ajax calls so that you will have a total control of how the test behaves. You will need to install the package first:</p><div><pre class="programlisting">
<strong>$ npm install --save-devkarma-jasmine-ajax</strong>
</pre></div><p>Then, update the configuration of Karma to include the plugin, as follows:</p><div><pre class="programlisting">frameworks: ['browserify', 'jasmine-ajax', 'jasmine'],</pre></div><p>The plugin overwrites the original <code class="literal">XMLHttpRequest</code> object, therefore, it's important to initialize the Ajax plugin before starting your test and restore the original object once your test is done.</p><p>In the <code class="literal">beforeEach()</code> function, we will initialize the plugin by calling <code class="literal">jasmine.Ajax.install()</code> and restore the original <code class="literal">XMLHttpRequest</code> object with <code class="literal">jasmine.Ajax.uninstall()</code> in <code class="literal">afterEach()</code>.</p><p>When your application makes an Ajax call, the plugin will catch the request and you can then inspect the request or fake the response, as follows:</p><div><pre class="programlisting">it('shows a success message when the contact is saved', () =&gt; {
editor.saveContact(fakeContact);

jasmine.Ajax.requests.mostRecent().respondWith({
status: '200',
contentType: 'application/json',
responseText: '{}'
  });

expect(FakeApp.lastSuccessMessage).toEqual('Contact saved');
expect(FakeApp.router.navigate)
.toHaveBeenCalledWith('contacts', true);
});</pre></div><p>In the <a id="id367" class="indexterm"/>preceding test, we saved the contact and faked an HTTP <code class="literal">200</code> response. When this happens, the application will show a success message and redirect the application to the contact list.</p><p>If the server responds with an error, then the application will show an error message and not make a redirection to the contact list:</p><div><pre class="programlisting">it('shows an error message when the contact cant be saved', () =&gt; {
editor.saveContact(fakeContact);

jasmine.Ajax.requests.mostRecent().respondWith({
status: '400',
contentType: 'application/json',
responseText: '{}'
  });

expect(FakeApp.lastErrorMessage)
.toEqual('Something goes wrong');
expect(FakeApp.router.navigate)
.not.toHaveBeenCalled();
});</pre></div><p>Another thing that the <code class="literal">saveContact()</code> method does is to set the <code class="literal">phones</code> and <code class="literal">emails</code> attributes in the contact model. The test will ensure that the attributes are sent to the server correctly, as shown in the following code:</p><div><pre class="programlisting">it('saves the model with the phones and emails added', () =&gt; {
var expectedPhone = {
description: 'test',
phone: '555 5555'
  };
var expectedEmail = {
description: 'test',
phone: 'john.doe@example.com'
  };

editor.phones = new Backbone.Collection([expectedPhone]);
editor.emails = new Backbone.Collection([expectedEmail]);
editor.saveContact(fakeContact);

var requestText = jasmine.Ajax.requests.mostRecent().params;
var request = JSON.parse(requestText);

expect(request.phones.length).toEqual(1);
expect(request.emails.length).toEqual(1);
expect(request.phones).toContain(expectedPhone);
expect(request.emails).toContain(expectedEmail);
});</pre></div><p>We are setting <a id="id368" class="indexterm"/>a list of <code class="literal">phones</code> and <code class="literal">emails</code> and then test whether the server receives the right request.</p><p>If the contact is not valid, then the controller will not send anything to the server:</p><div><pre class="programlisting">it('does not save the contact if the model is not valid', () =&gt; {
  // Emulates an invalid model
fakeContact.isValid = function() {
return false;
  };

editor.saveContact(fakeContact);
expect(jasmine.Ajax.requests.count()).toEqual(0);
});</pre></div><p>The <code class="literal">ContactEditor</code> object should upload the avatar image only if the model is new. If the model not is new, then the avatar is uploaded immediately when the user selects the image:</p><div><pre class="programlisting">it('uploads the selected avatar if model is new', () =&gt; {
  // Emulates a new model
fakeContact.isNew= function() {
return true;
  };

editor.uploadAvatar = jasmine.createSpy('uploadAvatar');
editor.saveContact(fakeContact);

jasmine.Ajax.requests.mostRecent().respondWith({
status: '200',
contentType: 'application/json',
responseText: '{}'
  });

expect(editor.uploadAvatar).toHaveBeenCalled();
});

it('does not upload the selected avatar if model is not new', () =&gt; {
  // Emulates a not new model
fakeContact.isNew= function() {
return false;
  };

editor.uploadAvatar = jasmine.createSpy('uploadAvatar');
editor.saveContact(fakeContact);

jasmine.Ajax.requests.mostRecent().respondWith({
status: '200',
contentType: 'application/json',
responseText: '{}'
  });

expect(editor.uploadAvatar).not.toHaveBeenCalled();
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Testing the subapplication Façade</h1></div></div></div><p>The<a id="id369" class="indexterm"/> subapplication façade's responsibility is to create the model or collect objects and create the appropriate subapplication controller to<a id="id370" class="indexterm"/> render the fetched data. To show the contact editor, the Façade should fetch the contact by its ID and then run the <code class="literal">ContactEditor</code> subapplication:</p><div><pre class="programlisting">var proxyquery = require('proxyquireify')(require);

var FakeApp = require('../../fakes/app');
var FakeRegion = require('../../fakes/region');
var FakeContactEditor = require('../../fakes/contactEditor');

var fakes = {
'../../app': FakeApp,
'./contactEditor': FakeContactEditor,
'./contactList': {},
'./contactViewer': {}
};

var ContactsApp = proxyquery('../../../app/js/apps/contacts/app', fakes);

describe('Contacts application facade', () =&gt; {
var app;
var region;

function respond(request) {
var fakeResponse = {
name: 'John Doe',
facebook: 'https://www.facebook.com/john.doe',
twitter: '@john.doe',
github: 'https://github.com/johndoe',
google: 'https://plus.google.com/johndoe'
    };

request.respondWith({
status: 200,
contentType: 'application/json',
responseText: JSON.stringify(fakeResponse)
    });
  }

beforeEach(() =&gt; {
region = new FakeRegion();
app = new ContactsApp({region});

jasmine.Ajax.install();
  });

afterEach(() =&gt; {
jasmine.Ajax.uninstall();
  });

describe('showing contact editor', () =&gt; {

  });
});</pre></div><p>The setup for <a id="id371" class="indexterm"/>this test suite is very similar to the controller. We should fake the <code class="literal">Ajax</code> calls and create a Façade object that <a id="id372" class="indexterm"/>is to be used on the specs. Our first test will be to verify that it is fetching the correct data:</p><div><pre class="programlisting">it('fetches data from the server', () =&gt; {
app.showContactEditorById('1');

var request = jasmine.Ajax.requests.mostRecent();
expect(request.url).toEqual('/api/contacts/1');
});</pre></div><p>The Façade should trigger <code class="literal">loading: start</code> when fetching the data from the server:</p><div><pre class="programlisting">it('triggers a loading:start event', () =&gt; {
var callback = jasmine.createSpy('callback');

FakeApp.on('loading:start', callback);
app.showContactEditorById('1');

expect(callback).toHaveBeenCalled();
});</pre></div><p>Then, it should stop when the request is fulfilled:</p><div><pre class="programlisting">it('triggers a loading:stop event when the contact is loaded', () =&gt; {
var callback = jasmine.createSpy('callback');

FakeApp.on('loading:stop', callback);
app.showContactEditorById('1');
respond(jasmine.Ajax.requests.mostRecent());

expect(callback).toHaveBeenCalled();
});</pre></div><p>Finally, it should show the editor:</p><div><pre class="programlisting">it('shows the rigth contact', () =&gt; {
spyOn(FakeContactEditor.prototype, 'showEditor');
app.showContactEditorById('1');
respond(jasmine.Ajax.requests.mostRecent());

expect(FakeContactEditor.prototype.showEditor)
.toHaveBeenCalled();

var args = FakeContactEditor.prototype
.showEditor.calls.argsFor(0);
var model = args[0];

expect(model.get('id')).toEqual('1');
expect(model.get('name')).toEqual('John Doe');
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Summary</h1></div></div></div><p>If you want to build robust applications with minimum defects, you should test your code. Even if you are very good at coding, sometimes you may forget a validation or break a dependency and won't know about it until the final user of your application finds the bug.</p><p>As a professional developer, you should make sure that your code is always ready for production; one way to successfully do it is to run tests in your development workflow. Another benefit of testing applications is that you will gain confidence in your code, which means that you can improve your code without the fear of breaking something accidentally.</p><p>In Backbone, testing depends on the responsibility of the object that you are testing. Models, views, controllers, and facades are tested in their own way. However, it doesn't matter what the object is, Jasmine does a great work in order to help you to make a good test battery.</p><p>In the next chapter, you will learn how to deploy your Backbone application to a server for production and how to build a production environment for your applications. You will setup a Heroku instance if you don't want to mess with the server configuration internals or want to see how all the parts are connected in deep. I will show you how to configure an Ubuntu server in order to make your deployments.</p></div></body></html>