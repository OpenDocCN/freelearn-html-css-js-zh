- en: Chapter 11. Adding Security and Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we mocked up users so that we could test various functions,
    but obviously this isn't how we want our application to work going forward. We
    want only authorized users to be able to add and edit their lists and share them
    with others. Our application is currently not very secure.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is a basic functionality of almost every web application. We
    have a great option for managing users signing up, logging in, and accessing privileged
    routes. We will install Passport authentication middleware for Node.js, configure
    it for local authentication, and set up session management. We will secure our
    dashboard route so that only authenticated users see their own dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use Node.js and Express middleware to secure our SPA
    by preventing common exploits such as **Cross-Site Request Forgery** (**CSRF**).
    We'll also talk about additional security concerns that we'll handle during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that would be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up **Passport** to authenticate users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating local authentication strategies for signing up and logging in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling users with **Mongoose**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding security headers and preventing CSRF attacks on our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication with Passport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passport is a Node.js plugin that has the singular purpose of authenticating
    requests. That is, making sure only people who are logged in and who should be
    able to make certain requests are able to do so. Authentication is a basic security
    feature of every web application, including SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Passport is extremely flexible, allowing authentication through a number of
    different means, called strategies. Strategies include logging in with a simple
    username and password, or using **OAuth** to log in with Facebook or Twitter.
    Passport provides over 100 different strategies we should use for authentication.
    This chapter will focus on a local authentication strategy, while the following
    chapter will integrate social media strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Like most plugins used with Express, Passport is middleware and so its use will
    be familiar to us. This is a great architecture as well, because it keeps concerns
    separated in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Passport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to install Passport. Getting the actual Passport
    module couldn''t be easier, we just use `npm` to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install each strategy we''re going to use for Passport separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need is some middleware to manage user sessions. For that,
    we''ll install the `express-session` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add Passport into our app. Open up our main `app.js` file
    and make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It's important that we require and initialize Passport before any of the routing,
    to make sure our authentication is available to our routes. In initializing `expressSession`,
    set a secret key that's something different than what I've given you here. It
    can be any string, really.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost ready. Express local strategy assumes users stored in a MongoDB
    database. We already have a MongoDB database with a users' table, but we really
    need to enforce some consistency, and it would be nice to have an easy way to
    model our data.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mongoose to configure the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use a package called Mongoose. Mongoose is a data modeling tool
    for Node.js, used widely in Express packages. Where we accessed our database directly
    before, we are now going to let Mongoose do a lot of the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Mongoose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other modules, we will use `npm` to install `mongoose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add the code to initialize Mongoose in our `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we require in the Mongoose library and initialize it with the URL of our
    local database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mongoose uses predefined data models to validate, store, and access MongoDB
    databases. We need to create a model that will represent our user documents. We
    already have a `users` collection in our `db`, so let's blow that away to avoid
    any conflicts or confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have a terminal window open with the Mongo daemon running. If
    not, just open a new terminal and type `mongod` to start it. In a second terminal
    window, start the MongoDB command-line tool by typing `mongo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that''s running, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We make sure we're using the Gift App database. We then run `showcollections`
    to list the collections, and see there's a `users` collection. We run the `db.users.drop()`
    collection method to drop the collection. Then we show the collections again to
    check that the users collection has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that complete, create a new folder called models. Inside that folder,
    create a file called `user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We require mongoose at the top of the file and then create a model called `User`
    with the `mongoose.model()` function. That function takes a string, which becomes
    the model name, and an object, which represents the actual model. In our case,
    we have an `id`, `username`, `email`, `password`, `firstName`, and `lastName`,
    which are each defined as strings. Mongoose will ensure that every `User` document
    stored in our database matches this format definition.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default for the Passport local strategy is for there to be a `username`
    and `password` field. This could be changed if you wanted to just use `email`
    and `password` or some other scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Passport strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have to set up a local Passport strategy. We need to extend this strategy
    to handle users logging in and signing up.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Passport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new directory called `passport`. Create a file called `init.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code gives Passport access to our `User` model. The serialize and deserialize
    functions are used to look up a user from the database (deserialize) and to store
    user information to the session of `User` (serialize).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s initialize Passport using our `init` function in our main `app.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We require in our `init` file, assigning the exported function to the variable
    name `initializePassport`, then we invoke that function passing an instance of
    Passport into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added a new library before the Passport code, `connect-flash`. This
    allows us to store flash messages in session such as *invalid password* and pass
    them back to display to a view. We need to install this software with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating the signup strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's build out and require the strategy for signing users up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to add a library for hashing the user password
    so we don''t store unencrypted passwords in our database, that''s bad news. We''re
    going to use a module called `bycrypt-nodejs`, which is easily installed using
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `passport` directory, create a new file called `signup.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We require the modules we need, which includes a reference to the Mongoose `User`
    module. We set up the strategy with a call to `passport.use()`. The first argument
    is the name of the strategy, in this case, `signup`. The next argument is a call
    to construct a new `LocalStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: That call receives an object, in this case containing `passReqToCallback = true`.
    This makes the request object available to the callback function, which is next.
    This is important so that we have the info for the signup.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function sets up a new function called `newSignup`, which does
    the bulk of the work. We first search to see if there is a user with the specified
    username. If there is, we exit and set a flash message that the user already exists.
    If the user doesn't exist, we create a new one. Finally, we pass the function
    to the next tick of the Node.js event loop to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that the actual callback functionality executes inside a call to
    `process.nextTick()` due to the asynchronous nature of this call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s edit our `init.js` file to include and initialize our signup strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We simply require our signup module and then invoke the exported function inside
    our `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, now we have the signup strategy to create users, we need a strategy for
    users to log in. Create a new file in the `passport` directory, called `signin.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we require in our dependencies. We then create and export a function
    that, when invoked, creates a new Passport strategy for login.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is query the database to see if a user with our `username`
    exists. If the user doesn't exist, we set an error message in the flash and return
    the result of the done function, with the second argument being false.
  prefs: []
  type: TYPE_NORMAL
- en: The next step, assuming we matched on a `username`, is to use the `bCrypt.compareSync()`
    function to check that the password passed in matches the hashed password for
    the user from the database. If it doesn't, we again set an error message on the
    flash and then return done, with the second argument being false.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, assuming the `username` returns a `user`, and the `password` matches,
    we authenticate merely by returning done, with the second argument being the `user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll load and initialize the login strategy in our `init.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just like with the signup strategy, we simply require the login strategy module
    then invoke the exported function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes for authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we've set up Passport, we can't quite sign up or log in users yet. We need
    to set up routes and views to render the signup and login experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `login.js` in your `routes` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we export a function that sets up routes for logging in, signing
    up, and logging out. We expect an instance of `passport` to be passed when the
    function is invoked. When a user logs in successfully, they will be redirected
    to the `/dash` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the routes to our main `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that we necessarily pass a reference to Passport to the route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating views for authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the routes to sign up and log in, we need views to render and
    show the `user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a login folder in your views directory. In that folder, create a new
    template called `signup.ejs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty standard form for signup, and we''ve used some `Bootstrap`
    classes to pretty things up a bit. If you start up your server and navigate to
    `http://localhost:3000/login/signup`, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views for authentication](img/image_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you fill out the form—making sure to have at least a `username` and `password-`you
    should create a `user` and be redirected to the `/dash` URL. It''s not impressive
    yet, but it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views for authentication](img/image_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you start up your MongoDB command line and look, you''ll see a `users`
    collection once again. Mongoose created that automatically for us. If you create
    a couple of users, you can see them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You see that we have two users. I created each of these using the signup form.
    Only the hash of their passwords is stored in the database. To round out signup
    in production, you would want to at least validate users' `email` addresses, but
    for development purposes, it's easier for us to be able to create fake accounts
    at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a form for logging in. Create a new `login.ejs` template in your
    `views/login` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Going to `http://localhost:3000/login` gives us a page that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views for authentication](img/image_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Logging in with a correct set of user credentials will take you to our still-boring
    `/dash` route. Logging in with incorrect credentials returns us to the login route
    and populates the flash message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views for authentication](img/image_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Authenticating requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main part of our application is our user dashboard, where our user will
    be able to create `giftlists`. Previously, we would access a user's dashboard
    by passing the user `id` in the dashboard URL. Obviously, there is no authentication
    here, and it's not a secure way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want users to log in before viewing only their own dashboard. If they
    go to the dashboard URL directly, they should be redirected to a login page.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to handle this in stereotypical Express fashion by writing a piece
    of middleware to handle adding authentication for routes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication-check middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passport gives us in-session access to check if a user is currently authenticated.
    We can use this to easily protect whole sections of an application, or add authentication
    on a route-by-route basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `authenticated.js` in your `utils` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our authenticated function is set up with the signature of all Express middleware—with
    arguments for request, response, and next. We check the return value of a call
    to the request object's `isAuthenticed()` function—this is something Passport
    provides to us.
  prefs: []
  type: TYPE_NORMAL
- en: If we are authenticated, we merely pass the request forward by calling `next()`.
    If we aren't authenticated, we will redirect the request to the `/login` route,
    rendering our login page.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting middleware into routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we want to insert our new middleware where we want to use it, in our
    dashboard route file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We require our new module into the router file, assigning it to the `isAuthenticated`
    variable. Next, we add the middleware to the main route.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting your server should log you out. If you want to log out without restarting
    your server, you can access the sign-out route at `http://localhost:3000/login/signout`.
    You can then try to access `/dash`, and you'll be redirected back to login. Signing
    back in as a valid user will redirect you to dash, which will render properly.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the dashboard route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before, we set up our `dash/:id` route to look up the user using a `param` function.
    That's no longer going to suit our purposes. What we want is to show an authenticated
    user their own dashboard after logging in. Fortunately, Passport has already cached
    the user data we need in-session for us so we don't have to look the user up every
    time we render the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some changes to our `dashboard` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we've simplified the code a bit. Our `/:id` route is now gone and the only
    route remaining is the main route, which gets triggered by get requests to `/dash`.
  prefs: []
  type: TYPE_NORMAL
- en: We already have user data cached in the request thanks to Passport, so it saves
    us one database lookup, helping our code perform better. We still look up the
    gift lists owned by this user, then we render the dashboard template we built
    earlier, which contains our single-page application frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the dashboard route](img/image_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So we have authenticated the user and stashed the `user` object in the session,
    making it available during the request.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is perhaps the most important and one of the trickier topics
    with regard to securing a web application from the front. Certainly, there are
    lots of different threat vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Helmet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the easiest things we can do to secure our Express application is to
    install and use the security middleware called Helmet. Helmet adds a number of
    security headers and policies, as well as preventing some attacks, such as `clickjacking`.
  prefs: []
  type: TYPE_NORMAL
- en: It does most of this under the covers, without the need for configuration on
    our part. For more detailed information, and to find alternative ways to `congigure`
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Helmet, first install it using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can actually see by the names of the submodules what some of the protections
    include.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply need to add the module to our main `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And there you have it. We've mitigated a pile of common web security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that `app.use('helmet')` must come before any of the routes or the
    protection will not be in place for those routes.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common web attack vectors is the **Cross-Site Request Forgery**
    (**CSRF**). CSRF is an attack where some untrusted source, such as another website
    or even an e-mail, takes advantage of a user's authenticated status to execute
    privileged code on another application. You can find more detailed information
    about CSRF at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, middleware to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `csurf` middleware is then plugged into our `app.js` the same way, with
    Helmet required in and then used. Please note that the `app.use('csurf')` must
    come after the `cookie parser` and `express-session` middleware, since it uses
    both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we edit our `login` routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We add a CSRF token to the data we pass to the `login` and `signup` pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a hidden field to our `login` and `signup` pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Restarting our server, reloading our login or `signup` page, and viewing source,
    you''ll see a hidden input tag like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That hidden field gets passed back with our request and checked for validity.
  prefs: []
  type: TYPE_NORMAL
- en: Taking additional security measures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've taken some basic, yet powerful, steps to secure our application against
    some of the biggest threats. A full exploration of the possible threats and security
    measures is beyond the scope of this book, but there are a few considerations
    worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HTTPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing HTTPS when you deploy to production prevents a number of different
    man-in-the-middle attacks, and prevents data from being intercepted and modified
    along the way. We'll explore this in the chapter on deploying to production.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you can set your cookies to be secure. Again, we'll cover this
    when we talk about deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding running as root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the reasons we use port `3000` locally is that in many environments,
    running on port `80` (the standard HTTP port) requires running as root. A well-known
    security policy is that all processes should be run with as few privileges as
    possible. Again, this is something we'll take of when we deploy—mostly by using
    a PaaS provider.
  prefs: []
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right now, our application does very little input validation—except that `username`
    and `password` are required for signup and login. But we can and should check
    user input on both the client and server side.
  prefs: []
  type: TYPE_NORMAL
- en: We will add some input validation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by installing and configuring the Passport middleware
    for Node.js. Passport provides us with a framework for authentication, including
    creating new users, logging in, and securing specific routes. We then built out
    local authentication strategies for logging in and signing up.
  prefs: []
  type: TYPE_NORMAL
- en: We created routes and view templates for logging in and signing up, and redirected
    successful attempts to our main dashboard URL. We were able to reduce database
    lookups by relying on Passport caching our user in-session.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we enhanced the security of our application by using Helmet to add
    security headers to requests, and using `csurf` to mitigate CSRF attempts. We
    closed by discussing a few additional security concerns when moving the application
    into a production environment.
  prefs: []
  type: TYPE_NORMAL
