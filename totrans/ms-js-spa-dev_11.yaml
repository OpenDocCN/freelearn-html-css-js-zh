- en: Chapter 11. Adding Security and Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。添加安全和身份验证
- en: In previous chapters, we mocked up users so that we could test various functions,
    but obviously this isn't how we want our application to work going forward. We
    want only authorized users to be able to add and edit their lists and share them
    with others. Our application is currently not very secure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们模拟了用户，以便我们可以测试各种功能，但显然这不是我们希望应用程序继续工作的方式。我们希望只有授权用户才能添加和编辑他们的列表并与他人分享。我们的应用程序目前安全性不高。
- en: Authentication is a basic functionality of almost every web application. We
    have a great option for managing users signing up, logging in, and accessing privileged
    routes. We will install Passport authentication middleware for Node.js, configure
    it for local authentication, and set up session management. We will secure our
    dashboard route so that only authenticated users see their own dashboard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证几乎是每个 Web 应用程序的基本功能。我们有一个很好的选项来管理用户注册、登录和访问受保护的路由。我们将为 Node.js 安装 Passport
    身份验证中间件，对其进行本地身份验证配置，并设置会话管理。我们将保护仪表板路由，以确保只有经过身份验证的用户才能看到自己的仪表板。
- en: In this chapter, we will use Node.js and Express middleware to secure our SPA
    by preventing common exploits such as **Cross-Site Request Forgery** (**CSRF**).
    We'll also talk about additional security concerns that we'll handle during deployment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Node.js 和 Express 中间件通过防止常见的漏洞，如**跨站请求伪造**（**CSRF**）来保护我们的单页应用（SPA）。我们还将讨论在部署期间我们将处理的其他安全关注点。
- en: 'Here are the topics that would be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up **Passport** to authenticate users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 **Passport** 以实现用户身份验证
- en: Creating local authentication strategies for signing up and logging in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于注册和登录的本地身份验证策略
- en: Modeling users with **Mongoose**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Mongoose** 模型用户
- en: Securing routes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护路由
- en: Adding security headers and preventing CSRF attacks on our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中添加安全头并防止 CSRF 攻击
- en: Adding authentication with Passport
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Passport 添加身份验证
- en: Passport is a Node.js plugin that has the singular purpose of authenticating
    requests. That is, making sure only people who are logged in and who should be
    able to make certain requests are able to do so. Authentication is a basic security
    feature of every web application, including SPAs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 是一个具有单一目的的 Node.js 插件，即验证请求。也就是说，确保只有登录的用户和应该能够发出某些请求的人才能这样做。身份验证是每个
    Web 应用程序的基本安全功能，包括单页应用（SPAs）。
- en: Passport is extremely flexible, allowing authentication through a number of
    different means, called strategies. Strategies include logging in with a simple
    username and password, or using **OAuth** to log in with Facebook or Twitter.
    Passport provides over 100 different strategies we should use for authentication.
    This chapter will focus on a local authentication strategy, while the following
    chapter will integrate social media strategies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 非常灵活，允许通过多种不同的方式实现身份验证，这些方式被称为策略。策略包括使用简单的用户名和密码登录，或者使用**OAuth**通过
    Facebook 或 Twitter 登录。Passport 提供了超过 100 种不同的策略，我们应该用于身份验证。本章将重点介绍本地身份验证策略，而下一章将集成社交媒体策略。
- en: Like most plugins used with Express, Passport is middleware and so its use will
    be familiar to us. This is a great architecture as well, because it keeps concerns
    separated in our application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数与 Express 一起使用的插件一样，Passport 是中间件，因此它的使用对我们来说很熟悉。这是一个很好的架构，因为它在我们的应用程序中保持了关注点的分离。
- en: Installing Passport
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Passport
- en: 'The first thing we need to do is to install Passport. Getting the actual Passport
    module couldn''t be easier, we just use `npm` to install it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装 Passport。获取实际的 Passport 模块非常简单，我们只需使用 `npm` 安装它：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to install each strategy we''re going to use for Passport separately:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要单独安装我们将为 Passport 使用的每个策略：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last thing we need is some middleware to manage user sessions. For that,
    we''ll install the `express-session` package:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最不需要的就是一些中间件来管理用户会话。为此，我们将安装`express-session`包：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to add Passport into our app. Open up our main `app.js` file
    and make the following modifications:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 Passport 添加到我们的应用程序中。打开我们的主 `app.js` 文件并做出以下修改：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's important that we require and initialize Passport before any of the routing,
    to make sure our authentication is available to our routes. In initializing `expressSession`,
    set a secret key that's something different than what I've given you here. It
    can be any string, really.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We are almost ready. Express local strategy assumes users stored in a MongoDB
    database. We already have a MongoDB database with a users' table, but we really
    need to enforce some consistency, and it would be nice to have an easy way to
    model our data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Using Mongoose to configure the database
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use a package called Mongoose. Mongoose is a data modeling tool
    for Node.js, used widely in Express packages. Where we accessed our database directly
    before, we are now going to let Mongoose do a lot of the heavy lifting for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Mongoose
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with other modules, we will use `npm` to install `mongoose`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we will add the code to initialize Mongoose in our `app.js` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we require in the Mongoose library and initialize it with the URL of our
    local database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user model
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mongoose uses predefined data models to validate, store, and access MongoDB
    databases. We need to create a model that will represent our user documents. We
    already have a `users` collection in our `db`, so let's blow that away to avoid
    any conflicts or confusion.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have a terminal window open with the Mongo daemon running. If
    not, just open a new terminal and type `mongod` to start it. In a second terminal
    window, start the MongoDB command-line tool by typing `mongo`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that''s running, type the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We make sure we're using the Gift App database. We then run `showcollections`
    to list the collections, and see there's a `users` collection. We run the `db.users.drop()`
    collection method to drop the collection. Then we show the collections again to
    check that the users collection has been removed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'With that complete, create a new folder called models. Inside that folder,
    create a file called `user.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We require mongoose at the top of the file and then create a model called `User`
    with the `mongoose.model()` function. That function takes a string, which becomes
    the model name, and an object, which represents the actual model. In our case,
    we have an `id`, `username`, `email`, `password`, `firstName`, and `lastName`,
    which are each defined as strings. Mongoose will ensure that every `User` document
    stored in our database matches this format definition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default for the Passport local strategy is for there to be a `username`
    and `password` field. This could be changed if you wanted to just use `email`
    and `password` or some other scheme.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Passport strategies
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have to set up a local Passport strategy. We need to extend this strategy
    to handle users logging in and signing up.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Passport
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new directory called `passport`. Create a file called `init.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code gives Passport access to our `User` model. The serialize and deserialize
    functions are used to look up a user from the database (deserialize) and to store
    user information to the session of `User` (serialize).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s initialize Passport using our `init` function in our main `app.js`
    file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We require in our `init` file, assigning the exported function to the variable
    name `initializePassport`, then we invoke that function passing an instance of
    Passport into it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added a new library before the Passport code, `connect-flash`. This
    allows us to store flash messages in session such as *invalid password* and pass
    them back to display to a view. We need to install this software with `npm`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating the signup strategy
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's build out and require the strategy for signing users up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to add a library for hashing the user password
    so we don''t store unencrypted passwords in our database, that''s bad news. We''re
    going to use a module called `bycrypt-nodejs`, which is easily installed using
    `npm`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In your `passport` directory, create a new file called `signup.js`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We require the modules we need, which includes a reference to the Mongoose `User`
    module. We set up the strategy with a call to `passport.use()`. The first argument
    is the name of the strategy, in this case, `signup`. The next argument is a call
    to construct a new `LocalStrategy`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: That call receives an object, in this case containing `passReqToCallback = true`.
    This makes the request object available to the callback function, which is next.
    This is important so that we have the info for the signup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The callback function sets up a new function called `newSignup`, which does
    the bulk of the work. We first search to see if there is a user with the specified
    username. If there is, we exit and set a flash message that the user already exists.
    If the user doesn't exist, we create a new one. Finally, we pass the function
    to the next tick of the Node.js event loop to be executed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that the actual callback functionality executes inside a call to
    `process.nextTick()` due to the asynchronous nature of this call.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s edit our `init.js` file to include and initialize our signup strategy:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We simply require our signup module and then invoke the exported function inside
    our `init` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login strategy
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, now we have the signup strategy to create users, we need a strategy for
    users to log in. Create a new file in the `passport` directory, called `signin.js`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, we require in our dependencies. We then create and export a function
    that, when invoked, creates a new Passport strategy for login.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is query the database to see if a user with our `username`
    exists. If the user doesn't exist, we set an error message in the flash and return
    the result of the done function, with the second argument being false.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The next step, assuming we matched on a `username`, is to use the `bCrypt.compareSync()`
    function to check that the password passed in matches the hashed password for
    the user from the database. If it doesn't, we again set an error message on the
    flash and then return done, with the second argument being false.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们匹配了`username`，下一步是使用`bCrypt.compareSync()`函数来检查传入的密码是否与数据库中用户的散列密码匹配。如果不匹配，我们再次在闪存中设置错误消息，然后返回`done`，第二个参数为`false`。
- en: Finally, assuming the `username` returns a `user`, and the `password` matches,
    we authenticate merely by returning done, with the second argument being the `user`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设`username`返回一个`user`，并且`password`匹配，我们只需通过返回`done`来认证，第二个参数是`user`。
- en: 'Now, we''ll load and initialize the login strategy in our `init.js` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`init.js`文件中加载和初始化登录策略：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like with the signup strategy, we simply require the login strategy module
    then invoke the exported function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像注册策略一样，我们只需引入登录策略模块然后调用导出的函数。
- en: Creating routes for authentication
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证路由
- en: Now we've set up Passport, we can't quite sign up or log in users yet. We need
    to set up routes and views to render the signup and login experience.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了Passport，我们还不能注册或登录用户。我们需要设置路由和视图来渲染注册和登录体验。
- en: 'Create a new file called `login.js` in your `routes` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`routes`文件夹中创建一个新的文件，命名为`login.js`：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we export a function that sets up routes for logging in, signing
    up, and logging out. We expect an instance of `passport` to be passed when the
    function is invoked. When a user logs in successfully, they will be redirected
    to the `/dash` path.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们导出了一个设置登录、注册和注销路由的函数。当函数被调用时，我们期望传递一个`passport`实例。当用户成功登录时，他们将被重定向到`/dash`路径。
- en: 'Now let''s add the routes to our main `app.js` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将路由添加到我们的主`app.js`文件中：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You'll notice that we necessarily pass a reference to Passport to the route.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们必然需要将Passport的引用传递给路由。
- en: Creating views for authentication
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证视图
- en: Now that we have the routes to sign up and log in, we need views to render and
    show the `user`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了注册和登录的路由，我们需要视图来渲染并显示`user`。
- en: 'Create a login folder in your views directory. In that folder, create a new
    template called `signup.ejs`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图目录中创建一个登录文件夹。在该文件夹中，创建一个新的模板，命名为`signup.ejs`：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is a pretty standard form for signup, and we''ve used some `Bootstrap`
    classes to pretty things up a bit. If you start up your server and navigate to
    `http://localhost:3000/login/signup`, you''ll see the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的注册表单，我们使用了一些`Bootstrap`类来使界面更美观。如果您启动服务器并导航到`http://localhost:3000/login/signup`，您将看到以下内容：
- en: '![Creating views for authentication](img/image_11_001.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![创建认证视图](img/image_11_001.jpg)'
- en: 'If you fill out the form—making sure to have at least a `username` and `password-`you
    should create a `user` and be redirected to the `/dash` URL. It''s not impressive
    yet, but it looks as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您填写了表单——确保至少有`username`和`password-`，您应该创建一个`user`并重定向到`/dash` URL。目前看起来并不令人印象深刻，但如下所示：
- en: '![Creating views for authentication](img/image_11_002.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![创建认证视图](img/image_11_002.jpg)'
- en: 'Now, if you start up your MongoDB command line and look, you''ll see a `users`
    collection once again. Mongoose created that automatically for us. If you create
    a couple of users, you can see them here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动MongoDB命令行并查看，您将再次看到一个`users`集合。Mongoose为我们自动创建了它。如果您创建了一些用户，您可以看到他们在这里：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You see that we have two users. I created each of these using the signup form.
    Only the hash of their passwords is stored in the database. To round out signup
    in production, you would want to at least validate users' `email` addresses, but
    for development purposes, it's easier for us to be able to create fake accounts
    at will.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们有两个用户。我使用注册表单创建了这些用户。他们的密码散列只存储在数据库中。为了在生产环境中完善注册，您至少想要验证用户的`email`地址，但出于开发目的，我们能够随意创建假账户会更容易一些。
- en: 'Now we need a form for logging in. Create a new `login.ejs` template in your
    `views/login` directory:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个用于登录的表单。在您的`views/login`目录中创建一个新的`login.ejs`模板：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Going to `http://localhost:3000/login` gives us a page that looks like the
    following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:3000/login`会给我们一个如下所示的页面：
- en: '![Creating views for authentication](img/image_11_003.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![创建认证视图](img/image_11_003.jpg)'
- en: 'Logging in with a correct set of user credentials will take you to our still-boring
    `/dash` route. Logging in with incorrect credentials returns us to the login route
    and populates the flash message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的用户凭据登录将带你到我们仍然无聊的`/dash`路由。使用错误的凭据登录将返回到登录路由，并填充闪存消息：
- en: '![Creating views for authentication](img/image_11_004.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![创建认证视图](img/image_11_004.jpg)'
- en: Authenticating requests
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证请求
- en: The main part of our application is our user dashboard, where our user will
    be able to create `giftlists`. Previously, we would access a user's dashboard
    by passing the user `id` in the dashboard URL. Obviously, there is no authentication
    here, and it's not a secure way of doing it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要部分是用户仪表板，用户将能够创建`giftlists`。之前，我们会通过在仪表板URL中传递用户`id`来访问用户的仪表板。显然，这里没有认证，这不是一种安全的方式。
- en: Now we want users to log in before viewing only their own dashboard. If they
    go to the dashboard URL directly, they should be redirected to a login page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望用户在查看自己的仪表板之前先登录。如果他们直接访问仪表板URL，他们应该被重定向到登录页面。
- en: We are going to handle this in stereotypical Express fashion by writing a piece
    of middleware to handle adding authentication for routes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照典型的Express风格来处理这个问题，通过编写一个中间件来处理为路由添加认证。
- en: Adding authentication-check middleware
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加认证检查中间件
- en: Passport gives us in-session access to check if a user is currently authenticated.
    We can use this to easily protect whole sections of an application, or add authentication
    on a route-by-route basis.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Passport为我们提供了会话访问权限，以检查用户是否当前已认证。我们可以使用这个功能轻松地保护应用程序的整个部分，或者按路由逐个添加认证。
- en: 'Create a new file called `authenticated.js` in your `utils` directory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`utils`目录下创建一个名为`authenticated.js`的新文件：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our authenticated function is set up with the signature of all Express middleware—with
    arguments for request, response, and next. We check the return value of a call
    to the request object's `isAuthenticed()` function—this is something Passport
    provides to us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的认证函数设置了所有Express中间件的签名——带有请求、响应和`next`参数。我们检查请求对象的`isAuthenticied()`函数的返回值——这是Passport为我们提供的。
- en: If we are authenticated, we merely pass the request forward by calling `next()`.
    If we aren't authenticated, we will redirect the request to the `/login` route,
    rendering our login page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已认证，我们只需通过调用`next()`将请求传递下去。如果我们未认证，我们将请求重定向到`/login`路由，渲染我们的登录页面。
- en: Inserting middleware into routes
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将中间件插入路由中
- en: 'Next, we want to insert our new middleware where we want to use it, in our
    dashboard route file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想在需要使用新中间件的地方插入它，在我们的仪表板路由文件中：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We require our new module into the router file, assigning it to the `isAuthenticated`
    variable. Next, we add the middleware to the main route.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新模块导入到路由器文件中，将其分配给`isAuthenticated`变量。接下来，我们将中间件添加到主路由。
- en: Restarting your server should log you out. If you want to log out without restarting
    your server, you can access the sign-out route at `http://localhost:3000/login/signout`.
    You can then try to access `/dash`, and you'll be redirected back to login. Signing
    back in as a valid user will redirect you to dash, which will render properly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的服务器应该会注销你。如果你想在不需要重新启动服务器的情况下注销，你可以访问`http://localhost:3000/login/signout`的注销路由。然后你可以尝试访问`/dash`，你将被重定向回登录页面。以有效用户身份重新登录将把你重定向到仪表板，并且可以正确渲染。
- en: Changing the dashboard route
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改仪表板路由
- en: Before, we set up our `dash/:id` route to look up the user using a `param` function.
    That's no longer going to suit our purposes. What we want is to show an authenticated
    user their own dashboard after logging in. Fortunately, Passport has already cached
    the user data we need in-session for us so we don't have to look the user up every
    time we render the dashboard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们设置了`dash/:id`路由，使用`param`函数查找用户。这已经不再适合我们的需求。我们想要的是在用户登录后显示认证用户的仪表板。幸运的是，Passport已经为我们缓存了会话中需要的用户数据，所以我们每次渲染仪表板时不需要查找用户。
- en: 'Let''s make some changes to our `dashboard` router:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`dashboard`路由器做一些修改：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we've simplified the code a bit. Our `/:id` route is now gone and the only
    route remaining is the main route, which gets triggered by get requests to `/dash`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们稍微简化了代码。我们的`/:id`路由已经不存在了，剩下的唯一路由是主路由，它由对`/dash`的GET请求触发。
- en: We already have user data cached in the request thanks to Passport, so it saves
    us one database lookup, helping our code perform better. We still look up the
    gift lists owned by this user, then we render the dashboard template we built
    earlier, which contains our single-page application frontend.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Passport，我们已经在请求中缓存了用户数据，因此节省了我们一次数据库查询，有助于我们的代码性能提升。然后我们查找该用户拥有的礼品清单，接着渲染我们之前构建的仪表板模板，其中包含我们的单页应用前端。
- en: 'We get the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![Changing the dashboard route](img/image_11_005.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![更改仪表板路由](img/image_11_005.jpg)'
- en: So we have authenticated the user and stashed the `user` object in the session,
    making it available during the request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经认证了用户并将`user`对象存储在会话中，使其在请求期间可用。
- en: Securing Express
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Express
- en: Authentication is perhaps the most important and one of the trickier topics
    with regard to securing a web application from the front. Certainly, there are
    lots of different threat vectors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 认证可能是从前端保护Web应用程序最重要的且最具挑战性的主题之一。当然，有很多不同的威胁向量。
- en: Helmet
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helmet
- en: One of the easiest things we can do to secure our Express application is to
    install and use the security middleware called Helmet. Helmet adds a number of
    security headers and policies, as well as preventing some attacks, such as `clickjacking`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的最简单的方法之一来保护我们的Express应用是安装并使用名为Helmet的安全中间件。Helmet添加了多个安全头和策略，以及防止一些攻击，例如`clickjacking`。
- en: It does most of this under the covers, without the need for configuration on
    our part. For more detailed information, and to find alternative ways to `congigure`
    it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它在幕后做了大部分工作，无需我们进行配置。有关更详细的信息，以及找到其他配置方式，请参阅。
- en: 'To get started with Helmet, first install it using `npm`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Helmet，首先使用`npm`安装它：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can actually see by the names of the submodules what some of the protections
    include.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上可以通过子模块的名称看到一些保护措施的内容。
- en: 'Next, we simply need to add the module to our main `app.js` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需将模块添加到我们的主`app.js`文件中：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And there you have it. We've mitigated a pile of common web security vulnerabilities.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们已经缓解了大量常见的Web安全漏洞。
- en: Please note that `app.use('helmet')` must come before any of the routes or the
    protection will not be in place for those routes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`app.use('helmet')`必须在任何路由之前，否则这些路由的保护将不会生效。
- en: CSRF
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSRF
- en: One of the most common web attack vectors is the **Cross-Site Request Forgery**
    (**CSRF**). CSRF is an attack where some untrusted source, such as another website
    or even an e-mail, takes advantage of a user's authenticated status to execute
    privileged code on another application. You can find more detailed information
    about CSRF at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的Web攻击向量之一是**跨站请求伪造**（**CSRF**）。CSRF是一种攻击，其中一些不受信任的来源，如另一个网站或甚至一封电子邮件，利用用户的认证状态在另一个应用程序上执行特权代码。您可以在[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))找到有关CSRF的更多详细信息。
- en: 'Once again, middleware to the rescue:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，中间件来拯救：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `csurf` middleware is then plugged into our `app.js` the same way, with
    Helmet required in and then used. Please note that the `app.use('csurf')` must
    come after the `cookie parser` and `express-session` middleware, since it uses
    both.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以相同的方式将`csurf`中间件插入到我们的`app.js`中，需要Helmet并在使用它之前。请注意，`app.use('csurf')`必须在`cookie
    parser`和`express-session`中间件之后，因为它使用这两个中间件。
- en: 'Next, we edit our `login` routes file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编辑我们的`login`路由文件：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add a CSRF token to the data we pass to the `login` and `signup` pages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将CSRF令牌添加到传递给`login`和`signup`页面的数据中。
- en: 'Next, we add a hidden field to our `login` and `signup` pages:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`login`和`signup`页面添加一个隐藏字段：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Restarting our server, reloading our login or `signup` page, and viewing source,
    you''ll see a hidden input tag like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动我们的服务器，重新加载我们的`login`或`signup`页面，并查看源代码，您将看到一个如下所示的隐藏输入标签：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That hidden field gets passed back with our request and checked for validity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那个隐藏字段会随我们的请求一起返回并检查其有效性。
- en: Taking additional security measures
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采取额外的安全措施
- en: We've taken some basic, yet powerful, steps to secure our application against
    some of the biggest threats. A full exploration of the possible threats and security
    measures is beyond the scope of this book, but there are a few considerations
    worth mentioning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采取了一些基本但强大的步骤来保护我们的应用程序免受一些最大威胁。对可能威胁和安全措施的全面探讨超出了本书的范围，但有一些值得注意的考虑因素。
- en: Implementing HTTPS
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施HTTPS
- en: Implementing HTTPS when you deploy to production prevents a number of different
    man-in-the-middle attacks, and prevents data from being intercepted and modified
    along the way. We'll explore this in the chapter on deploying to production.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署到生产环境时实施HTTPS可以防止多种中间人攻击，并防止数据在传输过程中被拦截和修改。我们将在关于部署到生产环境的章节中探讨这一点。
- en: Furthermore, you can set your cookies to be secure. Again, we'll cover this
    when we talk about deployment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以设置你的cookie为安全模式。同样，我们将在讨论部署时涵盖这一点。
- en: Avoiding running as root
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免以root身份运行
- en: One of the reasons we use port `3000` locally is that in many environments,
    running on port `80` (the standard HTTP port) requires running as root. A well-known
    security policy is that all processes should be run with as few privileges as
    possible. Again, this is something we'll take of when we deploy—mostly by using
    a PaaS provider.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本地使用端口`3000`的原因之一是，在许多环境中，在端口`80`（标准HTTP端口）上运行需要以root身份运行。一个众所周知的安全策略是所有进程都应该尽可能少地运行权限。同样，这也是我们在部署时要注意的事情——主要是由PaaS提供商来完成。
- en: Validating user input
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Right now, our application does very little input validation—except that `username`
    and `password` are required for signup and login. But we can and should check
    user input on both the client and server side.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序在输入验证方面做得很少——除了`username`和`password`在注册和登录时是必需的外。但我们可以也应该在客户端和服务器端检查用户输入。
- en: We will add some input validation in the next chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中添加一些输入验证。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by installing and configuring the Passport middleware
    for Node.js. Passport provides us with a framework for authentication, including
    creating new users, logging in, and securing specific routes. We then built out
    local authentication strategies for logging in and signing up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时安装并配置了Node.js的Passport中间件。Passport为我们提供了一个认证框架，包括创建新用户、登录和确保特定路由的安全。然后我们构建了登录和注册的本地认证策略。
- en: We created routes and view templates for logging in and signing up, and redirected
    successful attempts to our main dashboard URL. We were able to reduce database
    lookups by relying on Passport caching our user in-session.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了登录和注册的路由和视图模板，并将成功的尝试重定向到我们的主仪表板URL。我们能够通过依赖Passport缓存用户会话来减少数据库查询。
- en: Finally, we enhanced the security of our application by using Helmet to add
    security headers to requests, and using `csurf` to mitigate CSRF attempts. We
    closed by discussing a few additional security concerns when moving the application
    into a production environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用Helmet添加安全头到请求，并使用`csurf`来减轻CSRF尝试，增强了我们应用程序的安全性。我们在讨论将应用程序迁移到生产环境时的几个额外安全问题时结束。
