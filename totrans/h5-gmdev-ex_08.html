<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Building a Multiplayer Draw-and-Guess Game with WebSockets</h1></div></div></div><p>
<em>We built several local single-player games in the previous chapters. In this chapter, we will build a multiplayer game with the help of WebSockets. WebSockets enable us to create event-based server-client architecture. The messages are passed between all connected browsers instantly. We will combine the Canvas drawing, JSON data packing, and several techniques learned in the previous chapters to build the draw-and-guess game.</em>
</p><p>In this chapter, we will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Trying an existing multiuser sketchpad that shows drawings from different connected users through WebSockets</li><li class="listitem" style="list-style-type: disc">Installing a WebSocket server that is implemented by node.js</li><li class="listitem" style="list-style-type: disc">Connecting the server from a browser</li><li class="listitem" style="list-style-type: disc">Creating an instant chat room with the WebSocket API</li><li class="listitem" style="list-style-type: disc">Creating a multiuser drawing pad in the Canvas</li><li class="listitem" style="list-style-type: disc">Building a draw-and-guess game by integrating the chat room and drawing with game logic</li></ul></div><p>The following screenshot shows the draw-and-guess game that we will create in this chapter:</p><div><img src="img/B04290_08_01.jpg" alt="Building a Multiplayer Draw-and-Guess Game with WebSockets"/></div><p>So, let's get on with it.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Installing a WebSocket server</h1></div></div></div><p>The HTML5 WebSocket provides a<a id="id716" class="indexterm"/> client-side API to connect a browser to a backend server. This server has to support the WebSockets protocol in order to keep the connection persistent.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec202"/>Installing the Node.js WebSocket server</h2></div></div></div><p>In this section, we will<a id="id717" class="indexterm"/> download and install a server named Node.js on which we can install a WebSockets module.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Time for action – installing Node.js</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Go to the URL, <a class="ulink" href="http://nodejs.org">http://nodejs.org</a>, which<a id="id718" class="indexterm"/> contains the source code of the Node.js server.</li><li class="listitem">Click on the <strong>Install</strong> <a id="id719" class="indexterm"/>button on the page. This downloads the installation package based on your operating system.</li><li class="listitem">Follow the installer's instructions to install the Node.js package. After the installation, we can check whether Node.js is installed by checking its version with the following command:<div><pre class="programlisting">$ node --version</pre></div></li><li class="listitem">The preceding command should print a version number of the node.js. In my case, it is version 0.12.0:<div><pre class="programlisting">v0.12.0</pre></div></li><li class="listitem">We also need to check whether the <code class="literal">npm</code> package manager is installed with the following command:<div><pre class="programlisting">$ npm --version</pre></div></li><li class="listitem">The preceding command should print a version number of npm, Node.js packages manager. In my case, it is version 2.5.1.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec203"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just downloaded and installed the <code class="literal">Node.js</code> server. We will build server logic on top of this environment. The WebSocket server does not necessarily run on Node.js. There are different server-side implementations of the WebSockets protocol. We chose Node.js because it uses JavaScript, and we are familiar with it after building four HTML5 games in the previous chapters.</p><p>There is a fork from Node.js named <a id="id720" class="indexterm"/>io.js (<a class="ulink" href="http://iojs.org">http://iojs.org</a>). At the time of writing this book, io.js is still very new. It's worth checking the latest status and their differences on both platforms if you plan on using Node in future projects.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>In some Linux distributions, the binary is renamed from <code class="literal">node</code> to <code class="literal">nodejs</code>. You can create a symbolic link of <code class="literal">nodejs</code> into <code class="literal">node</code> by using the following command. You may need <code class="literal">sudo</code> to run the command:</p><div><pre class="programlisting">ln -s "$(which nodejs)" /usr/bin/node</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec204"/>Creating a WebSocket server to send connection count</h2></div></div></div><p>We just installed the <code class="literal">node.js</code> server. Now, we <a id="id721" class="indexterm"/>will build something with WebSockets. Imagine now that we want a server that accepts connections from browsers and then sends the connection count to all users.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec99"/>Time for action – running a WebSocket server </h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a project folder<a id="id722" class="indexterm"/> for our code. Inside it, create a new directory named <code class="literal">server</code>.</li><li class="listitem">Use a terminal or the shell command prompt to change the directory into our newly created folder.</li><li class="listitem">Type the following command that will install a WebSocket server:<div><pre class="programlisting">npm install --save ws</pre></div></li><li class="listitem">Create a new file named <code class="literal">server.js</code> under the <code class="literal">server</code> directory with the following content:<div><pre class="programlisting">var port = 8000;

// Server code
var WebSocketServer = require('ws').Server;
var server = new WebSocketServer({ port: port });

server.on('connection', function(socket) {
  console.log("A connection established");
});

console.log("WebSocket server is running.");
console.log("Listening to port " + port + ".");</pre></div></li><li class="listitem">Open the terminal and change to the server directory.</li><li class="listitem">Type the following command to execute the server:<div><pre class="programlisting">node server.js</pre></div></li><li class="listitem">You should get the following result if this works:<div><pre class="programlisting">$ node server.js 
WebSocket server is running.
Listening to port 8000.</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec205"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just created a simple server logic <a id="id723" class="indexterm"/>that initialized the WebSockets library and listened to the connection event.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec206"/>Initializing the WebSocket server</h2></div></div></div><p>In <code class="literal">Node.JS</code>, different<a id="id724" class="indexterm"/> functions are packed into modules. When we need a functionality in a specific module, we use <code class="literal">require</code> to load it. We load the WebSockets module and then initialize the server using the following code in the server logic:</p><div><pre class="programlisting">var WebSocketServer = require('ws').Server;
var server = new WebSocketServer({ port: port });</pre></div><p>Since the <code class="literal">ws</code> module is managed by <code class="literal">npm</code>, it's installed inside a folder called <code class="literal">node_modules</code>. When we require a library with only the name, the Node.js runtime looks for that module in the <code class="literal">node_modules</code> folder.</p><p>We used <code class="literal">8000</code> as the server's port number, with which a client connects to this server. We may choose a different port number, but we have to ensure that the chosen port number is not overlapped by other common server services.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec207"/>Listening to the connection event on the server side</h2></div></div></div><p>The <code class="literal">node.js</code> server is<a id="id725" class="indexterm"/> event based. This means that most of the logic is executed when a certain event is fired. The following code that we used in the example listens to the <code class="literal">connection</code> event and handles it:</p><div><pre class="programlisting">server.on('connection', function(socket) {
  console.log("A connection established");
});</pre></div><p>The <code class="literal">connection</code> event comes with a socket argument. We will need to store this socket later because we use this object to interact with the connecting client.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec208"/>Creating a client that connects to a WebSocket server and getting the total connections count</h2></div></div></div><p>We built the server in the last<a id="id726" class="indexterm"/> example, and now, we will build a client that connects to our WebSocket server and receives messages from the server. The message will contain the total connection count from the server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec100"/>Time for action – showing the connection count in a WebSocket application</h1></div></div></div><p>Carry out the <a id="id727" class="indexterm"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <a id="id728" class="indexterm"/>new directory named <code class="literal">client</code>.</li><li class="listitem">Create an HTML file named <code class="literal">index.html</code> in the <code class="literal">client</code> folder.</li><li class="listitem">Now, add a few markups in our HTML file. To do this, put the following code in the <code class="literal">index.html</code> file:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;WebSockets demo for HTML5 Games Development: A Beginner's Guide&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- game elements goes here later --&gt;
  &lt;script src="img/jquery-2.1.3.min.js"&gt;&lt;/script&gt;
  &lt;script src="img/html5games.websocket.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a directory named <code class="literal">js</code> and put the jQuery JavaScript file inside it.</li><li class="listitem">Create a new file named <code class="literal">html5games.websockets.js</code> as follows:<div><pre class="programlisting">var websocketGame = {
}
// init script when the DOM is ready.
$(function(){
  // check if existence of WebSockets in browser
  if (window["WebSocket"]) {
  
    // create connection
    websocketGame.socket = new WebSocket("ws://127.0.0.1:8000");
    
    // on open event
    websocketGame.socket.onopen = function(e) {
      console.log('WebSocket connection established.');
    };
    
    // on close event
    websocketGame.socket.onclose = function(e) {
      console.log('WebSocket connection closed.');
    };      
  }
});</pre></div></li><li class="listitem">After these steps, we should have the following folder structure created in our project directory:<div><img src="img/B04290_08_12.jpg" alt="Time for action – showing the connection count in a WebSocket application"/></div></li><li class="listitem">We will now test <a id="id729" class="indexterm"/>the<a id="id730" class="indexterm"/> code. First, you need to run the node server with our <code class="literal">server.js</code> code using <code class="literal">node</code> <code class="literal">server.js</code> in the <strong>server</strong> directory in the terminal.</li><li class="listitem">Next, open the <code class="literal">index.html</code> file in the client directory, in a web browser twice so that we have two client instances running side by side.</li><li class="listitem">Inspect the server terminal. There should be log messages similar to the following indicating the connection information and the total connection count:<div><pre class="programlisting">$ node server.js 
WebSocket server is running.
Listening to port 8000.
A connection established.
A connection established.</pre></div></li><li class="listitem">In the two web browsers, open the console in <strong>Developer Tools</strong>. You should also see the <strong>WebSocket connection established </strong>message in the console.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec209"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just built a client <a id="id731" class="indexterm"/>that established a <a id="id732" class="indexterm"/>WebSockets connection to the server that we built in the last section. The client would then print any messages that are received from the server to the console panel in the <strong>Inspector</strong> of <strong>Developer Tools</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec210"/>Establishing a WebSocket connection</h2></div></div></div><p>In any browser that supports <a id="id733" class="indexterm"/>WebSockets, we can establish a connection by creating a new WebSocket instance with the following code:</p><div><pre class="programlisting">var socket = new WebSocket(url);</pre></div><p>The <code class="literal">url</code> argument is a string with the WebSockets URL. In our example, we are running our server locally. Therefore, the URL we have used is <code class="literal">ws://127.0.0.1:8000</code>, where 8000 represents the port number of the server to which we are connecting. It is 8000 because the server was listening to port 8000 when we built the server-side logic.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec211"/>WebSocket client events</h2></div></div></div><p>Similar to the server, we have<a id="id734" class="indexterm"/> several WebSocket events on the client side. The following table lists the events that we will use to deal with WebSockets:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onopen</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id735" class="indexterm"/> fired when a connection to the server is established</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onmessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id736" class="indexterm"/> fired when any message from the server is received</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onclose</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is fired <a id="id737" class="indexterm"/>when the server closes the connection</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">onerror</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is fired<a id="id738" class="indexterm"/> when there is any error in the connection</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec212"/>Sending a message to all connected browsers</h2></div></div></div><p>Once the server gets a <a id="id739" class="indexterm"/>new <code class="literal">connection</code> event, we send the<a id="id740" class="indexterm"/> updated count of the connection to all clients. Sending a message to all clients is easy. We just need to call the <code class="literal">sendAll</code> function in the <code class="literal">server</code> instance with a <code class="literal">string</code> argument as the message.</p><p>The following code snippet sends a server message to all connected browsers:</p><div><pre class="programlisting">var message = "a message from server";
server.sendAll(message);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Time for action – sending total count to all users</h1></div></div></div><p>Perform the following steps to create our foundation logic for the game:</p><div><ol class="orderedlist arabic"><li class="listitem">In the server folder, we create a new file named <code class="literal">game.js</code>. We will store the room and game logic in this file.</li><li class="listitem">We define a <code class="literal">User</code> class that stores the socket connection object and creates a random ID.<div><pre class="programlisting">function User(socket) {
  this.socket = socket; 
  // assign a random number to User.
  // Long enough to make duplication chance less.
  this.id = "1" + Math.floor( Math.random() * 1000000000);
}</pre></div></li><li class="listitem">We also define a <code class="literal">Room</code> class. We store a collection of user instances in this class.<div><pre class="programlisting">function Room() {
  this.users = []; 
}</pre></div></li><li class="listitem">We define the two instance methods in the <code class="literal">Room</code> class that manages the adding and removing of users.<div><pre class="programlisting">Room.prototype.addUser = function(user){
  this.users.push(user); 
  var room = this; 

  // handle user closing
  user.socket.onclose = function(){
    console.log('A connection left.');
    room.removeUser(user);
  }
};
Room.prototype.removeUser = function(user) {
  // loop to find the user
  for (var i=this.users.length; i &gt;= 0; i--) {
    if (this.users[i] === user) {
      this.users.splice(i, 1);
    }
  }
};</pre></div></li><li class="listitem">Then, we define another method that is in charge of sending messages to all the connected users in the room:<div><pre class="programlisting">Room.prototype.sendAll = function(message) {
  for (var i=0, len=this.users.length; i&lt;len; i++) {
    this.users[i].socket.send(message);
  }
};</pre></div></li><li class="listitem">Before moving on, we<a id="id741" class="indexterm"/> need to export our newly <a id="id742" class="indexterm"/>defined <code class="literal">User</code> and <code class="literal">Room</code> classes to let other files use them:<div><pre class="programlisting">module.exports.User = User;
module.exports.Room = Room;</pre></div></li><li class="listitem">In the <code class="literal">server.js</code> file, we replace the connection handler with the following code, which sends the user count to all the connected users:<div><pre class="programlisting">var User = require('./game').User;
var Room = require('./game').Room;
var room1 = new Room();
server.on('connection', function(socket) {
  var user = new User(socket);
  room1.addUser(user);
  console.log("A connection established");
  var message = "Welcome " + user.id 
     + " joining the party. Total connection: "
     + room1.users.length;
  room1.sendAll(message);
});</pre></div></li><li class="listitem">We then move to the client. In the <code class="literal">html5games.websocket.js</code> file inside the <strong>clients</strong> | <strong>js</strong> folder, we add a handler to print out the messages received from the server.<div><pre class="programlisting">// on message event
websocketGame.socket.onmessage = function(e) {
  console.log(e.data);
};</pre></div></li><li class="listitem">Finally, we test the code. Launch the server by executing <code class="literal">node</code> <code class="literal">server.js</code> in the server directory. Then, open the <code class="literal">index.html</code> file, and we should see something similar to the following screenshot on the console:<div><img src="img/B04290_08_02.jpg" alt="Time for action – sending total count to all users"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec213"/>
<em>What just happened?</em>
</h2></div></div></div><p>We defined two <a id="id743" class="indexterm"/>classes, <code class="literal">User</code> and <code class="literal">Room</code>, in a <code class="literal">game.js</code> file, which<a id="id744" class="indexterm"/> we use to manage all the connected sockets.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec214"/>Defining class and instant instance methods</h2></div></div></div><p>In JavaScript, <strong>object-oriented programming</strong>
<a id="id745" class="indexterm"/> is done by using functions and <a id="id746" class="indexterm"/>prototypes. When we create a room instance by<a id="id747" class="indexterm"/> calling <code class="literal">new</code> <code class="literal">Room()</code>, the browser clones all properties and methods in <code class="literal">Room.prototype</code> to the instance.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec215"/>Handling a newly connected user</h2></div></div></div><p>For each connected user, we <a id="id748" class="indexterm"/>need to interact with them via an events handler. We add the user object into an array for easy management. We need to handle the <code class="literal">onclose</code> event when a user disconnects. To do this, we remove that user from the array.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec216"/>Exporting modules</h2></div></div></div><p>After defining our classes <a id="id749" class="indexterm"/>in the <code class="literal">game.js</code> file, we exported them. By exporting them to the module, we can import them in the other file by using the <code class="literal">require</code> method, as follows:</p><div><pre class="programlisting">var User = require('./game').User;
var Room = require('./game').Room;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec217"/>Sending messages to the client</h2></div></div></div><p>WebSockets have the <a id="id750" class="indexterm"/>ability to send messages from the server to a user. Traditionally,<a id="id751" class="indexterm"/> the client requests the server and then the server responds. In a socket server, all users are connected, so messages can be triggered and sent in both directions. Here, we loop through all the users to send a broadcast message:</p><div><pre class="programlisting">Room.prototype.send = function(message) {
  for (var i=0, len=this.users.length; i&lt;len; i++) {
    this.users[i].socket.send(message);
  }
};</pre></div><p>Then we listen to the server message on the client, by using the <code class="literal">onmessage</code> event handler.</p><div><pre class="programlisting">// on message event
websocketGame.socket.onmessage = function(e) {
  console.log(e.data);
};</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec102"/>Building a chatting application with WebSockets</h1></div></div></div><p>We now know how many<a id="id752" class="indexterm"/> browsers are connected. Suppose we want to build a chat room where users can type a message in their respective browsers and send the message to all the connected users instantly.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec218"/>Sending a message to the server</h2></div></div></div><p>We will let the user input a <a id="id753" class="indexterm"/>message and then send the message to the <code class="literal">node.js</code> server. The server will then forward the message to all the connected browsers. Once a browser receives the message, it displays it in the chat area. In this case, the users are connected to the instant chat room once they load the web page.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec103"/>Time for action – sending a message to the server through WebSockets</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">First, code the server logic.</li><li class="listitem">Open <code class="literal">servergame.js</code>. Add the following function to the file that handles user messages:<div><pre class="programlisting">Room.prototype.handleOnUserMessage = function(user) {
  var room = this;
  user.socket.on("message", function(message){
    console.log("Receive message from " + user.id + ": " + message);
  });
};</pre></div></li><li class="listitem">Add the following code inside the <code class="literal">Room.prototype.addUser</code> method that calls our newly created function:<div><pre class="programlisting">this.handleOnUserMessage(user);</pre></div></li><li class="listitem">Now, move on to the <code class="literal">client</code> folder.</li><li class="listitem">Open the <code class="literal">index.html</code> file and add the following markup in the <code class="literal">body</code> section. This provides inputs<a id="id754" class="indexterm"/> for the user to type and send messages to the server:<div><pre class="programlisting">&lt;input type="text" id="chat-input" autocomplete="off"&gt;
&lt;input type="button" value="Send" id="send"&gt;</pre></div></li><li class="listitem">Then, add the following code to the <code class="literal">html5games.websocket.js</code> JavaScript file. This sends the message to the server when the user clicks on the <code class="literal">send</code> button or presses the <em>Enter</em> key:<div><pre class="programlisting">$("#send").click(sendMessage);
   
$("#chat-input").keypress(function(event) {
   if (event.keyCode === 13) {  
      sendMessage();  
   }  
});

function sendMessage() {
   var message = $("#chat-input").val();
   websocketGame.socket.send(message);
   $("#chat-input").val("");
}</pre></div></li><li class="listitem">Before testing our code, check the server terminal and see whether the node server is still running. Press <em>Ctrl</em> + <em>C</em> to terminate it and run it again by using the <code class="literal">node</code> <code class="literal">server.js</code> command.</li><li class="listitem">Open <code class="literal">index.html</code> in a web browser. You should see an input text field with a <strong>Send</strong> button, as shown in the following screenshot:<div><img src="img/B04290_08_03.jpg" alt="Time for action – sending a message to the server through WebSockets"/></div></li><li class="listitem">Try to type <a id="id755" class="indexterm"/>something in the input text field and then click on the <strong>Send</strong> button or press <em>Enter</em>. The input text will be cleared.</li><li class="listitem">Now, switch to the server terminal, and you will see the server printing the text that we just sent. You can also put the browser and server terminal side by side to see how the message is sent instantly from the client to the server. The following screenshot shows the server terminal with messages from two connected browsers:<div><img src="img/B04290_08_04.jpg" alt="Time for action – sending a message to the server through WebSockets"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec219"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just extended our connection example by adding an input text field for the users to type some text there and send it out. The text is sent as a message to the WebSocket server. The server<a id="id756" class="indexterm"/> will then print the received message in the terminal.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec220"/>Sending a message from the client to the server</h2></div></div></div><p>In order to send a message from the <a id="id757" class="indexterm"/>client to the server, we call the following <code class="literal">send</code> method in the <code class="literal">WebSocket</code> instance:</p><div><pre class="programlisting">websocketGame.socket.send(message);</pre></div><p>In the following code snippet from our example, we get the message from the input text field and send it to the server:</p><div><pre class="programlisting">var message = $("#chat-input").val();
websocketGame.socket.send(message);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec221"/>Receiving a message on the server side</h2></div></div></div><p>On the server side, we need to <a id="id758" class="indexterm"/>handle the message we just sent from the client. We have an event named <code class="literal">message</code> in the connection instance in the WebSocket <code class="literal">node.js</code> library. We can listen to the connection message event to receive a message from each client connection.</p><p>The following code snippet shows how we use the message event listener to print the message on the server terminal:</p><div><pre class="programlisting">socket.on("message", function(message){
  console.log("Receive message: " + message);
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec104"/>Sending every received message on the server side to create a chat room</h1></div></div></div><p>In the last example, the server <a id="id759" class="indexterm"/>could receive messages sent from browsers. However, the server does nothing except print the received messages in the terminal. Therefore, we will add some logic to the server to send the messages out.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec105"/>Time for action – sending messages to all connected browsers</h1></div></div></div><p>Carry out the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">game.js</code> file<a id="id760" class="indexterm"/> in the <strong>server</strong> folder for the<a id="id761" class="indexterm"/> server-side logic.</li><li class="listitem">Add the following highlighted code to the message event listener handler:<div><pre class="programlisting">user.socket.on("message", function(message){
  console.log("Receive message from " + user.id + ": " + message); 
  // send to all users in room.
  var msg = "User " + user.id + " said: " + message;
  room.sendAll(msg);
});</pre></div></li><li class="listitem">That is it for the server side. Move on to the <code class="literal">client</code> folder and open the <code class="literal">index.html</code> file.</li><li class="listitem">We want to display the chat messages in the chat history area. To do this, add the following code to the HTML file:<div><pre class="programlisting">&lt;ul id="chat-history"&gt;&lt;/ul&gt;</pre></div></li><li class="listitem">Next, we need the client-side JavaScript to handle the received message from the server. We used it to print it out into the console panel, replace the <code class="literal">console.log</code> code with the following highlighted code in the <code class="literal">onmessage</code> event handler:<div><pre class="programlisting">socket.onmessage = function(e) {
  $("#chat-history").append("&lt;li&gt;"+e.data+"&lt;/li&gt;");
};</pre></div></li><li class="listitem">Let's test our code. Terminate any running node server by pressing <em>Ctrl</em> + <em>C</em>. Then, run the server again.</li><li class="listitem">Open the <code class="literal">index.html</code> file twice and put them side by side. Type something in the text field and press <em>Enter</em>. The message will appear on both the opened browsers. If you open many instances of the HTML file, the message would appear on all the browsers. The following screenshot shows two browsers displaying the chat history side by side:<div><img src="img/B04290_08_05.jpg" alt="Time for action – sending messages to all connected browsers"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec222"/>
<em>What just happened?</em>
</h2></div></div></div><p>This is an extension of <a id="id762" class="indexterm"/>our previous examples. We discussed <a id="id763" class="indexterm"/>how a server sends the connection count to all the connected clients. We also discussed how the client sends a message to the server. In this example, we combine these two techniques to let the server send the received messages to all the connected users.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec223"/>Comparing WebSockets with polling approaches</h2></div></div></div><p>If you have ever built a web page's chat<a id="id764" class="indexterm"/> room by using a <a id="id765" class="indexterm"/>server-side language and a database, then you may wonder what the difference is between the WebSocket implementation and the traditional one.</p><p>The traditional chat room method is often implemented by using a <strong>polling</strong> approach. The client asks the server for an update periodically. The server responds to the client with either no update or the updated data. However, the traditional approach has several problems. The client does not get new data updated from the server until the next time it asks the server. This means that the data update is periodically delayed with time and the response is not instant enough. If we want to improve this issue by shortening the polling duration, then more bandwidth is utilized because clients need to keep sending requests to the server.</p><p>The following graph shows requests between the client and the server. It shows that many useless requests are sent, but the server responds to the client without any new data:</p><div><img src="img/B04290_08_06.jpg" alt="Comparing WebSockets with polling approaches"/></div><p>There is a better<a id="id766" class="indexterm"/> polling approach named <a id="id767" class="indexterm"/>
<strong>long polling</strong>: the <a id="id768" class="indexterm"/>client sends a request to the server and waits for the response. Instead of the traditional polling approach where the server responds with "no update", the server does not respond at all until there is something that needs to be pushed to the server. In this approach, the server can push something to clients whenever there is an update. Once a client receives a response from the server, it creates another request and waits for the next server notification. The following graph shows the long polling approach where clients ask for updates and the server responds only when there is an update:</p><div><img src="img/B04290_08_07.jpg" alt="Comparing WebSockets with polling approaches"/></div><p>In the WebSockets approach, the number of requests are way less than the polling approach. This is because the connection between the client and server is persistent. Once the connection is established, a request from either the client side or the server side is sent only when there is any <a id="id769" class="indexterm"/>update. For instance, a <a id="id770" class="indexterm"/>client sends a message to the server when it wants to update something to the server. The server also sends messages to clients only when it needs to notify the clients of a data update. No other useless requests are sent during the connection. Therefore, less bandwidth is utilized. The following graph shows the WebSockets approach:</p><div><img src="img/B04290_08_08.jpg" alt="Comparing WebSockets with polling approaches"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec106"/>Making a shared drawing whiteboard with Canvas and WebSockets</h1></div></div></div><p>Suppose <a id="id771" class="indexterm"/>we want a shared sketchpad. Anyone <a id="id772" class="indexterm"/>can draw something on the<a id="id773" class="indexterm"/> sketchpad and all others can<a id="id774" class="indexterm"/> view it. We learned how messages are communicated between clients and servers. We will go further and send drawing data.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec224"/>Building a local drawing sketchpad</h2></div></div></div><p>Before we <a id="id775" class="indexterm"/>deal with data sending and server handling, let's focus on making a drawing whiteboard. We will use the Canvas to build a local drawing sketchpad.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec107"/>Time for action – making a local drawing whiteboard with the Canvas</h1></div></div></div><p>Carry out the <a id="id776" class="indexterm"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We will focus only on the client side in this section. Open the <code class="literal">index.html</code> file and add the following <code class="literal">canvas</code> markup:<div><pre class="programlisting">&lt;canvas id='drawing-pad' width='500' height='400'&gt;
&lt;/canvas&gt;</pre></div></li><li class="listitem">We will draw something in the Canvas and we will need the mouse position relative to the Canvas for this. We did this in <a class="link" href="ch04.html" title="Chapter 4. Building the Untangle Game with Canvas and the Drawing API">Chapter 4</a>, <em>Building the Untangle Game with Canvas and the Drawing API</em>. Add the following style to the Canvas:<div><pre class="programlisting">&lt;style&gt;
  canvas{position:relative;}
&lt;/style&gt;</pre></div></li><li class="listitem">Then, open the <code class="literal">html5games.websocket.js</code> JavaScript file to add the drawing logic.</li><li class="listitem">Replace the <code class="literal">websocketGame</code> global object with the following variable at the top of the JavaScript file:<div><pre class="programlisting">var websocketGame = {
   // indicates if it is drawing now.
   isDrawing : false,

   // the starting point of next line drawing.
   startX : 0,
   startY : 0,
}

// canvas context
var canvas = document.getElementById('drawing-pad');
var ctx = canvas.getContext('2d');</pre></div></li><li class="listitem">In the jQuery <code class="literal">ready</code> function, add the following mouse event handler code. The code handles the mouse's down, move, and up events:<div><pre class="programlisting">// the logic of drawing in the Canvas
$("#drawing-pad").mousedown(function(e) {
  // get the mouse x and y relative to the canvas top-left point.
  var mouseX = e.originalEvent.layerX || e.offsetX || 0;
  var mouseY = e.originalEvent.layerY || e.offsetY || 0;

  websocketGame.startX = mouseX;
  websocketGame.startY = mouseY;

  websocketGame.isDrawing = true;
});

$("#drawing-pad").mousemove(function(e) {
  // draw lines when is drawing
  if (websocketGame.isDrawing) {
    // get the mouse x and y 
    // relative to the canvas top-left point.
    var mouseX = e.originalEvent.layerX || e.offsetX || 0;
    var mouseY = e.originalEvent.layerY || e.offsetY || 0;

    if (!(mouseX === websocketGame.startX &amp;&amp; mouseY === websocketGame.startY)) {
      drawLine(ctx, websocketGame.startX, websocketGame.startY,mouseX,mouseY,1);

      websocketGame.startX = mouseX;
      websocketGame.startY = mouseY;
    }
  }
});

$("#drawing-pad").mouseup(function(e) {
  websocketGame.isDrawing = false;
});</pre></div></li><li class="listitem">At last, we<a id="id777" class="indexterm"/> have the following<a id="id778" class="indexterm"/> function to draw a line in the Canvas with the given starting and ending points:<div><pre class="programlisting">function drawLine(ctx, x1, y1, x2, y2, thickness) {
   ctx.beginPath();
   ctx.moveTo(x1,y1);
   ctx.lineTo(x2,y2);
   ctx.lineWidth = thickness;
   ctx.strokeStyle = "#444";
   ctx.stroke();
}</pre></div></li><li class="listitem">Save all files and open the <code class="literal">index.html</code> file. You should see an empty space where you can draw something by using the mouse. The drawings are not sent to the server yet, so others cannot view your drawings:<div><img src="img/B04290_08_13.jpg" alt="Time for action – making a local drawing whiteboard with the Canvas"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec225"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just created a<a id="id779" class="indexterm"/> local drawing pad. This is like a <a id="id780" class="indexterm"/>whiteboard where the player can draw in the Canvas by dragging the mouse. However, the drawing data is not sent to the server yet; all drawings are only displayed locally.</p><p>The <code class="literal">drawing</code> <code class="literal">line</code> function is the same that we used in <a class="link" href="ch04.html" title="Chapter 4. Building the Untangle Game with Canvas and the Drawing API">Chapter 4</a>, <em>Building the Untangle Game with Canvas and the Drawing API</em>. We also used the same code to get the mouse position relative to the <code class="literal">canvas</code> element. However, the logic of the mouse events is different from <a class="link" href="ch04.html" title="Chapter 4. Building the Untangle Game with Canvas and the Drawing API">Chapter 4</a>, <em>Building the Untangle Game with Canvas and the Drawing API</em>.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec02"/>Drawing in the Canvas</h3></div></div></div><p>When we draw something on the computer, it often means that we click on the Canvas and drag the mouse (or pen). The line is drawn until the mouse button is up. Then, the user clicks on another place and drags again to draw lines.</p><p>In our example, we have a Boolean flag named <code class="literal">isDrawing</code> to indicate whether the user is drawing. The <code class="literal">isDrawing</code> flag is <code class="literal">false</code> by default. When the mouse button is at a point, we turn the flag to <code class="literal">true</code>. When the mouse is moving, we draw a line between the moved point and the last point when the mouse button was. Then, we set the <code class="literal">isDrawing</code> flag to <code class="literal">false</code> when the mouse button is up. This is how the drawing logic works.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec226"/>Have a go hero – drawing with colors</h2></div></div></div><p>Can we modify the drawing sketchpad by adding color support? How about adding five buttons with red, blue, green, black, and white colors? The player can choose the color when drawing. Alternatively, we can also provide different brush width options to the user.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec227"/>Sending the drawing to all the connected browsers</h2></div></div></div><p>We will go further by sending our<a id="id781" class="indexterm"/> drawing data to the server and let the<a id="id782" class="indexterm"/> server send the drawing to all the connected browsers.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec108"/>Time for action – sending the drawing through WebSockets</h1></div></div></div><p>Carry out the <a id="id783" class="indexterm"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to <a id="id784" class="indexterm"/>modify the server logic. Open the <code class="literal">game.js</code> file and add two constants at the beginning of the file, as follows:<div><pre class="programlisting">// Constants
var LINE_SEGMENT = 0;
var CHAT_MESSAGE = 1;</pre></div></li><li class="listitem">In the <code class="literal">Room.prototype.addUser</code> method, add the following code at the beginning of the method:<div><pre class="programlisting">this.users.push(user);
var room = this;
// tell others that someone joins the room
var data = {
  dataType: CHAT_MESSAGE,
  sender: "Server",
  message: "Welcome " + user.id 
     + " joining the party. Total connection: " + this.users.length
};  
room.sendAll(JSON.stringify(data));</pre></div></li><li class="listitem">We use JSON-formatted string for communicating both drawing actions and chat messages. Add the following code to the user sockets on the message event handler:<div><pre class="programlisting">user.socket.on("message", function(message){
  console.log("Receive message from " + user.id + ": " + message);
  
  // construct the message
  var data = JSON.parse(message);
  if (data.dataType === CHAT_MESSAGE) {
    // add the sender information into the message data object.
    data.sender = user.id;
  }
  
  // send to all clients in room.
  room.sendAll(JSON.stringify(data));
});</pre></div></li><li class="listitem">In <code class="literal">server.js</code>, there is<a id="id785" class="indexterm"/> no need to send the welcome<a id="id786" class="indexterm"/> message to the room since this is now handled by the <code class="literal">Room.addUser</code> method. Remove the following code from the <code class="literal">server.js</code> file:<div><pre class="programlisting">room1.sendAll(message);</pre></div></li><li class="listitem">On the client side, we need the logic to respond to the server with the same data object definition. Open the <code class="literal">html5games.websocket.js</code> JavaScript file in the <strong>js</strong> directory under <strong>client</strong>.</li><li class="listitem">Add the following constants to the <code class="literal">websocketGame</code> global variable. The same constants with the same values are also defined in the server-side logic.<div><pre class="programlisting">// Contants
LINE_SEGMENT : 0,
CHAT_MESSAGE : 1,</pre></div></li><li class="listitem">When handling the message event on the client-side, convert the JSON-formatted string back to the data object. If the data is a chat message, then we display it as the chat history, otherwise we draw it in the Canvas as a line segment. Replace the <code class="literal">onmessage</code> event handler with the following code: <div><pre class="programlisting">websocketGame.socket.onmessage = function(e) {
   // check if the received data is chat or line segment
   console.log("onmessage event:",e.data);
   var data = JSON.parse(e.data);
   if (data.dataType === websocketGame.CHAT_MESSAGE) {
      $("#chat-history").append("&lt;li&gt;" + data.sender
          + " said: "+data.message+"&lt;/li&gt;");
   }
   else if (data.dataType === websocketGame.LINE_SEGMENT) {
      drawLine(ctx, data.startX, data.startY, data.endX, data.endY, 1);
   }
   
};</pre></div></li><li class="listitem">When the mouse is moving, we not only draw the line in the Canvas but also send the line data to the server. Add the following highlighted code to the <code class="literal">mousemove</code> event handler:<div><pre class="programlisting">$("#drawing-pad").mousemove(function(e) {
   // draw lines when is drawing
   if (websocketGame.isDrawing) {
      // get the mouse x and y 
      // relative to the canvas top-left point.
      var mouseX = e.originalEvent.layerX || e.offsetX || 0;
      var mouseY = e.originalEvent.layerY || e.offsetX || 0;

      if (!(mouseX === websocketGame.startX &amp;&amp; mouseY === websocketGame.startY)) {
         drawLine(ctx, websocketGame.startX, websocketGame.startY,mouseX,mouseY,1);
         
         <strong>// send the line segment to server</strong>
<strong>         var data = {};</strong>
<strong>         data.dataType = websocketGame.LINE_SEGMENT;</strong>
<strong>         data.startX = websocketGame.startX;</strong>
<strong>         data.startY = websocketGame.startY;</strong>
<strong>         data.endX = mouseX;</strong>
<strong>         data.endY = mouseY;</strong>
<strong>         websocketGame.socket.send(JSON.stringify(data));</strong>
         
         websocketGame.startX = mouseX;
         websocketGame.startY = mouseY;
      }
      
   }
});</pre></div></li><li class="listitem">Lastly, we need to <a id="id787" class="indexterm"/>modify the send message <a id="id788" class="indexterm"/>logic. We now pack the message in an object and format it as JSON when sending it to the server. Change the <code class="literal">sendMessage</code> function to the following code: <div><pre class="programlisting">function sendMessage() {
   var message = $("#chat-input").val();
   
   // pack the message into an object.
   var data = {};
   data.dataType = websocketGame.CHAT_MESSAGE;
   data.message = message;
   
   websocketGame.socket.send(JSON.stringify(data));
   $("#chat-input").val("");
}</pre></div></li><li class="listitem">Save all the files and relaunch the server.</li><li class="listitem">Open the <code class="literal">index.html</code> file in two browser instances.</li><li class="listitem">First, try the chat<a id="id789" class="indexterm"/> room feature by typing <a id="id790" class="indexterm"/>some messages and sending them. Then, try drawing something in the Canvas. Both browsers should display the same drawing, as shown in the following screenshot:<div><img src="img/B04290_08_10.jpg" alt="Time for action – sending the drawing through WebSockets"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec228"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just built a multiuser sketchpad. This is similar to the sketchpad we tried at the beginning of this chapter. We extended what you learned when building a chat room by sending a complex data object as a message.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec229"/>Defining a data object to communicate between the client and the server</h2></div></div></div><p>In order to communicate<a id="id791" class="indexterm"/> correctly between the server and clients when there is a lot of data packed into one message, we have to define a data object that both the client and server understand.</p><p>There are several properties in the data object. The following table lists the properties and why we need them:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property name</p>
</th><th style="text-align: left" valign="bottom">
<p>Why we need this property</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dataType</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an<a id="id792" class="indexterm"/> important property that helps us to understand the entire data. The data is either a chat message or drawing line segment data.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sender</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If the data is a <a id="id793" class="indexterm"/>chat message, the client needs to know who sent the message.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">message</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When<a id="id794" class="indexterm"/> the data type is a chat message, we surely need to include the message content itself into the data object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">startX</code>
</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>When the<a id="id795" class="indexterm"/> data type is a drawing line<a id="id796" class="indexterm"/> segment, we include the <em>x</em>/<em>y</em> coordinates of the starting point of the line.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">startY</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">endX</code>
</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>When the <a id="id797" class="indexterm"/>data type is a drawing line <a id="id798" class="indexterm"/>segment, we include the <em>x</em>/<em>y</em> coordinates of the ending point of the line.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">endY</code>
</p>
</td></tr></tbody></table></div><p>In addition, we have the <a id="id799" class="indexterm"/>following constants defined on both the client side and the server side; these constants are for the <code class="literal">dataType</code> property: </p><div><pre class="programlisting">// Contants
LINE_SEGMENT : 0,
CHAT_MESSAGE : 1,</pre></div><p>With these constants, we can compare datatypes with the following readable code, instead of using the meaningless Integer:</p><div><pre class="programlisting">if (data.dataType === websocketGame.CHAT_MESSAGE) {…}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec230"/>Packing the drawing lines data into JSON for sending</h2></div></div></div><p>We used the <code class="literal">JSON.stringify</code> function in <a id="id800" class="indexterm"/>the last chapter when we stored a JavaScript <a id="id801" class="indexterm"/>object into a JSON-formatted string in the local storage. Now, we need to send the data in string format between the server and the client. We use the same method to pack the drawing lines data into an object and send it as a JSON string.</p><p>The following code snippet shows how we pack the line segment data on the client side and send it to the server with a JSON-formatted string:</p><div><pre class="programlisting">// send the line segment to server
var data = {};
data.dataType = websocketGame.LINE_SEGMENT;
data.startX = startX;
data.startY = startY;
data.endX = mouseX;
data.endY = mouseY;
websocketGame.socket.send(JSON.stringify(data));</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec231"/>Recreating the drawing lines after receiving them from other clients</h2></div></div></div><p>The JSON parsing often <a id="id802" class="indexterm"/>comes as a pair of <code class="literal">stringify</code>. When we receive a message from the server, we have to parse it to the JavaScript object. The following code on the client side parses the data and either updates the chat history or draws a line based on the data:</p><div><pre class="programlisting">var data = JSON.parse(e.data);
if (data.dataType === websocketGame.CHAT_MESSAGE) {
  $("#chat-history").append("&lt;li&gt;"+data.sender+" said: "+data.message+"&lt;/li&gt;");
}
else if (data.dataType === websocketGame.LINE_SEGMENT) {
  drawLine(ctx, data.startX, data.startY, data.endX, data.endY, 1);
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec109"/>Building a multiplayer draw-and-guess game</h1></div></div></div><p>We built an instant chat room <a id="id803" class="indexterm"/>earlier in this chapter. Moreover, we just built a multiuser sketchpad. How about combining these two techniques and building a draw-and-guess game? A draw-and-guess game is a game in which one player is given a word to draw. All other players do not know the word and guess the word according to the drawing. The one who draws and who correctly guesses the word earn points.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec110"/>Time for action – building the draw-and-guess game</h1></div></div></div><p>We will implement the game flow of the draw-and-guess game as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we will add the game logic on the client side.</li><li class="listitem">Open the <code class="literal">index.html</code> file in the client directory. Add the following restart button right after the <em>send</em> button:<div><pre class="programlisting">&lt;input type="button" value="Restart" id="restart"&gt;</pre></div></li><li class="listitem">Open the <code class="literal">html5games.websocket.js</code> JavaScript.</li><li class="listitem">We need a few more constants to determine different states during the game play. Add the following highlighted code to the top of the file:<div><pre class="programlisting">// Constants
LINE_SEGMENT : 0,
CHAT_MESSAGE : 1,
<strong>GAME_LOGIC : 2,</strong>

<strong>// Constant for game logic state</strong>
<strong>WAITING_TO_START : 0,</strong>
<strong>GAME_START : 1,</strong>
<strong>GAME_OVER : 2,</strong>
<strong>GAME_RESTART : 3,</strong>
</pre></div></li><li class="listitem">In addition, we want a flag to indicate this player is in charge of drawing. Add the following Boolean global variable to the code:<div><pre class="programlisting">isTurnToDraw : false,</pre></div></li><li class="listitem">When the client receives<a id="id804" class="indexterm"/> a message from the server, it parses it and checks whether it is a chat message or a line drawing. We have another type of message now named <code class="literal">GAME_LOGIC</code> for handling the game logic. The game logic message contains different data for different game states. Add the following code to the <code class="literal">onmessage</code> event handler:<div><pre class="programlisting">else if (data.dataType === websocketGame.GAME_LOGIC) {
  if (data.gameState === websocketGame.GAME_OVER) {
    websocketGame.isTurnToDraw = false;
    $("#chat-history").append("&lt;li&gt;" + data.winner
       +" wins! The answer is '"+data.answer+"'.&lt;/li&gt;");
    $("#restart").show();
  }
  if (data.gameState === websocketGame.GAME_START) {
    // clear the Canvas.
    canvas.width = canvas.width;
    
    // hide the restart button.
    $("#restart").hide();
    
    // clear the chat history
    $("#chat-history").html("");
    
    if (data.isPlayerTurn) {
      websocketGame.isTurnToDraw = true;
      $("#chat-history").append("&lt;li&gt;Your turn to draw. Please draw '" + data.answer + "'.&lt;/li&gt;");
    }
    else {
      $("#chat-history").append("&lt;li&gt;Game Started. Get Ready. You have one minute to guess.&lt;/li&gt;");
    }
  }
}</pre></div></li><li class="listitem">There is one last step in the <a id="id805" class="indexterm"/>client-side logic. We want to restart the game by sending a restart signal to the server. At the same time, we clear the drawing and chat history. To do this, add the following code inside the <code class="literal">html5games.websocket.js</code> file.<div><pre class="programlisting">// restart button
$("#restart").hide();
$("#restart").click(function(){
  canvas.width = canvas.width;
  $("#chat-history").html("");
  $("#chat-history").append("&lt;li&gt;Restarting Game.&lt;/li&gt;");
  
  // pack the restart message into an object.
  var data = {};
  data.dataType = websocketGame.GAME_LOGIC;
  data.gameState = websocketGame.GAME_RESTART;
  websocketGame.socket.send(JSON.stringify(data));
  
  $("#restart").hide();
});</pre></div></li><li class="listitem">It is now time to move on to the server side. We need more states to control the game flow. Replace the constants at the beginning of the <code class="literal">game.js</code> file with the following code.<div><pre class="programlisting">// Constants
var LINE_SEGMENT = 0;
var CHAT_MESSAGE = 1;
var GAME_LOGIC = 2;
// Constant for game logic state
var WAITING_TO_START = 0;
var GAME_START = 1;
var GAME_OVER = 2;
var GAME_RESTART = 3; </pre></div></li><li class="listitem">In the previous example, the server side was just in charge of sending any incoming message to all connected browsers. This is not enough for a multiplayer game. The server will act as the game master that controls the game flow and determination of the winning condition. We extend the <code class="literal">Room</code> class with <code class="literal">GameRoom</code> that can handle the game flow.</li><li class="listitem">Now, add the following code to the end of the <code class="literal">game.js</code> file. This is the constructor function of a new class called <code class="literal">GameRoom</code>, which initializes game logic.<div><pre class="programlisting">function GameRoom() { 
  // the current turn of player index.
  this.playerTurn = 0;

  this.wordsList = ['apple','idea','wisdom','angry'];
  this.currentAnswer = undefined;

  this.currentGameState = WAITING_TO_START;
  
  // send the game state to all players.
  var gameLogicData = {
    dataType: GAME_LOGIC,
    gameState: WAITING_TO_START
  };

  this.sendAll(JSON.stringify(gameLogicData));
  
}</pre></div></li><li class="listitem">Then, we extend the<a id="id806" class="indexterm"/> existing <code class="literal">Room</code> functionality into the <code class="literal">GameRoom</code> prototype so that <code class="literal">GameRoom</code> will have access to the <code class="literal">Room</code> class' prototype function by default.<div><pre class="programlisting">// inherit Room
GameRoom.prototype = new Room();</pre></div></li><li class="listitem">Define the following <code class="literal">addUser</code> function in the <code class="literal">GameRoom</code> class. Append the code after our existing <code class="literal">GameRoom</code> code. This keeps the original room's <code class="literal">addUser</code> function and adds extra logic that waits until enough players join to start the game:<div><pre class="programlisting">GameRoom.prototype.addUser = function(user) {
  // a.k.a. super(user) in traditional OOP language.
  Room.prototype.addUser.call(this, user);
  
  // start the game if there are 2 or more connections
  if (this.currentGameState === WAITING_TO_START &amp;&amp; this.users.length &gt;= 2) {
    this.startGame();
  }
};</pre></div></li><li class="listitem">Unlike the previous example in which the server only passes user messages to all of the connected clients, now the server needs to determine whether the messages from the user are part of the game flow. Append the following code after the existing <code class="literal">GameRoom</code> logic; It overrides the original room's <code class="literal">handleOnUserMessage</code> function into new logic that handles chat messages, line segments, and the<a id="id807" class="indexterm"/> control of the game flow:<div><pre class="programlisting">GameRoom.prototype.handleOnUserMessage = function(user) {
  var room = this;
  // handle on message
  user.socket.on('message', function(message){
    console.log("[GameRoom] Receive message from " 
          + user.id + ": " + message); 
    
    var data = JSON.parse(message);
    if (data.dataType === CHAT_MESSAGE) {
      // add the sender information into the message data object.
      data.sender = user.id;
    }
    room.sendAll(JSON.stringify(data));
    
    // check if the message is guessing right or wrong
    if (data.dataType === CHAT_MESSAGE) {
      console.log("Current state: " + room.currentGameState);
      
      if (room.currentGameState === GAME_START) {
        console.log("Got message: " + data.message 
            + " (Answer: " + room.currentAnswer + ")");
      }
      
      if (room.currentGameState === GAME_START &amp;&amp; data.message === room.currentAnswer) {
        var gameLogicData = {
          dataType: GAME_LOGIC,
          gameState: GAME_OVER,
          winner: user.id,
          answer: room.currentAnswer
        };
        
        room.sendAll(JSON.stringify(gameLogicData));
        
        room.currentGameState = WAITING_TO_START;
        
        // clear the game over timeout
        clearTimeout(room.gameOverTimeout);
      }
    }
    
    
    if (data.dataType === GAME_LOGIC &amp;&amp; data.gameState === GAME_RESTART) {
      room.startGame();
    }
  });
};</pre></div></li><li class="listitem">Let's continue with <a id="id808" class="indexterm"/>the <code class="literal">GameRoom</code> logic. Add the following new function to the <code class="literal">game.js</code> file. This creates a new game inside the room by picking a player as a drawer and the others as guessers; then, it randomly picks a word for the drawer to draw:<div><pre class="programlisting">GameRoom.prototype.startGame = function() {
  var room = this;
  
  // pick a player to draw
  this.playerTurn = (this.playerTurn+1) % this.users.length;
  
  console.log("Start game with player " + this.playerTurn 
      + "'s turn.");
  
  // pick an answer
  var answerIndex = Math.floor(Math.random() * this.wordsList.length);
  this.currentAnswer = this.wordsList[answerIndex];
  
  // game start for all players
  var gameLogicDataForAllPlayers = {
    dataType: GAME_LOGIC,
    gameState: GAME_START,
    isPlayerTurn: false
  };
  
  this.sendAll(JSON.stringify(gameLogicDataForAllPlayers));
  
  // game start with answer to the player in turn.
  var gameLogicDataForDrawer = {
    dataType: GAME_LOGIC,
    gameState: GAME_START,
    answer: this.currentAnswer,
    isPlayerTurn: true
  };

  // the user who draws in this turn.
  var user = this.users[this.playerTurn];
  user.socket.send(JSON.stringify(gameLogicDataForDrawer));
  
  
  // game over the game after 1 minute.
  gameOverTimeout = setTimeout(function(){
    var gameLogicData = {
      dataType: GAME_LOGIC,
      gameState: GAME_OVER,
      winner: "No one",
      answer: room.currentAnswer
    };
    
    room.sendAll(JSON.stringify(gameLogicData));
    
    room.currentGameState = WAITING_TO_START;
  },60*1000);

  room.currentGameState = GAME_START;
};</pre></div></li><li class="listitem">At last, we <a id="id809" class="indexterm"/>export the <code class="literal">GameRoom</code> class so that other files, such as <code class="literal">server.js</code>, can access the <code class="literal">GameRoom</code> class:<div><pre class="programlisting">module.exports.GameRoom = GameRoom;</pre></div></li><li class="listitem"> In <code class="literal">server.js</code>, we must call our new <code class="literal">GameRoom</code> constructor instead of the generic <code class="literal">Room</code> constructor. Replace the original related code to <code class="literal">Room</code> with the following <code class="literal">GameRoom</code> code:<div><pre class="programlisting">var GameRoom = require('./game').GameRoom;
var room1 = new GameRoom();</pre></div></li><li class="listitem">We will save all the files and relaunch the server. Then, we will launch the <code class="literal">index.html</code> file in two browser instances. One browser will get a message from the server informing the player to draw something. The other browser, on the other hand, will inform the player to guess what the other player is drawing within one minute.</li><li class="listitem">The player who is told to draw something can draw in the Canvas. The drawings are sent to all the other connected players. The players who are told to guess cannot draw anything in the Canvas. Instead, players type what they guess in the text field and send it to the server. If the guess is correct, then the game ends. Otherwise, the game continues until the one-minute countdown finishes.<div><img src="img/B04290_08_11.jpg" alt="Time for action – building the draw-and-guess game"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec232"/>
<em>What just happened?</em>
</h2></div></div></div><p>We just created a<a id="id810" class="indexterm"/> multiplayer draw-and-guess game in WebSockets and Canvas. The main difference between the game and the multiuser sketchpad is that the server now controls the game flow instead of letting all the users draw.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec233"/>Inheriting the Room class</h2></div></div></div><p>In JavaScript, we can inherit a <a id="id811" class="indexterm"/>defined class with a new class. We define <code class="literal">GameRoom</code> that inherits the <code class="literal">Room</code> class. The <code class="literal">GameRoom</code> class will have the <code class="literal">Room</code> logic that it inherits plus the extra logic that is specifically designed for the game flow. Inheritance is done by creating an instance of the class into the prototype, as follows:</p><div><pre class="programlisting">GameRoom.prototype = new Room();</pre></div><p>Now, <code class="literal">GameRoom</code> has the prototype methods from <code class="literal">Room</code>. We can then define more logic in <code class="literal">GameRoom</code> such as the <code class="literal">startGame</code> method. We can also override the existing logic by defining a new prototype method in the <code class="literal">GameRoom</code> class with the same name; for example, we override the <code class="literal">handleOnUserMessage</code> method to send the game starting and winning logic.</p><p>Sometimes, we want to <a id="id812" class="indexterm"/>extend an existing logic instead of replacing the old one with a new one. In such a case, we need to execute the logic that we have overridden by the method with the same name. We can use the following code to execute the method that's in the original prototype; we used this approach in the <code class="literal">addUser</code> method to keep the original logic:</p><div><pre class="programlisting">// a.k.a. super(user) in traditional OOP language.
Room.prototype.addUser.call(this, user);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec234"/>Controlling the game flow of a multiplayer game</h2></div></div></div><p>Controlling the game flow of a <a id="id813" class="indexterm"/>multiplayer game <a id="id814" class="indexterm"/>is much more difficult than a single game. We can simply use a few variables to control the game flow of a single game, but we have to use message passing to inform each player of specific updated game flow.</p><p>First, we require the following highlighted <code class="literal">GAME_LOGIC</code> constant for <code class="literal">dataType</code>. We use this data to send and receive a message that is related to the game logic control:</p><div><pre class="programlisting">// Constants
var LINE_SEGMENT = 0;
var CHAT_MESSAGE = 1;
var GAME_LOGIC = 2;</pre></div><p>There are several states in the game flow. Before the game starts, the connected players are waiting for the game to start. Once there are enough connections for the multiplayer game, the server sends a game logic message to all the players to inform them of the start of the game.</p><p>When the game is over, the server sends a game over state to all the players. Then, the game finishes and the game logic halts until any player clicks on the restart button. Once the restart button is clicked, the client sends a game restart state to the server instructing the server to prepare a new game. Then, the game starts again.</p><p>We declare the four game states as the following constants in both the client and server so that they understand them:</p><div><pre class="programlisting">// Constant for game logic state
var WAITING_TO_START = 0;
var GAME_START = 1;
var GAME_OVER = 2;
var GAME_RESTART = 3;</pre></div><p>The following code on the server side holds an index to indicate which player's turn is now:</p><div><pre class="programlisting">var playerTurn = 0;</pre></div><p>The data which is sent to the player (whose turn it is) is different from the data that is sent to other players. The other players receive the following data with only a game start signal:</p><div><pre class="programlisting">var gameLogicDataForAllPlayers = {
  dataType: GAME_LOGIC,
  gameState: GAME_START,
  isPlayerTurn: false
};</pre></div><p>On the other hand, the<a id="id815" class="indexterm"/> player (whose turn is to draw) receives<a id="id816" class="indexterm"/> the following data with the word information:</p><div><pre class="programlisting">var gameLogicDataForDrawer = {
  dataType: GAME_LOGIC,
  gameState: GAME_START,
  answer: this.currentAnswer,
  isPlayerTurn: true
};  </pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec235"/>Room and Game Room</h2></div></div></div><p>By the end of this <a id="id817" class="indexterm"/>example, we have created two types of <a id="id818" class="indexterm"/>rooms: a normal room and a game room. Specifically, a normal room has the most basic features: managing users and chatting within the room. The game room, which is built on top of the normal room, adds another large block of logic to manage a draw-and-guess game flow. The game flow includes waiting for the game to start, starting the game, determining game over, and triggering time out. All these game flow controls are encapsulated into the <code class="literal">GameRoom</code> class.</p><p>In the future, we can easily expand the multiplayer game by adding different types of game into it. For example, we can create a 2-player tic-tac-toe game by creating a <code class="literal">TicTacToeGameRoom</code> class that shares similar waiting and restarting game logic in <code class="literal">GameRoom</code>. However, the <code class="literal">TicTacToeGameRoom</code> class will handle other game flows such as passing the game board data and handling a tied game. Since all game logic is encapsulated inside the specific game room, different types of multiplayer game won't affect each other.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec236"/>Improving the game</h2></div></div></div><p>We have just created a<a id="id819" class="indexterm"/> multiplayer game that is playable. However, there is still a lot to improve. In the following sections, we list two possible improvements of the game.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec03"/>Improving the styles</h3></div></div></div><p>The game looks very <a id="id820" class="indexterm"/>plain now. We can improve its visual outlook by adding CSS styles and decorative images to it. In the code bundle, you will find an example with extra CSS styles applied to make the game look better. You may try different styling effects also.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec04"/>Storing drawn lines on each game</h3></div></div></div><p>In the game, the drawer draws <a id="id821" class="indexterm"/>lines and other players guess the drawing. Now, imagine that two players are playing and the third player joins them. As there is no storage for the drawn lines anywhere, the third player cannot see what the drawer has drawn. This means that the third player has to wait until the game ends to play.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec237"/>Have a go hero</h2></div></div></div><p>How can we let a player who has joined late continue the game without losing the drawn lines? How can we reconstruct the drawing for a newly connected player? How about storing all drawing data of the current game on the server?</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec05"/>Improving the answer checking mechanism</h3></div></div></div><p>The answer checking on the server<a id="id822" class="indexterm"/> side compares the message with the <code class="literal">currentAnswer</code> variable to determine whether a player guessed correctly. The answer is treated as incorrect if the case does not match. It looks strange when the answer is "apples" and the player is told that their answer is wrong when they guess "apple".</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec238"/>Have a go hero</h2></div></div></div><p>How can we improve the answer checking mechanism? How about improving the answer checking logic to treat the answer as correct when using a different case or even similar words? The current game is quite plain in style. Please add your decoration to the game to make it more appealing to the players.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec111"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about connecting browsers to WebSockets. The messages and events from one browser are sent to all connected browsers in almost real time.</p><p>Specifically, we learned how WebSockets provide real-time events by drawing on an existing multiplayer sketchpad. It shows drawings from other users who are connected. We chose Node.js as the server-side WebSocket server. By using this server, we can easily build an event-based server to handle WebSocket requests from browsers. We discussed the relationship between the server and a client, which compares WebSockets with other approaches such as long-polling. We built an instant chat room application. We learned how to implement a server script to send all incoming messages to other connected browsers. We also learned how to display a received message from the server on the client side. Next, we built a multiuser drawing board and finally a draw-and-guess game by integrating the chatting along with the drawing pad.</p><p>Now that you have learned how to build a multiplayer game, we are ready to build physics games with the help of the physics engine in the next chapter.</p></div></body></html>