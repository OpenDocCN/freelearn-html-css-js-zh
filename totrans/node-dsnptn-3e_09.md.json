["```js\nimport { promises as fs } from 'fs'\nimport objectPath from 'object-path'\nexport class Config {\n  constructor (formatStrategy) {                           // (1)\n    this.data = {}\n    this.formatStrategy = formatStrategy\n  }\n  get (configPath) {                                       // (2)\n    return objectPath.get(this.data, configPath)\n  }\n  set (configPath, value) {                                // (2)\n    return objectPath.set(this.data, configPath, value)\n  }\n  async load (filePath) {                                  // (3)\n    console.log(`Deserializing from ${filePath}`)\n    this.data = this.formatStrategy.deserialize(\n      await fs.readFile(filePath, 'utf-8')\n    )\n  }\n  async save (filePath) {                                  // (3)\n    console.log(`Serializing to ${filePath}`)\n    await fs.writeFile(filePath,\n      this.formatStrategy.serialize(this.data))\n  }\n} \n```", "```js\nimport ini from 'ini'\nexport const iniStrategy = {\n  deserialize: data => ini.parse(data),\n  serialize: data => ini.stringify(data)\n} \n```", "```js\nexport const jsonStrategy = {\n  deserialize: data => JSON.parse(data),\n  serialize: data => JSON.stringify(data, null, '  ')\n} \n```", "```js\nimport { Config } from './config.js'\nimport { jsonStrategy, iniStrategy } from './strategies.js'\nasync function main () {\n  const iniConfig = new Config(iniStrategy)\n  await iniConfig.load('samples/conf.ini')\n  iniConfig.set('book.nodejs', 'design patterns')\n  await iniConfig.save('samples/conf_mod.ini')\n  const jsonConfig = new Config(jsonStrategy)\n  await jsonConfig.load('samples/conf.json')\n  jsonConfig.set('book.nodejs', 'design patterns')\n  await jsonConfig.save('samples/conf_mod.json')\n}\nmain() \n```", "```js\nfunction context(strategy) {...} \n```", "```js\nimport { OfflineState } from './offlineState.js'\nimport { OnlineState } from './onlineState.js'\nexport class FailsafeSocket {\n  constructor (options) {                                  // (1)\n    this.options = options\n    this.queue = []\n    this.currentState = null\n    this.socket = null\n    this.states = {\n      offline: new OfflineState(this),\n      online: new OnlineState(this)\n    }\n    this.changeState('offline')\n  }\n  changeState (state) {                                    // (2)\n    console.log(`Activating state: ${state}`)\n    this.currentState = this.states[state]\n    this.currentState.activate()\n  }\n  send (data) {                                            // (3)\n    this.currentState.send(data)\n  }\n} \n```", "```js\nimport jsonOverTcp from 'json-over-tcp-2'                  // (1)\nexport class OfflineState {\n  constructor (failsafeSocket) {\n    this.failsafeSocket = failsafeSocket\n  }\n  send (data) {                                            // (2)\n    this.failsafeSocket.queue.push(data)\n  }\n  activate () {                                            // (3)\n    const retry = () => {\n      setTimeout(() => this.activate(), 1000)\n    }\n    console.log('Trying to connect...')\n    this.failsafeSocket.socket = jsonOverTcp.connect(\n      this.failsafeSocket.options,\n      () => {\n        console.log('Connection established')\n        this.failsafeSocket.socket.removeListener('error', retry)\n        this.failsafeSocket.changeState('online')\n      }\n    )\n    this.failsafeSocket.socket.once('error', retry)\n  }\n} \n```", "```js\nexport class OnlineState {\n  constructor (failsafeSocket) {\n    this.failsafeSocket = failsafeSocket\n    this.hasDisconnected = false\n  }\n  send (data) {                                            // (1)\n    this.failsafeSocket.queue.push(data)\n    this._safeWrite(data)\n  }\n  _safeWrite (data) {                                      // (2)\n    this.failsafeSocket.socket.write(data, (err) => {\n      if (!this.hasDisconnected && !err) {\n        this.failsafeSocket.queue.shift()\n      }\n    })\n  }\n  activate () {                                            // (3)\n    this.hasDisconnected = false\n    for (const data of this.failsafeSocket.queue) {\n      this._safeWrite(data)\n    }\n    this.failsafeSocket.socket.once('error', () => {\n      this.hasDisconnected = true\n      this.failsafeSocket.changeState('offline')\n    })\n  }\n} \n```", "```js\nimport jsonOverTcp from 'json-over-tcp-2'\nconst server = jsonOverTcp.createServer({ port: 5000 })\nserver.on('connection', socket => {\n  socket.on('data', data => {\n    console.log('Client data', data)\n  })\n})\nserver.listen(5000, () => console.log('Server started')) \n```", "```js\nimport { FailsafeSocket } from './failsafeSocket.js'\nconst failsafeSocket = new FailsafeSocket({ port: 5000 })\nsetInterval(() => {\n  // send current memory usage\n  failsafeSocket.send(process.memoryUsage())\n}, 1000) \n```", "```js\nimport { promises as fsPromises } from 'fs'\nimport objectPath from 'object-path'\nexport class ConfigTemplate {\n  async load (file) {\n    console.log(`Deserializing from ${file}`)\n    this.data = this._deserialize(\n      await fsPromises.readFile(file, 'utf-8'))\n  }\n  async save (file) {\n    console.log(`Serializing to ${file}`)\n    await fsPromises.writeFile(file, this._serialize(this.data))\n  }\n  get (path) {\n    return objectPath.get(this.data, path)\n  }\n  set (path, value) {\n    return objectPath.set(this.data, path, value)\n  }\n  _serialize () {\n    throw new Error('_serialize() must be implemented')\n  }\n  _deserialize () {\n    throw new Error('_deserialize() must be implemented')\n  }\n} \n```", "```js\nimport { ConfigTemplate } from './configTemplate.js'\nexport class JsonConfig extends ConfigTemplate {\n  _deserialize (data) {\n    return JSON.parse(data)\n  }\n  _serialize (data) {\n    return JSON.stringify(data, null, '  ')\n  }\n} \n```", "```js\nimport { ConfigTemplate } from './configTemplate.js'\nimport ini from 'ini'\nexport class IniConfig extends ConfigTemplate {\n  _deserialize (data) {\n    return ini.parse(data)\n  }\n  _serialize (data) {\n    return ini.stringify(data)\n  }\n} \n```", "```js\nimport { JsonConfig } from './jsonConfig.js'\nimport { IniConfig } from './iniConfig.js'\nasync function main () {\n  const jsonConfig = new JsonConfig()\n  await jsonConfig.load('samples/conf.json')\n  jsonConfig.set('nodejs', 'design patterns')\n  await jsonConfig.save('samples/conf_mod.json')\n  const iniConfig = new IniConfig()\n  await iniConfig.load('samples/conf.ini')\n  iniConfig.set('nodejs', 'design patterns')\n  await iniConfig.save('samples/conf_mod.ini')\n}\nmain() \n```", "```js\nconst A_CHAR_CODE = 65\nconst Z_CHAR_CODE = 90\nfunction createAlphabetIterator () {\n  let currCode = A_CHAR_CODE\n  return {\n    next () {\n      const currChar = String.fromCodePoint(currCode)\n      if (currCode > Z_CHAR_CODE) {\n        return { done: true }\n      }\n      currCode++\n      return { value: currChar, done: false }\n    }\n  }\n} \n```", "```js\nconst iterator = createAlphabetIterator()\nlet iterationResult = iterator.next()\nwhile (!iterationResult.done) {\n  console.log(iterationResult.value)\n  iterationResult = iterator.next()\n} \n```", "```js\nclass MyIterable {\n  // other methods...\n  [Symbol.iterator] () {\n    // return an iterator\n  }\n} \n```", "```js\nexport class Matrix {\n  constructor (inMatrix) {\n    this.data = inMatrix\n  }\n  get (row, column) {\n    if (row >= this.data.length ||\n      column >= this.data[row].length) {\n      throw new RangeError('Out of bounds')\n    }\n    return this.data[row][column]\n  }\n  set (row, column, value) {\n    if (row >= this.data.length ||\n      column >= this.data[row].length) {\n      throw new RangeError('Out of bounds')\n    }\n    this.data[row][column] = value\n  }\n  [Symbol.iterator] () {\n    let nextRow = 0\n    let nextCol = 0\n    return {\n      next: () => {\n        if (nextRow === this.data.length) {\n          return { done: true }\n        }\n        const currVal = this.data[nextRow][nextCol]\n        if (nextCol === this.data[nextRow].length - 1) {\n          nextRow++\n          nextCol = 0\n        } else {\n          nextCol++\n        }\n        return { value: currVal }\n      }\n    }\n  }\n} \n```", "```js\nimport { Matrix } from './matrix.js'\nconst matrix2x2 = new Matrix([\n  ['11', '12'],\n  ['21', '22']\n])\nconst iterator = matrix2x2[Symbol.iterator]()\nlet iterationResult = iterator.next()\nwhile (!iterationResult.done) {\n  console.log(iterationResult.value)\n  iterationResult = iterator.next()\n} \n```", "```js\nfor (const element of matrix2x2) {\n  console.log(element)\n} \n```", "```js\nconst flattenedMatrix = [...matrix2x2]\nconsole.log(flattenedMatrix) \n```", "```js\nconst [oneOne, oneTwo, twoOne, twoTwo] = matrix2x2\nconsole.log(oneOne, oneTwo, twoOne, twoTwo) \n```", "```js\nfor (const letter of createAlphabetIterator()) {\n  //...\n} \n```", "```js\nfunction * myGenerator () {\n  // generator body\n} \n```", "```js\nfunction * fruitGenerator () {\n  yield 'peach'\n  yield 'watermelon'\n  return 'summer'\n}\nconst fruitGeneratorObj = fruitGenerator()\nconsole.log(fruitGeneratorObj.next())                      // (1)\nconsole.log(fruitGeneratorObj.next())                      // (2)\nconsole.log(fruitGeneratorObj.next())                      // (3) \n```", "```js\n { value: 'peach', done: false }\n    { value: 'watermelon', done: false }\n    { value: 'summer', done: true } \n```", "```js\nfor (const fruit of fruitGenerator()) {\n  console.log(fruit)\n} \n```", "```js\npeach\nwatermelon \n```", "```js\nfunction * twoWayGenerator () {\n  const what = yield null\n  yield 'Hello ' + what\n}\nconst twoWay = twoWayGenerator()\ntwoWay.next()\nconsole.log(twoWay.next('world')) \n```", "```js\nfunction * twoWayGenerator () {\n  try {\n    const what = yield null\n    yield 'Hello ' + what\n  } catch (err) {\n    yield 'Hello error: ' + err.message\n  }\n}\nconsole.log('Using throw():')\nconst twoWayException = twoWayGenerator()\ntwoWayException.next()\nconsole.log(twoWayException.throw(new Error('Boom!')))\nconsole.log('Using return():')\nconst twoWayReturn = twoWayGenerator()\nconsole.log(twoWayReturn.return('myReturnValue')) \n```", "```js\nUsing throw():\n{ value: 'Hello error: Boom!', done: false }\nUsing return():\n{ value: 'myReturnValue', done: true } \n```", "```js\nexport class Matrix {\n  // ...rest of the methods (stay unchanged)\n  * [Symbol.iterator] () {                                 // (1)\n    let nextRow = 0                                        // (2)\n    let nextCol = 0\n    while (nextRow !== this.data.length) {                 // (3)\n      yield this.data[nextRow][nextCol]\n      if (nextCol === this.data[nextRow].length - 1) {\n        nextRow++\n        nextCol = 0\n      } else {\n        nextCol++\n      }\n    }\n  }\n} \n```", "```js\nconst asyncIterator = iterable[Symbol.asyncIterator]()\nlet iterationResult = await asyncIterator.next()\nwhile (!iterationResult.done) {\n  console.log(iterationResult.value)\n  iterationResult = await asyncIterator.next()\n} \n```", "```js\nimport superagent from 'superagent'\nexport class CheckUrls {\n  constructor (urls) {                                     // (1)\n    this.urls = urls\n  }\n  [Symbol.asyncIterator] () {\n    const urlsIterator = this.urls[Symbol.iterator]()      // (2)\n    return {\n      async next () {                                      // (3)\n        const iteratorResult = urlsIterator.next()         // (4)\n        if (iteratorResult.done) {\n          return { done: true }\n        }\n        const url = iteratorResult.value\n        try {\n          const checkResult = await superagent             // (5)\n            .head(url)\n            .redirects(2)\n          return {\n            done: false,\n            value: `${url} is up, status: ${checkResult.status}`\n          }\n        } catch (err) {\n          return {\n            done: false,\n            value: `${url} is down, error: ${err.message}`\n          }\n        }\n      }\n    }\n  }\n} \n```", "```js\nimport { CheckUrls } from './checkUrls.js'\nasync function main () {\n  const checkUrls = new CheckUrls([\n    'https://nodejsdesignpatterns.com',\n    'https://example.com',\n    'https://mustbedownforsurehopefully.com'\n  ])\n  for await (const status of checkUrls) {\n    console.log(status)\n  }\n}\nmain() \n```", "```js\nasync function * generatorFunction() {\n  // ...generator body\n} \n```", "```js\nexport class CheckUrls {\n  constructor (urls) {\n    this.urls = urls\n  }\n  async * [Symbol.asyncIterator] () {\n    for (const url of this.urls) {\n      try {\n        const checkResult = await superagent\n          .head(url)\n          .redirects(2)\n        yield `${url} is up, status: ${checkResult.status}`\n      } catch (err) {\n        yield `${url} is down, error: ${err.message}`\n      }\n    }\n  }\n} \n```", "```js\nimport split from 'split2'\nasync function main () {\n  const stream = process.stdin.pipe(split())\n  for await (const line of stream) {\n    console.log(`You wrote: ${line}`)\n  }\n}\nmain() \n```", "```js\nfor await (const record of db.queryStream(sql`SELECT * FROM my_table`)) {\n  // do something with record\n} \n```", "```js\nfunction (req, res, next) { ... } \n```", "```js\nexport class ZmqMiddlewareManager {\n  constructor (socket) {                                     // (1)\n    this.socket = socket\n    this.inboundMiddleware = []\n    this.outboundMiddleware = []\n    this.handleIncomingMessages()\n      .catch(err => console.error(err))\n  }\n  async handleIncomingMessages () {                          // (2)\n    for await (const [message] of this.socket) {\n      await this\n        .executeMiddleware(this.inboundMiddleware, message)\n        .catch(err => {\n          console.error('Error while processing the message', err)\n        })\n    }\n  }\n  async send (message) {                                     // (3)\n    const finalMessage = await this\n      .executeMiddleware(this.outboundMiddleware, message)\n    return this.socket.send(finalMessage)\n  }\n  use (middleware) {                                         // (4)\n    if (middleware.inbound) {\n      this.inboundMiddleware.push(middleware.inbound)\n    }\n    if (middleware.outbound) {\n      this.outboundMiddleware.unshift(middleware.outbound)\n    }\n  }\n  async executeMiddleware (middlewares, initialMessage) {    // (5)\n    let message = initialMessage\n    for await (const middlewareFunc of middlewares) {\n      message = await middlewareFunc.call(this, message)\n    }\n    return message\n  }\n} \n```", "```js\nexport const jsonMiddleware = function () {\n  return {\n    inbound (message) {\n      return JSON.parse(message.toString())\n    },\n    outbound (message) {\n      return Buffer.from(JSON.stringify(message))\n    }\n  }\n} \n```", "```js\nimport { inflateRaw, deflateRaw } from 'zlib'\nimport { promisify } from 'util'\nconst inflateRawAsync = promisify(inflateRaw)\nconst deflateRawAsync = promisify(deflateRaw)\nexport const zlibMiddleware = function () {\n  return {\n    inbound (message) {\n      return inflateRawAsync(Buffer.from(message))\n    },\n    outbound (message) {\n      return deflateRawAsync(message)\n    }\n  }\n} \n```", "```js\nimport zeromq from 'zeromq'                                  // (1)\nimport { ZmqMiddlewareManager } from './zmqMiddlewareManager.js'\nimport { jsonMiddleware } from './jsonMiddleware.js'\nimport { zlibMiddleware } from './zlibMiddleware.js'\nasync function main () {\n  const socket = new zeromq.Reply()                          // (2)\n  await socket.bind('tcp://127.0.0.1:5000')\n  const zmqm = new ZmqMiddlewareManager(socket)              // (3)\n  zmqm.use(zlibMiddleware())\n  zmqm.use(jsonMiddleware())\n  zmqm.use({                                                 // (4)\n    async inbound (message) {\n      console.log('Received', message)\n      if (message.action === 'ping') {\n        await this.send({ action: 'pong', echo: message.echo })\n      }\n      return message\n    }\n  })\n  console.log('Server started')\n}\nmain() \n```", "```js\nimport zeromq from 'zeromq'\nimport { ZmqMiddlewareManager } from './zmqMiddlewareManager.js'\nimport { jsonMiddleware } from './jsonMiddleware.js'\nimport { zlibMiddleware } from './zlibMiddleware.js'\nasync function main () {\n  const socket = new zeromq.Request()                      // (1)\n  await socket.connect('tcp://127.0.0.1:5000')\n  const zmqm = new ZmqMiddlewareManager(socket)\n  zmqm.use(zlibMiddleware())\n  zmqm.use(jsonMiddleware())\n  zmqm.use({\n    inbound (message) {\n      console.log('Echoed back', message)\n      return message\n    }\n  })\n  setInterval(() => {                                      // (2)\n    zmqm.send({ action: 'ping', echo: Date.now() })\n      .catch(err => console.error(err))\n  }, 1000)\n  console.log('Client connected')\n}\nmain() \n```", "```js\nnode server.js \n```", "```js\nnode client.js \n```", "```js\nfunction createTask(target, ...args) {\n  return () => {\n    target(...args)\n  }\n} \n```", "```js\nconst task = target.bind(null, ...args) \n```", "```js\nconst statusUpdates = new Map()\n// The Target\nexport const statusUpdateService = {\n  postUpdate (status) {\n    const id = Math.floor(Math.random() * 1000000)\n    statusUpdates.set(id, status)\n    console.log(`Status posted: ${status}`)\n    return id\n  },\n  destroyUpdate (id) => {\n    statusUpdates.delete(id)\n    console.log(`Status removed: ${id}`)\n  }\n} \n```", "```js\nexport function createPostStatusCmd (service, status) {\n  let postId = null\n  // The Command\n  return {\n    run () {\n      postId = service.postUpdate(status)\n    },\n    undo () {\n      if (postId) {\n        service.destroyUpdate(postId)\n        postId = null\n      }\n    },\n    serialize () {\n      return { type: 'status', action: 'post', status: status }\n    }\n  }\n} \n```", "```js\nimport superagent from 'superagent'\n// The Invoker\nexport class Invoker {\n  constructor () {\n    this.history = []\n  }\n  run (cmd) {\n    this.history.push(cmd)\n    cmd.run()\n    console.log('Command executed', cmd.serialize())\n  }\n  // ...rest of the class \n```", "```js\ndelay (cmd, delay) {\n  setTimeout(() => {\n    console.log('Executing delayed command', cmd.serialize())\n    this.run(cmd)\n  }, delay)\n} \n```", "```js\nundo () {\n  const cmd = this.history.pop()\n  cmd.undo()\n  console.log('Command undone', cmd.serialize())\n} \n```", "```js\nasync runRemotely (cmd) {\n  await superagent\n    .post('http://localhost:3000/cmd')\n    .send({ json: cmd.serialize() })\n  console.log('Command executed remotely', cmd.serialize())\n} \n```", "```js\nimport { createPostStatusCmd } from './createPostStatusCmd.js'\nimport { statusUpdateService } from './statusUpdateService.js'\nimport { Invoker } from './invoker.js'\nconst invoker = new Invoker() \n```", "```js\nconst command = createPostStatusCmd(statusUpdateService, 'HI!') \n```", "```js\ninvoker.run(command) \n```", "```js\ninvoker.undo() \n```", "```js\ninvoker.delay(command, 1000 * 3) \n```", "```js\ninvoker.runRemotely(command) \n```"]