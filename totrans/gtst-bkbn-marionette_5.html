<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Divide and Conquer – Modularizing Everything</h1></div></div></div><p>After explaining in detail in <a class="link" href="ch04.html" title="Chapter 4. Managing Views">Chapter 4</a>, <em>Managing Views</em>, how to implement regions in <code class="literal">Marionette.js</code> to manage your views, it is time to understand how to deal with complex JavaScript projects and learn how to create a framework that would be extensible in subapplications and should require minimal effort to scale.</p><p>The following list contains the main topics that we will cover in this chapter and that we should consider while building modular and scalable single-page apps using <code class="literal">Marionette.js</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Divide and conquer</li><li class="listitem" style="list-style-type: disc">Modules</li><li class="listitem" style="list-style-type: disc">Subapplications</li><li class="listitem" style="list-style-type: disc">Memory management</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Applying the divide and conquer principle</h1></div></div></div><p>Complexity is the<a id="id110" class="indexterm"/> enemy of software, and building complex JavaScript applications can easily get out of hand. There are multiple ways to deal with complexity, but the most effective method is by using the principle of divide and conquer.</p><p>Directly through its module definition, <code class="literal">Marionette.js</code> <a id="id111" class="indexterm"/>allows us to split our code into smaller and more single responsibility blocks. If we do not break our code into smaller pieces, we will slow down development and make our application difficult to maintain. The easiest starting point to structure the code is the <code class="literal">Marionette.Application</code>. The application's primary responsibility is to start and stop subapplications and, if necessary, mediate cross subapplication communication. The following image shows how we can start from the application object to modularize our solution in subapplications and modules:</p><div><img src="img/4252OS_05_01.jpg" alt="Applying the divide and conquer principle"/></div><p>For the<a id="id112" class="indexterm"/> <strong>Single-page application</strong> (<strong>SPA</strong>) example that we are building, we probably will not need a lot of <a id="id113" class="indexterm"/>subapplications right from the beginning. But it is really important to know how to use this powerful feature that helps to break up an app into smaller and single responsibility units. The subapplication modules are independent parts of our app and they can consist of routers, controllers, models, layouts, and views.</p><p>All modules can be loaded on demand, so they do not need to be created from the beginning. For example, we can start them when the subapplication route matches specific patterns.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Modularizing single-page applications</h1></div></div></div><p>Designing a base <a id="id114" class="indexterm"/>architecture for single-page apps is not trivial. SPAs are opposite to traditional web apps that often have full-page reloads. They are dynamic page applications running in one page and usually, require spending some time on designing foundations. They are designed more like desktop apps since we store the application state in the client, but managing it quickly becomes a problem. As we have learned from the divide and conquer principle, a problem can be divided in several parts, so that each part can be handled independently. Having said that, let's explore how we can implement an application that will load single responsibility<a id="id115" class="indexterm"/> subapplications on demand, each of them has the ability to stop and start modules.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Getting started with modules</h1></div></div></div><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p>"Beauty of style and harmony and grace and good rhythm depends on simplicity."</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">-- Plato</td></tr></table></div><p>By understanding the concept of divide and conquer, we should agree that the modularization of code is tremendously important. Modules are small, simple, and well-encapsulated packages that have a singular focus with well-defined functions; they can be used in conjunction with other modules to create an entire system. In <code class="literal">Marionette.js</code>, a module provides a high-level piece of functionality and manages objects that really provide implementation details.</p><p>Let's define a <a id="id116" class="indexterm"/>module with no functionality to continue with the examples from the book store, where we will create the module that will contain the cart and order history subapplications:</p><div><pre class="programlisting">var MyApp = new Backbone.Marionette.Application();
var myModule = MyApp.module("MyModule");</pre></div><p>The modules of <code class="literal">Marionette.js</code> are loaded and defined after the <code class="literal">app.start()</code> call and they are fully instantiated objects. As you can see, Marionette's modules hang from our application. Let's now define a real-world module definition:</p><div><pre class="programlisting">Books.module('HistoryApp', {
  startWithParent: false,
  define: 
  function (HistoryApp, App, Backbone, Marionette,$, _) {

  }
});</pre></div><p>The following is an explanation of the previous code snippet:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Books</code>: This is the main application object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HistoryApp</code>: This is the name module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">startWithParent</code>: This should be false if we wish to manually start a module instead of having the application start it. We have to tell the module definition not to start with the parent, and that is exactly our scenario since we do not want to start all the subapplications from the beginning. This concept will be explained in detail when we get into the <em>Working with</em> <em>subapplications</em> section of this chapter.</li></ul></div><p>An explanation of the function arguments is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App</code>: This is the application central object that manage the module life cycle</li><li class="listitem" style="list-style-type: disc"><code class="literal">Backbone</code>: This is the reference to the <code class="literal">Backbone</code> library</li><li class="listitem" style="list-style-type: disc"><code class="literal">Marionette</code>: This is the reference to the <code class="literal">Backbone.Marionette</code> library</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: This is the reference to the DOM library, jQuery in this case</li><li class="listitem" style="list-style-type: disc"><code class="literal">_</code>: This is a reference to underscore</li></ul></div><p>In addition to<a id="id117" class="indexterm"/> the arguments explained, you can pass custom arguments to this function definition. Now we have a very simple module ready to encapsulate some of the functionality required.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Splitting modules into multiple files</h1></div></div></div><p>Sometimes a module is so<a id="id118" class="indexterm"/> long for a single file that we want to split <a id="id119" class="indexterm"/>the definition across multiple files. But it is pretty common for the subapplication modules to contain controllers, routers, and views, among others, so we do not want to put them all together in a file. This is made really simple by <code class="literal">Marionette.js</code> modules, so let's take a look.</p><p>The following is an example code from a controller file:</p><div><pre class="programlisting">Books.module('HistoryApp', function (HistoryApp, App) {    
    HistoryApp.Controller = Marionette.Controller.extend({

    });
});</pre></div><p>An example code from a router file is as follows:</p><div><pre class="programlisting">Books.module('HistoryApp', {
    startWithParent: false,
    define: 
  function (HistoryApp, App, Backbone, Marionette, $, _) {
    var Router = Backbone.Router.extend({

    });
  }
});</pre></div><p>We have created two files, one for the controller and other for the router, both of them are contained in the same module HistoryApp but located in separated files.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Implementing initializers and finalizers</h1></div></div></div><p>Modules have <a id="id120" class="indexterm"/>initializers and finalizers<a id="id121" class="indexterm"/> similar to application objects. Initializers are run when the module is started and finalizers are run when a module is stopped.</p><p>Let's add an<a id="id122" class="indexterm"/> initializer and a<a id="id123" class="indexterm"/> finalizer to our existing module:</p><div><pre class="programlisting">Books.module('HistoryApp', function (HistoryApp, App) {
    'use strict';

    HistoryApp.Controller = Marionette.Controller.extend({

});
   
    HistoryApp.addInitializer(function (args) {
        HistoryApp.controller = new HistoryApp.Controller();
    });

    HistoryApp.addFinalizer(function () {
        if (HistoryApp.controller) {
            HistoryApp.controller.close();
            delete HistoryApp.controller;
        }
    });

});</pre></div><p>This example shows how we can create definitions inside a module. We added a controller in this case, without actually creating any objects—just the definition—and then we let the initializer start creating the objects and set them up when the module is loaded.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Working with subapplications</h1></div></div></div><p>Our book's sample app<a id="id124" class="indexterm"/> is a single application that can contains several smaller applications, for example, shopping cart and order history. Each of them are independent but managed by the same application and are able to interact with other modules if necessary. The next diagram describes the concept of two subapplications being managed by a central application.</p><div><img src="img/4252OS_05_02.jpg" alt="Working with subapplications"/></div><p>Each <a id="id125" class="indexterm"/>subapplication is usually related with a screen from the SPA. They are responsible for doing what is required for screen changes using a controller that starts and stops modules and deals with their communication. They also manage the layout manipulating regions to display or hide views. Take a look at the code related to the diagram.</p><p>Let's now explore how to define two subapplications, each of them is also located in different file as we just learned in the previous section.</p><p>The following is our first application:</p><div><pre class="programlisting">Books.module('HistoryApp', function (HistoryApp, App) {
    'use strict';

    HistoryApp.Controller = Marionette.Controller.extend({

    });
});</pre></div><p>Our second application is as follows:</p><div><pre class="programlisting">Books.module('CartApp', function (CartApp, App) {
    'use strict';

    CartApp.Controller = Marionette.Controller.extend({

    });
});</pre></div><p>These applications are managed by the central application (<code class="literal">App</code>) that is passed as a parameter. Both the modules contain a controller definition as an example.</p><p>The next code<a id="id126" class="indexterm"/> snippet demonstrates how the main application is capable of starting and stopping subapplications:</p><div><pre class="programlisting">Books = (function (Backbone, Marionette) {
    'use strict';

    var App = new Marionette.Application();
  
    App.on('initialize:after', function () {
        if (Backbone.history) {
            Backbone.history.start();
        }
    });

    App.startSubApp = function (appName, args) {
        var currentApp = App.module(appName);
        if (App.currentApp === currentApp) { return; }

        if (App.currentApp) {
            App.currentApp.stop();
        }

        App.currentApp = currentApp;
        currentApp.start(args);
    };

    return App;

})(Backbone, Backbone.Marionette); </pre></div><p>As we can see, the main application is defined in a self-invoking function. It runs automatically/immediately when we create it, and note that calling the function returns the main <code class="literal">App</code> object.</p><p>The function <code class="literal">startSubApp</code> <a id="id127" class="indexterm"/>is what provides the ability to start and stop a module. This function will be called probably when the user clicks on the button to open the history or when a user navigates directly to this specific route. The next step is to understand how to call this function.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Using the route filter</h1></div></div></div><p>We have understood <a id="id128" class="indexterm"/>how to divide the application into subapplications; however, we still need to decide when and how we will tell the main application that we need to start a specific subapplication. To accomplish that, each module should be associated with a specific router that needs to be active from the beginning. This is different from modules that can be lazy loaded when a route matches. The creator of <code class="literal">Marionette.js</code> solves this scenario perfectly with his <code class="literal">BBCloneMail</code> example app that we mentioned before. For that purpose, he included a library called <code class="literal">routefilter.js</code>. As with any other library, this library is installed by adding the path reference in our project.</p><p>Route filter <a id="id129" class="indexterm"/>can be found at <a class="ulink" href="https://github.com/boazsender/backbone.routefilter">https://github.com/boazsender/backbone.routefilter</a>.</p><p>Usually, when we use SPA composed by subapplications, just one subapp is active at the same time, and our example application is not the exception. It is important to mention this in order to understand the next code.</p><p>The following code is for the <code class="literal">cart</code> router:</p><div><pre class="programlisting">Books.module('CartApp', {
    startWithParent: false,

    define: function (CartApp, App, Backbone, Marionette, $, _) {
        'use strict';

        var Router = Backbone.Router.extend({
            routes: {
                   "(:category)(/:id)": "init"
            },
            
            before: function () {
                App.startSubApp('CartApp');
            },

            init: function (category,id) {
                //call cart app controller function
            }
        });

        App.addInitializer(function () {
            var router = new Router();
        });
    }
});</pre></div><p>As we mentioned before, each subapplication generally has a router associated with it. This router will be the point of entrance for that application and will be responsible to lazy load it.</p><p>Let's explain <a id="id130" class="indexterm"/>what the pieces of the code means. Here, <code class="literal">before</code> is a function that is defined with the magic of <code class="literal">routefilter.js</code>. This function is executed before any function that maps the particular route. What it means is that the router will know when we are trying to access the specific subapplication and will start it by calling the function that we visited before, which is located at the main application (<code class="literal">App.startSubApp('CartApp')</code>). Other pieces that we are already familiar with are the module initializer and the route definition.</p><p>So, what if we want to start the history application now? Easy, just create a router associated with that subapplication, define that router, and we are done.</p><p>The following code puts this concept into practice:</p><div><pre class="programlisting">Books.module('HistoryApp', {
    startWithParent: false,


    define: 
      function (HistoryApp, App, Backbone, Marionette, $, _) {
        'use strict';

        var Router = Backbone.Router.extend({
            routes: {
                "history/orders": "showHistory",
            },
            before: function () {
                App.startSubApp('HistoryApp');
            },

            showHistory: function () {
                // call history app controller
            }
        });

        App.addInitializer(function () {
            var router = new Router();
        });
    }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Memory considerations</h1></div></div></div><p>One of the major challenges in single-page applications<a id="id131" class="indexterm"/> is to <a id="id132" class="indexterm"/>eliminate the memory leaks. The main problem is that we never do full-page reloads to flush the memory. So, applications need to handle closing subapplications when a new one is put in place to simulate a page load, thus unbinding all the events and objects associated with it.</p><p>But, we can still mess up the memory with zombies if we do not clean up references correctly. So like the main application, all subapplications should close old views and this is where Marionette's Region comes in to play. This especially ensures the unbinding of all the events when an object is disposed or when we switch viewsin a region.</p><p>In the case of subapplications, there are multiple ways to clean up the memory. To illustrate this, let's revisit some lines of code from the <em>Working with subapplications</em> section. This function is designed to stop and start subapplications as needed. We are using this technique to have just one subapplication running at the same time; once a subapplication is stopped, all its objects and events are disposed.</p><div><pre class="programlisting">    App.startSubApp = function (appName, args) {
        var currentApp = App.module(appName);
        if (App.currentApp === currentApp) { return; }

        if (App.currentApp) {
            App.currentApp.stop();
        }
        App.currentApp = currentApp;
        currentApp.start(args);
    };</pre></div><p>In our example, if the application was stopped, the router provides the functionality to call this function to start the subapplication again, if required. The next code is from the <em>Using the route filter</em> section of this chapter.</p><div><pre class="programlisting">    before: function () {
      App.startSubApp('HistoryApp')
    },</pre></div><p>As an important note, we need to develop discipline to remember that every time we create objects, we should be writing the proper code to remove them, always taking advantage of the <code class="literal">Marionette.js</code> capabilities.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Summary</h1></div></div></div><p>By far, the main problem that we have in creating a software is complexity. An easy starting point for a model view structure is provided by<code class="literal"> Backbone.js</code>, but it offers mainly low-level patterns. In the case of a more complex application, we can take advantage of some other frameworks to provide the missing parts on top of <code class="literal">Backbone.js</code>. For each part of your system, find a way to solve it and combine the solutions of the parts to obtain the solution of the original problem. Always strive for readability and maintainability when you implement your modules, and try to encapsulate behavior and not just state code with no reason.</p><p>Modules address the larger scale needs for encapsulation, while controllers, views, routers, and regions address the more detailed aspects of the matter.</p><p>Divide and conquer is a principle that has been used for years and is one of the most useful concepts when dealing with large and complex system structures. Keep up with all the best practices that we have learned and try to make them an integral part of your applications. The next step is to learn about messaging with <code class="literal">Marionette.js</code>.</p></div></body></html>