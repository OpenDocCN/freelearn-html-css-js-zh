<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Components and Templates</h1>
                
            
            
                
<p>Welcome to the second part of this book and congratulations for coming here! Now that you know the basic principles and techniques of programming in JavaScript, it's time to go deeper and know much better about some advantages offered by the wonderful framework that is Aurelia. Our starting point in this chapter will be to understand what is a component and how we can manage its life cycle through events that are taking place in our application. Then, we will explore the dependencies injection, a well-known design pattern used by most popular frameworks such as Java EE, Spring, and Aurelia! Our main focus will be to explain how we can manage our DOM and dynamically display the data on the screen, configure routes to access certain functionalities in our application, and, of course, apply everything learned in our FIFA World Cup application. This chapter will cover a lot of very useful concepts, some of them are:</p>
<ul>
<li>Creating components</li>
<li>Dependency Injection pattern</li>
<li>Component's life cycle/events</li>
<li>Data binding</li>
<li>Aurelia router</li>
<li>Testing components</li>
</ul>
<p>Let's start!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lego components</h1>
                
            
            
                
<p>Most modern frontend JavaScript frameworks provide some sort of support for component-based development. This is an incredibly important step in the direction of development for the web. Components provide a way to write small parts with a consistent API that can easily be orchestrated as part of a larger screen, application, or system. Imagine each component as a Lego piece—you can use it wherever you want and it will keep the same shape and behavior.</p>
<p>A component can be an HTML part, a JavaScript piece of code, a service, and so on. Any reusable part should be interpreted as a component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A little puzzle</h1>
                
            
            
                
<p>Let's practice a little how to think and abstract one application into a few components. Here's some web template with some sections:</p>
<div><img src="img/4c5b48a6-3104-4d9c-bf72-3d6f4ef7a209.png" style="width:52.17em;height:30.58em;"/></div>
<p>Now, it's time to think.</p>
<p>How many sections are similar?</p>
<ul>
<li>Buttons are very similar; just the text/color can change</li>
<li>Menu options can be a reusable single component</li>
<li>Main page sections are the same; just the content changes</li>
<li>The header can be decoupled from the application main section</li>
</ul>
<p>Which sections do you think can be reused across application pages, take a look:</p>
<ul>
<li>Main page sections can be used as a container for other options</li>
<li>The buttons can be shared across all the application sections</li>
</ul>
<p>Last, but not the least, do you think you need to refresh the entire page when you submit or just some sections?</p>
<p>A better option can be to refresh only what really needs to be refreshed. Each section can independently manage their data and the way it's retrieved.</p>
<p>Of course, all these answers depend on the business rules of the application, but the principles are always the same. If you find some section of your application that can be reused, reloaded, managed, and maintained independently of other sections, you should decouple it into a single component.</p>
<p>Once you have defined what parts of your application will be a component, it's time to organize. You must identify which components will be used just for some page in particular (maybe an Item component for a shopping cart page), how many of them will be shared across the entire application (a common table to be used into many reports of your application) and finally, organize them by separated groups:</p>
<div><img src="img/8e1fbeed-1565-415e-8367-1a8cac8ca853.png" style="width:28.58em;height:11.08em;"/></div>
<p>Now, let's create one folder per component; you should keep in mind that if some component will be <em>parent</em> of another component, the <em>child</em> folder should be created inside the parent, to specify ownership. Remember always that as a programmer, your main goal is to make your code readable and understandable to other developers—that's a good quality measure!</p>
<div><img src="img/383cf5cc-e2e5-4d1b-af94-55706141dcb4.png" style="width:41.67em;height:31.08em;"/></div>
<p>At this point, we now have our folder structure created for our components. An Aurelia component is basically composed of two files: the HTML template, called <strong>view</strong>, is rendered into the DOM. The <kbd>.js</kbd> file, called <strong>view model</strong>, is written in ES Next, and it defines the behavior and provides data for the view. The templating engine, along with <strong>dependency injection</strong> (<strong>DI</strong>), that we will explain in detail in the following sections, is responsible for creating and enforcing a predictable life cycle for the component. Once the component is instantiated, Aurelia’s data binding links the two pieces together, allowing changes in your view model to be reflected in the view and vice versa. This separation of concerns allows us to work/collaborate with designers and improve our product quality. Let's create one component as an example:</p>
<pre>/**card-component.js**/<br/><br/>export class CardComponent {<br/><br/>  cardTitle;<br/><br/>  constructor(){<br/>    this.cardTitle = 'Card component example'<br/>  }<br/><br/>}<br/><br/><br/>&lt;!--card-component.html--&gt;<br/><br/>&lt;template&gt;<br/>  &lt;div class="card" &gt;<br/><br/>    &lt;div class="card-header"&gt;<br/>      &lt;h2&gt;${cardTitle}&lt;/h2&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="card-body"&gt;<br/>    &lt;/div&gt;<br/><br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>You should remember some good practices about naming your components:</p>
<ul>
<li>Use dashes for naming your components. For example, <kbd>&lt;my-component&gt;</kbd> and <kbd>&lt;my-other-component&gt;</kbd> are valid name syntax, while <kbd>&lt;my_component&gt;</kbd> , <kbd>&lt;myComponent&gt;</kbd> and <kbd>&lt;my_other_component&gt;</kbd> are not. You must keep this notation, because the HTML parser will differentiate between custom and regular elements.</li>
<li>You can't register an already existing tag.</li>
<li>Custom elements are not self-closing. Only native HTML attributes allows this feature. Ensure that you write a closing tag (<kbd>&lt;my-component&gt;&lt;/my-component&gt;</kbd>).</li>
</ul>
<p>Our first component is created, hard coded, and works. Wait a second… how does the <kbd>.html</kbd> template know that my <kbd>.js</kbd> file is correct for retrieving data? Aurelia works under one premise: convention over configuration. What does that mean? If we use the same name for both files, the framework automatically will map that JavaScript file managing the <kbd>.html</kbd> template, we do not write any configuration code (different from other frameworks). Now, it’s time to integrate it into our main page.</p>
<p>We just need to import the filename with the <kbd>&lt;require&gt;</kbd> tag. For other reasons, this tag will be in the top section of the page. Then, we just call the component:</p>
<pre>&lt;!--main-template.html--&gt;<br/><br/>&lt;template&gt;<br/> &lt;require from="./components/card-component"&gt;&lt;/require&gt; //Remember to add the close tag<br/><br/> &lt;div class="main-content"&gt;<br/>     &lt;card-component&gt;&lt;/card-component&gt;<br/> &lt;/div&gt;<br/> <br/>&lt;/template&gt;</pre>
<p>Launch your application, and you will see your component in action. In this case, we just defined one single property to be rendered from the <kbd>.js</kbd> file to our template. This is a very basic example, so don’t worry, the action is coming!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Learning how DI works</h1>
                
            
            
                
<p>DI is based on the Inversion of control pattern. Let’s explain that.</p>
<p>Imagine that we create a web application without Aurelia. You will have to manually implement something like this:</p>
<ol>
<li>Load/instantiate a view model</li>
<li>Load/instantiate a view</li>
<li>Bind the view to the view model</li>
<li>Append the view to the DOM</li>
<li>Handle click on a link by user.</li>
<li>Parse the URL hash, determine which view model to load/instantiate, check whether the current view can be deactivated, and more</li>
<li>Rinse and repeat</li>
</ol>
<p>Again, and many more times.  Without Aurelia, you are implementing the logic that controls the application life cycle instead of your application business logic and features.</p>
<p>Now, let's create one using Aurelia. You won't work on any configuration code at the application level because the framework does that job for you. Instead, you focus on writing the views, view models, behaviors, and routes that embody your application's custom logic and appearance. Aurelia inverts the control, handling the application life cycle while allowing you to define your own features and behavior of the application. How? Through life cycle hooks.</p>
<p>Life cycle hooks are optional methods you attach to view models. Aurelia's router and the templating engine will invoke these methods at the appropriate time, allowing you to control specific life cycle steps.</p>
<p>We will explore all these methods deeper in the following sections; at the moment, we will focus only on <strong>Inversion of Control</strong> (<strong>IoC</strong>) and DI features.</p>
<p>Aurelia uses the IoC pattern to reduce the work required to build applications. You can specify and control them however you want using overridable conventions and hooks when the application starts/ends.</p>
<p>DI uses the same pattern for resolving dependencies. A dependency is an object that can be used, or more specifically, a service. Using this pattern, you made that service a part of the state of the client object, because you are passing that entire service rather than allowing the client to build or find the service.</p>
<p>DI needs an injector. This injector is responsible to provide and construct the service object and define that inside the client's state. The client is not allowed to directly call the injector code. It only waits until all its dependencies are satisfied.</p>
<p>Two modules are the key enablers for the DI pattern's application in Aurelia:</p>
<ul>
<li><strong>dependency</strong>-<strong>injection</strong>: An extensible and very lightweight DI container for JavaScript</li>
<li><strong>metadata</strong>: Provides a consistent way of accessing type, annotation, and origin metadata across a number of languages and formats</li>
</ul>
<p>To illustrate how the DI works, let's define a typical view model class with some external services injected. The code should be something like this:</p>
<pre>import CustomerService from './services/customer-service'<br/><br/>@inject(CustomerService)<br/>export class CustomerComponent {<br/><br/>  constructor(customerService){<br/>    this.customerService = customerService<br/>  }<br/><br/>}</pre>
<p>Now, let's analyze that code. How is this view model created at runtime?</p>
<p>Aurelia takes care of the creation order of each element, but how does it work? Well, first of all, Aurelia uses the DI container to instantiate all view models. As we said earlier, the client object doesn’t instantiate or locate their own dependencies. They rely on Aurelia to supply the dependencies as constructor arguments.</p>
<p>How are these dependencies discovered?</p>
<p>In an object oriented language (such as Java), the DI container can identify each dependency by its type. In the case of Aurelia, the dependencies, implementations are determined using the constructor arguments order list. In JavaScript, we can store a variety of information about our components or application as metadata. We don't have the chance to define a type-based constructor to define our objects. To deal with this situation, we must embed this information on the class itself, as <em>metadata</em>.</p>
<p>We can use decorators to add a customized constructor signature to our classes, based on types to be consumed by the Aurelia's DI container. This is exactly what the annotation <kbd>@inject</kbd> (<kbd>CustomerService</kbd>) performs in the view model file. If you are a TypeScript user, you can use the <kbd>emitDecoratorMetadata</kbd> flag, used for the same purpose of adding a constructor info to our classes. Just add the <kbd>@autoInject()</kbd> decorator to your class; in this case, the constructor parameter types are not needed.</p>
<p>View models written in this way are easy to test and modularize. You can split a big class into small components and inject them to achieve the goal. Remember that large classes are hard to maintain and are very vulnerable to rely on the anti-pattern <em>spaghetti code</em>.</p>
<p>Dependency resolution is a recursive process. Let's explain that—our customer view model has a dependency on the <kbd>CustomerService</kbd> file. When the DI container instantiates the <kbd>CustomerComponent</kbd> class, it first needs to retrieve the <kbd>CustomerService</kbd> instance or instantiate one if it doesn't already exist in the container. The <kbd>CustomerService</kbd> may have dependencies of its own, which the DI container will recursively resolve until the full dependency chain has been identified.</p>
<p>You can have as many injected dependencies as you need. Simply ensure that the inject decorator and the constructor match one another.</p>
<p>In case you are not using Babel or TypeScript decorator support, you can provide the inject metadata using a static method in your class:</p>
<pre>import {CustomerService} from 'backend/customer-service';<br/>import {CommonAlerts} from 'resources/dialogs/common-dialogs';<br/>import {EventAggregator} from 'aurelia-event-aggregator';<br/><br/>export class CustomerProfileScreen {<br/><br/>  static inject() { return [CustomerService, CommonAlerts, EventAggregator]; }<br/><br/>  constructor(customerService, alerts, ea) {<br/>    this.customerService = customerService;<br/>    this.alerts = alerts;<br/>    this.ea = ea;<br/>  }<br/><br/>}</pre>
<p>Static methods and properties are supported. The inject decorator simply sets the static property automatically. Why use it? Just to make our syntax more elegant and understandable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing a component's life cycle</h1>
                
            
            
                
<p>As we said earlier, Aurelia provides very complete life cycle event methods to customize and improve the behavior of our application. Here's a list with these methods:</p>
<pre>export class ComponentLifecycleExample {<br/><br/>  retrievedData;<br/><br/>  constructor(service) {<br/>    // Create and initialize your class object here...<br/>    this.service = service;<br/>  }<br/><br/>  created(owningView, myView) {<br/>    // Invoked once the component is created...<br/>  }<br/><br/>  bind(bindingContext, overrideContext) {<br/>    // Invoked once the databinding is activated...<br/>  }<br/><br/>  attached(argument) {<br/>    // Invoked once the component is attached to the DOM...<br/>    this.retrievedData = this.service.getData();<br/>  }<br/><br/>  detached(argument) {<br/>    // Invoked when component is detached from the dom<br/>    this.retrievedData = null;<br/>  }<br/><br/>  unbind(argument) {<br/>    // Invoked when component is unbound...<br/>  }<br/><br/>}</pre>
<p>Let's explore each method presented in the script:</p>
<p><strong><kbd>constructor()</kbd></strong>: This is the first method that is called. It's used to set all view model dependencies and values required for its instantiation.</p>
<p>The <kbd>constructor</kbd> method can be used for instantiating and initializing attributes to your component, and they should not necessarily be declared previously:</p>
<pre>constructor(){<br/>  this.customerName = 'Default name'<br/>  this.placeholderText = 'Insert customer name here'<br/>}</pre>
<p>Also, you can initialize variables using class methods:</p>
<pre>constructor(){<br/>  this.date = this.getCurrentDate()<br/>}<br/><br/>getCurrentDate(){<br/>  //Method implementation<br/>}</pre>
<p><kbd>created(owningView, myView)</kbd>: Next, the <kbd>created</kbd> method is called. At this point, the view has been created and belongs to the view model; they are connected to the controller. This callback will receive the view declared inside of the <kbd>(owningView)</kbd> component. If the component itself has a view, it is passed as second parameter, <kbd>(myView)</kbd>.</p>
<p><kbd>bind(bindingContext, overrideContext)</kbd>: At this point, the binding has started. If the view model has the <kbd>bind()</kbd> callback overridden, it will be called at this time. The first argument represents the binding context of the component. The second parameter is used for adding additional contextual properties.</p>
<p><kbd>attached()</kbd>: The <kbd>attached</kbd> callback is executed once the component is ready for use. It means instantiated and has its properties set and computed correctly.<br/></p>
<p>This method is perfect for retrieving data or set properties if you are using injected service methods. You can configure different ways to load your data, show loading alerts for the user, and increase the user experience. Let's see a quick example:</p>
<pre>export class ComponentExample {<br/><br/>  dataList<br/>  <br/>  constructor(){<br/>    // Constructor's code<br/>  }<br/>  <br/>  attached(){<br/>    this.showLoader(true);<br/>    this.service.retrieveAllData()<br/>                .then( data =&gt; {<br/>                   this.dataList = data.getBody()<br/>                   this.showLoader(false)<br/>                   this.showAlert('Data retrieved correctly!!!')<br/>                })<br/>                .catch( error =&gt; {<br/>                  console.log(error)<br/>                  this.showLoader(false)<br/>                  this.showAlert('Oops! We have some errors retrieving data!')<br/>                })<br/>    <br/>  }<br/>  <br/>}</pre>
<p>As you can see, we can define fallback alerts or methods to ensure that we are handling errors correctly (just if needed).</p>
<p><kbd>detached()</kbd>: Called when the component will be removed from the DOM. Different from the previous methods, this method is not executed when the application starts.<br/></p>
<p>The same as the previous example, we can define this method to restore the data to a previous state, delete local storage data, and so on.</p>
<p><kbd>unbind()</kbd>: Called when the component is unbound.</p>
<p>You should remember that each of these life cycle callbacks is optional. Just override what you really need. The execution order is the same as the list order mentioned earlier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing events with Aurelia</h1>
                
            
            
                
<p>We were explaining how to override and catch determined events and methods in the component life cycle, but what if we want to write our own methods and execute them when the user clicks on some button or moves the mouse for one section? We will start to <em>delegate</em> events.</p>
<p>The event delegation concept is a useful concept where the event handler is attached to one single element instead of multiple elements on the DOM. What implies that? Memory efficiency. It drastically reduces the number of event subscriptions by leveraging the <em>bubbling</em> characteristic of most DOM events.</p>
<p>On the other hand, we have the trigger concept. Similar, but not equal. You should use trigger binding when you need to subscribe to events that do not bubble (blur, focus, load, and unload).</p>
<p>Some examples are as listed:</p>
<ul>
<li>You need to disable a button, input, or another element</li>
<li>The element's content is made up of other elements (reusable component)</li>
</ul>
<p>In code words, it can be explained like this:</p>
<pre>&lt;select change.delegate="myEventCallback($event)" &gt;&lt;/select&gt;</pre>
<p>In your view model, you should have the method implemented with the correct number of params, so each time the <kbd>&lt;select&gt;</kbd> element changes, the event will be delegated to your custom function to handle it:</p>
<pre>export class TriggerAndDelegateExample {<br/><br/>  myEventCallback(event){<br/>    console.log(event)<br/>  }<br/><br/>}</pre>
<p>Now, let's <kbd>trigger</kbd> the same method:</p>
<pre>&lt;div class="option-container" focus.trigger="myEventCallback($event)"&gt;&lt;/div&gt;</pre>
<p>Note that we are using <kbd>trigger</kbd> binding to catch a not bubbling event.</p>
<p>In your daily work, maybe <kbd>delegate</kbd> and <kbd>trigger</kbd> could be enough for managing events, but there are some situations where you will need to know a little more advanced features to deal with it. Imagine that you are integrating a third-party plugin and need to interact with this content. Normally, <kbd>trigger</kbd> or <kbd>delegate</kbd> should do the work, but this won't be the case.</p>
<p>Let's look at an example:</p>
<pre class="language-markup">&lt;div class='my-plugin-container' click.delegate='onClickPluginContainer()'&gt;
      &lt;plugin-element&gt;&lt;/plugin-element&gt;
&lt;/div&gt;</pre>
<p>But why? Remember that you are dealing with a third-party plugin, so this will manage its events independently of the <kbd>container</kbd> component. That being said, the inner plugin will call <kbd>event.stopPropagation()</kbd> on any click events.</p>
<p>So what can we do in that case? Don't worry, you have another option—the <kbd>capture</kbd> command:</p>
<pre>&lt;div class='my-plugin-container' click.capture='onClickPluginContainer()'&gt;<br/>  &lt;plugin-element&gt;&lt;/plugin-element&gt;<br/>&lt;/div&gt;</pre>
<p>Now, the method will be executed correctly. Again, the most important question, why? It's because with the <kbd>capture</kbd> command, the <kbd>onClickPluginContainer()</kbd> event is guaranteed to happen irrespective of whether <kbd>event.stopPropagation()</kbd> is called or not inside the container.</p>
<p>Now, at this point, maybe you are wondering "So...what command should I use? Which of these is better?" The answer is simple—it depends on what you need. We recommend that you use <kbd>delegate</kbd>, because you will improve your application performance. Then, use <kbd>trigger</kbd> only if the event requires this, and finally, use <kbd>capture</kbd> if you will deal with third-party plugins or elements that you can't control, but remember that this last one is not commonly used and is not how you should normally work with browser events.</p>
<p>You can find more info about delegate and trigger in the official docs: <a href="https://aurelia.io/docs/binding/delegate-vs-trigger/">https://aurelia.io/docs/binding/delegate-vs-trigger/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data binding</h1>
                
            
            
                
<p>Aurelia has its own data binding system. Let's explain that with an example.</p>
<p>You know that you need to define a view and a view model file for each Aurelia component. Binding is the process that reflects the view model data into the view, and vice versa. As we said earlier, one of Aurelia's most beautiful features is double-binding framework, so you won't have to worry about updating the data on the view or view model.</p>
<p>Aurelia supports HTML and SVG attributes to JavaScript expressions. The binding attribute declaration is composed of three parts:</p>
<pre>attribute.commamnd = "expression"</pre>
<p class="mce-root">Let's explain each one:</p>
<p><kbd>attribute</kbd>: Refers to the HTML/SVG attribute we will apply to the binding. For example, one input tag could have defined the following attributes:</p>
<pre>&lt;input  value="someValue" id="inputId"  /&gt;</pre>
<p><kbd>value</kbd> and <kbd>id</kbd> will be the attributes we could refer.</p>
<p><kbd>command</kbd>: Here, you will use one of Aurelia's binding commands:</p>
<ul>
<li><strong>one</strong>-<strong>time</strong>: Flows data to one direction, from view model to view, just once.</li>
<li><strong>to</strong>-<strong>view </strong>/ <strong>one</strong>-<strong>way</strong>: Flows data in one direction, from view model to view.</li>
<li><strong>from</strong>-<strong>view:</strong> Flows data in one direction, from view to view model.</li>
<li><strong>two</strong>-<strong>way</strong>: Default behavior, flows data from view model to view and vice versa.</li>
<li><strong>bind</strong>: Automatically chooses the binding mode. It uses two-way binding for form controls and to-view binding for almost everything else.</li>
</ul>
<p>Let's use the same input element defined earlier as an example:</p>
<pre>&lt;input  value.from-view="userInputValue" id.bind="editableId"  /&gt;<br/>&lt;input  value.one-time="defaultInputValue" id.one-way="generatedId"  /&gt;</pre>
<p>The first <kbd>input</kbd> element uses the <kbd>from-view</kbd> command to bind anything the user writes in the <kbd>input</kbd> element, but this value cannot be changed and reflected from the <kbd>view-model</kbd> into the <kbd>view</kbd>. The <kbd>id</kbd> attribute uses the <kbd>two-way</kbd> binding, so this <kbd>id</kbd> can be updated in the view layer and reflected in the view model. The second binds the <kbd>value</kbd> attribute just once, then any update to this value will be ignored. In the case of the <kbd>id</kbd> attribute, it is generated by the <kbd>view-model</kbd> file, and any modification from <kbd>view</kbd> won't be reflected on <kbd>view-model</kbd>.</p>
<p><kbd>expression</kbd>: The last part. Commonly a JavaScript expression used to reflect <kbd>view-model</kbd> attributes, computed properties, and so on. Again, let's use the same <kbd>input</kbd> element for example purposes:</p>
<pre>&lt;input  value.from-view="modelValue" id.bind="formName + randomNumber"  /&gt;</pre>
<p>The <kbd>value</kbd> attribute just reflects the <strong><kbd>modelValue</kbd></strong> property into the view. The <kbd>id</kbd> attribute is performing an operation to attach a random number generated in the view model into one predefined property and use it as a single value to bind.</p>
<p>The same way that as event managing part, there could be some situations that you will need to use a little more advanced features to get the expected results. Commonly, you may deal with situations where you have <kbd>@bindable</kbd> properties while developing custom elements/attributes. These properties expect a reference to a function, so just use the <kbd>call</kbd> binding command to declare and pass a function to the bindable property. The <kbd>call</kbd> command is superior to the <kbd>bind</kbd> command for this use case, because it will execute the function in the correct context, ensuring that this is what you expect it to be:</p>
<pre class="language-markup">  &lt;custom-element go.call="doSomething()"&gt;&lt;/custom-element&gt;<br/></pre>
<p><kbd>go</kbd> is the <kbd>@bindable</kbd> attribute, and <kbd>doSomething()</kbd> is your <kbd>view-model</kbd> function.</p>
<p>One more feature you can add to your application is string interpolation. These expressions enable interpolating the result of an expression with text. The best way to demonstrate this capability is with an example. Here are two <kbd>span</kbd> elements with data-bound <kbd>textcontent</kbd>:</p>
<pre class="language-markup">    &lt;span textcontent.bind="'Hello' + name"&gt;&lt;/span&gt;

    &lt;span&gt;Hello ${name}&lt;/span&gt;</pre>
<p>At this point, we know the basic concepts about Aurelia's binding engine. Now, let's use this great feature in more advanced ways to improve our application!</p>
<p>We have explored in <a href="" target="_blank">Chapter 2</a>, <em>Styling the User Interface</em>, some ways to add CSS to our application and make it look great. However, in your daily work, you can find some common situation that will make you 'mix' some features.</p>
<p>Here's one:</p>
<p>You are writing a dashboard page and depending on user status (active, inactive), the Submit button should look colorful or just disabled with a different shape.</p>
<p>You can bind an element's <kbd>class</kbd> attribute using string interpolation or with <kbd>.bind/.one-time</kbd>:</p>
<pre>&lt;template&gt;<br/>  &lt;button class="btn ${isActive ? 'btn-active' : 'blocked-btn'} submit"&gt;&lt;/button&gt;<br/>  &lt;button class.bind="isActive ? 'btn-active' : 'blocked-btn'"&gt;&lt;/button&gt;<br/>  &lt;button class.one-time="isActive ? 'btn-active' : 'blocked-btn'"&gt;&lt;/button&gt;<br/>&lt;/template&gt;</pre>
<p>Using ternary operations, you can say to your view which class should be rendered into the view. Let's analyze the first:</p>
<ul>
<li><kbd>isActive</kbd> refers to a boolean property defined in view model.</li>
<li><kbd>?</kbd> is the ternary operator. If the condition is <kbd>true</kbd>, the first argument will be used, in this case, the <kbd>'btn-active'</kbd> class.</li>
<li><kbd>:</kbd> represents the <kbd>else</kbd> element of the condition. If it's evaluated to false, the second argument after the <kbd>:</kbd> will be used.</li>
</ul>
<p>Aurelia allows you to use external JavaScript libraries. It supports, on its binding system, only adding or removing the specified classes in the binding expression.</p>
<p>In this way, classes added by other code (for example, <kbd>classList.add(...)</kbd>) are not removed. This behavior implies a small cost, noticeable only in benchmarks or some critical situations like iteration of large lists. Replace the default behavior by binding directly to the element's <kbd>className</kbd> property using <kbd>class-name.bind="...."</kbd>, or <kbd>class-name.one-time="..."</kbd> can be a better option; so much faster.</p>
<p>Similar to classes, you can bind style attributes directly into the DOM. Remember that defining styles directly into the element is not wrong, but using classes, you can add more standardization to your elements and make this easy to maintain. Like other HTML attributes, you can use <kbd>style.bind</kbd> to retrieve <kbd>style</kbd> definitions from your <kbd>view-model</kbd>.</p>
<p>For example, let's define one array of styles:</p>
<pre>export class StyleExample {<br/>  constructor() {<br/>    this.styleAsString = 'color: red; background-color: blue';<br/><br/>    this.styleAsObject = {<br/>      color: 'red',<br/>      'background-color': 'blue'<br/>    };<br/>  }<br/>}</pre>
<p>Then, in the <kbd>view</kbd> file, we just need to bind the predefined properties:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;div style.bind="styleAsString"&gt;&lt;/div&gt;
      &lt;div style.bind="styleAsObject"&gt;&lt;/div&gt;
&lt;/template&gt;</pre>
<p>You can use string interpolation too:</p>
<pre class="language-markup">&lt;div style="width: ${width}px; height: ${height}px;"&gt;&lt;/div&gt;</pre>
<p>However, if you need to add compatibility with Internet Explorer and Edge, this syntax will be illegal. In those cases, you must use the <kbd>css</kbd> attribute:</p>
<pre class="language-markup">&lt;div css="width: ${width}px; height: ${height}px;"&gt;&lt;/div&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding computed properties</h1>
                
            
            
                
<p>Sometimes it is desirable to return a dynamically computed value (post-processed value) when accessing a property, or you may want to reflect the status of an internal variable without requiring the use of explicit method calls. In JavaScript, this can be accomplished with the use of a getter function:</p>
<pre>export class Developer {<br/>  firstName = 'Erikson';<br/>  lastName = 'Murrugarra';<br/><br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</pre>
<p>There's no trick here, you just need to bind the <kbd>fullName</kbd> property. The binding system will analyze the property and how we are referring to a function; it will process the required info before rendering the computed value. This is also called <strong>dirty checking</strong>; it will be constantly observing if some property changes its value, and if it has some repercussions on the computed element, it will be re-evaluated and reprocessed. Sounds like a multiple execution of the same method? Yes, your getter function will be called so many times, approximately once every 120 milliseconds. That's not an issue, but if we have a lot of computed properties or if our getter functions are a little complex, you should consider indicating to the binding systems which properties you want to observe; at this point, dirty checking is avoided. This is where the <kbd>@computedFrom</kbd> decorator comes in:</p>
<pre>import {computedFrom} from 'aurelia-framework';<br/><br/>export class Developer {<br/>  firstName = 'Erikson';<br/>  lastName = 'Murrugarra';<br/><br/>  @computedFrom('firstName', 'lastName')<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</pre>
<p><kbd>@computedFrom</kbd> will tell the binding system which properties need to be observed. When those expressions change, the binding system will reevaluate the property (execute the getter). This eliminates the need for dirty checking and can improve performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Value converters</h1>
                
            
            
                
<p>As we explained before coming across this topic, user interface elements in Aurelia are composed of two files: view and view model pairs. The view is written in pure HTML and is rendered into the DOM. The view model is written in JavaScript and provides data and behavior to the view. Aurelia links the two files together, as one single element using its powerful data binding engine, allowing changes in your view model to be reflected in the view and vice versa. Sometimes the data showed by your view model is not in a good or understandable format for displaying in the UI. Dealing with date and numeric values are the most common scenarios:</p>
<pre>export class Example {<br/>  <br/>  constructor() {<br/>    this.showRawData();<br/>  }<br/><br/>  showRawData() {<br/>    this.currentDate = new Date(); <br/>    this.someNumber = Math.random() * 1000000000;<br/>  }<br/>  <br/>}</pre>
<p>Our view should look like this:</p>
<pre class="language-markup">&lt;template&gt;
      ${currentDate} &lt;br/&gt;
      ${someNumber}
&lt;/template&gt;</pre>
<p>This code will give us the current date and some random number; well, that's what we are expecting and that's okay, but let's see how this data is displayed:</p>
<pre>Sun Dec 31 2017 18:04:45 GMT-0500 (-05)<br/>936693540.3380567</pre>
<p>That's definitely not friendly for user reading. A cool solution to this problem can be to compute the formatted values and expose them as properties of the <kbd>view-model</kbd> file. This is a valid approach, but remember that we are overloading our model with extra properties and methods; it can be a little messy in the future, especially when you need to keep the formatted values in sync when the original property value change. Fortunately, Aurelia has a feature to help us deal with these situations.</p>
<p>The most common option will be to create value converters to translate the model data into a readable format for the view. All okay at this point, but what happens if it is the view that needs to convert the value for sending it into a format acceptable for the <kbd>view-model</kbd>?</p>
<p>Aurelia value converters are quite similar to other value converters of another languages, such as XAML. The nice thing is that Aurelia comes with some notable improvements:</p>
<ul>
<li>The Aurelia <kbd>ValueConverter</kbd> interface uses two methods: <kbd>toView</kbd> and <kbd>fromView</kbd>. These methods define the direction the data is flowing in.</li>
<li>Aurelia value converter methods can accept multiple parameters.</li>
<li>Aurelia allows you to use multiple value converters in one single property, just using pipes (<kbd>|</kbd>).</li>
</ul>
<p>Let's look at an example to convert our date property into a more friendly readable value:</p>
<pre>import moment from 'moment';<br/><br/>export class DateFormatValueConverter {<br/><br/>  toView(value) {<br/>    return moment(value).format('M/D/YYYY h:mm:ss a');<br/>  }<br/><br/>}</pre>
<p>Our <kbd>view-model</kbd> file won't change:</p>
<pre>export class Example {<br/>  <br/>  constructor() {<br/>    this.showRawData();<br/>  }<br/><br/>  showRawData() {<br/>    this.currentDate = new Date(); <br/>    this.someNumber = Math.random() * 1000000000;<br/>  }<br/>  <br/>}</pre>
<p>However, our <kbd>view-model</kbd> file will look quite different at this time:</p>
<pre class="language-markup">&lt;template&gt;<br/>    &lt;require from="./date-format"&gt;&lt;/require&gt;<br/>    ${currentDate | dateFormat} &lt;br/&gt; <br/>    ${someNumber} <br/>&lt;/template&gt;</pre>
<p>With this value converter, we'll see this value on the screen:</p>
<pre>12/31/2017 6:25:05 pm</pre>
<p>This looks much better. Again, it's time to ask the more important question—why? Let's examine what we did. First, we created our value converter class called <kbd>DateFormatValueConverter</kbd> and implemented the <kbd>toView</kbd> method. Aurelia will execute this method and apply to the model values before displaying the data on screen. For converting purposes, we are using MomentJS. Next, we've updated the <kbd>view</kbd> file and added <kbd>&lt;require&gt;</kbd> tags to import our value converter class into the view that will use it.</p>
<p>When the framework processes the resource, it examines the class's metadata to determine the resource type (custom element, custom attribute, value converter, and such). Metadata isn't required, and in fact, our value converters didn't expose any. If you are curious, you must note something—we used the <kbd>ValueConverter</kbd> postfix to name our converter class. Again, why? It's because you must remember that one of the Aurelia bases is convention over configuration. In this way, the name ending with <kbd>ValueConverter</kbd> will be assumed to be one value converter.</p>
<p>Now we will show you a little more advanced example. Let's apply some changes to our class converter:</p>
<pre>import moment from 'moment';<br/><br/>export class DateFormatValueConverter {<br/>  <br/>  toView(value, format) {<br/>    return moment(value).format(format);<br/>  }<br/><br/>}</pre>
<p>The <kbd>view-model</kbd> file is still the same. Now, our template file will change again:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;require from="./date-format"&gt;&lt;/require&gt;

      ${currentDate | dateFormat:'M/D/YYYY h:mm:ss a'} &lt;br/&gt;
      ${currentDate | dateFormat:'MMMM Mo YYYY'} &lt;br/&gt;
      ${currentDate | dateFormat:'h:mm:ss a'} &lt;br/&gt;<br/>&lt;/template&gt;</pre>
<p>Now we can use the same value converter class to render data in different formats, according to our view demands.</p>
<p>Without any doubt, we have covered some of the most important features of Aurelia's binding behavior, but, for sure, there are more methods and commands that we will see in practice. For the moment, we are ready to pass to another important concept—routing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Routing and resources</h1>
                
            
            
                
<p>Routing is one of the most important parts of a web application. We already have our application deployed in <kbd>http://localhost:9000</kbd>, but it's time to start defining names and addresses for our resources. First, we need to define what a resource is. Conceptually, a resource is every related data belonging to one single object or element. For example, a person resource can have fields such as name, address, birthday, and more. So, expanding this, a resource can be a list of persons too. We will talk deeply about how your resources should be named, organized, and called, but at this moment, you just need to know the basics. In a web application, every resource has its own address. Let's look at an example:</p>
<p>We have an address book with some contacts:</p>
<ul>
<li><kbd>http://localhost:9000/</kbd> is the server URL, the base of all resources, the father path. Generally related to the home/welcome page, or first you define the user's view. The page has a button to see all our contacts.</li>
<li><kbd>http://locahost:9000/persons</kbd> is a URL related to the person list resource. Here, we will show a list of persons of our address book. You are able to pick one to see its contact details.</li>
<li><kbd>http://locahost:9000/persons/p001</kbd> will refer to the person with the <kbd>p001</kbd> ID. Here, we will be able to see its details. If you give this URL to another user, they should be able to see the same data as you, because this URL belongs to one single contact—the <kbd>p001</kbd>.</li>
<li><kbd>http://locahost:9000/persons?search=p001</kbd> is a little different. Imagine that our contact list is composed of more than 500 people. Don't you think it could be easier for the user search them by ID, name, or the most generic parameter? Here, we are using a query-param to express our search criteria; of course, we're still working with our friend <kbd>p001</kbd>.</li>
</ul>
<p>Now, let's configure our application to be ready for routing.</p>
<p>At this point, we have already created some components in our application. If not, don't worry, we will have enough time to practice that in the last part of this chapter.</p>
<p>Now, let's add some code to our <kbd>app.js</kbd> file. Remember that this file should be located in the base <kbd>src</kbd> folder of our application, since now it will represent our base route for all the applications:</p>
<pre>export class App {<br/>  configureRouter(config, router) {<br/>    this.router = router;<br/>    config.title = 'Aurelia';<br/>    config.map([<br/>      { route: ['', 'home'],       name: 'home',       moduleId: 'home/index' },<br/>      { route: 'users',            name: 'users',      moduleId: 'users/index', nav: true,           title: 'Users' },<br/>      { route: 'users/:id/detail', name: 'userDetail', moduleId: 'users/detail' },<br/>      { route: 'files/*path',      name: 'files',      moduleId: 'files/index', nav: false,    title: 'Files', href:'#files' }<br/>    ]);<br/>  }<br/>}</pre>
<p>Let's analyze the properties and methods used to define our routes:</p>
<ul>
<li><kbd>configureRouter(config, router)</kbd> is a reserved method that the framework will evaluate in the base <kbd>view-model</kbd> when the application starts. The parameters are referencing to the <kbd>Router</kbd>, <kbd>RouterConfiguration</kbd> from <kbd>aurelia-router</kbd> package. If they are not provided, the framework will inject them automatically.</li>
<li><kbd>this.router = router</kbd> is a reference to the router element, just to allow us to access this from the view layer (<kbd>app.html</kbd>), allowing us to build navigation menus dynamically.</li>
<li><kbd>config.title</kbd> refers to our application title displayed in the browser window. Technically, it's applied to the <kbd>&lt;title&gt;</kbd> element in the <kbd>&lt;head&gt;</kbd> of the HTML document.</li>
<li><kbd>config.map()</kbd> adds route(s) to the router. Although only <kbd>route</kbd>, <kbd>name</kbd>, <kbd>moduleId</kbd>, <kbd>href</kbd>, and <kbd>nav</kbd> were shown earlier, there are other properties that can be included in a <kbd>route</kbd>. The interface name for a <kbd>route</kbd> is <kbd>RouteConfig</kbd>. You can also use <kbd>config.mapRoute()</kbd> to add a single <kbd>route</kbd>.</li>
<li><kbd>route</kbd> is the pattern to match against the incoming URL fragments. It can be a string or array of strings. The <kbd>route</kbd> can contain parameterized routes or wildcards as well.</li>
</ul>
<p>Now, let's analyze the routes we've created:</p>
<ul>
<li>In the first <kbd>route</kbd> element, the first flag, <kbd>route</kbd>, is making reference to the base path (<kbd>''</kbd>) and the <kbd>home</kbd> path. If we directly access <kbd>http//:localhost:9000/</kbd> or <kbd>http//:localhost:9000/home</kbd>, the application will display the same page. The <kbd>name</kbd> flag is the URL identifier to call directly from one link or <kbd>href</kbd> element. Finally, we need to reference which file we are referencing with the <kbd>route</kbd>; in this case, the component is located in <kbd>home/index</kbd> and will be represented inside the <kbd>moduleId</kbd> flag.</li>
<li>The second URL is referencing to the <kbd>users</kbd> resource, but it has some variations. The <kbd>nav</kbd> flag can be a Boolean or number property. When set to true, the route will be included in the router's navigation model. When specified as a number, the value will be used in sorting the routes; this makes it easier to create a dynamic menu or similar elements. Finally, the <kbd>title</kbd> flag will show the page title appended to the page title in the browser window.</li>
<li>The third is a little different. We can see a weird param in the middle of the route, the <kbd>:id</kbd>. This means that this part of the URL signature will be dynamic, do you remember our person <kbd>p001</kbd>? The <kbd>:id</kbd> parameter will be used to represent the <kbd>p001</kbd> code and make the URL unique for this resource. Also, in the <kbd>view-model</kbd> file, we will be able to consume that parameter and retrieve some data related to it.</li>
<li>Lastly, we are seeing <kbd>'files/*path'</kbd>. Wildcard routes are used to match the <em>rest</em> of a path. The <kbd>href</kbd> flag is a conditionally optional property. If it is not defined, <kbd>route</kbd> is used. If <kbd>route</kbd> has segments, <kbd>href</kbd> is required as in the case of files, because the router does not know how to fill out the parameterized portions of the pattern.</li>
</ul>
<p>There can be some situations where you will need some extra features to deal with them.</p>
<p>For example, case-sensitive routes; Aurelia has that problem solved too:</p>
<pre class="language-javascript">config.map([
          { route: ['', 'home'], name: 'home',  moduleId: 'home/index' },
          { route: 'users',      name: 'users', moduleId: 'users/index', nav: true, title: 'Users', caseSensitive: true }
]);</pre>
<p>The <kbd>caseSensitive</kbd> flag will be used in these cases.</p>
<p>Another situation, very common, can be the unknown routes; Aurelia has a nice way to deal with it:</p>
<pre class="language-typescript">config.map([
          { route: ['', 'home'], name: 'home',  moduleId: 'home/index' },
          { route: 'users',      name: 'users', moduleId: 'users/index', nav: true, title: 'Users' }
        ]);

config.mapUnknownRoutes('not-found');</pre>
<p>The <kbd>config.mapUnknownRoutes()</kbd> method will make a reference to the <kbd>'not-found'</kbd> component module. Another way is representing it as a function:</p>
<pre class="language-javascript">const handleUnknownRoutes = (instruction) =&gt; {
      return { route: 'not-found', moduleId: 'not-found' };
}

config.mapUnknownRoutes(handleUnknownRoutes);</pre>
<p>Other common scenario could be redirected routes. This is very simple—you just need to add the <kbd>redirect</kbd> flag and specify the reference to the module you want to show:</p>
<pre class="language-javascript">config.map([
      { route: '', redirect: 'home' },
      { route: 'home', name: 'home', moduleId: 'home/index' }
]);</pre>
<p>At this point, we know how to configure the routing at the <kbd>view-model</kbd> level, but what about the view? Don't worry, this will be our next topic.</p>
<p>All this configuration was performed in the <kbd>app.js</kbd> file, so now we need to go to our <kbd>app.html</kbd> file. You must consider some things before adding the routing property to your template.</p>
<p>Commonly, most web applications use a base layout. This can be composed by the header, a lateral menu, and the view content. That being said, the only element that should be refreshed and reloaded with the router is the view content; the header and the menu will always be the same for the entire application, so we need to define our router element inside that container; let's look at the code:</p>
<pre>&lt;template&gt;<br/>  &lt;div class="header"&gt;<br/>    &lt;header-component&gt;&lt;/header-component&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="menu"&gt;<br/>    &lt;menu-component&gt;&lt;/menu-component&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="main-content"&gt;<br/>    &lt;router-view&gt;&lt;/router-view&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>The <kbd>&lt;router-view&gt;&lt;/router-view&gt;</kbd> is the HTML flag that Aurelia router will use to render the components we've configured as routes. Graphically, the representation is as follows:</p>
<div><img src="img/96e2aed5-5449-4d52-9a56-1b09c80c7171.png" style="width:63.25em;height:38.50em;"/></div>
<p>At this point, everything is okay. However, this is a very basic approach; let's explore some advanced way to make our layout more flexible and configurable. We know that the <kbd>router-view</kbd> element defined in HTML is always associated with one or more views referenced in a router configuration method defined in its parent view's view model.</p>
<p>To specify a layout on the <kbd>router-view</kbd> HTML element, we use the following attributes:</p>
<ul>
<li><kbd>layout-view</kbd>: Specifies the layout view to use through the filename (with path)</li>
<li><kbd>layout-model</kbd>: Specifies the model parameter to pass to the activate function of view model</li>
<li><kbd>layout-view-model</kbd>: Specifies the <kbd>moduleId</kbd> to use with the layout view</li>
</ul>
<p>To explain that, we will implement a custom layout page totally decoupled from our <kbd>app.html</kbd> file:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;div&gt;
        &lt;router-view layout-view="layout.html"&gt;&lt;/router-view&gt;
      &lt;/div&gt;
&lt;/template&gt;</pre>
<p>We are referencing a file called <kbd>layout.html</kbd>. This file will contain our basic layout distribution:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;div class="left-content"&gt;
        &lt;slot name="left-content"&gt;&lt;/slot&gt;
      &lt;/div&gt;
      &lt;div class="right-content"&gt;
        &lt;slot name="right-content"&gt;&lt;/slot&gt;
      &lt;/div&gt;
&lt;/template&gt;</pre>
<p>Also, note the <kbd>&lt;slot&gt;</kbd> tag. This is a mechanism to associate parts of the layout to part of some view referencing its name; in this case, let's create a <kbd>home</kbd> component with custom layout:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;div slot="left-content"&gt;
        &lt;home-header&gt;&lt;/home-header&gt; <br/>      &lt;/div&gt; <br/>      &lt;div slot="right-content"&gt;<br/>         &lt;home-menu&gt;&lt;/home-menu&gt; <br/>      &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>Any content outside of the slot declared won't be rendered. We just have one more task to do—configure the router:</p>
<pre class="language-javascript">config.map([
          { route: '', name: 'home', moduleId: 'home' }
]);</pre>
<p>We just need to declare the route and reference it to the home module. The layout will <em>read</em> the slot tags defined inside and will render to the main template. In this way we can customize the layout according to the route we are accessing the application, one use case could have custom menu options while displaying some routes.</p>
<p>There is one more thing we need to cover to have our router ready for work—the fallback route. Imagine that your application is based on roles. If the user is not allowed to access some resource, he should be redirected to the previous location. What if there's no previous location? The fallback route comes to the rescue!</p>
<p>Let the code show the magic:</p>
<pre class="language-javascript">export class App {
      configureRouter(config, router) {
        this.router = router;
        config.title = 'Example';
        config.map([
          { route: ['', 'home'], name: 'home',  moduleId: 'home/index' },
          { route: 'users',      name: 'users', moduleId: 'users/index', nav: true, title: 'Users' }
        ]);

        config.fallbackRoute('users');
}</pre>
<p>Now you know the most important characteristics about Aurelia router and how to configure it to improve your application. We are almost ready to start creating components to our FIFA WC App. In the last chapter, we learned about testing, TDD, and debugging. Now, it's time to apply the learned concepts and test our components. Let's code!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing our components</h1>
                
            
            
                
<p>Testing is one of the most important steps when you develop software applications. At this point, we are ready to start creating components, defining binding behaviors, and configuring our routes. All is okay, but how do we ensure that our components work as expected? We need to test each component before marking it as complete and ready for QA/Production environment.</p>
<p>With Aurelia's component tester, you'll be able to test your component in an isolated way, like on a mini Aurelia application. What to do when testing a component? Evaluate the expected data, and assert a response to data binding and behavior through the life cycle.</p>
<p>First of all, we need to install the <kbd>aurelia-testing</kbd> package:</p>
<pre class="language-powershell"><strong> npm install aurelia-testing</strong></pre>
<p>This library is based on Jasmine, the popular BDD JavaScript testing framework that provides the test structure and assertions. If you generated your application with the Aurelia CLI, Jasmine should be included.</p>
<p>Once installed, you can start writing your first unit test. We are going to start with a simple component that returns the customer name.</p>
<p>First, let's define our <kbd>View</kbd> template:</p>
<pre class="language-markup">&lt;template&gt;
      &lt;div class="custName"&gt;${custName}&lt;/div&gt;
&lt;/template&gt;</pre>
<p>And in the <kbd>ViewModel</kbd> file:</p>
<pre class="language-javascript">import {bindable} from 'aurelia-framework';<br/>
    export class CustomerComponent {
      @bindable custName;
}</pre>
<p>Our component should work. Let's verify that. We need to create our test file:</p>
<pre>import {StageComponent} from 'aurelia-testing';<br/>import {bootstrap} from 'aurelia-bootstrapper';<br/><br/>describe('CustomerComponent', () =&gt; {<br/>  let component;<br/><br/>  beforeEach(() =&gt; {<br/>    component = StageComponent<br/>      .withResources('customer-component')<br/>      .inView('&lt;customer-component cust-name.bind="custName"&gt;&lt;/customer-component&gt;')<br/>      .boundTo({ custName: 'Diego' });<br/>  });<br/><br/>  it('should render first name', done =&gt; {<br/>    component.create(bootstrap).then(() =&gt; {<br/>      const nameElement = document.querySelector('.custName');<br/>      expect(nameElement.innerHTML).toBe('Diego');<br/>      done();<br/>    }).catch(e =&gt; { console.log(e.toString()) });<br/>  });<br/><br/>  afterEach(() =&gt; {<br/>    component.dispose();<br/>  });<br/>});</pre>
<p>Okay, that looks fine; it should pass. What are we doing?</p>
<p>First, we import the <kbd>StageComponent</kbd> from <kbd>aurelia-testing</kbd>:</p>
<pre class="language-javascript">import {StageComponent} from 'aurelia-testing';</pre>
<p>The <kbd>StageComponent</kbd> just creates a new instance of the <kbd>ComponentTester</kbd> class, which does all the work. Next, the <kbd>StageComponent</kbd> factory will stage the component:</p>
<pre class="language-javascript">    component = StageComponent
      .withResources('src/customer-component')
      .inView('&lt;customer-component cust-name.bind="custName"&gt;&lt;/customer-component&gt;')
      .boundTo({ custName: 'Diego' });</pre>
<p>The <kbd>StageComponent</kbd> has one property—<kbd>withResources()</kbd>—and it allows you to start off the staging with a fluent API. The class method <kbd>withResources</kbd> is very useful to specify which resource or resources you will use and register. If you need more than one single resource, just use an array of string to register all of them. Then, <kbd>inView</kbd> method allows us to provide the HTML code we need to run. This is a standard view where you can define properties and other stuff just like in our application's real components. Finally, <kbd>boundTo</kbd> method provides a test <kbd>viewModel</kbd> with the predefined data configured in <kbd>inView</kbd>.</p>
<p>In this first part, the staging is performed by Jasmine's <kbd>beforeEach()</kbd> method in order to reuse the same setup in case we have multiple tests:</p>
<pre>component.create(bootstrap).then(() =&gt; {<br/>      const nameElement = document.querySelector('.custName');<br/>      expect(nameElement.innerHTML).toBe('Diego');<br/>      done();<br/>    }).catch(e =&gt; { console.log(e.toString()) });</pre>
<p>Next, we enter the test itself, the <kbd>create()</kbd> method. Create will kick everything off and bootstrap the mini Aurelia application (it's receiving the <kbd>bootstrap</kbd> component imported from the <kbd>aurelia-bootstrapper</kbd> library imported earlier); this method will configure the test using <kbd>standardConfiguration</kbd>, register provided resources as global resources, start the application, and, finally, render your component so that you can assert the expected behavior. In this case, we want to ensure that our <kbd>custName</kbd> property gets rendered correctly in the HTML by selecting the div tag via its class name. We use <kbd>document.querySelector('.custName')</kbd> to get the element value and assert that its <kbd>innerHTML</kbd> is <kbd>Diego</kbd>. Next, we call Jasmine's <kbd>done</kbd> function to tell Jasmine that the test is complete. Calling done is needed since the create method is asynchronous and returns a <kbd>Promise</kbd>. If the test raises some error, the <kbd>catch()</kbd> method will be triggered and will print the error log in console:</p>
<pre>component.dispose();</pre>
<p>Finally, we call <kbd>dispose</kbd> on our <kbd>ComponentTester</kbd> instance. This will clean up the DOM so that our next test starts out with a clean document.</p>
<p>Our first test is complete and guess what...it passed! That was a very basic example, but we've learned the basic parts of a component test and how we can include it in our application. Now, let's explore more advanced features.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing component life cycle</h1>
                
            
            
                
<p>We need to ensure that our data is retrieved as expected, and the same way, we need to assert that our component behavior is going well too. To do this, we can tell the component we created that we will manually handle the life cycle methods; you will find the code very self-explanatory:</p>
<pre>import {StageComponent} from 'aurelia-testing';<br/>import {bootstrap} from 'aurelia-bootstrapper';<br/><br/>describe('CustomerComponent', () =&gt; {<br/>  let component;<br/><br/>  beforeEach(() =&gt; {<br/>    component = StageComponent<br/>      .withResources('src/customer-component')<br/>      .inView('&lt;customer-component cust-name.bind="custName"&gt;&lt;/customer-component&gt;')<br/>      .boundTo({ custName: 'Diego' });<br/>  });<br/><br/>  it('can manually handle life cycle', done =&gt; {<br/>    let nameElement;<br/><br/>    component.manuallyHandleLifecycle().create()<br/>      .then(() =&gt; {<br/>        nameElement = document.querySelector('.custName');<br/>        expect(nameElement.innerHTML).toBe(' ');<br/>      })<br/>      .then(() =&gt; component.bind())<br/>      .then(() =&gt; {<br/>        expect(nameElement.innerHTML).toBe('Foo bind');<br/>      })<br/>      .then(() =&gt; component.attached())<br/>      .then(() =&gt; {<br/>        expect(nameElement.innerHTML).toBe('Foo attached');<br/>      })<br/>      .then(() =&gt; component.detached())<br/>      .then(() =&gt; component.unbind())<br/>      .then(() =&gt; {<br/>        expect(component.viewModel.custName).toBe(null);<br/>      })<br/>      .then(() =&gt; component.bind({ custName: 'Bar' }))<br/>      .then(() =&gt; {<br/>        expect(nameElement.innerHTML).toBe('Bar bind');<br/>      })<br/>      .then(() =&gt; component.attached())<br/>      .then(() =&gt; {<br/>        expect(nameElement.innerHTML).toBe('Bar attached');<br/>      })<br/>      .then(done)<br/>      .catch(done);<br/>  });<br/><br/>  afterEach(() =&gt; {<br/>    component.dispose();<br/>  });<br/><br/>});</pre>
<p>The imported libraries still being the same, the <kbd>create()</kbd> method of our component element will bootstrap the application and provide us with an easy way to check for our life cycle method responses; just ensure that you call them in the order they are executed.</p>
<p>What about components depending on external services? Don't worry, you just need to add some extra lines to the test code and create a class "mocking" the service.</p>
<p>First, our Mock class:</p>
<pre class="language-javascript">export class MockService {
      firstName;

      getFirstName() { return Promise.resolve(this.firstName);
}</pre>
<p>Our test class will look like this:</p>
<pre class="language-javascript">describe('MyComponent', () =&gt; {
      let component;
      let service = new MockService(); //Our created Mock

      beforeEach(() =&gt; {
        service.firstName = undefined; 

        component = StageComponent
          .withResources('src/component')
          .inView('&lt;component&gt;&lt;/component&gt;');

        component.bootstrap(aurelia =&gt; {
          aurelia.use.standardConfiguration();
          aurelia.container.registerInstance(Service, service); //Register our mock service instance to the current container instance
        });
      });

      it('should render first name', done =&gt; {
        service.firstName = 'Diego';

        component.create(bootstrap).then(() =&gt; {
          const nameElement = document.querySelector('.first-name');
          expect(nameElement.innerHTML).toBe('Diego');

          done();
        });
      });

      afterEach(() =&gt; {
        component.dispose();
      });
});</pre>
<p>First of all, we are declaring our mock service as a global variable. This will be used for injecting it into Aurelia's container context; this way, the component won't detect any difference between the real service class and our mocked service. Another thing you should pay attention to is that at the <kbd>beforeEach()</kbd> method level, we are declaring the <kbd>firstName</kbd> property as <kbd>undefined</kbd>; this is just to make it reusable and customizable for each test depending on their own needs. Remember that this method is executed independently for each unit test.</p>
<p>What if I need to define a more complex view, evaluating containers for my component? Easy, you are allowed to use template literals:</p>
<pre>import {StageComponent} from 'aurelia-testing';<br/>import {bootstrap} from 'aurelia-bootstrapper';<br/><br/>describe('MyAttribute', () =&gt; {<br/>  let component;<br/><br/>  beforeEach(() =&gt; {<br/>    //Literal HTML syntax<br/>    let view = `<br/>          &lt;div class="row"&gt;<br/>            &lt;div class="col-xs-12"&gt;<br/>              &lt;div my-attribute.bind="color"&gt;Diego&lt;/div&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        `;<br/>    component = StageComponent<br/>      .withResources('src/my-attribute')<br/>      .inView(view)<br/>      .boundTo(viewModel);<br/>  });<br/>  //...<br/>});</pre>
<p>What do you think? It's easy right? That's good! Now, we are completely ready for the best part of this chapter; let's put everything in practice!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time to practice!</h1>
                
            
            
                
<p>It's time to start coding! At this point, we have our application created and running, preconfigured to use SASS as CSS preprocessor, and integrated with the Aurelia Materialize library to follow good design practices of Material Design. Now we need to define our layout. It will be very basic at this time and across the application growing, our developed components can be improved and refactorized.</p>
<p>First, we need to access our root folder application; once inside, we just need to type the following command:</p>
<pre><strong>au run --watch<br/></strong></pre>
<p>Next, we open our favorite browser's window, which should look something like this:</p>
<div><img src="img/2d6fae7e-14d3-4fc2-bc15-f9306dc51a56.png"/></div>
<p>Now, let's create our main layout. Inside the <kbd>src</kbd> folder, we will create a folder named layout. Inside this folder, to subfolders: header and menu:</p>
<ul>
<li><kbd>./src &gt; layout &gt; header &gt;</kbd>: Here, we will create an HTML file for view and JS file for view-model. Both files are called <kbd>app-header</kbd></li>
<li><kbd>./src &gt; layout &gt; menu &gt;</kbd>: Same way as the header, both files will be called <kbd>app-menu</kbd></li>
</ul>
<p>Our folder structure should look like this:</p>
<div><img src="img/94e94a9e-a44f-428e-b91c-b49a49001190.png" style="width:14.17em;height:16.33em;"/></div>
<p>First, we'll create the <kbd>app-header</kbd> component. Let's open the HTML file and create our <kbd>navbar</kbd> header. It's at this point that we will see the Aurelia Materialize features:</p>
<pre>&lt;template&gt;<br/>  &lt;md-navbar&gt;<br/>    &lt;div class="margin-content"&gt;<br/><br/>      &lt;ul class="hide-on-med-and-down right"&gt;<br/>        &lt;li md-waves&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li md-waves&gt;&lt;a href="#map"&gt;Login&lt;/a&gt;&lt;/li&gt;<br/>      &lt;/ul&gt;<br/><br/>    &lt;/div&gt;<br/>  &lt;/md-navbar&gt;<br/>&lt;/template&gt;</pre>
<p><kbd>&lt;md-navbar&gt;</kbd> tag refers to the <kbd>navbar</kbd> element of Aurelia Materialize. This is very helpful because the components are already created; we just need to call them and start defining how we want to show to our user. We won't create any CSS class at this point. Inside our <kbd>nav-bar</kbd>, we are creating two navigation options just to see how it looks on the browser.</p>
<p>With our first component created, it's time to integrate it with our main page, <kbd>app.html</kbd>. First, we need to call the created component using the <kbd>&lt;require&gt;</kbd> tag:</p>
<pre>&lt;require from="./layout/header/app-header"&gt;&lt;/require&gt;</pre>
<p>Then, we just need to call the created component by its filename:</p>
<pre>&lt;app-header&gt;&lt;/app-header&gt;</pre>
<p>Now just reload your browser's window and... an error is raised! What to do in that case? What happened? Our best friend, the console, will tell us the truth:</p>
<div><pre>DEBUG [templating] importing resources for app.html Array [ "materialize-css/css/materialize.css", "layout/header/app-header" ]<br/>vendor-bundle.js:14222:8 TypeError: target is undefined<a>[Learn More]</a></pre></div>
<p>Let's pay attention to the last parts of each line. First, the error occurred when the Aurelia bootstrapper was importing and configuring our created component. The last message tells us the error cause: <kbd>undefined</kbd> <kbd>target</kbd>.</p>
<p>Think for a few minutes, what could have happened? We know you have enough knowledge to tell us what the error was.</p>
<p>Ready? If you note, our recently created <kbd>view-model</kbd> file for <kbd>app-header.js</kbd> is completely empty. So we have the view, but that view is not pointing to anything, and the <kbd>target is undefined</kbd>! To solve this error, we just need to declare the component name and export it:</p>
<pre>export class AppHeader {<br/><br/>}</pre>
<p>Now, let's reload our browser:</p>
<div><img src="img/8fecd523-4b09-4e83-8131-e9c7ac4b3426.png" style="width:38.08em;height:10.67em;"/></div>
<p>Awesome, right? Relax, this is just the beginning. Now it's time to create our menu.</p>
<p>Our chosen Materialize component is the fixed <kbd>sidenav</kbd>. However, to integrate this into our application, we will merge some of the techniques and concepts learned until now. First, let's code our component:</p>
<pre>&lt;template&gt;<br/><br/>  &lt;md-sidenav view-model.ref="sideNav" md-fixed="true" md-edge="left"&gt;<br/>    &lt;ul&gt;<br/>      &lt;li md-waves&gt;&lt;a&gt;Option A&lt;/a&gt;&lt;/li&gt;<br/>      &lt;li md-waves&gt;&lt;a&gt;This is better&lt;/a&gt;&lt;/li&gt;<br/>      &lt;li md-waves&gt;&lt;a&gt;I want this&lt;/a&gt;&lt;/li&gt;<br/>      &lt;li md-waves&gt;&lt;a&gt;Oops!&lt;/a&gt;&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/md-sidenav&gt;<br/><br/>&lt;/template&gt;</pre>
<p>Similarly, using the <kbd>&lt;require&gt;</kbd> tag, we will import it into our <kbd>app.html</kbd> file. If we just call the <kbd>sidenav</kbd> menu, we will get the following result:</p>
<div><img src="img/79d28c18-8032-4bcf-84f5-bb225c6b3d78.png"/></div>
<p>Of course, we don't want to hide our main application content! It's time to start using CSS to make the <kbd>app-menu</kbd> play for our team.</p>
<p>First, let's add some container order to our app.html page. It should be something like this:</p>
<pre>&lt;template&gt;<br/>  &lt;require from="materialize-css/css/materialize.css"&gt;&lt;/require&gt;<br/>  &lt;require from="./layout/header/app-header"&gt;&lt;/require&gt;<br/>  &lt;require from="./layout/menu/app-menu"&gt;&lt;/require&gt;<br/><br/>  &lt;app-header&gt;&lt;/app-header&gt;<br/>  <br/>  &lt;main&gt;<br/><br/>    &lt;div class="row"&gt;<br/>      <br/>      &lt;div class="col s12 m12 l12"&gt;<br/>        &lt;h1&gt;${message}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>      <br/>    &lt;/div&gt;<br/><br/>    &lt;app-menu&gt;&lt;/app-menu&gt;<br/>    <br/>  &lt;/main&gt;<br/><br/>&lt;/template&gt;</pre>
<p>We are just involving our main content, in this case, the message property, into one container that fills the entire screen no matter the resolution.</p>
<p>If we run the application, we'll still be seeing the same result. We need to apply some custom CSS modifications to our sidenav component. It's time to start using SASS!</p>
<p>We have SASS on our dependencies path, and it's ready for use in our application, but let's add some modifications just to make our files distribution a little more understandable for us.</p>
<p>Go to the <kbd>aurelia_project</kbd> folder and open the task called <kbd>process-css.js</kbd>.</p>
<p>If you remember the Gulp task automation from the previous chapters, you'll find the code very familiar. We just need to add one single line:</p>
<pre>export default function processCSS() {<br/>  return gulp.src(project.cssProcessor.source)<br/>    .pipe(sourcemaps.init())<br/>    .pipe(sass().on('error', sass.logError))<br/>    .pipe(gulp.dest('./')) //THIS LINE<br/>    .pipe(build.bundle());<br/>}</pre>
<p>Why this line? We want to see the generated CSS file into our project and import it from our <kbd>index.html</kbd> file. Again, why? It's because using this file directly into your browser, your style modifications and debugging will be easier in case you need to modify or maintain the style sheets.</p>
<p>Then, let's create our <kbd>styles</kbd> folder. This should be located directly in our <kbd>src</kbd> folder. Could it be located in a different location? Sure, but we recommend that you first check your <kbd>aurelia.json</kbd> file.</p>
<p>If you search the <kbd>cssProcessor</kbd> task, you will find this:</p>
<pre>"cssProcessor": {<br/>  "id": "sass",<br/>  "displayName": "Sass",<br/>  "fileExtension": ".scss",<br/>  "source": "src/**/*.scss"<br/>},</pre>
<p>The source property is indicating the level at which our scss files will be located, and guess where they are by default? Yes, the <kbd>src/*whatever*/*.scss</kbd> location. You can modify it, but for our current purpose, we don't need to.</p>
<p>Then, inside our folder, let's create our first .<kbd>scss</kbd> file called <kbd>_mainlayout.scss</kbd>. Remember that the <kbd>_</kbd> prefix is to indicate that this style sheet will be used as part of another style sheet. We just need to add the following code:</p>
<pre><br/>header, main, footer {<br/>  padding-left: 300px;<br/>}<br/><br/>md-navbar[md-fixed="true"] nav {<br/>  padding-right: 300px;<br/>}<br/><br/>md-sidenav {<br/>  div {<br/>    collapsible-body {<br/>    }<br/>    padding: 0;<br/>  }<br/>}</pre>
<p>We are just telling our <kbd>header</kbd> and application main body to stay 300 px right from our app menu. Now, it's time to reload our browser:</p>
<div><img src="img/a9859fcc-dab2-481a-9ff5-7bca8e890f81.png"/></div>
<p>Our base layout is done! Guess what? Yeah, its time to add routing!</p>
<p>Let's decouple the welcome message of the <kbd>app.js</kbd> file. Create a home component to render a custom message; we called it <kbd>app-home</kbd>. Now, instead of the <kbd>&lt;h2&gt;</kbd> tag in your <kbd>app.html</kbd> file, put the <kbd>&lt;router-view&gt;</kbd> tag.</p>
<p>In the app <kbd>view-model</kbd> file, delete the <kbd>constructor</kbd> method; we won't use it this time. Then, just add the following code:</p>
<pre>configureRouter(config, router) {<br/>  this.router = router;<br/>  config.title = 'FIFA WC 2018';<br/>  config.map([<br/>    { route: ['', 'home'],       name: 'home',       moduleId: 'home/app-home' },<br/>  ]);<br/>}</pre>
<p>Now, let's reload our browser. Pay attention to the window title; it now reflects our application name!</p>
<div><img src="img/af791f7f-7765-4879-92f0-8d25501a93ec.png"/></div>
<p>For practice purposes, we are done by this time! If you note, we're mixing a lot of concerns in just some basic approaches to our application. Now, let's add the extra value to our code. Do you remember our hard-coded menu options? Don't you think it should be dynamic? Yes, we are talking about adding dynamic binding to our practice! What are you waiting for, open your <kbd>app-menu</kbd> view and <kbd>view-model</kbd>!</p>
<p>Let's create an array of string in the <kbd>view-model</kbd> layer. We will use the same options used in the image:</p>
<pre>export class AppMenu {<br/><br/>  menuOptions = [<br/>    'Option A',<br/>    'This is better',<br/>    'I want this',<br/>    'Oops!',<br/>  ]<br/><br/>}</pre>
<p class="mce-root">Next, the magic. The <kbd>repeat</kbd> command will do the dirty work for us. Okay, we know that we didn't mention it before; do you remember when we said we'll review a lot of new concerns when implementing a real application? This is one of those:</p>
<pre>&lt;template&gt;<br/><br/>  &lt;md-sidenav view-model.ref="sideNav" md-fixed="true" md-edge="left"&gt;<br/>    &lt;ul&gt;<br/><br/>      &lt;li repeat.for="option of menuOptions" md-waves&gt;&lt;a&gt;${option}&lt;/a&gt;&lt;/li&gt;<br/><br/>    &lt;/ul&gt;<br/>  &lt;/md-sidenav&gt;<br/><br/>&lt;/template&gt;</pre>
<p>That was very easy. Now we are really done. Our FIFA WC 2018 App is ready to start writing our business services and components! One more thing is pending and that's the tests part. We won't cover it in practice, because in the next chapter, we will find some more complex components created for our application, and we will be nice to apply testing to real-life components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Your knowledge about Aurelia at this moment is just amazing! We wanted to cover every aspect regarding component creation and how you can abstract your business scenario into one digital application. You learned that each component is part of an everything, is reusable, and allows you to separate your application concerns. Since a component is an isolated piece of your application, it manages his own life cycle; Aurelia allows us to have complete control and configure events such as data loading or some custom behavior when the components is destroyed. Another very interesting thing is that we can create our own events, and we can trigger them from the view layer.</p>
<p>Also, you must remember that one component can inherit from other components, and they all have properties. Remember that Aurelia is a double-way binding framework, so all these properties are synchronized between the view and view model files. We also learned how to implement value-converters and some other binding behavior to improve our application performance and reduce the amount of code, making our application more lightweight and maintainable. Once our components are created and we have our application scenarios, it's time to link all of them through dynamic routing, defining user workflows and passing dynamic properties to each template. Last but never least, we went through how to test our application components, ensuring their functionality and life cycle behavior.</p>
<p>You can start creating components and exploring the Aurelia Materialize's library to customize your application. In subsequent chapters, you will find our app very advanced, but don't worry, there won't be anything we haven't explained. Keep practicing!</p>


            

            
        
    </body></html>