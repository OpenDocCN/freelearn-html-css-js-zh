- en: Chapter 4. REST is Best – Interacting with the Server Side of Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of development work involved in creating a JavaScript single page
    application is generally going to be on the frontend, but not to be overlooked
    is the all-important data-transfer layer of your application, which communicates
    with the server and the database. **Representational State Transfer** (**REST**)
    is the standard architectural style of data transfer between client and server
    for the World Wide Web and the **Internet of Things** (**IoT**). Any time you
    use a web application, chances are that REST is being used to communicate data
    and transitions of state from the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of using the REST architectural style for a SPA is that the frontend
    of your application can be entirely agnostic of what type of software is being
    used to retrieve requests on your server, as long as your application can be used
    over **Hypertext Transfer Protocol** (**HTTP**), the standard application protocol
    for the World Wide Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental aspects of the REST architectural style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write basic REST API endpoints for performing CRUD operations in a single
    page web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with REST requests on your application frontend using AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of some alternatives to REST, such as SOAP, WebSockets, MQTT, CoAP,
    and DDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the fundamentals of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is the architectural style used to serve web pages and make requests on
    the World Wide Web, or simply the Web. Although the Internet and the Web are often
    referred to interchangeably, they differ in the fact that the Web is merely a
    *part* of the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The Web is a collection of documents, or *web pages*, which are served or hosted
    on computers all over the world and are connected via *hyperlinks*, or what are
    commonly referred to as links. These links are served over HTTP, the language
    of communication for the Web. REST is often confused with HTTP because of its
    mutual relationship with the Web, but HTTP and REST are far from the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an architectural style versus a protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is an architectural style, while HTTP is an application layer protocol.
    This means that while HTTP is the language of communication on the Web, REST is
    simply a set of rules for performing requests and operations on the Web. These
    operations performed through a REST architectural style are commonly referred
    to as *Web Services*. In this way, HTTP is simply the method of transport for
    the Web Services performed by an application using REST.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An architectural style, or architectural pattern, is a set of rules which provides
    developers with the ability to build abstraction layers as frameworks that are
    built to achieve a common language of interaction that is to ultimately be consumed
    by some type of client, or user agent. In the case of the Web, that user agent
    is a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: A web abstraction layer, or web framework, can be written in any number of languages
    to provide Web Services via REST, or RESTful services, as long as that language
    can be hosted on a web server. When that framework follows the REST architectural
    style, the UI for any application using it can be completely *agnostic*, or unbiased,
    as to the technology behind the RESTful service.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A protocol, as it relates to the Web, is part of an abstraction layer of the
    **Internet Protocol Suite**, or TCP/IP, providing a common method of communication
    between connected computers.
  prefs: []
  type: TYPE_NORMAL
- en: Transport layer protocols
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The term TCP/IP is a combination of the Internet Protocol Suite''s most widely
    used protocols: **Transmission Control Protocol** (**TCP**) and **Internet Protocol**
    (**IP**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP**'
  prefs: []
  type: TYPE_NORMAL
- en: TCP is a transport layer protocol, which lies underneath the application layer.
    This means that services and information are *transported* up to the top-level
    application layer of the Internet Protocol Suite.
  prefs: []
  type: TYPE_NORMAL
- en: '**IP**'
  prefs: []
  type: TYPE_NORMAL
- en: IP is also a transport layer protocol. You have most likely seen this protocol
    associated with the term IP address, or Internet Protocol address, which is a
    unique numerical identifier for a device on a network. On the Web, domain names
    are commonly used to point to an IP address to make it easier for people to remember
    how to reach that address.
  prefs: []
  type: TYPE_NORMAL
- en: Application layer protocols
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The application layer of TCP/IP is the abstraction layer that defines methods
    of communication between host computers that are connected through the Web. This
    layer specifies several protocols, with some of the most common being HTTP, FTP,
    SSH, and SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP**'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is the primary protocol for data exchange within the application layer
    of TCP/IP, and it provides the foundation of communication for RESTful web services.
    HTTP is also responsible for serving a web page for display within a browser,
    and for sending data from a form on a web page to a server.
  prefs: []
  type: TYPE_NORMAL
- en: '**FTP**'
  prefs: []
  type: TYPE_NORMAL
- en: The **File Transfer Protocol** (**FTP**), is another standard protocol within
    the TCP/IP application layer that is used for transferring files between computers.
    FTP communication requires an FTP server and an FTP client.
  prefs: []
  type: TYPE_NORMAL
- en: '**SSH**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Shell** (**SSH**) is another common protocol in the application layer
    which is used to allow secure remote logins to a non-secure network entry point.
    For SSH connections to work, a SSH server must be available to receive requests
    from a SSH client. A SSH client most often comes in the form of a terminal application
    with a **command line interface** (**CLI**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**SMTP**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**) is the standard method of sending
    e-mail, or electronic mail, in the application layer of TCP/IP. SMTP may also
    be used to receive e-mail and is typically used for this purpose by e-mail servers.
    SMTP is not typically used by user-level e-mail clients for receiving e-mail,
    however. Instead, these clients more commonly use POP3 or IMAP.'
  prefs: []
  type: TYPE_NORMAL
- en: POP3 is the third version of the **Post Office Protocol**, which is a standard
    application layer protocol for receiving e-mail over TCP/IP connections. POP3
    is generally used to download e-mail to a local computer and then delete it from
    the host server.
  prefs: []
  type: TYPE_NORMAL
- en: IMAP is the **Internet Message Access Protocol**. It is also a standard application
    layer protocol for receiving e-mail over TCP/IP connections. IMAP is generally
    used as way to manage a host server e-mail inbox by multiple clients, and therefore
    it does not delete the e-mail from the server after downloading it to a local
    computer like POP3\. The latest versions of IMAP also support tracking the state
    of an e-mail on the host server, such as read, replied to, or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP as a transfer protocol for REST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: REST defines a set of rules by which to make HTTP requests for a web application
    or service. HTTP requests can be made in any number of ways, but they are only
    RESTful if they follow that set of rules. HTTP provides the transport layer upon
    which those requests are made.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that a web application interacting with a REST API is agnostic
    of the type of software framework being used to serve the API endpoints, HTTP
    is agnostic of the types of operating systems being used across all of the servers
    which it communicates with.
  prefs: []
  type: TYPE_NORMAL
- en: The constraints of REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST architectural style is governed by a set of constraints, or rules,
    that dictate how it should be implemented, interacted with, and handle data. REST
    was first defined by the American computer scientist Roy Fielding in a doctoral
    dissertation in 2000, along with these constraints.
  prefs: []
  type: TYPE_NORMAL
- en: REST is considered to be a *hybrid* architectural style in that it borrows from
    other architectural styles that existed before its conception. These other architectural
    styles lend greatly to the REST constraints outlined here.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first constraint of REST is the client-server architectural style. This
    constraint exists to enforce the agnostic nature of REST, or the *separation of
    concerns* that is so fundamental to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-server](img/B05228_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows the client-server relationship, and how they are separated.
    The **client**, or web browser, needs only display the UI for an application.
    The UI can be as simple or as sophisticated as deemed necessary, without affecting
    the REST architecture on the server. This REST constraint provides for scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second constraint of REST builds upon the client-server constraint in that
    the communication between client and server must be stateless. This means that
    any request from a web browser to the REST server must supply all expected information
    needed for the context of the request and the current session in order to expect
    the appropriate response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will have no stored information to help delineate the request, thereby
    making the REST server *stateless* and putting the burden of session state on
    the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stateless](img/B05228_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts the client-stateless-server architectural style in which
    the web browser state can change and the REST server remains consistent. This
    REST constraint provides for visibility, reliability, and scalability, which are
    a few of the key benefits of using REST.
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third constraint of REST builds again upon the client-server and stateless
    constraints. A cache, or data stored for reuse, can be permitted for use by the
    browser for any given request based on the cacheability of that request as delegated
    by the REST server. If the server''s cache component indicates that a request
    is cacheable, then the browser can cache it for future requests. Cacheability
    is often indicated in the case where a request made multiple times to a particular
    REST endpoint will likely result in an identical response each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache](img/B05228_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts the client-cache-stateless-server architectural style.
    This style is just like client-stateless-server, but with the added component
    of a client cache.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fourth constraint of REST is the use of a uniform interface among components
    of the system. This refers to the simplistic nature of the architecture involved
    in a REST implementation in which the components are decoupled. This allows each
    component of the architecture to evolve on its own, without affecting the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uniform interface](img/B05228_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows the uniform-client-cache-stateless-server architectural style.
    This combines the three previous architectural style constraints with the added
    constraint of uniform interface.
  prefs: []
  type: TYPE_NORMAL
- en: The uniform interface constraint is further subdivided into four of its own
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Identification of resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A resource in REST is any conceptual mapping of information to a uniquely identifiable
    object. This object can be a person, place, or thing. An example of this in the
    case of the Web is a Uniform Resource Identifier (URI). More specifically, a Uniform
    Resource Locator (URL) is a special type of URI that provides a method to find
    a web resource and specifies how to obtain a representation of information from
    that resource. A URL is also commonly referred to as a web address. In relation
    to REST, a URL may also be referred to as an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulation of resources through representations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A representation in REST is a set of data which represents the current state
    of a resource. In a web architecture using REST, a JSON document can be used as
    a representation to pass between client and server, and manipulate or change a
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Self-descriptive messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Messages in REST are the communication between components. In keeping with the
    constraint for a REST server to be stateless, the messages must be self-descriptive,
    meaning it carries all the information necessary to tell each component how it
    should be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Hypermedia as the engine of application state
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hypermedia refers to web pages, or hypertext, and the hyperlinks that connect
    them. In order to remain stateless, a RESTful architecture uses hypermedia to
    convey the state of the application based on representations received from the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fifth constraint of REST is a layered system, which is a hierarchy of architectural
    components, where each layer provides services to the layer above it and uses
    the services from the layer below it. In this manner, each layer only has visibility
    into one layer below it, thus making it agnostic of any layers down.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is applied to distributed servers on the Web that are used to enhance
    the scalability of an application. For example, a web browser may communicate
    with any number of *intermediate* servers based on its location, but it is never
    aware of whether it is connected to the end server or one of those intermediate
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layered system is also used to implement load balancing across servers. This
    allows additional servers to take on requests when the primary server is inundated
    with too many requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layered system](img/B05228_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts a uniform-layered-client-cache-stateless-server. This architectural
    style combines the previous four with the added constraint of a layered system.
  prefs: []
  type: TYPE_NORMAL
- en: Code-on-demand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sixth and final constraint of REST is the **code-on-demand** architectural
    style, and it is the only *optional* constraint. In this style, the server provides
    a set of executable code encapsulated in some form that is consumable by the browser.
    Some examples of this are Java applets, Flash animations running ActionScript,
    and client-side widgets running JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using code-on-demand can improve the flexibility of a REST application, but
    it also reduces *visibility* by encapsulating some functionality. This is why
    code-on-demand is an optional constraint for REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code-on-demand](img/B05228_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts the final REST architectural style. This combines all previously
    described constraints, which are required for REST, with the optional constraint
    of code-on-demand.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The REST constraints were designed with separation of concerns and forward-compatibility
    in mind, and this design allows for the individual components of REST to evolve
    without compromising the underlying architectural style itself.
  prefs: []
  type: TYPE_NORMAL
- en: By enforcing the constraints of REST, some particular architectural properties
    are exposed that reveal the beneficial nature of this architectural style. Let's
    explore some specific benefits of REST more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance is a major benefit of REST, and it is exposed by using cache, simple
    representations such as JSON, a layered system with multiple servers and load
    balancing, and the decoupling of components through a uniform interface.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simplicity is another key benefit of REST, and it is primarily exposed by the
    uniform resource constraint in which individual components of the system are decoupled.
    Simplicity is also seen in the server component, which needs only to support HTTP
    requests, and does not have to support state for any request.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separation of concerns lends to the simplicity of REST, but is also a benefit
    itself. This is seen in the separate server-client relationship, the burden of
    caching being put on the frontend, and the use of a layered system. Separation
    of concerns is a common pattern seen not only in architecture but in software
    design as well, such as the MVW architectural patterns discussed in *[Chapter
    2](ch02.html "Chapter 2. Model-View-Whatever")* , *Model-View-Whatever*.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The architectural property of scalability is exposed in REST through the simplicity
    of the client-server relationship and the separation of concerns properties. By
    combining these key attributes, the system becomes more scalable because the complexity
    of relationships between the components is reduced by having specific guidelines
    around how they should work together.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Portability is a benefit of REST that is exposed through the client-server separation
    of concerns. This allows the user interface layer of the application to be *portable*
    because it is agnostic of the underlying server software being used to host the
    REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Portability is also exposed through code-on-demand, giving REST the ability
    to transport application code from server to client.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visibility simply refers to the ability to understand what is happening in a
    system based on the components' interactions with each other. With REST, high
    visibility is a benefit because of the decoupled nature of components and the
    fact that they need little to no knowledge of each other. This allows interactions
    made within the architecture to be easily understood, such as requests for endpoints.
    To determine the full nature of a request, one need not look beyond the representation
    of that request itself.
  prefs: []
  type: TYPE_NORMAL
- en: The code-on-demand constraint of REST is one that actually reduces visibility,
    but for this reason, it is optional. In following, code-on-demand is not often
    used by modern-day web applications, aside from simple JavaScript widgets that
    are found on web pages and used for advertising, social networks, and other third-party
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reliability is a benefit of REST that is exposed primarily through the stateless
    server constraint. With a stateless server, a failure in the application can be
    analyzed at the system level because you know that the origin of that failure
    is from a single, decoupled component of the system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you receive an error message in the UI for a web application
    that indicates to the user that information was entered incorrectly, then this
    failure can be handled at the UI level. If, on the other hand, you receive a HTTP
    400 response code error from the server after entering the correct information,
    you can further deduce that the REST server endpoint is not configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the REST architectural style is often used to perform
    , **Read**, **Update** and **Delete** (**Create**, **Read**, **Update**, **and
    Delete** (**CURD**)) operations in modern web single page applications, and these
    operations are known as web services. To employ RESTful web services for your
    own application, you will need not only a HTTP server, but a hosted database or
    database server in order to perform CRUD operations on the data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a simple database with MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is the database used for the MEAN stack. It is an open source, document-oriented
    database system and can easily be added to your stack via download or package
    manager, depending upon the operating system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB can be installed on systems running Linux, Windows, and OS X. Direct
    downloads are available for these operating systems and, additionally, MongoDB
    can be installed using Homebrew on OS X. Homebrew is a popular CLI package manager
    for OS X. For instructions on installing Homebrew, visit brew.sh.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running OS X and have Homebrew installed, you can use the following
    instructions to install MongoDB using a CLI. For installation on other systems,
    you can find instructions on MongoDB's documentation site at [docs.mongodb.com/manual/installation/](http://docs.mongodb.com/manual/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB on Mac using Homebrew
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start by updating Homebrew to the latest version before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the `mongodb` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once MongoDB is installed, you will want to add it to your command-line `PATH`
    for convenience. To do so, add the following to your user directory `.profile`,
    `.bash_profile`, or `.bashrc` file if you have one of them already. If you don''t
    have any of these files, then create `.profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added MongoDB to your `PATH`, you will need to create a directory
    for storing your data before you can run it. The default data directory for MongoDB
    is `/data/db`. You will most likely have to run this command as the superuser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MongoDB data directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, go to the CLI and create a database directory using `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to set the permissions on the directory to give you read
    and write access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running MongoDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now you should be all set and you can go ahead and run MongoDB using the mongod
    command on the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is set up properly, you should see several lines of output with
    the last line showing something similar to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Port 27017 is the default port for MongoDB but it can be changed, if necessary,
    using the `--port` option on the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To stop MongoDB from running at any time, press *Ctrl* + *C* at the command
    prompt where it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collection with MongoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A collection in MongoDB is analogous to a table in a traditional relational
    database. Let''s set up a test database and collection using the `user.json` document
    we have been working with in our example application. From the root directory
    of the application, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a database named test and a collection named users,
    then it will import the data from the user.json file to the users collection.
    You should see two lines of output after running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This output indicates that the `user.json` document was imported to the MongoDB
    instance running on localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Node.js MongoDB driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoDB provides drivers for several programming languages. We will be using
    the Node.js driver. The Node.js driver for MongoDB can be installed using NPM.
    Go to the root directory of the application and install it there and save to your
    local `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can start using MongoDB within your Node.js application. First, let''s
    add some additional lines to the `server.js` file we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will set up a connection to your local MongoDB test database and output
    a message to the console if it is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you added these lines to the additional code we wrote to `server.js` in
    [*Chapter 3*](ch03.html "Chapter 3. SPA Essentials – Creating the Ideal Application
    Environment"),*SPA Essentials - Creating the Ideal Application Environment*, the
    entire content of the file should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The assert module we added provides a simple set of assertion tests that can
    be used for testing invariants, or values that cannot change. Now let''s save
    the file and run the server again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is working properly and your Node.js server is connected to the
    database, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that your Node.js server is running and connected to MongoDB.
    If the MongoDB connection is not successful, an error will be thrown in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a Node.js server running with a connection to the test database
    in MongoDB, we can begin writing some REST API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic REST API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common type of RESTful request on the Web is a HTTP `GET` or `Read`
    operation. An example of this is a simple request to view a web page through a
    URL. GET requests can be performed to read any kind of data and do not need to
    be supported by a database, but in order to implement the Create, Update, and
    Delete operations on data, some type of database or data store must be used, along
    with a REST **Application Programming Interface** (**API**).
  prefs: []
  type: TYPE_NORMAL
- en: CRUD with REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performing full CRUD operations with your web application can be done using
    the simple NPM, Bower, and Grunt application you have been working with thus far;
    we just need to write some API endpoints now to make this possible. Let's go back
    to our application CLI to make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling request data with Node.js and Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can handle any API request data sent to our server, we have to add
    the ability to parse that data. In most cases, this will be data that is sent
    from a web page through a form or some other means. This type of data is referred
    to as the **body** of the request, and in order to parse it we will need to add
    another Node.js package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the Node.js `body-parser` package to our application dependencies.
    Now let''s go back to editing `server.js` and add some additional code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add the bodyParser variable declaration below the other variable declarations
    at the top of the file, and then call `app.use(bodyParser.json())` just below
    it and above all route definitions. This will now allow us to handle and parse
    any JSON data sent as the body of any request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating with a POST request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express follows REST vernacular by providing method names for routes that match
    their respective HTTP request type. In REST, a HTTP POST request is the standard
    method used for a Create operation. The respective Express method for this is
    `.post()`. Let's set up a simple POST request with Express that will allow us
    to add additional records to our users collection in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s remove the MongoDB connection test code in `server.js` and replace
    it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Make sure this code is *above* the `app.use('/', ...)` and `app.get('*', ...)`
    definitions we created in [*Chapter 3*](ch03.html "Chapter 3. SPA Essentials –
    Creating the Ideal Application Environment"), *SPA Essentials - Creating the Ideal
    Application Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire content of `server.js` should now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The .post() request endpoint or handler we added will first log the `request.body`
    object, which has been parsed and converted from JSON, to the server console on
    the command line. It will then connect to MongoDB and call the MongoDB `insertOne()`
    method to insert the `request.body` document into the users collection in our
    database.
  prefs: []
  type: TYPE_NORMAL
- en: There are many libraries available that can handle this type of interaction
    and database inserts from a request much more gracefully, but it is important
    to understand how the Express server is interacting with MongoDB, so for that
    reason, we are using the native MongoDB API to perform these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the POST request on the frontend
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a POST handler set up in our server, let''s test that it works
    by sending a request from the frontend. Inserting information is commonly done
    from user entry in a form, so let''s edit the application layout index.html file
    and add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Add this HTML code just under the opening `<body>` tag in the page. We will
    again use the `Payload.js` API for making a request to the server; this time,
    a simple POST request. Notice that the `data-url` attribute of the `<form>` tag
    is set to the API endpoint URL, and the `data-method` attribute is set to *post*.
    When the form is submitted, this will take the form data and convert it to JSON
    and send it as the request body to the server via a POST request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the app from the CLI and go to `localhost:8080` in your browser. You
    should see the form there. Add some sample data to the form inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now click to submit the form just once. If all goes well, you should see something
    like the following displayed in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The JSON document created from the form should now be inserted into the users
    collection in the MongoDB test database. This means there are now two documents
    in the collection - the document we inserted originally from the user.json file,
    and the one we just added from the form POST.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got a couple of records in our database, we need a way to retrieve
    those documents and display them in the browser. We can do this by first creating
    an endpoint to read data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Reading with a GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A HTTP `GET` request is the standard method used for a Read operation in REST.
    The respective Express method for this is `.get()`. We previously set up a GET
    request in *Chapter 3* to load our layout page, but this time we want to write
    a REST API request that will return the user records from MongoDB in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, hit *Ctrl* + *C* on the command line to stop the server, then open up
    `server.js` again for editing. Just below the `.post()` endpoint we wrote, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that this handler is requested through the same URL as the `.post()`
    handler, but it will be handled differently because of the HTTP request method
    being a GET instead of a POST.
  prefs: []
  type: TYPE_NORMAL
- en: First, the request will connect to the test database and then call the MongoDB
    .find() method on the users collection, which will return a cursor. A cursor in
    MongoDB is a pointer to the results of a database query. As we mentioned in *[Chapter
    3](ch03.html "Chapter 3. SPA Essentials – Creating the Ideal Application Environment")*
    , *SPA Essentials - Creating the Ideal Application Environment*, MongoDB uses
    the BSON data format internally, so in order to format the cursor for use in our
    application, we have to convert the BSON data to a format that is consumable over
    HTTP. For this purpose, we chain the `.toArray()` method to the `.find()` operation,
    which will convert the result set to an array of documents. We can also access
    the length property of the resulting array and log the number of documents retrieved
    to the server console.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass an anonymous callback function to the `.toArray()` method and
    return the resulting data as a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the GET request on the frontend
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let''s set up some HTML to test our GET request on the frontend. Edit the
    application layout index.html page and edit the HTML we added to retrieve and
    display data from the `user.json` file in *[Chapter 2](ch02.html "Chapter 2. Model-View-Whatever"),
    Model-View-Whatever*. This should be right underneath the form we just added for
    the POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have now changed the URL for the GET request from `/user.json` to `/api/users`.
    Payload.js will handle an API request as a GET by default, so there is no need
    to add the d`ata-method="get"` attribute to this URL, other than to provide more
    transparency. Additionally, the empty .results <div> is indicated as where we
    want to display our resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have changed the `data-template` attribute value here from user (singular)
    to users (plural). This indicates that we want to load a Handlebars template named
    users. Create a new file in the root of your app directory called `users.handlebars`
    and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to recompile the Handlebars templates and save them to the `templates.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this from the command line and you will be just about ready to load the
    MongoDB data into the template. First, run the server again, and then go to or
    refresh `localhost:8080` in your browser. Click the Load user data link and you
    should see only one name show up below it: the `first_name` and `last_name` fields
    from the document you just inserted into the database. If you check the console,
    you should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So two documents were actually retrieved from the database, but only one name
    is displayed in the browser. Why is this? The reason is quite simple, but easy
    to overlook. The data from the document we first inserted from `user.json` looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The new document we added from the form `POST` request, however, looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the document we created from the form does not have a name object
    with the first and last properties nested in it like the `user.json` document,
    but instead has the explicit `first_name` and `last_name` properties, and those
    are the properties that we are looking to display in the Handlebars template.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why the HTML view only displays one name, but how did we
    overlook this? The reason for this is attributed to the fact that MongoDB is a
    document-oriented database with no strict data typing, like a relational database.
    As we discussed in *[Chapter 3](ch03.html "Chapter 3. SPA Essentials – Creating
    the Ideal Application Environment")* , *SPA Essentials – Creating the Ideal Application
    Environment*, this is one of the things that makes NoSQL document-oriented databases
    completely different than traditional SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: So when we inserted the new data into our collection from the form POST, MongoDB
    did nothing to check that the format of the new document matched the format of
    the existing document. Self-defined document structure is a powerful feature of
    a document-oriented database, but it can also lead to application errors and missing
    data for the UI when the document collections are not normalized.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's write an Update endpoint to change one of our existing documents and
    have it match the other.
  prefs: []
  type: TYPE_NORMAL
- en: Updating with a PUT request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In REST, a HTTP `PUT` request is the standard method used for an Update operation.
    The respective Express method for this is .put().
  prefs: []
  type: TYPE_NORMAL
- en: 'Now hit *Ctrl* + *C* to stop the Node.js server, then open up the server.js
    file again and add the following code below the `.get()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are again using the same endpoint URL, but this will only handle a `PUT`
    request made from the frontend. This method will first connect to our test database,
    and then it will call the MongoDB `.udpateOne()` method to update an existing
    document. The first argument passed to this method is a filter, or data to look
    for and find a match. The `.updateOne()` method will only look for the first document
    that matches a filter and then end the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the filter passed to the method here is `{ "id": 1 }`. This is
    the `id` field that was passed in from the `user.json` file. Remember that MongoDB
    actually creates its own internal id for every document if one is not supplied,
    and this field is called `_id`. So in the case of our original user object we
    supplied, it will have an `_id` field set to a BSON `ObjectId` and the original
    *id* field we supplied set to 1\. Since we know that the new document we created
    from the form POST does not have the extraneous *id* field, we can safely filter
    on that field to find the original document and update it.'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter we are passing to the `.updateOne()` method is the entire
    request body, which will be an object produced from a form submission. Typically,
    with a PUT request, the intention is to update existing fields with new values,
    but in this case we actually want to change the structure of the document to match
    the structure of the new record we created using the form POST.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter passed to the `.updateOne()` method is an anonymous callback
    function to which the result of the update request is passed. Here, we log that
    result to the console and return it as JSON to the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the PUT request on the frontend
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let''s go back to the application layout index.html file and add some more
    HTML just below the GET request HTML we added previously. To do this, copy the
    HTML from the `POST` request form and change it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code matches the POST request HTML save for a few minor changes. We have
    edited the `<h2>` title to show that this is the PUT request form, and the `data-method`
    attribute on the form is now set to `put`. Leave all form inputs as they are because
    we will want the updated document to match the new document we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start the server again from the command line and then go to or refresh
    localhost:8080 in your browser. You should see the new `PUT` Request form we added
    below the `POST` request and `GET` request areas on the page. Now enter the data
    from the original `user.json` object into the corresponding form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now click the submit button once and check your console output. You should
    see a lot of information printed to the console. At the very top of it, you should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This result indicates that one record was modified. If the update was successful,
    the original `user.json` document should now match the format of the second one
    we added from the form POST. To test this, click on the Load user data link to
    GET the user documents and list the names using the Handlebars template and the
    `first_name` and `last_name` properties. You should now see each of the two names
    listed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To complete our RESTful API endpoints in server.js, let's add a final `Delete`
    handler and use it to remove one of the two user records.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting with a DELETE request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A HTTP `DELETE` request is the standard method used for the homonymous Delete
    operation in REST. Naturally, the respective Express method for this is `.delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit *Ctrl* + *C* on the command to stop the server and then open *server.js*
    again for editing. Add the following code just below the `.put()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This handler will first connect to the database, then it will call the MongoDB
    `.deleteOne()` method on the users collection. The first parameter passed to the
    `.deleteOne()` method is a condition to match against a record to delete. In this
    case, we want to delete the new record we created earlier from the form POST,
    so we are using the unique `first_name` value of `Peebo` for this.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter passed to the `.deleteOne()` method is an anonymous callback
    function which is passed the result of the delete request. We are again going
    to log that result to the console and return it to the frontend as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the DELETE request on the frontend
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open the application layout index.html file again and add the following code
    below the `PUT` request form we added previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added a simple button with the Payload.js attributes necessary
    to send a HTTP `DELETE` request.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be noted that no request body, such as form data, can be sent with
    a `DELETE` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start up the Node.js server again and then go to or reload index.html in your
    browser. You should see the **Delete Peebo** button at the bottom of the page.
    Click the button just once and then check the console output. You will see a lot
    of information from the result. At the very top of the output, you should see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The n: 1 property shown here indicates that one record was successfully deleted.
    To verify this, go back to the browser and scroll up to the Load user data link
    under the **GET Request** title. Click that link, and you should now see only
    the original `user.json` document `first_name` and `last_name` shown. The console
    will also indicate that only a single result was found in the users collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you now have a full RESTful set of endpoints written to perform
    CRUD operations with Express and MongoDB. Although quite primitive, these example
    methods should give you a foundation for learning more and building upon them
    to create a more robust single page application. They should also give you a better
    understanding of the REST architectural style, and how Node.js interacts with
    MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is arguably the most widely used architectural style across the Web and
    the IoT, but there are many other technologies, protocols, and architectural styles
    available to use for web services and single page web application data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: TCP versus UDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, TCP is the transport layer protocol upon which HTTP travels
    to the application layer. Some of the beneficial attributes of TCP connections
    are that they are reliable, serial, and checked for errors while sending information.
    These benefits, however, can sometimes lead to undesirable latency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP versus UDP](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Internet Protocol Suite includes many other protocols alongside TCP. One
    of these protocols is **User Datagram Protocol** (**UDP**). UDP is also a core
    member of the *transport layer* of TCP/IP. The primary difference between UDP
    and TCP is that UDP is *connectionless*. This means that individual units of data
    are transmitted with self-identifying information and the receiving end of that
    information has no prior knowledge of when or how it will be received. UDP does
    nothing to ensure that a recipient endpoint is actually available to receive that
    information, and thus this risk must be taken into consideration when using UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Since UDP uses no connection, it is inherently not *reliable*, and that is what
    sets it apart from a connection-based protocol such as TCP. TCP allows for error
    checking and correction during a transmission because both parties are aware of
    each other due to their *connection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages sent over UDP and other connectionless protocols are called *datagrams*.
    UDP and datagrams should only be used when error checking and correction is not
    needed or is performed within the application layer itself. Checking errors at
    the application level is often the model that is used with UDP since error checking
    and correction is almost always a necessity with any application. Some examples
    of application types that use UDP are:'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voice over IP** (**VoIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Massively multiplayer online games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Name System** (**DNS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some **Virtual Private Network** (**VPN**) systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most obvious disadvantages with UDP and a connectionless protocol are that
    there is no guarantee of message delivery, no error checking, and, consequently,
    no error correction. This can be a major disadvantage in an application where
    a user is interacting with the system on their own and most events are user generated.
    In a system where hundreds or thousands of users may be interacting with each
    other, however, a connectionless protocol allows the application to be free of
    latency due to error correction. A massively multiplayer online game is a good
    example of a system in which thousands or even millions of messages may need to
    be transported across a network consistently, but this cannot be done reliably
    while also maintaining connections with error checking and correction.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is often compared to **Simple Object Access Protocol** (**SOAP**), although
    SOAP is actually a protocol and not an architectural style like REST. The reason
    for the comparison is because both are used for web services, and in this context,
    REST is synonymous with HTTP, which is a protocol. Even though SOAP is a protocol,
    it also interacts with HTTP to transmit messages for implementing web services.
    It can also be used over SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message format for SOAP is XML. An XML message sent with SOAP is referred
    to as an *envelope*. The structure of a SOAP envelope follows a particular pattern
    involving elements including a mandatory *body* element and an optional *header*
    element. The body may also include nested *fault* constructs which carry information
    regarding exceptions. An example of a SOAP message is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: REST can also use XML for data exchange, but more commonly uses JSON in modern-day
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets is a protocol that allows interactive communication between a web
    browser and a server. The term *interactive* in this context means that the server
    can *push* messages to the web browser without the browser needing to periodically
    *poll* the server for new data, as might typically be done in a web application
    using HTTP, AJAX, and REST.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of *push* technology before. This paradigm is evident in
    many smartphone applications that push update notifications to a phone as soon
    as new data is available. This is also referred to as *real-time data*. HTTP is
    limited in that it does not support open connections that can receive real-time
    data. Instead, HTTP requires that a request be made and a connection or *socket*
    is opened, a response is received, information is downloaded, and the connection
    is then closed. Once new information becomes available, this will not be evident
    to the application needing that information without making periodic requests to
    the server, which is referred to as *polling*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2011, WebSockets became officially standardized and supported by modern
    web browsers. This protocol allows data to be transferred to and from a server
    by using an *open* socket connection, allowing the client to request data at will
    but also allowing the server to *push* data to the client in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WebSockets](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Web applications using REST are limited by the open/close connection constraint
    with HTTP. This makes sense for many web applications that do not need a server
    response without a user interaction, or that can implement periodic server polling
    without too much overhead required. Web applications that want to provide real-time
    data to the user without an action, however, may be better served by using WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MQTT originally stood for **MQ Telemetry Transport**. It is a messaging protocol
    designed to be used on top of TCP/IP, or the Internet Protocol Suite. MQTT employs
    a *publish-subscribe*, or PubSub, messaging pattern in which events or messages
    are published by publishers and available to any number of subscribers. In following,
    subscribers receive messages from any number of publishers. In this paradigm,
    publishers are entirely agnostic of subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to SOAP and WebSockets, MQTT is not designed to be used for web
    services over HTTP, but instead is primarily use for **machine-to-machine **(**M2M**)
    communication. MQTT is often used for satellite communications, home or **smart
    home** automation, and for mobile applications. MQTT is considered to be lightweight
    and have a small code footprint, making it ideal for mobile applications which
    may be using slower, wireless mobile network connections.
  prefs: []
  type: TYPE_NORMAL
- en: The "MQ" in MQTT was originally derived from IBM's **Message Queuing** (**MQ**)
    protocol. Message queuing is not actually a requirement for MQTT, however, which
    is why it is no longer a true acronym and is simply referred to as MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT is an **Organization for the Advancement of Structured Information Standards**
    (**OASIS**) standard. OASIS is an organization that defines standards for the
    IoT and other areas of technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any software that implements MQTT is referred to as an MQTT broker, which is
    a type of message broker architectural pattern that translates messages sent from
    an application to the proprietary format of the receiver, or the message broker
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MQTT](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The purpose of the message broker is to take the messages received by an application
    and perform some type of action on them. For example, some actions might be:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiating web service requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forwarding messages to other destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming messages to a different type of representation for consumption
    by anther application or endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing messages to be used for publish-subscribe events and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and/or responding to application errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many popular message broker applications and services that can be
    used for message exchange in single page applications. Some of these are Mosquitto,
    CloudMQTT, IBM MessageSight, and ActiveMQ.
  prefs: []
  type: TYPE_NORMAL
- en: AMQP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Advanced Message Queuing Protocol** (**AMQP**) is similar to MQTT. It is
    an open standard application layer protocol for use with message brokers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular open source message brokers for modern-day web applications
    is RabbitMQ, which employs AMQP. In an AMQP architecture using something like
    RabbitMQ, messages are *produced* by an application and then *queued* or stored
    in the RabbitMQ server. A queue is also, in a sense, a *buffer* because it can
    store any amount of information for any amount of time until it is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AMQP](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although it uses AMQP, RabbitMQ also includes an adapter for MQTT. It additionally
    supports HTTP and **Streaming Text Oriented Messaging Protocol** (**STOMP**).
    The fact that RabbitMQ is open source and that it also includes adapters for other
    protocols, most notably HTTP, contributes greatly to its popularity today.
  prefs: []
  type: TYPE_NORMAL
- en: CoAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Constrained Application Protocol** (**CoAP**) is a web transfer protocol
    designed for M2Mcommunication. The machines primarily targeted for CoAP services
    are IoT devices.'
  prefs: []
  type: TYPE_NORMAL
- en: CoAP is actually quite similar to HTTP and employs the REST architectural style
    as part of its specification. The difference with CoAP is that it strictly adheres
    to REST principles, while HTTP merely supports REST but does not require it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since CoAP uses the REST architectural style, it can actually be connected
    to over HTTP because, like with any RESTful architecture, the client is agnostic
    of the RESTful server it is accessing. In this scenario, a cross-protocol proxy
    is used to make the CoAP services available to a HTTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CoAP](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Distributed Data Protocol** (**DDP**) is not commonly used but gaining ground
    through the popular Meteor JavaScript framework. DDP is a simple protocol used
    for explicitly retrieving representations from a server, and also receiving updates
    regarding modifications on those representations in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: DDP allows Meteor applications to use WebSockets for services, providing a framework
    around those services to be connectionless. JSON data is used, but instead of
    being explicitly requested like it is with a RESTful architecture, the JSON data
    messages can be *pushed* in real time to an application.
  prefs: []
  type: TYPE_NORMAL
- en: DDP was originally developed for Meteor by its founders; however, it is not
    specific to Meteor and can be used in other frameworks. Meteor's implementation
    of DDP is written entirely in JavaScript and is open source.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now learned the fundamental aspects of the REST architectural style,
    the differences between an architectural style and a protocol, the relationship
    between REST and the HTTP protocol, and the constraints of REST. You have also
    learned to write some basic REST API endpoints using Express and MongoDB. A good
    understanding of REST and the server side of a single page application is paramount
    to becoming a skilled web SPA developer. In the next chapter, we will transition
    our focus to the frontend of SPA development, learn a few things about SPA UI
    frameworks and best practices, and take everything we have learned so far and
    apply it to the View layer.
  prefs: []
  type: TYPE_NORMAL
