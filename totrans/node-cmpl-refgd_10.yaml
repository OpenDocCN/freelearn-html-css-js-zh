- en: Deploying Node.js Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the Notes application is fairly complete, it's time to think about
    how to deploy it to a real server. We've created a minimal implementation of the
    collaborative note concept that works fairly well. To grow, Notes must escape
    our laptop and live on a real server. The goal is to look at deployment methods
    for Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional LSB-compliant Node.js deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PM2 to improve reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment to a **Virtual Private Server** (**VPS**) provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice deployment with Docker (we have four distinct services to deploy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment to a Docker hosting provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first task is to duplicate the source code from the previous chapter. It's
    suggested you create a new directory, `chap10`, as a sibling of the `chap09` directory,
    and copy everything from `chap09` to `chap10`.
  prefs: []
  type: TYPE_NORMAL
- en: Notes application architecture and deployment considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into deploying the Notes application, we need to review its architecture.
    To deploy the Notes application, we must understand what we're planning to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have segmented the services into two groups, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0722ddbb-10a6-4c2d-988c-703ed2474e35.png)'
  prefs: []
  type: TYPE_IMG
- en: The user authentication server should be the more secure portion of the system.
    On our laptop, we weren't able to create the envisioned protective wall around
    that service, but we're about to implement such protection.
  prefs: []
  type: TYPE_NORMAL
- en: One strategy to enhance security is to expose as few ports as possible. That
    reduces the so-called attack surface, simplifying our work in hardening the application
    against security bugs. With the Notes application, we have exactly one port to
    expose, the HTTP service through which users access the application. The other
    ports, the two for MySQL servers and the user authentication service port, should
    be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the Notes application needs to access both the Notes database and
    the user authentication service. That service, in turn, needs to access the user
    authentication database. As currently envisaged, no service outside the Notes
    application requires access to either database or to the authentication service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of this segmentation requires either two or three subnets, depending
    on the lengths you wish to go to. The first, FrontNet, contains the Notes application
    and its database. The second, AuthNet, contains the authentication service and
    its database. A third possible subnet would contain the Notes and authentication
    services. The subnet configuration must limit the hosts with access to the subnet,
    and create a security wall between subnets.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Linux Node.js service deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional Linux/Unix server application deployment uses an **init script**
    to manage background processes. They are to start every time the system boots
    and cleanly shut down when the system is halted. While it's a simple model, the
    specifics of this vary widely from one **operating system** (**OS**) to another.
  prefs: []
  type: TYPE_NORMAL
- en: A common method is for the `init` process to manage background processes using
    shell scripts in the `/etc/init.d` directory. Other OSes use other process managers,
    such as `upstart` or `launchd`.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js project itself does not include any scripts to manage server processes
    on any OS. Node.js is more like a construction kit, with the pieces and parts
    to build servers, and is not a complete polished server framework itself. Implementing
    a complete web service based on Node.js means creating the scripting to integrate
    with process management on your OS. It's up to us to develop those scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web services have to be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reliable: For example, to auto-restart when the server process crashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manageable: Meaning it integrates well with system management practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Observable: Meaning the administrator must be able to get status and activity
    information from the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate what's involved, let's use PM2 to implement background server
    process management for Notes. PM2 detects the system type and can automatically
    integrate itself with the process management system. It will create an LSB-style
    init script ([http://wiki.debian.org/LSBInitScripts](http://wiki.debian.org/LSBInitScripts)),
    or other scripts, as required by the process management system on your server.
  prefs: []
  type: TYPE_NORMAL
- en: For this deployment, we'll set up a single Ubuntu 17.10 server. You should provision
    a **Virtual Private Server** (**VPS**) from a hosting provider and do all installation
    and configuration there. Renting a small machine instance from one of the major
    providers for the time needed to go through this chapter will only cost a couple
    of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: You can also do the tasks in this section using **VirtualBox** on your laptop.
    Simply install Debian or Ubuntu as a virtual machine in VirtualBox, then follow
    the instructions in this section. It won't be quite the same as using a remote
    VPS hosting provider, but does not require renting a server.
  prefs: []
  type: TYPE_NORMAL
- en: Both the Notes and user authentication services will be on that server, along
    with a single MySQL instance. While our goal is a strong separation between FrontNet
    and AuthNet, with two MySQL instances, we won't do so at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisite – provisioning the databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux package management system doesn't allow us to install two MySQL instances.
    Instead, we implement separation in the same MySQL instance by using separate
    databases with different usernames and access privileges for each database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to ensure that MySQL is installed on your server. For Ubuntu,
    **DigitalOcean** has a fairly good tutorial: [https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04](https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04).
    While the Ubuntu version for that tutorial is old, the instructions are still
    accurate enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL server must support TCP connections from `localhost`. Edit the configuration
    file, `/etc/mysql/my.cnf`, to have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This limits MySQL server connections to the processes on the server. A miscreant
    would have to break into the server to access your database. Now that our database
    server is available, let's set up two databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chap10/notes/models` directory, create a file named `mysql-create-db.sql`
    containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `chap10/users` directory, create a file named `mysql-create-db.sql`
    containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t run those scripts on the server, because the Notes application has
    not yet been copied to the server. When that''s accomplished, we''ll run the scripts
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will create the two databases, `notes` and `userauth`, with associated
    usernames and passwords. Each user can access only their associated database.
    Later, we'll set up Notes and the user authentication service with YAML configuration
    files to access these databases.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the Node.js documentation ([https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)),
    the recommended installation method for Debian or Ubuntu Linux distributions is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've seen this before, so substitute the Node.js desired version number in
    the URL. Installing this way means that as new Node.js releases are issued, upgrades
    are easily accomplished with the normal package management procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Notes and user authentication on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before copying the Notes and user authentication code to this server, let's
    do a little coding to prepare for the move. We know that the Notes and authentication
    services must access the MySQL instance on `localhost` using the usernames and
    passwords given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using the approach we've followed so far, this means a pair of YAML files for
    `Sequelize` parameters, and changing environment variables in the `package.json`
    files to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `chap10/notes/models/sequelize-server-mysql.yaml` file containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It was discovered during testing that a simple password such as `notes` was
    not acceptable to the MySQL server, and that a longer password was required. In
    `chap10/notes/package.json`, add the following line to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a `chap10/users/sequelize-server-mysql.yaml` file containing the
    following code the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The passwords shown in these configuration files obviously will not pass any
    security audits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `chap10/users/package.json`, add the following line to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This configures the authentication service to access the databases just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to select a place on the server to install the application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This empty directory looks to be as good a place as any. Simply upload `chap10/notes`
    and `chap10/users` to your preferred location. Before uploading, remove the `node_modules`
    directory in both directories.
  prefs: []
  type: TYPE_NORMAL
- en: That's both to save time on the upload, and because of the simple fact that
    any native-code modules installed on your laptop will be incompatible with the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your laptop, you might run a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Use the actual IP address or domain name assigned to the server being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in each directory, run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We're running these commands as `root` rather than a user ID that can use the `sudo` command.
    The machine offered by the chosen hosting provider (DigitalOcean) is configured
    so users log in as `root`. Other VPS hosting providers will provide machines where
    you log in as a regular user and then use `sudo` to perform privileged operations.
    As you read these instructions, pay attention to the command prompt we show. We've
    followed the convention where `$` is used for commands run as a regular user and `#` is
    used for commands run as `root`. If you're running as a regular user, and need
    to run a `root` command, then run the command with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way of doing this is to just delete the whole `node_modules` directory
    and then let `npm install` do its job. Remember that we set up the `PATH` environment
    variable the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can place this in the login script (`.``bashrc`, `.cshrc`, and so on) on
    your server so it's automatically enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can now run the SQL scripts written earlier to set up the database
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you should be able to start up the services by hand to check that everything
    is working correctly. The MySQL instance has already been tested, so we just need
    to start the user authentication and Notes services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then log in to the server on another Terminal session and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command both tests that the backend user authentication service
    is functioning and gives us a user account we can use to log in. The `users-list`
    command demonstrates that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is generated inside of `Sequelize`. The `mysql2` driver is an alternate
    MySQL driver, implemented in pure JavaScript, and includes support for returning
    Promises for smooth usage in `async` functions. If you do get this message, go
    ahead and install the package and remember to add this dependency to your `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start the Notes service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then we can use our web browser to connect to the application. Since you probably
    do not have a domain name associated with this server, Notes can be accessed via
    the IP address of the server, such as `http://159.89.145.190:3000/`.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we're using the IP address of the VPS used to test the instructions
    in this section. The IP address you use will, of course, be different.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you know that the drill for verifying Notes is working. Create a few
    notes, open a few browser windows, see that real-time notifications work, and
    so on. Once you're satisfied that Notes is working on the server, kill the processes
    and move on to the next section, where we'll set this up to run when the server
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting Twitter authentication to work on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Twitter application we set up for Notes previously won't work because the
    authentication URL is incorrect for the server. For now, we can log in using the user
    profile created previously. If you want to see OAuth work with Twitter, go to
    `apps.twitter.com` and reconfigure the application to use the IP address of your
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'By hosting somewhere other than our laptop, the Twitter `callbackURL` must
    point to the correct location. The default value was `http://localhost:3000` for
    use on our laptop. But we now need to use the IP address for the server. In `notes/package.json,`
    add the following environment variable to the `on-server` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Use the actual IP address or domain name assigned to the server being used.
    In a real deployment, we'll have a domain name to use here.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PM2 to manage Node.js processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to manage server processes, to ensure restarts if the process
    crashes, and so on. We'll use **PM2** ([http://pm2.keymetrics.io/](http://pm2.keymetrics.io/))
    because it's optimized for Node.js processes. It bundles process management and
    monitoring into one application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a directory, `init`, in which to use PM2\. The PM2 website suggests
    you install the tool globally but, as students of the Twelve Factor Application
    model, we recognize it's best to use explicitly declared dependencies and avoid
    global unmanaged dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `package.json` file containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Install PM2 using `npm install` as usual.
  prefs: []
  type: TYPE_NORMAL
- en: In normal PM2 usage, we launch scripts with `pm2 start script-name.js`. We could
    make an `/etc/init` script which does that, but PM2 also supports a file named
    `ecosystem.json` that can be used to manage a cluster of processes. We have two
    processes to manage together, the user-facing Notes application, and the user
    authentication service on the back end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `ecosystem.json` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This file describes the directories containing both services, the script to
    run each service, the command-line options, and the environment variables to use.
    It's the same information that is in the `package.json` scripts, but spelled out
    more clearly. Adjust `TWITTER_CALLBACK_HOST` for the IP address of the server.
    For documentation, see [http://pm2.keymetrics.io/docs/usage/application-declaration/](http://pm2.keymetrics.io/docs/usage/application-declaration/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then start the services with `npm run start`,  which looks like the following
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/641357ce-aa02-4035-93b1-61885a0dd4c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can again navigate your browser to the URL for your server, such as `http://159.89.145.190:3000`,
    and check that Notes is working. Once started, some useful commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These commands let you query the status of the services.
  prefs: []
  type: TYPE_NORMAL
- en: The `pm2 monit` command gives you a pseudo-graphical monitor of system activity.
    For documentation, see [http://pm2.keymetrics.io/docs/usage/monitoring/](http://pm2.keymetrics.io/docs/usage/monitoring/).
  prefs: []
  type: TYPE_NORMAL
- en: The `pm2 logs` command addresses the application log management issue we raised
    elsewhere. Activity logs should be treated as an event stream, and should be captured
    and managed appropriately. With PM2, the output is automatically captured, can
    be viewed, and the log files can be rotated and purged. See [http://pm2.keymetrics.io/docs/usage/log-management/](http://pm2.keymetrics.io/docs/usage/log-management/)
    for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we restart the server, these processes don''t start with the server. How
    do we handle that? It''s very simple because PM2 can generate an `init` script
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `pm2 save` command saves the current state. Whatever services are running
    at that time will be saved and managed by the generated start up script.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to generate the startup script, using the `pm startup` command.
    PM2 supports generating start up scripts on several OSes, but when run this way,
    it autodetects the system type and generates the correct start up script. It also
    installs the start up script, and starts it running. See the documentation at [http://pm2.keymetrics.io/docs/usage/startup/](http://pm2.keymetrics.io/docs/usage/startup/) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at the output, some useful commands will be printed. The
    details will vary based on your operating system, because each operating system
    has its own commands for managing background processes. In this case, the installation
    is geared to use the `systemctl` command, as verified by this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You are free to run these commands yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that PM2 starts the services as advertised, reboot your server, then
    use PM2 to check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493c7bae-a569-4c71-a6ff-b5600ce2f63a.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing to notice is that upon initially logging in to the `root` account,
    the `pm2 status` command is not available. We installed PM2 locally to `/opt/init`,
    and the command is only available in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: After going to that directory, we can now run the command and see the status.
    Remember to set the correct IP address or domain name in the `TWITTER_CALLBACK_HOST`
    environment variable. Otherwise, logging in with Twitter will fail.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the Notes application under a fairly good management system. We
    can easily update its code on the server and restart the service. If the service
    crashes, PM2 will automatically restart it. Log files are automatically kept for
    our perusal.
  prefs: []
  type: TYPE_NORMAL
- en: PM2 also supports deployment from the source on our laptop, which we can push
    to staging or production environments. To support this, we must add deployment
    information to the `ecosystem.json` file and then run the `pm2 deploy` command
    to push the code to the server. See the PM2 website for more information: [http://pm2.keymetrics.io/docs/usage/deployment/](http://pm2.keymetrics.io/docs/usage/deployment/).
  prefs: []
  type: TYPE_NORMAL
- en: While PM2 does a good job at managing server processes, the system we've developed
    is insufficient for an internet-scale service. What if the Notes application were
    to become a viral hit and suddenly we need to deploy a million servers spread
    around the planet? Deploying and maintaining servers one at a time, like this,
    is not scalable.
  prefs: []
  type: TYPE_NORMAL
- en: We also skipped over implementing the architectural decisions at the beginning.
    Putting the user authentication data on the same server is a security risk. We
    want to deploy that data on a different server, under tighter security.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll explore a new system, Docker, that solves these problems
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js microservice deployment with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker ([http://docker.com](http://docker.com)) is the new attraction in the
    software industry. Interest is taking off like crazy, spawning many projects,
    often with names containing puns around shipping containers.
  prefs: []
  type: TYPE_NORMAL
- en: It is described as *an open platform for distributed applications for developers
    and sysadmins*. It is designed around Linux containerization technology and focuses
    on describing the configuration of software on any variant of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Docker automates the application deployment within software containers. The
    basic concepts of Linux containers date back to `chroot` jail's first implementation
    in the 1970s, and other systems such as Solaris Zones. The Docker implementation
    creates a layer of software isolation and virtualization based on Linux cgroups,
    kernel namespaces, and union-capable filesystems, which blend together to make
    Docker what it is. That was some heavy geek-speak, so let's try a simpler explanation.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker container is a running instantiation of a Docker image. An image is
    a given Linux OS and application configuration designed by developers for whatever
    purpose they have in mind. Developers describe an image using a **Dockerfile**.
    The Dockerfile is a fairly simple-to-write script showing Docker how to build
    an image. Docker images are designed to be copied to any server, where the image
    is instantiated as a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: A running container will make you feel like you're inside a virtual server running
    on a virtual machine. But Docker containerization is very different from a virtual
    machine system such as VirtualBox. The processes running inside the container
    are actually running on the host OS. The containerization technology (cgroups,
    kernel namespaces, and so on) create the illusion of running on the Linux variant
    specified in the Dockerfile, even if the host OS is completely different. Your
    host OS could be Ubuntu and the container OS could be Fedora or OpenSUSE; Docker
    makes it all work.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, with Virtual Machine software (VirtualBox, and VMWare, among others),
    you're using what feels like a real computer. There is a virtual BIOS and virtualized
    system hardware, and you must install a full-fledged guest OS. You must follow
    every ritual of computer ownership, including securing licenses if it's a closed
    source system such as Windows.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker is primarily targeted at x86 flavors of Linux, it is available
    on several ARM-based OSes, as well as other processors. You can even run Docker
    on single-board computers, such as Raspberry Pis, for hardware-oriented Internet
    of Things projects. Operating systems such as Resin.IO are optimized to solely
    run Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker ecosystem contains many tools, and their number is quickly increasing.
    For our purposes, we''ll be focusing on the following three specific tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker engine**: This is the core execution system that orchestrates everything.
    It runs on a Linux host system, exposing a network-based API that client applications
    use to make Docker requests, such as building, deploying, and running containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker machine**: This is a client application performing functions around
    provisioning Docker Engine instances on host computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker compose**: This helps you define, in a single file, a multi-container
    application, with all its dependencies defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the Docker ecosystem, you can create a whole universe of subnets and services
    to implement your dream application. That universe can run on your laptop or be
    deployed to a globe-spanning network of cloud-hosting facilities around the world.
    The surface area through which miscreants can attack is strictly defined by the
    developer. A multicontainer application will even limit access so strongly between
    services that miscreants who do manage to break into a container will find it
    difficult to break out of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker, we'll first design on our laptop the system shown in the previous
    diagram. Then we'll migrate that system to a Docker instance on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on your laptop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best place to learn how to install Docker on your laptop is the Docker
    documentation website. What we''re looking for is the Docker **Community Edition**
    (**CE**). There is the Docker **Enterprise Edition** (**EE**), with more features
    and some opportunities to pay support fees:'
  prefs: []
  type: TYPE_NORMAL
- en: macOS installation – [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows installation – [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu installation – [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions are available for several other distros. Some useful post-install
    Linux instructions are at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because Docker runs on Linux, it does not run natively on macOS or Windows.
    Installation on either OS requires installing Linux inside a virtual machine and
    then running Docker tools within that virtual Linux machine. The days when you
    had to handcraft that setup yourself are long gone. The Docker team has made this
    easy by developing easy-to-use Docker applications for Mac and Windows. The Docker
    for Windows and Docker for Mac bundles package the Docker tools and lightweight
    virtual machine software. The result is very lightweight, and the Docker containers
    can be left running in the background with little impact.
  prefs: []
  type: TYPE_NORMAL
- en: You may find references to Docker Toolbox as the method to install Docker on
    macOS. That application is long gone, and has been replaced by Docker for Windows
    and Docker for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Docker with Docker for Windows/macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start Docker for Windows or Mac is very simple. You simply find and double-click
    on the application icon. It launches as would any other native application. When
    started, it manages a virtual machine (not VirtualBox) within which is a Linux
    instance running the Docker Engine. On macOS, a menu bar icon shows up with which
    you control `Docker.app`, and on Windows, an icon is available in the system tray.
  prefs: []
  type: TYPE_NORMAL
- en: There are settings available so that Docker automatically launches every time
    you start your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: On both, the CPU must support **Virtualization**. Bundled inside Docker for
    Windows and Docker for Mac is an ultra-lightweight hypervisor, which, in turn,
    requires virtualization support from the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, this may require BIOS configuration. See [https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled](https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled).
  prefs: []
  type: TYPE_NORMAL
- en: For Mac, this requires hardware from 2010 or newer, with Intel’s hardware support
    for **memory management unit** (MMU) virtualization, including **Extended Page
    Tables** (**EPT**) and Unrestricted Mode. You can check for this support by running `sysctl
    kern.hv_support`. It also requires macOS 10.11 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Kicking the tires of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the setup accomplished, we can use the local Docker instance to create
    Docker containers, run a few commands, and, in general, learn how to use this
    amazing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in so many software journeys, this one starts with saying `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `docker run` command downloads a Docker image, named on the command line,
    initializes a Docker container from that image, and then runs that container.
    In this case, the image, named `hello-world`, was not present on the local computer
    and had to be downloaded and initialized. Once that was done, the `hello-world`
    container was executed and it printed out these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query your computer to see that while the `hello-world` container has
    executed and finished, it still exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6adbc2-daf3-4940-8f95-25f501d4f895.png)'
  prefs: []
  type: TYPE_IMG
- en: The `docker ps` command lists the running Docker containers. As we see here,
    the `hello-world` container is no longer running, but with the `-a` switch, `docker
    ps` also shows those containers that exist but are not currently running. We also
    see that this computer has a Nextcloud instance installed along with its associated
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done using a container, you can clean up with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The name `boring_lumiere` is the container name automatically generated by Docker.
    While the image name was `hello-world`, that's not the container name. Docker
    generated the container name so you have a more user-friendly identifier for the
    containers than the hex ID shown in the container ID column. When creating a container, it's
    easy to specify any container name you like.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AuthNet for the user authentication service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all that theory spinning around our heads, it's time to do something practical.
    Let's start by setting up the user authentication service. In the diagram shown
    earlier, this will be the box labeled AuthNet containing a MySQL instance and
    the authentication server.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL container for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find publicly available Docker images, go to [https://hub.docker.com/](https://hub.docker.com/)
    and search. You'll find many Docker images ready to go. For example, Nextcloud,
    and its associated database, was shown earlier installed alongside the `hello-world`
    application when we kicked the tires. Both are available from their respective
    project teams and it's simply (more or less) a matter of typing `docker run nextcloud` to
    install and run the containers. The process of installing Nextcloud, and its associated
    database, as well as many other packaged applications, such as GitLab, is very
    similar to what we're about to do to build AuthNet, so the skills you're about
    to learn are very practical.
  prefs: []
  type: TYPE_NORMAL
- en: Just for MySQL, there are over 11,000 containers available. Fortunately, the
    two containers provided by the MySQL team are very popular and easy to use. The
    `mysql/mysql-server` image is a little easier to configure, so let's use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Docker image name can be specified, along with a *tag* that is usually the
    software version number. In this case, we''ll use `mysql/mysql-server:5.7`, where
    `mysql/mysql-server` is the container name, and `5.7` is the tag. MySQL 5.7 is
    the current GA release. Download the image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This downloaded four images in total, because this image is built on top of
    three other images. We'll see later how that works when we learn how to build
    a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'A container can be started using this image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We started this service in the foreground. The container name is `mysql`. We
    set an environment variable, which, in turn (according to the image documentation),
    initializes the `root` password as shown. In another window, we can get into the
    container and run the MySQL client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The **`docker exec`** command lets you run programs inside the container. The
    `-it` option says the command is run interactively, on an assigned terminal. Substitute
    `bash` for `mysql`, and you have an interactive `bash` command shell.
  prefs: []
  type: TYPE_NORMAL
- en: This `mysql` command instance is running inside the container. The container
    is configured by default to not expose any external port, and it has a default
    `my.cnf` file.
  prefs: []
  type: TYPE_NORMAL
- en: The database files are locked inside the container. As soon as that container
    is deleted, the database will go away. Docker containers are meant to be ephemeral,
    being created and destroyed as needed, while databases are meant to be permanent,
    with lifetimes measured in decades sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, it''s cool that we can easily install and launch a MySQL instance.
    But there are several deficiencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to the database from other software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the database files outside the container for a longer lifespan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom configuration, because database admins love to tweak the settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to be connected to AuthNet along with the user authentication service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before proceeding, let''s clean up. In a Terminal window, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This closes out and cleans up the containers. And, to reiterate the point made
    earlier, the database in that container went away.  If that database contained
    critical information, you just lost it with no chance to recover the data.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing AuthNet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker supports creating virtual bridge networks between containers. Remember
    that a Docker container has many of the features of an installed Linux OS. Each
    container can have its own IP address(es) and exposed ports. Docker supports creating
    what amounts to being a virtual Ethernet segment, called a **bridge network**.
    These networks live solely within the host computer and, by default, are not reachable
    by anything outside the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker bridge network, therefore, has strictly limited access. Any Docker
    container attached to a bridge network can communicate with other containers attached
    to that network. The containers find each other by hostname, and Docker includes
    an embedded DNS server to set up the hostnames required. That DNS server is configured
    to not require dots in domain names, meaning that the DNS/hostname of each container
    is simply the container name, rather than something such as `container-name.service`.
    This policy of using hostnames to identify containers is Docker's implementation
    of service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `authnet` as a sibling to the `users` and `notes` directories.
    We'll be working on AuthNet in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file, `buildauthnet.sh`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This creates a Docker bridge network.
  prefs: []
  type: TYPE_NORMAL
- en: Script execution on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executing scripts on Windows is different because it uses PowerShell rather
    than `bash`, and a large number of other considerations. For this, and the scripts
    which follow, make these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Powershell script filenames must end with the `.ps1` extension. For most of
    these scripts, that's all that is required because the scripts are so simple.
    To execute the script, simply type `.\scriptname.ps1` in the Powershell window.
    In other words, on Windows, the script just shown must be named `buildauthnet.ps1`,
    and is executed as `.\buildauthnet.ps1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the scripts, you may need to change the Powershell Execution Policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, there are security considerations with this change, so change the
    Execution Policy back when you're done.
  prefs: []
  type: TYPE_NORMAL
- en: A simpler method on Windows is to simply paste these commands into a PowerShell
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Linking Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the older days of Docker, we were told to link containers using the `--link` option.
    With that option, Docker would create entries in `/etc/hosts` so that one container
    can refer to another container by its hostname. That option also arranged access
    to TCP ports and volumes between linked containers. This allowed the creation
    of multicontainer services, using private TCP ports for communication that exposed
    nothing to processes outside the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we are told that the `--link` option is a legacy feature, and that instead
    we should use `bridge` networks.  In this chapter, we'll focus solely on using
    `bridge` networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the networks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at details about the network with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, this won't show any containers attached to `authnet`. The output
    shows the network name, the IP range of this network, the default gateway, and
    other useful network configuration information. Since nothing is connected to
    the network, let's get started with building the required containers.
  prefs: []
  type: TYPE_NORMAL
- en: The db-userauth container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a network, we can start connecting containers to that network.
    And then we'll explore the containers to see how private they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a script, `startdb.sh`, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you will need to name the script `startdb.ps1` instead, and put
    the text all on one line rather than extend the lines with backslashes. And, the
    volume mounted on `/var/lib/mysql` must be created separately. Use these commands
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When run, the container will be named `db-userauth`. To give a little bit of
    security, the `root` password has been randomized. We've instead defined a database
    named `userauth`, accessed by a user named `userauth`, using the password `userauth`.
    That's not exactly secure, so feel free to choose better names and passwords.
    The container is attached to the `authnet` network.
  prefs: []
  type: TYPE_NORMAL
- en: There are two `--volume` options that we must talk about. In Dockerese, a volume
    is a thing inside a container that can be mounted from outside the container.
    In this case, we're defining a volume, `userauth-data`, in the host filesystem
    to be mounted as `/var/lib/mysql` inside the container. And, we're defining a
    local `my.cnf` file to be used as `/etc/my.cnf` inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: For the Windows version, we have two changes to the `--volume` mounts. We specify
    the mount for `/etc/my.cnf` as `$PSScriptRoot\my.cnf:/etc/my.cnf`, because that's
    how you reference a local file in Powershell.
  prefs: []
  type: TYPE_NORMAL
- en: For `/var/lib/mysql,` we referenced a separately created volume. The volume
    is created using the `volume create` command, and with that command there is no
    opportunity to control the location of the volume. It's important that the volume
    lives outside the container, so that the database files survive the destruction/creation
    cycle for this container.
  prefs: []
  type: TYPE_NORMAL
- en: Taken together, those settings mean the database files and the configuration
    file live outside the container and will therefore exist beyond the lifetime of
    one specific container. To get the `my.cnf`, you will have to run the container
    once without the ``--volume `pwd`/my.cnf:/etc/my.cnf`` option so you can copy
    the default `my.cnf` file into the `authnet` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script once without that option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is similar to what we saw earlier, but for this newline giving the
    randomized password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell you the `db-userauth` container is attached to `authnet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We see our database has been created and it''s empty. But we did this so we
    could grab the `my.cnf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `docker cp` command is used for copying files in and out of containers.
    If you've used `scp`, the syntax will be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the `my.cnf` file, there''s a big pile of setting changes you
    might want to make. The first specific change to make is commenting out the line
    reading `socket=/var/lib/mysql/mysql.sock`, and the second is adding a line reading 
    `bind-address = 0.0.0.0`. The purpose with these changes is to configure the MySQL
    service to listen on a TCP port rather than a Unix domain socket. This makes it
    possible to communicate with the MySQL service from outside the container. The
    result would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now stop the `db-userauth` service, and remove the container, as we did earlier.
    Edit the `startdb` script to enable the line mounting `/etc/my.cnf` into the container,
    and then restart the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we inspect the `authnet` network, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the `authnet` network has the network number `172.18.0.0/16`,
    and the `db-userauth` container was assigned `172.18.0.2`. This level of detail
    is rarely important, but it is useful on our first time through to carefully examine
    the setup so we understand what we''re dealing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we said earlier, there is a DNS server running within the Docker bridge
    network setup, and domain name resolution is configured to use `nodots`. That''s
    so Docker container names are the DNS hostname for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Access the MySQL server using the container name as the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile for the authentication service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `users` directory, create a file named `Dockerfile` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfiles describe the installation of an application on a server. See [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for documentation. They document assembly of the bits in a Docker container image,
    and the instructions in a Dockerfile are used to build a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` command specifies a pre-existing image from which to derive a given
    image. We talked about this earlier; you can build a Docker container starting
    from an existing image. The official Node.js Docker image ([https://hub.docker.com/_/node/](https://hub.docker.com/_/node/))
    we're using is derived from `debian:jessie`. Therefore, commands available within
    the container are what Debian offers, and we use `apt-get` to install more packages. We
    use Node.js 10  because it supports ES6 modules and the other features we've been
    using.
  prefs: []
  type: TYPE_NORMAL
- en: The `ENV` commands define environment variables. In this case, we're using the
    same environment variables defined within the user authentication service, except
    we have a new `REST_LISTEN` variable. We'll take a look at that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` commands are where we run the shell commands required to build the
    container. The first thing is to make a `/userauth` directory that will contain
    the service source code. The `COPY` command copies files into that directory.
    And then we'll need to run an `npm install` so that we can run the service. But
    first we use the `WORKDIR` command to move the current working directory into
    `/userauth` so that the `npm install` is run in the correct place. We also install
    the requisite Debian packages so that any native code Node.js packages can be
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended that you always combine `apt-get update` with `apt-get install` in
    the same command line, like this, because of the Docker build cache. When rebuilding
    an image, Docker starts with the first changed line. By putting those two together,
    you ensure that `apt-get update` is executed any time you change the list of packages
    to be installed. For a complete discussion, see the documentation at [https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this command is `npm install --unsafe-perm`. The issue here is
    that these commands are being run as `root`. Normally, when `npm` is run as `root`,
    it changes its user ID to a nonprivileged user. This can cause failure, however,
    and the `--unsafe-perm` option prevents changing the user ID.
  prefs: []
  type: TYPE_NORMAL
- en: The `EXPOSE` command informs Docker that the container listens on the named
    TCP port. This does not expose the port beyond the container.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the CMD command documents the process to launch when the container
    is executed. The `RUN` commands are executed while building the container, while CMD says
    what's executed when the container starts.
  prefs: []
  type: TYPE_NORMAL
- en: We could have installed PM2 in the container, then used a PM2 command to launch
    the service.  But Docker is able to fulfill the same function, because it supports
    automatically restarting a container if the service process dies. We'll see how
    to do this later.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the authentication service for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re using a different file for `SEQUELIZE_CONNECT`. Create a new file named `users/sequelize-docker-mysql.yaml` containing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that instead of `localhost` as the database host, we use `db-userauth`.
    Earlier, we explored the `db-userauth` container and determined that was the hostname
    of the container. By using `db-userauth` in this file, the authentication service
    will use the database in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to take care of the environment variable named `REST_LISTEN`. Previously,
    the authentication server had listened only to `http://localhost:3333`. We'd done
    this for security purposes, that is, to limit which processes could connect to
    the service. Under Docker, we need to connect to this service from outside its
    container so that other containers can connect to this service. Therefore, it
    must listen to connections from outside the localhost.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `users-server.mjs`, we need to make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That is, if the `REST_LISTEN` variable exists, the REST server is told to listen
    to whatever it says, otherwise the service is to listen to `localhost`. With the
    environment variable in the Dockerfile, the authentication service will listen
    to the world (`0.0.0.0`). Are we throwing caution to the wind and abrogating our
    fiduciary duty in keeping the sacred trust of storing all this user identification
    information? No. Be patient. We'll describe momentarily how to connect this service
    and its database to `AuthNet` and will prevent access to `AuthNet` by any other
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the authentication service Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `users/package.json` add the following line to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we've put the configuration environment variables into `package.json`.
    In this case, the configuration environment variables are in the Dockerfile. This
    means we need a way to run the server with no environment variables other than
    those in the Dockerfile. With this `scripts`entry, we can do `npm run docker` and
    then the Dockerfile environment variables will supply all configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build the authentication service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `docker build` command builds a container from a Dockerfile. As we said
    earlier, the process begins with the image defined in the `FROM` command. Then
    the build proceeds step by step, and the output shows literally each step as it
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a script, `authnet/startserver.sh`, or on Windows call it `startserver.ps1`,
    containing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This launches the newly built container, giving it the name `userauth`, attaching
    it to `authnet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That starts the user authentication service. On Windows, start it as `.\startserver.ps1`.
    You should recall that it's a REST service, and therefore running it through its
    paces is done with `users-add.js` and the other scripts. But, since we did not
    expose a public port from the service we must run those scripts from inside the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: We determine whether a container exposes a public port in one of two ways. The
    easiest is running `docker ps -a` and viewing the container listing details. There
    is a column marked PORTS, and for `userauth` we see `3333/tcp`. This is a side
    effect of the EXPOSE command in the Dockerfile. If that port were exposed, it
    would appear in the PORTS column as `0.0.0.0:3333->3333/tcp`. Remember the goal
    for the `userauth` container, and `authnet` overall, was that it would not be
    publicly accessible because of security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Authnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore what we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This prints out a large JSON object describing the network, and its attached
    containers, which we've looked at before. If all went well, we'll see there are
    now two containers attached to `authnet` where there'd previously been only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into the `userauth` container and poke around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `/userauth` directory is inside the container and is exactly the files placed
    in the container using the `COPY` command, plus the installed files in `node_modules:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test of adding a user to the authentication service works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The process listing is interesting to study. Process PID 1 is the `npm run docker` command
    in the Dockerfile. Processes proceed from there to the `node` process running
    the actual server.
  prefs: []
  type: TYPE_NORMAL
- en: A `ping` command proves the two containers are available as hostnames matching
    the container names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can log in to the `db-userauth` container and inspect the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully Dockerized the user authentication service in two containers,
    `db-userauth` and `userauth`. We've poked around the insides of a running container
    and found some interesting things. But, our users need the fantastic Notes application
    to be running, and we can't afford to rest on our laurels.
  prefs: []
  type: TYPE_NORMAL
- en: Creating FrontNet for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the back half of our system set up in a Docker container, as well as
    the private bridge network to connect the backend containers. We now need to set up
    another private bridge network, `frontnet`, and attach the other half of our system
    to that network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory, `frontnet`, which is where we''ll develop the tools to
    build and run that network. In that directory, create a file, `buildfrontnet.sh`,
    or on Windows, `buildfrontnet.ps1`, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and create the `frontnet` bridge network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We'll proceed from here similarly to how `authnet` was created. However, we
    can work more quickly because we've already gone over the basics.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL container for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the `authnet` directory, copy the `my.cnf` and `startdb.sh` files into
    the `frontnet` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `my.cnf` file can probably be used unmodified, but we have a few changes
    to make to the `startdb.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, name the file `startdb.ps1` containing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes are simple substitutions to transliterate from `userauth` to `notes`.
    And then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For Windows, simply run `.\startdb.ps1`.
  prefs: []
  type: TYPE_NORMAL
- en: This database will be available at the `db-notes` domain name on `frontnet`.
    Because it's attached to `frontnet`, it won't be reachable by containers connected
    to `authnet`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Since `db-notes` is on a different network segment, we've achieved separation.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `notes` directory, create a file named `Dockerfile` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the Dockerfile we used for the authentication service. We're
    using the environment variables from `notes/package.json`, plus a new one, and
    there's a couple of new tricks involved here, so let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious change is the number of `COPY` commands. The Notes application
    is a lot more involved given the number of subdirectories full of files that must
    be installed.  We start by creating the top-level directories of the Notes application
    deployment tree. Then, one by one, we copy each subdirectory into its corresponding
    subdirectory in the container filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In a `COPY` command, the trailing slash on the destination directory is important.
    Why?  Because the documentation says that the trailing slash is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is: Why use multiple `COPY` commands such as this?  This would
    have been trivially simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: But, it is important to avoid copying the `node_modules` directory into the
    container. The container `node_modules` must be built inside the container, because
    the container operating system is almost certainly different to the host operating
    system. Any native code modules must be built for the correct operating system.
    That constraint led to the question of concisely copying specific files to the
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve developed a process to build a Bootstrap 4 theme, which we developed
    in Chapter 6,* Implementing the Mobile-First Paradigm*.  If you have a Bootstrap
    4 theme to build, simply uncomment the corresponding lines in the Dockerfile.
    Those lines move the working directory to `/notesapp/theme` and then run the scripts
    to build the theme. A new script is required in `theme/package.json` to remove
    the `theme/node_modules` directory after the theme has been built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a new `SEQUELIZE_CONNECT` file. Create `models/sequelize-docker-mysql.yaml`
    containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This will access a database server on the `db-notes` domain name using the named
    database, username, and password.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `USER_SERVICE_URL` variable no longer accesses the authentication
    service at `localhost`, but at `userauth`. The `userauth` domain name is currently only
    advertised by the DNS server on AuthNet, but the Notes service is on FrontNet.
    This means we'll have to connect the `userauth` container to the FrontNet bridge
    network so that its name is known there as well. We'll get to that in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](19304f2b-9d3e-45a4-981b-1b7cd269895b.xhtml)*, Multiuser Authentication
    the Microservice Way* we discussed the need to protect the API keys supplied by
    Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't want to commit the keys in the source code, but they have to go somewhere. 
    Placeholders are in the Dockerfile for specifying `TWITTER_CONSUMER_KEY` and `TWITTER_CONSUMER_SECRET`.
  prefs: []
  type: TYPE_NORMAL
- en: The value for `TWITTER_CALLBACK_HOST` needs to reflect where Notes is deployed.
    Right now, it is still on your laptop, but by the end of the chapter, it will
    be deployed to the server, and, at that time, it will need the IP address or domain
    name of the server.
  prefs: []
  type: TYPE_NORMAL
- en: A new variable is `NOTES_SESSIONS_DIR` and the matching `VOLUME` declaration.
    If we were to run multiple Notes instances, they could share session data by sharing
    this volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supporting the `NOTES_SESSIONS_DIR` variable requires one change in `app.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a hardcoded directory name, we can use an environment variable to
    define the location where session data is stored. Alternatively, there are `sessionStore`
    implementations for various servers such as REDIS, enabling session data sharing
    between containers on separate host systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `notes/package.json,` add these scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As for the authentication server, this lets us build the container and then,
    within the container, we can run the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `frontnet` directory, create a file named `startserver.sh`, or,
    on Windows, `startserver.ps1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the authentication service, the Notes application container must export
    a port to the public. Otherwise, the public will never be able to enjoy this wonderful
    creation we're building. The `-p` option is how we instruct Docker to expose a
    port.
  prefs: []
  type: TYPE_NORMAL
- en: The first number is a TCP port number published from the container, and the
    second number is the TCP port inside the container. Generally speaking, this option
    maps a port inside the container to one reachable by the public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, run `.\startserver.ps1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can connect our browser to `http://localhost:3000` and start
    using the Notes application. But we''ll quickly run into a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/030b00fc-4919-4709-bbf5-37d41b7e5b6d.png)'
  prefs: []
  type: TYPE_IMG
- en: The user experience team is going to scream about this ugly error message, so
    put it on your backlog to generate a prettier error screen. For example, a flock
    of birds pulling a whale out of the ocean is popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error means that Notes cannot access anything at the host named `userauth`.
    That host does exist, because the container is running, but it''s not on `frontnet`,
    and is not reachable from the `notes` container. Namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect FrontNet and AuthNet, you''ll see the containers attached to
    each do not overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the architecture diagram at the beginning of the chapter, we showed a connection
    between the `notes` and `userauth` containers. The connection is required so `notes`
    can authenticate its users. But that connection does not exist, yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, a simple change to `startserver.sh` (`startserver.ps1`) does
    not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is conceptually simple to specify multiple `--net` options when starting
    a container, Docker does not support this. It silently accepts the command as
    shown, but only connects the container to the last network mentioned in the options.
    Instead, Docker requires that you take a second step to attach the container to
    a second network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: With no other change, the Notes application will now allow you to log in and
    start adding and editing notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a glaring architecture question staring at us. Do we connect the `userauth`
    service to `frontnet`, or do we connect the `notes` service to `authnet`?    To
    verify that either direction solves the problem, run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first time around, we connected `notes` to `authnet`, then we disconnected
    it from `authnet`, and then connected `userauth` to `frontnet`. That means we
    tried both combinations and, as expected, in both cases `notes` and `userauth`
    were able to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: This is a question for security experts since the consideration is the attack
    vectors available to any intruders. Suppose Notes has a security hole allowing
    an invader to gain access. How do we limit what is reachable via that hole?
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary observation is that by connecting `notes` to `authnet`, `notes`
    not only has access to `userauth`, but also to `db-userauth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This sequence reconnects `notes` to `authnet`, and demonstrates the ability
    to access both the `userauth` and `db-userauth` containers. Therefore, a successful
    invader could access the `db-userauth` database, a result we wanted to prevent.
    Our diagram at the beginning showed no such connection between `notes` and `db-userauth`.
  prefs: []
  type: TYPE_NORMAL
- en: Given that our goal for using Docker was to limit the attack vectors, we have
    a clear distinction between the two container/network connection setups. Attaching `userauth`
    to `frontnet` limits the number of containers that can access `db-userauth`. For
    an intruder to access the user information database, they must first break into
    `notes`, and then break into `userauth`. Unless, that is, our amateur attempt
    at a security audit is flawed.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the location of MySQL data volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `db-userauth` and `db-notes` Dockerfiles contain `VOLUME /var/lib/mysql`,
    and when we started the containers, we gave `--volume` options, assigning a host
    directory for that container directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We can easily see this connects a host directory, so it appears within the container
    at that location. Simply inspecting the host directory with tools such as `ls`
    shows that files are created in that directory corresponding to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: The `VOLUME` instruction instructs Docker to create a directory outside the
    container and to map that directory so that it's mounted inside the container
    on the named path. The `VOLUME` instruction by itself doesn't control the directory
    name on the host computer. If no `--volume` option is given, Docker still arranges
    for the content of said directory to be kept outside the container. That's useful,
    and at least the data is available outside the container, but you haven't controlled
    the location.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we restart the `db-notes` container without using the `--volume` option
    for `/var/lib/mysql`, we can inspect the container to  discover where Docker put
    the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: That's not exactly a user-friendly pathname, but you can snoop into that directory
    and see that indeed the MySQL database is stored there. The simplest way to use
    a user-friendly pathname for a volume is with the `--volume` options we showed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage we have is to easily switch databases. For example, we could
    test Notes with pre-cooked test databases full of notes written in Swahili (`notes-data-swahili`),
    Romanian (`notes-data-romanian`), German (`notes-data-german`) and English (`notes-data-english`).
    Each test database could be stored in the named directory, and testing against
    the specific language is as simple as running the notes container with different
    `--volume` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, if you restart the `notes` container with the `--volume` option,
    you can inspect the container and see the directory is mounted on the directory
    you specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: With the `--volume` options, we have controlled the location of the host directory
    corresponding to the container directory.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to note is that controlling the location of such directories
    makes it easier to make backups and take other administrative actions with that
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Docker deployment of background services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the scripts we've written so far, the Docker container is run in the foreground. 
    That makes it easier to debug the service since you see the errors.   For a production
    deployment, we need the Docker container detached from the terminal, and an assurance
    that it will restart itself automatically.   Those two attributes are simple to
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply change this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `-it` option is what causes the Docker container to run in the foreground. 
    Using these options causes the Docker container to run detached from your terminal,
    and if the service process dies, the container will automatically restart.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the cloud with Docker compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is cool that we can create encapsulated instantiations of the software
    services we've created. But the promise was to use the Dockerized application
    for deployment on cloud services. In other words, we need to take all this learning
    and apply it to the task of deploying Notes on a public internet server with a
    fairly high degree of security.
  prefs: []
  type: TYPE_NORMAL
- en: We've demonstrated that, with Docker, Notes can be decomposed into four containers
    that have a high degree of isolation from each other, and from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another glaring problem: our process in the previous section was partly
    manual, partly automated. We created scripts to launch each portion of the system,
    which is a good practice according to the Twelve Factor Application model. But
    we did not automate the entire process to bring up Notes and the authentication
    services. Nor is this solution scalable beyond one machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the last issue first—scalability. Within the Docker ecosystem,
    several **Docker orchestrator** services are available. An Orchestrator automatically
    deploys and manages Docker containers over a group of machines. Some examples
    of Docker Orchestrators are Docker Swarm (which is built into the Docker CLI),
    Kubernetes, CoreOS Fleet, and Apache Mesos. These are powerful systems able to
    automatically increase/decrease resources as needed, to move containers from one
    host to another, and more. We mention these systems for your further study as
    your needs grow.
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/))
    will solve the other problems we've identified. It lets us easily define and run
    several Docker containers together as a complete application. It uses a YAML file,
    `docker-compose.yml`, to describe the containers, their dependencies, the virtual
    networks, and the volumes. While we'll be using it to describe the deployment
    onto a single host machine, Docker compose can be used for multimachine deployments,
    especially when combined with Docker Swarm. Understanding Docker compose will
    provide a basis upon which to understand/use the other tools, such as Swarm or
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker machine ([https://docs.docker.com/machine/overview/](https://docs.docker.com/machine/overview/))
    is a tool for installing Docker Engine on virtual hosts, either local or remote,
    and for managing Docker containers on those hosts. We'll be using this to provision
    a server on a cloud hosting service, and push containers into that server. It
    can also be used to provision a virtual host on your laptop within a VirtualBox
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, ensure Docker compose and Docker machine are installed. If
    you've installed Docker for Windows or Docker for Mac, both are installed along
    with everything else. On Linux, you must install both separately by following
    the instructions at the links given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a directory, `compose`, as a sibling to the `users`
    and `notes` directories. In that directory, create a file named `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: That's the description of the entire Notes deployment. It's at a fairly high
    level of abstraction, roughly equivalent to the options on the command-line tools
    we've used so far. Further details are located inside the Dockerfiles, which are
    referenced from this compose file.
  prefs: []
  type: TYPE_NORMAL
- en: The `version` line says that this is a version 3 compose file. The version number
    is inspected by the `docker-compose` command, so it can correctly interpret its
    content. The full documentation is worth reading at  [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major sections used here: **services**, **volumes**, and **networks**.
    The services section describes the containers being used, the networks section
    describes the networks, and the volumes section describes the volumes. The content
    of each section matches the intent/purpose of the commands we ran earlier. The
    information we''ve already dealt with is all here, just rearranged.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two database containers, `db-userauth` and `db-notes`. Both reference
    the Dockerhub image using the `image` tag. For the databases, we did not create
    a Dockerfile, but instead built directly from the Dockerhub image. The same happens
    here in the compose file.
  prefs: []
  type: TYPE_NORMAL
- en: For the `userauth` and `notes` containers, we created a Dockerfile. The directory
    containing that file is referenced by the `build` tag. To build the container,
    `docker-compose` looks for a file named `Dockerfile` in the named directory. There
    are more options for the `build` tag, which are discussed in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The `container_name` attribute is equivalent to the `--name` attribute and specifies
    a user-friendly name for the container. We must specify the container name in
    order to specify the container hostname in order to do Docker-style service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: The `command` tag overrides the `CMD` tag in the Dockerfile. We've specified
    this for the two database containers, so we can instruct MySQL to bind to IP address
    `0.0.0.0`. Even though we didn't create a Dockerfile for the database containers,
    there is a Dockerfile created by the MySQL maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: The `networks` attribute lists the networks to which this container must be
    connected and is exactly equivalent to the `--net` argument. Even though the `docker`
    command doesn't support multiple `--net` options, we can list multiple networks
    in the compose file. In this case, the networks are bridge networks. As we did
    earlier, the networks themselves must be created separately, and in a compose
    file, that's done in the *networks* section.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the networks in our system is a `bridge` network. This fact is described
    in the compose file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `expose` attribute declares which ports are exposed from the container,
    and is equivalent to the `EXPOSE` tag. The exposed ports are not published outside
    the host machine, however. The `ports` attribute declares the ports that are to
    be published. In the ports declaration, we have two port numbers: the first being
    the published port number and the second being the port number inside the container.
    This is exactly equivalent to the `-p` option used earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: The `notes` container has a few environment variables, such as `TWITTER_CONSUMER_KEY`
    and `TWITTER_CONSUMER_SECRET`, that you may prefer to store in this file rather
    than in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The `depends_on` attribute lets us control the start up order. A container that
    depends on another will wait to start until the depended-upon container is running.
  prefs: []
  type: TYPE_NORMAL
- en: The `volumes` attribute describes mappings of a container directory to a `host`
    directory. In this case, we've defined two volume names, `db-userauth-data` and `db-notes-data`,
    and then used them for the volume mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the volumes, start with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The volume names are the same as in the compose file, but with `compose*_*`
    tacked on the front.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect the volume location using the `docker` command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s preferable, you can specify a pathname in the `compose` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This is the same configuration we made earlier. It uses the `userauth-data`
    and `notes-data` directories for the MySQL data files for their respective database
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: The `environment` tag describes the environment variables that will be received
    by the container. As before, environment variables should be used to inject configuration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The `restart` attribute controls what happens if, or when, the container dies.
    When a container starts, it runs the program named in the `CMD` instruction, and
    when that program exits, the container exits. But what if that program is meant
    to run *forever*, shouldn't Docker know it should restart the process? We could
    use a background process supervisor, such as Supervisord or PM2\. But, we can
    also use the Docker `restart` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restart` attribute can take one of the following four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no` – do not restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failure:count` – restart up to *N* times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always` – always restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped` – start the container unless it was explicitly stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the Notes application with Docker compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Windows, we're able to run the commands in this section unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before deploying this to a server, let''s run it on our laptop using `docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We first needed to stop and delete the existing containers. Because the compose
    file wants to launch containers with the same names as we''d built earlier, we
    also have to remove the existing containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Once that's done, we can build the containers, `docker-compose build`, and then
    start them running, `docker-compose up`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test is to execute a shell in `userauth` to run our user database
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've proved that the authentication service will work, and, by the
    way, created a user account, you should be able to browse to the Notes application
    and run it through its paces.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try pinging different containers to ensure that the application
    network topology has been created correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Docker command-line tools to explore the running containers and networks,
    you'll see they have new names. The new names are similar to the old names, but
    prefixed with the string `compose_`. This is a side effect of using Docker compose.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `docker-compose` attaches to the containers so that logging output
    is printed on the Terminal. Output from all four containers will be intermingled
    together. Thankfully, each line is prepended by the container name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done testing the system, simply type *CTRL* +* C* on the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: To avoid running with the containers attached to the Terminal, use the `-d`
    option. This says to detach from the Terminal and run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate way to bring down the system described in the compose file is with
    the `docker-compose down` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `up` command builds, recreates, and starts the containers. The build step
    can be handled separately using the `docker-compose build` command. Likewise,
    starting and stopping the containers can be handled separately by using the `docker-compose
    start` and `docker-compose-stop` commands.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, your command shell should be in the directory containing the `docker-compose.yml`
    file. That's the default name for this file. This can be overridden with the `-f`
    option to specify a different filename.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to cloud hosting with Docker compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've verified on our laptop that the services described by the compose file
    work as intended. Launching the containers is now automated, fixing one of the
    issues we named earlier. It's now time to see how to deploy to a cloud-hosting
    provider. This is where we turn to Docker machine.
  prefs: []
  type: TYPE_NORMAL
- en: Docker machine can be used to provision Docker instances inside a VirtualBox
    host on your laptop. What we'll be doing is provisioning a Docker system on DigitalOcean. The `docker-machine` command
    comes with drivers supporting a long list of cloud-hosting providers.  It's easy
    to adapt the instructions shown here for other providers, simply by substituting
    a different driver.
  prefs: []
  type: TYPE_NORMAL
- en: After signing up for a DigitalOcean account, click on the API link in the dashboard.
    We need an API token to grant `docker-machine` access to the account. Go through
    the process of creating a token and save away the token string you're given. The
    Docker website has a tutorial at [https://docs.docker.com/machine/examples/ocean/](https://docs.docker.com/machine/examples/ocean/).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the token in hand, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `digitalocean` driver is, as we said earlier, used with Digital Ocean. The
    Docker website has a list of drivers at [https://docs.docker.com/machine/drivers/](https://docs.docker.com/machine/drivers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of information is printed here about things being set up. The most important
    is the message at the end. A series of environment variables are used to tell
    the `docker` command where to connect to the Docker Engine instance. As the messages
    say, run: `docker-machine env sandbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the environment variables used to access the Docker host we just created.
    You should also go to your cloud-hosting provider dashboard and see that the host
    has been created. This command also gives us some instructions to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This shows that we have a Docker Engine instance running in a host at our chosen
    cloud-hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting test at this point is to run `docker ps -a` on this Terminal,
    and then to run it in another Terminal that does not have these environment variables.
    That should show the cloud host has no containers at all, while your local machine
    may have some containers (depending on what you currently have running):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've verified that we can launch a container on the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to build our containers for the new machine. Because we''ve
    switched the environment variables to point to the new server, these commands
    cause action to happen there rather than inside our laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Because we changed the environment variables, the build occurs on the `sandbox`
    machine rather than on our laptop, as previously.
  prefs: []
  type: TYPE_NORMAL
- en: This will take a while because the Docker image cache on the remote machine
    is empty. Additionally, building the `notesapp` and `userauth` containers copies
    the entire source tree to the server and runs all build steps on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The build may fail if the default memory size is 500 MB, the default on DigitalOcean
    at the time of writing. If so, the first thing to try is resizing the memory on
    the host to at least 2 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the build is finished, launch the containers on the remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the containers start, you should test the `userauth` container as we''ve
    done previously. Unfortunately, the first time you do this, that command will
    fail. The problem is these lines in the `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the build occurs on the remote machine, and the `docker-machine`
    command does not copy the named file to the server. Hence, when Docker attempts
    to start the container, it is unable to do so because that volume mount cannot
    be satisfied because the file is simply not there. This, then, means some surgery
    on `docker-compose.yml`, and to add two new Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make these changes to `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Instead of building the database containers from a Docker image, we're now building
    them from a pair of Dockerfiles. Now we must create those two Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `authnet`, create a file named `Dockerfile` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This copies certain settings from what had been the `db-userauth` description
    in `docker-compose.yml`. The important thing is that we now `COPY` the `my.cnf` file
    rather than use a volume mount.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `frontnet`, create a `Dockerfile` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is the same, but with a few critical values changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making these changes, we can now build the containers, and launch them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a working build, and can bring up the containers, let's inspect
    them and verify everything works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute a shell in `userauth` to test and set up the user database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, this verifies that the `userauth` service works, that
    the remote containers are set up, and that we can proceed to using the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is: What''s the URL to use?  The service is not on `localhost`,
    because it''s on the remote server. We don''t have a domain name assigned, but
    there is an IP address for the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Docker tells you the IP address, which you should use as the basis of the URL.
    Hence, in your browser, visit `http://IP-ADDRESS:3000`
  prefs: []
  type: TYPE_NORMAL
- en: With Notes deployed to the remote server, you should check out all the things
    we've looked at previously. The bridge networks should exist, as shown previously,
    with the same limited access between containers. The only public access should
    be port `3000` on the `notes` container.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to set the `TWITTER_CALLBACK_HOST` environment variable appropriately
    for your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our database containers mount a volume to store the data, let''s see
    where that volume landed on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Those are the expected volumes, one for each container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Those are the directories, but they''re not located on our laptop. Instead,
    they''re on the remote server. Accessing these directories means logging into
    the remote server to take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point, you can inspect the directories corresponding to these volumes
    and see that they indeed contain MySQL configuration and data files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also find that the Docker command-line tools will work. The process
    list is especially interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70d8826e-ebbb-4a78-bc23-074165ed0bfe.png)'
  prefs: []
  type: TYPE_IMG
- en: Look closely at this and you see a process corresponding to every container
    in the system. These processes are running in the host operating system. Docker
    creates layers of configuration/containment around those processes to create the
    appearance that the process is running under a different operating system, and
    with various system/network configuration files, as specified in the container
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The claimed advantage Docker has over virtualization approaches, such as VirtualBox,
    is that Docker is very lightweight. We see right here why Docker is lightweight:
    there is no virtualization layer, there is only a containerization process (`docker-containerd-shim`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re satisfied that Notes is working on the remote server, you can
    shut it down and remove it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This shuts down all the containers at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This shuts down the remote machine. The cloud-hosting provider dashboard will
    show that the Droplet has stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can go ahead and delete the Docker machine instance as well,
    if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: And, if you're truly certain you want to delete the machine, the preceding command
    does the deed. As soon as you do this, the machine will be erased from your cloud-hosting
    provider dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been quite a journey. We went from an application that existed
    solely on our laptop, to exploring two ways to deploy Node.js applications to
    a production server.
  prefs: []
  type: TYPE_NORMAL
- en: We started by reviewing the Notes application architecture and how that will
    affect deployment. That enabled you to understand what you had to do for server
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Then you learned the traditional way to deploy services on Linux using an init
    script. PM2 is a useful tool for managing background processes in such an environment.
    You also learned how to provision a remote server using a virtual machine hosting
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Then you took a long trip into the land of Docker, a new and exciting system
    for deploying services on machines. You learned how to write a Dockerfile so that
    Docker knows how to construct a service image. You learned several ways to deploy
    Docker images on a laptop or on a remote server. And you learned how to describe
    a multi-container application using Docker compose.
  prefs: []
  type: TYPE_NORMAL
- en: You're almost ready to wrap up this book. You've learned a lot along the way; there
    are two final things to cover.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about both unit testing and functional testing.
    While a core principle of test-driven development is to write the unit tests before
    writing the application, we've done it the other way around and put the chapter
    about unit testing at the end of this book. That's not to say unit testing is
    unimportant, because it is extremely important.
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we'll explore how to harden our application, and application
    infrastructure, against attackers.
  prefs: []
  type: TYPE_NORMAL
