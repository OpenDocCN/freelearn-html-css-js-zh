<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Creating Real-time Web Apps" id="aid-1NA0K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Creating Real-time Web Apps</h1></div></div></div><p>The web has offered an ever more dynamic and interactive user experience. Throughout the 90s, most of the web consisted of static pages or server-side rendered pages. Frames and iframes made it possible to reload parts of the page in a limited way. When Ajax appeared in the mid-2000s, it allowed pages to be much more engaging. Client-side JavaScript could now request data from the server on demand and update the page dynamically.</p><p>Real-time web applications are the next step in this evolution. These are applications where the server pushes data to clients without the clients needing to initiate a request. This allows a user to be notified of new information or for users to interact with each other in real time.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Establishing a two-way communication channel between the client and server</li><li class="listitem">Adding real-time interactivity to our application</li><li class="listitem">Introducing a backend to scale our real-time application across multiple servers</li></ul></div><div class="section" title="Understanding options for real-time communication"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec51"/>Understanding options for real-time communication</h1></div></div></div><p>Real-time web <a id="id418" class="indexterm"/>applications need a bidirectional communication channel between the client and the server. This is any persistent connection that allows the server to push additional data to the client when needed. The WebSockets protocol is the modern standard for this kind of communication and is implemented by most browsers.</p><p>WebSocket connections are initiated via HTTP, but otherwise do not depend on it. The WebSocket protocol defines a way of sending messages bi-directionally over a TCP connection. TCP is the low-level transport protocol that usually underlies HTTP. WebSockets are still a relatively new technology and not fully supported by all clients and servers. Most modern web browsers today do support WebSockets. However, intermediate servers (proxies, firewalls, and load-balancers) can prevent WebSocket connections from working (either through lack of support or intentionally blocking non-HTTP traffic). In these cases, there are alternative ways of achieving real-time communication.</p><p>The EventSource standard defines a way for a server to send events to clients over HTTP and defines a JavaScript API for handling these events. It is not as efficient or widely-supported as WebSockets, but is better supported by some older servers and clients.</p><p>The ultimate fallback is <span class="strong"><strong>long-polling</strong></span>. This is when the client initiates an ordinary (Ajax) request to the server, which <a id="id419" class="indexterm"/>stays open until the server has some data to <a id="id420" class="indexterm"/>send. As soon as the client receives any data, it makes another request to the server for the next message. This introduces additional bandwidth overheads and latency compared to WebSockets, but has the widest support as it just uses ordinary HTTP requests.</p><p>Ideally, a client and server can negotiate to work out the best available type of connection to use. This can be quite a complicated process, though. Fortunately, there are libraries which can handle this for us.</p></div></div>
<div class="section" title="Introducing Socket.IO" id="aid-1O8H61"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec52"/>Introducing Socket.IO</h1></div></div></div><p>Socket.IO is a mature and <a id="id421" class="indexterm"/>well-established library with excellent cross-browser support. It aims to quickly and reliably establish a bidirectional communication channel in a cross-browser compatible way. It provides a consistent abstraction, based on idiomatic JavaScript events, for real-time communication between the client and the server over this channel. If you have ever used SignalR in .NET, you can think of Socket.IO as the JavaScript equivalent.</p><div class="section" title="Implementing a chat room with Socket.IO"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec60"/>Implementing a chat room with Socket.IO</h2></div></div></div><p>Let's implement a chat <a id="id422" class="indexterm"/>lobby for users of our application to <a id="id423" class="indexterm"/>talk to one another. First, we need to install Socket.IO:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install --save socket.io</strong></span>
</pre></div><p>The server-side implementation for this is very simple. We just need to tell Socket.IO that, whenever a user sends a chat message, we want to broadcast this to all connected users as given here <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {
    io.on('connection', (socket) =&gt; {
       socket.on('chatMessage', (message) =&gt; {
           io.emit('chatMessage', message);
        });
    });
 };</pre></div><p>Here, we add a listener to Socket.IO's <code class="literal">connection</code> event. Our listener is fired whenever a new client connects to the application. The <code class="literal">socket</code> variable represents the connection to that specific client.</p><p>The <code class="literal">io</code> parameter shown previously will be a Socket.IO instance. To create one of these, we need to provide a <a id="id424" class="indexterm"/>reference to the HTTP server that will host <a id="id425" class="indexterm"/>our application, so that Socket.IO can add its own connection handling. To keep things tidier, we'll add a new <code class="literal">server</code> module in <code class="literal">src/server.js</code> to set up our server, start our Express application, and initialize Socket.IO:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = require('./config/mongoose').then(mongoose =&gt; {
    const app = require('../src/app')(mongoose);
    const server = require('http').createServer(app);
    const io = require('socket.io')(server);
    require('./realtime/chat')(io);
    
    server.on('close', () =&gt; { 
        require('../src/config/redis.js').quit();
        mongoose.disconnect();
    });
    return server;
});</pre></div><p>This also allows us to simplify the bootstrap script and our integration tests as in <code class="literal">bin/www</code>:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env node

var debug = require('debug')('hangman:server');
var port = normalizePort(process.env.PORT || '3000');
<span class="strong"><strong>require('../src/server').then((server) =&gt; {</strong></span>
    server.listen(port);
    server.on('error', onError);
<span class="strong"><strong>    server.on('listening', onListening.bind(server));</strong></span>
}).catch(function(error) {
    debug(error);
    process.exit(1);
});

...

function onListening() {
<span class="strong"><strong>  var addr = this.address();</strong></span>
  ...
}</pre></div><p>... and in <a id="id426" class="indexterm"/>
<code class="literal">gulpfile.js</code>:</p><div class="informalexample"><pre class="programlisting">gulp.task('integration-test',
         ['lint-integration-test', 'test'], done =&gt; {
  const TEST_PORT = 5000;
  
<span class="strong"><strong>  require('./src/server.js').then((server) =&gt; {</strong></span>
<span class="strong"><strong>    server.listen(TEST_PORT);</strong></span>
<span class="strong"><strong>    server.on('listening', () =&gt; {</strong></span>
      gulp.src('integration-test/**/*.js')
        .pipe(
          ...
        }))
<span class="strong"><strong>        .on('error', error =&gt; server.close(() =&gt; done(error)))</strong></span>
<span class="strong"><strong>        .on('end', () =&gt; server.close(done))</strong></span>
    });
  });
});</pre></div><p>Now we need to add the client-side code to communicate with this service. First, we'll add a place for our chat lobby to the application home page as given here <code class="literal">src/views/index.hjs</code>:</p><div class="informalexample"><pre class="programlisting">    {{/topPlayers}}
    &lt;/ol&gt;
<span class="strong"><strong>    &lt;hr/&gt;</strong></span>
<span class="strong"><strong>    &lt;h3&gt;Lobby&lt;/h3&gt;</strong></span>
<span class="strong"><strong>    &lt;form class="chat"&gt;</strong></span>
<span class="strong"><strong>      &lt;div id="messages"&gt;&lt;/div&gt;</strong></span>
<span class="strong"><strong>      &lt;input id="message"/&gt;&lt;input type="submit" value="Send"/&gt;</strong></span>
<span class="strong"><strong>    &lt;/form&gt;</strong></span>
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Now, we'll create the <a id="id427" class="indexterm"/>client-side script to connect this with the server as given here <code class="literal">src/public/scripts/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
    'use strict';
    var socket = io();
    
    $('form.chat').submit(function(event){
        socket.emit('chatMessage', $('#message').val());
        $('#message').val('');
        event.preventDefault();
    });

    socket.on('chatMessage', function(message){
        $('#messages').append($('&lt;p&gt;').text(message));
    });
});</pre></div><p>Finally, we need to include our new script in the page and include the Socket.IO client-side script that defines <a id="id428" class="indexterm"/>the preceding <code class="literal">io</code> function <a id="id429" class="indexterm"/>
<code class="literal">src/view/index.hjs</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
    ...
    &lt;script src="/scripts/index.js"&gt;&lt;/script&gt;
<span class="strong"><strong>    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>    &lt;script src="/scripts/chat.js"&gt;&lt;/script&gt;</strong></span>
  &lt;/head&gt;
  &lt;body&gt;
    ...</pre></div><p>Note that we haven't created the <code class="literal">socket.io.js</code> script anywhere. This is served as a result of attaching Socket.IO to our server in <code class="literal">src/server.js</code>. Since we don't define the <code class="literal">io</code> variable in our own script, we need to let ESLint know that it exists as a global variable as given in <code class="literal">gulpfile.js</code>:</p><div class="informalexample"><pre class="programlisting">gulp.task('lint-client', function() {
     return gulp.src('src/public/**/*.js')
         .pipe(eslint({ envs: [ 'browser', 'jquery' ],
<span class="strong"><strong>                        globals: { io: false } }))</strong></span>
         .pipe(eslint.format())
         .pipe(eslint.failAfterError());
 });  </pre></div><p>Now, if we open up our application in two browser windows, they can send chat messages to each other!</p></div></div>
<div class="section" title="Scaling real-time Node.js applications" id="aid-1P71O1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Scaling real-time Node.js applications</h1></div></div></div><p>Since our chat <a id="id430" class="indexterm"/>messages are being relayed via the server, clients can currently only communicate with other clients connected to the same server. This is a problem if we want to scale our application horizontally across many servers.</p><p>This is easy to fix, but tricky to demonstrate. To do so, we need to have two separate instances of our application running. This will be more realistic and more useful if they are also using the same shared databases for persistence. So we need to start up MongoDB and Redis, then start two instances of our application on different ports (so that they don't collide).</p><p>This means running all of the following commands (replacing the dbpath of MongoDB as appropriate for your setup):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; redis-server</strong></span>
<span class="strong"><strong>&gt; mongod --dbpath C:\data\mongodb</strong></span>
<span class="strong"><strong>&gt; set MONGODB_URL=mongodb://localhost/hangman</strong></span>
<span class="strong"><strong>&gt; set REDIS_URL=redis://127.0.0.1:6379/</strong></span>
<span class="strong"><strong>&gt; set PORT=3000</strong></span>
<span class="strong"><strong>&gt; npm start</strong></span>
<span class="strong"><strong>&gt; set PORT=3001</strong></span>
<span class="strong"><strong>&gt; npm start</strong></span>
</pre></div><p>The commands that start the database or application servers also occupy the current console. So, to be able to run all of these commands, we need to execute them in separate windows or tell them to execute in the background. On Windows, this can be achieved with the following batch script:</p><div class="informalexample"><pre class="programlisting">@echo off
START /B redis-server
START /B mongod --dbpath C:\data\mongodb
set MONGODB_URL=mongodb://localhost/hangman
set REDIS_URL=redis://127.0.0.1:6379/
SLEEP 2
set PORT=3000
START /B npm start
SLEEP 1
set PORT=3001
START /B npm start</pre></div><p>Now you can connect separate browsers to a separate application instance at <code class="literal">http://localhost:3000</code> and <code class="literal">http://localhost:3001</code>. Notice that two clients connected to the same application instance can receive messages from each other, but not from clients on the other application instance.</p><p>To resolve this, we need a shared backend through which all the applications can communicate. Redis is <a id="id431" class="indexterm"/>a perfect candidate for this.</p><div class="section" title="Using Redis as a backend"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec61"/>Using Redis as a backend</h2></div></div></div><p>Socket.IO <a id="id432" class="indexterm"/>makes use of the <span class="strong"><strong>adapter</strong></span> pattern to <a id="id433" class="indexterm"/>support different backends. An adapter is just a wrapper for converting one interface into another. Socket.IO has a standard backend interface and various adapters to allow different implementations to work with this interface. By default, it uses an in-memory adapter that is limited to a single process. However, the Socket.IO project also provides an adaptor for using Redis as a backend:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install socket.io-redis --save</strong></span>
</pre></div><p>Once installed, using this is simply a matter of telling Socket.IO where to find our Redis instance (we skip this in test environments where we only have one application process) as given here <code class="literal">src/server.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
 
module.exports = require('./config/mongoose').then(mongoose =&gt; {
    const app = require('../src/app')(mongoose);
    const server = require('http').createServer(app);
    const io = require('socket.io')(server);

<span class="strong"><strong>    if (process.env.REDIS_URL &amp;&amp; process.env.NODE_ENV !== 'test') {</strong></span>
<span class="strong"><strong>        const redisAdapter = require('socket.io-redis');</strong></span>
<span class="strong"><strong>        io.adapter(redisAdapter(process.env.REDIS_URL));</strong></span>
<span class="strong"><strong>    }</strong></span>

    require('./realtime/chat')(io);
     
    ...
    return server;
 });</pre></div><p>And that's it! We don't require any other changes to our code to support scalability. If you restart your application instances now, you should find that clients can communicate between them.</p></div></div>
<div class="section" title="Integrating Socket.IO with Express" id="aid-1Q5IA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Integrating Socket.IO with Express</h1></div></div></div><p>So far, apart <a id="id434" class="indexterm"/>from sharing the same server, the Socket.IO and <a id="id435" class="indexterm"/>Express parts of our application are completely independent. While it's good that they are loosely coupled, some cross-cutting concerns may be relevant to both.</p><p>For example, both parts of our application should have a mutually consistent way of identifying the current user. This is especially important if they are to come together to provide a single coherent user experience.</p><p>First, let's extend our user middleware to provide the current user's name as well as their ID, by looking them up in the user service as given here <code class="literal">src/middleware/users.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

<span class="strong"><strong>module.exports = (service) =&gt; {</strong></span>
    const uuid = require('uuid');

    return function(req, res, next) {
        let userId = req.cookies.userId;
        if (!userId) {
            userId = uuid.v4();
            res.cookie('userId', userId);
            req.user = {
                id: userId
            };
            next();
<span class="strong"><strong>        } else {</strong></span>
<span class="strong"><strong>            service.getUsername(userId).then(username =&gt; {</strong></span>
<span class="strong"><strong>                req.user = {</strong></span>
<span class="strong"><strong>                    id: userId,</strong></span>
<span class="strong"><strong>                    name: username</strong></span>
<span class="strong"><strong>                };</strong></span>
<span class="strong"><strong>                next();</strong></span>
<span class="strong"><strong>            });</strong></span>
<span class="strong"><strong>        }</strong></span>
    };
};</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>You can find updated tests for this middleware in the book's companion code.</p></div><p>This will mean <a id="id436" class="indexterm"/>injecting our user service as a dependency, like we do <a id="id437" class="indexterm"/>for the other middleware modules (that is, routes) in our application as given in <code class="literal">src/app.js</code>:</p><div class="informalexample"><pre class="programlisting">  ...

  let gamesService = require('./service/games')(mongoose);
  let usersService = require('./service/users');

<span class="strong"><strong>  let users = require('./middleware/users')(usersService);</strong></span>
  let routes = require('./routes/index')(gamesService, usersService);
  let games = require('./routes/games')(gamesService, usersService);
  let profile = require('./routes/profile')(usersService);
  ...</pre></div><p>The interesting part is allowing Socket.IO to make use of this middleware. Socket.IO has its own concept of middleware very similar to that of Express. Recall that Express middleware functions take <a id="id438" class="indexterm"/>parameters for the current request, response, and a <code class="literal">next</code> callback. Socket.IO middleware functions just take a communication socket and a <code class="literal">next</code> callback. However, we can access the original HTTP handshake that initiated the socket. This allows us to adapt our Express middleware to Socket.IO middleware and use it as follows, in <code class="literal">src/server.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
 
module.exports = require('./config/mongoose').then(mongoose =&gt; {
    let app = require('../src/app')(mongoose);
    let server = require('http').createServer(app);
    let io = require('socket.io')(server);

    if (process.env.REDIS_URL) {
        let redisAdapter = require('socket.io-redis');
        io.adapter(redisAdapter(process.env.REDIS_URL));
    }

<span class="strong"><strong>    io.use(adapt(require('cookie-parser')()));</strong></span>
<span class="strong"><strong>    const usersService = require('./services/users.js');</strong></span>
<span class="strong"><strong>    io.use(adapt(require('./middleware/users')(usersService)));</strong></span>

    require('./realtime/chat')(io);
    
    ...
    return server;
}); 

<span class="strong"><strong>function adapt(expressMiddleware) {</strong></span>
<span class="strong"><strong>    return (socket, next) =&gt; {</strong></span>
<span class="strong"><strong>        expressMiddleware(socket.request, socket.request.res, next);</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Now the user <a id="id439" class="indexterm"/>middleware will run for Socket.IO as well as regular HTTP requests, making user data available to Socket.IO as well. Let's use this to <a id="id440" class="indexterm"/>include usernames in our chat. First, we need to update our server as given in <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {
    io.on('connection', (socket) =&gt; {
        socket.on('chatMessage', (message) =&gt; {
<span class="strong"><strong>            io.emit('chatMessage', {</strong></span>
<span class="strong"><strong>                username: socket.request.user.name,</strong></span>
<span class="strong"><strong>                message: message</strong></span>
<span class="strong"><strong>            });</strong></span>
        });
    });
 }</pre></div><p>Notice that Socket.IO allows us to send objects instead of simple strings as the event payload. Now we <a id="id441" class="indexterm"/>just need to make use of this in the client as given here <code class="literal">src/public/scripts/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
    'use strict';

    var socket = io();
    ...
<span class="strong"><strong>    socket.on('chatMessage', function(data){</strong></span>
        $('#messages').append(
<span class="strong"><strong>            $('&lt;p&gt;').text(data.message)</strong></span>
<span class="strong"><strong>                .prepend($('&lt;b&gt;').text(data.username)));</strong></span>
});</pre></div><p>If you now open the application in separate browser sessions and specify different usernames, you will see these in the chat output.</p></div>
<div class="section" title="Directing Socket.IO messages" id="aid-1R42S1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Directing Socket.IO messages</h1></div></div></div><p>Now that we have <a id="id442" class="indexterm"/>access to usernames, we can also announce the arrival of users in the lobby. We can do this by extending our Socket.IO connection event handler as given here <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {

    io.on('connection', (socket) =&gt; {
<span class="strong"><strong>        const username = socket.request.user.name;</strong></span>

<span class="strong"><strong>        if(username) {</strong></span>
<span class="strong"><strong>            socket.broadcast.emit('chatMessage', {</strong></span>
<span class="strong"><strong>                username: username,</strong></span>
<span class="strong"><strong>                message: 'has arrived',</strong></span>
<span class="strong"><strong>                type: 'action'</strong></span>
<span class="strong"><strong>            });</strong></span>
<span class="strong"><strong>        }</strong></span>

        socket.on('chatMessage', (message) =&gt; {
            io.emit('chatMessage', {
<span class="strong"><strong>                username: username,</strong></span>
                message: message
            });
        });
    });
 }</pre></div><p>Here, we use <code class="literal">socket.broadcast.emit</code>, rather than <code class="literal">io.emit</code>, to send the event to all clients except for the current socket. Note that we also add extra data to the message. This time we add a <code class="literal">type</code> <a id="id443" class="indexterm"/>field (set to <code class="literal">'action'</code> for the arrival message) to allow different visual presentation of different types of message. We can achieve this by updating our client-side code to set additional CSS classes based on the message type as given here <code class="literal">src/public/scripts/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">    socket.on('chatMessage', function(data){
        $('#messages').append(
<span class="strong"><strong>            $('&lt;p&gt;').text(data.message).addClass(data.type)</strong></span>
                .prepend($('&lt;b&gt;').text(data.username)));
    });</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>You can find the CSS file for the example application in the companion code.</p></div><p>Let's also enforce that users have to choose a username before they can take part in the chat as given here <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {
    io.on('connection', (socket) =&gt; {
        ...
        socket.on('chatMessage', (message) =&gt; {
<span class="strong"><strong>            if (!username) {</strong></span>
<span class="strong"><strong>                socket.emit('chatMessage', {</strong></span>
<span class="strong"><strong>                    message: 'Please choose a username',</strong></span>
<span class="strong"><strong>                    type: 'warning'</strong></span>
<span class="strong"><strong>                });</strong></span>
<span class="strong"><strong>            } else {</strong></span>
                io.emit('chatMessage', {
                    username: username,
                    message: message
                });                
<span class="strong"><strong>            }</strong></span>
        });
    });
 }</pre></div><p>Here, we use <a id="id444" class="indexterm"/>
<code class="literal">socket.emit</code> rather than <code class="literal">io.emit</code> to send a message to the client associated with the current socket.</p></div>
<div class="section" title="Testing Socket.IO applications" id="aid-1S2JE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Testing Socket.IO applications</h1></div></div></div><p>Now let's look <a id="id445" class="indexterm"/>at how we can test our chat module. To talk to it from our tests we'll need a Socket.IO client. The Socket.IO project provides another package for this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install socket.io-client --save-dev</strong></span>
</pre></div><p>The infrastructure for our tests consists of setting up a server and multiple clients as given here <code class="literal">test/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
describe('chat', function() {
    const expect = require('chai').expect;
    let server, io, url, createUser, createdClients = [];
    
    beforeEach(done =&gt; {
        server = require('http').createServer();
        
        server.listen((err) =&gt; {
            if (err) {
                done(err);
            } else {
                const addr = server.address();
                url = 'http://localhost:' + addr.port + '/chat'; 

                io = require('socket.io')(server);
                require('../../src/realtime/chat.js')(io);
                
                done();
            }
        });
    });
    
    afterEach(done =&gt; {
        createdClients.forEach(client =&gt; client.disconnect());
        server.close(done);
    });

    const createClient = require('socket.io-client');
    createUser = (name, room) =&gt; {
        let user = {
            name: name,
            client: createClient(url)
        };
        createdClients.push(user.client);
        return user;
    };
});</pre></div><p>Here, we create an <a id="id446" class="indexterm"/>HTTP server without specifying an address, so that the OS will assign us an available port. We then use this this server to host our chat implementation.</p><p>Since we're running the chat module in isolation, we don't have our users middleware available, so will need an alternative way to provide usernames. We can do this with a stub middleware in our tests that reads usernames directly from a header:</p><div class="informalexample"><pre class="programlisting">'use strict';

describe('chat', function() {
    const expect = require('chai').expect;
    let server, io, url, createUser, createdClients = [];
    
    beforeEach(done =&gt; {
        server = require('http').createServer();
        
        server.listen((err) =&gt; {
            if (err) {
                done(err);
            } else {
                const addr = server.address();
                url = 'http://localhost:' + addr.port;

                io = require('socket.io')(server);
<span class="strong"><strong>                io.use((socket, next) =&gt; {</strong></span>
<span class="strong"><strong>                    socket.request.user = {</strong></span>
<span class="strong"><strong>                        name: socket.request.headers.username</strong></span>
<span class="strong"><strong>                    };</strong></span>
<span class="strong"><strong>                    next();</strong></span>
<span class="strong"><strong>                });</strong></span>
                
                require('../../src/realtime/chat.js')(io);
                
                done();
            }
        });
    });
    
    ...

    const createClient = require('socket.io-client');
    createUser = (name, room) =&gt; {
<span class="strong"><strong>        let headers = {};</strong></span>
<span class="strong"><strong>        if (name) {</strong></span>
<span class="strong"><strong>            headers.username = name;</strong></span>
<span class="strong"><strong>        }</strong></span>
                
        let user = {
            name: name,
<span class="strong"><strong>            client: createClient(url, { extraHeaders: headers})</strong></span>
        };
        createdClients.push(user.client);
        user.client.emit('joinRoom', room);
        
        return user;
    };
});</pre></div><p>Now we are ready to <a id="id447" class="indexterm"/>implement our tests. The first two, for messages initiated from the server, are quite simple:</p><div class="informalexample"><pre class="programlisting">    it('warns unnamed users to choose a username', done =&gt; {
        let unnamedUser = createUser();
        unnamedUser.client.emit('chatMessage', 'Hello!');
        unnamedUser.client.on('chatMessage', (data) =&gt; {
            expect(data.message).to.contain('choose a username');
            expect(data.username).to.be.undefined;
            expect(data.type).to.equal('warning');
            done();
        });
    });
    
    it('broadcasts arrival of named users', done =&gt; {
        let connectedUser = createUser();
        let newUser = createUser('User1');
        connectedUser.client.on('chatMessage', (data) =&gt; {
            expect(data.message).to.contain('arrived');
            expect(data.username).to.equal(newUser.name);
            expect(data.type).to.equal('action');
            done();
        });
    });</pre></div><p>Testing messages sent <a id="id448" class="indexterm"/>between clients requires a little more care to capture each client's receipt of the message:</p><div class="informalexample"><pre class="programlisting">    it('emits messages from named users back to all users', done =&gt; {
        let namedUser = createUser('User1');
        let otherUser = createUser();
        let messageReceived = function(data) {
            this.received = data;
            if (namedUser.received &amp;&amp; otherUser.received) {
                [namedUser.received, otherUser.received]
                .forEach(received =&gt; {
                    expect(received.message).to.equal('Hello!');
                    expect(received.username)
                        .to.equal(namedUser.name);
                });
                done();
            }
        };
        otherUser.client.on('chatMessage',
                            messageReceived.bind(otherUser));
        namedUser.client.on('chatMessage',
                            messageReceived.bind(namedUser));
        namedUser.client.emit('chatMessage', 'Hello!');
    });</pre></div></div>
<div class="section" title="Organizing Socket.IO applications"><div class="titlepage" id="aid-1T1402"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Organizing Socket.IO applications</h1></div></div></div><p>Now that we have a <a id="id449" class="indexterm"/>chat lobby on the index page of our application, it's a bit odd that users have to reload the page (and lose the chat history) to find out about new games. We can use Socket.IO to update these as well.</p><div class="section" title="Exposing real-time updates to the model"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Exposing real-time updates to the model</h2></div></div></div><p>First, we'll <a id="id450" class="indexterm"/>need our games service itself to expose events for when games are added or removed. Here we use the Mongoose-provided <code class="literal">post</code> method to hook into persistence operations on games as given here <code class="literal">src/services/games.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

<span class="strong"><strong>const EventEmitter = require('events');</strong></span>
<span class="strong"><strong>const emitter = new EventEmitter();</strong></span>

module.exports = (mongoose) =&gt; {
    let Game = mongoose.models['Game'];

    if (!Game) {
        let Schema = mongoose.Schema;
        let gameSchema = new Schema({
            word: String,
            setBy: String
        });

        ...
        
<span class="strong"><strong>        gameSchema.post('save', game =&gt;</strong></span>
<span class="strong"><strong>            emitter.emit('gameSaved', game));</strong></span>
<span class="strong"><strong>        gameSchema.post('remove', game =&gt;</strong></span>
<span class="strong"><strong>            emitter.emit('gameRemoved', game));</strong></span>
        
        Game = mongoose.model('Game', gameSchema);
    }
    
    return {
        ...
        get: id =&gt; Game.findById(id),
<span class="strong"><strong>        events: emitter</strong></span>
    };
};

<span class="strong"><strong>module.exports.events = emitter;</strong></span>
</pre></div><p>We expose <a id="id451" class="indexterm"/>an <span class="strong"><strong>event emitter</strong></span> to allow other modules to subscribe to events for when games are added or removed. Event emitters are a built-in feature of Node.js, which provide a simple way to expose custom events. Note that the Mongoose <code class="literal">Schema</code> class is itself an event emitter, so we could just expose this directly. However, this would be leaking details about the implementation of our games service.</p><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>Again, you can find new tests for these changes in the companion code.</p></div></div><div class="section" title="Organizing Socket.IO applications using namespaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec63"/>Organizing Socket.IO applications using namespaces</h2></div></div></div><p>Real-time <a id="id452" class="indexterm"/>chat and real-time updates to the list of games are quite distinct functional areas of our application. Socket.IO <a id="id453" class="indexterm"/>provides <span class="strong"><strong>namespaces</strong></span> to allow us to organise events. This allows us to still use a single connection between the client and the server, without having to worry about clashing event names between different functional areas. This is very useful as applications become larger and more complex.</p><p>Putting our chat functionality under a namespace is a very simple change on the client and the server (and in our tests).</p><p>The following code is from <code class="literal">src/public/scripts/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
    'use strict';
<span class="strong"><strong>    var socket = io('/chat');</strong></span>
    ...</pre></div><p>The following code is from <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {
<span class="strong"><strong>     const namespace = io.of('/chat');</strong></span>
<span class="strong"><strong>     </strong></span>
<span class="strong"><strong>     namespace.on('connection', (socket) =&gt; {</strong></span>
         ...
         
         socket.on('chatMessage', (message) =&gt; {
             if (!username) {
                 ...
             } else {
<span class="strong"><strong>                 namespace.emit('chatMessage', {</strong></span>
                     username: username,
                     message: message
                 });
             }
         });
     });
 };</pre></div><p>The following code is from <code class="literal">test/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">                const addr = server.address();
<span class="strong"><strong>                url = 'http://localhost:' + addr.port + '/chat';</strong></span>
</pre></div><p>Now we can add a new Socket.IO module for exposing changes to games. This simply needs to forward events from our games service to connected Socket.IO clients.</p><p>We add the following code under<a id="id454" class="indexterm"/> <code class="literal">src/realtime/games.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = (io, service) =&gt; {
    io.of('/games').on('connection', (socket) =&gt; {
        forwardEvent('gameSaved', socket);
        forwardEvent('gameRemoved', socket);
    });

    function forwardEvent(name, socket) {
        service.events.on(name, game =&gt; {
            if (game.setBy !== socket.request.user.id) {
                socket.emit(name, game.id);
            }
        });
    }
};</pre></div><p>We also need <a id="id455" class="indexterm"/>to include this module in the initialisation of our server.</p><p>The following code is from <code class="literal">src/server.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
 
module.exports = require('./config/mongoose').then(mongoose =&gt; {
    ...

    require('./realtime/chat')(io);
<span class="strong"><strong>    const gamesService = require('./services/games.js')(mongoose);</strong></span>
<span class="strong"><strong>    require('./realtime/games')(io, gamesService);</strong></span>
    
    ...
    return server;
});</pre></div><p>The corresponding client just needs to connect to the <code class="literal">/games</code> namespace and update the list accordingly.</p><p>The following code is from <code class="literal">src/public/scripts/index.js</code>:</p><div class="informalexample"><pre class="programlisting">    var socket = io('/games');
    var availableGames = $('#availableGames');
    
    socket.on('gameSaved', function(game) {
        availableGames.append(
            '&lt;li id="' + game + '"&gt;&lt;a href="/games/' + game + '"&gt;' +
                game + '&lt;/a&gt;&lt;/li&gt;');
    });
    socket.on('gameRemoved', function(game) {
        $('#' + game).remove();
    });</pre></div><p>The following code is added to <code class="literal">src/views/index.hjs</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;h3&gt;Games available to play&lt;/h3&gt;
    &lt;ul id="availableGames"&gt;
      {{#availableGames}}
<span class="strong"><strong>        &lt;li id="{{id}}"&gt;&lt;a href="/games/{{id}}"&gt;{{id}}&lt;/a&gt;&lt;/li&gt;</strong></span>
      {{/availableGames}}
    &lt;/ul&gt;</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip12"/>Tip</h3><p>In practice, it would better to use a client-side MV* library such as Knockout or Backbone to update the page based on model changes, rather than manipulating the DOM like this, but that's outside the scope of this book.</p></div><p>Now, if you <a id="id456" class="indexterm"/>open the application in <a id="id457" class="indexterm"/>two separate browser sessions and create a new game in one browser window, it will immediately appear in the other.</p></div><div class="section" title="Partitioning Socket.IO clients using rooms"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Partitioning Socket.IO clients using rooms</h2></div></div></div><p>The final <a id="id458" class="indexterm"/>piece of functionality we're going to add in this chapter is the ability for users playing the <a id="id459" class="indexterm"/>same game to talk to one another. We can re-use the chat functionality we've already written for this. However, we want a separate chat for the lobby on the homepage and for each game.</p><p>Socket.IO provides <span class="strong"><strong>rooms</strong></span> for directing messages to different groups of clients. Remember that namespaces allow us to divide our application into different functional areas. Rooms allow us to divide up clients within the same functional area.</p><p>Rooms in <a id="id460" class="indexterm"/>Socket.IO are just string identifiers and we add clients to a room using the <code class="literal">socket.join</code> function. We'll introduce a new <code class="literal">joinRoom</code> event to allow our clients to ask our server to add them to a particular room. We'll respond to this event on the server as follows:</p><p>The following code is from <code class="literal">src/realtime/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = io =&gt; {
    const namespace = io.of('/chat');
    
    namespace.on('connection', (socket) =&gt; {
        const username = socket.request.user.name;
        
<span class="strong"><strong>        socket.on('joinRoom', (room) =&gt; {</strong></span>
<span class="strong"><strong>            socket.join(room);</strong></span>
            if (username) {
<span class="strong"><strong>                socket.broadcast.to(room).emit('chatMessage', {</strong></span>
                    username: username,
                    message: 'has arrived',
                    type: 'action'
                });
            }
            
            socket.on('chatMessage', (message) =&gt; {
                if (!username) {
                    ...
                } else {
<span class="strong"><strong>                    namespace.to(room).emit('chatMessage', {</strong></span>
                        username: username,
                        message: message
                    });
                }
            });
            
<span class="strong"><strong>            socket.on('disconnect', () =&gt; {</strong></span>
<span class="strong"><strong>                if (username) {</strong></span>
<span class="strong"><strong>                    socket.broadcast.to(room).emit('chatMessage', {</strong></span>
<span class="strong"><strong>                        username: username,</strong></span>
<span class="strong"><strong>                        message: 'has left',</strong></span>
<span class="strong"><strong>                        type: 'action'</strong></span>
<span class="strong"><strong>                    });</strong></span>
<span class="strong"><strong>                }</strong></span>
<span class="strong"><strong>            });</strong></span>
        });
    });
};</pre></div><p>Note that we also announce when users leave a particular room, in the same way that we announce <a id="id461" class="indexterm"/>arrivals. Again, you can find the additional test for this functionality in the example code.</p><p>We'll add the <a id="id462" class="indexterm"/>chat functionality into the game page and specify the correct room using a data attribute on the chat form.</p><p>The following code is from <code class="literal">src/views/game.hjs</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hangman - Game #{{id}}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="/scripts/game.js"&gt;&lt;/script&gt;
<span class="strong"><strong>    &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong>    &lt;script src="/scripts/chat.js"&gt;&lt;/script&gt;</strong></span>
    &lt;base href="/games/{{ id }}/"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hangman - Game #{{id}}&lt;/h1&gt;
    &lt;h2 id="word" data-length="{{ length }}"&gt;&lt;/h2&gt;
    &lt;p&gt;Press letter keys to guess&lt;/p&gt;
    &lt;h3&gt;Missed letters:&lt;/h3&gt;
    &lt;p id="missedLetters"&gt;&lt;/p&gt;
<span class="strong"><strong>    &lt;hr/&gt;</strong></span>
<span class="strong"><strong>    &lt;h3&gt;Discussion&lt;/h3&gt;</strong></span>
<span class="strong"><strong>    &lt;form class="chat" data-room="{{id}}"&gt;</strong></span>
<span class="strong"><strong>      &lt;div id="messages"&gt;&lt;/div&gt;</strong></span>
<span class="strong"><strong>      &lt;input id="message"/&gt;&lt;input type="submit" value="Send"/&gt;</strong></span>
<span class="strong"><strong>    &lt;/form&gt;</strong></span>
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The following code is from <code class="literal">src/views/index.hjs</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;hr/&gt;
    &lt;h3&gt;Lobby&lt;/h3&gt;
<span class="strong"><strong>    &lt;form class="chat" data-room="lobby"&gt;</strong></span>
      &lt;div id="messages"&gt;&lt;/div&gt;
      &lt;input id="message"/&gt;&lt;input type="submit" value="Send"/&gt;
    &lt;/form&gt;</pre></div><p>Then we need to update the client script to join the correct room when connecting.</p><p>The following code is from <code class="literal">src/public/scripts/chat.js</code>:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function() {
    'use strict';

    var chat = $('form.chat');
    var socket = io('/chat');
    
<span class="strong"><strong>    socket.emit('joinRoom', chat.data('room')); </strong></span>
<span class="strong"><strong>    chat.submit(function(event){</strong></span>
        ...
    });
    ...
});</pre></div><p>Finally, we need to make sure that typing a chat message doesn't interfere with playing the game. We can do this by only treating keypresses as guesses for the game when the user isn't typing in the chat message box.</p><p>The following <a id="id463" class="indexterm"/>code is from <code class="literal">src/public/javascript/game.js</code>:</p><div class="informalexample"><pre class="programlisting">    $(document).keydown(function(event) {
<span class="strong"><strong>        if (!$('.chat #message').is(':focus') &amp;&amp;</strong></span>
                event.which &gt;= 65 &amp;&amp; event.which &lt;= 90) {
            var letter = String.fromCharCode(event.which);
            if (guessedLetters.indexOf(letter) === -1) {
                guessedLetters.push(letter);
                guessLetter(letter);
            }
        }
    });</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip13"/>Tip</h3><p>You can find new and updated tests for this functionality in the companion code.</p></div><p>Putting this all <a id="id464" class="indexterm"/>together, we can now have multiple clients talking to one another in separate rooms:</p><div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Partitioning Socket.IO clients using rooms"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Summary" id="aid-1TVKI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we have created a real-time client/server communication channel using Socket.IO, used Redis as a backend to scale a real-time application horizontally, integrated Socket.IO with Express middleware, and organized our application using Socket.IO namespaces and rooms.</p><p>As the network connectivity of our application is becoming more complicated, it's more important to test the application on a web server outside of the development or CI environment. In the next chapter, we'll look at how to deploy our application to the web.</p></div></body></html>