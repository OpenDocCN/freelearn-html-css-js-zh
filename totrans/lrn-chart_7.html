<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced Chart.js</h1>
                </header>
            
            <article>
                
<p>When you create data visualizations with Chart.js, most of the work you will have involves preparing the data so that it can be loaded and used by a chart instance. You don't have to worry much about fonts, padding, axes, screen resizing, or responsiveness, since new charts are preconfigured with defaults intended for optimal presentation and interactivity. In the last chapter, we learned how to adjust colors, labels, animations, and other typical configurations in different types of charts. In this chapter, we will explore configuration topics that you won’t use as frequently, and that may require additional coding, extensions, and integration with other libraries, such as tooltip behavior configuration, label generation, scripting, creating mixed charts, creating plugins, using the Chart.js API, and using HTML Canvas with Chart.js.</p>
<p>What you will learn in this chapter includes the following:</p>
<ul>
<li>Tooltip configuration</li>
<li>Advanced legend configuration</li>
<li>Displaying multiple charts</li>
<li>Extending Chart.js</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tooltip configuration</h1>
                </header>
            
            <article>
                
<p>Tooltips are the main feature used by Chart.js to reveal quantitative details about data. While some context comes from the grid, the only way to natively display data right next to the data point is using a tooltip. Of course, you can label the value points as we saw in the previous chapter, but that requires extensions or plugins, and may clutter your chart if used in excess. Chart.js visualizations rely on interactivity to show details. In this section, we will learn how to configure the way these details are displayed.</p>
<p>Tooltips can be configured for each chart using the tooltips key in the <kbd>options</kbd> object. They can also be configured for all charts using <kbd>Chart.defaults.global.tooltips</kbd>. The properties of these objects that you can configure are listed in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 26.584%">
<p><strong>Object</strong></p>
</td>
<td style="width: 29.0634%">
<p><strong>Value</strong></p>
</td>
<td style="width: 43.1129%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>titleSpacing</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Space before and after each <em>title</em> line. Default is <kbd>2</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>bodySpacing</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Space before and after each <em>tooltip</em> item. Default is <kbd>2</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>footerSpacing</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Space before and after each <em>footer</em> line. Default is <kbd>2</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>titleMarginBottom</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Margin after the <kbd>title</kbd> in pixels. Default is <kbd>6</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>footerMarginTop</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Margin before the <kbd>footer</kbd> in pixels. Default is <kbd>6</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>xPadding</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Vertical padding in pixels. Default is <kbd>6</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>yPadding</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>Horizontal padding in pixels. Default is <kbd>6</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>enabled</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Turns tooltips on or off. Default is <kbd>true</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>intersect</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td style="width: 43.1129%">
<p>If <kbd>true</kbd>, the tooltip interaction mode will only be applied when the cursor hovers exactly over the point (inside the <kbd>pointHitRadius</kbd>). If <kbd>false</kbd>, it will be applied at all times. Global default is <kbd>true</kbd>, but changes depending on the type of chart.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>mode</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>nearest</kbd>, <kbd>index</kbd>, <kbd>dataset</kbd>, <kbd>x</kbd>, <kbd>y</kbd>. Deprecated values are <kbd>label</kbd> (same as <kbd>index</kbd>), and <kbd>single</kbd> (behaves like <kbd>nearest</kbd> when intersect: <kbd>true</kbd>).</p>
</td>
<td style="width: 43.1129%">
<p>Selects the tooltip interaction mode. <kbd>nearest</kbd> displays the value of the nearest point (includes one item per tooltip), <kbd>index</kbd> displays values of all the points with the same index (will include an item for each <kbd>dataset</kbd> in the same tooltip), <kbd>dataset</kbd> will display the entire <kbd>dataset</kbd> in a tooltip. Two other modes are available for cartesian scales only: <kbd>x</kbd> will include in the tooltip all items that share the same <kbd>x</kbd> coordinate value, and <kbd>y</kbd> will include all items that share the same <kbd>y</kbd> coordinate value. <kbd>index</kbd> mode, which in Cartesian scales defaults to the <kbd>x</kbd> indexes, can also be set for the <kbd>y</kbd> indexes by adding the property <kbd>axis</kbd>: <kbd>y</kbd>. The global default is <kbd>nearest</kbd> but it changes depending on the type of chart.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>position</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>average</kbd>, <kbd>nearest</kbd>, or a custom position</p>
</td>
<td style="width: 43.1129%">
<p>Defines where the tooltip is positioned in relation to the value point. The default is <kbd>average</kbd>. (You can define your own custom position creating an entry in the <kbd>Chart.Tooltip.positioners</kbd> map that returns an object with <em>x</em> and <em>y</em> coordinates.)</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p class="CDPAlignCenter CDPAlign"><kbd>titleFontFamily</kbd>, <kbd>titleFontStyle</kbd>, <kbd>titleFontColor</kbd>, <kbd>titleFontSize</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>String</kbd> and <kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Font attributes for <kbd>title</kbd> (which is configured using <kbd>callbacks</kbd>).</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p style="padding-left: 30px"><kbd>bodyFontFamily</kbd>, <kbd>bodyFontStyle</kbd>, <kbd>bodyFontColor</kbd>, <kbd>bodyFontSize</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>String</kbd> and <kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Font attributes for <kbd>body</kbd> (which is configured using <kbd>callbacks</kbd>).</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p style="padding-left: 30px"><kbd>footerFontFamily</kbd>, <kbd>footerFontStyle</kbd>, <kbd>footerFontColor</kbd>, <kbd>footerFontSize</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>String</kbd> and <kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Font attributes for <kbd>footer</kbd> (which is configured using <kbd>callbacks</kbd>).</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>caretSize</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Size in pixels of the tooltip arrow. Default is <kbd>5</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>caretPadding</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>Distance of the arrow tip from the tooltip position (example: the value point). Default is <kbd>2</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>cornerRadius</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 43.1129%">
<p>The radius of the rounded rectangle in pixels. Default is <kbd>6</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>backgroundColor</kbd></p>
</td>
<td style="width: 29.0634%">
<p>CSS color</p>
</td>
<td style="width: 43.1129%">
<p>The background color of the tooltip. Default is <kbd>rgba(0,0,0,0.8)</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>multiKeyBackground</kbd></p>
</td>
<td style="width: 29.0634%">
<p>CSS color</p>
</td>
<td style="width: 43.1129%">
<p>The background of the colored box (won't be visible if the <kbd>dataset</kbd> color is opaque). Default is <kbd>#fff</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>borderColor</kbd></p>
</td>
<td style="width: 29.0634%">
<p>CSS color</p>
</td>
<td style="width: 43.1129%">
<p>The border color of the tooltip. Default is <kbd>rgba(0,0,0,0)</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>borderWidth</kbd></p>
</td>
<td style="width: 29.0634%">
<p>Number</p>
</td>
<td style="width: 43.1129%">
<p>The border width of the tooltip. Default is 0.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>displayColors</kbd></p>
</td>
<td style="width: 29.0634%">
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td style="width: 43.1129%">
<p>If <kbd>false</kbd>, hides color boxes. Default is <kbd>true</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 26.584%">
<p><kbd>callbacks</kbd></p>
</td>
<td style="width: 29.0634%">
<p>Object</p>
</td>
<td style="width: 43.1129%">
<p>An object containing several callback functions. See the <em>Tooltip callbacks</em> section on tooltip <kbd>callbacks</kbd> in this chapter.</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Static properties for tooltips (used in the <em>options.tooltips</em> key)</div>
<p>In the following example, several default style properties were changed for the tooltips of a chart instance. Each tooltip will have a gray background, a yellow 3-pixel border, a pink 16-pixel title, an italic body, and a 10-pixel arrow, distant 10 pixels from the data point:</p>
<pre>const data = {<br/>   labels: ["One", "Two", "Three", "Four"],<br/>   datasets: [{label:'Dataset 1',… },{label:'Dataset 2',…}, <br/>   {label:'Dataset 3',…}]<br/>};<br/>new Chart('chart', {type: 'line', data: data,<br/>    options: {<br/>        legend: { display: false },<br/>        tooltips: {<br/>            mode: 'index',<br/>            titleFontSize: 16,<br/>            titleFontColor: 'pink',<br/>            bodyFontStyle: 'italic',<br/>            titleSpacing: 10,<br/>            caretSize: 10,<br/>            caretPadding: 10,<br/>            backgroundColor: 'rgba(10,10,60,.5)',<br/>            borderColor: 'yellow',<br/>            borderWidth: 3,<br/>        },<br/>    }<br/>});</pre>
<p>The full code is in <kbd>Tooltips/tooltip-1.html</kbd>. The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f2a97dd6-cfd2-4e4a-b4ac-2f06d89a9627.png" width="701" height="350"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Tooltip with modified border color and width, background color, title font size and color, body font style,<br/>
caret arrow size, and padding (distance from value point). Code: <em>Tooltips/tooltip-1.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hovering interactions</h1>
                </header>
            
            <article>
                
<p>Tooltips respond to hover events. The next table lists properties of the <kbd>hover</kbd> object, which can be configured globally using <kbd>Chart.defaults.global.hover</kbd> or locally using <kbd>options.hover</kbd>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 25.3444%">
<p><strong>Object</strong></p>
</td>
<td style="width: 32.6446%">
<p><strong>Value</strong></p>
</td>
<td style="width: 40.7713%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 25.3444%">
<p><kbd>intersect</kbd></p>
</td>
<td style="width: 32.6446%">
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td style="width: 40.7713%">
<p>Same behavior as <kbd>tooltip.intersect</kbd>. Tooltips can respond to different intersect states when hovering.</p>
</td>
</tr>
<tr>
<td style="width: 25.3444%">
<p><kbd>mode</kbd></p>
</td>
<td style="width: 32.6446%">
<p><kbd>nearest</kbd>, <kbd>index</kbd>, <kbd>dataset</kbd>, <kbd>x</kbd>, <kbd>y</kbd>. Deprecated values are <kbd>label</kbd> (same as <kbd>index</kbd>), and <kbd>single</kbd> (behaves like <kbd>nearest</kbd> when <kbd>intersect: true</kbd>).</p>
</td>
<td style="width: 40.7713%">
<p>Same behavior as <kbd>tooltip.mode</kbd>. Tooltips can respond to a different mode when hovering.</p>
</td>
</tr>
<tr>
<td style="width: 25.3444%">
<p><kbd>axis</kbd></p>
</td>
<td style="width: 32.6446%">
<p><kbd>x</kbd>, <kbd>y</kbd>, <kbd>xy</kbd></p>
</td>
<td style="width: 40.7713%">
<p>Selects parameters that are used to calculate the distance from the value point to the cursor during a hover event. The default is <kbd>x</kbd>. Horizontal bar charts override this to <kbd>y</kbd> so that <kbd>mode:index</kbd> can select different bars.</p>
</td>
</tr>
<tr>
<td style="width: 25.3444%">
<p><kbd>animationDuration</kbd></p>
</td>
<td style="width: 32.6446%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 40.7713%">
<p>The duration of the animation. This affects any hovering events, including tooltips.</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Configuration options for the hover object</div>
<p>Both the <kbd>hover</kbd> and the tooltip objects support the mode and intersect properties. They are similar, but the <kbd>hover</kbd> property also applies to non-tooltip events (configured with the optional <kbd>onHover</kbd> callback).</p>
<p>If the <kbd>intersect</kbd> property is <kbd>true</kbd>, the event will only be fired if the mouse is directly over a bar or pie slice, or within a certain radius from the value point (for line, scatter, and bubble charts). If <kbd>intersect</kbd> is <kbd>false</kbd>, the event may be fired before the mouse is over the value point.</p>
<p>The <kbd>mode</kbd> property selects the data values related to the event. If <kbd>intersect</kbd> is <kbd>false</kbd>, and <kbd>mode</kbd> is <kbd>nearest</kbd>, it will select the nearest point.</p>
<p>When used in tooltips, the <kbd>mode</kbd> property also determines which items appear in a tooltip. If <kbd>nearest</kbd>, it will show the value that is nearest to the point where the mouse is (typical in scatter and bubble charts). The property can also have the following values:</p>
<ul>
<li><kbd>point</kbd>, showing only items that actually intersect the point (typical inline charts)</li>
<li><kbd>index</kbd>, showing all the points at the same index (typical in a bar or pie chart)</li>
<li><kbd>dataset</kbd>, listing all points in the dataset</li>
</ul>
<p>There are also two more modes that are exclusive to Cartesian scales: <em>x</em> and <em>y</em>, which selects all points with the same values of <em>x</em> and <em>y</em>, respectively.</p>
<p>Edit the <kbd>Tooltips/tooltip-3-modes.html</kbd> file and experiment with different modes. The following screenshots show some tooltip modes applied to a line chart with three datasets:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7b1434ae-e560-4368-87f4-7ef4b269bb4a.png" width="1456" height="785"/></p>
<div class="CDPAlignCenter packt_figref CDPAlign">Tooltip interaction modes: (a) displays single value point; (b) displays items with same index (or x value in this case);<br/>
(c) displays items with same y value; (d) displays all items in a dataset. Code: <em>Tooltips/tooltip-3-modes.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scriptable properties</h1>
                </header>
            
            <article>
                
<p>Tooltips have three properties that receive functions. One allows you to replace the Canvas-generated tooltips with your own custom HTML tooltips. The other two allow sorting of tooltip items (when several items appear in a single tooltip) and filtering. These properties are listed as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Object</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>custom</kbd></p>
</td>
<td>
<p>(<kbd>tooltipModel</kbd>)</p>
</td>
<td>
<p>Used to generate custom HTML tooltips. See the <em>Custom HTML tooltips</em> section on HTML tooltips in this chapter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>filter</kbd></p>
</td>
<td>
<p><kbd>(item, data)</kbd>; array of datasets in <kbd>data.datasets</kbd>; array of labels in <kbd>data.labels</kbd>; <kbd>item.x</kbd> and <kbd>item.y</kbd> contain coordinates of the value point, <kbd>item.xLabel</kbd> and <kbd>item.yLabel</kbd> the labels in each axis, <kbd>item.index</kbd> is the index of the item in the dataset, and <kbd>item.datasetIndex</kbd> is the index of its dataset<span><span>.</span></span></p>
</td>
<td>
<p>A function that returns <kbd>true</kbd> or <kbd>false</kbd> and is called before rendering a tooltip item. If it returns <kbd>false</kbd>, the item will not be rendered.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>itemSort</kbd></p>
</td>
<td>
<p><kbd>(item1, item2)</kbd>; each parameter is an item object with the following properties: <kbd>x</kbd>, <kbd>y</kbd>, <kbd>xLabel</kbd>, <kbd>yLabel</kbd>, <kbd>index</kbd>, <kbd>dataSetIndex</kbd>.</p>
</td>
<td>
<p>Sorts items (in tooltips that contain multiple items). The function returns a number. If <kbd>item1 &lt; item2</kbd> the function should return negative value, if <kbd>item1 &gt; item2</kbd> a positive value should be returned, and zero should be returned if they are equal.</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Scriptable properties for tooltips</div>
<p>Let’s see some examples. In the following code (<kbd>Tooltip/tooltip-4-script-filter.html</kbd>), the filtering function ignores all items that contain <em>y</em> values greater than <kbd>20</kbd>. Additionally, the <kbd>events</kbd> key was used to reduce the events the tooltips respond to. In this example, they are only activated with clicks:</p>
<pre>const data = {<br/>   labels: ["One", "Two", "Three", "Four"],<br/>   datasets: [{label:'Dataset 1',… },{label:'Dataset 2',…},<br/>   {label:'Dataset 3',…}]<br/>};<br/>new Chart('chart', { type: 'line', data: data,<br/>    options: {<br/>        legend: { display: false },<br/>        tooltips: {<br/>            mode: 'index',<br/>            intersect: false,<br/>            filter: (item, data) =&gt; data.datasets[item.datasetIndex]<br/>                                        .data[item.index] &lt; 20<br/>        },<br/>        events: ['click']<br/>    }<br/>});</pre>
<p>The following screenshot shows the result of clicking near the values points of <kbd>index</kbd> 1. Since one of the three points is greater than <kbd>20</kbd>, it doesn't show up in the tooltip:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/73b0319d-9e66-4862-80f2-b972576742dd.png" style="width:41.00em;height:20.67em;" width="730" height="368"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Tooltip with mode: index filtering only items that have a y value less than 20. Code: <em>Tooltip/tooltip-4-script-filter.html.</em></div>
<p>This other example (<kbd>Tooltip/tooltip-5-script-sort.html</kbd>) configures item sorting in <em>ascending</em> order by the <em>y</em> value, in the same chart:</p>
<pre>new Chart('chart', { type: 'line', data: data,<br/>        options: {<br/>            legend: { display: false },<br/>            tooltips: {<br/>                mode: 'index',<br/>                intersect: false,<br/>                itemSort: (a,b) =&gt; b.y - a.y<br/>            },<br/>            events: ['click']<br/>        }<br/>    });</pre>
<p>The result is as follows. Note that the tooltip items are ordered by their <em>y</em> value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/94b914d9-fb05-4b9f-9143-10fba32087f9.png" style="width:40.33em;height:20.42em;" width="731" height="370"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Tooltip with mode: ‘index’ sorting items by their <em>y</em> value. Code: <em>Tooltip/tooltip-5-script-sort.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tooltip callbacks</h1>
                </header>
            
            <article>
                
<p>With <kbd>callbacks</kbd>, you can dynamically generate the text contents and colors of the items displayed in a tooltip based on data values and other accessible attributes. The <kbd>Callbacks</kbd> are properties of the <kbd>tooltips.callbacks</kbd> object, which can be configured globally (<kbd>Chart.defaults.global.tooltips.callbacks</kbd>) or locally per chart instance (<kbd>options.tooltips.callbacks</kbd>). They are listed in the table as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Object</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeTitle</kbd>, <kbd>title</kbd>, <kbd>afterTitle</kbd></p>
</td>
<td>
<p><kbd>(item[], data)</kbd>; array of datasets in <kbd>data.datasets</kbd>; array of labels in <kbd>data.labels</kbd>; each item element contains the following properties: <kbd>x</kbd>, <kbd>y</kbd>, <kbd>xLabel</kbd>, <kbd>yLabel</kbd>, <kbd>index</kbd>, <kbd>dataSetIndex</kbd>.</p>
</td>
<td>
<p>The <kbd>title</kbd> function returns the text for the tooltip title. You can also implement other functions to include text above or below it.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeBody</kbd>, <kbd>body</kbd>, <kbd>afterBody</kbd></p>
</td>
<td>
<p>The <kbd>body</kbd> function returns the text for the tooltip body (including labels). You can also implement other functions to include text above or below it.</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>beforeFooter</kbd>, <kbd>footer</kbd>, <kbd>afterFooter</kbd></p>
</td>
<td>
<p>The <kbd>footer</kbd> function returns the text for the tooltip footer. You can also implement other functions to include text before or after it.</p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>beforeLabel</kbd>, <kbd>label</kbd>, <kbd>afterLabel</kbd></p>
</td>
<td>
<p><kbd>(item,data)</kbd>; array of datasets in <kbd>data.datasets</kbd>; array of labels in <kbd>data.labels</kbd>; <kbd>item.x</kbd> and <kbd>item.y</kbd> contain coordinates of the value point, <kbd>item.xLabel</kbd> and <kbd>item.yLabel</kbd> the labels in each axis, <kbd>item.index</kbd> is the index of the item in the dataset, <kbd>item.datasetIndex</kbd> is the index of its dataset.</p>
</td>
<td>
<p>The <kbd>label</kbd> function returns the text for this label. You can also implement other functions to include text above or below one or more labels.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>labelColor</kbd></p>
</td>
<td>
<p><kbd>(item, chart)</kbd></p>
</td>
<td>
<p>The function returns the color of the text box of an individual item label</p>
</td>
</tr>
<tr>
<td>
<p><kbd>labelTextColor</kbd></p>
</td>
<td>
<p><kbd>(item, chart)</kbd></p>
</td>
<td>
<p>The function returns the color of the text for an individual item label</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Callbacks to create and change the text contents of tooltips</div>
<p>The following example (<kbd>Tooltips/tooltip-6-callback.html</kbd>) uses <kbd>callbacks</kbd> to add extra text to the title, insert separator characters above and below the item labels, and append a <kbd>footer</kbd> containing the average of all the value points:</p>
<pre>new Chart('chart', { type: 'horizontalBar', data: data,<br/>    options: {<br/>        legend: { display: false },<br/>        tooltips: {<br/>            mode: 'index',<br/>            callbacks: {<br/>                footer: (items, data) =&gt; 'Average: ' + (data.datasets<br/>                                        .map(d=&gt;d.data[items[0].index])<br/>                                        .reduce((a,b)=&gt;a+b, 0) /     <br/>                                         items.length)<br/>                                        .toFixed(2),<br/>                title: (items, data) =&gt; "Stage " + items[0].yLabel,<br/>                beforeBody: () =&gt; '============',<br/>                afterBody: () =&gt; '------------------',<br/>            }<br/>        },<br/>        events: ['click']<br/>    }<br/>});</pre>
<p>The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1098f2c7-7876-4a8c-a7fe-03ab830c698b.png" width="724" height="368"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Tooltip with a footer, extra text in title, and separators before and after body created with callbacks. Code: <em>Tooltips/tooltip-6-callback.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom HTML tooltips</h1>
                </header>
            
            <article>
                
<p>The <kbd>Chart.defaults.global.tooltips.custom</kbd> (or <kbd>options.tooltips.custom</kbd>) property receives a function that should build an HTML tooltip and connect it to a tooltip <em>model</em> object passed as a parameter. The tooltip model is a native object that responds to tooltip events and stores tooltip properties. Its properties can be copied and reused inside the HTML tooltip if desired.</p>
<p>The following example (<kbd>Tooltips/tooltip-7-custom.html</kbd>) shows how to create a simple custom HTML tooltip containing an image. The custom tooltip can be created using HTML as shown in the following snippet, or programmatically using DOM, and should initially be hidden (<kbd>opacity: 0</kbd>). When a <kbd>hover</kbd> event activates a tooltip, the model’s opacity changes and the custom tooltip uses this state to make itself visible:</p>
<pre>&lt;html&gt;&lt;head&gt; ...<br/>    &lt;style&gt; <br/>        #tooltip {<br/>            opacity: 0;<br/>            position: absolute;<br/>            margin: 5px;<br/>        }<br/>    &lt;/style&gt;<br/>&lt;/head&gt;&lt;body&gt;<br/>&lt;canvas id="chart" width="200" height="100"&gt;&lt;/canvas&gt;<br/>&lt;div id="tooltip"&gt;&lt;/div&gt;<br/>&lt;script&gt;<br/>    const data = {<br/>        labels: ["jupiter", "saturn", "uranus", "neptune"],<br/>        datasets: [{<br/>           data: [142984,120536,51118,49528],<br/>           backgroundColor: ['#d7191c','#fdae61','#abdda4','#2b83ba'],<br/>        }]<br/>    };<br/>    new Chart('chart', { type: 'bar', data: data,<br/>        options: {<br/>           legend: { display: false },<br/>            title: {<br/>                display: true,<br/>                text: 'Planetary diameters',<br/>                fontSize: 24<br/>            },<br/>            tooltips: {<br/>                mode: 'index',<br/>                intersect: true,<br/>                enabled: false, // turn off canvas tooltips<br/>                custom: function(model) {<br/>                    const tooltip = document.getElementById('tooltip');<br/>                    if(model.opacity === 0) {<br/>                        tooltip.style.opacity = 0;<br/>                        return;                    }<br/>                   if(model.body) {<br/>                        const value = model.body[0].lines[0];<br/>                        tooltip.innerHTML = '&lt;b&gt;'+ value + " km&lt;br/&gt;"<br/>                                            +'&lt;img width="50"  <br/>                                            src="../Images/'<br/>                                            +model.title[0] +'.jpg" <br/>                                            &lt;/img&gt;';<br/>                        const pos =   <br/>                        this._chart.canvas.getBoundingClientRect();<br/>                        tooltip.style.opacity = 1;<br/>                        tooltip.style.left = pos.left + model.caretX +  <br/>                        'px';<br/>                        tooltip.style.top  = -50 + pos.top +  <br/>                        model.caretY + 'px';<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    });<br/>&lt;/script&gt;<br/>&lt;/body&gt;&lt;/html&gt;</pre>
<p>The code extracts the title and filename from the tooltip model’s <kbd>title</kbd>, and the value from the model’s <kbd>body</kbd>. The custom tooltip also used the model’s coordinates to decide where it would be placed. The result is as follows. If you hover over the labels in the <em>x-</em>axis or the bars, the HTML tooltip will be shown above each bar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2cedb051-ab16-446d-835b-1dc75707acc5.png" width="671" height="344"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Bar chart with a custom HTML tooltip that appears when the mouse hovers over a bar or label. Code: <em>Tooltips/tooltip-7-custom.html.</em></div>
<p>Positioning tooltips in pie charts is a bit more complex. For more examples on how to create custom HTML tooltips, check the samples page in the official documentation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advanced legend configuration</h1>
                </header>
            
            <article>
                
<p>Chart.js provides default presentation and behavior for legends and labels. In the previous chapter, we saw some examples of how to change the default behavior by programming the <kbd>onClick</kbd> event handler callback. In this section, we will see how to generate individual labels and, if you need even more control, how to create custom HTML legends.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generating labels</h1>
                </header>
            
            <article>
                
<p>Labels can be generated with the <kbd>generateLabels</kbd> callback property. They should return an item object (the same object that is passed to an <kbd>onClick</kbd> function), which contains the properties listed as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Object</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>text</kbd></p>
</td>
<td>
<p>String</p>
</td>
<td>
<p>The text of the label</p>
</td>
</tr>
<tr>
<td>
<p><kbd>datasetIndex</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td>
<p>The index of the label</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fillStyle</kbd>, <kbd>strokeStyle</kbd>, <kbd>lineCap</kbd>,<br/>
<kbd>lineJoin</kbd>,<br/>
<kbd>lineDash</kbd>, <kbd>lineWidth</kbd>, <kbd>lineDashOffset</kbd></p>
</td>
<td>
<p>The same values as the corresponding Canvas commands</p>
</td>
<td>
<p>Fill and stroke attributes for the legend box</p>
</td>
</tr>
<tr>
<td>
<p><kbd>pointStyle</kbd></p>
</td>
<td>
<p><kbd>circle</kbd>, <kbd>cross</kbd>, <kbd>crossRot</kbd>, <kbd>dash</kbd>, <kbd>line</kbd>, <kbd>rect</kbd>, <kbd>rectRounded</kbd>, <kbd>rectRot</kbd>, <kbd>star</kbd>, <kbd>triangle</kbd></p>
</td>
<td>
<p>If <kbd>legend.labels.usePointStyle</kbd> is <kbd>true</kbd>, the label will use the same point style as the chart. This allows you to set a different point style for the legend labels.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hidden</kbd></p>
</td>
<td>
<p>Boolean</p>
</td>
<td>
<p>If <kbd>true,</kbd> chart elements related to the dataset will not be rendered</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Properties of a legend label object (received by onClick and returned by generateLabels)</div>
<p class="mce-root"/>
<p>The following code shows configuration for legend labels (<kbd>Legend/legend-1-gen-labels.html</kbd>) using a <kbd>generateLabels</kbd> callback. The colored box is configured as a rotated rectangle with <kbd>pointStyle</kbd>. The label’s <kbd>fontSize</kbd> controls the size of the font and point. The border color of each dataset is the fill for each label:</p>
<pre>options: {<br/>    legend: {<br/>        labels: {<br/>            usePointStyle: true,<br/>            fontSize: 14,<br/>            generateLabels: function(chart) {<br/>                const items = [];<br/>                chart.data.datasets.forEach((dataset, i) =&gt; {<br/>                    items.push({<br/>                        text: dataset.label,<br/>                        datasetIndex: i,<br/>                        fillStyle: dataset.borderColor,<br/>                        lineWidth: 0,<br/>                        pointStyle: 'rectRot',<br/>                    });<br/>                });<br/>                return items;<br/>            },<br/>        },  ...<br/>    }<br/>}</pre>
<p>The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e53681a3-8787-492b-9981-fe3cbf0a5925.png" style="width:38.58em;height:19.50em;" width="695" height="351"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Generated labels with different symbols for legends. Code: <em>Legend/legend-1-gen-labels.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTML legends</h1>
                </header>
            
            <article>
                
<p>If you have a very complex legend or wish to display a legend outside the Canvas mixed with the HTML in your page, you can generate custom HTML legends. To create them, you need an empty <kbd>&lt;div&gt;</kbd> block:</p>
<pre>&lt;div id="chart-legends"&gt;&lt;/div&gt;</pre>
<p>So, the legend can be attached to the page’s body. Then, you implement a <kbd>callback</kbd> function for the <kbd>Chart.defaults.global.legendCallback</kbd> property or <kbd>options.legendCallback</kbd> that returns the HTML for the legend. You can create the content dynamically and apply CSS styles with property values copied from the chart. The HTML is generated with <kbd>chart.generateLegend()</kbd>.</p>
<p>It’s easier with an example. The following code implements a simple HTML legend from an HTML list. You can run the full code in <kbd>Legend/legend-2-html-callback.html</kbd>:</p>
<pre>const myChart = new Chart("myChart", {<br/>     type: 'line',<br/>     data: {<br/>         labels: ['Day 1','Day 2','Day 3','Day 4','Day 5','Day 6'],<br/>         datasets: datasets,<br/>     },<br/>     options: {<br/>         legendCallback: function(chart) {<br/>             const labels = document.createElement("ul");<br/>             labels.style.display = 'flex';<br/>             labels.style.justifyContent = 'center';<br/> <br/>             chart.data.datasets.forEach((dataset, i) =&gt; {<br/>                 const item = document.createElement("li");<br/>                 item.style.listStyle = 'none';<br/>                 item.style.display = 'inline';<br/> <br/>                 const icon = document.createElement("div");<br/>                 icon.style.width = icon.style.height = '15px';<br/>                 icon.style.display = 'inline-block';<br/>                 icon.style.margin = '0 6px';<br/>                 icon.style.backgroundColor = dataset.borderColor;<br/> <br/>                 item.appendChild(icon); // add colored square<br/>                 item.innerHTML += dataset.label; // add label text<br/>                 labels.appendChild(item);<br/>             });<br/>             return labels.outerHTML;<br/>         },<br/>         legend: { display: false, position: 'bottom' }<br/>     }<br/> });<br/> <br/> const legend = document.getElementById('chart-legends');<br/> legend.innerHTML = myChart.generateLegend(); // generates HTML</pre>
<p>The new legend doesn’t replace the default label. Unless you wish to display both legends, you should hide the default legend using <kbd>display: false</kbd>.</p>
<p>No behaviors are included in these HTML legends. You need to implement them yourself using JavaScript events. The following screenshot shows the result of the previous code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ff5d2f80-b5d7-40bb-a014-ad4dc9075c58.png" style="width:41.58em;height:23.92em;" width="601" height="346"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Legends created with HTML. Code: <em>Legend/legend-1-gen-labels.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying multiple charts</h1>
                </header>
            
            <article>
                
<p>Many times, you need to display more than one chart in a page to present different sets of data, or different views of the same data using different chart types. You may also wish to draw multiple charts over the same axes, so they can be compared. Another possibility is to use Canvas to draw over or under a chart and add context or additional data. All these scenarios are possible in Chart.js, but they require different strategies.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rendering many charts on one page</h1>
                </header>
            
            <article>
                
<p>You can render several different charts on the same page by simply drawing a separate Canvas for each one.</p>
<p>The following example displays four charts on one page that share the same data. First, we need to set up the canvases using HTML and CSS:</p>
<pre>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>     &lt;script src=".../Chart.min.js"&gt;&lt;/script&gt;<br/>     &lt;style&gt;<br/>         .container {<br/>             width: 98%;<br/>             height: 80vh;<br/>             position: absolute;<br/>         }<br/>         .top {<br/>             height:50%;<br/>             position: relative;<br/>         }<br/>         .col {<br/>             width: 50%;<br/>             position: absolute;<br/>         }<br/>         .col:nth-child(2n-1) {<br/>             left: 50%;<br/>         }<br/>         .footer {<br/>             height: 50%;<br/>             position: relative;<br/>         }<br/>     &lt;/style&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/> &lt;div class="container"&gt;<br/>     &lt;div class="top" width="400" height="200"&gt;<br/>         &lt;div class="col"&gt;&lt;canvas id="chart1"&gt;&lt;/canvas&gt;&lt;/div&gt;<br/>         &lt;div class="col"&gt;&lt;canvas id="chart2"&gt;&lt;/canvas&gt;&lt;/div&gt;<br/>     &lt;/div&gt;<br/>     &lt;div class="top" width="400" height="200"&gt;<br/>         &lt;div class="col"&gt;&lt;canvas id="chart3"&gt;&lt;/canvas&gt;&lt;/div&gt;<br/>         &lt;div class="col"&gt;&lt;canvas id="chart4"&gt;&lt;/canvas&gt;&lt;/div&gt;<br/>     &lt;/div&gt;<br/>     &lt;div class="footer"&gt;<br/>         &lt;form&gt;<br/>           &lt;button type="button" id="changeData"&gt;Get Data&lt;/button&gt;<br/>         &lt;/form&gt;<br/>     &lt;/div&gt;<br/> &lt;/div&gt;<br/> &lt;script&gt; ... &lt;/script&gt;<br/> &lt;/body&gt;<br/> &lt;/html&gt;</pre>
<p>The JavaScript code is shown in the following code. The chart initially loads some static data, but every time the button is pressed, the data changes and the charts are updated. The <kbd>updateData()</kbd> function was created to simulate new random data that is loaded into each chart every time the button is pressed:</p>
<pre>function updateData() {<br/>     charts.forEach(c =&gt; {<br/>         let datasets = 3<br/>         if(c.canvas.id == 'chart4') {<br/>             datasets = 1;<br/>         }<br/>         for(let i = 0; i &lt; datasets; i++) {<br/>             for (let j = 0; j &lt; 6; j++) {<br/>                c.config.data.datasets[i].data[j] =  <br/>                Math.ceil(Math.random() * 25);<br/>             }<br/>         }<br/>         c.update();<br/>     });<br/> }<br/> <br/> Chart.defaults.global.legend.labels.boxWidth = 15;<br/> <br/> const data = [[12, 19, 3, 5, 2, 3],[6, 5, 22, 2, 7, 11],[2, 3, 5, 16,  <br/> 0, 1]],<br/>       labels = ['Day 1','Day 2','Day 3','Day 4','Day 5','Day 6'],<br/>       strokes = <br/>      ['rgba(54,162,235,1)','rgba(255,99,132,1)','rgba(132,255,99,1)'],<br/>       fills=   <br/>      ['rgba(54,162,235,.2)','rgba(255,99,132,.2)',<br/>      'rgba(132,200,99,.2)'];<br/> <br/> const datasets = [];<br/> for(let i = 0; i &lt; data.length; i++) {<br/>     datasets.push({<br/>         label: 'Dataset ' + (i+1),<br/>         data: data[i],<br/>         backgroundColor: fills[i],<br/>         borderColor: strokes[i],<br/>     });<br/> }<br/> <br/> const charts = [];<br/> <br/> charts.push(new Chart("chart1", { type: 'line',<br/>     data: { labels: labels, datasets: datasets }<br/> }));<br/> <br/> charts.push(new Chart("chart2", { type: 'bar',<br/>     data: { labels: labels, datasets: datasets }<br/> }));<br/> <br/> charts.push(new Chart("chart3", { type: 'radar',<br/>     data: { labels: labels, datasets: datasets },<br/>     options: {legend: {display: false }}<br/> }));<br/> <br/> charts.push(new Chart("chart4", { type: 'doughnut',<br/>     data: {<br/>         labels: labels,<br/>         datasets: [datasets[0]].map(d =&gt; ({<br/>             data: d.data,<br/>             backgroundColor: ['#d73027','#fc8d59','#fee090',<br/>                               '#e0f3f8','#91bfdb','#4575b4'],<br/>         })),<br/>     },<br/>     options: {legend: {position: 'left'}}<br/> }));<br/> <br/> document.getElementById("changeData")<br/>         .addEventListener("click", updateData);</pre>
<p>You can see the following result. Run the full code from <kbd>Multiple/ multiple-1-canvas.html</kbd>. Press the button and observe all the charts changing at once:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/339846e3-e8bd-4408-9346-66e8eeb55f77.png" width="979" height="572"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Displaying and updating multiple charts in one page. Code: <em>Multiple/multiple-1-canvas.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixed charts</h1>
                </header>
            
            <article>
                
<p>Mixed charts are charts of different types that share the same axes. A typical example is to overlay a bar chart with one or more line charts. In Chart.js, this is achieved simply by adding a different <kbd>type</kbd> property in one or more datasets.</p>
<p>In the following example (<kbd>Multiple/ multiple-2-mixed.html</kbd>), a bar chart is used to display a set of values and a line chart is used to show the accumulated average:</p>
<pre>const values = [12, 33, 42, 67, 90, 56, 51, 78, 95, 101, 120, 140];<br/>const averages = [];<br/>for(let i = 0; i &lt; values.length; i++) {<br/>     averages[i] = values.slice(0,i+1).reduce((a,b)=&gt;a+b,0)/(i+1);<br/> }<br/> <br/> new Chart("myChart", {<br/>     type: 'bar',<br/>     data: {<br/>         labels: ['Jan','Feb','Mar','Apr','May','Jun','Jul',<br/>                  'Aug','Sep','Oct','Nov','Dec'],<br/>         datasets: [{<br/>             type: 'line',<br/>             label: 'Line dataset (average)',<br/>             data: averages,<br/>             borderColor: 'red',<br/>             fill: false<br/>         },{<br/>             label: 'Bar dataset (totals)',<br/>             data: values,<br/>             borderColor: 'blue',<br/>             backgroundColor: 'rgba(0,0,120,.6)'<br/>         }]<br/>     }<br/> })</pre>
<p>Since <kbd>bar</kbd> is the default type, it doesn’t need a <kbd>type</kbd> property. There could also be additional datasets for each type.</p>
<p>The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/55756f96-cdf8-4df9-998d-127aa5030b65.png" width="734" height="377"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A mixed bar/line chart. Code: <em>Multiple/multiple-2-mixed.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Overlaying a canvas</h1>
                </header>
            
            <article>
                
<p>One way to draw text and graphics on a chart is to draw on the same canvas <em>after</em> the chart is completely loaded. You can do that implementing your code in a function assigned to the <kbd>animation.onComplete</kbd> property. You can also write a simple plugin. Another way to draw over or under a chart is to draw on top of another canvas, and position it <em>exactly</em> over or under your chart canvas. This is easy to do if you won’t be resizing your page. If you do any resizing, you will have to write additional scripts to scale your canvas content to keep it in sync with the chart (in this case, a plugin would be a better solution).</p>
<p>As an example, let's use the <kbd>GeoJSON</kbd> world map we loaded and rendered in <a href="25edc904-3528-40cc-8865-75ccf1fc78eb.xhtml">Chapter 2</a>,<em> Technology Fundamentals</em>, and place it under the bubble chart with the city populations we created in <a href="9c3dd8a3-6dde-42ba-9e93-ae1e2884cc57.xhtml">Chapter 4,</a><em> Creating Charts</em>. Since the map uses a simple cylindrical projection, we just have to make them both the same size, and use CSS absolute positioning to stack one over the other:</p>
<pre>&lt;html lang="en"&gt;<br/> &lt;head&gt;<br/>     &lt;script src="../JavaScript/canvasmap.js" &gt;&lt;/script&gt;<br/>     &lt;script src=".../Chart.min.js"&gt;&lt;/script&gt;<br/>     &lt;script src=".../papaparse.min.js"&gt;&lt;/script&gt;<br/>     &lt;style&gt;<br/>         canvas {<br/>             position: absolute;<br/>             top:  0;<br/>             left: 0;<br/>         }<br/>     &lt;/style&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/> <br/>&lt;canvas id="map" width="1000" height="500"&gt;&lt;/canvas&gt;<br/>&lt;canvas id="my-bubble-chart" width="1000" height="500"&gt;&lt;/canvas&gt;<br/>&lt;script&gt;...&lt;/script&gt;<br/>&lt;/body&gt;&lt;/html&gt;</pre>
<p>The drawings also have to start on the same point and use the same scales. The code uses four functions from <kbd>JavaScript/canvasmap.js</kbd>: a simple script that draws a map from GeoJSON data:</p>
<ul>
<li><kbd>map.setCanvas(canvas)</kbd>: receives the background canvas where the map will be drawn</li>
<li><kbd>map.drawMap(geodata)</kbd>: receives an array of GeoJSON features and draws the map</li>
<li><kbd>map.scaleX(longitude)</kbd> and <kbd>map.scaleY(latitude)</kbd>: converts latitudes and longitudes into pixel coordinates</li>
</ul>
<p>The following code obtains the <kbd>canvas</kbd> context for the map and sets its fill and stroke styles, loads and parses a GeoJSON file containing shapes for a world map, and a CSV containing city names, populations, latitudes, and longitudes. It then calls functions to draw the map and the chart:</p>
<pre>const mapCanvas = document.getElementById("map");<br/>const mapContext = mapCanvas.getContext("2d");<br/> <br/> // Map ocean background<br/> mapContext.fillStyle = 'rgb(200,200,255)';<br/> mapContext.fillRect(0, 0, mapCanvas.width, mapCanvas.height);<br/> <br/> // countries border and background<br/> mapContext.lineWidth = .25;<br/> mapContext.strokeStyle = 'white';<br/> mapContext.fillStyle = 'rgb(50,50,160';<br/> <br/> // setup map canvas<br/> map.setCanvas(mapCanvas); // Function from JavaScript/canvasmap.js<br/> <br/> // load files<br/> const files = ['../Data/world.geojson', '../Data/cities15000.csv'];<br/> const promises = files.map(file =&gt; fetch(file).then(resp =&gt;   <br/> resp.text()));<br/> Promise.all(promises).then(results =&gt; {<br/> <br/>     // Draw the map<br/>     const object = JSON.parse(results[0]);<br/>     map.drawMap(object.features); // function from  <br/>     JavaScript/canvasmap.js<br/> <br/>     // Draw the chart<br/>     const data = Papa.parse(results[1], {header: true});<br/>     drawChart(data.data);  // function described below<br/> });</pre>
<p>The radius of each bubble will be somewhat proportional to the population. This function will return a value that fits well in the map:</p>
<pre>function scaleR(value) {<br/>     const r = Math.floor(value / 100000);<br/>     return r != 0 ? r/10 : .25;<br/> }</pre>
<p>The <kbd>drawChart()</kbd> function uses the parsed CSV datasets to generate an array of location objects, each containing <em>name</em> and the required bubble chart properties: <kbd>r</kbd> radius and <em>x</em>, <em>y</em> coordinates. The generated <kbd>locations</kbd> array is used as the <kbd>dataset</kbd> for the bubble chart:</p>
<pre>function drawChart(datasets) {<br/>     const locations = [];<br/>     datasets.forEach(city =&gt; {<br/>         const obj = {<br/>             x: map.scaleX(+city.longitude), // From  <br/>             JavaScript/canvasmap.js<br/>             y: map.scaleY(-city.latitude),  // From <br/>             JavaScript/canvasmap.js<br/>             r: scaleR(city.population),<br/>             name: city.asciiname<br/>         };<br/>         locations.push(obj);<br/>     });<br/> <br/>     const dataObj = {<br/>         datasets: [<br/>             {   data: locations,<br/>                 backgroundColor: function(context) {...}<br/>             }<br/>         ]<br/>     }</pre>
<p>The <kbd>options</kbd> configuration object must configure scales so that there are no margins. Setting <kbd>min</kbd> and <kbd>max</kbd> properties for the ticks, removing legends and making <kbd>responsive:false</kbd> will guarantee this. Tooltips were also configured to show name and population (this is not shown here, but you can see the full code in <kbd>Multiple/multiple-3-overlay.html</kbd>):</p>
<pre>    const chartObj = {<br/>         type: "bubble",<br/>         data: dataObj,<br/>         options: {<br/>             scales: {<br/>                 xAxes: [{ display: false,<br/>                           ticks: {<br/>                             min: map.scaleX(-180), // match map size  <br/>                             with<br/>                             max: map.scaleX(180)   // canvas size<br/>                         }<br/>                     }<br/>                 ],<br/>                 yAxes: [{ display: false,<br/>                           ticks: {<br/>                             min: map.scaleY(-90), // match map size <br/>                             with<br/>                             max: map.scaleY(90)   // canvas size<br/>                         }<br/>                     }<br/>                 ]<br/>             },<br/>             tooltips: {...}, // see full code<br/>             animation: { duration: 0 },<br/>             responsive: false,<br/>             legend: { display: false }<br/>         }<br/>     };<br/>     new Chart("my-bubble-chart", chartObj);<br/> }</pre>
<p>The final result is as follows. The chart is interactive; you can hover over a large city and get details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5f36f79f-5421-4145-9677-03d88aa42503.png" width="998" height="497"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Two stacked HTML Canvases: one draws an SVG GeoJSON map, the other draws a bubble chart with Chart.js.<br/>
Code: <em>Multiple/multiple-3-overlay.html.</em></div>
<p>Since we used very large files in this example, it takes a while to load the chart and the tooltips may run a bit slow on some systems. A quick way to optimize it is to reduce the data files previously before loading them. You can also filter and only use the large cities, drawing the small ones separately with Canvas.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending Chart.js</h1>
                </header>
            
            <article>
                
<p>There are several ways to extend Chart.js. You may use the prototype methods, callbacks, and event handlers and interact with the rendering process; you can create plugins, which have their own life cycle and are easier to reuse in other charts; and you can extend Chart.js from existing charts or even create new charts and scales.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prototype methods</h1>
                </header>
            
            <article>
                
<p>Prototype methods are automatically called during rendering and updates. You can also call them directly if you need to interfere with the rendering process. They are listed in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>destroy()</kbd></p>
</td>
<td>
<p>Destroys a chart instance. This can be used if you wish to reuse the canvas, or remove the chart completely.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>reset()</kbd></p>
</td>
<td>
<p>Restores the chart to its initial state (after layout and before its initial animation). A new animation can be triggered with <kbd>render()</kbd> or <kbd>update()</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>stop()</kbd></p>
</td>
<td>
<p>Stops an animation loop. This is usually called in an <kbd>onProgress</kbd> callback. Calling <kbd>render()</kbd> or <kbd>update()</kbd> will resume the animation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>clear()</kbd></p>
</td>
<td>
<p>Clears the chart canvas (effective after the chart has finished rendering). You can call <kbd>render()</kbd> or <kbd>update()</kbd> to draw it again.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>resize()</kbd></p>
</td>
<td>
<p>Resizes the chart. Called automatically every time the canvas is resized.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>update(config)</kbd></p>
</td>
<td>
<p>Updates the chart. This should be called after any changes in the datasets. You can include a configuration object with the following properties: <em>duration</em> (Number) to control the redraw animation duration, <em>lazy</em> (boolean) to decide if the animation can be interrupted by others, and <em>easing</em> (String), to select an easing function.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>render(config)</kbd></p>
</td>
<td>
<p>Redraws all chart elements but does not update the chart elements for new data.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>toBase64Image()</kbd></p>
</td>
<td>
<p>Generates the chart as a new base64-encoded PNG image. It can be displayed in an HTML page, or converted into a blob for download.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>generateLegend()</kbd></p>
</td>
<td>
<p>Returns the contents of the <kbd>options.legendCallback</kbd> property (an HTML legend) when called.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getElementAtEvent(e)</kbd></p>
</td>
<td>
<p>Used in event handlers to obtain the element at an event.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getElementsAtEvent(e)</kbd></p>
</td>
<td>
<p>Used in event handlers to obtain all elements with the same data index at an event.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getDatasetAtEvent(e)</kbd></p>
</td>
<td>
<p>Used in event handlers to obtain an array of elements that belong to a dataset.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getDatasetMeta(index)</kbd></p>
</td>
<td>
<p>Returns the metadata for the dataset corresponding to the index.</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Chart.js prototype methods</div>
<p>Some of these methods are used to trigger the execution of life cycle callbacks in plugins. Many are already called automatically and may not be effective in all stages of an animation, since other stages may call methods that undo the desired effect.</p>
<p>In this chapter, we saw an example with <kbd>generateLabels()</kbd>, and in the previous chapter, we used <kbd>update()</kbd>. Event methods are common in event handlers, which receive a JavaScript event.</p>
<p>The <kbd>toBase64Image()</kbd> method generates a Base64 image string. Call it in <kbd>animation.onComplete</kbd> or in any <kbd>callback</kbd> function that is invoked only when the chart is fully drawn (otherwise it may generate a partially drawn or blank image). It returns a string that can be assigned to the <kbd>src</kbd> attribute of an HTML image for rendering on an HTML page:</p>
<pre>&lt;image id="image"&gt;&lt;/image&gt;<br/>…<br/>&lt;script&gt;<br/>new Chart("chart", { type: 'line', data: {…},<br/>     options: {<br/>         animation: {<br/>             onComplete: function () {<br/>                 let image = document.getElementById('image');<br/>                 image.src = this.toBase64Image();<br/>        }<br/>    }<br/>});<br/>&lt;/script&gt;</pre>
<p>You can also use it to create an image for download with a blob function. Use the <kbd>b64-to-blob</kbd> function available from <a href="http://www.npmjs.com/package/b64-to-blob">www.npmjs.com/package/b64-to-blob</a> or via CDN by adding the following line to your page:</p>
<pre>&lt;script src="https://unpkg.com/b64-to-blob"&gt;&lt;/script&gt;</pre>
<p>Add the following tag where you want the download link:</p>
<pre>&lt;a id=’link’ download=’chart.png’&gt;&lt;/a&gt;</pre>
<p>Then, place this code in the <kbd>animation.onComplete</kbd> function:</p>
<pre>const link = document.getElementById('link');<br/>const blob = b64toBlob(image.src.split(',')[1], 'image/png');<br/>link.href = URL.createObjectURL(blob);</pre>
<p>After the chart loads, it will create a link that, when clicked, will download a PNG image of the chart. The full code is in <kbd>Extensions/ext-1-prototype.html</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating plugins</h1>
                </header>
            
            <article>
                
<p>Plugins are the most efficient way to extend Chart.js. A plugin can insert code before and after different phases of the rendering cycle of a chart. At each phase, it can access the chart object and read configurable options. This can be used to change practically any property or behavior of the chart.</p>
<p>Plugins are designed to be reusable. During the previous chapters, we used several popular plugins to extend Chart.js in different ways. They are great to encapsulate complexity, but simple plugins can also be very useful.</p>
<p>In the last example, we created a download link for a PNG version of the chart. If you tried it, you may have noticed that the image has a transparent background. This is OK if your background is white, but if it isn’t, the chart may be hard to read. A naïve approach to fixing the problem would be painting the canvas white using CSS or fill commands. But, it won’t work because Chart.js redraws the canvas during its render cycle. You also need to deal with any animations, resizing, updates, and other events that might reset the background <em>after</em> you changed its color. This is a case for a plugin. With a plugin, you can insert code during the render cycle, draw the background after the canvas is initialized, and before the chart is drawn.</p>
<p>The render life cycle of Chart.js is illustrated as follows. When the chart is loaded for the first time, it performs the <strong>init</strong>, <strong>update</strong>, and <strong>render</strong> steps. Every time the page is resized, <strong>update</strong><em> </em>and <strong>render</strong> are executed, and on <strong>events</strong>, the <strong>render</strong> step is performed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f6355f83-f594-4472-bf17-2002499a25ca.png" width="1035" height="593"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Chart.js life cycle. Each phase can be intercepted by plugin callbacks.</div>
<p>Depending on your plugin, you may need to intercept one or more of these steps. The following table lists the callbacks that are available for plugins. Each <kbd>callback</kbd> function contains at least two parameters: a reference to the chart instance and an <kbd>options</kbd> object (configured under a plugin ID key, in <kbd>options.plugins</kbd>). Some callbacks may have additional parameters:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Parameters</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeInit</kbd><br/>
<kbd>afterInit</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called before and after <em>new</em> <kbd>Chart()</kbd> is invoked</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeUpdate</kbd><br/>
<kbd>afterUpdate</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called before and after the <em>update</em> stage</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeLayout</kbd><br/>
<kbd>afterLayout</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called before and after the <em>layout</em> stage</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeDatasetsUpdate</kbd><br/>
<kbd>afterDatasetsUpdate</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called before and after updating all datasets</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeDatasetUpdate</kbd><br/>
<kbd>afterDatasetUpdate</kbd></p>
</td>
<td>
<p>(<em>chart, dataset, options</em>)</p>
</td>
<td>
<p>Called before and after updating each dataset</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeRender</kbd><br/>
<kbd>afterRender</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called before and after the <em>render</em> stage</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeDraw</kbd><br/>
<kbd>afterDraw</kbd></p>
</td>
<td>
<p>(<em>chart, easing, options</em>)</p>
</td>
<td>
<p>Called before and after the <em>draw</em> stage</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeDatasetsDraw</kbd><br/>
<kbd>afterDatasetsDraw</kbd></p>
</td>
<td>
<p>(<em>chart, easing, options</em>)</p>
</td>
<td>
<p>Called before and after drawing all datasets</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeDatasetDraw</kbd><br/>
<kbd>afterDatasetDraw</kbd></p>
</td>
<td>
<p>(<em>chart, dataset, options</em>)</p>
</td>
<td>
<p>Called before and after drawing each dataset</p>
</td>
</tr>
<tr>
<td>
<p><kbd>beforeEvent</kbd><br/>
<kbd>afterEvent</kbd></p>
</td>
<td>
<p>(<em>chart, event, options</em>)</p>
</td>
<td>
<p>Called before and after <em>events</em></p>
</td>
</tr>
<tr>
<td>
<p><kbd>resize</kbd></p>
</td>
<td>
<p>(<em>chart, dimensions, options</em>)</p>
</td>
<td>
<p>Called after resizing</p>
</td>
</tr>
<tr>
<td>
<p><kbd>destroy</kbd></p>
</td>
<td>
<p>(<em>chart, options</em>)</p>
</td>
<td>
<p>Called after <kbd>chart.destroy()</kbd> is called</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Life cycle callbacks that can be used in plugins</div>
<p>To see a demonstration of these methods, run the <kbd>Extensions/ext-2-plugin-lifecycle.html</kbd> file. It logs every life cycle event while a chart with three plugins is rendered and destroyed.</p>
<p>A plugin is a simple object. An <kbd>id</kbd> property is not necessary unless you plan to configure the plugin in the <em>options</em> object. You can include just the callback properties you need. The following code will create a simple configurable plugin that will draw a blue square in front of the chart, and a red one in front of the axes but behind the bars (<kbd>Extensions/ext-3-simple-plugin.html</kbd>):</p>
<pre>const plugin = {<br/>     id: 'p1',<br/>     afterRender: function(chart, options) {<br/>         chart.ctx.fillStyle = 'blue';<br/>         chart.ctx.fillRect(60,60,100,100);<br/>     },<br/>     beforeDatasetsDraw: function(chart, percent, options) {<br/>         chart.ctx.fillStyle = 'red';<br/>         chart.ctx.fillRect(200,60,100,100);<br/>     },<br/> };</pre>
<p>This effect is shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d5f87689-359b-4489-9cec-4b5916306048.png" width="721" height="360"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The blue and red squares were drawn in the chart using simple plugins. Code: <em>Extensions/ext-3-simple-plugin.html.</em></div>
<p>If you are writing a plugin locally and have multiple charts, you can include a list of plugins to add to each chart using the <em>plugins</em> key in the <kbd>Chart()</kbd> constructor. It takes an array:</p>
<pre>new Chart("chart", {<br/>     type: 'bar',<br/>     data: {…},<br/>     options: {…},<br/>     plugins: [plugin1]<br/> });</pre>
<p>Plugins should be reusable whenever possible. Reusable plugins are normally created in separate <kbd>.js</kbd> files and made automatically available to all charts. In this case, they should be registered globally with the following:</p>
<pre>Chart.plugins.register(plugin);</pre>
<p>Let’s create a plugin for the last example so that the image and the chart have an opaque background. Plugins should have configurable options. There are greater chances you will reuse this plugin if you can configure the background color for each chart. We could also add the possibility of drawing a background image. The plugin will be stored in a separate JavaScript file, <kbd>JavaScript/chartback.js</kbd>, which creates the plugin object and registers it globally. The <kbd>id</kbd> is necessary so that a chart can identify the plugin and configure its options.</p>
<p>Since the image needs to be redrawn every time the chart is resized or updated, the best place to draw it is in the <kbd>beforeDraw</kbd> callback. This code will also place the image behind the axes:</p>
<pre>const bgPlugin = { id: 'chartback',<br/>    beforeDraw: function(chart, steps, options) {<br/>       let ctx = chart.ctx;<br/>        if(options.backgroundColor) {<br/>            ctx.fillStyle = options.backgroundColor;<br/>            ctx.fillRect(0, 0, chart.width, chart.height);<br/>        }<br/>        if(options.backgroundImage) {<br/>            let image = new Image(chart.width, chart.height);<br/>            image.src = options.backgroundImage;<br/>            ctx.drawImage(image, 0,0,chart.width, chart.height);<br/>        }<br/>    }<br/>}<br/>Chart.plugins.register(bgPlugin);</pre>
<p>To use the plugin, import it into the HTML file where the chart will be created:</p>
<pre>&lt;script src="../JavaScript/chartback.js"&gt;&lt;/script&gt;</pre>
<p>This plugin's configuration options can be set in the <kbd>options.plugins.chartback</kbd> key (<kbd>chartback</kbd> is the plugin's ID). This code is in <kbd>Extensions/ext-4-chartback.html</kbd>:</p>
<pre>new Chart("chart", { type: 'bar', data: {…},<br/>    options: {<br/>        animation: {…},<br/>        plugins: {<br/>            chartback: {<br/>                backgroundColor: 'white',<br/>                backgroundImage: '../Images/mars.jpg'<br/>            }<br/>        }<br/>    },<br/>});</pre>
<p>The chart will be drawn with an image behind. If you don’t want the image, you can just set the <kbd>backgroundColor</kbd> and have a chart with an opaque background. The following screenshot shows a web page with the chart and the <kbd>.png</kbd> file loaded by an image viewer application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8db602bd-6610-4ab1-b5fd-c7d955f100fd.png" width="1326" height="689"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Using a plugin that places a background image behind the chart. Code: <em>Extensions/ext-4-chartback.html.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chart.js extensions</h1>
                </header>
            
            <article>
                
<p>Besides plugins, Chart.js also includes an advanced extensions API where you can extend charts and axes. With this API, you can derive from existing chart types or create entirely new chart types by implementing the provided interfaces. This topic is beyond the scope of this book, but you can try out the examples provided in the official documentation or perhaps use some of the many popular extensions already available. A selection is listed in the official documentation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored several advanced Chart.js topics that you may rarely need, but give you more control over the look and feel of your charts, allowing a high degree of customization and the possibility of integrating it with standard web technologies and frameworks.</p>
<p>We learned how to configure tooltip and legend presentation and behavior using native Canvas options and custom HTML extensions, and how to create pages with multiple charts, mixed charts, and overlaying charts with other graphics using Canvas. We also wrote extensions for Chart.js using its programming API to generate a PNG version of a chart, and to create a simple plugin that adds a background image to a chart.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<p><strong>Books and websites</strong>:</p>
<ul>
<li>Chart.js official documentation and samples: <a href="https://www.chartjs.org/docs/latest/">https://www.chartjs.org/docs/latest/</a></li>
<li>Palette.js Color schemes: <a href="http://google.github.io/palette.js/">http://google.github.io/palette.js/</a></li>
<li>Color brewer 2.0 by Cynthia Brewer: <a href="http://colorbrewer2.org/">http://colorbrewer2.org/</a></li>
<li>Patternomaly plugin: <a href="https://github.com/ashiguruma/patternomaly">https://github.com/ashiguruma/patternomaly</a></li>
<li>Datalabels plugin: <a href="https://github.com/chartjs/chartjs-plugin-datalabels">https://github.com/chartjs/chartjs-plugin-datalabels</a></li>
<li>Outlabels plugin: <a href="https://github.com/Neckster/chartjs-plugin-piechart-outlabels">https://github.com/Neckster/chartjs-plugin-piechart-outlabels</a></li>
</ul>
<p><strong>Data sources</strong>:</p>
<ul>
<li>Volumes of the World’s Oceans (based on ETOPO1): <kbd>Chapter03/Pages/BarChart1.html</kbd> and others. <a href="https://www.ngdc.noaa.gov/mgg/global/etopo1_ocean_volumes.html">https://www.ngdc.noaa.gov/mgg/global/etopo1_ocean_volumes.html</a></li>
<li>Geographical database: <kbd>Chapter02/Data/cities1000.csv</kbd>. GeoNames geographical database: <a href="http://www.geonames.org">www.geonames.org</a></li>
<li>GeoJSON map of the world: <kbd>Chapter02/Data/world.geojson</kbd>. Simplified version adapted from <a href="https://www.naturalearthdata.com">https://www.naturalearthdata.com</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>