- en: Chapter 2. Managing Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter, Backbone views are responsible for
    managing **DOM** (**Document Object Model**) interactions between users and applications.
    A typical Backbone application is composed of many views with a very specific
    behavior; for instance, we can have a view to show contact data and another view
    to edit it. As you know, rendering a single view is a trivial task, but orchestrating
    a complex layout with multiple views can be a pain.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to develop a better strategy to deal with complex view interactions
    to make the project easier to maintain and fun to develop. If you don't put the
    necessary attention into the organization of your views you can end up with a
    dirty DOM and messy code, which makes it hard to introduce new features or change
    existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous chapter, we are going to separate responsibilities
    by identifying common view use cases and then will learn how to compose layouts
    by using small views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify common view types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement reusable views for common types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the reusable view types to compose complex views easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying view types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After working with Backbone for a while you can see common use cases for views
    emerge; they are so common they can be used for different unrelated projects.
    These views can be extracted and can be used on any project if they are built
    correctly. Looking at the Backbone documentation, Views do not implement a default
    render method, so the trick here is to define a set of views with a default render
    method for different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View with model** – Render a template with model data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View with collection** – Render a collection of views with collection data;
    it should update the list of views automatically when the collection changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region** – This view acts like a container; it points to a particular DOM
    node and manages the content for that node. It''s used to render other views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout** – A layout is composed of one or more regions; it defines an HTML
    structure to organize where the regions will be placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 2.1 shows a simple wireframe for an application; as you can see, it is
    a very common layout found on web applications and is very useful to understand
    how the common view types are related.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying view types](img/B01962_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Views, Regions, and Layout relationship'
  prefs: []
  type: TYPE_NORMAL
- en: With these foundation views you will have a simple but powerful framework to
    manage your views, so you won't need to implement the `render()` method anymore.
  prefs: []
  type: TYPE_NORMAL
- en: ModelView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest implementation is to render a single model; it''s a very straightforward
    algorithm. Extract data from the model and use a template engine to make the actual
    render with the data; finally, attach the result in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the following code we can identify five steps to rendering the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get data from the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the template with model data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the result on the DOM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we return this in the `render()` method; this is useful for chaining
    calls. These steps are common for all views that need to render a model, so we
    can extract that behavior in a new view type. This view will own the generic algorithm
    and let the specific parts open to extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The model data now is done in a separated method, `serializeData()`, allowing
    us to implement a different way to provide data to the view; however, it implements
    a default behavior that is needed in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: The template is now compiled in the process using the Underscore template engine,
    so that you have to provide the template text and let it make the rest. But this
    leaves the view highly coupled with a template engine; what if you need to use
    a different one such as Handlebars?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same strategy as before in the `serializedData()` method, and
    put this behavior in a separated method. All template engines need two things:
    template text and data. Template text can be obtained by a jQuery selector, a
    string variable, pre-compiled template, and so on. So we will leave this open
    to the final implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And, as we did with `serializedData()`, a default behavior is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `template` property can be either a function or a string.
    If a string is used, the default behavior will be to use the Underscore template
    engine. If a function is used, the function gives us the freedom to use any template
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to render a model in a view, we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You only need to specify the template and the model, and you're done!
  prefs: []
  type: TYPE_NORMAL
- en: CollectionView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Backbone Collections are composed of many models, so when rendering a collection
    what we need is to render a list of `Views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `modelView` property should be a View class; it could be our `ModelView`
    class of the previous section or any other view. See how for each model in the
    collection it instantiates and renders a `this.modelView` with the current model.
    As a result, an `html` variable will contain an array of all rendered views. Finally
    the `html` array can be attached easily to the `$el` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example of how to use `CollectionView`, see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will do the job, it will render a `MyModelView` for each model
    in the `someCollection` object and put the result list in the `#main` element.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you add models to the collection or remove them, the view will not
    be updated. That's not a desirable behavior. When a model is added, it should
    add a new view at the end of the list; if a model is deleted from the collection,
    the view associated with that model should be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: A quick and dirty way to sync collection changes and views is to re-render the
    entire view on every change in the collection, but this approach is very inefficient
    because client resources are consumed when re-rendering views that don't need
    to change. A better approach should exist.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a model is added to the collection an `add` event is triggered; we can
    create an event handler to update the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the `addModel` method is called, it should create and render a new view
    with the data of the model added and put it at the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A `renderModel()` method was added since both methods, `render()` and `modelAdded()`,
    need to render the model in the same way. The DRY principle was applied.
  prefs: []
  type: TYPE_NORMAL
- en: When a child view is rendered, it is useful to listen for all the events for
    the given view, so that we can listen for child events from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our event handler is very simple; it renders the added model with the `renderModel()`
    method, attaches an event handler for any event in the view, and appends the result
    at the end of the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a model is removed from the collection, the view that contains that model
    should be deleted from the DOM to reflect the current state of the collection.
    Consider an event handler for the `removed` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we obtain the view associated with the model? There is no easy way
    to do it with the code that we have. To make it easy, we can keep track of model-view
    associations; in this way, getting the view is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At rendering time, we store a reference to the view in the `this.children` hash
    table for future reference, since `render()` and `modelAdded()` use the same method
    to render; this change is done in one place, the `renderModel()` method.
  prefs: []
  type: TYPE_NORMAL
- en: When a model is removed, the `modelRemoved()` method can easily find the view
    and remove it by calling the standard `remove()` method and destroying the reference
    in the `this.children` hash.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a `CollectionView` is destroyed, it should remove all children views to
    clean the memory properly. This should be done by extending the `remove()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the view needs to be removed, it will do it and clean all the children
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a collection is wiped, the view should re-render the entire collection,
    because all items were replaced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but previous views should be closed too; as we saw in the previous
    section, the best place to do it is in the render method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If a view has no items yet, the `closeChildren()` method will not do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Region
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common use case is to swap between views in a common DOM element; this can
    be done by using the same `el` property in both views and calling the `render()`
    method on the view you want to see. But this way doesn't clean the memory and
    event bindings because both views will remain live in memory, even if they are
    not in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: A particularly useful scenario is when you need to switch between sub-applications,
    because sub-applications are rendered in the same DOM element normally. For example,
    when a user wants to edit contact information, he/she will click on an **Edit**
    button, and the current view will be replaced with an edit form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Region](img/B01962_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Swapping views with regions'
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch between views, a `Region` class could be used as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Region` object points to an existing DOM element; to show a view on that
    element, the `show()` method should be called on the `Region` object. Note that
    views don't have the `el` property set because regions will put the element in
    the DOM and not the View itself. This gives us an extra feature, views don't need
    to set an `el` property anymore and can be rendered on any available region.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic region manager can be implemented with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `show()` method is called, it closes the current view, if any, then
    assigns a new `currentView` and opens the view. When a view is open, `Region`
    ensures that the `$el` property exists, first calling the `ensureEl()` method.
    Then the interesting part happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Backbone documentation explains how views works:'
  prefs: []
  type: TYPE_NORMAL
- en: '*All views have a DOM element at all times (the el property), whether they''ve
    already been inserted into the page or not. In this fashion, views can be rendered
    at any time, and inserted into the DOM all at once [...]*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And that''s what happens here: we render the view in memory first, calling
    `view.render()`, and then insert the result in the DOM pointed by the Region `$el`
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: A `remove()` method is implemented too, to make regions compatible with Backbone
    Views. When a region is removed, it needs to close the owned view too, so this
    allows us to do this easily.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have a region that owns a `CollectionView` with many views inside;
    when the `remove()` method is called on the region, it will call the `remove()`
    method on the `CollectionView`, which will call the `remove()` method on every
    child view.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Layout is used to define structure; its intention is to create a skeleton
    where other views will be placed. A common web application layout is composed
    of a header, a sidebar, footer, and a common area, for example. With layouts we
    can define regions, in a declarative way, where these elements will be placed.
    After the layout is rendered, we can show the views we want on those views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see a layout; each of these elements is a region,
    so other views should be created to fill the regions—for example, a HeaderView
    class for the header region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout](img/B01962_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A common web application layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation of this example could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'See how regions are declared: a pair of names and a selector. The layout will
    expose the regions through the `getRegion()` method, which receives the name of
    the region and returns an instance of the `Region` class that can be used as seen
    in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the layout needs to define a `template` property; it should follow
    the same rules used in the `ModelView` implementation. That template will define
    the HTML where regions will be pointed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to create a Layout view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The layout extends directly from `ModelView` so the `render()` method acts like
    in `ModelView`, but extends its behavior creating the necessary regions after
    rendering. The `configurateRegions()` method creates a region for every region
    declared on the `regions` property. Associations between region names and `Region`
    instances are stored in the _`regions` property, to be used on future references.
  prefs: []
  type: TYPE_NORMAL
- en: When a layout is removed, it should close any region opened, so that all resources
    are released cleanly. That's the job of the `closeRegions()` method; it iterates
    over all regions created with `configurateRegions()` and calls the `remove()`
    method for every region.
  prefs: []
  type: TYPE_NORMAL
- en: As the regions are stored in a private property called _`regions`, a method
    for accessing the regions is required; the `getRegion()` method returns the region
    instance associated with the name of the region.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created four simple but powerful new views types that can be used easily
    on projects, minimizing the effort and making less redundant code. In the next
    section, we will convert our contacts project into a more complex project, using
    what we have learned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/B01962_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Application root layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will have a root layout with three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Header – Will contain a navigation bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footer – Copyright information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main – This element shows all sub-applications on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This layout description is not a Layout object; instead, it describes the HTM
    root content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this root layout, the header and footer are very straightforward, so is not
    necessary to create a separate view for them. There is a `main` div that will
    be our main region, for the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ContactList` subapplication is responsible for rendering the collection
    in the DOM. Thus, the `ContactList` object will instantiate the necessary views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A layout is created to put the `CollectionView` inside; the layout template
    has a `div` with a `contact-list-layout` id that will be used as the target region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the layout code is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The view that renders the collection of contacts is very straightforward because
    it just need to specify the `modelView` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The contact card template shows the contact name, phone number, email, and
    its social networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContactListItemView` class should handle the delete and view events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on the **Delete** button, the view triggers a `contact:delete`
    event and lets the controller handle the deletion process. Because the **View**
    button is simpler than the **Delete**, we can redirect the user to the contact
    list from the view; note that delegating this very simple task to the controller
    will add more overhead without benefit.
  prefs: []
  type: TYPE_NORMAL
- en: The action bar allow the user to add new users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`ContactListActionBar` just renders its template and waits for a click on its
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the button is clicked, we redirect the user to the contact form to create
    a new user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The contact details show a read-only version of a single contact; here you
    can see all the details of a given contact but no edition. The following screenshots
    shows how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the details](img/B01962_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Contact details'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show a read-only version of a contact, we need to first define a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The layout defines two regions, one for the widget at the left and another
    one for the main content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When `ContactViewLayout` is rendered, the widget and the about information should
    be rendered. The templates for these views are very simple, so for space reasons
    will not be shown here; if you want to see the details of the implementation,
    please go to the GitHub repo for this book.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContactAbout` view includes three buttons to go back to the list, another
    to delete the contact, and a final one to edit it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we did in the `ContactList`, we will delegate the deletion process to the
    controller; views should not handle that business logic. However, the edit and
    go back button are simple URL redirections and can be implemented directly in
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: Editing information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Figure 2.6 shows how the edit form for the contacts should looks. The form view
    should be able to grab information from the input boxes and update the Contact
    model passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layout template should be created here to separate the widget at the left
    from the form view at the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![Editing information](img/B01962_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Edit contact form'
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout defines two regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to edit a contact, we need to define a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For space reasons, I have eliminated the duplicated code in the book, but you
    can see the complete code in the GitHub repo. Please note that this form will
    be used for editing and creating new contacts. For each attribute in the model,
    an input is rendered with the contents of the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on the **Cancel** button, it triggers a `form:cancel` event
    that is processed by the `ContactEditor` subapplication controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When the model is rendered, it may or may not contain attributes due to the
    server response; for this reason, we extend the `serializeData()` method to assign
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the **Save** button, the `saveContact()` is called,
    it gets the data from the inputs and assigns new values to the model, then triggers
    a `form:save` event to be processed by the `ContactEditor` subapplication controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Rendering third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common issue when rendering views is not rendering plugins from others because
    they are designed to work with traditional web applications but not with SPA;
    this is because many plugins are DOM-dependent, which means that the target element
    should exist in the actual DOM. To see this issue more clearly, let me show you
    an example with the jQueryUI Calendar plugin. Let's add a `birthdate` field to
    our `ContactEditor`, replacing the age field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And make the proper changes in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To show a calendar on the `birthdate` field we need to call `$('#birthdate').datepicker()`somewhere,
    but what is the best place to do that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After calling the `show()` method on the `region` object, the `contactForm`
    view is live in the DOM, so it makes sense to call the `datepicker()` method after
    that. However this is not a good strategy because our controller object knows
    about DOM elements, which are not its responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Views should be responsible for dealing with the DOM, so rendering third-party
    plugins is included. Another approach could be to extend the `render()` method
    on the `FormView` class but we already have the `onRender()` callback, which is
    called after the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But this is not going to work because we are rendering the view on a region.
    Did you remember the `show()` method?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The showing process first renders the view in memory and after that makes it
    available on the DOM. That's why this doesn't work. The intent of the `onRender()`
    method is to make template changes before making them available on the DOM. We
    need to add a new callback method that will be called when the view is in the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Remember to make this feature available in `CollectionView` too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, our `ContactForm` will end with something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Remember, most third-party plugins need to have the element in the DOM or they
    will not work, so you should call the plugin only after rendering the view. The
    best place to call plugins is in the extended view class so the responsibility
    for DOM manipulation is encapsulated in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started by creating common view types that are common for almost every project.
    Those views are simple in principle but powerful; we can effectively manage nested
    views without worrying about insufficient memory.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that, by encapsulating common patterns in the `render()` method,
    we can create useful view types; in this chapter, we have seen four of them but
    if you are curious I encourage you to take a look at the Marionette framework,
    which works on top of Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marionette includes all the views exposed here: `ItemView`, `CollectionView`,
    `LayoutView`, Regions. and other useful view types. Marionette objects behave
    very similarly to what we see here, so that you can easily interchange Marionette
    objects with those described in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins should be called only after the view is on the DOM, because most plugins
    are DOM-dependent. When rendering plugins, remember to do it in the view not outside
    it; the `onShow()` callback strategy ensures that the view is available on the
    DOM, and so is the best place to render third-party plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about how to sync views and models.
    You will see how to manage complex data and render it effectively in views. Validation
    is an important feature for your application; you will learn how to validate models
    and use that information to display error messages on your views.
  prefs: []
  type: TYPE_NORMAL
