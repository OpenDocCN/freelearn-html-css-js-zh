- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Code Quality with Linters and Formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this chapter, we’ve dealt mostly with constructs and code that has been
    in the hot path – that is, directly necessary to actually do something. However,
    in most projects, there are many parts that are not directly useful or visible.
    Quite often, these parts play a crucial role in keeping projects at a certain
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: One example in the field of software project quality enhancers is the tooling
    that is used to ensure certain coding standards are being followed. Those tools
    can appear in many categories – the most prominent categories being **linters**
    and **formatters**. In general, these tools can be categorized as auxiliary tooling.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn what types of auxiliary tooling exist and why we’d
    potentially want to use some extra tooling to enhance our project’s code quality.
    We’ll introduce the most important auxiliary tools such as **ESLint**, **Stylelint**,
    and **Prettier**. We will also have a look at how these tools are integrated or
    used with standard text editors such as VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: With the auxiliary tools presented in this chapter, you’ll be able to have an
    outstanding positive impact on any Node.js-based frontend project that you’ll
    contribute to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding auxiliary tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ESLint and alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Stylelint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Prettier and EditorConfig
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3fLWnyP](https://bit.ly/3fLWnyP).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding auxiliary tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When most people think about software, they’ll have applications such as Microsoft
    Word, games such as Minecraft, or web applications such as Facebook in mind. Thanks
    to popular media, the widespread opinion is that these applications are written
    by individual geniuses that hack some ones and zeroes into an obscure interface.
    The reality could not be more far off.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, to create any kind of software, lots of libraries, tooling, and
    – in many cases – large teams are necessary. However, what most people underestimate
    is the effort to just keep the ball rolling – that is, to still be able to add
    new features to the existing software. There are several issues that contribute
    to this feature slowdown.
  prefs: []
  type: TYPE_NORMAL
- en: On the one hand, the complexity within software always rises. This is whether
    we want it or not – with every new feature, a project becomes more challenging.
    In addition, larger software tends to be written by more developers – and every
    developer has a slightly different preference and style. This quickly becomes
    a mess for new developers or even those with experience in the project but who
    are working in areas that they did not touch beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: One way to tame the rise of complexity is the introduction of processes. For
    instance, the process of conducting pull requests with reviews is already presented
    to spread knowledge about new features, detect issues, and discuss findings. At
    the end of a good pull request review, the code should be in a state where the
    new additions fit well into the whole project, both functionally and technically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, everything is about automation. Therefore, while having manual processes
    such as a code review might be good and necessary, we usually prefer automated
    processes. This is exactly where all the auxiliary tooling comes in. Take, for
    instance, a potential discussion about code formatting within a code review. Let’s
    say a part of the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code itself is fine – the `div` function should perform a division, and
    of course, it does that. Nevertheless, the formatting is way off. A reviewer might
    complain that the parameters of the function should be properly formatted using
    a space after a comma. Another reviewer might not like the return statement, which
    would break without the use of parenthesis. A third review could remark on the
    missing optional semicolon and that the indentation is just a single space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after everything is set and done, a new version of the code would be pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the second reviewer might bring up a discussion of why the semicolon
    was introduced – it is only optional in this case and the code works without it.
    At this point, a new reviewer joins and questions the introduction of the function
    at all: “Why is a function for division needed in the first place? There is nothing
    new or interesting here.”'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, you’ll see that much time was wasted on all sides. Instead of
    discussing the business need of the function in the first place, time was – and
    is still – spent discussing formalities that should be aligned and corrected automatically.
    This is where linters and formatters come into play. They can take the task of
    making code beautiful to read by following the standard that was set for a project.
    Hence, a team would need to agree only once on the tabs versus spaces debate or
    the use of semicolons. The tooling takes care of actually applying the decision.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons in JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is quite loose regarding syntax. While other languages have rules
    and constructs that always need to be followed, JavaScript has many optional constructs
    in its specification. For instance, semicolons are – up to some degree – optional.
    There are a few cases where you’d need a semicolon to avoid nasty surprises such
    as in the head of `for`-loops, but for the most part, you could just drop them
    and your code would still work.
  prefs: []
  type: TYPE_NORMAL
- en: There are many areas in which auxiliary tooling makes sense. Sure, the alignment
    of code itself is nice, but even things such as commit messages when working with
    a project’s version control system or checking whether documentation was supplied
    can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: While checking the actual syntax – for example, the use of whitespace and newlines,
    is a common use case – an even more important one is to check the actual code
    constructs for some patterns. The validation of the used patterns is often referred
    to as **linting** – with a category of tools known as **linters**. A tool that
    excels in that space is **ESLint**.
  prefs: []
  type: TYPE_NORMAL
- en: Using ESLint and alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ESLint statically analyzes code to identify common patterns and find problems.
    It can be used as a library from your Node.js applications, as a tool from your
    Node.js scripts, in your CI/CD pipelines, or implicitly within your code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general recommendation is to install ESLint locally in your Node.js project.
    A local installation can be done with your favorite package manager, such as npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you’ll want to specify the `--save-dev` flag. This will add a
    dependency to the development dependencies, which are not installed in consuming
    applications and will be skipped for production installations. Indeed, development
    dependencies are only interesting during the project’s actual development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also make ESLint a global tool. This way, you can run
    ESLint even in projects and code files that do not already include it. To install
    ESLint globally, you need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Potentially, you’ll need elevated shell access (e.g., using `sudo`) to install
    ESLint globally. The general recommendation is to avoid using elevated shell access,
    which implies avoiding global installations.
  prefs: []
  type: TYPE_NORMAL
- en: Global versus local installations
  prefs: []
  type: TYPE_NORMAL
- en: npm is not only a great way to distribute packages but also to distribute tools.
    The standard installation of npm creates a special directory for such tools. This
    dedicated directory is added to your system’s `PATH` variable, allowing direct
    execution of anything that is inside the directory. By using a global installation,
    a tool such as ESLint is added to the dedicated directory, giving us the option
    of running it just by typing `eslint` in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, tools in a local installation are not placed in the dedicated
    directory. Instead, they are available in the `node_modules/.bin` folder. To avoid
    running lengthy commands such as `./node_modules/.bin/eslint`, we can use the
    `npx` utility.
  prefs: []
  type: TYPE_NORMAL
- en: '`npx` is a task runner installed together with Node.js and npm. It intelligently
    checks whether the provided script is installed locally or globally. If nothing
    is found, then a package is temporarily downloaded from the npm registry, executing
    the script from the temporary installation. Consequently, running `npx eslint`
    in a project where ESLint is installed will start the linting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s initialize a new project (`npm init -y`) and install `eslint` as a development
    dependency. Now that you’ve installed ESLint, you can actually use it on some
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we can leverage the sample from the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before we can run `eslint`, we also need to create a configuration. Having a
    configuration file is something that almost all utilities for frontend development
    will require. In the case of ESLint, the configuration file should be named `.eslintrc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the following `.eslintrc` file in the same directory as `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: .eslintrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are different ways to write a configuration way for ESLint. In the preceding
    snippet, we used the JSON format, which should feel quite familiar for anyone
    with a JavaScript or web development background. Another common approach is to
    use the YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding configuration, we instruct ESLint to stop looking for parent
    configurations. As this is indeed the configuration for our project, we can stop
    at this level. Additionally, we configure ESLint’s parser to actually parse ESM
    following a very recent specification. Finally, we configure the rule for semicolons
    to throw an error if semicolons are missing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result of applying this ruleset can be seen in the following code snippet.
    Running `npx eslint` starting on all JavaScript files from the current directory
    (`.`) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the linter complains. However, this kind of complaint is certainly
    in the positive region. Rather constructively, ESLint also tells us about the
    option to automatically fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the same command with the suggested `--``fix` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No output here. Indeed, this is a good thing. The missing semicolon has been
    inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How about other rules? What if we want to force code to use anonymous arrow
    functions instead of the named functions? While many things can be covered by
    the rules coming directly with ESLint, the system can be extended with rules from
    third-party packages. Third-party packages that bring in additional functionality
    for ESLint are called ESLint plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To bring in a rule to enforce the usage of anonymous arrow functions, we can
    use an ESLint plugin. The package for this is called `eslint-plugin-prefer-arrow`.
    Let’s install it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can change the configuration. We need to include a reference to the
    plugin and also specify the rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .eslintrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this configuration, we can now test whether the function declaration is
    indeed qualified as an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In contrast to the previous error, we are not seeing any hint of an automatic
    fix here. In such cases, the author of the code has to do all the changes to please
    the linter manually.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of alternatives to ESLint. In the past, the TypeScript-specific
    variant TSLint was quite popular. However, a couple of years ago, the team behind
    TSLint decided to actually merge their rules into ESLint – also making ESLint
    the de facto standard for linting TypeScript files. Today, the most popular alternatives
    are **Rome**, **quick-lint-js**, and **JSHint**.
  prefs: []
  type: TYPE_NORMAL
- en: Rome is an all-in-one tooling that combines several utilities into one cohesive
    application. While Rome is not written in JavaScript using Node.js, it still integrates
    nicely into the standard frontend tooling. One of the aspects covered in Rome
    is linting. At the time of writing, Rome is, unfortunately, not yet feature-complete
    and still in an early alpha version, but its performance and convenience benefits
    are a clear advantage.
  prefs: []
  type: TYPE_NORMAL
- en: The **quick-lint-js** package is a small tool that does not require configuration
    and is tuned to outperform ESLint in execution time. The downside of this is that
    quick-lint-js has fewer features and is less flexible in its design.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, one of the golden classics in the linting field is **JSHint**. Originally,
    it was created as a more configurable version of **JSLint**, which can be considered
    the first popular linter for JavaScript. One of the issues with JSHint is that
    it does not support the latest and greatest features of the **ECMAScript** standard.
    If you are looking for ES2020 support, then JSHint can be discarded. Likewise,
    JSHint is a bit more restrictive on extensibility. In JSHint, you cannot define
    custom rules. However, if something is missing in JSHint, you’ll not be able to
    just add it.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of ESLint, however, is that it already has the ecosystem
    that others are potentially missing. One area where ESLint shines is editor support.
    *Figure 5**.1* shows the entry of the official ESLint extension on the VS Code
    Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace
    ](img/Figure_5.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace
  prefs: []
  type: TYPE_NORMAL
- en: Similar plugins exist for other editors. Some editors such as Brackets even
    come with an ESLint integration preinstalled.
  prefs: []
  type: TYPE_NORMAL
- en: The editor integration will indicate ESLint issues directly in the code. This
    is really helpful during development. Instead of waiting for code quality inspection
    results after the code has been written, you can directly see issues when they
    appear. This way, you’ll be able to fix them immediately, instead of being required
    to come back to previously closed files later.
  prefs: []
  type: TYPE_NORMAL
- en: In almost all editor integrations, you’ll not only get some squiggles or similar
    visual hints when ESLint finds an issue but also the possibility to run a quick
    fix. Running a quick fix will trigger ESLint’s repair functionality. In the preceding
    command line usage, we triggered this behavior by using the `--``fix` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.2* shows how VS Code reports the issues found by ESLint on the
    given example file, `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – ESLint integration reporting issues in VS Code ](img/Figure_5.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – ESLint integration reporting issues in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: In general, it makes sense to define a sound basis for linting rules. The basis,
    however, should not be too large. Too many rules will ultimately have the opposite
    effect. Instead of empowering a team by finding a common style and avoiding problematic
    patterns, the constraints are too heavy – essentially slowing down or even blocking
    progress on new features. Therefore, the recommendation is to start with a few
    rules and add new ones when certain code issues come up more often in pull request
    reviews. This way, the set of linting rules will evolve with the project.
  prefs: []
  type: TYPE_NORMAL
- en: While linting JavaScript source files is definitely one of the most important
    tasks, it is by far not the only kind of source file you’ll encounter in modern
    frontend development. Arguably, the second most important type of files are stylesheets
    such as **CSS** or **SCSS**. For those, we can rely on another tool for linting
    called Stylelint.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Stylelint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stylelint is a linter for CSS files and can be extended to also understand CSS
    dialects such as SCSS, **Sass**, **Less**, or **SugarCSS**. It has over 170 built-in
    rules but, much like ESLint, provides support for custom rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Stylelint, we can follow the same steps as with ESLint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it usually makes sense to rely on the standard configuration provided
    by Stylelint. Unlike ESLint, the standard configuration is released in a separate
    package and, therefore, needs to be installed as well. The command to install
    both packages as development dependencies looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In any case, we still require a configuration file. For the moment, it is sufficient
    to just let `stylelint` know that we want to use the configuration from the `stylelint-config-standard`
    package. Here, we can write another configuration file next to the project’s `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .stylelintrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s introduce some problematic CSS files to try out the `stylelint`
    utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: style.css
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet has several issues. On one hand, we’ll overwrite the `padding-left`
    property by using the `padding` shorthand afterward. On the other hand, we’ll
    use an invalid color hex code. Finally, we might want to have a new line between
    different declaration blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the `stylelint` utility with the `npx` task runner – just like how
    we triggered `eslint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is quite a list of issues coming out! Luckily, just like with `eslint`,
    we can use the `--fix` flag to automatically fix as much as possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the cosmetic issues dealing with spaces and newlines can be tackled automatically
    by Stylelint, the remaining two issues (`3:5` and `6:12`) require a bit more brainpower
    to be fixed. The first issue requires a decision of whether we want to either
    remove the `padding-left` property or move it after the usage of the `padding`
    shorthand. The second issue requires us to actually think about a valid color
    to use. Here, Stylelint cannot possibly know which color we had in mind when writing
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Stylelint is not only very useful but is also quite unique. In the world of
    CSS linters, there are not many options. Mostly, people tend to rely on their
    tooling – for example, Sass or Less, to already give them some errors and warnings.
    Stylelint goes a bit further. In addition to the rich set of in-built rules and
    its flexibility via plugins, Stylelint also offers a rich ecosystem. As with ESLint,
    many editors have an integration for Stylelint.
  prefs: []
  type: TYPE_NORMAL
- en: With all the linting in place, we can now turn to an even softer part of code
    cosmetics – how code is structured visually. A tool to help us here is **Prettier**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Prettier and EditorConfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prettier is a code formatter that works with a lot of different source files.
    Among the supported file types, we have plain JavaScript, Flow, TypeScript, HTML,
    CSS, SASS, Markdown, and many more. Prettier is also integrated into many different
    editors such as Atom, Emacs, Sublime Text, Vim, Visual Studio, or VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dig into installing and configuring the Prettier formatter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Such as the previous tools, Prettier can be installed locally or globally.
    Adding Prettier to an existing project can be done by installing the `prettier`
    package from the npm registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prettier can format JavaScript code even without any configuration. To run
    Prettier on an existing code file, you can use the `prettier` utility with `npx`.
    For instance, to apply formatting to your previous code file, you can run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, Prettier just printed the result of the formatting in the command
    line. It also added a semicolon to the end of the statement. Let’s configure Prettier
    to *not* add semicolons at the end of statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Prettier, a `.prettierrc` file should be added to the root of
    the project – right next to `package.json`. The file can be written with JSON.
    An example is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .prettierrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The provided example sets the indentation to four spaces. It instructs Prettier
    to always use single quotes instead of double quotes for strings when possible.
    Most importantly, we disable the use of semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding configuration in place, we can run `prettier` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The effect is striking. Now, four spaces instead of two are being used. The
    semicolon is dropped. The configuration has been successfully applied. However,
    one thing that is still left open is to actually overwrite the existing file.
    After all, getting the formatting code in the command line is nice but not worth
    a lot if we did not really format the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `prettier` to apply the changes, the `--write` flag needs to be used. The
    command from *step 4* would therefore change to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output now prints a summary of all the files that have and have not been
    changed. With the preceding command, only the `index.js` file is formatted; however,
    the `prettier` utility would also accept wild cards such as `*` to indicate placeholders
    matching multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: Globs
  prefs: []
  type: TYPE_NORMAL
- en: Many Node.js utilities accept a special kind of syntax to match multiple files.
    Very often, this syntax comes directly or is at least inspired by the `glob` package,
    which copied the notation from Unix. The syntax defines so-called globs – that
    is, patterns that allow matching files. In this regular expression-like syntax,
    `*` matches 0 or more characters in a single path segment, while `?` matches exactly
    a single character. Another useful construct is `**`, which can be used to denote
    0 or more directories. A pattern such as `**/*.js` would thus match any `.js`
    file in the current directory and any subdirectory. More details on the `glob`
    package and its syntax can be found at [https://www.npmjs.com/package/glob](https://www.npmjs.com/package/glob).
  prefs: []
  type: TYPE_NORMAL
- en: While Prettier is great for many kinds of source files, it surely cannot tackle
    text files in general. Quite often, however, we want to establish general formatting
    rules for anything in our project. This is where **EditorConfig** comes in.
  prefs: []
  type: TYPE_NORMAL
- en: EditorConfig is a standard to help maintain consistent coding styles for a project.
    It is established by a file named `.editorconfig`. Pretty much every editor supports
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `.editorconfig` example looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: .editorconfig
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As with ESLint, we can use nested configuration files – that is, specialize
    the configuration for subdirectories by having another `.editorconfig` file in
    them. The `root = true` configuration tells the editor to stop traversing the
    file system upward for additional configuration files. Otherwise, this file has
    only a single section, `[*]`, matching all text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ruleset in the preceding example above would actually tell an editor to
    exclusively use the line feed (`lf`) character to end lines. While this is the
    standard on Unix-based systems, Windows users would usually get two characters
    to end lines: line feed (`lf`) and carriage return (`cr`) – the so-called `lfcr`
    convention. In addition, the ruleset would introduce an empty line at the end
    of each file. By definition, each text file would use two spaces as an indentation
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While such a configuration is nice, it can be in direct conflict with the Prettier
    configuration. However, another great thing about Prettier is that it can work
    hand in hand with EditorConfig. Let’s rewire the previous configuration to also
    use EditorConfig:'
  prefs: []
  type: TYPE_NORMAL
- en: .prettierrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since Prettier rules will always take precedence and overwrite the ones from
    the `.editorconfig` file, it makes sense to remove conflicting rules. Otherwise,
    we will be only left with the JavaScript-specific formatting rules – for example,
    for semicolons and the preferred quote style, in `.prettierrc`. The general text
    formatting rules are now specified via EditorConfig implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in mind, let’s recap what we’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how code quality can be enhanced with the help
    of linters and formatters. You can now use common tools such as EditorConfig,
    Prettier, Stylelint, or ESLint. You are now able to add, configure, and run these
    tools in any project that you like.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can contribute to pretty much all frontend projects that
    are based on Node.js for their tooling. Also, you can introduce great quality
    enhancers such as Prettier. Once successfully introduced, these tools ensure that
    certain quality gates are always fulfilled. In the case of Prettier, discussions
    about code style are mostly a thing of the past – helping teams all around the
    world to actually focus on the actual problem instead of dealing with code cosmetics.
  prefs: []
  type: TYPE_NORMAL
- en: A downside to keep in mind is that most of these tools have some assumptions
    about your code. So, if your code uses, for instance, one of the flavors we discussed
    in [*Chapter 4*](B18989_04.xhtml#_idTextAnchor042), *Using Different Flavors of
    JavaScript*, then you’ll most likely need to teach some of your tools about this
    flavor, too. Quite often, this only requires the installation of a plugin, but
    in severe cases, you are left with the decision to either abandon the tool or
    stop using the flavor for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will take an in-depth look at perhaps the most important
    tooling for frontend developers: bundlers.'
  prefs: []
  type: TYPE_NORMAL
