["```js\n<!-- file: Child.svelte -->\n<script>\n  export let message;\n</script>\n<h1>{message}</h1>\n```", "```js\n<!-- file: Parent.svelte -->\n<script>\n  import Child from './Child.svelte';\n</script>\n<Child message=\"Hello, World!\" />\n```", "```js\n<!-- file: Counter.svelte -->\n<script>\n  let count = 0;\n  function increment() {\n    count += 1;\n  }\n</script>\n<button on:click={increment}>Click me</button>\n<p>{count}</p>\n```", "```js\n<!-- A.svelte -->\n<script>\n  export let height;\n</script>\n```", "```js\n<!-- B.svelte -->\n<script>\n  import A from './A.svelte';\n  let height = 0;\n</script>\n<A height={height} />\n```", "```js\n<!-- A.svelte -->\n<script>\n  export let height;\n  setInterval(() => console.log('A:', height), 1000);\n</script>\n<!-- B.svelte -->\n<script>\n  import A from './A.svelte';\n  let height = { value: 100 };\n  setInterval(() => console.log('B:', height), 1000);\n</script>\n<A height={height} />\n```", "```js\n<button on:click={() => { height.value += 10; }} />\n```", "```js\n<script>\n  let name = \"John\";\n</script>\n<input bind:value={name} />\n```", "```js\n<script>\n  import Profile from './Profile.svelte';\n  let name = \"John\";\n</script>\n<Profile bind:username={name} />\n```", "```js\n<script>\n  import Profile from './Profile.svelte';\n  let name = \"John\";\n</script>\n<p>Name from App: {name}</p>\n<Profile bind:username={name} />\n<p> element and a <button> element. The <p> element shows the value of the name state variable, and the <button> element, when clicked, updates the value of the name state variable to Svelte. Due to the binding, when the button is clicked, it will also update the username props in the <Profile> component.\nHere’s the updated version of the `<``Profile>` component:\n\n```", "```js\n\n In this code snippet, we are looking at the `<Profile>` component. This component receives a prop called `username`, whose value is displayed inside a `<p>` element. We’ve also added a button, and when clicked, it will update the value of the `username` prop to `\"World\"`.\nBecause of the binding we established in the parent component, any change to the `username` prop in this `<Profile>` component will also update the `name` state variable in the parent component.\nIndeed, if you click on the button in the parent component, both the `name` state variable in the parent component and the `username` prop in the `<Profile>` component will update to `\"Svelte\"`. On the other hand, if you click on the button in the `<Profile>` component, both the `name` state variable in the parent component and the `username` prop in the `<Profile>` component will change to `\"World\"`. This is the power of two-way binding in Svelte, allowing you to easily synchronize data between parent and child components.\nWhen we talk about binding in Svelte, we often refer to *two-way data binding*. But what exactly does *two-way* mean? And is there such a thing as *one-way* data binding? Let’s delve deeper into the concept of data flow to clarify these terms.\nOne-way versus two-way data flow\nWhen you pass data from one component to another component either through props or binding, data flows from one component to another component. The term data flow refers to how data is passed or transmitted between components or elements within a web application.\nUnderstanding data flow is important when designing an application’s architecture, as it helps to establish clear lines of communication between components and determine how information is shared and updated throughout the system.\nData flow can be unidirectional (one-way) or bidirectional (two-way), depending on how data is transferred between components.\nIn one-way data flow, data moves in a single direction, from a parent to a child component, or from a component to a DOM element. This unidirectional flow is achieved through component props or DOM element attributes.\nFor example, consider the following code snippets featuring two components, component `A` and component `B`.\nIn component `B`, we define a prop named `value`:\n\n```", "```js\n\n In component `A`, we import component `B` and pass the value of a variable named `data` to the prop of component `B`:\n\n```", "```js\n\n Here, the value of `data` in component `A` is passed to the `value` prop in component `B`, illustrating the data flow from component `A` to component `B`.\nIf you draw up the data flow in a diagram, this is what a one-way data flow looks like:\n![](img/B18887_03_1.jpg)\n\nFigure 3.1: One-way data flow\nThe boxes show the data state and value prop, and the arrow shows how changing one value will affect another.\nIn one-way data flow, changes to data in the parent component automatically propagate to the child component, but the reverse is not true.\nBuilding on the example with component `A` and component `B`, if the value of the `data` variable in component `A` changes, this change would automatically update the `value` props in component `B`. However, any changes made directly to the `value` props in component `B` would not affect the `data` variable in component `A`. Data changes only flow from component `A` to component `B`, but not in the reverse direction.\nHaving a one-way data flow makes the application easier to reason about and debug, as data changes follow a predictable path. For example, when the `data` variable in component `A` changes unexpectedly, isolating the issue becomes more straightforward. Because of the one-way data flow, we know that any changes to the `data` variable in component `A` will only originate from component `A`, not from component `B`.\nOn the other hand, two-way data flow allows data to flow in both directions, enabling automatic updates between the parent and child components, or between a component and DOM elements. Two-way data flow in Svelte is achieved through component or DOM element bindings.\nFor example, consider the following code snippets featuring two components, component `C` and component `D`.\nIn component `D`, we define a prop named `value`:\n\n```", "```js\n\n In component `C`, we import component `D` and bind the value of a variable named `data` to the prop of component `D`:\n\n```", "```js\n\n Here, the value of `data` in component `C` is bound to the `value` prop in component `D`, illustrating the two-way data flow between component `C` to component `D`.\nHere is a diagram showing how the data flows in a two-way data flow:\n![](img/B18887_03_2.jpg)\n\nFigure 3.2: Two-way data flow\nIn a two-way data flow, when you change the data in the parent component, the child component is automatically updated; conversely, changing the data in the child component automatically updates the parent.\nBuilding on the example with component `C` and component `D`, if the value of the `data` variable in component `C` changes, this change would automatically update the `value` props in component `D`. Conversely, unlike one-way data flow, any changes made directly to the `value` props in component `D` would update the `data` variable in component `C`. Data changes flow from component `C` to component `D` as well as from component `D` to component `C`.\nWhile this bidirectional flow of data can make it easier to keep data in different components synchronized, it can also introduce complexity and make the application harder to debug, since data changes can originate from multiple sources.\nFor example, when the `data` variable in component `C` changes unexpectedly, isolating the issue becomes more complex. Because of two-way data flow, any changes to the `data` variable in component `C` could originate from component `C`, as well as from component `D`. This complexity can escalate further if the `value` prop of component `D` is also bound to the prop of another component.\nIn summary, one-way data flow offers predictability and easier debugging, while two-way data flow makes it much easier to synchronize data across multiple components but at the cost of added complexity.\nNow that we’ve delved into both one-way and two-way data flows via props, let’s explore how to create state variables that derive their values from props.\nDeriving states from props with a reactive declaration\nIt’s common in Svelte to create new state variables based on the values of props.\nFor instance, a `<DateLabel />` component might accept a `date` value as a prop and display a formatted date inside a `<label>` element. To use the `<DateLabel>` component, you might write the following:\n\n```", "```js\n\n To display the date as formatted text, you could first define a variable named `label`, deriving its value from the `date` prop:\n\n```", "```js\n\n In this code snippet, we defined a variable called `label` and derived its value from the `date` prop using the `toLocaleDateString()` method. This variable is then used inside a `<label>` element to display the formatted date.\nIn the preceding code snippet, the `label` variable is initialized when the `<DateLabel>` component is first created. However, if the `date` prop changes after the component has been initialized, the `label` variable won’t update to reflect the new value. This is not the intended behavior, as the `<DateLabel>` component should always display the most up-to-date formatted date based on the latest `date` prop.\nTo solve this issue, you can use Svelte’s reactive declarations to keep the `label` variable updated whenever the `date` prop changes.\nSvelte’s reactive declarations utilize a special `$:` syntax to mark a statement as reactive. This means that whenever the variables used in that statement change, the statement itself will be re-run.\nLet’s modify our component code to use Svelte’s reactive declaration:\n\n```", "```js\n\n In this code snippet, by modifying the declaration of `label` to a reactive declaration, the component will automatically re-compute the `label` variable whenever the `date` prop is modified, ensuring that the `<DateLabel>` component is always displaying the most current formatted date.\nSo, how does Svelte know when a reactive declaration statement should be re-run?\nSvelte re-runs a reactive declaration statement whenever any of its dependent variables change. The Svelte compiler identifies these dependencies by analyzing the statement.\nFor example, in the reactive declaration `$: label = date.toLocaleDateString();`, Svelte recognizes that the dependency for this statement is the `date` variable. Therefore, whenever the `date` changes, the statement will re-run and update the value of the `label` variable.\nA good rule of thumb for identifying dependencies in a reactive declaration is to look for any variable on the right side of the equal sign (`=`). These variables are considered dependencies of the reactive declaration.\nYou can include multiple dependencies within a single reactive declaration. For instance, let’s say we want to add a new `locale` prop to the `<DateLabel>` component. To use this new prop, you might write something like this:\n\n```", "```js\n\n In this code snippet, we pass in a new `locale` prop with the value `de-DE` to format the date in German. To accommodate this new `locale` prop, we’ll need to modify our `<DateLabel>` component as follows:\n\n```", "```js\n\n In this updated code, the reactive declaration `$: label = date.toLocaleDateString(locale);` now has two dependencies: `date` and `locale`. Svelte will automatically re-run this statement whenever either of these variables changes, ensuring that the `label` value stays up to date with the latest `date` and `locale` props.\nNow that we’ve covered the basics of props, bindings, states, and derived states, it’s crucial to note that as components become more complex, managing these elements can quickly become overwhelming. In the next section, we’ll explore some tips for effectively managing complex derived states to keep them manageable.\nManaging complex derived states\nAs your Svelte application grows more complex, it will likely involve a greater number of interconnected components with multiple props and derived states. When dealing with this complexity, tracking updates and changes can become a complex task. Each prop or state change can affect other parts of your component, making it challenging to manage and predict how your component will behave.\nTo make this easier, here are some guidelines to consider:\n\n*   *Maintain one-way data flow for* *derived states*\n\n    While it’s possible to derive state from props and other states, it’s crucial to maintain a one-way data flow to simplify both debugging and understanding. Consider the following Svelte example:\n\n    ```", "```js\n\n     *   *Group similar* *logic together*\n\n    Consider this tip a stylistic suggestion. When dealing with multiple reactive declarations, it’s beneficial to group those that are related together. Utilize blank lines to create a visual separation between unrelated reactive declarations. This not only improves readability but also aids in code maintenance.\n\n    It is worth noting that the Svelte compiler takes care of execution order based on dependencies regardless of how you arrange your declarations. For example, the following two code snippets will behave identically due to Svelte’s handling of dependencies:\n\n    ```", "```js\n\n    ```", "```js\n\n    The Svelte compiler analyzes the dependencies of each declaration and executes them in the correct order. In this case, it evaluates `b = a * 2` before `c = b * 2` since the latter depends on the value of `b`, established by the former declaration.\n\n     *   *Avoid reassigning* *props directly*\n\n    It might be tempting to modify the value of a prop directly, especially when you want to transform its value or provide a default fallback. For example, you might consider writing something like this to set a default value for an undefined prop:\n\n    ```", "```js\n\n    ```", "```js\n\n    In this improved example, we introduce a new variable, `dataWithDefault`, which takes on either the value of the `data` prop or a default value of `100` if `data` is undefined. This approach makes the component’s behavior more transparent and easier to debug.\n\n     *   *Be cautious when updating* *derived states*\n\n    Modifying a derived state directly can introduce inconsistencies, particularly when that state is based on props or other state variables.\n\n    Consider the following example:\n\n    ```", "```js\n\n    In this example, we have a single prop named `value` and two derived states, `double` and `triple`, which are two and three times the value of the `value` prop respectively. The component features two input boxes, each bound to `double` and `triple` using two-way binding.\n\n    Here, `triple` can be modified in two ways: either by updating the `value` prop, which will keep `triple` at three times the value of `value`, or by directly changing the value in the input box, thereby directly altering `triple`.\n\n    If you type into the input box bound to `triple`, you’ll find that its value diverges from being strictly three times the `value` prop. This inconsistency arises because `triple` is now subject to changes from multiple sources, causing it to go *out of sync* with the original `value`.\n\n    If you were to map out a diagram illustrating the data flow between `value` `double` and `triple`, you’d get the following diagram:\n\n![](img/B18887_03_3.jpg)\n\nFigure 3.3: Data flows between props, states, and the input elements\nNotice that both `double` and `triple` have two incoming arrows, suggesting multiple pathways for changing their values. Conversely, `value` has no incoming arrows, indicating that modifying `triple` alone would cause `value` and `double` to go out of sync.\nTherefore, it is recommended to refrain from manually updating derived states, as this complicates debugging and makes the component’s behavior harder to reason about.\nIf you wish to modify the input while maintaining the synchrony between `value`, `double`, and `triple`, a solution will be discussed in the following section.\nBy keeping these tips in mind, you can better manage complex derived states and make your components more maintainable and easier to understand.\nIn our last tip, we highlighted that updating the derived states can lead to inconsistencies between states and props and noted that there’s a solution to modify the input while keeping everything in sync. That solution is what we will explore next.\nUpdating props using derived states\nIn an attempt to synchronize the `value` prop with changes to the input bound to `triple`, one might be tempted to add another reactive declaration. This declaration would update the `value` prop to be one-third of `triple` whenever `triple` changes. Here is the proposed modification:\n\n```", "```js\n\n As we discussed earlier, it’s best practice to maintain a one-way data flow for derived states to simplify debugging and data management. Indeed, the Svelte compiler flags the preceding code snippet for cyclical dependencies. This is because `double` is derived from `value`, and `value` is in turn dependent on `double`.\nHowever, Svelte’s compiler determines dependency relationships based solely on the reactive declarations. By refactoring the code to make these relationships less obvious, you can bypass the compiler’s cyclical dependency check. Here’s a refactored version of the code that does just that:\n\n```", "```js\n\n In the provided code snippet, we’ve shifted the equations `value = double / 2` and `value = triple / 3` into separate functions named `updateValueFromDouble` and `updateValueFromTriple`. This change lets us evade Svelte’s compiler warning about cyclical dependencies.\nHowever, there’s a catch. If you try altering the `triple` input, it updates `value` but doesn’t refresh `double`. This happens because Svelte avoids infinite update loops. Changing `triple` would set off a chain reaction—updating `value`, then `double`, then back to `value`, and so on.\nThis is how the data flow looks right now:\n![](img/B18887_03_4.jpg)\n\nFigure 3.4: Data flows between props, states, and the input elements\nAs you can see in the diagram, we update the value of `value`, `double`, and `triple` through reactive declarations, creating a loop in the data flow, indicated by the bold arrows.\nTherefore, using derived states to update their original properties via reactive declarations isn’t advisable.\nA better approach to keep `value`, `double`, and `triple` in sync is to establish value as the single source of truth. Since both `double` and `triple` are derived from `value`, any changes to the input should first update `value`. This, in turn, triggers the reactive declarations to automatically recalculate `double` and `triple`.\nHere’s the updated code:\n\n```", "```js\n\n```"]