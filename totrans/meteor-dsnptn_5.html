<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Testing Patterns"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Testing Patterns</h1></div></div></div><p class="calibre7">This chapter will cover testing patterns that ensure our code is easy to maintain. With these patterns, you will learn how to implement regression testing—a method to identify if the new code breaks the old code before the code goes into production. Building tests is crucial to maintain code and collaborate with others. You will learn the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Behavior tests</li><li class="listitem">Unit tests</li></ul></div><p class="calibre7">Testing in Meteor is still under heavy development, but the functions that we will cover are basic and are unlikely to change.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Testing Patterns">
<div class="book" title="Behavior tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec33" class="calibre1"/>Behavior tests</h1></div></div></div><p class="calibre7">Behavior tests <a id="id351" class="calibre1"/>are known as end-to-end tests too. The purpose of a behavior test is simple: it makes sure that a feature of the project is working. A feature refers to the business logic behind the application. For example, a feature of our current project is viewing a list of products in our landing page. Another feature is the ability to add a variable quantity of products to the order.</p><p class="calibre7">To run behavior<a id="id352" class="calibre1"/> tests in Meteor, we essentially need to build a robot that can visit our website and try to make these features work. While this sounds complex, the Meteor Velocity project simplifies much of this when paired with Cucumber.</p><p class="calibre7">Velocity is a project that sets the stage for other testing frameworks to use. It works by creating mirrors of the project where tests can run.</p><p class="calibre7">Cucumber is a specification-by-example testing framework. It is meant to describe application features in plain English before they are programmed. In a collaboration setting, these tests are<a id="id353" class="calibre1"/> the ones that matter most because they make sure that the application is behaving as expected. We will use the Cucumber package now because it is one of the only testing frameworks that support behavior tests that are currently available to Meteor.</p><p class="calibre7">To build tests, we first need to install the <code class="email">xolvio:cucumber</code> package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">meteor add xolvio:cucumber</strong></span>
</pre></div><p class="calibre7">This package automatically installs Velocity and all other required packages. Now run the Meteor command to start up the server. The following two things are going to happen:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A new browser window will open if there are any tests to run</li><li class="listitem">The current project will have a dot on the top-right side</li></ul></div><p class="calibre7">The new browser window is what we<a id="id354" class="calibre1"/> call a <span class="strong"><strong class="calibre2">mirror</strong></span> and is the client that is going to run all the behavior tests that we define. While this is great, it is annoying to have a second browser window open and close every time we run the Meteor command.</p><p class="calibre7">To get rid of the second browser window, we can use <code class="email">phantomjs</code> to run tests. To do this, we will simply run the Meteor command with some settings:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">SELENIUM_BROWSER=phantomjs meteor</strong></span>
</pre></div><p class="calibre7">PhantomJS is a headless browser. A headless browser is a web browser (such as Safari and Chrome) without a <a id="id355" class="calibre1"/>
<span class="strong"><strong class="calibre2">Graphical User Interface</strong></span> (<span class="strong"><strong class="calibre2">GUI</strong></span>). In other words, it's a browser for robots, and this is exactly what our robot needs to run our tests.</p><p class="calibre7">Let's make a custom Meteor alias with this command. Open the <code class="email">~/.bash_profile</code> directory with your favorite text editor. If you use Sublime Text 3, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">sublime ~/.bash_profile</strong></span>
</pre></div><p class="calibre7">In this file, add this line to the end of the document:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># ~/.bash_profile</strong></span>

alias devmeteor='SELENIUM_BROWSER=phantomjs meteor'</pre></div><p class="calibre7">Now completely quit your terminal, and then open it again. Go to your project and run the <code class="email">devmeteor</code> command to start your project.</p><p class="calibre7">Go to the project URL. Here, you will notice a blue circle on the top-right corner of the project. Click this to reveal the velocity test dashboard. Whenever tests fail, here you will see why they failed. All tests are rerun every time there is a change in the code.</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Behavior tests" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre7">Let's start by<a id="id356" class="calibre1"/> building our first behavior test. In this test, we are going to check whether we can add items to the order. To do this, we need to program two key components:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Features</li><li class="listitem">Steps</li></ul></div><p class="calibre7">
<span class="strong"><strong class="calibre2">Steps</strong></span> are, basically, snippets of<a id="id357" class="calibre1"/> code in JavaScript or CoffeeScript that<a id="id358" class="calibre1"/> interpret the <span class="strong"><strong class="calibre2">feature</strong></span>. Step snippets are automatically generated after writing a feature. Therefore, we need to start by writing the description of the feature.</p><p class="calibre7">All our tests are going to be saved under the <code class="email">/tests</code> directory. Behavior tests will always go under the <code class="email">/cucumber</code> folder. At the time of this writing book, this has been mandatory because Velocity runs under these special directories only:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/features/cart/add to cart.feature</strong></span>

Feature: Add to Cart

  As a customer
  I want to add items to my cart
  So I can checkout

  Background:
    Given I am an anonymous customer

  @dev
  Scenario: Add one to cart
    When I navigate to "/"
    And I click on the first button with class ".add-to-cart"
    Then I should have one product with quantity 1 in my cart</pre></div><p class="calibre7">Notice that the file <a id="id359" class="calibre1"/>ends in <code class="email">.feature</code> and is located under the <code class="email">/features</code> directory. Placing files under the <code class="email">features</code> directory is mandatory as well for the testing suite to be able to identify your feature files.</p><p class="calibre7">This file is written in the Gherkin language. If you want to add comments, you can use the pound sign (<code class="email">#</code>) just we do in CoffeeScript. The <code class="email">Feature</code> keyword describes the feature; this can be anything as long as it helps you to identify what the feature is. After this, we can see three lines that describe the purpose of the feature. This description can also be anything you want since this does not affect the test, but it is common to use the following syntax to help identify whether the feature is useful or not:</p><div class="informalexample"><pre class="programlisting">  As a [role]
  I want [feature]
  So that [benefit]</pre></div><p class="calibre7">Next, we will find the <code class="email">Background</code> and <code class="email">Scenario</code> keywords. Both are a list of actions that lead to a result. For each feature, there can be multiple scenarios that test the different parts of the feature. The <code class="email">Background</code> keyword defines a list of actions to be taken before running the ones under the <code class="email">Scenario</code> keyword. Try to keep backgrounds short and simple, and keep in mind that they will run for every scenario.</p><p class="calibre7">Also, notice that we have an <code class="email">@dev</code> keyword directly above the <code class="email">Scenario</code> keyword; this keyword controls where <code class="email">Scenario</code> is going to run. If you do not include a keyword, it will only run when you run <code class="email">meteor --test</code> in your terminal. If you include <code class="email">@dev</code>, the test will run every time you make changes to your web application. Also, you can include <code class="email">@ignore</code> to ignore the test completely.</p><p class="calibre7">The <code class="email">Given</code>, <code class="email">When</code>, <code class="email">And</code>, and <code class="email">Then</code> keywords are commands that run the steps in our test code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Given</code>: The purpose of <code class="email">Given</code> is to put the app<a id="id360" class="calibre1"/> in a known state before any interaction occurs.</li><li class="listitem"><code class="email">When</code>: The purpose of <code class="email">When</code> is to<a id="id361" class="calibre1"/> describe the key action the user performs.</li><li class="listitem"><code class="email">And</code>: The purpose of <code class="email">And</code> is to write <a id="id362" class="calibre1"/>scenarios more fluently. They, basically, substitute <code class="email">And</code> with the previous keyword.</li><li class="listitem"><code class="email">Then</code>: The purpose of <code class="email">Then</code> is to<a id="id363" class="calibre1"/> observe and evaluate outcomes. This phrase will always make sure that the system has produced something.</li></ul></div><p class="calibre7">Now that we have programmed our first feature, let's generate the steps that will execute the feature. Run your alias command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">devmeteor</strong></span>
</pre></div><p class="calibre7">Once the server has started, Velocity will produce a command you can use to tail the projects' <code class="email">cucumber.log</code>. Open up a separate terminal without deactivating Meteor and run that command. It <a id="id364" class="calibre1"/>should look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">tail -f /Users/YOU/pathtoyourproject/online_shop/.meteor/local/log/cucumber.log</strong></span>
</pre></div><p class="calibre7">Now you will see something like this:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Behavior tests" class="calibre8"/></div><p class="calibre9"> </p><p class="calibre7">If you don't, you can restart the Meteor project without leaving <code class="email">cucumber.log</code>. Here, we can see the JavaScript version of the steps that the feature is expecting. Let's rewrite these in CoffeeScript under the special <code class="email">/step_definitions</code> directory. This directory must always be a sibling to the related <code class="email">.feature</code> files.</p><p class="calibre7">Copy the code snippets and create a new file under the <code class="email">/tests/cucumber/features/cart/step_definitions/steps.coffee</code> directory. We are going to <a id="id365" class="calibre1"/>convert these snippets to CoffeeScript, since this is what we<a id="id366" class="calibre1"/> have been working with all along. You can do this quickly at <a class="calibre1" href="http://js2.coffee">http://js2.coffee</a>.</p><p class="calibre7">Notice that each function passes a <code class="email">callback</code> variable at the end and calls the <code class="email">pending()</code> function. When tests run, this indicates that the function has not been built yet and appears as pending in the Cucumber log. We can remove the <code class="email">callback</code> variable after we have finished working with the function. Notice that arguments are passed as well.</p><p class="calibre7">Running tests with this code will not work; we need to initialize the test properly. To do this, we begin by using <a id="id367" class="calibre1"/>CoffeeScripts' <code class="email">do</code> function and attaching the commands to the <code class="email">module.exports</code> function. You need to do this for every test file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/features/cart/step_definitions/steps.coffee</strong></span>

do -&gt;
  'use strict'

  module.exports = -&gt;
    @Given ...
    @When ...
    @Then ...</pre></div><p class="calibre7">Now that the tests are actually running, we can dive deeper. The first function that we will address is <code class="email">Given</code>. <code class="email">Given</code> needs to make sure that the user is completely new and has no active order. To do this, we are <a id="id368" class="calibre1"/>going to use <span class="strong"><strong class="calibre2">fixtures</strong></span>. Fixtures are <code class="email">Meteor.methods</code> exclusively available in testing. We can use these methods to clear our database or add seed data. Let's start by making a fixture that ensures that the user is anonymous and another fixture that clears all the orders:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/fixtures/cart_fixtures.coffee</strong></span>

do -&gt;
  'use strict'

  Meteor.methods
    "anonymous_user": -&gt;
      if @userId
        @setUserId null

    "reset_orders": -&gt;
      Orders.remove {}
      OrderDetails.remove {}</pre></div><p class="calibre7">Now, we can <a id="id369" class="calibre1"/>call these methods in the <code class="email">Given</code> function (or any other function) using the <code class="email">@server.call</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/features/cart/step_definitions/steps.coffee</strong></span>

do -&gt;
  'use strict'

  module.exports = -&gt;
    @Given /^I am an anonymous customer$/, -&gt;
      @server.call "reset_orders"
      @server.call "anonymous_user"</pre></div><p class="calibre7">Notice that we are using <code class="email">@server</code>, but we can use <code class="email">@client</code> too since this is a call to <code class="email">Meteor.method</code>. Now let's program <code class="email">When</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/features/cart/step_definitions/steps.coffee</strong></span>

do -&gt;
  'use strict'
  ...

  module.exports = -&gt;
    url = require('url')
    @Given /^I am an anonymous customer$/, -&gt;
      ...

    @When /^I navigate to "([^"]*)"$/, (path) -&gt;
      @browser
        .url url.resolve(process.env.ROOT_URL, path)

    @When /^I click on the first button with class "([^"]*)"$/, (button) -&gt;
      @browser
        .waitForExist "body *"
        .waitForVisible ".product"
        .element ".product:nth-child(1) #{button}"
        .click()</pre></div><p class="calibre7">The <code class="email">@browser</code> object gives access to an instance of webdriver. This means that we can use the webdriver functions to simulate user clicks, inspect elements, and browse the Web. Notice that we can require NPM modules through the <code class="email">require</code> function as well. In this case, we will require the <code class="email">url</code> module to help identify routes.</p><p class="calibre7">The first <code class="email">When</code> function requires a single argument defined by the regular expression. In this case, it is the <code class="email">path</code> variable. Arguments will always be listed one by one as they are defined in the<a id="id370" class="calibre1"/> regular expression, and they will end with the callback function (which we do not need to use): <code class="email">(arg1, arg2, arg3, callback) -&gt;</code>.</p><p class="calibre7">The second <code class="email">When</code> function needs to wait for the DOM to load before acting on it. To do this, we will use the <code class="email">waitForExist</code> and <code class="email">waitForVisible</code> functions. If the elements do not render, then the test will fail due to a timeout in this function. Remember that if you ever want to see what the test is doing, you can browse to your mirror.</p><p class="calibre7">You can find a full list of the <a id="id371" class="calibre1"/>available webdriver functions at <a class="calibre1" href="http://webdriver.io/api.html">http://webdriver.io/api.html</a>, but here is a list of the ones you will use the most:</p><div class="informalexample"><table border="1" class="calibre12"><colgroup class="calibre13"><col class="calibre14"/><col class="calibre14"/></colgroup><thead class="calibre15"><tr class="calibre16"><th valign="bottom" class="calibre17">
<p class="calibre18">Function</p>
</th><th valign="bottom" class="calibre17">
<p class="calibre18">Use</p>
</th></tr></thead><tbody class="calibre19"><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">waitForExist(selector[,timeout,reverse])</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">Default<a id="id372" class="indexterm"/> timeout: <code class="literal">500</code>, reverse: <code class="literal">false</code>.</p>
<p class="calibre18">This waits for an element to render on the DOM. Setting the <code class="literal">reverse</code> flag to <code class="literal">true</code> will instead wait for the element to stop existing.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">waitForVisible(selector[,timeout,reverse])</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">Default timeout: <code class="literal">500</code>, reverse: <code class="literal">false</code>.</p>
<p class="calibre18">This waits for an element to be visible (checks that the display CSS property is <a id="id373" class="indexterm"/>not set to any, that the element is not outside the viewport, and that the <code class="literal">opacity</code> CSS property is not set to <code class="literal">0</code>). Setting the <code class="literal">reverse</code> flag to <code class="literal">true</code> will instead wait for the element to be<a id="id374" class="indexterm"/> invisible.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">click(selector)</code>
</p>
<p class="calibre18">
<code class="literal">doubleClick(selector)</code>
</p>
<p class="calibre18">
<code class="literal">leftClick(selector)</code>
</p>
<p class="calibre18">
<code class="literal">rightClick(selector)</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">This clicks <a id="id375" class="indexterm"/>an element. Can<a id="id376" class="indexterm"/> take in a CSS <a id="id377" class="indexterm"/>selector.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">setValue(selector,values)</code>
</p>
<p class="calibre18">
<code class="literal">addValue(selector,values)</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">This sends a <a id="id378" class="indexterm"/>sequence of keystrokes to<a id="id379" class="indexterm"/> an element. Can use unicode characters as well to simulate things such as backspace and arrow keys. The <code class="literal">addValue</code> function will append to a set value.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">getText(selector)</code>
</p>
<p class="calibre18">
<code class="literal">getValue(selector)</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">This gets the<a id="id380" class="indexterm"/> node text or input <a id="id381" class="indexterm"/>value.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">getCssProperty(selector,property)</code>
</p>
<p class="calibre18">
<code class="literal">getAttribute(selector,attribute)</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">This gets data on a <a id="id382" class="indexterm"/>CSS property<a id="id383" class="indexterm"/> or DOM element attribute. The <code class="literal">property</code> variable will return an object instead of a string.</p>
</td></tr><tr class="calibre16"><td valign="top" class="calibre20">
<p class="calibre18">
<code class="literal">then(function(valueFromGet))</code>
</p>
</td><td valign="top" class="calibre20">
<p class="calibre18">This uses <a id="id384" class="indexterm"/>data obtained from any <code class="literal">get</code> function. The first parameter is always the value of the <code class="literal">get</code> function.</p>
</td></tr></tbody></table></div><p class="calibre7">Now let's build <a id="id385" class="calibre1"/>our <code class="email">Then</code> function<a id="id386" class="calibre1"/> and use <span class="strong"><strong class="calibre2">Chai</strong></span> to evaluate that everything proceeded as expected:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/cucumber/features/cart/step_definitions/steps.coffee</strong></span>

do -&gt;
  'use strict'

  module.exports = -&gt;
    ...

    @Then /^I should have one product with quantity one in my cart$/, -&gt;
      @browser
        .waitForVisible ".order_detail"
        .getText ".order_detail:nth-child(1) .quantity"
        .then (quantity) -&gt;
          expect quantity
            .to.equal "1"</pre></div><p class="calibre7">Here, we have used the <code class="email">then</code> function to work with the value from the <code class="email">.quantity</code> node. We use Chai to<a id="id387" class="calibre1"/> check whether the value obtained is correct. The list of Chai functions is<a id="id388" class="calibre1"/> long, and you will find yourself using most of them. They are easy to guess though! You can find all of these functions here: <a class="calibre1" href="http://chaijs.com/api/bdd">http://chaijs.com/api/bdd</a>.</p></div></div>
<div class="book" title="Unit tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Unit tests</h1></div></div></div><p class="calibre7">Unit tests are much easier to build than behavior tests. These tests make sure that only a section of the web application is working correctly, such as <code class="email">Meteor.method</code> or a template helper.</p><p class="calibre7">Unit tests make it quicker to<a id="id389" class="calibre1"/> find bugs in broken behavior tests. They should be used mostly in parts that you know can break easily, such as a publisher or a particular helper.</p><p class="calibre7">To run<a id="id390" class="calibre1"/> unit tests, we are going to use the <code class="email">sanjo:jasmine</code> package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">meteor add sanjo:jasmine</strong></span>
</pre></div><p class="calibre7">Now create two directories: <code class="email">/jasmine/client/integration</code> and <code class="email">/jasmine/server/integration</code>. These are the special directories where <code class="email">jasmine</code> runs tests. Let's build a quick test for the <code class="email">products</code> publisher:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># /tests/jasmine/client/integration/publishers/products_pub_test.coffee</strong></span>

do -&gt;
  'use strict'

  describe "Products publisher", -&gt;
    it "should return product data", -&gt;
      # SETUP
      subscription = Meteor.subscribe("products")

      if subscription.ready()
        # EXECUTE
        product = Products.findOne()

        # VERIFY
        expect product
          .not.toBeUndefined()</pre></div><p class="calibre7">Jasmine is simple. First, you use the <code class="email">describe</code> function to describe the object of the feature, and then you use the <code class="email">it</code> function to explain each part of the feature that should work. It is <a id="id391" class="calibre1"/>common to divide the evaluating function into three blocks: <code class="email">SETUP</code>, <code class="email">EXECUTE</code> and <code class="email">VERIFY</code>. At setup, we make sure that everything is ready for the test to run, then we execute a series of functions, and finally, we use the Chai expressions to verify whether the test passes or fails.</p><p class="calibre7">Unit tests are great for<a id="id392" class="calibre1"/> testing peculiarities in your code that users might not see reflected visually. Have a look at the Jasmine documentation at <a class="calibre1" href="http://jasmine.github.io/2.3/introduction.html">http://jasmine.github.io/2.3/introduction.html</a> for a collection of great examples.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned how to build simple tests for our web application. In addition, we learned that they are a crucial part of the development process in order to maintain the application in both a team and nonteam setting. Behavior tests are the tests that make sure that the application is running all the features as expected, while unit tests are the tests that make sure that only particular weak spots are running as expected. Be careful with testing. While it is important to keep tests active for maintenance, it is more important to focus on the programming of the product. If you do not have time to write a full behavior test, write at least one unit test on a function that is critical for the web application to work.</p><p class="calibre7">In the next chapter, we are going to cover how to deploy our web application to a production quality server and how to identify errors produced by the application easily, once the application is running.</p></div></body></html>