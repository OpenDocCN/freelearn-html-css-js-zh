<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Utilizing Caching in EaselJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Utilizing Caching in EaselJS</h1></div></div></div><p>As you know, after developing an animation, it's very important to work on the performance issues to make it smooth. The performance of rendering animations varies between browsers but there are some techniques like caching that can simply improve the performance. In this chapter, we will learn how to make better and smooth animations or drawings using the <span class="emphasis"><em>EaselJS</em></span> caching system of <a id="id89" class="indexterm"/>
<code class="literal">DisplayObject</code>.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring the caching feature of EaselJS</li><li class="listitem" style="list-style-type: disc">Understanding the cache method</li><li class="listitem" style="list-style-type: disc">Example of using cache</li><li class="listitem" style="list-style-type: disc">Using cache in animations</li><li class="listitem" style="list-style-type: disc">Using cache with Bitmap</li></ul></div><div class="section" title="Exploring the caching feature of EaselJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Exploring the caching feature of EaselJS</h1></div></div></div><p>In EaselJS, <a id="id90" class="indexterm"/>when you have a shape, or even better, an <a id="id91" class="indexterm"/>instance of the <code class="literal">DisplayObject</code> that doesn't change frequently, it's better to use the <span class="emphasis"><em>cache </em></span>function to cache it in a different <code class="literal">Canvas</code> element. This technique will help you use EaselJS in the drawing process to animate and render animations or drawings smoothly, as the shapes don't need to be rendered with every tick.</p><p>It is basically the main idea of using the <code class="literal">cache</code> method in the <code class="literal">DisplayObject</code> class. All you need to do is learn more about using the cache method in EaselJS. In further sections, we will go through methods, their usage, and how to create animations with caching.</p></div></div>
<div class="section" title="Understanding the cache method"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Understanding the cache method</h1></div></div></div><p>In order to <a id="id92" class="indexterm"/>understand how caching a <code class="literal">DisplayObject</code> works in EaselJS, we take the example of an imaginary canvas area so that the cached elements get rendered into it and each time you need to update the target shape, you call the <code class="literal">cache</code> method again.</p><p>You can see the definition of the <code class="literal">cache</code> method inside the <code class="literal">DisplayObject</code> class in the following piece of code:</p><div class="informalexample"><pre class="programlisting">cache (x, y, width, height, [scale=1])</pre></div><div class="blockquote"><blockquote class="blockquote"><p>Draws the display object into a new canvas, which is then used for subsequent draws. For complex content that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape), this can provide for much faster rendering because the content does not need to be re-rendered each tick. The cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually update the cache by calling <code class="literal">updateCache()</code> or <code class="literal">cache()</code> again. You must specify the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached using this display object's coordinates.</p></blockquote></div><p>This has been taken from:</p><p>
<a class="ulink" href="http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache">http://www.createjs.com/Docs/EaselJS/classes/DisplayObject.html#method_cache</a>
</p><p>As you can see, the <code class="literal">cache</code> method accepts four mandatory and one optional parameter. The first and second parameters define the <span class="emphasis"><em>coordinate</em></span>
<span class="strong"><strong> </strong></span>of the cache area; the third and fourth parameters define the <span class="emphasis"><em>width</em></span> and <span class="emphasis"><em>height</em></span> of the cache area. Using the last parameter, you can define the <span class="emphasis"><em>scale of shape</em></span> inside the cache area. By default it is set as <code class="literal">1</code>, but you can change it.</p><div class="section" title="Example of using cache"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>Example of using cache</h2></div></div></div><p>Now it's <a id="id93" class="indexterm"/>time to see an example of using the <code class="literal">cache</code> method in EaselJS. The following piece of code uses the <code class="literal">cache</code> method to render a circle into a canvas element:</p><div class="informalexample"><pre class="programlisting">var shape = new createjs.Shape(); 
shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25); 
shape.cache(-25, -25, 50, 50);</pre></div><p>In the first line, we created a shape using the <code class="literal">Shape</code> class, filled it with red color, and then rendered it at <code class="literal">(0, 0)</code> with a radius of <code class="literal">25</code>. In the third line, you will notice the use of the <code class="literal">cache</code> method. In this line, a <span class="emphasis"><em>cache area</em></span> is created at <code class="literal">-25</code>, <code class="literal">-25</code> with a width and height of <code class="literal">50</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>In order to update the target shape (the shape variable in the above example), you need to call the <code class="literal">cache</code> or <code class="literal">updateCache</code> method with all new parameters again.</p></div></div><p>The complete<a id="id94" class="indexterm"/> source code and result is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="content-type" content="text/html;charset=UTF-8"&gt;
&lt;title&gt;Cache method in EaselJS&lt;/title&gt;
&lt;script type='text/javascript' src='createjs.js'&gt;&lt;/script&gt;

&lt;script type='text/javascript'&gt;
window.onload=function() {
  var canvas = document.getElementById("testCanvas");
  var stage = new createjs.Stage(canvas);

  var shape = new createjs.Shape();
  shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25); 
  shape.cache(-25, -25, 50, 50);

  stage.addChild(shape);
  stage.update();
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;canvas id="testCanvas" width="400" height="100" style="border: 1px solid black;"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The above source code is the completed example of using the cache method in EaselJS. The result of this source code is as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0260OS_05_01.jpg" alt="Example of using cache"/></div></div></div>
<div class="section" title="Using cache in complex shapes and animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Using cache in complex shapes and animations</h1></div></div></div><p>Caching in <a id="id95" class="indexterm"/>EaselJS comes in handy when you have a complex shape or animation in your canvas. In most cases, complex shapes with details shouldn't get rendered in every tick. So you can simply use the cache method to cache it in order to prevent rendering overhead.</p><p>Now we will see a complex example from the EaselJS library<a id="id96" class="indexterm"/> (source: <a class="ulink" href="https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html">https://github.com/CreateJS/EaselJS/blob/master/examples/Cache.html</a>) and the effect of using a cache technique on that. In this animation, we will create about <span class="emphasis"><em>200</em></span> complex circles and move them on each tick. There is a checkbox on the page that controls the enabling or disabling of caching for all shapes inside the canvas area using <code class="literal">cache</code> and <code class="literal">uncache</code> methods.</p><p>The following screenshot shows us a preview of our animation (notice the checkbox):</p><div class="mediaobject"><img src="graphics/0260OS_05_02.jpg" alt="Using cache in complex shapes and animations"/></div><p>There are three main functions that handle this animation and all the logics; <code class="literal">init</code>, <code class="literal">tick</code>, and <code class="literal">toggleCache</code>. We will discuss each one of them separately.</p><p>In the first lines of the code, we will use the following variables:</p><div class="informalexample"><pre class="programlisting">var canvas;
var stage;
var shape;
varcircleRadius= 30;
var rings = 30;</pre></div><p>The first <a id="id97" class="indexterm"/>variable holds the canvas element, the second one is used for the <code class="literal">Stage</code> object, the <code class="literal">shape</code> variable is used to draw shapes on the stage, and <code class="literal">circleRadius</code> and <code class="literal">rings</code> are used for basic settings of circles. <code class="literal">circleRadius</code> is used to define the radius of each circle and <code class="literal">rings</code> is used to define the number of rings inside each circle.</p><p>The following code shows the the basic <code class="literal">init</code> method that draws all shapes and prepares the stage:</p><div class="informalexample"><pre class="programlisting">Function init() {
  // create a new stage and point it at our canvas:
  canvas = document.getElementById("testCanvas");
  stage = new createjs.Stage(canvas);

  // create a large number of slightly complex vector shapes, and give them random positions and velocities:

  var colors = ["#828b20", "#b0ac31", "#cbc53d", "#fad779", "#f9e4ad", "#faf2db", "#563512", "#9b4a0b", "#d36600", "#fe8a00", "#f9a71f"];

  for(var i= 0; i&lt; 200; i++) {
    shape = new createjs.Shape();
      for(var j = rings; j &gt; 0; j--) {
        shape.graphics.beginFill(colors[Math.random() * colors.length | 0]).drawCircle(0, 0, circleRadius * j / rings);
    }
    shape.x = Math.random() * canvas.width;
    shape.y = Math.random() * canvas.height;
    shape.velX = Math.random() * 10 - 5;
    shape.velY = Math.random() * 10 - 5;

    stage.addChild(shape);
  }

  // add a text object to output the current FPS:
  fpsLabel = new createjs.Text("-- fps", "bold 18px Arial", "#FFF");
  stage.addChild(fpsLabel);
  fpsLabel.x = 10;
  fpsLabel.y = 20;

  // start the tick and point it at the window so we can do some work before updating the stage:
  createjs.Ticker.addEventListener("tick", tick);
  createjs.Ticker.setFPS(50);
}</pre></div><p>This code<a id="id98" class="indexterm"/> is used to create the stage and all shape objects. In lines 3 and 4, the <code class="literal">Stage</code> object is created. In line 8, we defined random colors for circle rings. After that, we have used a <span class="emphasis"><em>for-loop</em></span>, which draws 200 different circles with random positions on the stage. We have another for-loop to draw rings inside the circles in line 12.</p><p>In our animation, we have a label that indicates the <span class="strong"><strong>Frames per Second</strong></span> (<span class="strong"><strong>FPS)</strong></span> rate<a id="id99" class="indexterm"/> on each tick. So, in lines 28 to 31, we have defined our label properties. In line 34, the <code class="literal">Ticker</code> class is created and in line 36, the FPS of the animation is set to <code class="literal">50</code>.</p><p>After the <code class="literal">init</code> function, we have a tick function that will be called on each tick by EaselJS:</p><div class="informalexample"><pre class="programlisting">function tick(event) {
  var w = canvas.width;
  var h = canvas.height;
  var l = stage.getNumChildren() - 1;

  // iterate through all the children and move them according to their velocity:
  for(var i= 1; i&lt; l; i++) {
    var shape = stage.getChildAt(i);
    shape.x = (shape.x + shape.velX + w) % w;
    shape.y = (shape.y + shape.velY + h) % h;
  }
  fpsLabel.text = Math.round(createjs.Ticker.getMeasuredFPS()) + " fps";
  // draw the updates to stage:
  stage.update(event);
}</pre></div><p>The main <a id="id100" class="indexterm"/>job of the above <code class="literal">init</code> function is to change the position of all the circles on the stage on each tick, set the current FPS rate to the label, and then update the stage. The reason there is <code class="literal">-1</code> in line 4 is to exclude the label object from <code class="literal">children</code>; keep in mind that we only need to change the position of all the circles.</p><p>The last function is the <code class="literal">toggleCache</code> function<a id="id101" class="indexterm"/>. This method enables or disables caching for all circles:</p><div class="informalexample"><pre class="programlisting">function toggleCache(value) {
  // iterate all the children except the fpsLabel, and set up the cache:
  var l = stage.getNumChildren() - 1;
  for(var i= 0; i&lt; l; i++) {
    var shape = stage.getChildAt(i);
    if (value) {
      shape.cache(-circleRadius, -circleRadius, circleRadius * 2,circleRadius * 2);
    } else {
      shape.uncache();
    }
  }
}</pre></div><p>This function is called only when you check or uncheck the checkbox on the page so it enables or disables caching for all circle objects on <code class="literal">stage</code>. There is a for-loop that iterates over all circle shapes and calls the <code class="literal">cache</code> or <code class="literal">uncache</code> method according to the status of the checkbox. Consequently, the caching for circle shapes will be enabled or disabled.</p><p>By clicking on the checkbox, you can obviously see that the animation rendering gets smoother when caching is enabled.</p><p>Finally, you can find the complete source code of our animation on the Packt website.</p></div>
<div class="section" title="Caching Bitmap"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Caching Bitmap</h1></div></div></div><p>In this section, we will utilize<a id="id102" class="indexterm"/> the <code class="literal">cache</code> method with Bitmap and <code class="literal">AlphaMaskFilter</code> to develop a reflection effect in EaselJS. The target is to load an image and create a <code class="literal">Bitmap</code> class to draw the image. Then, clone the <code class="literal">Bitmap</code> image, change the rotation and add a gradient background, and use <code class="literal">AlphaMaskFilter</code> to create the reflection effect.</p><p>The following screenshot is a preview of the result:</p><div class="mediaobject"><img src="graphics/0260OS_05_03.jpg" alt="Caching Bitmap"/></div><p>The following is the source code of this example:</p><div class="informalexample"><pre class="programlisting">function init() {
  var canvas = document.getElementById("canvas");
  var stage = new createjs.Stage(canvas);

  var image = new Image();
  image.src = "easeljs.png";

  //wait to load the image
  image.onload = function(evt) {
    var bitmap = new createjs.Bitmap(evt.target);
    var width = bitmap.image.width;
    var height = bitmap.image.height;

    //clone the existing bitmap to use as reflection
    var reflectBitmap = bitmap.clone();
    reflectBitmap.regY = height;
    reflectBitmap.rotation = 180;

    //to add a padding from the main bitmap
    reflectBitmap.y = height + 2;
    reflectBitmap.scaleX = -1;

    var maskShape = new createjs.Shape();
    var graphics = maskShape.graphics;
    //add reflection effect
    graphics.beginLinearGradientFill(["rgba(255, 255, 255, 0)", "rgba(255, 255, 255, 0.6)"], [0.5, 1], 0, 10, 0, height);
    graphics.drawRect(0, 0, width, height);
    graphics.endFill();

    maskShape.cache(0, 0, width, height);

    reflectBitmap.filters = [new createjs.AlphaMaskFilter(maskShape.cacheCanvas)];
    reflectBitmap.cache(0, 0, width, height);

    //add both pictures
    stage.addChild(bitmap);
    stage.addChild(reflectBitmap);
    stage.update();
  }
}</pre></div><p>As seen in <a id="id103" class="indexterm"/>previous examples, firstly, we created the <code class="literal">Stage</code> class. Then, in order to load the image, we used the <code class="literal">Image</code> class and passed the address of the image to the <code class="literal">src</code> property. The <code class="literal">Image</code> class has an <code class="literal">onload</code> event, which helps developers know when the image is loaded completely. We used this event to execute other parts of the application correctly.</p><p>After that, we used a <code class="literal">Bitmap</code> class and passed the image parameter from the <code class="literal">Image</code> class to it. Because we need the width and height of the picture, we saved them into two different variables called <code class="literal">width</code> and <code class="literal">height</code>. At this moment, we have the first picture but we should have one more picture to create the reflection effect. So, we used the <code class="literal">clone</code> function to duplicate the image. In order to change the rotation, scale, and coordination of the second image, we changed the <code class="literal">regY</code>, <code class="literal">rotation</code>, <code class="literal">y</code>, and <code class="literal">scaleX</code> properties.</p><p>After that, a new shape is created using the <code class="literal">Shape</code> class. This is the mask layer that will be used for the <code class="literal">AlphaMaskFilter</code>. Then, we added a linear background to it to create the reflection <a id="id104" class="indexterm"/>effect and cached it using the <code class="literal">cache</code> function. Finally, an <code class="literal">AlphaMaskFilter</code> is added to the second picture (a cloned <code class="literal">Bitmap</code> class) and this shape is used as the mask layer. The second picture is also cached again. Both pictures are added to <code class="literal">Stage</code> using the <code class="literal">addChild</code> function and <code class="literal">Stage</code> is also updated with the <code class="literal">update</code> function.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we have learned how to work with the <code class="literal">cache</code> method in EaselJS to create better drawings and animations on the canvas. The reason we use caching in EaselJS is to provide better and faster animation rendering in browsers and also use fewer resources while rendering the animations or drawings. In the next section, we discussed about using the cache method with the <code class="literal">Bitmap</code> class to create the reflection effect.</p><p>In the next chapter, we will talk about applying filters in canvas with EaselJS, which is one of the best features of EaselJS, and you can make fantastic stuff with this feature.</p></div></body></html>