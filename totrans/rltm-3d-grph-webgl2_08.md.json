["```js\nconst canvas = document.getElementById('webgl-canvas');\nconst { width, height } = canvas;\n\nconst texture = gl.createTexture();\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n```", "```js\nconst renderbuffer = gl.createRenderbuffer();\ngl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\ngl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\n```", "```js\nconst framebuffer = gl.createFramebuffer();\n```", "```js\ngl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n```", "```js\ngl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n```", "```js\ngl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n```", "```js\ngl.bindTexture(gl.TEXTURE_2D, null);\ngl.bindRenderbuffer(gl.RENDERBUFFER, null);\ngl.bindFramebuffer(gl.FRAMEBUFFER, null);\n```", "```js\nfunction render() {\n  // off-screen rendering\n  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  // we set the uniform to true because of an offscreen render\n  gl.uniform1i(program.uOffscreen, true);\n  draw();\n\n  // on-screen rendering\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  // we set the uniform to false because of the default render\n  gl.uniform1i(program.uOffscreen, false);\n  draw();\n}\n```", "```js\nvoid main(void) {\n\n  if (uOffscreen) {\n    fragColor = uMaterialDiffuse;\n    return;\n  }\n\n  // ...\n}\n```", "```js\nfunction init() {\n  configure();\n  load();\n\n  // instead of calling 'draw', we are now calling 'render'\n  clock.on('tick', render);\n}\n```", "```js\nconst canvas = document.getElementById('webgl-canvas');\n\ncanvas.onmouseup = event => {\n  // capture coordinates from the `event`\n};\n```", "```js\nlet top = 0,\n  left = 0;\n\nwhile (canvas && canvas.tagName !== 'BODY') {\n  top += canvas.offsetTop;\n  left += canvas.offsetLeft;\n  canvas = canvas.offsetParent;\n}\n```", "```js\nconst x = ev.clientX - (a + b + c);\nconst y = canvasHeight - (ev.clientY - (d + e + f));\n```", "```js\nleft += window.pageXOffset;\ntop -= window.pageYOffset;\n```", "```js\nx = ev.clientX - left;\ny = canvas.height - (ev.clientY - top);\n```", "```js\n// read one pixel\nconst readout = new Uint8Array(1 * 1 * 4);\ngl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\ngl.readPixels(coords.x, coords.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, readout);\ngl.bindFramebuffer(gl.FRAMEBUFFER, null);\n```", "```js\nfunction compare(readout, color) {\n  return (\n    Math.abs(Math.round(color[0] * 255) - readout[0]) <= 1 &&\n    Math.abs(Math.round(color[1] * 255) - readout[1]) <= 1 &&\n    Math.abs(Math.round(color[2] * 255) - readout[2]) <= 1\n  );\n}\n```", "```js\nlet pickedObject;\n\nscene.traverse(object => {\n  if (compare(readout, object.diffuse)) {\n    // Returning any value from the 'scene.traverse' method breaks the loop\n    return pickedObject = object;\n  }\n});\n```", "```js\ncamera.setElevation(0);\n```", "```js\nfunction positionGenerator() {\n  const\n    flagX = Math.floor(Math.random() * 10),\n    flagZ = Math.floor(Math.random() * 10);\n\n  let x = Math.floor(Math.random() * 60),\n    z = Math.floor(Math.random() * 60);\n\n  if (flagX >= 5) {\n    x = -x;\n  }\n  if (flagZ >= 5) {\n    z = -z;\n  }\n\n  return [x, 0, z];\n}\n```", "```js\nconst colorset = {};\n\nfunction objectLabelGenerator() {\n  const\n    color = [Math.random(), Math.random(), Math.random(), 1],\n    key = color.toString();\n\n  if (key in colorset) {\n    return objectLabelGenerator();\n  }\n  else {\n    colorset[key] = true;\n    return color;\n  }\n}\n```", "```js\nfunction diffuseColorGenerator(index) {\n  const color = (index % 30 / 60) + 0.2;\n  return [color, color, color, 1];\n}\n```", "```js\n0 % 30 = 0\n1 % 30 = 1\n...\n29 % 30 = 29\n30 % 30 = 0\n31 % 30 = 1\n... \n```", "```js\nfunction scaleGenerator() {\n  const scale = Math.random() + 0.3;\n  return [scale, scale, scale];\n}\n```", "```js\nfunction load() {\n  scene.add(new Floor(80, 20));\n\n  for (let i = 0; i < 100; i++) {\n    const objectType = Math.floor(Math.random() * 2);\n\n    const options = {\n      position: positionGenerator(),\n      scale: scaleGenerator(),\n      diffuse: diffuseColorGenerator(i),\n      pcolor: objectLabelGenerator()\n    };\n\n    switch (objectType) {\n      case 1:\n        return scene.load('/common/models/ch8/sphere.json', \n         `ball_${i}`, options);\n      case 0:\n        return scene.load('/common/models/ch8/cylinder.json', \n         `cylinder_${i}`, options);\n    }\n  }\n}\n```", "```js\nuniform vec4 uPickingColor;\n\nvoid main(void) {\n\n  if (uOffscreen) {\n    fragColor = uPickingColor;\n    return;\n  }\n  else {\n    // on-screen rendering\n  }\n\n}\n```", "```js\nfunction render() {\n  // Off-screen rendering\n  gl.bindFramebuffer(gl.FRAMEBUFFER, picker.framebuffer);\n  gl.uniform1i(program.uOffscreen, true);\n  draw();\n\n  // On-screen rendering\n  gl.uniform1i(program.uOffscreen, showPickingImage);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  draw();\n}\n```", "```js\npicker = new Picker(canvas, {\n  hitPropertyCallback: hitProperty,\n  addHitCallback: addHit,\n  removeHitCallback: removeHit,\n  processHitsCallback: processHits,\n  moveCallback: movePickedObjects\n});\n```", "```js\nfunction hitProperty(obj) {\n  return obj.pcolor;\n}\n```", "```js\nfunction addHit(obj) {\n  obj.previous = obj.diffuse.slice(0);\n  obj.diffuse = obj.pcolor;\n}\n```", "```js\nfunction removeHit(obj) {\n  obj.diffuse = obj.previous.slice(0);\n}\n```", "```js\nfunction processHits(hits) {\n  hits.forEach(hit => hit.diffuse = hit.previous);\n}\n```", "```js\nfunction movePickedObjects(dx, dy) {\n  const hits = picker.getHits();\n\n  if (!hits) return;\n\n  const factor = Math.max(\n    Math.max(camera.position[0], camera.position[1]), \n     camera.position[2]\n  ) / 2000;\n\n  hits.forEach(hit => {\n    const scaleX = vec3.create();\n    const scaleY = vec3.create();\n\n    if (controls.alt) {\n      vec3.scale(scaleY, camera.normal, dy * factor);\n    }\n    else {\n      vec3.scale(scaleY, camera.up, -dy * factor);\n      vec3.scale(scaleX, camera.right, dx * factor);\n    }\n\n    vec3.add(hit.position, hit.position, scaleY);\n    vec3.add(hit.position, hit.position, scaleX);\n  });\n}\n```", "```js\nconst hits = picker.getHits();\n```", "```js\nif (!hits) return;\n```", "```js\nconst factor = Math.max(\n  Math.max(camera.position[0], camera.position[1]), camera.position[2]\n) / 2000;\n```", "```js\nhits.forEach(hit => {\n  const scaleX = vec3.create();\n  const scaleY = vec3.create();\n\n  // ...\n});\n```", "```js\nif (controls.alt) {\n  vec3.scale(scaleY, camera.normal, dy * factor);\n}\n```", "```js\nelse {\n  vec3.scale(scaleY, camera.up, -dy * factor);\n  vec3.scale(scaleX, camera.right, dx * factor);\n}\n```", "```js\nvec3.add(hit.position, hit.position, scaleY);\nvec3.add(hit.position, hit.position, scaleX);\n```"]