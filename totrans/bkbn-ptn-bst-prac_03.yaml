- en: Chapter 3. Working with Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript models are an essential part of client-side data management. In stateful
    JavaScript applications, local or remote data is stored in models and the model
    provides a number of functions to work with this data such as conversions, validations,
    data persistence, and so on. Backbone models are no different than these and provide
    similar functionalities such as set/get data, validate, save to or fetch from
    the server, delete an attribute, and sync with the server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some basic problems with models that Backbone
    developers usually face, and will then propose some possible solutions to them.
    Also, we will cover a few interesting plugins and extensions for models that will
    help reduce boilerplate in your code. The main points to be covered are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic usage of models**: Learn the basics of Backbone models, such as important
    methods, properties, and data operations.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validating the data**: We will see how basic data validations are done with
    Backbone models. Also, we will analyze an important plugin, `Backbone.Validation`
    that helps us reduce lots of boilerplate validation code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serializing models**: The data sent to the server or received from the server
    can be of different format than the format the model expects it to be. In this
    section, we will see how overriding the `parse`() and `toJSON()` methods help
    the model directly communicate with the server.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding relational data model**: We will read an analysis of nested
    models and collections with the help of the Backbone relational plugin.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage of models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Models are one of the most important components of Backbone. Starting from
    storing data, they provide a lot of functionality, including logic around the
    data, validations, data interactions, and so on. A model can be defined by extending
    the `Backbone.Model` class, shown as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A model consists of an `attributes` property that stores the data within it.
    You can get the model data using a `get()` method and set the data in `attributes`
    by using the `set()` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `toJSON()` method of a model returns a copy of the model attributes as
    a JSON object. Note that the output has `age` now set to the new value. Whenever
    you change any attribute via the `set()` method, a `change` event gets fired on
    the model:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `change` event for each changed attribute also gets fired:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is quite beneficial when you want to update your views partially, because
    both the `change` and `change:age` events get fired in this case. You can listen
    only to a particular attribute change and act accordingly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Using the defaults property
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, you may want your model to have a set of default values until
    new data is added to it. Backbone provides a `defaults` property where you can
    specify the initial data, as shown in the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When added for every instance of the model, any unspecified attribute will automatically
    be set to the default value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding object references in the defaults property
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure that you never use any object or array directly in the `defaults`
    property. This is because the objects are shared by reference in JavaScript, and
    if added into `defaults`, the objects will get shared among all the instances
    of the model. An example follows to explain the case:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see that the `hobbies` array now becomes a shared property between
    both the instances of the model. This is not a desired case and you should always
    avoid putting objects as default attributes. The solution to this problem can
    be achieved by using a function for the `defaults` property instead of an object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function will get executed every time a model instance is created, and
    thus will always send a new object for `defaults`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Data interaction with the server
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Backbone model has made data operations with the server quite easy by providing
    a set of interesting methods such as `fetch()`, `save()`, `sync()`, and `destroy()`.
    Let's look into each of these methods one by one. We will use the same user model
    as we did earlier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a model
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, if you set new values to the model and call the `save()` method
    on it, your server should create a new model in the database. Next time onwards,
    the model will carry this `id` attribute and calling the `save()` method again
    should only update the model and not create a new one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As no `id` attribute is present there yet, a POST request is sent to the `/users`
    URL and the server sends a response with the new ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Updating a model
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Updating a model is also similar. If there is an `id` attribute present, the
    same `save()` method sends a PUT request to the server with new attributes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fetching a model
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the `id` attribute is present, the `fetch()` method of the model sends a
    GET request to retrieve and populate the model:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Deleting a model
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `destroy()` method to delete a model. This method sends a DELETE request
    to the server with the model ID:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Validating the data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Backbone, validation is taken care of by the `model.validate()` method.
    By default, the `Backbone.Model` class doesn''t have a `validate()` method on
    its own. However, the developers are encouraged to add a `validate()` method that
    gets called by the model every time an attribute is saved or set with `validate:
    true` passed. A copy of the attributes is sent to the `validate()` method with
    all the changed values. Let''s look at a simple data validation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we created a model with the two attributes `name` and `email`, added a
    `validate()` method to test the values of these attributes, and defined a view
    that will handle the validation errors, if any.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are setting both the values in a single `set()` method, the `validate()`
    method will be called only once. However, it will return an error as soon as it
    finds an invalid attribute. What if we want to display all the errors together
    on our form? In that case, we must return an array or an object with all the error
    messages as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will receive an object with all the errors. This is useful while you
    need to show data individually even when they are set one by one. For example,
    this will be handy while we want to validate a field on blur event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Using the Backbone.Validation plugin
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we just saw a simple implementation of data validation. However, when there
    are lots of form fields with multiple validation criteria, the `validate()` method
    becomes too large with several nested if-else conditions. Creating the complete
    validation logic from scratch may make it more complicated and time-consuming.
    Fortunately, there is a wonderful plugin called `Backbone.Validation` ([http://thedersen.com/projects/backbone-validation/](http://thedersen.com/projects/backbone-validation/)),
    which makes things a lot easier by providing multiple built-in validation methods
    and simplifying the validation binding with views. Let's reimplement the previous
    validation with this plugin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Configuring validation rules
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a number of built-in validators, such as `required`, `maxLength`,
    `minLength`, `max`, `min`, `length`, and `pattern`. They are used as shown in
    the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are some existing validation patterns such as e-mail, number, and URL.
    Alternatively, you can use a regular expression as a pattern. Similarly, you may
    need to define the complete validation functionality for an attribute rather than
    just a regular expression. In that case, you can add custom method validators
    to an attribute. Check the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can add the custom method to an attribute directly as a function or you
    can add the method name as a string, just like we did here. Every attribute can
    have one error message for each validation rule, or it can have a single one for
    all its validation rules. For example, in the following code, we provide separate
    messages for the `required` and `format` validations of `email`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Prevalidating a model with the preValidate() method
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This plugin provides another important functionality to prevalidate an attribute
    of the model without touching the model itself, shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, the attribute will be validated against the set of validators assigned to
    it, and the return value will be an error message if validation fails.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The `Backbone.Validation` plugin is very effective if your application needs
    several form validations. It removes a lot of boilerplate from your code base
    and provides a simple yet robust validation mechanism.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Serializing models
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the model data we used in our examples in the previous chapters are
    all simple data objects with attributes. However, there might be a case where
    the server is sending a different data format and you need to extract the essential
    part from it and apply it to the related model. For example, consider the following
    data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of sending the preceding data, the server returns the following data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This data cannot be applied directly to a model with the attributes `name`
    and `email`. If we call the `fetch()` method on the model now, it will just add
    another attribute named `user` to the model. The method that can help us overcome
    this issue is called `parse()`. By default, this method just passes the server
    response and the model applies whatever it receives from the `parse()` method.
    Here is how it is defined in `Backbone.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, we can override the `parse()` method to modify the raw server response
    and send back only the attribute `hash`. For this case, an object with the `name`
    and `email` attributes should be returned from the `parse()` method, as shown
    in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `server.json` file consists of the newly formatted data. In the `parse()`
    method, we are parsing the response and returning data that the Backbone model
    can accept.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `fetch()` method will not clear your model, but will extend
    the attributes only. So if in our case, the server sends only an e-mail in the
    response, the previous e-mail will get updated, but the name will still be what
    it was.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to fetching data from the server, sending data to it can also face
    the same problem, that is, the server may expect the exact format in which it
    sends data to the model. Now, if we call the `save()` method on the model, it
    will send the data in the following format:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, if the server expects the data in the same format as it is sending now,
    we need to override the `toJSON()` method, which is pretty straightforward. In
    the following code, we create a new object with the `user` property and return
    that object from the `toJSON()` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The request will be sent to the server with the following data, which is exactly
    what we were looking for:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, this process has a downside. In most cases, we use the `toJSON()`
    method to get the model attributes hash directly. As we are overriding this method
    here, the data returned will differ from the expected data. So, you need to decide
    whether you will follow this approach to serialize the model or implement server-side
    interaction separately. If you go for this process, remember to apply the model
    data accordingly in your views when using the `toJSON()` method. Or alternatively,
    you can clone the `model.attributes` property to get the `hash` attribute:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is better not to use the `model.attributes` property directly. Manipulating
    the `hash` attribute directly can potentially cause some unexpected consequences,
    as the object will be passed by reference.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the relational data model
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the examples we have gone through so far have used simple models to represent
    data. However, in any nontrivial application, the data structure is much more
    complex, and the relationships among entities are multi-relational. For any medium-
    or large-level application, there will be lots of one-to-one, one-to-many, and
    many-to-one relations. Keeping these relations synced with the server often becomes
    a tedious job, especially while saving or fetching data with multiple requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'While researching for this book, I found that most Backbone developers, at
    some point of their learning phase, have faced issues with nested models and collections.
    Fortunately, there is a great plugin known as Backbone-relational ([http://backbonerelational.org/](http://backbonerelational.org/)),
    developed by Paul Uithol, which minimizes the Backbone model hand-holding by syncing
    the model and all its related models with a single `save()` or `fetch()` method.
    It provides some great features that include the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional relations that notify related models of changes through events
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control over how relations are serialized
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic conversion of nested objects in a model's attributes into model instances
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy retrieval of a set of related models
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the type of `HasMany` collections
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will look into a simple example with company-employee relationship to explain
    the concept of the Backbone-relational plugin:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we created a company-employees one-to-many relationship. In the company
    model configuration, you need to define the relation type that is used to create
    a `Backbone.Relation` instance at first. The `type` relation property can be `Backbone.HasMany`,
    `Backbone.HasOne`, or a direct reference to a particular relation instance. You
    also need to specify the attribute of the company model that holds all the employee
    models. Once the basic configuration is done, we will define the `Employee` model
    and `Employees` collection. Let''s test the relationship with some dummy data
    now:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've now created a fully-managed relation. When you add or remove models from
    `innofied.employees` or update `employee.worksIn`, the other side of the relation
    automatically gets updated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The previous mentioned code is just an elementary example of the Backbone-relational
    model. Once you go through their complete documentation, you will find that the
    plugin provides many features that can enhance application development process
    to a great extent.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed some basic problems around Backbone models that lots
    of developers face, and described how we can approach these issues in our projects.
    We learned about basic data validation as well as getting all the error messages
    together from our validate method. Also, we saw how using the Backbone validation
    plugin can reduce our efforts when performing data validation by providing lots
    of inbuilt features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If the data sent from the server has a different format from what a model expects,
    we now know how to override the `parse()` method to overcome this issue. Similarly,
    we override the `toJSON()` method to change the format of data that will be passed
    to the server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器发送的数据格式与模型期望的不同，我们现在知道如何覆盖`parse()`方法来解决这个问题。同样，我们也覆盖了`toJSON()`方法来改变将传递给服务器的数据格式。
- en: For most nontrivial applications, a nested model relationship is an essential
    requirement, and the Backbone-relational plugin can provide a ready-made solution
    for that. The plugin is widely accepted by the Backbone community and a lot of
    projects are currently using it successfully.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数非平凡应用，嵌套模型关系是一个基本要求，Backbone-relational插件可以为此提供一个现成的解决方案。该插件被Backbone社区广泛接受，并且许多项目目前正在成功使用它。
- en: There are some important topics to cover when working with models, such as collections,
    events, and sync. We are going to cover each of these points separately in the
    following chapters. The events and sync functionality is discussed in detail in
    [Chapter 6](ch06.html "Chapter 6. Working with Events, Sync, and Storage"), *Working
    with Events, Sync, and Storage*. In the next chapter, we will discuss the different
    functionalities of Backbone collections, basic and multiple sorting, filtering
    mechanisms, and collections with multiple model types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模型时，有一些重要的话题需要讨论，例如集合、事件和同步。我们将在接下来的章节中分别详细讨论这些点。事件和同步功能在[第6章](ch06.html
    "第6章。处理事件、同步和存储")*处理事件、同步和存储*中进行了详细讨论。在下一章中，我们将讨论Backbone集合的不同功能，基本和多种排序，过滤机制，以及具有多种模型类型的集合。
