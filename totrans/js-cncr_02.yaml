- en: Chapter 2. The JavaScript Execution Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first chapter of this book explored the state of JavaScript concurrency.
    Generally speaking, dealing with concurrency in JavaScript applications is anything
    but a trivial matter. There's a lot to think about when writing concurrent JavaScript
    code, and the kind of solutions that we come up with are often unorthodox. There's
    a lot of callbacks, and wading through all of them is enough to drive a person
    insane. We also caught a glimpse of how our pattern of writing concurrent JavaScript
    code has started to change with existing concurrency components. Web workers have
    started to mature, and JavaScript language concurrency constructs have only just
    been introduced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The language and the runtime environment only get us partway there. We need
    to think about concurrency at the design level, rather than after the fact. Concurrency
    should be the default. This is easy to say and very difficult to do. Throughout
    this book, we're going to explore all that the JavaScript concurrency features
    have to offer, and how we can best use them to our advantage as design tools.
    But, before we do this, we need to go into depth on what's really happening when
    our JavaScript runs. This knowledge is an essential input to designing concurrent
    applications, because we'll know exactly what to expect when choosing one concurrency
    mechanism over another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start with the browser environment, by looking at all
    the subsystems that our code touches—such as the JavaScript interpreter, the task
    queue, and the DOM itself. Then we'll walk through some code that will shed some
    light on what's really happening behind the scenes to orchestrate our code. We'll
    close the chapter with a discussion on the challenges that we face with this model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Everything is a task
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we visit a web page, a whole environment is created for us within the browser.
    This environment has several subsystems that enable the webpage we're looking
    at to look and behave as it should according to **World Wide Web Consortium**
    (**W3C**) specs. Tasks are the fundamental abstraction inside a web browser. Anything
    that happens is either a task itself, or a smaller part of a larger task.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're reading any of the W3C specifications, the term "user agent" is used
    instead of "web browser". In 99.9% of cases, the major browser vendors are what
    we're reading about.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at the major components of these environments, and
    how task queues and event loops facilitate the communication between these components,
    to realize the overall appearance and behavior of the web page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Meet the players
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s introduce some terminology that will help us throughout the various
    sections in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution environment**: This container gets created whenever a new web page
    is opened. It''s the all-encompassing environment, which has everything that our
    JavaScript code will interact with. It also serves as a sandbox—our JavaScript
    code can''t reach outside of this environment.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行环境**：每当打开一个新的网页时，就会创建这个容器。这是一个包罗万象的环境，其中包含我们的JavaScript代码将与之交互的一切。它还充当一个沙盒——我们的JavaScript代码无法超出这个环境。'
- en: '**JavaScript interpreter**: This is the component that''s responsible for parsing
    and executing our JavaScript source code. It''s the browser''s job to augment
    the interpreter with globals, such as `window`, and `XMLHttpRequest`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript解释器**：这是负责解析和执行我们的JavaScript源代码的组件。浏览器的工作是向解释器添加全局变量，例如`window`和`XMLHttpRequest`。'
- en: '**Task queue**: Tasks are queued whenever something needs to happen. An execution
    environment has at least one of these queues, but typically, it has several of
    them.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务队列**：每当需要发生某些事情时，就会将任务排队。执行环境至少有一个这样的队列，但通常有几个。'
- en: '**Event loop**: An execution environment has a single event loop that''s responsible
    for servicing all task queues. There''s only one event loop, because there''s
    only one thread.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**：执行环境有一个负责服务所有任务队列的单个事件循环。只有一个事件循环，因为只有一个线程。'
- en: Take a look at the following visualization of an execution environment created
    within a web browser. The task queues are the entry points for anything that happens
    in the browser. For example, one task can be used to execute a script by passing
    it to the JavaScript interpreter, while another task is used to render pending
    DOM changes. Now we'll dig into the parts that make up the environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下在网页浏览器中创建的以下执行环境可视化。任务队列是浏览器中发生任何事情的入口点。例如，一个任务可以通过传递给JavaScript解释器来执行一个脚本，而另一个任务用于渲染挂起的DOM更改。现在我们将深入了解构成环境的各个部分。
- en: '![Meet the players](img/B05133_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![遇见参与者](img/B05133_02_01.jpg)'
- en: The Execution environment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行环境
- en: Perhaps the most revealing aspect of the web browser execution environment is
    the relatively minor role played by our JavaScript code and the interpreter that
    executes it. Our code is simply a cog in a much larger machine. There's certainly
    a lot going on within these environments, because the platform that browsers implement
    serve an enormous purpose. It's not simply a matter of rendering elements on the
    screen, then enhancing these elements with style properties. The DOM itself is
    similar to a micro platform, just as networking facilities, file access, security,
    and so on. All these pieces are essential for a functioning web economy of sites,
    and more recently, applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器执行环境中最能揭示其本质的方面可能是我们的JavaScript代码及其解释器所扮演的相对较小的角色。我们的代码只是在一个更大机器中的一个齿轮。在这些环境中，确实有很多事情在进行，因为浏览器实现的平台具有巨大的作用。这不仅仅是在屏幕上渲染元素，然后通过样式属性增强这些元素。DOM本身就像一个微型平台，就像网络设施、文件访问、安全等。所有这些部分对于网站功能的网络经济和最近的应用程序都是必不可少的。
- en: In a concurrency context, we're mostly interested in the mechanics that tie
    all these platform pieces together. Our application is written mainly in JavaScript,
    and the interpreter knows how to parse and run it. But, how does this ultimately
    translate into visual changes on the page? How does the networking component of
    the browser know to make an HTTP request, and how does it invoke the JavaScript
    interpreter once the response has arrived?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发上下文中，我们主要对将所有这些平台部件联系在一起的机制感兴趣。我们的应用程序主要用JavaScript编写，解释器知道如何解析和运行它。但是，这最终如何转化为页面上的视觉变化？浏览器的网络组件如何知道发起一个HTTP请求，以及如何在响应到达后调用JavaScript解释器？
- en: It's the coordination of these moving parts that restricts our concurrency options
    in JavaScript. These restrictions are necessary, because without them, programming
    web applications would become too complex.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这些运动部件的协调限制了JavaScript中的并发选项。这些限制是必要的，因为没有它们，编写网络应用程序将变得过于复杂。
- en: Event loops
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: Once an execution environment is in place, the event loop is one of the first
    components to start. Its job is to service one or more task queues in the environment.
    Browser vendors are free to implement queues as they see fit, but there has to
    be at least one queue. Browsers can place every task in one queue if they please,
    and treat every task with equal priority. The problem with doing so would mean
    that if the queue is getting backlogged, tasks that must receive priority, such
    as mouse or keyboard events, are stuck in line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it makes sense to have a handful of queues, if for no other reason
    than to separate tasks by priority. This is all the more important because there''s
    only one thread of control—meaning only one CPU—that will process these queues.
    Here''s what an event loop that services several queues by varying levels of priorities
    looks like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Event loops](img/B05133_02_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Even though the event loop is started along with the execution environment,
    this doesn't mean that there's always tasks for it to consume. If there were always
    tasks to process, there would never be any CPU time for the actual application.
    The event loop will sit and wait for more tasks, and the queue with the highest
    priority gets serviced first. For example, with the queues used in the preceding
    image, the *interactive* queue will always be serviced first. Even if the event
    loop is making its way through the *render* queue tasks, if an *interactive* task
    is queued, the event loop will handle this task before resuming with render tasks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Task queues
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of queued tasks is essential to understand how web browsers work.
    The term browser is actually misleading. We used them to browse static web pages
    in an earlier, sparser web. Now, large and complex applications run in browsers—it's
    really more of a web platform. The task queues and event loops that service them
    are probably the best design to handle so many moving parts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw earlier in this chapter that the JavaScript interpreter, along with
    the code that it parses and runs, is really just a black box when viewed from
    the perspective of an execution environment. In fact, invoking the interpreter
    is itself a task, and is reflective of the run-to-completion nature of JavaScript.
    Many tasks involve the invocation of the JavaScript interpreter, as visualized
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Task queues](img/B05133_02_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Any one of these events—the user clicking an element, a script loading in the
    page, or data from a prior API call arriving in the browser—creates a task that
    invokes the JavaScript interpreter. It tells the interpreter to run a specific
    piece of code, and it'll continue to run it until it completes. This is the run-to-completion
    nature of JavaScript. Next, we'll dig into the execution contexts created by these
    tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Execution contexts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to look at the JavaScript interpreter itself—the component that
    takes over from other browser components when events take place and code needs
    to run. There's always an active JavaScript context, and within the interpreter,
    we'll find a stack of contexts. This is similar to many programming languages
    where stacks control the active context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Think of the active context as a snapshot of what's happening right now in our
    JavaScript code. A stack structure is used because the active context can change
    to something else, such as when a function is called. When this happens, a new
    snapshot is pushed onto the stack, becoming the active context. When it's done
    running, it's popped from the stack, leaving the next context as the active context.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a look at how the JavaScript interpreter handles
    context switching, and the internal job queue that manages the context stack.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining execution state
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The stack of contexts within the JavaScript interpreter isn''t a static structure—it''s
    constantly changing. There''s two important things that happen throughout the
    lifetime of this stack. First, at the top of the stack, we have the active context.
    This is the code that currently executes as the interpreter moves through its
    instructions. Here''s an idea of what a JavaScript execution context stack looks
    like with the active context always at the top:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining execution state](img/B05133_02_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: The other important responsibility of the call stack is to bookmark the state
    of an active context when it's deactivated. For example, let's say that after
    a few statements, `func1()` calls `func2()`. At this point, the context is bookmarked
    to the spot directly after the call to `func2()`. Then, it's replaced with the
    new active context—`func2()`. When it completes, the process is repeated and `func1()`again
    becomes the active context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This kind of context switching happens all over our code. For example, there's
    a global context, which is the entry point into our code, there's the functions
    themselves which have their own context. There are also more recent additions
    to the language, which have their own contexts, such as modules and generators.
    Next, we'll look at the job queues responsible for creating new execution contexts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Job queues
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jobs queues are similar to the task queues that we looked at earlier. The difference
    is that job queues are specific to the JavaScript interpreter. That is, they're
    encapsulated within the interpreter—the browser doesn't interact directly with
    these queues. However, when the interpreter is invoked by the browser, in response
    to a loaded script or event callback task for example, new jobs are created by
    the interpreter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Job queues](img/B05133_02_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: The job queues within the JavaScript interpreter are actually much more straightforward
    than the task queues that are used to coordinate all the web browser components.
    There are only two essential queues. One is for creating new execution context
    stacks (call stacks). The other is specific to promise resolution callback functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll go into more depth on how the promise resolution callback job works in
    the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Given the restricted responsibilities of these internal JavaScript job queues,
    one might draw the conclusion that they're unnecessary—an act of over engineering.
    That's not true, because while today there's limited responsibilities found in
    these jobs, the job queue design allows for much easier expansion and refinement
    of the language. In particular, the job queue mechanism is favorable when considering
    new concurrency constructs in future versions of the language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating tasks using timers
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've had a look at all the inner workers of the web
    browser environment, and where the JavaScript interpreter fits in this environment.
    What does all this have to do with applying concurrency principles to our code?
    With the knowledge of what's happening under the hood, we have a greater insight
    into what's happening when a given chunk of our code is run. Particularly, we
    know what's happening relative to other code chunks; time ordering is a crucial
    concurrency property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This being said, let's actually write some code. In this section, we'll use
    timers to explicitly add tasks to the task queue. We'll also learn when and where
    the JavaScript interpreter jumps in and starts executing our code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using setTimeout()
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setTimeout()` function is staple in any JavaScript code. It''s used to
    execute code at some point in the future. New JavaScript programmers often trip
    over the `setTimeout()` function because it''s a timer. At a set point in the
    future, say 3 seconds from now, a callback function will be invoked. When we call
    `setTimeout()`, we will get the `atimer` ID in return, which can be cleared later
    on using `clearTimeout()`. Here''s what the basic usage of `setTimeout()` looks
    like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here's the part that's misunderstood by JavaScript newcomers; it's a best effort
    timer. The only guarantee we have when using `setTimeout()` is that our callback
    function will never be called sooner than the allotted time that we pass it. So
    if we said call this function in 300 milliseconds, it'll never call it in 275
    milliseconds. Once the 300 milliseconds have elapsed, a new task is queued. If
    there's nothing waiting in line before this task, the callback is run right on
    time. Even if there are a few things in the queue in front of it, the effects
    are hardly noticeable—it appears to run at the correct time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'But as we''ve seen, JavaScript is single threaded and run-to-completion. This
    means that once the JavaScript interpreter starts, it doesn''t stop until it''s
    finished; even if there''s a task waiting for a timer event callback. So, it''s
    entirely possible that even though we asked the timer to execute the callback
    in 300 milliseconds, it executes it in 500 milliseconds. Let''s take a look at
    an example to see how this is possible:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using setInterval()
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cousin of `setTimeout()` is the `setInterval()` function. As the name suggests,
    it accepts a callback function that's to be called at a regular interval. In fact,
    `setInterval()` takes the exact same arguments as `setTimeout()`. The only difference
    is that it will keep calling the function every x milliseconds until the timer
    is cleared using `clearInterval()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: This function is handy when we want to keep calling the same function, over
    and over. For example, if we poll an API endpoint, `setInterval()` is a good candidate
    solution. However, keep in mind that the scheduling of the callbacks is fixed.
    That is, once we call `setInterval()` with, say, 1000 milliseconds, there's no
    changing that 1000 milliseconds without first clearing the timer. For cases where
    the interval needs to be dynamic, using `setTimeout()` works better. The callback
    schedules the next interval, which allows the interval to be dynamic. For example,
    backing off from polling an API too frequently by increasing the interval.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setTimeout()` example that we last looked at, we saw how running JavaScript
    code can mess with the event loop. That is, it prevents the event loop from consuming
    the task that invokes the JavaScript interpreter with our callback function. This
    allows us to defer code execution till some point in the future, but with no promises
    of accuracy. Let''s see what happens when we schedule tasks using `setInterval()`.
    There''s also some blocking JavaScript code that runs afterward:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Responding to DOM events
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we saw how to schedule JavaScript code to run at a
    later time. This is done explicitly by other JavaScript code. Most of the time,
    our code runs in response to user interactions. In this section, we'll look at
    the common interface that's used not only by DOM events, but also by things such
    as network and web worker events. We'll also look at a technique for dealing with
    large volumes of similar events—called debouncing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Event targets
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EventTarget` interface is used by many browser components, including DOM
    elements. It's how we dispatch events to elements as well as listen to events
    and respond by executing a callback function. It's actually a very straightforward
    interface that's easy to follow. This is crucial since many different types of
    components use this same interface for event management. We'll see as we progress
    through the book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The same task queue mechanisms that execute the callback functions for the
    timers that we used in the preceding section are relevant for `EventTarget` events.
    That is, if an event has taken place, a task to invoke the JavaScript interpreter
    with the appropriate callback is queued. The same limitations faced with using
    `setTimeout()` are imposed here. Here''s what a task queue looks like when there''s
    long-running JavaScript code that''s blocking user events:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Event targets](img/B05133_02_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'In addition to attaching listener functions to event targets that react to
    user interaction, we can trigger these events manually, as the following code
    illustrates:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's good practice to name functions that are used in callbacks where possible.
    This way, when our code breaks, it's much easier to trace down the problem. It's
    not impossible with anonymous functions, it's just more time consuming. On the
    other hand, arrow functions are more concise and have more binding flexibility.
    Choose your trade-offs wisely.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Managing event frequency
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge with user interaction events is that there can be lots of them,
    in a very short amount of time. For instance, when the user moves the mouse around
    on the screen, hundreds of events are dispatched. If we had event targets listening
    for these events, the task queue would quickly fill up, and the user experience
    would bog down.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Even when we do have event listeners in place for high frequency events, such
    as mouse moves, we don't necessarily need to respond to all of them. For example,
    if there's 150 mouse move events that take place in 1-2 seconds, chances are,
    we only care about the last move—the most recent position of the mouse pointer.
    That is, the JavaScript interpreter is being invoked with our event callback code
    149 times more than it needs to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with these types of event frequency scenarios, we can utilize a technique
    called *debouncing*. A debounced function means that if it''s called in succession
    more than once within a given time frame, only the last call is actually used
    and the earlier calls are ignored. Let''s walk through an example of how we can
    implement this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the debounce technique to avoid giving the CPU more work than necessary
    is an example of the conserve principle in action. By ignoring 149 events, we
    save (conserve) the CPU instructions that would otherwise be executed and provide
    no real value. We also save on any kind of memory allocation that would otherwise
    happen in these event handlers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript concurrency principles were introduced at the end of [Chapter
    1](ch01.html "Chapter 1. Why JavaScript Concurrency?"), *Why JavaScript Concurrency?*,
    and they'll be pointed out throughout the code examples in the remainder of the
    book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Responding to network events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another critical piece of any front-end application is network interactions,
    fetching data, issuing commands, and so forth. Since network communications are
    an inherently asynchronous activity, we have to rely on events—the `EventTarget`
    interface to be precise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by looking at the generic mechanism that hooks up our callback functions
    with requests and getting responses from the back-end. Then, we'll look at how
    trying to synchronize several network requests creates a seemingly hopeless concurrency
    scenario.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Making requests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To interact with the network, we create a new instance of `XMLHttpRequest`.
    We then tell it the type of request that we want to make—GET versus POST and the
    request endpoint. These request objects also implement the `EventTarget` interface
    so that we can listen for data arriving from the network. Here''s an example of
    what this code looks like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see here that there are a number of possible states for network requests.
    The successful path is the server responding with the data we need and we're able
    to parse it as JSON. The error state is when something went wrong, maybe the server
    isn't reachable. The final state that we're concerned with here is when the request
    is cancelled or aborted. This means that we no longer care about the successful
    path because something in our application changed while the request was in flight.
    The user navigated to another section, for example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: While the previous code was easy enough to use and understand, it's not always
    the case. We're looking at a single request and a few callbacks. Very seldom do
    our application components consist of a single network request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Coordinating requests
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding section, we saw what the basic interaction with `XMLHttpRequest`
    instances looks like for making a network request. The challenge surfaces when
    there are several requests. Most of the time, we make multiple network requests
    so that we have the data necessary for rendering a UI component. The responses
    from the back-end will all arrive at different times, and are likely dependent
    on one another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Somehow, we need to synchronize the responses of these asynchronous network
    requests. Let''s take a look at how we can go about doing this using the `EventTaget`
    callback functions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's a lot of extra bits to consider when there's more than one request.
    Since they all arrive at different times, we need to store the parsed responses
    in an array, and with the arrival of every response, we need to check if we have
    everything we expect. This simplified example doesn't even take into consideration
    failed or cancelled requests. As this code alludes, the callback function approach
    to synchronization is limiting. In the coming chapters, we'll learn how to overcome
    this limitation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency challenges with this model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll wrap this chapter up with a discussion on the challenges that this execution
    model poses with JavaScript concurrency. There are two fundamental obstacles.
    The first is the fact that no matter what, any JavaScript code that runs will
    block anything else from happening. The second obstacle is trying to synchronize
    asynchronous actions with callback functions, leading to callback hell.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章结束于对JavaScript并发执行模型所面临的挑战的讨论。有两个基本障碍。第一个是无论什么情况，任何运行的JavaScript代码都会阻塞其他任何事情的发生。第二个障碍是尝试使用回调函数同步异步操作，导致回调地狱。
- en: Limited opportunity for parallelism
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性有限
- en: It used to be that the lack of parallelism in JavaScript wasn't really an issue.
    Nobody missed it because JavaScript was viewed as a progressive enhancement tool
    for HTML pages. This changed when the front-end started taking on more responsibilities.
    These days, the majority of the application actually resides in the front-end.
    This allows back-end components to focus on problems that can't be solved by JavaScript
    (from a browser perspective, NodeJS is another matter entirely that we'll look
    at later in the book).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，JavaScript缺乏并行性并不是真正的问题。没有人会想念它，因为JavaScript被视为HTML页面的渐进增强工具。当前端开始承担更多责任时，这种情况发生了变化。如今，应用程序的大部分实际上都驻留在前端。这使得后端组件能够专注于JavaScript（从浏览器角度来看，NodeJS完全是另一回事，我们将在本书稍后讨论）无法解决的问题。
- en: For example, mapping and reducing API data sources into some representation
    required by a feature can be implemented in the back-end. This means that the
    front-end JavaScript code just needs to query for this endpoint. The problem is
    that this API endpoint is created for some specific UI feature, not as an essential
    supporting pillar of our data model. If we can perform these tasks in the front-end,
    we keep the UI features and the data transformations they need, tightly coupled
    together. This frees up the back-end to stay focused on more pressing issues like
    replication and load balancing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将映射和减少API数据源到某个功能所需的表示形式可以在后端实现。这意味着前端JavaScript代码只需要查询这个端点。问题是这个API端点是针对某些特定的UI功能创建的，而不是作为我们数据模型的基本支持支柱。如果我们能在前端执行这些任务，我们就将UI功能和它们所需的数据转换紧密耦合在一起。这使后端能够专注于更紧迫的问题，如复制和负载均衡。
- en: We can perform these types of data transformations in the front-end, but they
    wreak havoc on the usability of the interface. This is largely due to all the
    moving parts competing for the same compute resource. This model, in other words,
    makes it impossible for us to implement the parallelize principle and take advantage
    of more than one resource. We will overcome this web browser limitation with the
    help of Web workers, covered in further chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前端执行这些类型的数据转换，但它们会破坏界面的可用性。这主要是因为所有移动部件都在争夺相同的计算资源。换句话说，这种模型使我们无法实现并行化原则并利用多个资源。我们将通过后续章节中介绍的Web
    workers克服这种网络浏览器的限制。
- en: Synchronization through callbacks
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调进行同步
- en: Synchronization through callbacks is hard to implement and doesn't scale well.
    It's callback hell, which is a term popular among JavaScript programmers. Needless
    to say, endless synchronization through callbacks in our code creates problems.
    We often have to create some kind of state tracking mechanism, such as global
    variables. And when problems do arise, a nest of callback functions is very time
    consuming to traverse mentally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回调进行同步难以实现且扩展性不佳。这是回调地狱，一个在JavaScript程序员中流行的术语。不用说，代码中无尽的回调同步会引发问题。我们经常不得不创建某种状态跟踪机制，例如全局变量。当问题确实出现时，一大堆回调函数在心理上非常耗时去遍历。
- en: Generally speaking, the callback approach to synchronizing multiple asynchronous
    actions requires a lot of overhead. That is, the boilerplate code that exists
    for the sole purpose of dealing with asynchronous actions. The synchronize concurrency
    principle is about writing concurrent code that doesn't embed the main goal in
    a maze of synchronization handling logic. Promises help us write concurrent code
    consistently throughout our application by lessening the use of callback functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，同步多个异步操作的回调方法需要大量的开销。也就是说，存在只是为了处理异步操作而存在的样板代码。同步并发原则是关于编写不将主要目标嵌入到同步处理逻辑迷宫中的并发代码。通过减少回调函数的使用，Promise帮助我们在整个应用程序中一致地编写并发代码。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The focus of this chapter has been the web browser platform and JavaScript's
    place within it. There are a lot of events taking place whenever we view and interact
    with web pages. These are processed as tasks, taken from queues. One such task
    is invoking the JavaScript interpreter with code to run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点一直是网络浏览器平台以及JavaScript在其中所处的位置。在我们查看和与网页互动时，总会有很多事件发生。这些事件被处理为任务，从队列中取出。其中一项任务就是使用代码调用JavaScript解释器来运行。
- en: When the JavaScript interpreter runs, it contains an execution context stack.
    A function, a module, and global script code—these are all examples of JavaScript
    execution contexts. The interpreter also has it's own internal job queues; one
    is used to create new execution context stacks, and another is used for calling
    promise resolution callback functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript解释器运行时，它包含一个执行上下文栈。函数、模块和全局脚本代码——这些都是JavaScript执行上下文的例子。解释器还有它自己的内部作业队列；一个用于创建新的执行上下文栈，另一个用于调用承诺解析回调函数。
- en: We wrote some code that manually created tasks using the `setTImeout()` function
    and explicitly demonstrated how long-running JavaScript code can be problematic
    for these tasks. We then looked at the `EventTarget` interface, used to listen
    to DOM events, and to network requests, amongst other things we didn't look at
    in this chapter, like web workers and file readers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些代码，使用`setTImeout()`函数手动创建任务，并明确展示了长时间运行的JavaScript代码对这些任务可能造成的问题。然后我们研究了`EventTarget`接口，该接口用于监听DOM事件，以及网络请求，以及其他我们没有在本章中探讨的内容，如web
    workers和文件读取器。
- en: We wrapped up with a look at some of the challenges that JavaScript programmers
    face when using this model. In particular, it's hard to follow our JavaScript
    concurrency principles. We can't parallelize, and trying to synchronize using
    nothing but callbacks is a nightmare.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结了JavaScript程序员在使用此模型时面临的挑战。特别是，遵循我们的JavaScript并发原则很难。我们无法并行化，而仅使用回调函数来尝试同步则是一场噩梦。
- en: In the next chapter, we'll look at a new way of thinking about synchronization
    using promises. This will allow us to start designing and building concurrent
    JavaScript applications in earnest.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种使用承诺（promises）来思考同步的新方法。这将使我们能够真正开始设计和构建并发JavaScript应用程序。
