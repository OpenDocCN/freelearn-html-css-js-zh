<html><head></head><body>
		<div><h1 id="_idParaDest-29" class="chapter-number"><a id="_idTextAnchor028"/>2</h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>The Basic Components that Make up a Three.js Application</h1>
			<p>In the previous chapter, you learned about the basics of Three.js. We looked at a couple of examples, and you created your first complete Three.js application. In this chapter, we’ll dive a bit deeper into Three.js and explain the basic components that make up a Three.js application.</p>
			<p>By the end of this chapter, you’ll have learned how to use the basic components that are used in every Three.js application and should be able to create simple scenes using these standard components. You should also feel comfortable working with Three.js applications that use the more advanced objects, since the approach used by Three.js for simple and advanced components is the same.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating a scene</li>
				<li>How geometries and meshes are related</li>
				<li>Using different cameras for different scenes</li>
			</ul>
			<p>We’ll start by looking at how you can create a scene and add objects.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Creating a scene</h1>
			<p>In <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you created a <code>THREE.Scene</code>, so you <a id="_idIndexMarker098"/>already know some of the basics of Three.js. We saw that for a scene to show anything, we need four different types of objects:</p>
			<ul>
				<li><code>THREE.Scene</code> is rendered onscreen.</li>
				<li><strong class="bold">Lights</strong>: These have an <a id="_idIndexMarker100"/>effect on how materials are shown and are used when creating shadow effects (discussed in detail in <a href="B18726_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Light Sources </em><em class="italic">in Three.js</em>).</li>
				<li><strong class="bold">Meshes</strong>: These are<a id="_idIndexMarker101"/> the main objects that are rendered from the perspective of the camera. These objects contain the vertices and faces that make up the geometry (for example, a sphere or a cube) and contain a material, which defines what the geometry looks like.</li>
				<li><strong class="bold">Renderer</strong>: This uses <a id="_idIndexMarker102"/>the camera and the information in the scene to draw (render) the output on the screen.</li>
			</ul>
			<p><code>THREE.Scene</code> serves as the main container for the lights and the meshes you want to render. <code>THREE.Scene</code> itself doesn’t have that many options and functions.</p>
			<p><code>THREE.Scene</code> is a structure that is sometimes also called a scene graph. A scene graph can hold all the necessary information of a graphical scene. In Three.js, this means that a <code>THREE.Scene</code> contains all the objects necessary for rendering. It is interesting to note that a scene graph, as the name implies, isn’t just an array of objects; a scene graph consists of a set of nodes in a tree structure. As we’ll see in <a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>, Three.js provides objects you can use to create groups of different meshes or lights. The main object you use for that, which you can use to create a scene graph, is the <code>THREE.Group</code>. As the name implies, this object allows you to group objects together. A <code>THREE.Group</code> extends from another base class in Three.js called <code>THREE.Object3D</code>, which provides a set of standard functions to add and modify children. <code>THREE.Mesh</code> and <code>THREE.Scene</code> both also extend<a id="_idIndexMarker103"/> from a <code>THREE.Object3D</code> so you could also use those to create a nested structure. But it’s convention, and also more semantically correct, to use <code>THREE.Group</code> to build up the scene graph.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>The basic functionality of a scene</h2>
			<p>The best way to<a id="_idIndexMarker104"/> explore the functionality of a scene is by looking at an example. In the source code for this chapter, you can find the <code>chapter-2/basic-scene.html</code> example. We’ll use this example to explain the various functions and options a scene has. When we open this example in the browser, the output will look similar to what’s shown in the next screenshot (remember that you can use the mouse to move, zoom, and pan around the rendered scene):</p>
			<div><div><img src="img/Figure_2.1_B18726.jpg" alt="Figure 2.1 – Basic scene setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Basic scene setup</p>
			<p>The preceding figure looks like the examples we saw in <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>. Even though the scene looks pretty empty, it already contains a few objects:</p>
			<ul>
				<li>We’ve got <code>THREE.Mesh</code>, which represents the floor area you can see</li>
				<li>We’re using <code>THREE.PerspectiveCamera</code> to determine what we’re looking at</li>
				<li>We’ve<a id="_idIndexMarker105"/> added <code>THREE.AmbientLight</code> and <code>THREE.DirectionalLight</code> to provide lighting</li>
			</ul>
			<p>The source code for this example can be found in <code>basic-scene.js</code>, and we can use code from <code>bootstrap/bootstrap.js</code>, <code>bootstrap/floor.js</code>, and <code>bootstrap/lighting.js</code> since this is a generic scene setup we use throughout this book. What happens in all these files can be simplified as in the following code:</p>
			<pre class="source-code">
// create a camera
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// create a renderer
const renderer = new THREE.WebGLRenderer({ antialias: true
  });
// create a scene
const scene = new THREE.Scene();
// create the lights
scene.add(new THREE.AmbientLight(0x666666));
scene.add(THREE.DirectionalLight(0xaaaaaa));
// create the floor
const geo = new THREE.BoxBufferGeometry(10, 0.25, 10, 10,
  10, 10);
const mat = new THREE.MeshStandardMaterial({ color:
  0xffffff,});
const mesh = new THREE.Mesh(geo, mat);
scene.add(mesh);</pre>
			<p>As you can see <a id="_idIndexMarker106"/>in the preceding code, we create <code>THREE.WebGLRenderer</code> and <code>THREE.PerspectiveCamera</code>, since we always need those. Next, we create a <code>THREE.Scene</code> and just add all the objects that we want to use. In this case, we add two lights and a single mesh. Now, we have all the components to start up a render loop, as we’ve already seen in <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene </em><em class="italic">with Three.js</em>.</p>
			<p>Before we look at the <code>THREE.Scene</code> object in more depth, we’ll first explain what you can do in the demo, and after that, look at the code. Open the <code>chapter-2/basic-scene.html</code> example in your browser and look at the <strong class="bold">Controls</strong> menu in the upper-right corner, which you <a id="_idIndexMarker107"/>can see in the following screenshot:</p>
			<div><div><img src="img/Figure_2.2_B18726.jpg" alt="Figure 2.2 – Basic scene setup with Cubemap background"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Basic scene setup with Cubemap background</p>
			<h3>Adding and removing objects</h3>
			<p>With these <code>THREE.Scene</code>. We’ll start by looking at how you can add and remove <code>THREE.Mesh</code> objects to and from a scene. The following code shows the function we call when you click on the <strong class="bold">addCube</strong> button:</p>
			<pre class="source-code">
const addCube = (scene) =&gt; {
  const color = randomColor();
  const pos = randomVector({
    xRange: { fromX: -4, toX: 4 },
    yRange: { fromY: -3, toY: 3 },
    zRange: { fromZ: -4, toZ: 4 },
  });
  const rotation = randomVector({
    xRange: { fromX: 0, toX: Math.PI * 2 },
    yRange: { fromY: 0, toY: Math.PI * 2 },
    zRange: { fromZ: 0, toZ: Math.PI * 2 },
  });
  const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  const cubeMaterial = new THREE.MeshStandardMaterial({
    color: color,
    roughness: 0.1,
    metalness: 0.9,
  });
  const cube = new THREE.Mesh(geometry, cubeMaterial);
  cube.position.copy(pos);
  cube.rotation.setFromVector3(rotation);
  cube.castShadow = true;
  scene.add(cube);
};</pre>
			<p>Let us <a id="_idIndexMarker109"/>understand the preceding code in detail:</p>
			<ul>
				<li>First, we have determined some random settings for the cube that will be added: a random color (by calling the <code>randomColor() </code>helper function), a random position, and a random rotation. These last two are randomly generated by calling <code>randomVector()</code>.</li>
				<li>Next, we create the geometry we want to add to the scene: a cube. We just create a new <code>THREE.BoxGeometry</code> for this, define a material (<code>THREE.MeshStandardMaterial</code> in this example), and combine these two into <code>THREE.Mesh</code>. We use random variables to set the cube’s position and rotation.</li>
				<li>Finally, this <code>THREE.Mesh</code> can then be added to the scene by calling <code>scene.add(cube)</code>.</li>
			</ul>
			<p>A new element that we have introduced in the preceding code is that we also give the cube a name using the <code>name</code> attribute. The name is set to <code>cube-</code>, appended with the number of objects currently in the scene (<code>scene.children.length</code>). A name is very useful for debugging purposes but can also be used to directly access an object from your scene. If you use the <code>THREE.Scene.getObjectByName(name)</code> function, you can directly retrieve a specific object and, for instance, change its location without having to make the JavaScript object a global variable.</p>
			<p>There might also be <a id="_idIndexMarker110"/>situations where you want to remove an existing object from a <code>THREE.Scene</code>. Since a <code>THREE.Scene</code> exposes all its children through the <code>children</code> property, we can just use the following simple code to remove the last child added:</p>
			<pre class="source-code">
const removeCube = (scene) =&gt; {
  scene.children.pop();
};</pre>
			<p>Three.js provides other helpful functions for the <code>THREE.Scene</code> too, related to working with the children of the scene:</p>
			<ul>
				<li><code>add</code>: We’ve already seen this function, which adds the provided object to the scene. If it was previously added to a different <code>THREE.Object3D</code>, it’ll be removed from that object.</li>
				<li><code>Attach</code>: This is similar to <code>add</code>, but if you use it, any rotations or translations applied to this object will be kept.</li>
				<li><code>getObjectById</code>: When you add an object to a scene, it gets an ID. The first one gets <code>1</code>, the second one <code>2</code>, and so on. With this function, you can get a child based on this ID.</li>
				<li><code>getObjectByName</code>: This returns an object based on its <code>name</code> property. The name is something you can set on an object – this is in contrast with the <code>id </code>property, which is assigned by Three.js.</li>
				<li><code>Remove</code>: This removes this object from the scene.</li>
				<li><code>Clear</code>: This removes all the children from the scene.</li>
			</ul>
			<p>Note that the preceding functions are actually from the base object that the <code>THREE.Scene</code> extends from: the <code>THREE.Object3D</code>.</p>
			<p>Throughout the book, we’ll use these functions if we want to manipulate the children of a scene (or in <code>THREE.Group</code>, as we’ll explore later on.)</p>
			<p>Besides the functionality<a id="_idIndexMarker111"/> to add and remove objects, a <code>THREE.Scene</code> also provides a couple of other settings. The first one we’ll look at is adding fog.</p>
			<h3>Adding fog</h3>
			<p>The <code>fog</code> property lets<a id="_idIndexMarker112"/> you add a fog effect to the complete scene; the farther an object is from the camera, the more it will be hidden from sight. This is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.3_B18726.jpg" alt="Figure 2.3 – Using fog to hide objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Using fog to hide objects</p>
			<p>To best see the effect of the added fog, use the mouse to zoom in and out, and you’ll see the cubes being affected by the fog. Enabling fog is really easy in Three.js. Just add the following line <a id="_idIndexMarker113"/>of code after you’ve defined your scene:</p>
			<pre class="source-code">
scene.fog = new THREE.Fog( 0xffffff, 1, 20 );</pre>
			<p>Here, we define white fog (<code>0xffffff</code>). The other two properties can be used to tune how the mist appears. The <code>1</code> value sets the <code>near</code> property, and the <code>20</code> value sets the <code>far</code> property. With these properties, you can determine where the mist starts and how fast it gets denser. With the <code>THREE.Fog</code> object, the fog increases linearly. In the <code>chapter-02/basic-scene.html</code> sample, you can modify these properties by using the menu on the right of the screen to see how these settings affect what you see onscreen.</p>
			<p>There is also an alternative fog implementation provided by Three.js, <code>THREE.FogExp2</code>:</p>
			<pre class="source-code">
scene.fog = new THREE.FogExp2( 0xffffff, 0.01 );</pre>
			<p>This time, we don’t specify near and far, but just the color (<code>0xffffff</code>) and the mist’s density (<code>0.01</code>). Usually, it’s best to experiment a bit with these properties to get the effect you want.</p>
			<p>Another<a id="_idIndexMarker114"/> interesting feature of a scene is that you can configure a background.</p>
			<h3>Changing the background</h3>
			<p>We’ve already seen that <a id="_idIndexMarker115"/>we can change the background color by setting <code>clearColor</code> of <code>WebGLRenderer</code> like this: <code>renderer.setClearColor(backgroundColor)</code>. You can also use the <code>THREE.Scene</code> object to change the background. For this, you’ve got three options:</p>
			<ul>
				<li><em class="italic">Option 1</em>: You can use a solid color.</li>
				<li><em class="italic">Option 2</em>: You can use a texture, which is basically an image, stretched out to fill the complete screen. (More on textures in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working </em><em class="italic">with Textures</em>.)</li>
				<li><em class="italic">Option 3</em>: You can use an environment map. This is also a kind of texture, but one that completely encompasses the camera, and moves around when you change the camera orientation.</li>
			</ul>
			<p>Note that this sets the background color of the HTML canvas we’re rendering to and not the background color of the HTML page. If you want to have a transparent canvas, you need to set the <code>alpha</code> property of the renderer to <code>true</code>:</p>
			<pre class="source-code">
new THREE.WebGLRenderer({ alpha: true }}</pre>
			<p>In the <code>chapter-02/basic-scene.html</code> menu on the right, there is a dropdown that shows all these different settings. If you select the <strong class="bold">Texture</strong> option from the <strong class="bold">backGround</strong> dropdown, you’ll see the following:</p>
			<div><div><img src="img/Figure_2.4_B18726.jpg" alt="Figure 2.4 – Background using a texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Background using a texture</p>
			<p>We’ll cover textures and<a id="_idIndexMarker116"/> cubemaps in much more detail in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em>. But we’ll have a quick look now at how to configure these and a simple background color for the scene (the source for this can be found in <code>controls/scene-controls.js</code>):</p>
			<pre class="source-code">
// remove any background by setting the background to null
scene.background = null;
// if you want a simple color, just set the background to a
  color
scene.background = new THREE.Color(0x44ff44);
// a texture can be loaded with a THREE.TextureLoader
const textureLoader = new THREE.TextureLoader();
textureLoader.load(
  "/assets/textures/wood/abstract-antique-
    backdrop-164005.jpg",
  (loaded) =&gt; {
    scene.background = loaded;
  }
// a cubemap can also be loaded with a THREE.TextureLoader
     textureLoader.load("/assets/equi.jpeg", (loaded) =&gt; {
  loaded.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = loaded;
});</pre>
			<p>As you can see from the preceding code, you can assign either <code>null</code>, <code>THREE.Color</code>, or <code>THREE.Texture</code> to the <code>background</code> property of the scene. Loading a texture or a cubemap is done asynchronously, so, we have to wait for <code>THREE.TextureLoader</code> to load the image data before we can assign it to the background. In the case of the cubemap, we need<a id="_idIndexMarker117"/> to take an extra step and tell Three.js what kind of texture we’ve loaded. We will go into more detail in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em>, when we dive into the details of how textures work.</p>
			<p>If you look back at the beginning of the following code section, you will see how we created the cubes that we added to the scene:</p>
			<pre class="source-code">
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const cubeMaterial = new THREE.MeshStandardMaterial({
  color: color,
  roughness: 0.1,
  metalness: 0.9,
});
const cube = new THREE.Mesh(geometry, cubeMaterial);</pre>
			<p>In the preceding code, we have created a geometry and specified a material. The <code>THREE.Scene</code> object also provides a way to force the meshes in the scene to use the same material. In the<a id="_idIndexMarker118"/> following section, we’ll explore how that works.</p>
			<h3>Updating all the materials in the scene</h3>
			<p>A <code>THREE.Scene</code> has two<a id="_idIndexMarker119"/> properties that affect the material of the meshes in the scene. The first one is the <code>overrideMaterial</code> property. First, let’s demonstrate how this works. On the <code>chapter-02/basic-scene.html</code> page, you can click on the <code>THREE.MeshNormalNormal</code> material:</p>
			<div><div><img src="img/Figure_2.5_B18726.jpg" alt="Figure 2.5 – Override mesh materials with MeshNormalMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Override mesh materials with MeshNormalMaterial</p>
			<p>As you can see in the preceding figure, all the objects (including the ground floor) now use the same material – in this case, <code>THREE.MeshNormalMaterial</code>. This material colors each face of the mesh based on its orientation (its <em class="italic">normal</em> vector) to the camera. This can be very easily done in code by just calling <code>scene.overrideMaterial = </code><code>new THREE.MeshNormalMaterial();</code>.</p>
			<p>Besides applying a complete material to the scene, Three.js also provides a way to set the environment map property of each mesh’s material to the same value. An environment map simulates the environment (for instance, a room, outdoors, or a cave) the meshes are in. The environment map can be used to create reflections on the meshes to make them feel more real.</p>
			<p>We’ve already seen how we can load an environment map in the previous section on backgrounds. If we want all our materials to use an environment map for more dynamic reflections and shading, we <a id="_idIndexMarker120"/>can assign that loaded environment map to the <code>environment</code> property of a scene:</p>
			<pre class="source-code">
textureLoader.load("/assets/equi.jpeg", (loaded) =&gt; {
  loaded.mapping = THREE.EquirectangularReflectionMapping;
  scene.environment = loaded;
});</pre>
			<p>The best way to demonstrate the preceding code is by toggling the <code>chapter-02/basic-scene.html</code> example. If you now zoom in close to the cubes, you can see that their faces reflect part of the environment and aren’t a solid color anymore:</p>
			<div><div><img src="img/Figure_2.6_B18726.jpg" alt="Figure 2.6 – Set the environment map to all the meshes in the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Set the environment map to all the meshes in the scene</p>
			<p>Now that we’ve discussed<a id="_idIndexMarker121"/> the basic container for all the objects we want to render, in the next section, we’ll take a closer look at the objects (<code>THREE.Mesh</code> combining <code>THREE.Geometry</code> and a material) that you can add to the scene.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>How geometries and meshes are related</h1>
			<p>In each <a id="_idIndexMarker122"/>of the<a id="_idIndexMarker123"/> examples so far, you’ve seen geometries and meshes being used. For instance, to create a sphere and add it to the scene, we used the following:</p>
			<pre class="source-code">
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshBasicMaterial({color:
  0x7777ff);
const sphere = new THREE.Mesh(sphereGeometry,
  sphereMaterial);
scene.add(sphere);</pre>
			<p>We defined the geometry (<code>THREE.SphereGeometry</code>), which is the shape of an object, and its material (<code>THREE.MeshBasicMaterial</code>), and we combined these two in a mesh (<code>THREE.Mesh</code>) that can be added to a scene. In this section, we’ll take a closer look <a id="_idIndexMarker124"/>at<a id="_idIndexMarker125"/> geometries and meshes. We’ll start with geometries.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The properties and functions of a geometry</h2>
			<p>Three.js comes <a id="_idIndexMarker126"/>with a large set of geometries out of the box that you can use in your 3D scene. Just add a material, create a mesh, and you’re pretty much done. The following screenshot, from the <code>chapter-2/geometries </code>example, shows a couple of the standard geometries available in Three.js:</p>
			<div><div><img src="img/Figure_2.7_B18726.jpg" alt="Figure 2.7 – Some of the basic geometries available in the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Some of the basic geometries available in the scene</p>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Learning to Work with Geometries</em>, and <a href="B18726_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Advanced Geometries</em>, we’ll explore all the basic and advanced geometries that Three.js has to offer. For now, we’ll look in greater detail at what a geometry actually is.</p>
			<p>A geometry in Three.js, and in most other 3D libraries, is basically a collection of points in a 3D space, also called vertices (where a single point is called a vertex), and a number of faces connecting those points together. Take, for example, a cube:</p>
			<ul>
				<li>A cube has eight corners. Each of these corners can be defined as an <code>x-, y-, and z- </code>coordinate. So, each cube has eight points in a 3D space.</li>
				<li>A cube has six sides, with a vertex at each corner. In Three.js, a face always consists of three vertices that make a triangle (which has three edges). So, in the case of a cube, each side consists of two triangles to make the complete side. An example of how that looks can be seen in <em class="italic">Figure 2</em><em class="italic">.7</em> by looking at the red cube.</li>
			</ul>
			<p>When you use one of the geometries provided by Three.js, you don’t have to define all the vertices and faces yourself. For a cube, you only need to define the width, height, and depth. Three.js uses that information and creates a geometry with eight vertices in the correct position<a id="_idIndexMarker127"/> and with the correct number of faces (12 in the case of a cube – 2 triangles per side). Even though you’d normally use the geometries provided by Three.js or generate them automatically, you can still create geometries completely by hand using vertices and faces, although this can quickly become complex, as you can see in the following lines of code:</p>
			<pre class="source-code">
const v = [
    [1, 3, 1],
    [1, 3, -1],
    [1, -1, 1],
    [1, -1, -1],
    [-1, 3, -1],
    [-1, 3, 1],
    [-1, -1, -1],
    [-1, -1, 1]]
const faces = new Float32Array([
  ...v[0], ...v[2], ...v[1],
  ...v[2], ...v[3], ...v[1],
  ...v[4], ...v[6], ...v[5],
  ...v[6], ...v[7], ...v[5],
  ...v[4], ...v[5], ...v[1],
  ...v[5], ...v[0], ...v[1],
  ...v[7], ...v[6], ...v[2],
  ...v[6], ...v[3], ...v[2],
  ...v[5], ...v[7], ...v[0],
  ...v[7], ...v[2], ...v[0],
  ...v[1], ...v[3], ...v[4],
  ...v[3], ...v[6], ...v[4]
]);
const bufferGeometry = new THREE.BufferGeometry();
bufferGeometry.setAttribute("position", new THREE.BufferAttribute(faces, 3));
bufferGeometry.computeVertexNormals();</pre>
			<p>The preceding code <a id="_idIndexMarker128"/>shows how to create a simple cube. We define the points (the vertices) that make up this cube in the <code>v</code> array. From these vertices, we can create the faces next. In Three.js, we need to provide all the <code>faces</code> information in one large <code>Float32Array</code>. As we mentioned, a face consists of three vertices. So, for each face, we need to define nine values: the <code>x</code>, <code>y</code>, and <code>z</code> of each vertex. Since we’ve got three vertices per face, we have nine values. To make it a little bit easier to read, we use the <code>...</code> (spread) operator from JavaScript to add the individual values of each vertex to the array. So,  <code>...v[0], ...v[2], ...v[1]</code> will result in the following values in the array: <code>1, 3, 1, 1, -1, 1, 1, </code><code>3, 1</code>.</p>
			<p>Note that you have to take care of the sequence of the vertices used to define the faces. The order in which they are defined determines whether Three.js thinks it is a front-facing face (a face facing the camera) or a back-facing face. If you create faces, you should use a clockwise sequence for front-facing faces and a counter-clockwise sequence if you want to create a back-facing face.</p>
			<p>In our example, we have used a number of vertices to define the six sides of the cube, with two triangles for each face. In previous versions of Three.js, you could also use a quad instead of a triangle. A quad uses four vertices instead of three to define the face. Whether using quads or triangles is better is a heated debate raging in the 3D modeling world. Basically though, using quads is often preferred during modeling since they can be more easily enhanced and smoothed than triangles. For rendering and game engines though, working with triangles is often easier since every shape can be rendered very efficiently using triangles.</p>
			<p>Using these vertices<a id="_idIndexMarker129"/> and faces, we can now create a new instance of <code>THREE.BufferGeometry</code> and assign the vertices to the <code>position</code> attribute. The last step is to call <code>computeVertexNormals()</code> on the geometry we have created. When we call this function, Three.js determines the normal vector for each of the vertices and for the faces. This is the information Three.js uses to determine how to color the faces based on the various lights in the scene (which you can easily visualize if you use <code>THREE.MeshNormalMaterial</code>).</p>
			<p>With this geometry, we can now create a mesh, just like we saw earlier. We’ve created an example that you can use to play around with the position of the vertices, which also shows the individual faces. In our <code>chapter-2/custom-geometry</code> example, you can change the position of all the vertices of a cube and see how the faces react. This is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.8_B18726.jpg" alt="Figure 2.8 – Move vertices around to change the shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Move vertices around to change the shape</p>
			<p>This example, which uses the same setup as all our other examples, has a render loop. Whenever you change one of the properties in the drop-down control box, the cube is rendered based on<a id="_idIndexMarker130"/> the changed position of one of the vertices. This isn’t something that works out of the box. For performance reasons, Three.js assumes that the geometry of a mesh won’t change during its lifetime. For most geometries and use cases, this is a very valid assumption. If you, however, change the backing array (in this case, the <code>const faces = new Float32Array([...])</code> array), we need to tell Three.js that something has changed. You can do that by setting the <code>needsUpdate</code> property of the relevant attribute to <code>true</code>. This will look something like the following:</p>
			<pre class="source-code">
mesh.geometry.attributes.position.needsUpdate = true;
mesh.geometry.computeVertexNormals();</pre>
			<p>Note that in the case of updated vertices, it is also a good idea to recalculate the normal vectors, to make sure the materials are also rendered correctly. More information on what a normal vector is and why it is important will be explained in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working </em><em class="italic">with Textures</em>.</p>
			<p>There is one button from the <code>chapter-2/custom-geometry</code> menu that we haven’t addressed yet. In the menu on the right, there is a <code>clone()</code> function, as the name implies, we can make a copy of the geometry and, for instance, use it to create a different mesh with a different material. In the same example, <code>chapter-2/custom-geometry</code>, you can see a <strong class="bold">clone</strong> button at the top of the <a id="_idIndexMarker131"/>control GUI, as in the following screenshot:</p>
			<div><div><img src="img/Figure_2.9_B18726.jpg" alt="Figure 2.9 – Make a clone of the geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Make a clone of the geometry</p>
			<p>If you click on this button, a clone (copy) will be made of the geometry as it currently is; then, a new object will be created with a different material, and finally, the object will be added to the scene. The code for this is as follows:</p>
			<pre class="source-code">
const cloneGeometry = (scene) =&gt; {
  const clonedGeometry = bufferGeometry.clone();
  const backingArray = clonedGeometry.getAttribute
    ("position").array;
  // change the position of the x vertices so it is placed
  // next to the original object
  for (const i in backingArray) {
    if ((i + 1) % 3 === 0) {
      backingArray[i] = backingArray[i] + 3;
    }
  }
  clonedGeometry.getAttribute("position").needsUpdate =
    true;
  const cloned = meshFromGeometry(clonedGeometry);
  cloned.name = "clonedGeometry";
  const p = scene.getObjectByName("clonedGeometry");
  if (p) scene.remove(p);
  scene.add(cloned);
};</pre>
			<p>As you can see in the <a id="_idIndexMarker132"/>preceding code, we use the <code>clone()</code> function to clone <code>bufferGeometry</code>. Once cloned, we make sure to update the <code>x</code> value of each vertex so the clone is put in a different position than the original one (we could also have used <code>translateX</code>, which we explain in the following section of this chapter). Next, we create a <code>THREE.Mesh</code>, remove the cloned mesh if it is there, and add the new clone. To create the new mesh, we use a custom function called <code>meshFromGeometry</code>. As a quick sidestep, let’s look at how that is implemented as well:</p>
			<pre class="source-code">
const meshFromGeometry = (geometry) =&gt; {
  var materials = [
    new THREE.MeshBasicMaterial({ color: 0xff0000,
      wireframe: true }),
    new THREE.MeshLambertMaterial({
      opacity: 0.1,
      color: 0xff0044,
      transparent: true,
    }),
  ];
  var mesh = createMultiMaterialObject(geometry, materials);
  mesh.name = "customGeometry";
  mesh.children.forEach(function (e) {
    e.castShadow = true;
  });
  return mesh;
};</pre>
			<p>If you look back<a id="_idIndexMarker133"/> at this example, you can see a transparent cube and the lines (the edges) that make up our geometry. To do this, we create a multi-material mesh. This means that we tell Three.js to use two different materials in a single mesh. For this, Three.js provides a nice helper function called <code>createMultiMaterialObject</code>, which does what the name implies. Based on a geometry and a list of materials, it creates an object that we can add to the scene. There is one thing you need to know though when working with the results from a <code>createMultiMaterialObject</code> call. What you get back isn’t a single mesh; it is a <code>THREE.Group</code>, a container object that, in this case, contains a separate <code>THREE.Mesh</code> for each of the materials we provide. So, when rendering the mesh, it looks like a single object, but it actually comprises multiple <code>THREE.Mesh</code> objects rendered on top of one another. This also means that if we want to have shadows, we need to enable this for each of the meshes inside the group (which is what we did in the preceding code fragment).</p>
			<p>In the preceding code, we used <code>createMultiMaterialObject</code> from the <code>THREE.SceneUtils</code> object to add a wireframe to the geometry we created. Three.js also provides an alternative way of adding a wireframe using <code>THREE.WireframeGeometry</code>. Assuming you have a geometry called <code>geom</code>, you can create a wireframe geometry from that: <code>const wireframe = new THREE.WireframeGeometry(geom);</code>. Next, you can draw the lines of this geometry, using the <code>Three.LineSegments</code> object, by first creating a <code>const line = new THREE.LineSegments(wireframe)</code> object, and then adding it to the scene: <code>scene.add(line)</code>. Since this helper internally is just a <code>THREE.Line</code> object, you can style how the wireframe appears. For instance, to set the width of the wireframe lines, use <code>line.material.linewidth = </code><code>2;</code>.</p>
			<p>We’ve already<a id="_idIndexMarker134"/> looked a bit at the <code>THREE.Mesh</code> object. In the next section, we’ll dive a bit deeper into what you can do with it.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Functions and attributes for meshes</h2>
			<p>We’ve already <a id="_idIndexMarker135"/>learned that <a id="_idIndexMarker136"/>to create a mesh, we need a geometry and one or more materials. Once we have a mesh, we add it to the scene and it’s rendered. There are a couple of properties you can use to change where and how this mesh appears on the scene. In our first example, we’ll look at the following set of properties and functions:</p>
			<ul>
				<li><code>position</code>: This determines the position of the object relative to the position of its parent. Most often, the parent of an object is a <code>THREE.Scene</code> object or a <code>THREE.Group</code> object.</li>
				<li><code>rotation</code>: With this property, you can set the rotation of an object around any of its own axes. Three.js also provides specific functions for rotations around a single axis: <code>rotateX()</code>, <code>rotateY()</code>, and <code>rotateZ()</code>.</li>
				<li><code>scale</code>: This property allows you to scale the object around its <code>x-</code>, <code>y-</code>, and <code>z-a</code>xes.</li>
				<li><code>translateX()</code> / <code>translateY()</code> and <code>translateZ()</code>: This property moves the object by a specified amount along the corresponding axis.</li>
				<li><code>lookAt()</code>: This property points the object to a specific vector in space. This is an alternative to setting the rotation manually.</li>
				<li><code>visible</code>: This property determines whether this mesh should be rendered or not.</li>
				<li><code>castShadow</code>: This property determines whether this mesh casts shadows when it is hit by light. By default, meshes don’t cast shadows.</li>
			</ul>
			<p>When we’re rotating an object, we’re rotating around an axis. In a 3D scene, there are multiple spaces that have an axis you can rotate around. The <code>rotateN()</code> functions rotate the object around the axis in <em class="italic">local</em> space. This means the object rotates around the axis of its parent. So, when you add an object to the scene, the <code>rotateN()</code>  functions will <a id="_idIndexMarker137"/>rotate<a id="_idIndexMarker138"/> that object around the main axis of the scene. When it is part of a nested group, these functions will rotate the object around the axis of its parent, which is normally the behavior you’re looking for. Three.js also has a specific <code>rotateOnWorldAxis</code>, which allows you to rotate an object around the axis of the main <code>THREE.Scene</code> regardless of the actual parent of the object. Finally, you can also force the object to rotate around its own axis (this is called <em class="italic">object</em> space) by calling the <code>rotateOnAxis</code> function.</p>
			<p>As always, we have an example ready for you that will allow you to play around with these properties. If you open <code>chapter-2/mesh-properties</code> in your browser, you get a drop-down menu where you can alter all these properties and directly see the result, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.10_B18726.jpg" alt="Figure 2.10 – Mesh properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Mesh properties</p>
			<p>Let me walk <a id="_idIndexMarker139"/>you<a id="_idIndexMarker140"/> through the properties; I’ll start with the <code>position</code> property.</p>
			<h3>Setting the location of the mesh with the position property</h3>
			<p>We’ve already <a id="_idIndexMarker141"/>seen this property <a id="_idIndexMarker142"/>a couple of times, so let’s quickly address it. With this property, you set the <code>x-</code>, <code>y-</code>, and <code>z-c</code>oordinates of the object relative to its parent. We’ll get back to this in <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Learning to Work with Geometries</em>, when we look at grouping objects. We can set an object’s position property in three different ways. We can set each coordinate directly:</p>
			<pre class="source-code">
cube.position.x = 10;
cube.position.y = 3;
cube.position.z = 1;</pre>
			<p>However, we can also set all of them at once, as follows:</p>
			<pre class="source-code">
cube.position.set(10,3,1);</pre>
			<p>There is also a third option. The <code>position</code> property is a <code>THREE.Vector3</code> object. That means we can also do the following to set this object:</p>
			<pre class="source-code">
cube.position = new THREE.Vector3(10,3,1)</pre>
			<p>Next on the list is the <code>rotation</code> property. You’ve already seen this property being used a couple of <a id="_idIndexMarker143"/>times here<a id="_idIndexMarker144"/> and in <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene </em><em class="italic">with Three.js</em>.</p>
			<h3>Defining the rotation of the mesh with the rotation property</h3>
			<p>With this <a id="_idIndexMarker145"/>property, you set the<a id="_idIndexMarker146"/> rotation of the object around one of its axes. You can set this value in the same manner as we did the position. A complete rotation, as you might remember from math class, is <code>2π</code>. You can configure this in Three.js in a couple of different ways:</p>
			<pre class="source-code">
cube.rotation.x = 0.5*Math.PI;
cube.rotation.set(0.5*Math.PI, 0, 0);
cube.rotation = new THREE.Vector3(0.5*Math.PI,0,0);</pre>
			<p>If you want to use degrees (from 0 to 360) instead, we’ll have to convert those to radians. This can be easily done as follows:</p>
			<pre class="source-code">
const degrees = 45;
const inRadians = degrees * (Math.PI / 180);</pre>
			<p>In the preceding code block, we’ve done the conversion ourselves. Three.js also provides the <code>MathUtils</code> class, which provides a lot of helpful conversions, including one that does the same thing as we did in the preceding code block. You can play around with this property using the <code>chapter-2/mesh-properties</code> example.</p>
			<p>The next property on our list is one we haven’t talked about: <code>scale</code>. The name pretty much sums up what you can do with this property. You can scale the object along a specific axis. If you set the scale to a value less than one, the object will shrink, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.11_B18726.jpg" alt="Figure 2.11 – Use scale to shrink a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Use scale to shrink a mesh</p>
			<p>When you use<a id="_idIndexMarker147"/> values greater<a id="_idIndexMarker148"/> than one, the object will become larger, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_2.12_B18726.jpg" alt="Figure 2.12 – Use scale to grow a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Use scale to grow a mesh</p>
			<p>The<a id="_idIndexMarker149"/> next part<a id="_idIndexMarker150"/> of the mesh that we’ll look at is the <code>translate</code> property.</p>
			<h3>Changing the position using the translate property</h3>
			<p>With <code>translate</code>, you<a id="_idIndexMarker151"/> can also<a id="_idIndexMarker152"/> change the position of an object, but instead of defining the absolute position where you want the object to be, you define the distance the object should move, relative to its current position. For instance, we have a sphere that is added to a scene, and its position has been set to <code>(1, 2, 3)</code>. Next, we translate the object along its <code>x-a</code>xis: <code>translateX(4)</code>. Its position will now be <code>(5, 2, 3)</code>. If we want to restore the object to its original position, we use <code>translateX(-4)</code>. In the <code>chapter-2/mesh-properties</code> example, there is a menu tab called <code>translate</code> values for <code>x</code>, <code>y</code>, and <code>z</code> and hit the <strong class="bold">translate</strong> button. You’ll see the object being moved to a new position based on these three values.</p>
			<p>The last two properties we’ll look at are used to remove the object completely, by setting the <code>visible</code> property to <code>false</code>, and disabling whether this object casts shadows by setting the <code>castShadow</code> property to <code>false</code>. When you click on these buttons, you’ll see the cube becomes invisible and visible, and you can disable it from casting shadows.</p>
			<p>For more information on meshes, geometries, and what you can do with these objects, check out <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Learning to Work with Geometries</em>, and <a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Points </em><em class="italic">and Sprites</em>.</p>
			<p>So far, we’ve looked at <code>THREE.Scene</code>, the main object that holds all the objects that we want to render, and we’ve looked in detail at what a <code>THREE.Mesh</code> is, and how you can create a <code>THREE.Mesh</code> and position it in a scene. In previous sections, we’ve already used a camera to determine what part of <code>THREE.Scene</code> you wanted to render but haven't <a id="_idIndexMarker153"/>explained in detail yet how<a id="_idIndexMarker154"/> you can configure a camera. In the next section, we’ll dive into those details.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Using different cameras for different scenes</h1>
			<p>There are two <a id="_idIndexMarker155"/>different camera types in Three.js: the orthographic camera and the perspective camera. Note that Three.js also provides a couple of very specific cameras for creating scenes that can be viewed using 3D glasses or VR gear. We won’t go into detail about those cameras in this book, since they work exactly the same as the cameras explained in this chapter. If you’re interested in these <a id="_idIndexMarker156"/>cameras, Three.js <a id="_idIndexMarker157"/>provides a few <a id="_idIndexMarker158"/>standard examples:</p>
			<ul>
				<li><strong class="bold">Anaglyph </strong><strong class="bold">effect</strong>: <a href="https://threejs.org/examples/#webgl_effects_anaglyph&#13;">https://threejs.org/examples/#webgl_effects_anaglyph</a></li>
				<li><strong class="bold">Parallax </strong><strong class="bold">barrier</strong>: <a href="https://threejs.org/examples/#webgl_effects_parallaxbarrier&#13;">https://threejs.org/examples/#webgl_effects_parallaxbarrier</a></li>
				<li><strong class="bold">Stereo </strong><strong class="bold">effect</strong>: <a href="https://threejs.org/examples/#webgl_effects_stereo&#13;">https://threejs.org/examples/#webgl_effects_stereo</a></li>
			</ul>
			<p>If you’re looking for simple VR cameras, you can use <code>THREE.StereoCamera</code> to create 3D scenes that are rendered side to side (standard stereo effect), use a parallel barrier (as 3DS provides), or provide an anaglyph effect where the different views are rendered in different colors. Alternatively, Three.js has some experimental support for the WebVR standard, which is supported by a number of browsers (for more info, see <a href="https://webvr.info/developers/">https://webvr.info/developers/</a>). To use this, not that much needs to change. You just set <code>renderer.vr.enabled = true</code>, and Three.js will handle the rest. The Three.js website has a couple of examples where this property and some other features of Three.js's support for WebVR are demonstrated: <a href="https://threejs.org/examples/">https://threejs.org/examples/</a>.</p>
			<p>For now, we’ll<a id="_idIndexMarker159"/> focus on the standard perspective and orthographic cameras. The best way to explain the differences between these cameras is by looking at a couple of examples.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>An orthographic camera versus a perspective camera</h2>
			<p>In the examples<a id="_idIndexMarker160"/> for this chapter, you can<a id="_idIndexMarker161"/> find a demo called <code>chapter2/cameras</code>. When you open this example, you’ll see something like the following:</p>
			<div><div><img src="img/Figure_2.13_B18726.jpg" alt="Figure 2.13 – Perspective camera view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Perspective camera view</p>
			<p>This preceding screenshot is called a perspective view and is the most natural view. As you can see from this figure, the farther away the cubes are from the camera, the smaller they are rendered. If we change the camera to the other type supported by Three.js, the orthographic camera, you’ll see the following view of the same scene:</p>
			<div><div><img src="img/Figure_2.14_B18726.jpg" alt="Figure 2.14 – Orthographic camera view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Orthographic camera view</p>
			<p>With<a id="_idIndexMarker162"/> the<a id="_idIndexMarker163"/> orthographic camera, all the cubes are rendered the same size; the distance between an object and the camera doesn’t matter. This is often used in 2D games, such as old versions of <em class="italic">Civilization</em> and <em class="italic">SimCity 4</em>:</p>
			<div><div><img src="img/Figure_2.15_B18726.jpg" alt="Figure 2.15 – Orthographic usage in Si﻿mCity 4"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Orthographic usage in SimCity 4</p>
			<h3>Perspective camera properties</h3>
			<p>Let’s first look a<a id="_idIndexMarker164"/> bit closer at <code>THREE.PerspectiveCamera</code>. In the example, you can set a number of properties that define what is shown through the lens of the camera:</p>
			<ul>
				<li><code>fov</code>: The <strong class="bold">Field of View</strong> (<strong class="bold">FOV</strong>) is the<a id="_idIndexMarker165"/> part of the scene that can be seen from the position of the camera. Humans, for instance, have an almost 180-degree FOV, while some birds even have a complete 360-degree FOV. But since a normal computer screen doesn’t completely fill our vision, a smaller value is often chosen. Generally, for games, a FOV of between 60 and 90 degrees is chosen. <em class="italic">Good </em><em class="italic">default</em>: 50</li>
				<li><code>aspect</code>: This is the aspect ratio between the horizontal and vertical sizes of the area where we’re rendering the output. In our case, since we use the entire window, we just use that ratio. The aspect ratio determines the difference between the horizontal FOV and the vertical FOV. <em class="italic">Good default</em>: <code>window.innerWidth / </code><code>window.innerHeight</code></li>
				<li><code>near</code>: The <code>near</code> property defines how close to the camera Three.js should render the scene. Normally, we set this to a very small value to directly render everything from the position of the camera. <em class="italic">Good </em><em class="italic">default</em>: 0.1</li>
				<li><code>far</code>: The <code>far</code> property defines how far the camera can see from the position of the camera. If we set this too low, part of our scene might not be rendered, and if we set it too high, in some cases, it might affect the rendering performance. <em class="italic">Good </em><em class="italic">default</em>: 100</li>
				<li><code>zoom</code>: The <code>zoom</code> property allows you to zoom in and out of the scene. When you use a number lower than 1, you zoom out of the scene, and if you use a number higher than 1, you zoom in. Note that if you specify a negative value, the scene will be rendered upside down. <em class="italic">Good </em><em class="italic">default</em>: 1</li>
			</ul>
			<p>The following <a id="_idIndexMarker166"/>diagram gives a good overview of how these properties work together to determine what you see:</p>
			<div><div><img src="img/Figure_2.16_B18726.jpg" alt="Figure 2.16 – Properties of the perspective camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Properties of the perspective camera</p>
			<p>The <code>fov</code> property of the camera determines the horizontal FOV. Based on the <code>aspect</code> property, the vertical FOV is determined. The <code>near</code> property is used to determine the position of the near plane, and the <code>far</code> property determines the position of the far plane. The area<a id="_idIndexMarker167"/> between the near plane and the far plane will be rendered as follows:</p>
			<div><div><img src="img/Figure_2.17_B18726.jpg" alt="Figure 2.17 – Far and near clip the rendered mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Far and near clip the rendered mesh</p>
			<h3>Orthographic camera properties</h3>
			<p>To configure<a id="_idIndexMarker168"/> the orthographic camera, we need to use other properties. The orthographic projection isn’t interested in which aspect ratio to use or what FOV we have of the scene, since all the objects are rendered at the same size. When you define an orthographic camera, you define the cuboid area that needs to be rendered. The properties of the orthographic camera reflect this, as follows:</p>
			<ul>
				<li><code>left</code>: This is described in the Three.js documentation as the camera frustum left plane. You should see this as the left-hand border of what will be rendered. If you set this value to <code>-100</code>, you won’t see any objects that are positioned farther than that on the left-hand side.</li>
				<li><code>right</code>: The <code>right</code> property works in a way similar to the <code>left</code> property, but this time, on the other side of the screen. Anything farther to the right won’t be rendered.</li>
				<li><code>top</code>: This is the top position to be rendered.</li>
				<li><code>bottom</code>: This is the bottom position to be rendered.</li>
				<li><code>near</code>: From this point, based on the position of the camera, the scene will be rendered.</li>
				<li><code>far</code>: To this point, based on the position of the camera, the scene will be rendered.</li>
				<li><code>zoom</code>: This allows you to zoom in and out of the scene. When you use a number lower than <code>1</code>, you’ll zoom out of the scene; if you use a number higher than <code>1</code>, you’ll zoom in. Note that if you specify a negative value, the scene will be rendered upside down. The default value is <code>1</code>.</li>
			</ul>
			<p>And all these <a id="_idIndexMarker169"/>properties can be summarized in the following diagram:</p>
			<div><div><img src="img/Figure_2.18_B18726.jpg" alt="Figure 2.18 – Properties of the orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Properties of the orthographic camera</p>
			<p>And just like with the perspective camera, you can exactly define the area of the scene you want to render:</p>
			<div><div><img src="img/Figure_2.19_B18726.jpg" alt="Figure 2.19 – Clipped area with an orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Clipped area with an orthographic camera</p>
			<p>In the previous section, we explained the different cameras supported by Three.js. You’ve learned how to configure them, and how you can use their properties to render different parts <a id="_idIndexMarker170"/>of the scene. What we didn’t show yet is how you can control what part of the scene a camera is looking at. We’ll explain that in the next section.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Looking at specific points</h2>
			<p>So far, you’ve seen how to create a camera and what the various arguments mean. In <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you also saw that you need to position your <a id="_idIndexMarker171"/>camera somewhere in the scene and that the view from that camera is rendered. Normally, the camera is pointed to the center of the scene: position <code>(0, 0, 0)</code>. We can, however, easily change what the camera is looking at, as follows:</p>
			<pre class="source-code">
<code>camera.lookAt(new THREE.Vector3(x, y, z));</code></pre>
			<p>In the <code>chapter2/cameras</code> example, you can also specify the coordinates you want the camera to look at. Note that when you change <code>lookAt</code> in the <code>OrthographicCamera</code> settings, the cubes still stay the same size.</p>
			<div><div><img src="img/Figure_2.20_B18726.jpg" alt="Figure 2.20 – Changed lookAt property for the orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Changed lookAt property for the orthographic camera</p>
			<p>When you use the <code>lookAt</code> function, you point the camera at a specific position. You can also use this to make the camera follow an object around a scene. Since every <code>THREE.Mesh</code> object has a position that is a <code>THREE.Vector3</code> object, you can use the <code>lookAt</code> function to <a id="_idIndexMarker172"/>point to a specific mesh in the scene. All you need to use is this: <code>camera.lookAt(mesh.position)</code>. If you call this in the render loop, you’ll make the camera follow an object as it moves through a scene.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Debugging what a camera looks at</h2>
			<p>When looking at <a id="_idIndexMarker173"/>configuring the camera, having a menu where you can play around with the different settings can help a lot. Sometimes, though, you might want to exactly see the area that will be rendered by the camera. Three.js allows you to do this, by visualizing the frustum of the camera (the area that is shown by the camera). To do this, we simply add an additional camera to the scene and add a camera helper. To see this in action, open the <code>chapter-2/debug-camera.html</code> example:</p>
			<div><div><img src="img/Figure_2.21_B18726.jpg" alt="Figure 2.21 – Show the frustum of the camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – Show the frustum of the camera</p>
			<p>In the preceding figure, you <a id="_idIndexMarker174"/>can see the outline of the frustum of a perspective camera. If you change the properties in the menu, you can see that the frustum changes as well. This frustum is visualized by adding the following:</p>
			<pre class="source-code">
const helper = new THREE.CameraHelper(camera);
scene.add(helper);
// in the render loop
helper.update();</pre>
			<p>We’ve also added a <strong class="bold">switchCamera</strong> button, which allows you to switch between the external camera looking in at the scene and the main camera in the scene. This provides a great way to get the correct settings for your camera:</p>
			<div><div><img src="img/Figure_2.22_B18726.jpg" alt="Figure 2.22 – Switch between cameras"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – Switch between cameras</p>
			<p>Switching cameras<a id="_idIndexMarker175"/> is really easy in Three.js. The only thing you need to do is tell Three.js you want to render the scene through a different camera.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Summary</h1>
			<p>We discussed a lot in this second introductory chapter. We showed the functions and properties of <code>THREE.Scene</code> and explained how you can use these properties to configure your main scene. We also showed you how to create geometries. You can either create them from scratch using a <code>THREE.Buffergeometry</code> object or use any of the built-in geometries Three.js provides. Finally, we showed you how to configure the two main cameras Three.js provides. <code>THREE.PerspectiveCamera</code> renders a scene using a real-world perspective, and <code>THREE.OrthographicCamera</code> provides the fake 3D effect often seen in games. We’ve also covered how geometries work in Three.js and you can now easily create your own geometries from the standard geometries provided by Three.js or by crafting them by hand.</p>
			<p>In the next chapter, we’ll look at the various light sources that are available in Three.js. You’ll learn how the various light sources behave, how to create and configure them, and how they affect different materials.</p>
		</div>
	</body></html>