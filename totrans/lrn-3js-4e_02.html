<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-29" class="chapter-number"><a id="_idTextAnchor028"/>2</h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>The Basic Components that Make up a Three.js Application</h1>
			<p>In the previous chapter, you learned about the basics of Three.js. We looked at a couple of examples, and you created your first complete Three.js application. In this chapter, we’ll dive a bit deeper into Three.js and explain the basic components that make up a <span class="No-Break">Three.js application.</span></p>
			<p>By the end of this chapter, you’ll have learned how to use the basic components that are used in every Three.js application and should be able to create simple scenes using these standard components. You should also feel comfortable working with Three.js applications that use the more advanced objects, since the approach used by Three.js for simple and advanced components is <span class="No-Break">the same.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating <span class="No-Break">a scene</span></li>
				<li>How geometries and meshes <span class="No-Break">are related</span></li>
				<li>Using different cameras for <span class="No-Break">different scenes</span></li>
			</ul>
			<p>We’ll start by looking at how you can create a scene and <span class="No-Break">add objects.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Creating a scene</h1>
			<p>In <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you created a <strong class="source-inline">THREE.Scene</strong>, so you <a id="_idIndexMarker098"/>already know some of the basics of Three.js. We saw that for a scene to show anything, we need four different types <span class="No-Break">of objects:</span></p>
			<ul>
				<li><strong class="bold">Camera</strong>: This <a id="_idIndexMarker099"/>determines which part of <strong class="source-inline">THREE.Scene</strong> is <span class="No-Break">rendered onscreen.</span></li>
				<li><strong class="bold">Lights</strong>: These have an <a id="_idIndexMarker100"/>effect on how materials are shown and are used when creating shadow effects (discussed in detail in <a href="B18726_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Working with Light Sources </em><span class="No-Break"><em class="italic">in Three.js</em></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Meshes</strong>: These are<a id="_idIndexMarker101"/> the main objects that are rendered from the perspective of the camera. These objects contain the vertices and faces that make up the geometry (for example, a sphere or a cube) and contain a material, which defines what the geometry <span class="No-Break">looks like.</span></li>
				<li><strong class="bold">Renderer</strong>: This uses <a id="_idIndexMarker102"/>the camera and the information in the scene to draw (render) the output on <span class="No-Break">the screen.</span></li>
			</ul>
			<p><strong class="source-inline">THREE.Scene</strong> serves as the main container for the lights and the meshes you want to render. <strong class="source-inline">THREE.Scene</strong> itself doesn’t have that many options <span class="No-Break">and functions.</span></p>
			<p><strong class="source-inline">THREE.Scene</strong> is a structure that is sometimes also called a scene graph. A scene graph can hold all the necessary information of a graphical scene. In Three.js, this means that a <strong class="source-inline">THREE.Scene</strong> contains all the objects necessary for rendering. It is interesting to note that a scene graph, as the name implies, isn’t just an array of objects; a scene graph consists of a set of nodes in a tree structure. As we’ll see in <a href="B18726_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em>, Three.js provides objects you can use to create groups of different meshes or lights. The main object you use for that, which you can use to create a scene graph, is the <strong class="source-inline">THREE.Group</strong>. As the name implies, this object allows you to group objects together. A <strong class="source-inline">THREE.Group</strong> extends from another base class in Three.js called <strong class="source-inline">THREE.Object3D</strong>, which provides a set of standard functions to add and modify children. <strong class="source-inline">THREE.Mesh</strong> and <strong class="source-inline">THREE.Scene</strong> both also extend<a id="_idIndexMarker103"/> from a <strong class="source-inline">THREE.Object3D</strong> so you could also use those to create a nested structure. But it’s convention, and also more semantically correct, to use <strong class="source-inline">THREE.Group</strong> to build up the <span class="No-Break">scene graph.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>The basic functionality of a scene</h2>
			<p>The best way to<a id="_idIndexMarker104"/> explore the functionality of a scene is by looking at an example. In the source code for this chapter, you can find the <strong class="source-inline">chapter-2/basic-scene.html</strong> example. We’ll use this example to explain the various functions and options a scene has. When we open this example in the browser, the output will look similar to what’s shown in the next screenshot (remember that you can use the mouse to move, zoom, and pan around the <span class="No-Break">rendered scene):</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_2.1_B18726.jpg" alt="Figure 2.1 – Basic scene setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Basic scene setup</p>
			<p>The preceding figure looks like the examples we saw in <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>. Even though the scene looks pretty empty, it already contains a <span class="No-Break">few objects:</span></p>
			<ul>
				<li>We’ve got <strong class="source-inline">THREE.Mesh</strong>, which represents the floor area you <span class="No-Break">can see</span></li>
				<li>We’re using <strong class="source-inline">THREE.PerspectiveCamera</strong> to determine what we’re <span class="No-Break">looking at</span></li>
				<li>We’ve<a id="_idIndexMarker105"/> added <strong class="source-inline">THREE.AmbientLight</strong> and <strong class="source-inline">THREE.DirectionalLight</strong> to <span class="No-Break">provide lighting</span></li>
			</ul>
			<p>The source code for this example can be found in <strong class="source-inline">basic-scene.js</strong>, and we can use code from <strong class="source-inline">bootstrap/bootstrap.js</strong>, <strong class="source-inline">bootstrap/floor.js</strong>, and <strong class="source-inline">bootstrap/lighting.js</strong> since this is a generic scene setup we use throughout this book. What happens in all these files can be simplified as in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// create a camera
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// create a renderer
const renderer = new THREE.WebGLRenderer({ antialias: true
  });
// create a scene
const scene = new THREE.Scene();
// create the lights
scene.add(new THREE.AmbientLight(0x666666));
scene.add(THREE.DirectionalLight(0xaaaaaa));
// create the floor
const geo = new THREE.BoxBufferGeometry(10, 0.25, 10, 10,
  10, 10);
const mat = new THREE.MeshStandardMaterial({ color:
  0xffffff,});
const mesh = new THREE.Mesh(geo, mat);
scene.add(mesh);</pre>
			<p>As you can see <a id="_idIndexMarker106"/>in the preceding code, we create <strong class="source-inline">THREE.WebGLRenderer</strong> and <strong class="source-inline">THREE.PerspectiveCamera</strong>, since we always need those. Next, we create a <strong class="source-inline">THREE.Scene</strong> and just add all the objects that we want to use. In this case, we add two lights and a single mesh. Now, we have all the components to start up a render loop, as we’ve already seen in <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene </em><span class="No-Break"><em class="italic">with Three.js</em></span><span class="No-Break">.</span></p>
			<p>Before we look at the <strong class="source-inline">THREE.Scene</strong> object in more depth, we’ll first explain what you can do in the demo, and after that, look at the code. Open the <strong class="source-inline">chapter-2/basic-scene.html</strong> example in your browser and look at the <strong class="bold">Controls</strong> menu in the upper-right corner, which you <a id="_idIndexMarker107"/>can see in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_2.2_B18726.jpg" alt="Figure 2.2 – Basic scene setup with Cubemap background"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Basic scene setup with Cubemap background</p>
			<h3>Adding and removing objects</h3>
			<p>With these <strong class="bold">Controls</strong>, you <a id="_idIndexMarker108"/>can add cubes to the scene and remove the cube that was last added. It also allows you to change the background of the scene and set the material and the environment map for all the objects in the scene. We’ll explore these various options and how you can use them to configure a <strong class="source-inline">THREE.Scene</strong>. We’ll start by looking at how you can add and remove <strong class="source-inline">THREE.Mesh</strong> objects to and from a scene. The following code shows the function we call when you click on the <span class="No-Break"><strong class="bold">addCube</strong></span><span class="No-Break"> button:</span></p>
			<pre class="source-code">
const addCube = (scene) =&gt; {
  const color = randomColor();
  const pos = randomVector({
    xRange: { fromX: -4, toX: 4 },
    yRange: { fromY: -3, toY: 3 },
    zRange: { fromZ: -4, toZ: 4 },
  });
  const rotation = randomVector({
    xRange: { fromX: 0, toX: Math.PI * 2 },
    yRange: { fromY: 0, toY: Math.PI * 2 },
    zRange: { fromZ: 0, toZ: Math.PI * 2 },
  });
  const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  const cubeMaterial = new THREE.MeshStandardMaterial({
    color: color,
    roughness: 0.1,
    metalness: 0.9,
  });
  const cube = new THREE.Mesh(geometry, cubeMaterial);
  cube.position.copy(pos);
  cube.rotation.setFromVector3(rotation);
  cube.castShadow = true;
  scene.add(cube);
};</pre>
			<p>Let us <a id="_idIndexMarker109"/>understand the preceding code <span class="No-Break">in detail:</span></p>
			<ul>
				<li>First, we have determined some random settings for the cube that will be added: a random color (by calling the <strong class="source-inline">randomColor() </strong>helper function), a random position, and a random rotation. These last two are randomly generated by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">randomVector()</strong></span><span class="No-Break">.</span></li>
				<li>Next, we create the geometry we want to add to the scene: a cube. We just create a new <strong class="source-inline">THREE.BoxGeometry</strong> for this, define a material (<strong class="source-inline">THREE.MeshStandardMaterial</strong> in this example), and combine these two into <strong class="source-inline">THREE.Mesh</strong>. We use random variables to set the cube’s position <span class="No-Break">and rotation.</span></li>
				<li>Finally, this <strong class="source-inline">THREE.Mesh</strong> can then be added to the scene by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">scene.add(cube)</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>A new element that we have introduced in the preceding code is that we also give the cube a name using the <strong class="source-inline">name</strong> attribute. The name is set to <strong class="source-inline">cube-</strong>, appended with the number of objects currently in the scene (<strong class="source-inline">scene.children.length</strong>). A name is very useful for debugging purposes but can also be used to directly access an object from your scene. If you use the <strong class="source-inline">THREE.Scene.getObjectByName(name)</strong> function, you can directly retrieve a specific object and, for instance, change its location without having to make the JavaScript object a <span class="No-Break">global variable.</span></p>
			<p>There might also be <a id="_idIndexMarker110"/>situations where you want to remove an existing object from a <strong class="source-inline">THREE.Scene</strong>. Since a <strong class="source-inline">THREE.Scene</strong> exposes all its children through the <strong class="source-inline">children</strong> property, we can just use the following simple code to remove the last <span class="No-Break">child added:</span></p>
			<pre class="source-code">
const removeCube = (scene) =&gt; {
  scene.children.pop();
};</pre>
			<p>Three.js provides other helpful functions for the <strong class="source-inline">THREE.Scene</strong> too, related to working with the children of <span class="No-Break">the scene:</span></p>
			<ul>
				<li><strong class="source-inline">add</strong>: We’ve already seen this function, which adds the provided object to the scene. If it was previously added to a different <strong class="source-inline">THREE.Object3D</strong>, it’ll be removed from <span class="No-Break">that object.</span></li>
				<li><strong class="source-inline">Attach</strong>: This is similar to <strong class="source-inline">add</strong>, but if you use it, any rotations or translations applied to this object will <span class="No-Break">be kept.</span></li>
				<li><strong class="source-inline">getObjectById</strong>: When you add an object to a scene, it gets an ID. The first one gets <strong class="source-inline">1</strong>, the second one <strong class="source-inline">2</strong>, and so on. With this function, you can get a child based on <span class="No-Break">this ID.</span></li>
				<li><strong class="source-inline">getObjectByName</strong>: This returns an object based on its <strong class="source-inline">name</strong> property. The name is something you can set on an object – this is in contrast with the <strong class="source-inline">id </strong>property, which is assigned <span class="No-Break">by Three.js.</span></li>
				<li><strong class="source-inline">Remove</strong>: This removes this object from <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">Clear</strong>: This removes all the children from <span class="No-Break">the scene.</span></li>
			</ul>
			<p>Note that the preceding functions are actually from the base object that the <strong class="source-inline">THREE.Scene</strong> extends from: <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">THREE.Object3D</strong></span><span class="No-Break">.</span></p>
			<p>Throughout the book, we’ll use these functions if we want to manipulate the children of a scene (or in <strong class="source-inline">THREE.Group</strong>, as we’ll explore <span class="No-Break">later on.)</span></p>
			<p>Besides the functionality<a id="_idIndexMarker111"/> to add and remove objects, a <strong class="source-inline">THREE.Scene</strong> also provides a couple of other settings. The first one we’ll look at is <span class="No-Break">adding fog.</span></p>
			<h3>Adding fog</h3>
			<p>The <strong class="source-inline">fog</strong> property lets<a id="_idIndexMarker112"/> you add a fog effect to the complete scene; the farther an object is from the camera, the more it will be hidden from sight. This is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_2.3_B18726.jpg" alt="Figure 2.3 – Using fog to hide objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Using fog to hide objects</p>
			<p>To best see the effect of the added fog, use the mouse to zoom in and out, and you’ll see the cubes being affected by the fog. Enabling fog is really easy in Three.js. Just add the following line <a id="_idIndexMarker113"/>of code after you’ve defined <span class="No-Break">your scene:</span></p>
			<pre class="source-code">
scene.fog = new THREE.Fog( 0xffffff, 1, 20 );</pre>
			<p>Here, we define white fog (<strong class="source-inline">0xffffff</strong>). The other two properties can be used to tune how the mist appears. The <strong class="source-inline">1</strong> value sets the <strong class="source-inline">near</strong> property, and the <strong class="source-inline">20</strong> value sets the <strong class="source-inline">far</strong> property. With these properties, you can determine where the mist starts and how fast it gets denser. With the <strong class="source-inline">THREE.Fog</strong> object, the fog increases linearly. In the <strong class="source-inline">chapter-02/basic-scene.html</strong> sample, you can modify these properties by using the menu on the right of the screen to see how these settings affect what you <span class="No-Break">see onscreen.</span></p>
			<p>There is also an alternative fog implementation provided by <span class="No-Break">Three.js, </span><span class="No-Break"><strong class="source-inline">THREE.FogExp2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
scene.fog = new THREE.FogExp2( 0xffffff, 0.01 );</pre>
			<p>This time, we don’t specify near and far, but just the color (<strong class="source-inline">0xffffff</strong>) and the mist’s density (<strong class="source-inline">0.01</strong>). Usually, it’s best to experiment a bit with these properties to get the effect <span class="No-Break">you want.</span></p>
			<p>Another<a id="_idIndexMarker114"/> interesting feature of a scene is that you can configure <span class="No-Break">a background.</span></p>
			<h3>Changing the background</h3>
			<p>We’ve already seen that <a id="_idIndexMarker115"/>we can change the background color by setting <strong class="source-inline">clearColor</strong> of <strong class="source-inline">WebGLRenderer</strong> like this: <strong class="source-inline">renderer.setClearColor(backgroundColor)</strong>. You can also use the <strong class="source-inline">THREE.Scene</strong> object to change the background. For this, you’ve got <span class="No-Break">three options:</span></p>
			<ul>
				<li><em class="italic">Option 1</em>: You can use a <span class="No-Break">solid color.</span></li>
				<li><em class="italic">Option 2</em>: You can use a texture, which is basically an image, stretched out to fill the complete screen. (More on textures in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working </em><span class="No-Break"><em class="italic">with Textures</em></span><span class="No-Break">.)</span></li>
				<li><em class="italic">Option 3</em>: You can use an environment map. This is also a kind of texture, but one that completely encompasses the camera, and moves around when you change the <span class="No-Break">camera orientation.</span></li>
			</ul>
			<p>Note that this sets the background color of the HTML canvas we’re rendering to and not the background color of the HTML page. If you want to have a transparent canvas, you need to set the <strong class="source-inline">alpha</strong> property of the renderer <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
new THREE.WebGLRenderer({ alpha: true }}</pre>
			<p>In the <strong class="source-inline">chapter-02/basic-scene.html</strong> menu on the right, there is a dropdown that shows all these different settings. If you select the <strong class="bold">Texture</strong> option from the <strong class="bold">backGround</strong> dropdown, you’ll see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_2.4_B18726.jpg" alt="Figure 2.4 – Background using a texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Background using a texture</p>
			<p>We’ll cover textures and<a id="_idIndexMarker116"/> cubemaps in much more detail in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>. But we’ll have a quick look now at how to configure these and a simple background color for the scene (the source for this can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">controls/scene-controls.js</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
// remove any background by setting the background to null
scene.background = null;
// if you want a simple color, just set the background to a
  color
scene.background = new THREE.Color(0x44ff44);
// a texture can be loaded with a THREE.TextureLoader
const textureLoader = new THREE.TextureLoader();
textureLoader.load(
  "/assets/textures/wood/abstract-antique-
    backdrop-164005.jpg",
  (loaded) =&gt; {
    scene.background = loaded;
  }
// a cubemap can also be loaded with a THREE.TextureLoader
     textureLoader.load("/assets/equi.jpeg", (loaded) =&gt; {
  loaded.mapping = THREE.EquirectangularReflectionMapping;
  scene.background = loaded;
});</pre>
			<p>As you can see from the preceding code, you can assign either <strong class="source-inline">null</strong>, <strong class="source-inline">THREE.Color</strong>, or <strong class="source-inline">THREE.Texture</strong> to the <strong class="source-inline">background</strong> property of the scene. Loading a texture or a cubemap is done asynchronously, so, we have to wait for <strong class="source-inline">THREE.TextureLoader</strong> to load the image data before we can assign it to the background. In the case of the cubemap, we need<a id="_idIndexMarker117"/> to take an extra step and tell Three.js what kind of texture we’ve loaded. We will go into more detail in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>, when we dive into the details of how <span class="No-Break">textures work.</span></p>
			<p>If you look back at the beginning of the following code section, you will see how we created the cubes that we added to <span class="No-Break">the scene:</span></p>
			<pre class="source-code">
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const cubeMaterial = new THREE.MeshStandardMaterial({
  color: color,
  roughness: 0.1,
  metalness: 0.9,
});
const cube = new THREE.Mesh(geometry, cubeMaterial);</pre>
			<p>In the preceding code, we have created a geometry and specified a material. The <strong class="source-inline">THREE.Scene</strong> object also provides a way to force the meshes in the scene to use the same material. In the<a id="_idIndexMarker118"/> following section, we’ll explore how <span class="No-Break">that works.</span></p>
			<h3>Updating all the materials in the scene</h3>
			<p>A <strong class="source-inline">THREE.Scene</strong> has two<a id="_idIndexMarker119"/> properties that affect the material of the meshes in the scene. The first one is the <strong class="source-inline">overrideMaterial</strong> property. First, let’s demonstrate how this works. On the <strong class="source-inline">chapter-02/basic-scene.html</strong> page, you can click on the <strong class="bold">Toggle Override Material</strong> button. This will change the material of all the meshes in the scene to a <span class="No-Break"><strong class="source-inline">THREE.MeshNormalNormal</strong></span><span class="No-Break"> material:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_2.5_B18726.jpg" alt="Figure 2.5 – Override mesh materials with MeshNormalMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Override mesh materials with MeshNormalMaterial</p>
			<p>As you can see in the preceding figure, all the objects (including the ground floor) now use the same material – in this case, <strong class="source-inline">THREE.MeshNormalMaterial</strong>. This material colors each face of the mesh based on its orientation (its <em class="italic">normal</em> vector) to the camera. This can be very easily done in code by just calling <strong class="source-inline">scene.overrideMaterial = </strong><span class="No-Break"><strong class="source-inline">new THREE.MeshNormalMaterial();</strong></span><span class="No-Break">.</span></p>
			<p>Besides applying a complete material to the scene, Three.js also provides a way to set the environment map property of each mesh’s material to the same value. An environment map simulates the environment (for instance, a room, outdoors, or a cave) the meshes are in. The environment map can be used to create reflections on the meshes to make them feel <span class="No-Break">more real.</span></p>
			<p>We’ve already seen how we can load an environment map in the previous section on backgrounds. If we want all our materials to use an environment map for more dynamic reflections and shading, we <a id="_idIndexMarker120"/>can assign that loaded environment map to the <strong class="source-inline">environment</strong> property of <span class="No-Break">a scene:</span></p>
			<pre class="source-code">
textureLoader.load("/assets/equi.jpeg", (loaded) =&gt; {
  loaded.mapping = THREE.EquirectangularReflectionMapping;
  scene.environment = loaded;
});</pre>
			<p>The best way to demonstrate the preceding code is by toggling the <strong class="bold">Toggle Environment</strong> button from the <strong class="source-inline">chapter-02/basic-scene.html</strong> example. If you now zoom in close to the cubes, you can see that their faces reflect part of the environment and aren’t a solid <span class="No-Break">color anymore:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_2.6_B18726.jpg" alt="Figure 2.6 – Set the environment map to all the meshes in the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Set the environment map to all the meshes in the scene</p>
			<p>Now that we’ve discussed<a id="_idIndexMarker121"/> the basic container for all the objects we want to render, in the next section, we’ll take a closer look at the objects (<strong class="source-inline">THREE.Mesh</strong> combining <strong class="source-inline">THREE.Geometry</strong> and a material) that you can add to <span class="No-Break">the scene.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>How geometries and meshes are related</h1>
			<p>In each <a id="_idIndexMarker122"/>of the<a id="_idIndexMarker123"/> examples so far, you’ve seen geometries and meshes being used. For instance, to create a sphere and add it to the scene, we used <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const sphereGeometry = new THREE.SphereGeometry(4, 20, 20);
const sphereMaterial = new THREE.MeshBasicMaterial({color:
  0x7777ff);
const sphere = new THREE.Mesh(sphereGeometry,
  sphereMaterial);
scene.add(sphere);</pre>
			<p>We defined the geometry (<strong class="source-inline">THREE.SphereGeometry</strong>), which is the shape of an object, and its material (<strong class="source-inline">THREE.MeshBasicMaterial</strong>), and we combined these two in a mesh (<strong class="source-inline">THREE.Mesh</strong>) that can be added to a scene. In this section, we’ll take a closer look <a id="_idIndexMarker124"/>at<a id="_idIndexMarker125"/> geometries and meshes. We’ll start <span class="No-Break">with geometries.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The properties and functions of a geometry</h2>
			<p>Three.js comes <a id="_idIndexMarker126"/>with a large set of geometries out of the box that you can use in your 3D scene. Just add a material, create a mesh, and you’re pretty much done. The following screenshot, from the <strong class="source-inline">chapter-2/geometries </strong>example, shows a couple of the standard geometries available <span class="No-Break">in Three.js:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_2.7_B18726.jpg" alt="Figure 2.7 – Some of the basic geometries available in the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Some of the basic geometries available in the scene</p>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Learning to Work with Geometries</em>, and <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Exploring Advanced Geometries</em>, we’ll explore all the basic and advanced geometries that Three.js has to offer. For now, we’ll look in greater detail at what a geometry <span class="No-Break">actually is.</span></p>
			<p>A geometry in Three.js, and in most other 3D libraries, is basically a collection of points in a 3D space, also called vertices (where a single point is called a vertex), and a number of faces connecting those points together. Take, for example, <span class="No-Break">a cube:</span></p>
			<ul>
				<li>A cube has eight corners. Each of these corners can be defined as an <strong class="source-inline">x-, y-, and z- </strong>coordinate. So, each cube has eight points in a <span class="No-Break">3D space.</span></li>
				<li>A cube has six sides, with a vertex at each corner. In Three.js, a face always consists of three vertices that make a triangle (which has three edges). So, in the case of a cube, each side consists of two triangles to make the complete side. An example of how that looks can be seen in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.7</em> by looking at the <span class="No-Break">red cube.</span></li>
			</ul>
			<p>When you use one of the geometries provided by Three.js, you don’t have to define all the vertices and faces yourself. For a cube, you only need to define the width, height, and depth. Three.js uses that information and creates a geometry with eight vertices in the correct position<a id="_idIndexMarker127"/> and with the correct number of faces (12 in the case of a cube – 2 triangles per side). Even though you’d normally use the geometries provided by Three.js or generate them automatically, you can still create geometries completely by hand using vertices and faces, although this can quickly become complex, as you can see in the following lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const v = [
    [1, 3, 1],
    [1, 3, -1],
    [1, -1, 1],
    [1, -1, -1],
    [-1, 3, -1],
    [-1, 3, 1],
    [-1, -1, -1],
    [-1, -1, 1]]
const faces = new Float32Array([
  ...v[0], ...v[2], ...v[1],
  ...v[2], ...v[3], ...v[1],
  ...v[4], ...v[6], ...v[5],
  ...v[6], ...v[7], ...v[5],
  ...v[4], ...v[5], ...v[1],
  ...v[5], ...v[0], ...v[1],
  ...v[7], ...v[6], ...v[2],
  ...v[6], ...v[3], ...v[2],
  ...v[5], ...v[7], ...v[0],
  ...v[7], ...v[2], ...v[0],
  ...v[1], ...v[3], ...v[4],
  ...v[3], ...v[6], ...v[4]
]);
const bufferGeometry = new THREE.BufferGeometry();
bufferGeometry.setAttribute("position", new THREE.BufferAttribute(faces, 3));
bufferGeometry.computeVertexNormals();</pre>
			<p>The preceding code <a id="_idIndexMarker128"/>shows how to create a simple cube. We define the points (the vertices) that make up this cube in the <strong class="source-inline">v</strong> array. From these vertices, we can create the faces next. In Three.js, we need to provide all the <strong class="source-inline">faces</strong> information in one large <strong class="source-inline">Float32Array</strong>. As we mentioned, a face consists of three vertices. So, for each face, we need to define nine values: the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">z</strong> of each vertex. Since we’ve got three vertices per face, we have nine values. To make it a little bit easier to read, we use the <strong class="source-inline">...</strong> (spread) operator from JavaScript to add the individual values of each vertex to the array. So,  <strong class="source-inline">...v[0], ...v[2], ...v[1]</strong> will result in the following values in the array: <strong class="source-inline">1, 3, 1, 1, -1, 1, 1, </strong><span class="No-Break"><strong class="source-inline">3, 1</strong></span><span class="No-Break">.</span></p>
			<p>Note that you have to take care of the sequence of the vertices used to define the faces. The order in which they are defined determines whether Three.js thinks it is a front-facing face (a face facing the camera) or a back-facing face. If you create faces, you should use a clockwise sequence for front-facing faces and a counter-clockwise sequence if you want to create a <span class="No-Break">back-facing face.</span></p>
			<p>In our example, we have used a number of vertices to define the six sides of the cube, with two triangles for each face. In previous versions of Three.js, you could also use a quad instead of a triangle. A quad uses four vertices instead of three to define the face. Whether using quads or triangles is better is a heated debate raging in the 3D modeling world. Basically though, using quads is often preferred during modeling since they can be more easily enhanced and smoothed than triangles. For rendering and game engines though, working with triangles is often easier since every shape can be rendered very efficiently <span class="No-Break">using triangles.</span></p>
			<p>Using these vertices<a id="_idIndexMarker129"/> and faces, we can now create a new instance of <strong class="source-inline">THREE.BufferGeometry</strong> and assign the vertices to the <strong class="source-inline">position</strong> attribute. The last step is to call <strong class="source-inline">computeVertexNormals()</strong> on the geometry we have created. When we call this function, Three.js determines the normal vector for each of the vertices and for the faces. This is the information Three.js uses to determine how to color the faces based on the various lights in the scene (which you can easily visualize if you <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">THREE.MeshNormalMaterial</strong></span><span class="No-Break">).</span></p>
			<p>With this geometry, we can now create a mesh, just like we saw earlier. We’ve created an example that you can use to play around with the position of the vertices, which also shows the individual faces. In our <strong class="source-inline">chapter-2/custom-geometry</strong> example, you can change the position of all the vertices of a cube and see how the faces react. This is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_2.8_B18726.jpg" alt="Figure 2.8 – Move vertices around to change the shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Move vertices around to change the shape</p>
			<p>This example, which uses the same setup as all our other examples, has a render loop. Whenever you change one of the properties in the drop-down control box, the cube is rendered based on<a id="_idIndexMarker130"/> the changed position of one of the vertices. This isn’t something that works out of the box. For performance reasons, Three.js assumes that the geometry of a mesh won’t change during its lifetime. For most geometries and use cases, this is a very valid assumption. If you, however, change the backing array (in this case, the <strong class="source-inline">const faces = new Float32Array([...])</strong> array), we need to tell Three.js that something has changed. You can do that by setting the <strong class="source-inline">needsUpdate</strong> property of the relevant attribute to <strong class="source-inline">true</strong>. This will look something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
mesh.geometry.attributes.position.needsUpdate = true;
mesh.geometry.computeVertexNormals();</pre>
			<p>Note that in the case of updated vertices, it is also a good idea to recalculate the normal vectors, to make sure the materials are also rendered correctly. More information on what a normal vector is and why it is important will be explained in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working </em><span class="No-Break"><em class="italic">with Textures</em></span><span class="No-Break">.</span></p>
			<p>There is one button from the <strong class="source-inline">chapter-2/custom-geometry</strong> menu that we haven’t addressed yet. In the menu on the right, there is a <strong class="bold">clone</strong> button. We mentioned that the geometry defines the form and shape of an object, and combined with a material, we create an object that can be added to the scene to be rendered by Three.js. With the <strong class="source-inline">clone()</strong> function, as the name implies, we can make a copy of the geometry and, for instance, use it to create a different mesh with a different material. In the same example, <strong class="source-inline">chapter-2/custom-geometry</strong>, you can see a <strong class="bold">clone</strong> button at the top of the <a id="_idIndexMarker131"/>control GUI, as in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_2.9_B18726.jpg" alt="Figure 2.9 – Make a clone of the geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Make a clone of the geometry</p>
			<p>If you click on this button, a clone (copy) will be made of the geometry as it currently is; then, a new object will be created with a different material, and finally, the object will be added to the scene. The code for this is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const cloneGeometry = (scene) =&gt; {
  const clonedGeometry = bufferGeometry.clone();
  const backingArray = clonedGeometry.getAttribute
    ("position").array;
  // change the position of the x vertices so it is placed
  // next to the original object
  for (const i in backingArray) {
    if ((i + 1) % 3 === 0) {
      backingArray[i] = backingArray[i] + 3;
    }
  }
  clonedGeometry.getAttribute("position").needsUpdate =
    true;
  const cloned = meshFromGeometry(clonedGeometry);
  cloned.name = "clonedGeometry";
  const p = scene.getObjectByName("clonedGeometry");
  if (p) scene.remove(p);
  scene.add(cloned);
};</pre>
			<p>As you can see in the <a id="_idIndexMarker132"/>preceding code, we use the <strong class="source-inline">clone()</strong> function to clone <strong class="source-inline">bufferGeometry</strong>. Once cloned, we make sure to update the <strong class="source-inline">x</strong> value of each vertex so the clone is put in a different position than the original one (we could also have used <strong class="source-inline">translateX</strong>, which we explain in the following section of this chapter). Next, we create a <strong class="source-inline">THREE.Mesh</strong>, remove the cloned mesh if it is there, and add the new clone. To create the new mesh, we use a custom function called <strong class="source-inline">meshFromGeometry</strong>. As a quick sidestep, let’s look at how that is implemented <span class="No-Break">as well:</span></p>
			<pre class="source-code">
const meshFromGeometry = (geometry) =&gt; {
  var materials = [
    new THREE.MeshBasicMaterial({ color: 0xff0000,
      wireframe: true }),
    new THREE.MeshLambertMaterial({
      opacity: 0.1,
      color: 0xff0044,
      transparent: true,
    }),
  ];
  var mesh = createMultiMaterialObject(geometry, materials);
  mesh.name = "customGeometry";
  mesh.children.forEach(function (e) {
    e.castShadow = true;
  });
  return mesh;
};</pre>
			<p>If you look back<a id="_idIndexMarker133"/> at this example, you can see a transparent cube and the lines (the edges) that make up our geometry. To do this, we create a multi-material mesh. This means that we tell Three.js to use two different materials in a single mesh. For this, Three.js provides a nice helper function called <strong class="source-inline">createMultiMaterialObject</strong>, which does what the name implies. Based on a geometry and a list of materials, it creates an object that we can add to the scene. There is one thing you need to know though when working with the results from a <strong class="source-inline">createMultiMaterialObject</strong> call. What you get back isn’t a single mesh; it is a <strong class="source-inline">THREE.Group</strong>, a container object that, in this case, contains a separate <strong class="source-inline">THREE.Mesh</strong> for each of the materials we provide. So, when rendering the mesh, it looks like a single object, but it actually comprises multiple <strong class="source-inline">THREE.Mesh</strong> objects rendered on top of one another. This also means that if we want to have shadows, we need to enable this for each of the meshes inside the group (which is what we did in the preceding <span class="No-Break">code fragment).</span></p>
			<p>In the preceding code, we used <strong class="source-inline">createMultiMaterialObject</strong> from the <strong class="source-inline">THREE.SceneUtils</strong> object to add a wireframe to the geometry we created. Three.js also provides an alternative way of adding a wireframe using <strong class="source-inline">THREE.WireframeGeometry</strong>. Assuming you have a geometry called <strong class="source-inline">geom</strong>, you can create a wireframe geometry from that: <strong class="source-inline">const wireframe = new THREE.WireframeGeometry(geom);</strong>. Next, you can draw the lines of this geometry, using the <strong class="source-inline">Three.LineSegments</strong> object, by first creating a <strong class="source-inline">const line = new THREE.LineSegments(wireframe)</strong> object, and then adding it to the scene: <strong class="source-inline">scene.add(line)</strong>. Since this helper internally is just a <strong class="source-inline">THREE.Line</strong> object, you can style how the wireframe appears. For instance, to set the width of the wireframe lines, use <strong class="source-inline">line.material.linewidth = </strong><span class="No-Break"><strong class="source-inline">2;</strong></span><span class="No-Break">.</span></p>
			<p>We’ve already<a id="_idIndexMarker134"/> looked a bit at the <strong class="source-inline">THREE.Mesh</strong> object. In the next section, we’ll dive a bit deeper into what you can do <span class="No-Break">with it.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Functions and attributes for meshes</h2>
			<p>We’ve already <a id="_idIndexMarker135"/>learned that <a id="_idIndexMarker136"/>to create a mesh, we need a geometry and one or more materials. Once we have a mesh, we add it to the scene and it’s rendered. There are a couple of properties you can use to change where and how this mesh appears on the scene. In our first example, we’ll look at the following set of properties <span class="No-Break">and functions:</span></p>
			<ul>
				<li><strong class="source-inline">position</strong>: This determines the position of the object relative to the position of its parent. Most often, the parent of an object is a <strong class="source-inline">THREE.Scene</strong> object or a <span class="No-Break"><strong class="source-inline">THREE.Group</strong></span><span class="No-Break"> object.</span></li>
				<li><strong class="source-inline">rotation</strong>: With this property, you can set the rotation of an object around any of its own axes. Three.js also provides specific functions for rotations around a single axis: <strong class="source-inline">rotateX()</strong>, <strong class="source-inline">rotateY()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">rotateZ()</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">scale</strong>: This property allows you to scale the object around its <strong class="source-inline">x-</strong>, <strong class="source-inline">y-</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">z-a</strong></span><span class="No-Break">xes.</span></li>
				<li><strong class="source-inline">translateX()</strong> / <strong class="source-inline">translateY()</strong> and <strong class="source-inline">translateZ()</strong>: This property moves the object by a specified amount along the <span class="No-Break">corresponding axis.</span></li>
				<li><strong class="source-inline">lookAt()</strong>: This property points the object to a specific vector in space. This is an alternative to setting the <span class="No-Break">rotation manually.</span></li>
				<li><strong class="source-inline">visible</strong>: This property determines whether this mesh should be rendered <span class="No-Break">or not.</span></li>
				<li><strong class="source-inline">castShadow</strong>: This property determines whether this mesh casts shadows when it is hit by light. By default, meshes don’t <span class="No-Break">cast shadows.</span></li>
			</ul>
			<p>When we’re rotating an object, we’re rotating around an axis. In a 3D scene, there are multiple spaces that have an axis you can rotate around. The <strong class="source-inline">rotateN()</strong> functions rotate the object around the axis in <em class="italic">local</em> space. This means the object rotates around the axis of its parent. So, when you add an object to the scene, the <strong class="source-inline">rotateN()</strong>  functions will <a id="_idIndexMarker137"/>rotate<a id="_idIndexMarker138"/> that object around the main axis of the scene. When it is part of a nested group, these functions will rotate the object around the axis of its parent, which is normally the behavior you’re looking for. Three.js also has a specific <strong class="source-inline">rotateOnWorldAxis</strong>, which allows you to rotate an object around the axis of the main <strong class="source-inline">THREE.Scene</strong> regardless of the actual parent of the object. Finally, you can also force the object to rotate around its own axis (this is called <em class="italic">object</em> space) by calling the <span class="No-Break"><strong class="source-inline">rotateOnAxis</strong></span><span class="No-Break"> function.</span></p>
			<p>As always, we have an example ready for you that will allow you to play around with these properties. If you open <strong class="source-inline">chapter-2/mesh-properties</strong> in your browser, you get a drop-down menu where you can alter all these properties and directly see the result, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_2.10_B18726.jpg" alt="Figure 2.10 – Mesh properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Mesh properties</p>
			<p>Let me walk <a id="_idIndexMarker139"/>you<a id="_idIndexMarker140"/> through the properties; I’ll start with the <span class="No-Break"><strong class="source-inline">position</strong></span><span class="No-Break"> property.</span></p>
			<h3>Setting the location of the mesh with the position property</h3>
			<p>We’ve already <a id="_idIndexMarker141"/>seen this property <a id="_idIndexMarker142"/>a couple of times, so let’s quickly address it. With this property, you set the <strong class="source-inline">x-</strong>, <strong class="source-inline">y-</strong>, and <strong class="source-inline">z-c</strong>oordinates of the object relative to its parent. We’ll get back to this in <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Learning to Work with Geometries</em>, when we look at grouping objects. We can set an object’s position property in three different ways. We can set each <span class="No-Break">coordinate directly:</span></p>
			<pre class="source-code">
cube.position.x = 10;
cube.position.y = 3;
cube.position.z = 1;</pre>
			<p>However, we can also set all of them at once, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
cube.position.set(10,3,1);</pre>
			<p>There is also a third option. The <strong class="source-inline">position</strong> property is a <strong class="source-inline">THREE.Vector3</strong> object. That means we can also do the following to set <span class="No-Break">this object:</span></p>
			<pre class="source-code">
cube.position = new THREE.Vector3(10,3,1)</pre>
			<p>Next on the list is the <strong class="source-inline">rotation</strong> property. You’ve already seen this property being used a couple of <a id="_idIndexMarker143"/>times here<a id="_idIndexMarker144"/> and in <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene </em><span class="No-Break"><em class="italic">with Three.js</em></span><span class="No-Break">.</span></p>
			<h3>Defining the rotation of the mesh with the rotation property</h3>
			<p>With this <a id="_idIndexMarker145"/>property, you set the<a id="_idIndexMarker146"/> rotation of the object around one of its axes. You can set this value in the same manner as we did the position. A complete rotation, as you might remember from math class, is <strong class="source-inline">2π</strong>. You can configure this in Three.js in a couple of <span class="No-Break">different ways:</span></p>
			<pre class="source-code">
cube.rotation.x = 0.5*Math.PI;
cube.rotation.set(0.5*Math.PI, 0, 0);
cube.rotation = new THREE.Vector3(0.5*Math.PI,0,0);</pre>
			<p>If you want to use degrees (from 0 to 360) instead, we’ll have to convert those to radians. This can be easily done <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const degrees = 45;
const inRadians = degrees * (Math.PI / 180);</pre>
			<p>In the preceding code block, we’ve done the conversion ourselves. Three.js also provides the <strong class="source-inline">MathUtils</strong> class, which provides a lot of helpful conversions, including one that does the same thing as we did in the preceding code block. You can play around with this property using the <span class="No-Break"><strong class="source-inline">chapter-2/mesh-properties</strong></span><span class="No-Break"> example.</span></p>
			<p>The next property on our list is one we haven’t talked about: <strong class="source-inline">scale</strong>. The name pretty much sums up what you can do with this property. You can scale the object along a specific axis. If you set the scale to a value less than one, the object will shrink, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_2.11_B18726.jpg" alt="Figure 2.11 – Use scale to shrink a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Use scale to shrink a mesh</p>
			<p>When you use<a id="_idIndexMarker147"/> values greater<a id="_idIndexMarker148"/> than one, the object will become larger, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_2.12_B18726.jpg" alt="Figure 2.12 – Use scale to grow a mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Use scale to grow a mesh</p>
			<p>The<a id="_idIndexMarker149"/> next part<a id="_idIndexMarker150"/> of the mesh that we’ll look at is the <span class="No-Break"><strong class="source-inline">translate</strong></span><span class="No-Break"> property.</span></p>
			<h3>Changing the position using the translate property</h3>
			<p>With <strong class="source-inline">translate</strong>, you<a id="_idIndexMarker151"/> can also<a id="_idIndexMarker152"/> change the position of an object, but instead of defining the absolute position where you want the object to be, you define the distance the object should move, relative to its current position. For instance, we have a sphere that is added to a scene, and its position has been set to <strong class="source-inline">(1, 2, 3)</strong>. Next, we translate the object along its <strong class="source-inline">x-a</strong>xis: <strong class="source-inline">translateX(4)</strong>. Its position will now be <strong class="source-inline">(5, 2, 3)</strong>. If we want to restore the object to its original position, we use <strong class="source-inline">translateX(-4)</strong>. In the <strong class="source-inline">chapter-2/mesh-properties</strong> example, there is a menu tab called <strong class="bold">translate</strong>. From there, you can experiment with this functionality. Just set the <strong class="source-inline">translate</strong> values for <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">z</strong> and hit the <strong class="bold">translate</strong> button. You’ll see the object being moved to a new position based on these <span class="No-Break">three values.</span></p>
			<p>The last two properties we’ll look at are used to remove the object completely, by setting the <strong class="source-inline">visible</strong> property to <strong class="source-inline">false</strong>, and disabling whether this object casts shadows by setting the <strong class="source-inline">castShadow</strong> property to <strong class="source-inline">false</strong>. When you click on these buttons, you’ll see the cube becomes invisible and visible, and you can disable it from <span class="No-Break">casting shadows.</span></p>
			<p>For more information on meshes, geometries, and what you can do with these objects, check out <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Learning to Work with Geometries</em>, and <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Points </em><span class="No-Break"><em class="italic">and Sprites</em></span><span class="No-Break">.</span></p>
			<p>So far, we’ve looked at <strong class="source-inline">THREE.Scene</strong>, the main object that holds all the objects that we want to render, and we’ve looked in detail at what a <strong class="source-inline">THREE.Mesh</strong> is, and how you can create a <strong class="source-inline">THREE.Mesh</strong> and position it in a scene. In previous sections, we’ve already used a camera to determine what part of <strong class="source-inline">THREE.Scene</strong> you wanted to render but haven't <a id="_idIndexMarker153"/>explained in detail yet how<a id="_idIndexMarker154"/> you can configure a camera. In the next section, we’ll dive into <span class="No-Break">those details.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Using different cameras for different scenes</h1>
			<p>There are two <a id="_idIndexMarker155"/>different camera types in Three.js: the orthographic camera and the perspective camera. Note that Three.js also provides a couple of very specific cameras for creating scenes that can be viewed using 3D glasses or VR gear. We won’t go into detail about those cameras in this book, since they work exactly the same as the cameras explained in this chapter. If you’re interested in these <a id="_idIndexMarker156"/>cameras, Three.js <a id="_idIndexMarker157"/>provides a few <a id="_idIndexMarker158"/><span class="No-Break">standard examples:</span></p>
			<ul>
				<li><strong class="bold">Anaglyph </strong><span class="No-Break"><strong class="bold">effect</strong></span><span class="No-Break">: </span><a href="https://threejs.org/examples/#webgl_effects_anaglyph&#13;"><span class="No-Break">https://threejs.org/examples/#webgl_effects_anaglyph</span></a></li>
				<li><strong class="bold">Parallax </strong><span class="No-Break"><strong class="bold">barrier</strong></span><span class="No-Break">: </span><a href="https://threejs.org/examples/#webgl_effects_parallaxbarrier&#13;"><span class="No-Break">https://threejs.org/examples/#webgl_effects_parallaxbarrier</span></a></li>
				<li><strong class="bold">Stereo </strong><span class="No-Break"><strong class="bold">effect</strong></span><span class="No-Break">: </span><a href="https://threejs.org/examples/#webgl_effects_stereo&#13;"><span class="No-Break">https://threejs.org/examples/#webgl_effects_stereo</span></a></li>
			</ul>
			<p>If you’re looking for simple VR cameras, you can use <strong class="source-inline">THREE.StereoCamera</strong> to create 3D scenes that are rendered side to side (standard stereo effect), use a parallel barrier (as 3DS provides), or provide an anaglyph effect where the different views are rendered in different colors. Alternatively, Three.js has some experimental support for the WebVR standard, which is supported by a number of browsers (for more info, see <a href="https://webvr.info/developers/">https://webvr.info/developers/</a>). To use this, not that much needs to change. You just set <strong class="source-inline">renderer.vr.enabled = true</strong>, and Three.js will handle the rest. The Three.js website has a couple of examples where this property and some other features of Three.js's support for WebVR are <span class="No-Break">demonstrated: </span><a href="https://threejs.org/examples/"><span class="No-Break">https://threejs.org/examples/</span></a><span class="No-Break">.</span></p>
			<p>For now, we’ll<a id="_idIndexMarker159"/> focus on the standard perspective and orthographic cameras. The best way to explain the differences between these cameras is by looking at a couple <span class="No-Break">of examples.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>An orthographic camera versus a perspective camera</h2>
			<p>In the examples<a id="_idIndexMarker160"/> for this chapter, you can<a id="_idIndexMarker161"/> find a demo called <strong class="source-inline">chapter2/cameras</strong>. When you open this example, you’ll see something like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_2.13_B18726.jpg" alt="Figure 2.13 – Perspective camera view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Perspective camera view</p>
			<p>This preceding screenshot is called a perspective view and is the most natural view. As you can see from this figure, the farther away the cubes are from the camera, the smaller they are rendered. If we change the camera to the other type supported by Three.js, the orthographic camera, you’ll see the following view of the <span class="No-Break">same scene:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_2.14_B18726.jpg" alt="Figure 2.14 – Orthographic camera view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Orthographic camera view</p>
			<p>With<a id="_idIndexMarker162"/> the<a id="_idIndexMarker163"/> orthographic camera, all the cubes are rendered the same size; the distance between an object and the camera doesn’t matter. This is often used in 2D games, such as old versions of <em class="italic">Civilization</em> and <span class="No-Break"><em class="italic">SimCity 4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_2.15_B18726.jpg" alt="Figure 2.15 – Orthographic usage in Si﻿mCity 4"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Orthographic usage in SimCity 4</p>
			<h3>Perspective camera properties</h3>
			<p>Let’s first look a<a id="_idIndexMarker164"/> bit closer at <strong class="source-inline">THREE.PerspectiveCamera</strong>. In the example, you can set a number of properties that define what is shown through the lens of <span class="No-Break">the camera:</span></p>
			<ul>
				<li><strong class="source-inline">fov</strong>: The <strong class="bold">Field of View</strong> (<strong class="bold">FOV</strong>) is the<a id="_idIndexMarker165"/> part of the scene that can be seen from the position of the camera. Humans, for instance, have an almost 180-degree FOV, while some birds even have a complete 360-degree FOV. But since a normal computer screen doesn’t completely fill our vision, a smaller value is often chosen. Generally, for games, a FOV of between 60 and 90 degrees is chosen. <em class="italic">Good </em><span class="No-Break"><em class="italic">default</em></span><span class="No-Break">: 50</span></li>
				<li><strong class="source-inline">aspect</strong>: This is the aspect ratio between the horizontal and vertical sizes of the area where we’re rendering the output. In our case, since we use the entire window, we just use that ratio. The aspect ratio determines the difference between the horizontal FOV and the vertical FOV. <em class="italic">Good default</em>: <strong class="source-inline">window.innerWidth / </strong><span class="No-Break"><strong class="source-inline">window.innerHeight</strong></span></li>
				<li><strong class="source-inline">near</strong>: The <strong class="source-inline">near</strong> property defines how close to the camera Three.js should render the scene. Normally, we set this to a very small value to directly render everything from the position of the camera. <em class="italic">Good </em><span class="No-Break"><em class="italic">default</em></span><span class="No-Break">: 0.1</span></li>
				<li><strong class="source-inline">far</strong>: The <strong class="source-inline">far</strong> property defines how far the camera can see from the position of the camera. If we set this too low, part of our scene might not be rendered, and if we set it too high, in some cases, it might affect the rendering performance. <em class="italic">Good </em><span class="No-Break"><em class="italic">default</em></span><span class="No-Break">: 100</span></li>
				<li><strong class="source-inline">zoom</strong>: The <strong class="source-inline">zoom</strong> property allows you to zoom in and out of the scene. When you use a number lower than 1, you zoom out of the scene, and if you use a number higher than 1, you zoom in. Note that if you specify a negative value, the scene will be rendered upside down. <em class="italic">Good </em><span class="No-Break"><em class="italic">default</em></span><span class="No-Break">: 1</span></li>
			</ul>
			<p>The following <a id="_idIndexMarker166"/>diagram gives a good overview of how these properties work together to determine what <span class="No-Break">you see:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_2.16_B18726.jpg" alt="Figure 2.16 – Properties of the perspective camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Properties of the perspective camera</p>
			<p>The <strong class="source-inline">fov</strong> property of the camera determines the horizontal FOV. Based on the <strong class="source-inline">aspect</strong> property, the vertical FOV is determined. The <strong class="source-inline">near</strong> property is used to determine the position of the near plane, and the <strong class="source-inline">far</strong> property determines the position of the far plane. The area<a id="_idIndexMarker167"/> between the near plane and the far plane will be rendered <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_2.17_B18726.jpg" alt="Figure 2.17 – Far and near clip the rendered mesh"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Far and near clip the rendered mesh</p>
			<h3>Orthographic camera properties</h3>
			<p>To configure<a id="_idIndexMarker168"/> the orthographic camera, we need to use other properties. The orthographic projection isn’t interested in which aspect ratio to use or what FOV we have of the scene, since all the objects are rendered at the same size. When you define an orthographic camera, you define the cuboid area that needs to be rendered. The properties of the orthographic camera reflect this, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">left</strong>: This is described in the Three.js documentation as the camera frustum left plane. You should see this as the left-hand border of what will be rendered. If you set this value to <strong class="source-inline">-100</strong>, you won’t see any objects that are positioned farther than that on the <span class="No-Break">left-hand side.</span></li>
				<li><strong class="source-inline">right</strong>: The <strong class="source-inline">right</strong> property works in a way similar to the <strong class="source-inline">left</strong> property, but this time, on the other side of the screen. Anything farther to the right won’t <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">top</strong>: This is the top position to <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">bottom</strong>: This is the bottom position to <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">near</strong>: From this point, based on the position of the camera, the scene will <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">far</strong>: To this point, based on the position of the camera, the scene will <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">zoom</strong>: This allows you to zoom in and out of the scene. When you use a number lower than <strong class="source-inline">1</strong>, you’ll zoom out of the scene; if you use a number higher than <strong class="source-inline">1</strong>, you’ll zoom in. Note that if you specify a negative value, the scene will be rendered upside down. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>And all these <a id="_idIndexMarker169"/>properties can be summarized in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_2.18_B18726.jpg" alt="Figure 2.18 – Properties of the orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Properties of the orthographic camera</p>
			<p>And just like with the perspective camera, you can exactly define the area of the scene you want <span class="No-Break">to render:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_2.19_B18726.jpg" alt="Figure 2.19 – Clipped area with an orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Clipped area with an orthographic camera</p>
			<p>In the previous section, we explained the different cameras supported by Three.js. You’ve learned how to configure them, and how you can use their properties to render different parts <a id="_idIndexMarker170"/>of the scene. What we didn’t show yet is how you can control what part of the scene a camera is looking at. We’ll explain that in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Looking at specific points</h2>
			<p>So far, you’ve seen how to create a camera and what the various arguments mean. In <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you also saw that you need to position your <a id="_idIndexMarker171"/>camera somewhere in the scene and that the view from that camera is rendered. Normally, the camera is pointed to the center of the scene: position <strong class="source-inline">(0, 0, 0)</strong>. We can, however, easily change what the camera is looking at, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="source-inline">camera.lookAt(new THREE.Vector3(x, y, z));</strong></pre>
			<p>In the <strong class="source-inline">chapter2/cameras</strong> example, you can also specify the coordinates you want the camera to look at. Note that when you change <strong class="source-inline">lookAt</strong> in the <strong class="source-inline">OrthographicCamera</strong> settings, the cubes still stay the <span class="No-Break">same size.</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_2.20_B18726.jpg" alt="Figure 2.20 – Changed lookAt property for the orthographic camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Changed lookAt property for the orthographic camera</p>
			<p>When you use the <strong class="source-inline">lookAt</strong> function, you point the camera at a specific position. You can also use this to make the camera follow an object around a scene. Since every <strong class="source-inline">THREE.Mesh</strong> object has a position that is a <strong class="source-inline">THREE.Vector3</strong> object, you can use the <strong class="source-inline">lookAt</strong> function to <a id="_idIndexMarker172"/>point to a specific mesh in the scene. All you need to use is this: <strong class="source-inline">camera.lookAt(mesh.position)</strong>. If you call this in the render loop, you’ll make the camera follow an object as it moves through <span class="No-Break">a scene.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Debugging what a camera looks at</h2>
			<p>When looking at <a id="_idIndexMarker173"/>configuring the camera, having a menu where you can play around with the different settings can help a lot. Sometimes, though, you might want to exactly see the area that will be rendered by the camera. Three.js allows you to do this, by visualizing the frustum of the camera (the area that is shown by the camera). To do this, we simply add an additional camera to the scene and add a camera helper. To see this in action, open the <span class="No-Break"><strong class="source-inline">chapter-2/debug-camera.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_2.21_B18726.jpg" alt="Figure 2.21 – Show the frustum of the camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – Show the frustum of the camera</p>
			<p>In the preceding figure, you <a id="_idIndexMarker174"/>can see the outline of the frustum of a perspective camera. If you change the properties in the menu, you can see that the frustum changes as well. This frustum is visualized by adding <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const helper = new THREE.CameraHelper(camera);
scene.add(helper);
// in the render loop
helper.update();</pre>
			<p>We’ve also added a <strong class="bold">switchCamera</strong> button, which allows you to switch between the external camera looking in at the scene and the main camera in the scene. This provides a great way to get the correct settings for <span class="No-Break">your camera:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_2.22_B18726.jpg" alt="Figure 2.22 – Switch between cameras"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – Switch between cameras</p>
			<p>Switching cameras<a id="_idIndexMarker175"/> is really easy in Three.js. The only thing you need to do is tell Three.js you want to render the scene through a <span class="No-Break">different camera.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Summary</h1>
			<p>We discussed a lot in this second introductory chapter. We showed the functions and properties of <strong class="source-inline">THREE.Scene</strong> and explained how you can use these properties to configure your main scene. We also showed you how to create geometries. You can either create them from scratch using a <strong class="source-inline">THREE.Buffergeometry</strong> object or use any of the built-in geometries Three.js provides. Finally, we showed you how to configure the two main cameras Three.js provides. <strong class="source-inline">THREE.PerspectiveCamera</strong> renders a scene using a real-world perspective, and <strong class="source-inline">THREE.OrthographicCamera</strong> provides the fake 3D effect often seen in games. We’ve also covered how geometries work in Three.js and you can now easily create your own geometries from the standard geometries provided by Three.js or by crafting them <span class="No-Break">by hand.</span></p>
			<p>In the next chapter, we’ll look at the various light sources that are available in Three.js. You’ll learn how the various light sources behave, how to create and configure them, and how they affect <span class="No-Break">different materials.</span></p>
		</div>
	</body></html>