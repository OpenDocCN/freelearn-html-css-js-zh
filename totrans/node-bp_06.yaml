- en: Chapter 6. Using Node.js as a Command-line Tool
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：将 Node.js 用作命令行工具
- en: In the previous chapters, we learned how to use Node.js with client-side frameworks,
    such as AngularJS and Backbone.js. Each time, we ran the backend from the command
    line. Node.js is suitable not only for web applications, but also for developing
    command-line tools. The access to the filesystem, the various built-in modules,
    and the great community makes Node.js an attractive environment for such kind
    of programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用 Node.js 与客户端框架一起使用，例如 AngularJS 和 Backbone.js。每次，我们都从命令行运行后端。Node.js
    不仅适合于 Web 应用程序，也适合于开发命令行工具。对文件系统的访问、各种内置模块以及庞大的社区使 Node.js 成为这类程序的有吸引力的环境。
- en: In this chapter, we will detail the process of developing a command-line tool
    to upload pictures on **Flickr**. By the end of this chapter, we will have created
    a program that finds images in a particular directory and uploads them on Internet
    portals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍开发用于在 **Flickr** 上上传图片的命令行工具的过程。到本章结束时，我们将创建一个程序，该程序可以在特定目录中查找图片并将它们上传到互联网门户。
- en: Exploring the required modules
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索所需的模块
- en: 'We will use several modules to make our life easier, which are listed as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个模块来简化我们的工作，具体如下：
- en: '`fs`: This gives us access to the filesystem, and is a built-in feature of
    the Node.js module.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`: 这为我们提供了对文件系统的访问，并且是 Node.js 模块的一个内置特性。'
- en: '`optimist`: This is a module that parses the parameters passed to our Node.js
    script.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimist`: 这是一个模块，用于解析传递给我们的 Node.js 脚本的参数。'
- en: '`readline`: This allows the reading of a stream (such as `process.stdin`) on
    a line-by-line basis. We will use it for getting input from the user while our
    application is still running. The module is added in Node.js by default.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline`: 这允许按行读取流（例如 `process.stdin`）。我们将在应用程序运行时使用它来获取用户输入。该模块默认添加到 Node.js
    中。'
- en: '`glob`: This module reads a directory and returns all the existing files that
    match a predefined specific pattern.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob`: 这个模块读取一个目录，并返回所有匹配预定义特定模式的现有文件。'
- en: '`open`: At some point, we will need to open a page in the user''s default browser.
    Node.js runs on different operating systems that have different commands to open
    the default browser. This module helps us by providing one API.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`: 在某个时候，我们需要在用户的默认浏览器中打开一个页面。Node.js 在不同的操作系统上运行，这些操作系统有不同的命令来打开默认浏览器。此模块通过提供一个
    API 来帮助我们。'
- en: '`flapi`: This is the Flickr API wrapper used to communicate with Flickr''s
    services.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flapi`: 这是用于与 Flickr 服务通信的 Flickr API 包装器。'
- en: 'Based on the preceding list, we can write and use the following `package`.`json`
    file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的列表，我们可以编写并使用以下 `package`.`json` 文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The entry point of our script is the `index.js` file. Thus, we set it as a value
    of the `main` property. There is another feature which we haven't used so far—the
    `bin` property. This is the key/pair mapping of the binary script names and the
    Node.js script paths. In other words, when our module is published in the Node.js
    package manager's register and later installed, our console will automatically
    have the `flickruploader` command available. During the installation, the `npm`
    command checks whether we have passed something to the `bin` property. If yes,
    then it creates our script's `symlink`. It is also important that we add the `#!/usr/bin/env`
    node at the top of our `index.js` file. This is how the system will know that
    the script should be processed with Node.js. At the end, if we type the command
    and press *Enter*, our script will be run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的入口点是 `index.js` 文件。因此，我们将它设置为 `main` 属性的值。还有一个我们尚未使用的特性——`bin` 属性。这是二进制脚本名称和
    Node.js 脚本路径的键/值映射。换句话说，当我们的模块在 Node.js 包管理器的注册中发布并随后安装时，我们的控制台将自动拥有 `flickruploader`
    命令。在安装过程中，`npm` 命令检查我们是否向 `bin` 属性传递了某些内容。如果是，那么它将创建我们脚本的 `symlink`。在 `index.js`
    文件的顶部添加 `#!/usr/bin/env node` 也是非常重要的。这样系统就会知道脚本应该用 Node.js 处理。最后，如果我们输入命令并按 *Enter*
    键，我们的脚本就会运行。
- en: Planning the application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用程序
- en: 'We can split the command-line tool into two parts: the first one reads a directory
    and returns all the files in it and the second one sends the images to Flickr.
    It''s a good idea to form these two functionalities in different modules. The
    following diagram shows how our project will appear:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将命令行工具分为两部分：第一部分读取一个目录并返回其中的所有文件，第二部分将图片发送到 Flickr。将这两个功能形成不同的模块是个好主意。以下图表显示了我们的项目将如何呈现：
- en: '![Planning the application](img/00011.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![规划应用程序](img/00011.jpeg)'
- en: 'The `images` directory will be used as a test folder, that is, our script will
    do its job in that directory. Of course, we can have another one if we want. The
    two modules mentioned previously are saved in the `lib` directory. So, we should
    first get the files (`Files.js`) and then upload them (`Flickr.js`) to the portal.
    The two operations are asynchronous, so both the modules should accept **callbacks**.
    The following is the content of the `index.js` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`images` 目录将被用作测试文件夹，也就是说，我们的脚本将在该目录中执行其任务。当然，如果我们想的话，可以有一个其他的。之前提到的两个模块保存在
    `lib` 目录中。因此，我们首先需要获取文件 (`Files.js`)，然后将其 (`Flickr.js`) 上传到门户。这两个操作是异步的，所以这两个模块都应该接受
    **回调函数**。以下为 `index.js` 文件的内容：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Files` module will look into the specified folder and scan it for subfolders
    and images. All the files that are pictures are returned as a parameter of the
    passed callback. These pictures are sent to the `Flickr` module. Along with the
    files, we will also pass few settings needed to access Flickr's services. Eventually,
    once everything goes well, we will call `process.exit(1)` to terminate the program
    and return the user to the terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files` 模块将检查指定的文件夹，并扫描其中的子文件夹和图片。所有图片文件都将作为传递的回调函数的参数返回。这些图片将被发送到 `Flickr`
    模块。除了文件外，我们还将传递一些访问 Flickr 服务的必要设置。最终，一旦一切顺利，我们将调用 `process.exit(1)` 来终止程序并将用户返回到终端。'
- en: Obtaining images from a folder
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件夹中获取图片
- en: 'The `Files.js` file starts with the definition of the required modules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files.js` 文件以所需模块的定义开始：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Immediately after, we need to define two variables. The `currentDirectory` variable
    stores the path to the current working directory and `rl` is an instance of the
    `readline` module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们需要定义两个变量。`currentDirectory` 变量存储当前工作目录的路径，而 `rl` 是 `readline` 模块的一个实例。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `createInterface` function accepts an object. The two required fields are
    `input` and `output`. The `input` field will point to the incoming readable stream
    and `output` to the writable stream. In our case, the user will type data directly
    into the terminal/console, so we will pass `process.stdin`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`createInterface` 函数接受一个对象。两个必需的字段是 `input` 和 `output`。`input` 字段将指向传入的可读流，而
    `output` 指向可写流。在我们的例子中，用户将直接在终端/控制台中输入数据，因此我们将传递 `process.stdin`。'
- en: At the beginning of the chapter, we mentioned the `optimist` module. We will
    use it to get the parameter from the command line. In our case, this will be the
    directory used to parse. It's always good to provide an alternative way to apply
    settings, that is, in addition to asking the user, accept a command-line argument.
    Every Node.js script has a global object, `process`, which has the `argv` property.
    This property is an array of arguments passed from the terminal. The `optimist`
    module simplifies the parsing and provides an effective API to access these arguments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到了 `optimist` 模块。我们将使用它从命令行获取参数。在我们的例子中，这将是我们用于解析的目录。总是提供一种替代方法来应用设置是很好的，也就是说，除了询问用户外，还应接受命令行参数。每个
    Node.js 脚本都有一个全局对象 `process`，它有一个 `argv` 属性。这个属性是从终端传递的参数的数组。`optimist` 模块简化了解析并提供了一个有效的
    API 来访问这些参数。
- en: 'Let''s add the following code immediately after the definition of the `rl`
    variable:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `rl` 变量的定义之后立即添加以下代码：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The callback of the question method returns the text typed by the user. All
    we have to do is pass it to the `readDirectory` function, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 询问方法的回调返回用户输入的文本。我们只需将其传递给 `readDirectory` 函数，如下所示：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, we should check whether the path is valid. For this, we will use
    the `fs.existsSync` method. If the directory exists, we get the files that match
    the following pattern:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该检查路径是否有效。为此，我们将使用 `fs.existsSync` 方法。如果目录存在，我们将获取符合以下模式的文件：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means parse the directory and all its subdirectories and search for the
    files ending with `jpg`, `jpeg`, `gif`, or `png`. The `glob` module helps a lot
    in such cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着解析目录及其所有子目录，并搜索以 `jpg`、`jpeg`、`gif` 或 `png` 结尾的文件。在这种情况下，`glob` 模块非常有帮助。
- en: Before sending the files back to `index.js`, we display them and ask the user
    for a confirmation. This is again done with the `readline` module included at
    the beginning. It is important to use `rl.close()`. This method relinquishes the
    control over the input and output streams.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文件发送回 `index.js` 之前，我们需要显示它们并请求用户确认。这同样是通过在开头包含的 `readline` 模块完成的。使用 `rl.close()`
    方法是很重要的。此方法释放了对输入和输出流的控制。
- en: Authorizing the Flickr protocol
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权 Flickr 协议
- en: 'We will use the `flapi` module to communicate with Flickr. It provides access
    to the API methods. Most large-scale companies implement some level of authorization.
    In other words, we can''t just make a request and upload/retrieve data. We need
    to sign in our requests with access tokens or provide credentials during the process.
    Flickr uses **OAuth** (1.0 specification), a type of standard for such operations.
    OAuth is an open standard for authorization and defines a method for clients to
    access server resources. Let''s check the following diagram and see how Flickr''s
    OAuth mechanism works:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`flapi`模块与Flickr进行通信。它提供了访问API方法的功能。大多数大型公司都会实施一定程度的授权。换句话说，我们不能只是发出请求并上传/检索数据。我们需要在请求中签名访问令牌或在过程中提供凭证。Flickr使用**OAuth**（1.0规范），这是一种此类操作的行业标准。OAuth是一个开放标准，用于授权，并定义了客户端访问服务器资源的方法。让我们查看以下图表，看看Flickr的OAuth机制是如何工作的：
- en: '![Authorizing the Flickr protocol](img/00012.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![授权Flickr协议](img/00012.jpeg)'
- en: Almost the entire process is wrapped in the `flapi` module. What we should remember
    here is that we need a **Key** and **Secret** to retrieve an access token. The
    same token will be used later when uploading the images.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎整个流程都被`flapi`模块封装。我们应该记住的是，我们需要一个**密钥**和**密钥**来检索访问令牌。相同的令牌将在上传图片时使用。
- en: Obtaining your application's Key and Secret
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取应用程序的密钥和密钥
- en: To create our own application's *Key* and *Secret*, we must have a valid Flickr
    account first. Next, log in and navigate to [http://www.flickr.com/services/apps/create/apply/](http://www.flickr.com/services/apps/create/apply/).
    On this page, click on **APPLY FOR A NON-COMMERCIAL KEY**, which is the blue button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自己的应用程序的*密钥*和*密钥*，我们首先必须拥有一个有效的Flickr账户。接下来，登录并导航到[http://www.flickr.com/services/apps/create/apply/](http://www.flickr.com/services/apps/create/apply/)。在此页面上，点击**申请非商业密钥**，这是蓝色的按钮。
- en: '![Obtaining your application''s Key and Secret](img/00013.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![获取应用程序的密钥和密钥](img/00013.jpeg)'
- en: 'We are building a non-commercial application; however, if you plan to use the
    key for commercial purposes, go with the second option on the right. After that,
    you will see a form with few fields. Fill them and click on the **SUBMIT** button,
    as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个非商业应用程序；然而，如果您计划将密钥用于商业目的，请选择右侧的第二个选项。之后，您将看到一个带有少量字段的表单。填写它们并点击以下截图所示的**提交**按钮：
- en: '![Obtaining your application''s Key and Secret](img/00014.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![获取应用程序的密钥和密钥](img/00014.jpeg)'
- en: 'The next screen, which will be shown, contains our **Key** and **Secret**.
    It should look like the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示的下一屏包含我们的**密钥**和**密钥**。它应该看起来像以下截图：
- en: '![Obtaining your application''s Key and Secret](img/00015.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![获取应用程序的密钥和密钥](img/00015.jpeg)'
- en: Writing into the Flickr.js module
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Flickr.js模块写入
- en: 'Once we get the **Key** and **Secret** values, we can continue and start writing
    our `lib/Flickr.js` module. Here is the initial code of the file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了**密钥**和**密钥**值，我们就可以继续并开始编写我们的`lib/Flickr.js`模块。以下是该文件的初始代码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The required dependencies are at the beginning of the previous code. We mentioned
    the `open` module; here, `http` is used to run a Node.js HTTP server and `url`
    is used to parse parameters from an incoming request. The module exports a function
    that accepts three arguments. The first one contains the Flickr''s API settings
    such as **Key** and **Secret**. The second argument is an array of the files that
    need to be uploaded. At the end, we accept a `callback` function, which will be
    called once the uploading is complete. We save everything in a few global variables
    and call `createFlapiClient`, which will initialize the `flapi` object. Before
    we see what exactly happens in `createFlapiClient`, let''s edit `index.js` and
    pass the needed options, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的依赖项位于上一段代码的开头。我们提到了`open`模块；在这里，`http`用于运行Node.js HTTP服务器，而`url`用于解析传入请求的参数。该模块导出一个接受三个参数的函数。第一个参数包含Flickr的API设置，如**密钥**和**密钥**。第二个参数是需要上传的文件数组。最后，我们接受一个`callback`函数，该函数将在上传完成后被调用。我们将所有内容保存在几个全局变量中，并调用`createFlapiClient`，这将初始化`flapi`对象。在我们看到`createFlapiClient`中确切发生的事情之前，让我们编辑`index.js`并传递所需选项，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We left `flickrOptions` empty, but now is the time to fill it. Set **Key** as
    the value of `oauth_consumer_key` and **Secret** as the value of `oauth_consumer_secret`.
    The tokens `oauth_token` and `oauth_token_secret` are commented by default, but
    once we perform the initial authorizing, we will set their values. At the end,
    there is also a permissions property, which should be set to `write` because we
    will upload the photos.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`flickrOptions`留空，但现在是我们填充它的时候了。将**密钥**设置为`oauth_consumer_key`的值，将**密钥**设置为`oauth_consumer_secret`的值。默认情况下，令牌`oauth_token`和`oauth_token_secret`被注释掉，但一旦我们执行初始授权，我们将设置它们的值。最后，还有一个权限属性，应该设置为`write`，因为我们将会上传照片。
- en: 'When the right options are configured in `Flickr.js`, we can create our `flapi`
    client and start querying Flickr''s servers, as shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Flickr.js`中配置了正确的选项时，我们可以创建我们的`flapi`客户端并开始查询Flickr的服务器，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We pass the settings, currently `oauth_consumer_key`, `oauth_consumer_secret`,
    and `perms`. Note that `oauth_token` is `undefined` and we need to authorize our
    application. This happens in the browser. The mechanism defined by Flickr requires
    the opening of a specific URL and the passing of a callback address, where the
    user will be redirected to after being granted the permissions. We are developing
    a command-line tool, so we can't really provide that address because our script
    is in the terminal. Therefore, we run our own HTTP server, which will accept requests
    from Flickr. Of course, this server will be available only on our machine and
    during the script execution. But that should be enough because we need it only
    during the first time. If everything goes well, we will get the `oauth_token`
    and `oauth_token_secret` values, as shown in the following code. We will set them
    in `flickrOptions` and the HTTP server will not be run next time. When the server
    is started, we open a new page in the user's default browser, passing the correct
    URL returned by `flapiClient.getUserAuthURL`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递设置，目前是`oauth_consumer_key`、`oauth_consumer_secret`和`perms`。请注意，`oauth_token`是`undefined`，我们需要授权我们的应用程序。这发生在浏览器中。Flickr定义的机制要求打开一个特定的URL并传递一个回调地址，用户在获得权限后将被重定向到该地址。我们正在开发一个命令行工具，所以我们实际上无法提供该地址，因为我们的脚本在终端中。因此，我们运行自己的HTTP服务器，该服务器将接受来自Flickr的请求。当然，这个服务器将只在我们机器上和脚本执行期间可用。但那应该足够了，因为我们只需要在第一次运行时使用它。如果一切顺利，我们将获得`oauth_token`和`oauth_token_secret`值，如下面的代码所示。我们将它们设置在`flickrOptions`中，并且下次不会运行HTTP服务器。当服务器启动时，我们在用户的默认浏览器中打开一个新页面，传递由`flapiClient.getUserAuthURL`返回的正确URL。
- en: 'The code underlying `runServer` is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`runServer`函数背后的代码如下：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The server listens on port 3000, and it has only one handler. The request we
    are waiting for contains the *GET* parameter `oauth_verifier`. We will get access
    to it by using the `url` module and its `parse` method. It's also important that
    we send `true` as the second parameter so that Node.js parses the query string
    of the request. By passing `oauth_verifier` to `flapi`, the client's `getUserAccessToken`
    method, we will get the needed token and secret. There is an `uploadPhotos` function
    called at the end, but we will leave its body empty for now. This will be filled
    in the next section of the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器监听在端口3000上，并且只有一个处理器。我们正在等待的请求包含*GET*参数`oauth_verifier`。我们将通过使用`url`模块及其`parse`方法来获取它。同样重要的是，我们需要将`true`作为第二个参数发送，以便Node.js解析请求的查询字符串。通过将`oauth_verifier`传递给客户端的`getUserAccessToken`方法`flapi`，我们将获取所需的令牌和密钥。在最后，会调用一个名为`uploadPhotos`的函数，但现在我们将保持其主体为空。这将在本章的下一部分中填充。
- en: Running our application tool
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序工具
- en: 'Now, let''s run our tool. Type `node ./index.js` into your terminal and you
    will see what is shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的工具。在您的终端中输入`node ./index.js`，您将看到以下截图所示的内容：
- en: '![Running our application tool](img/00016.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的应用程序工具](img/00016.jpeg)'
- en: 'Our test directory is `images`, so we type this string and click on *Enter*.
    The code in `Files.js` will scan the directory for images and will ask us for
    a confirmation, as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的目录是`images`，所以我们输入这个字符串并点击*Enter*。`Files.js`中的代码将扫描目录中的图片，并要求我们确认，如下面的截图所示：
- en: '![Running our application tool](img/00017.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的应用程序工具](img/00017.jpeg)'
- en: 'Type **y** and press *Enter*. A message will be displayed that the server is
    running and a new page will open in our default browser. It will ask us to grant
    the application permission to perform several actions, as shown in the following
    screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**y**并按*Enter*键。将显示一条消息，表明服务器正在运行，并且在我们的默认浏览器中打开一个新页面。它将要求我们授予应用程序执行几个操作的权限，如下面的截图所示：
- en: '![Running our application tool](img/00018.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的应用程序工具](img/00018.jpeg)'
- en: 'Click on the blue button with text **OK, I''LL AUTHORIZE IT**. There are two
    things happening at the moment. The browser sends a request with the `oauth_verifier`
    parameter to our Node.js server. We use the value, pass it to the `getUserAccessToken`
    method, and fetch the needed `oauth_token` and `oauth_token_secret` values. At
    the same time, the browser gets a response, and we see something similar to the
    following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击带有文本**OK, I'LL AUTHORIZE IT**的蓝色按钮。此时有两个动作正在进行。浏览器发送一个带有`oauth_verifier`参数的请求到我们的Node.js服务器。我们使用该值，将其传递给`getUserAccessToken`方法，并获取所需的`oauth_token`和`oauth_token_secret`值。同时，浏览器收到响应，我们看到如下类似的截图：
- en: '![Running our application tool](img/00019.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的应用程序工具](img/00019.jpeg)'
- en: We will get the information from the second and third lines and put it in the
    `flickrOptions` object, which is initialized in the `index.js` file. By doing
    this, we will avoid the steps performed with the Node.js server next time. The
    script will be able to upload the photos directly without asking for the token
    and secret.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第二行和第三行获取信息，并将其放入在`index.js`文件中初始化的`flickrOptions`对象中。通过这样做，我们将避免下次使用Node.js服务器执行的步骤。脚本将能够直接上传照片，而无需请求令牌和密钥。
- en: Uploading the images
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图片
- en: 'The last function that we will write is the `uploadPhotos` method for the `Flickr.js`
    module. It will use the global `filesToOpen` array and upload the files one by
    one. Since the operation is asynchronous, we will continuously execute the function
    till the array is empty. We can see the code for this as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的最后一个函数是`Flickr.js`模块的`uploadPhotos`方法。它将使用全局`filesToOpen`数组，逐个上传文件。由于操作是异步的，我们将持续执行该函数，直到数组为空。我们可以看到如下代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `done` callback returns the application flow to `index.js`, where the script
    is terminated. The result of the entire process will look like the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`done`回调将应用程序流程返回到`index.js`，在那里脚本终止。整个过程的结果将如下截图所示：'
- en: '![Uploading the images](img/00020.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![上传图片](img/00020.jpeg)'
- en: Summary
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Node.js as a command-line tool. We successfully
    got arguments from the terminal, searched directories for image files, and uploaded
    them to Flickr. Most of the raw operations such as access to the filesystem or
    the Flickr OAuth implementation were delegated to different modules, which we
    added as dependencies to the project. More and more instruments are emerging everyday
    which transform Node.js into an attractive environment to develop not only web-based
    applications, but also command-line scripts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将Node.js用作命令行工具。我们成功从终端获取了参数，搜索目录中的图片文件，并将它们上传到Flickr。大多数原始操作，如文件系统访问或Flickr
    OAuth实现，都委托给了不同的模块，我们将它们作为依赖项添加到项目中。每天都有越来越多的工具出现，使Node.js成为一个吸引人的开发环境，不仅适用于基于Web的应用程序，也适用于命令行脚本。
- en: In the next chapter, we will learn how to use Node.js and Ember.js together.
    We will get a Twitter social feed and display it on the browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将Node.js和Ember.js一起使用。我们将获取Twitter社交动态并将其显示在浏览器上。
