- en: Going Live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to write tests for the Node.js and Vue.js
    components for our application. We learned what technologies we can use for testing
    MEVN applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about what **Continuous Integration** (**CI**)
    is, how it makes our lives easier, and how we can deploy our application in Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is a practice in the software development process where each member of the
    team is makes continuous small changes in the code and integrates them back into
    the original codebase. After each change, the developer pushes it to GitHub and
    the tests run automatically in that change. This helps to check whether there
    are any bugs or issues in the changed code.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where multiple developers are working on the same application.
    Each developer is working on a different feature on separate branches. They all
    build the features and write the test code for the features they build. Everything
    is going well. Then when the features are completed, they try to integrate all
    the features, and all of a sudden everything breaks. The tests also fail and many
    bugs start to creep out.
  prefs: []
  type: TYPE_NORMAL
- en: If the application is small, it wouldn't be a very big deal because the bugs
    could be fixed easily. But if it's a large project, then it would be very hard
    just to figure out what went wrong, let alone fix it all. That is where CI originated.
  prefs: []
  type: TYPE_NORMAL
- en: CI came into practice to mitigate such risks while integrating software. The
    rule for CI is to integrate early and often, which helps to identify the bugs
    and problems early in the process of adding new functionalities to the existing
    codebase. So instead of waiting for the completion of every component, CI encourages
    us to build the codebase and run the test suites on every single change that is
    committed to the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow for CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a diagram that explains how CI works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8af5c4d7-a178-4509-9323-836971059b9f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a real-world scenario, multiple developers work on the same application.
    They work separately on their own machines. When they make changes to the codebase,
    they push it to the repository in the version control system that they are using.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this change triggers the CI process that we have integrated into our application
    to run the test suites automatically and do the quality checks for the code that
    we have changed.
  prefs: []
  type: TYPE_NORMAL
- en: If the test suite passes, then it goes to the further process for testing the
    full application and is handed over to the QAs.
  prefs: []
  type: TYPE_NORMAL
- en: But, if the tests fail, then the developers or the whole team working on that
    application are notified. Then the developer working on that change makes the
    necessary changes to fix the bug, makes a commit, and pushes the fixed code changes
    to the repository. Again, the same process is repeated until the tests pass. Hence,
    if there are any bugs, they are identified early on and fixed early on.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are aware of what CI is and why we should use it, let''s look into
    some of the benefits it gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build and test applications automatically**: While it is expected that a
    developer builds the application and runs the tests before pushing the changed
    code into the repository, sometimes the developer might just forget. In such cases,
    integrating a Continuous Integration process helps make the process automatic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gives the confidence to deploy**: Since CI checks the test suites and we
    can configure it to check the quality of the code in our codebase, we don''t need
    to worry about forgetting to run the tests before pushing the code to GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy configuration**: CI is very easy to configure. We only need to create
    a single file with all the configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error reporting**: This is one of the powerful features of CI. When something
    breaks while building or running the tests, the team gets a notification. It can
    also provide information about who made what changes, which is awesome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know about CI, we need to start using it in our application as well.
    There are several technologies that can be used to follow the CI process for any
    application. There are a lot of tools and each has their own benefits of use;
    the one that we are going to choose for our application is **Travis CI**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Travis CI is a technology used to build a CI server. Travis CI is used heavily
    with GitHub. There are a few other tools as well. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Circle CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphore CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to learn more about each of the options, here is a good read for
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blog.github.com/2017-11-07-github-welcomes-all-ci-tools/.](https://blog.github.com/2017-11-07-github-welcomes-all-ci-tools/)'
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI is used to build for every push that is made to GitHub and it is very
    easy to set up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Travis in the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to the setup part. The first thing to do here is to check out
    the official website for Travis CI at [https://travis-ci.org/](https://travis-ci.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Activating the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to sign up first, which can be done easily using Sign in with GitHub.
    When you are done, you should see the list of your existing repositories. Select
    the application that you want to set up the Travis CI with and you will be able
    to see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30e6d08-74fb-4d0f-a31a-a2383b362d25.png)'
  prefs: []
  type: TYPE_IMG
- en: Specifying the Node.js version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, activate the repository in which you want to add Travis CI. We can see
    the list of our repositories in our profile. Select the application and click
    on the check mark to activate Travis CI in the repository. Now the next part is
    to add the configuration details. The first thing is to specify the `node` version
    that we will be using for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `.travis.yml` file in the application in the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this code block tells that this is a Node.js project and that the version
    of Node.js for this project is `10.0.0`. You have to specify the Node.js that
    is installed in your application. You can check the version with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the same version in the .`travis.yml` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: If the specified version is not a standard or available version of Node.js,
    then an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify the version of Node.js that we want to use to build the
    project in a file called `.nvmrc`. The `travis.yml` file reads the content of
    this file if the version is not specified in the `.travis.yml` file itself.
  prefs: []
  type: TYPE_NORMAL
- en: Building the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now the next part is to tell Travis to run the test suites. This part is specified
    in the `script` key in the `.travis.yml` file. The default build script for a
    Node.js project is `npm test`. But let''s first start with adding a single command
    to run in a single file so that it''s quick. Update the content of the .`travis.yml`
    file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `script` to run the unit tests when any change is made to the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next part is to install the dependencies. By default, no dependencies are
    added by Travis CI. The following command tells Travis CI to download the dependencies
    before building the `script`. It uses `npm` to install the dependencies, so let''s
    add a `script` to install such dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We have successfully configured Travis CI for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s commit and push this file to GitHub. When you do, check the branches
    on `travis.org` to view all the builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95cbafc8-b06a-4641-ad29-a5b134ca4ee3.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the master is the branch where we added the Travis CI build and the build
    is passing. You can view the details for for `master` branch by clicking on the
    build.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a good approach to view the builds, the best approach is to create
    a pull request for each branch and see the build pass or fail in that pull request
    itself. So, let's create a new pull request to see how we can make the best use
    of Travis CI to make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a branch called `setup_travis` (you can name your branch anything,
    but make sure it indicates a particular change so that it''s easier to identify
    what changes that branch can expect) with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's make a simple change to the application so that our pull request contains
    some differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `README.md` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5] bash'
  prefs: []
  type: TYPE_NORMAL
- en: install dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm install
  prefs: []
  type: TYPE_NORMAL
- en: serve with hot reload at localhost:8080
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm run dev
  prefs: []
  type: TYPE_NORMAL
- en: build for production with minification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm run build
  prefs: []
  type: TYPE_NORMAL
- en: build for production and view the bundle analyzer report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm run build --report
  prefs: []
  type: TYPE_NORMAL
- en: run unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm run unit
  prefs: []
  type: TYPE_NORMAL
- en: run e2e tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm run e2e
  prefs: []
  type: TYPE_NORMAL
- en: run all tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm test
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make a `commit` for the changes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, push the changes to GitHub with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we go to our GitHub repository page for this application, we should
    be able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/827bc17c-f9de-44ec-bc0f-75421894291a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Compare & pull request button. Then add the necessary description
    and hit the Create pull request button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86f73e47-7c07-408e-8bbd-fd8d672f0084.png)'
  prefs: []
  type: TYPE_IMG
- en: As soon as you create a pull request, Travis CI will start to build the application,
    and as you go on to add more commits and push changes to, Travis CI will build
    the application for every commit.
  prefs: []
  type: TYPE_NORMAL
- en: While it is a good practice to run the tests before we push any changes to GitHub,
    Travis CI build helps to notify if something breaks by building the application
    for every single commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add settings to notify us via email or any other mechanism when
    the build fails or succeeds as well. By default, Travis CI will notify us via
    email notifications, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e2dc45f-4a5e-4c6a-b9b9-9dddd6e98882.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see here that Travis CI has been successfully integrated and that the
    tests are also passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af4bbac-399e-49cc-9b8f-68fa4117efb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on Details, we can see the detailed log for the build as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d247e17-4aca-4929-8b2e-cfe8a2ce4072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we are confident with the changes, we can merge the pull request to the
    master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec72e221-f298-4441-bcd3-f1f33d39832d.png)'
  prefs: []
  type: TYPE_IMG
- en: Introduction to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last and most important part of developing an application is to deploy it.
    Heroku is a cloud platform as a service. It is a cloud platform where we can host
    our applications. Heroku is an easy and elegant way to deploy and manage our applications.
  prefs: []
  type: TYPE_NORMAL
- en: With Heroku, we can deploy our applications written in Node.js, and many other
    programming languages as well, such as Ruby, Java, and Python. Regardless of the
    programming language, the setup required for the Heroku application is the same
    across all languages.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to deploy our application using Heroku, such as using
    Git, GitHub, Dropbox, or via API. We will be focusing on deploying our application
    with a Heroku client in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Heroku account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with app deployment in Heroku, we first need to create an account.
    You can create yours directly from [https://www.heroku.com/](https://www.heroku.com/).
    If you want to learn more about different types of apps, you can check out the
    official documentation at [https://devcenter.heroku.com/](https://devcenter.heroku.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create your account, you should be able to see your own dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30d6ccf6-84b5-4d3b-b947-787319f4b488.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Node.js app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku provides a lot of options for the application that we will build. It
    supports Node.js, Ruby, Java, PHP, Python, Go, Scala, and Clojure. Let's go ahead
    and choose Node.js from the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation itself will guide you when you follow each step. Let's go
    ahead and deploy our own app in Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and foremost thing to do is to install Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Heroku in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install Heroku in Windows simply by downloading the installer from the
    official page, [https://devcenter.heroku.com/articles/heroku-cli#download-and-install](https://devcenter.heroku.com/articles/heroku-cli#download-and-install),
    and running the installer.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Heroku in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heroku can be installed in Linux with just a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installing Heroku in macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can install Heroku in macOS using `homebrew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether `Heroku` is installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This should print the version of Heroku that we just installed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Heroku is installed, let''s go to `https://dashboard.heroku.com/apps`,
    where we will be creating a Heroku application for our project. Click on the Create
    New App button and enter the application name that you want to provide to your
    application. We will be naming it `movie-rating-app-1` for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4721c0e-7c82-4e5b-83e0-d0cf45af189d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a Heroku application. Now, let''s switch to our application
    in the Terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will prompt you to enter your email and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fee4b358-df38-4a65-a9be-02ff0a82c01b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you have already initialized a Git repository in your application,
    you can skip the `git init` part in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command will link our application to the Heroku application that we just
    created.
  prefs: []
  type: TYPE_NORMAL
- en: The setup part is done. Now, we can go ahead and make some changes in our application.
    Commit to the GitHub repo the way we have been doing so far and push the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the simple command to deploy to the Heroku app is to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things that we need to take care of here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are serving the Vue.js components by converting them to static files
    using the `serve-static` package in `server.js`, we need to update the start script
    in `package.json` to run the `node` server. Let''s update the start  script with
    the following line in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in the `config/Config.js` file we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are specifying the local MongoDB URL that will not work when we host
    our application in Heroku. For this, we can use a tool called **mLab**. mLab is
    a Database as a service tool for MongoDB. mLab allows us to create as many databases
    as we want for a sandbox database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create an account on [https://mlab.com/](https://mlab.com/).
    Once you are logged in, click on the Create new button to create a new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aca147de-3bfd-4f55-8ec2-12b01c69f427.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can choose any cloud provider we want. Choose the plan type as Sandbox and
    click on CONTINUE. Choose any region and then click on CONTINUE and add the database
    name you want for the application. Finally, click on Submit Order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca4e7127-ac66-42e8-86d1-ff23d3a18294.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we click on the database name, we can see the link to the MongoDB URL
    provided by mLab. We also need to create a database user to be able to authenticate
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Users tab, click on Add Database User, provide the username and password,
    and hit Create.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be able to see the MongoDB URL in the database profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d14a44ce-c38e-431b-ab91-86317ebcdf25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s update the MongoDB URL in our `config/Config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to change is the port of the application. The Heroku
    application automatically assigns a port when deploying an application. We should
    only be using port `8081` of the development environment only. So, let''s verify
    that our `server.js` has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s commit and push the changes to the `master` and then deploy again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The application should be successfully deployed to Heroku and we should be
    able to view our application at [https://movie-rating-app-1.herokuapp.com/](https://movie-rating-app-1.herokuapp.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e799d4c-c59c-4581-9810-b444da6c59c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Heroku error logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If something goes wrong when we are deploying in Heroku, we can also look into
    the error logs that Heroku provides with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what CI is and how to use it to make the build automatic
    in the application. We also learned about how to deploy apps using Heroku integration.
    Overall, we learned how to build a full-stack web application using the Vue.js
    and Node.js technologies, we integrated a different authentication mechanism,
    and we also learned how to write tests for the application and make deployments
    for the application. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: This is just the beginning of the journey that you will be taking forward. You
    should now be able to make small-to-large scale applications with all the technologies
    that we have learned about here.
  prefs: []
  type: TYPE_NORMAL
- en: This book has provided you with the skills to build an application using JavaScript
    as the sole programming language using the MEVN stack. This can be a great start
    if you are planning on building your own complete application. I hope you enjoyed
    reading the book and that you continue building awesome applications!
  prefs: []
  type: TYPE_NORMAL
