<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>


</head>
<body>
<div><div><h1 data-number="6">5 Queues and Deques</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="img/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>We have explored the inner workings of <strong>stacks</strong>, a data structure governed by the <em>LIFO</em> (Last in First out) principle. Now, let's turn our attention to <strong>queues</strong>, a similar yet distinct data structure. While stacks prioritize the most recent additions, queues operate on a <em>FIFO</em> (First in First out) basis, prioritizing the earliest entries. We will delve into the mechanics of queues and then explore <strong>deques</strong>, a versatile hybrid data structure that combines elements of both stacks and queues. By the end of this chapter, you will have a solid understanding of these fundamental data structures and their practical applications.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The queue data structure</li>
<li>The deque data structure</li>
<li>Adding elements to a queue and a deque</li>
<li>Removing elements from a queue and a deque</li>
<li>Simulating circular queues with the <em>Hot Potato</em> game</li>
<li>Checking whether a phrase is a palindrome with a deque</li>
<li>Different problems we can resolve using queues and deques</li>
</ul>

<h2 data-number="6.1">The queue data structure</h2>
<p>Queues are all around us in everyday life. Think of the line to buy a movie ticket, the cafeteria queue at lunchtime, or the checkout line at the grocery store. In each of these scenarios, the underlying principle is the same: the first person to join the queue is the first one to be served.</p>
<figure>
<img src="img/file23.png" alt="Figure 5.1: Real life queue example: a group of people standing in line to buy a ticket" width="867" height="509"/><figcaption aria-hidden="true">Figure 5.1: Real life queue example: a group of people standing in line to buy a ticket</figcaption>
</figure>
<p>An extremely popular example in computer science is the printing line. Let's say we need to print five documents. We open each document and click on the <em>Print</em> button. Each document will be sent to the print line. The first document that we asked to be printed is going to be printed first and so on, until all the documents are printed.</p>
<p>In the realm of data structures, a queue is a linear collection of elements that adheres to the <em>First In, First Out</em> (FIFO) principle, often referred to as <em>First Come, First Served</em>. New elements are always added at the rear (end) of the queue, while removal of elements always occurs at the front (beginning).</p>
<p>Let's put these concepts into practice by creating our own Queue class using JavaScript and TypeScript.</p>


<h2 data-number="6.2">Creating the Queue class</h2>
<p>We are going to create our own class to represent a queue. The source code for this chapter is available inside the <code>src/05-queue-deque</code> folder on GitHub. We will start by creating the <code>queue.js</code> file which will contain our class that represents a stack using an array-based approach.</p>
<blockquote>
<p>In this book, we will take an incremental approach to building our understanding of data structures. We will leverage the concepts we mastered in the previous chapter and gradually increase the complexity as we progress (so make sure you do not skip chapters). This approach will allow us to build a solid foundation and tackle more intricate structures with confidence.</p>
</blockquote>
<p>First, we will declare our <code>Queue</code> class:</p>
<div><pre><code>class Queue {
  #items = [];
  // other methods
}</code></pre>
</div>
<p>We need a data structure that will store the elements of the queue. We can use an array to do this as we are already familiar with the array data structure, and we have also learned in the previous chapter that an array-based approach is preferred compared to an object-based approach.</p>
<p>And again, we will prefix the variable <code>items</code> with the hash <code>#</code> prefix to indicate this property is private and can only be referenced inside the <code>Queue</code> class, hence, allowing us to protect the data and follow the FIFO principle when it comes to the insertion and removal of elements.</p>
<p>The following methods will be available in the <code>Queue</code> class:</p>
<ul>
<li><code>enqueue(item)</code>: This method adds a new item at the end of the queue.</li>
<li><code>dequeue()</code>: This method removes the first item from the beginning of the queue. It also returns the removed item.</li>
<li><code>front()</code>: This method returns the first element from the beginning of the queue. The queue is not modified (it does not remove the element; it only returns the element for information purposes). This is like the <code>peek</code> method from the <code>Stack</code> class.</li>
<li><code>isEmpty()</code>: This method returns <code>true</code> if the queue does not contain any elements, and <code>false</code> if the size of the stack is bigger than 0.</li>
<li><code>clear()</code>: This method removes all the elements of the queue.</li>
<li><code>size()</code>: This method returns the number of elements that the queue contains.</li>
</ul>
<p>We will code each method in the following subsections.</p>

<h3 data-number="6.2.1">Enqueueing elements to end of the queue</h3>
<p>The first method that we will implement is the <code>enqueue</code> method. This method is responsible for adding new elements to the queue, with one especially important detail: we can only add new items at the rear of the queue as follows:</p>
<div><pre><code>enqueue(item) {
  this.#items.push(item);
}</code></pre>
</div>
<p>As we are using an array to store the elements of the queue, we can use the <code>push</code> method from the JavaScript <code>Array</code> class that will add a new item to the end of the array. The <code>enqueue</code> method has the same implementation as the <code>push</code> method from the <code>Stack</code> class; from a code standpoint, we are only changing the name of the method.</p>


<h3 data-number="6.2.2">Dequeuing elements from beginning of the queue</h3>
<p>Next, we are going to implement the <code>dequeue</code> method. This method is responsible for removing the items from the queue. As the queue uses the FIFO principle, the item at the beginning of the queue (index 0 of our internal array) is removed. For this reason, we can use the <code>shift</code> method from the JavaScript <code>Array</code> class as follows:</p>
<div><pre><code>dequeue() {
  return this.#items.shift();
}</code></pre>
</div>
<p>The <code>shift</code> method from the <code>Array</code> class removes the first element from an array and returns it. If the array is empty, <code>undefined</code> is returned and the array is not modified. So this works perfectly with the behavior of the queue.</p>
<p>The <code>enqueue</code> method has constant time complexity (<em>O(1)</em>). The <code>dequeue</code> method can have linear time complexity (<em>O(n)</em>), since we are using the <code>shift</code> method to remove the first element of an array, it can lead to <em>O(n)</em> performance in the worst case as the remaining elements need to be shifted down.</p>


<h3 data-number="6.2.3">Peeking the element from the front of the queue</h3>
<p>Next, we will implement additional helper methods in our class. If we would like to know what the front element of the queue is, we can use the <code>front</code> method. This method will return the item that is located at the index 0 of our internal array:</p>
<div><pre><code>front() {
  return this.#items[0];
}</code></pre>
</div>


<h3 data-number="6.2.4">Verifying if it is empty, the size and clearing the queue</h3>
<p>The next methods we will create are the <code>isEmpty</code> method, <code>size</code> getter, and the <code>clear</code> method. These three methods have the exact same implementation as the <code>Stack</code> class:</p>
<div><pre><code>  isEmpty() {
    return this.#items.length === 0;
  }
  get size() {
    return this.#items.length;
  }
  clear() {
    this.#items = [];
  }</code></pre>
</div>
<p>Using the <code>isEmpty</code> method, we can simply verify whether the length of the internal array is 0.</p>
<p>For the size, we create a getter for the <code>size</code> of the queue, which is simply the length of the internal array.</p>
<p>And for the <code>clear</code> method, we can simply assign a new empty array that will represent an empty queue.</p>
<p>Finally, we have the <code>toString</code> method, with the same code as the <code>Stack</code> class as follows:</p>
<div><pre><code>toString() {
  if (this.isEmpty()) {
    return 'Empty Queue';
  } else {
    return this.#items.map(item =&gt; {
      if (typeof item === 'object' &amp;&amp; item !== null) {
        return JSON.stringify(item);
      } else {
        return item.toString();
      }
    }).join(', ');
  }
}</code></pre>
</div>


<h3 data-number="6.2.5">Exporting the Queue data structure as a library class</h3>
<p>We have created a file src/05-queue-deque/queue.js with our <code>Queue</code> class. And we would like to use the <code>Queue</code> class in a different file for testing for easy maintainability of our code (<code>src/05-queue-deque/01-using-queue-class.js</code>). How can we achieve this?</p>
<p>We covered this in the previous chapter as well. We will use the <code>module.exports</code> from <code>CommonJS</code> Module to expose our class:</p>
<div><pre><code>// queue.js
class Queue {
  // our Queue class implementation
}
module.exports = Queue;</code></pre>
</div>


<h3 data-number="6.2.6">Using the Queue class</h3>
<p>Now it is time to test and use our <code>Queue</code> class! As discussed in the previous subsection, let's go ahead and create a separate file so we can write as many tests as we like: <code>src/05-queue-deque/01-using-queue-class.js</code>.</p>
<p>The first thing we need to do is to import the code from the <code>queue.js</code> file and instantiate the <code>Queue</code> class we just created:</p>
<div><pre><code>const Queue = require('./queue');
const queue = new Queue();</code></pre>
</div>
<p>Next, we can verify whether it is empty (the output is<code> true</code>, because we have not added any elements to our queue yet):</p>
<div><pre><code>    console.log(queue.isEmpty()); // true</code></pre>
</div>
<p>Next, let's simulate a printer's queue. Suppose we have three documents open in a computer. And we click on the print button in each document. By doing so, it will enqueue the documents to the queue in the order the print button was clicked:</p>
<div><pre><code>queue.enqueue({ document: 'Chapter05.docx', pages: 20 });
queue.enqueue({ document: 'JavaScript.pdf', pages: 60 });
queue.enqueue({ document: 'TypeScript.pdf', pages: 80 });</code></pre>
</div>
<p>If we call the <code>front</code> method, it is going to return the file <code>Chapter05.docx</code>, because it was the first document that was added to the queue to be printed:</p>
<div><pre><code>console.log(queue.front()); // { document: 'Chapter05.docx', pages: 20 }</code></pre>
</div>
<p>Let's also check the queue size:</p>
<div><pre><code>    console.log(queue.size); // 3</code></pre>
</div>
<p>Now let's "print" all documents in the queue by dequeuing them until the queue is empty:</p>
<div><pre><code>// print all documents
while (!queue.isEmpty()) {
  console.log(queue.dequeue());
}</code></pre>
</div>
<p>The following diagram shows the dequeue operation when printing the first document from the queue:</p>
<figure>
<img src="img/file24.png" alt="Figure 5.2: Simulation of a printer queue" width="1209" height="253"/><figcaption aria-hidden="true">Figure 5.2: Simulation of a printer queue</figcaption>
</figure>


<h3 data-number="6.2.7">Reviewing the efficiency of our Queue class</h3>
<p>Let's review the efficiency of each method of our queue class by considering the Big O notation in terms of time of execution:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Complexity</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr class="even">
<td><code>enqueue</code></td>
<td><em>O(1)</em></td>
<td>Adding an element to the end of an array is usually a constant-time operation.</td>
</tr>
<tr class="odd">
<td><code>dequeue</code></td>
<td><em>O(n)</em></td>
<td>Removing the first element requires shifting all remaining elements, taking time proportional to the queue's size.</td>
</tr>
<tr class="even">
<td><code>front</code></td>
<td><em>O(1)</em></td>
<td>Directly accessing the first element by index is a constant-time operation.</td>
</tr>
<tr class="odd">
<td><code>isEmpty</code></td>
<td><em>O(1)</em></td>
<td>Checking the length property of an array is a constant-time operation.</td>
</tr>
<tr class="even">
<td><code>size</code></td>
<td><em>O(1)</em></td>
<td>Accessing the length property is a constant-time operation.</td>
</tr>
<tr class="odd">
<td><code>clear</code></td>
<td><em>O(1)</em></td>
<td>Overwriting the internal array with an empty array is considered constant time.</td>
</tr>
<tr class="even">
<td><code>toString</code></td>
<td><em>O(n)</em></td>
<td>Iterating over the elements, potentially stringifying them, and joining them into a string takes time proportional to the number of elements.</td>
</tr>
</tbody>
</table>
Table 5.1:
<p>The <code>dequeue</code> operation is generally the most performance-sensitive operation for a queue implemented using an array. This is due to the need to shift elements after removing the first one. There are alternative queue implementations (for example using a linked list, which we will cover in the next chapter, or a <strong>circular queue</strong>) that can optimize the dequeue operation to have constant time complexity in most cases. We will create a circular queue later in this chapter.</p>



<h2 data-number="6.3">The deque data structure</h2>
<p>The <strong>deque</strong> data structure, also known as the <strong>double</strong>-<strong>ended queue</strong>, is a special queue that allows us to insert and remove elements from the end or from the front of the deque.</p>
<p>A deque can be used to store a user's web browsing history. When a user visits a new page, it is added to the front of the deque. When the user navigates back, the most recent page is removed from the front, and when the user navigates forward, a page is added back to the front.</p>
<p>Another application would be an undo/redo feature. We learned we can use two stacks for this feature in the last chapter, but we can also use a deque as an alternative. User actions are pushed onto the deque, and undo operations pop actions off the front, while redo operations push them back on.</p>


<h2 data-number="6.4">Creating the Deque class</h2>
<p>As usual, we will start by declaring the <code>Deque</code> class located in the file <code>src/05-queue-deque/deque.js</code>:</p>
<div><pre><code>class Deque {
  #items = [];
}</code></pre>
</div>
<p>We will continue using an array-based implementation for our data structure. And given the deque data structure allows inserting and removing from both ends, we will have the following methods:</p>
<ul>
<li><code>addFront(item)</code>: This method adds a new element at the front of the deque.</li>
<li><code>addRear(item)</code>: This method adds a new element at the back of the deque.</li>
<li><code>removeFront()</code>: This method removes the first element from the deque.</li>
<li><code>removeRear()</code>: This method removes the last element from the deque.</li>
<li><code>peekFront()</code>: This method returns the first element from the deque.</li>
<li><code>peekRear()</code>: This method returns the last element from the deque.</li>
</ul>
<blockquote>
<p>The <code>Deque</code> class also implements the <code>isEmpty</code>, <code>clear</code>, <code>size</code>, and <code>toString</code> methods (you can check the complete source code by downloading the source code bundle for this book). The code for these is the same as for the <code>Queue</code> class.</p>
</blockquote>

<h3 data-number="6.4.1">Adding elements to the deque</h3>
<p>Let's check both methods that will allow us to add elements to the front and to the back of the deque:</p>
<div><pre><code>addFront(item) {
  this.#items.unshift(item);
}
addRear(item) {
  this.#items.push(item);
}</code></pre>
</div>
<p>The <code>addFront</code> method inserts an element at index 0 of the internal array by using the <code>Array.unshift</code> method.</p>
<p>The <code>addRear</code> method inserts an element at the end of the deque. It has the same implementation as the <code>enqueue</code> method from the <code>Queue</code> class.</p>


<h3 data-number="6.4.2">Removing elements from the deque</h3>
<p>The methods to remove from both the front and the back of the deque are presented as follows:</p>
<div><pre><code>removeFront() {
  return this.#items.shift();
}
removeRear() {
  return this.#items.pop();
}</code></pre>
</div>
<p>The <code>removeFront</code> method removes and returns the element at the beginning (front) of the deque. If the deque is empty, it returns <code>undefined</code>. It has the same implementation as the <code>dequeue</code> method from the <code>Queue</code> class.</p>
<p>The <code>removeRear</code> method removes and returns the element at the end (rear) of the deque. If the deque is empty, it returns <code>undefined</code>. It has the same implementation as the <code>pop</code> method from the <code>Stack</code> class.</p>


<h3 data-number="6.4.3">Peeking elements of the deque</h3>
<p>Finally, let's check the peek methods as follows:</p>
<div><pre><code>peekFront() {
  return this.#items[0];
}
peekRear() {
  return this.#items[this.#items.length - 1];
}</code></pre>
</div>
<p>The <code>peekFront</code> method allows you to look at (peek) the element at the beginning (front) of the deque without removing it. It has the same implementation as the <code>peek</code> method from the <code>Queue</code> class.</p>
<p>The <code>peekRear</code> method allows you to look at (peek) the element at the end (rear) of the deque without removing it. It has the same implementation as the <code>peek</code> method from the <code>Stack</code> class.</p>
<blockquote>
<p>Note the similarities of the implementation of the deque methods with the Stack and Queue classes. We can say the deque data structure is a hybrid version of the stack and queue data structures. Please refer to the Queue and Stack efficiency review to check the time complexity for these methods.</p>
</blockquote>


<h3 data-number="6.4.4">Using the Deque class</h3>
<p>It is time to test our Deque class (<code>src/05-queue-deque/03-using-deque-class.js</code>). We will use it in the scenario of a browser's "<em>Back</em>" and "<em>Forward</em>" button functionality. Let's see how this could be implemented using our Deque class:</p>
<div><pre><code>const Deque = require('./deque');
class BrowserHistory {
  #history = new Deque(); // {1}
  #currentPage = null; // {2}
  visit(url) {
    this.#history.addFront(url); // {3}
    this.#currentPage = url; // {4}
  }
  goBack() {
    if (this.#history.size() &gt; 1) { // {5}
      this.#history.removeFront();  // {6}
      this.#currentPage = this.#history.peekFront(); // {7}
    }
  }
  goForward() {
    if (this.#currentPage !== this.#history.peekBack()) { // {8}
      this.#history.addFront(this.#currentPage);  // {9}
      this.#currentPage = this.#history.removeFront(); // {10}
    }
  }
  get currentPage() { // returns the current page for information
    return this.#currentPage;
  }
}</code></pre>
</div>
<p>Following is the explanation:</p>
<ul>
<li>A <code>Deque</code> named <code>history</code> is created to store URLs of visited pages (<code>{1}</code>). The <code>currentPage</code> variable keeps track of the currently displayed page (<code>{2}</code>).</li>
<li>The <code>visit(url)</code> method adds the new <code>url</code> to the front of the <code>history</code> deque (<code>{3}</code>) and updates the <code>currentPage</code> to the new URL (<code>{4}</code>).</li>
<li>The <code>goBack()</code> method:
<ul>
<li>Checks if there are at least two pages in the <code>history</code> (current and previous - <code>{5}</code>).</li>
<li>If so, it removes the current page from the front of the history deque (<code>{6}</code>).</li>
<li>Updates <code>currentPage</code> to the now-front element, which represents the previous page (<code>{7}</code>).</li>
</ul></li>
<li>The <code>goForward()</code> method:
<ul>
<li>Checks if the <code>currentPage</code> is different from the last element in the history deque (meaning there is a "next" page - <code>{8}</code>).</li>
<li>If so, adds the current page back to the front of the history deque (<code>{9}</code>).</li>
<li>Removes and sets <code>currentPage</code> to the now-front element, which was the "next" page (<code>{10}</code>).</li>
</ul></li>
</ul>
<p>With our browser simulation ready, we can use it:</p>
<div><pre><code>const browser = new BrowserHistory();
browser.visit('loiane.com');
browser.visit('https://loiane.com/about'); // click on About menu
browser.goBack();
console.log(browser.currentPage); // loiane.com
browser.goForward();
console.log(browser.currentPage); // https://loiane.com/about</code></pre>
</div>
<p>We will simulate visiting the website <a href="https://loiane.com">https://loiane.com</a>, which is the author's blog. Next, we will visit the About page so we can add another URL to the browser's history. Then, we can click on the "Back" button to go back to the home page. And we can also click on the "Next" button to go back the About page. And of course, we can peek what is the current page or the history as well. The following image exemplifies this simulation:</p>
<figure>
<img src="img/file25.png" alt="Figure 5.3: Simulation of a browser Back and Next buttons" width="1208" height="676"/><figcaption aria-hidden="true">Figure 5.3: Simulation of a browser Back and Next buttons</figcaption>
</figure>



<h2 data-number="6.5">Creating the Queue and Deque classes in TypeScript</h2>
<p>With the JavaScript implementation done, we can rewrite our Queue and Deque classes using TypeScript:</p>
<div><pre><code>// src/05-queue-deque/queue.ts
class Queue&lt;T&gt; {
  private items: T[] = [];
  enqueue(item: T): void {}
  // all other methods are the same as in JavaScript
}
export default Queue;</code></pre>
</div>
<p>And the <code>Deque</code> class:</p>
<div><pre><code>// src/05-queue-deque/deque.ts
class Deque&lt;T&gt; {
  private items: T[] = [];
  addFront(item: T): void {}
  addRear(item: T): void {}
  // all other methods are the same as in JavaScript
}
export default Deque;</code></pre>
</div>
<p>We will use the generics to make our data structures flexible and have items of only one type. The code inside the methods is the same as the JavaScript implementation.</p>


<h2 data-number="6.6">Solving problems using queues and deques</h2>
<p>Now that we know how to use the <code>Queue</code> and <code>Deque</code> classes, let's use them to solve some computer science problems. In this section, we will cover a simulation of the <em>Hot Potato</em> game with queues and how to check whether a phrase is a <em>palindrome</em> with deques.</p>

<h3 data-number="6.6.1">The circular queue: the Hot Potato game</h3>
<p>The Hot Potato game is a classic children's game where participants form a circle and pass around an object (the "hot potato") as fast as they can while music plays. When the music stops, the person holding the potato is eliminated. The game continues until only one person remains.</p>

<h4 data-number="6.6.1.1">The CircularQueue class</h4>
<p>We can perfectly simulate this game using a <strong>Circular Queue</strong> implementation:</p>
<div><pre><code>class CircularQueue {
  #items = [];
  #capacity = 0; // {1}
  #front = 0; // {2}
  #rear = -1; // {3}
  #size = 0; // {4}
  constructor(capacity) { // {5}
    this.#items = new Array(capacity);
    this.#capacity = capacity;
  }
  get size() { return this.#size; }
}</code></pre>
</div>
<p>A circular queue is a queue implemented using a fixed-size array, meaning a pre-defined capacity (<code>{1}</code>), where the front (<code>{2}</code>) and rear (<code>{3}</code>) pointers can "wrap around" to the beginning of the array when they reach the end. This efficiently reuses the space in the array, avoiding unnecessary resizing. The <code>front</code> pointer is initialized to 0, pointing to the first element's position. The <code>rear</code> pointer is initialized to -1, indicating an empty queue. The <code>size</code> property (<code>{4}</code>) tracks the current number of elements in the queue.</p>
<p>When we create a circular queue, we need to inform how many elements we are planning to store (<code>{5}</code>).</p>
<p>Let's review the <code>enqueue</code> and <code>isFull</code> methods next:</p>
<div><pre><code>enqueue(item) {
  if (this.isFull()) { // {6}
    throw new Error("Queue is full");
  }
  this.#rear = (this.#rear + 1) % this.#capacity; // {7}
  this.#items[this.#rear] = item; // {8}
  this.#size++; // {9}
}
isFull() { return this.#size === this.#capacity; }</code></pre>
</div>
<p>Before we add any elements to queue, we need to check if it is not full, meaning the size is the same as the capacity (<code>{6}</code>). With a fixed capacity, this makes the circular queue predictable in terms of memory usage, but this can also be viewed as a limitation.</p>
<p>If the queue is not full, we increment the <code>rear</code> pointer by 1. The key point here is to use the modulo operator (<code>%</code>) to wrap rear back to 0 if it reaches the end of the array (<code>{7}</code>). Then we insert the item at the new rear position (<code>{8}</code>) and increment the size counter (<code>{9}</code>).</p>
<p>Finally, we have the <code>dequeue</code> and <code>isEmpty</code> methods:</p>
<div><pre><code>dequeue() {
  if (this.isEmpty()) { throw new Error("Queue is empty"); } // {10}
  const item = this.#items[this.#front]; // {11}
  this.#size--; // {12}
  if (this.isEmpty()) {
    this.#front = 0; // {13}
    this.#rear = -1; // {14}
  } else {
    this.#front = (this.#front + 1) % this.#capacity; // {15}
  }
  return item; // {16}
}
isEmpty() { return this.#size === 0;  }</code></pre>
</div>
<p>To remove the item at the front of the queue, first, we need to check the queue size (<code>{10}</code>). If the queue is not empty, we can retrieve the item that is currently stored at the front position (<code>{11}</code>) so we can return it later (<code>{16}</code>). Then, we decrement the size counter (<code>{12}</code>).</p>
<p>If the queue is not empty after dequeuing, we need to increment the <code>front</code> pointer by 1 and wrap around it using the modulo operator (<code>{15}</code>). If the queue is empty after dequeuing, we reset both <code>front</code> (<code>{13}</code>) and <code>rear</code> (<code>{14}</code>) pointers to their initial values.</p>
<p>The biggest advantage of the circular queue is both enqueueing and dequeuing operations are generally <em>O(1)</em> (constant time) due to direct manipulation of pointers.</p>


<h4 data-number="6.6.1.2">The Hot Potato game simulation</h4>
<p>With the new class ready to be used, let's put it in practice the Hot Potato game simulation:</p>
<div><pre><code>function hotPotato(players, numPasses) {
  const queue = new CircularQueue(players.length); // {1}
  for (const player of players) { // {2}
    queue.enqueue(player);
  }
  while (queue.size &gt; 1) { // {3}
    for (let i = 0; i &lt; numPasses; i++) { // {4}
      queue.enqueue(queue.dequeue()); // {5}
    }
    console.log(`${queue.dequeue()} is eliminated!`); // {6}
  }
  return queue.dequeue(); // {7} The winner
}</code></pre>
</div>
<p>This function takes an array of players and a number <code>num</code> representing the number of times the "potato" is passed before a player is eliminated and it returns the winner.</p>
<p>First, we create a circular queue (<code>{1}</code>) with the numbers of players and we enqueue all players (<code>{2}</code>).</p>
<p>We run a loop until only one player remains (<code>{3}</code>):</p>
<ul>
<li>Another loop will pass the potato <code>numPasses</code> times (<code>{4}</code>) by dequeueing and then re-enqueueing the same player (<code>{5}</code>).</li>
<li>The player at the front is removed and announced as eliminated (<code>{6}</code>).</li>
</ul>
<p>The last remaining player is dequeued and declared the winner (<code>{7}</code>).</p>
<p>We can use the following code to try the <code>hotPotato</code> algorithm:</p>
<div><pre><code>const players = ["Violet", "Feyre", "Poppy", "Oraya", "Aelin"];
const winner = hotPotato(players, 7);
console.log(`The winner is: ${winner}!`);</code></pre>
</div>
<p>The execution of the algorithm will have the following output:</p>
<div><pre><code>Poppy is eliminated!
Feyre is eliminated!
Aelin is eliminated!
Oraya is eliminated!
The winner is: Violet!</code></pre>
</div>
<p>This output is simulated in the following diagram:</p>
<figure>
<img src="img/file26.png" alt="Figure 5.4: The Hot Potato game simulation using circular queue" width="1075" height="779"/><figcaption aria-hidden="true">Figure 5.4: The Hot Potato game simulation using circular queue</figcaption>
</figure>
<p>You can change the number of passes using the <code>hotPotato</code> function to simulate different scenarios.</p>



<h3 data-number="6.6.2">Palindrome checker</h3>
<p>The following is the definition of a <strong>palindrome</strong> according to Wikipedia:</p>
<blockquote>
<em>A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward, such as madam or racecar.</em>
</blockquote>
<p>There are different algorithms we can use to verify whether a phrase or string is a palindrome. The easiest way is reversing the string and comparing it with the original string. If both strings are equal, then we have a palindrome. We can also use a stack to do this, but the easiest way of solving this problem using a data structure is using a deque: characters are added to the deque, and then removed from both ends simultaneously. If the removed characters match throughout the process, the string is a palindrome.</p>
<p>The following algorithm uses a deque to solve this problem:</p>
<div><pre><code>const Deque = require('./deque');
function isPalindrome(word) {
  if (word === undefined || word === null ||
     (typeof word === 'string' &amp;&amp; word.length === 0)) { // {1}
    return false;
  }
  const deque = new Deque(); // {2}
  word = word.toLowerCase().replace(/\s/g, ''); // {3}
  for (let i = 0; i &lt; word.length; i++) {
    deque.addRear(word[i]); // {4}
  }
  while (deque.size() &gt; 1) { // {5}
    if (deque.removeFront() !== deque.removeRear()) { // {6}
      return false;
    }
  }
  return true;
}</code></pre>
</div>
<p>Before we start with the algorithm logic, we need to verify whether the string that was passed as a parameter is valid with the edge cases (<code>{1}</code>). If it is not valid, then we return <code>false</code> because an empty string or non-existent word cannot be considered a palindrome.</p>
<p>We will use the Deque class we implemented in this chapter (<code>{2}</code>). As we can receive a string with both lowercase and capital letters, we will transform all letters to lowercase, and we will also remove all the spaces (<code>{3}</code>). If you want to, you can also remove all special characters such as !?-() and so on. To keep this algorithm simple, we will skip this part. Next, we will enqueue all characters of the string to the deque (<code>{4}</code>).</p>
<p>While we have at least two elements in the deque (<code>{5}</code> - if only one character is left, it is a palindrome), we will remove one element from the front and one from the back (<code>{6}</code>). To be a palindrome, both characters removed from the deque need to match. If the characters do not match, then the string is not a palindrome (<code>{7}</code>).</p>
<p>We can use the following code to try the <code>isPalindrome</code> algorithm:</p>
<div><pre><code>console.log(isPalindrome("racecar")); // Output: true</code></pre>
</div>



<h2 data-number="6.7">Exercises</h2>
<p>We will resolve an exercise from <strong>LeetCode</strong> using the concepts we learned in this chapter.</p>

<h3 data-number="6.7.1">Number of Students Unable to Eat Lunch</h3>
<p>The exercise we will resolve is the <em>1700. Number of Students Unable to Eat Lunch</em> problem available at <a href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/">https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>function countStudents(students: number[], sandwiches: number[]): number {}</code>, which receives a queue of <code>students</code> that would prefer to eat a sandwich 0 or 1 and a stack of <code>sandwiches</code>, which will have the same size.</p>
<p>This is a simulation exercise, according to the problem's description:</p>
<ul>
<li>If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.</li>
<li>Otherwise, they will leave it and go to the queue's end.</li>
<li>This continues until none of the queue students want to take the top sandwich and are thus unable to eat.</li>
</ul>
<p>The key to resolve this problem is to also treat the stack of sandwiches as a queue (<em>FIFO</em>) instead of a stack (<em>LIFO</em>).</p>
<p>Let's write the <code>countStudents</code> function:</p>
<div><pre><code>function countStudents(students: number[], sandwiches: number[]) {
    while (students.length &gt; 0) { // {1}
      if (students[0] === sandwiches[0]) { // {2}
          students.shift(); // {3}
          sandwiches.shift(); // {4}
      } else {
          if (students.includes(sandwiches[0])) { // {5}
              let num = students.shift(); // {6}
              students.push(num); // {7}
          } else {
              break; // {8}
          }
      }
  }
  return students.length;
}</code></pre>
</div>
<p>The while loop keeps running as long as there are students in the queue (<code>{1}</code>).</p>
<p>If the first student's preference(<code>students[0]</code>) matches (<code>{2}</code>) the sandwich at the front (top sandwich <code>sandwiches[0]</code>), both the student (<code>{3}</code>) and sandwich (<code>{4}</code>) are removed from the front of their respective queues.</p>
<p>If there is not a match, we check for potential match using the <code>includes</code> method from the JavaScript <code>Array</code> class to see if any student in the queue would take the current top sandwich (<code>{5}</code>). If there is a potential match, the current student (<code>{6}</code>) is moved to the back of the queue (<code>{7}</code>).</p>
<p>If there is no one left in line who wants the current sandwich, the loop breaks (<code>{8}</code>). This indicates that the remaining students will not be able to eat.</p>
<p>The function returns the length of the <code>students</code> array. This length represents the number of students still in line who could not get a sandwich they liked.</p>
<p>This solution passes all the tests and resolves the problem. The <code>includes</code> check (<code>{5}</code>) is important for efficiency. Without it, the code would unnecessarily rotate the queue even when no student would want the top sandwich, so we get bonus points, although this method is not native for a queue data structure.</p>
<p>The time and space complexity of this function is <em>O(nˆ2)</em>, where <em>n</em> is the number of <code>students</code>. This is because the outer loop runs until there are no students left, which in the worst case is <em>n</em> iterations.</p>
<p>Inside the loop, there are two operations that can be costly: <code>students.shift()</code>, which is <em>O(n)</em>, and <code>students.includes(sandwiches[0])</code>, which is also <em>O(n)</em>. Since these operations are nested inside the loop, the total complexity is <em>O(nˆ2)</em>.</p>
<p>The space complexity is <em>O(1)</em>, not counting the space needed for the input arrays. This is because the function only uses a fixed amount of additional space to store the <code>num</code> variable.</p>
<blockquote>
<p>Can you think of a more optimized approach to resolve this problem that might not involve the queue data structure? During technical interviews, it is important to also think about optimizations. Give it a try, and you will find the solution along with the explanation in the source code, along with the <em>2034. Time Needed to Buy Tickets</em> problem resolution as well.</p>
</blockquote>



<h2 data-number="6.8">Summary</h2>
<p>In this chapter, we delved into the fundamental concept of queues and their versatile cousin, the deque. We crafted our own queue algorithm, mastering the art of adding (enqueue) and removing (dequeue) elements in a first-in, first-out (FIFO) manner. Exploring the deque, we discovered its flexibility in inserting and deleting elements from both ends, expanding the possibilities for creative solutions.</p>
<p>To solidify our understanding, we applied the knowledge to real-world scenarios. We simulated the classic Hot Potato game, leveraging a circular queue to model its cyclical nature. Additionally, we created a palindrome checker, demonstrating the deque's power in handling data from both directions. We also tackled a simulation challenge from LeetCode, reinforcing the practical applications of queues in problem-solving.</p>
<p>Now, with a firm grasp of these linear data structures (arrays, stacks, queues and deques), we are ready to venture into the dynamic world of linked lists in the next chapter, where we will unlock even greater potential for complex data manipulation and management.</p>


</div>
</div>
</body>
</html>