<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Learning Service Worker Basics</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up service workers</li><li class="listitem" style="list-style-type: disc">Setting up SSL for Windows</li><li class="listitem" style="list-style-type: disc">Setting up SSL for Mac</li><li class="listitem" style="list-style-type: disc">Setting up GitHub pages for SSL</li><li class="listitem" style="list-style-type: disc">Registering a service worker</li><li class="listitem" style="list-style-type: disc">Registering a service worker in detail</li><li class="listitem" style="list-style-type: disc">Debugging</li><li class="listitem" style="list-style-type: disc">Providing stale version on error</li><li class="listitem" style="list-style-type: disc">Creating mock responses</li><li class="listitem" style="list-style-type: disc">Handling request timeouts</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Introduction</h1></div></div></div><p>If you travel a bit, chances are you have probably found yourself stuck with <strong>zero network connectivity</strong>
<a id="id0" class="indexterm"/> way too often. This is frustrating, especially if you just wanted to continue reading some news articles, blog posts, or you wanted to get some work done.</p><p>Unfortunately, with your browser, attempting to make requests for something from the network while being offline doesn't quite work out so well.</p><div><img src="img/B05381_01_01.jpg" alt="Introduction"/></div><p>Even though on planes, the subway, in hotels, and at conferences, Wi-Fi may provide you with opportunities to restore your connection, in general you will have to wait for the network to return online in order to request the pages you want to view.</p><p>Previous attempts to solve this issue include <code class="literal">AppCache</code>. It seems to work, to some extent, but the issue with <code class="literal">AppCache</code> is that it makes a lot of assumptions about user interactions. When those assumptions are not met, the application will fail to function as expected. It is also designed to work well with single page apps, not the traditional multi-page websites.</p><p>Also, one of the most challenging problems with providing a seamless user experience with web apps is making them functional while offline. This is an important issue to resolve, given that most users today access web apps on the move. Enter service workers, a script running in the background of our browser.</p><p>Being able to use a web app, regardless of the connectivity, means users can operate uninterrupted when they are on board a plane, the subway, or in places where connectivity is limited or not available. This technology will help boost client productivity and will increase the availability of the application.</p><p>With service workers, we are able to pre-cache some assets of a website. What we are referencing as assets are JavaScript files, CSS files, images, and some fonts. This will help us to speed up the loading time, instead of having to fetch information from the web servers every time we visit the same website. And of course, most importantly, those assets will be available for us when we are offline.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Service workers</h2></div></div></div><p>A<a id="id1" class="indexterm"/> service worker is a script that stands between your browser and the network, giving you, among other things, the ability to intercept network requests, and respond to them in different ways.</p><p>In order for your website or app to work, the browser fetches its assets, such as HTML pages, JavaScript, CSS, images, and fonts. In the past, managing these resources was mainly the <a id="id2" class="indexterm"/>browser's responsibility. If the browser couldn't access the network, you would probably see its <strong>Unable to connect to the Internet</strong> message. There were techniques you could use to encourage the local caching of assets, but the browser often had the last say.</p><p>One feature service worker uses heavily is promises. So it is important to have a good understanding of promises.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Promises</h2></div></div></div><p>Promises <a id="id3" class="indexterm"/>are a great mechanism for running async operations with success dependent on one another. This is central to the way service workers work.</p><p>Promises can do a great many things, but for now, all you need to know is that if something returns a promise, you can attach <code class="literal">.then()</code> to the end and include callbacks inside it for success, failure, and so on, or you can insert <code class="literal">.catch()</code>, the end if you want to include a failure callback.</p><p>Let's compare a traditional synchronous callback structure to its asynchronous promise equivalent:</p><p>
<code class="literal">sync</code>
</p><div><pre class="programlisting">try {
  var value = Fn();
  console.log(value);
} catch(err) {
  console.log(err);
}</pre></div><p>
<code class="literal">async</code>
</p><div><pre class="programlisting">Fn().then(function(value) {
  console.log(value);
  }).catch(function(err) {
  console.log(err);
});</pre></div><p>In the <code class="literal">sync</code> example, we have to wait for <code class="literal">Fn()</code> to run and return a <code class="literal">value </code>before any more of the code can execute. In the <code class="literal">async</code> example, <code class="literal">Fn()</code> returns a promise for the value, then the rest of the code can carry on running. When the promise resolves, the code inside <code class="literal">then </code>will be run asynchronously.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Promise.resolve(value)</h3></div></div></div><p>This<a id="id4" class="indexterm"/> method returns an object of <code class="literal">Promise.then</code>, which is resolved with the value passed into the <code class="literal">resolve</code> method, as in <code class="literal">Promise.resolve(value)</code>. If this value has a <code class="literal">then</code> method, the returned method will follow it; otherwise, it will be fulfilled with the value.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Promise.reject(reason)</h3></div></div></div><p>This<a id="id5" class="indexterm"/> method takes <code class="literal">reason</code> as an argument and returns a promise object that is rejected.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up service workers</h1></div></div></div><p>In order to get<a id="id6" class="indexterm"/> service workers running, we need to serve our code via <a id="id7" class="indexterm"/>
<strong>Hyper Text Transfer Protocol Secure</strong> (<strong>HTTPS</strong>). Service workers are designed to run only across HTTPS for security reasons. Source code repositories such as GitHub support HTTPS, where you can host your files.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Getting ready</h2></div></div></div><p>If you are using a newer version of a browser, the chances are that service workers are already enabled on it. But, if that is not the case, we will have to change few things in the browser settings. In the following section, we are going to cover how to enable service worker features in Chrome and Firefox.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How to do it...</h2></div></div></div><p>Follow the steps below to enable service worker in Chrome and Firefox.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Chrome</h3></div></div></div><p>To <a id="id8" class="indexterm"/>experiment<a id="id9" class="indexterm"/> in Chrome, you need to download <a id="id10" class="indexterm"/>Chrome Canary:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="https://www.google.com/chrome/browser/canary.html">https://www.google.com/chrome/browser/canary.html</a> and download the latest version.</li><li class="listitem">Open Chrome Canary and type <code class="literal">chrome://flags</code>.</li><li class="listitem">Turn on <code class="literal">experimental-web-platform-features</code>.</li><li class="listitem">Restart the browser.</li><li class="listitem">The following image shows experimental features on the Chrome browser, where you enable the <strong>Experimental Web Platform</strong> feature by clicking on the <strong>Enable</strong> link underneath:<div><img src="img/B05381_01_02.jpg" alt="Chrome"/></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Firefox</h3></div></div></div><p>To <a id="id11" class="indexterm"/>experiment in Firefox, you need to download<a id="id12" class="indexterm"/> Firefox Nightly:</p><div><ol class="orderedlist arabic"><li class="listitem">Go <a id="id13" class="indexterm"/>to <a class="ulink" href="https://nightly.mozilla.org/">https://nightly.mozilla.org/</a> and download the latest version.</li><li class="listitem">Open Firefox Nightly, and go to <code class="literal">about:config</code>.<div><img src="img/B05381_01_03.jpg" alt="Firefox"/></div></li><li class="listitem">Set <code class="literal">experimental-web-platform-features</code> to <code class="literal">true</code>.</li><li class="listitem">Restart<a id="id14" class="indexterm"/> the browser.</li></ol></div><div><div><h3 class="title"><a id="note01"/>Note</h3><p>At the time of <a id="id15" class="indexterm"/>writing, Opera offers partial support for service workers, including basic support, as well as installing and uninstalling events. Internet Explorer and Safari do not support service workers.</p><p>Service workers are currently an experimental technology, meaning the syntax and the behavior are subject to change in future versions as the specification changes.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up SSL for Windows</h1></div></div></div><p>Service workers <a id="id16" class="indexterm"/>are designed to run only across HTTPS, so in order for us to test our code, we need our web pages to be delivered across HTTPS. In this recipe, we will cover getting your site setup with SSL support for Windows.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Getting ready</h2></div></div></div><p>This recipe assumes you run Windows 7 or higher with <a id="id17" class="indexterm"/>
<strong>Internet Information Service</strong> (<strong>IIS</strong>) enabled.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How to do it...</h2></div></div></div><p>Follow these instructions to enable SSL:</p><div><ol class="orderedlist arabic"><li class="listitem">First, open IIS; you can do this by running the following command inside the command line:<div><pre class="programlisting">
<strong>Inetmgr</strong>
</pre></div></li><li class="listitem">Select the server node in the tree view and double-click the <strong>Server Certificates</strong> feature in the list view, as shown:<div><img src="img/B05381_01_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Click <a id="id18" class="indexterm"/>on the <strong>Create Self-Signed Certificate...</strong> link in the <strong>Actions</strong> pane.<div><img src="img/B05381_01_05.jpg" alt="How to do it..."/></div></li><li class="listitem">Enter <a id="id19" class="indexterm"/>a meaningful name for the new certificate and click <strong>OK</strong>.<div><img src="img/B05381_01_06.jpg" alt="How to do it..."/></div><p>This will generate a self-signed certificate, which is marked for <strong>Server Authentication</strong> use, meaning it uses a server-side certificate for authenticating the identity of the server and also for HTTP SSL encryption.</p><p>In order to create an SSL binding, we have to select a site in the tree view and then, in the <strong>Actions</strong> pane, click <strong>Bindings...</strong>. This will bring up the bindings editor that manages bindings for your website, which include create, edit, and delete. Now, to add your new SSL binding to the site, click <strong>Add...</strong>.</p><div><img src="img/B05381_01_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Port 80 is the default setting for a new binding for HTTP. We can select <strong>https</strong> in the <strong>Type</strong> drop-down list. Select the self-signed certificate we created <a id="id20" class="indexterm"/>in the previous section from the <strong>SSL Certificate</strong> drop-down list, and then click <strong>OK</strong>.<div><img src="img/B05381_01_08.jpg" alt="How to do it..."/></div></li><li class="listitem">Now we have a new SSL binding on our site and all that remains is to make sure that it works.<div><img src="img/B05381_01_09.jpg" alt="How to do it..."/></div></li><li class="listitem">Click <strong>Continue to this website</strong> to<a id="id21" class="indexterm"/> proceed.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up SSL for Mac</h1></div></div></div><p>As mentioned<a id="id22" class="indexterm"/> in the previous recipe, service workers are designed to run only across HTTPS. So, in order for us to test our code, we need our web pages to be delivered across HTTPS. In this recipe, we will cover getting your site set up with SSL support for Mac.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>This recipe assumes that you are running OS X 10.11, El Capitan, or higher. We are going to use a command-line utility called Vim for editing files, which already comes with Mac. Make sure not to use the number pad with Vim. Please be aware that this process is lengthy.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it...</h2></div></div></div><p>Follow these instructions to enable SSL:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to make sure Apache is running (you may get a prompt for a password):<div><pre class="programlisting">
<strong>$ sudo apachectl start</strong>
</pre></div></li><li class="listitem">The<a id="id23" class="indexterm"/> next step is to make some modifications to your <code class="literal">httpd.conf</code>. Because it's a system file, you will need to use <code class="literal">sudo</code> again:<div><pre class="programlisting">
<strong>$ sudo vim /etc/apache2/httpd.conf</strong>
</pre></div></li><li class="listitem">In this file, you should uncomment both <code class="literal">socache_shmcb_module</code> and <code class="literal">ssl_module</code>, and also the include the <code class="literal">httpd-ssl.conf</code> file by removing the leading <code class="literal">#</code> symbol on those lines (you can use <code class="literal">/</code> to search on the Vim editor):<div><pre class="programlisting">LoadModule socache_shmcb_module libexec/apache2/mod_socache_shmcb.so
...
LoadModule ssl_module libexec/apache2/mod_ssl.so
...
Include /private/etc/apache2/extra/httpd-ssl.conf</pre></div></li><li class="listitem">After saving the preceding file (press <code class="literal">:wq</code>), you should then open up your <code class="literal">/etc/apache2/extra/httpd-vhosts.conf</code> file:<div><pre class="programlisting">
<strong>$ sudo vim /etc/apache2/extra/httpd-vhosts.conf</strong>
</pre></div></li><li class="listitem">Here, you can create a VirtualHost entry for each virtual host that you wish to provide SSL support for:<div><pre class="programlisting">&lt;VirtualHost *:80&gt;
       DocumentRoot "/Library/WebServer/Documents"
    ServerName localhost
    SSLEngine on
    SSLCertificateFile "/private/etc/apache2/localhost.crt"
    SSLCertificateKeyFile "/private/etc/apache2/localhost.key"
&lt;/VirtualHost&gt;</pre></div><p>Make sure you copy your development folder to the <code class="literal">DocumentRoot</code> directory as you did earlier: <code class="literal">/Library/WebServer/Documents</code>.</p><p>To get this all to work with Apache, we need to create a self-signed certificate that we have already referenced in the <code class="literal">VirtualHost</code> definition.</p></li><li class="listitem">Generate a key:<div><pre class="programlisting">
<strong>$ cd /etc/apache2</strong>
</pre></div></li><li class="listitem">Press <em>Enter</em> with no input after the following command:<div><pre class="programlisting">
<strong>$ sudo openssl genrsa -out localhost-key.pem 1024</strong>
</pre></div></li><li class="listitem">Next, we have to generate a certificate signing request:<div><pre class="programlisting">
<strong>$ sudo openssl req -new -key localhost-key.pem -out localhost.csr</strong>
</pre></div></li><li class="listitem">Using <a id="id24" class="indexterm"/>this <strong>certificate signing request</strong> (<strong>CSR</strong>), generate<a id="id25" class="indexterm"/> the certificate:<div><pre class="programlisting">
<strong>$ sudo openssl x509 -req -days 365 -in localhost.csr -signkey  </strong>
<strong>localhost-key.pem -out localhost.crt</strong>
</pre></div></li><li class="listitem">Then we have to convert the key to a no-phrase key:<div><pre class="programlisting">
<strong>$ sudo openssl rsa -in localhost-key.pem -out localhost.key</strong>
</pre></div></li><li class="listitem">Now change <code class="literal">server.crt</code> to <code class="literal">localhost.crt</code> as well as <code class="literal">server.key</code> to <code class="literal">localhost.key</code>:<div><pre class="programlisting">
<strong>$ sudo vim /etc/apache2/extra/httpd-ssl.conf</strong>
</pre></div></li><li class="listitem">All you need to do now is double check your Apache configuration syntax:<div><pre class="programlisting">
<strong>$ sudo apachectl configtest</strong>
</pre></div></li><li class="listitem">If all goes well, restart Apache:<div><pre class="programlisting">
<strong>$ sudo apachectl -k restart</strong>
</pre></div></li><li class="listitem">Now, simply point your browser at <code class="literal">https://localhost</code>. If you are prompted for a self-signed certificate in Chrome you can hit the <strong>Advanced</strong> option on that page and proceed, while in Firefox, you need to expand the <strong>I understand the risks</strong> options and add an exception. This is owing to the fact that the self-signed certificates are not signed by any authority, and for this reason the browsers add warnings about them. Although, since you are the one who created the certificate, you understand it's safe to accept it.</li><li class="listitem">To fix this, you need to add the certificate as a trusted root authority.</li><li class="listitem">Open the <strong>Keychain Access</strong> utility in OS X. Select the <strong>System</strong> option on the left. Click the lock icon in the upper-left corner to enable changes.<div><img src="img/B05381_01_10.jpg" alt="How to do it..."/></div></li><li class="listitem">Click the plus button at the bottom and select the <code class="literal">/etc/apache2/localhost.cer</code> file you copied to the desktop. In the dialog <a id="id26" class="indexterm"/>that comes up, click <strong>Always Trust</strong>. After the localhost gets added to the system keychain, double-click it to open it again. Expand the <strong>Trust</strong> section and for the first option, pick <strong>Always Trust</strong>.</li><li class="listitem">At this point, everything has been configured. Quit Chrome and all other browsers (this is required), fire up the web server, and try to navigate to the local HTTPS site again.<div><img src="img/B05381_01_11.jpg" alt="How to do it..."/></div></li></ol></div><div><div><h3 class="title"><a id="tip01"/>Tip</h3><p>Detailed steps to download the code bundle are mentioned in the Preface of this book. Please have a look.</p><p>The code bundle<a id="id27" class="indexterm"/> for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Service-Worker-Development-Cookbook">https://github.com/PacktPublishing/Service-Worker-Development-Cookbook</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Setting up GitHub pages for SSL</h1></div></div></div><p>Service workers <a id="id28" class="indexterm"/>are designed to run only across HTTPS. So, in <a id="id29" class="indexterm"/>order for us to test our code, we need our web pages to be delivered across HTTPS. GitHub pages are served across HTTPS and it's free to use. So let's get on with it.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Getting ready</h2></div></div></div><p>Before registering for a GitHub account, please make sure you have a valid e-mail address.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up GitHub pages:</p><div><ol class="orderedlist arabic"><li class="listitem">Head over to <a id="id30" class="indexterm"/>GitHub (<a class="ulink" href="https://github.com">https://github.com</a>) and register yourself to obtain an account, if you don't have one already.</li><li class="listitem">Once <a id="id31" class="indexterm"/>you have done that, log in and create <a id="id32" class="indexterm"/>a new repository with the following format:<p>
<code class="literal">username.github.io</code>, where <code class="literal">username</code> is your username.</p><div><img src="img/B05381_01_12.jpg" alt="How to do it..."/></div><p>If the first part of the repository doesn't match your username exactly, it won't work.</p></li><li class="listitem">Open your command-line window and clone your repository.<div><pre class="programlisting">
<strong>$ git  clone https://github.com/username/username.github.io</strong>
</pre></div></li><li class="listitem">Change the directory to <code class="literal">username.github.io</code>:<div><pre class="programlisting">
<strong>$ cd username.github.io</strong>
</pre></div></li><li class="listitem">Create a directory called <code class="literal">service-workers</code>:<div><pre class="programlisting">
<strong>$ mkdir service-workers</strong>
</pre></div></li><li class="listitem">Create <a id="id33" class="indexterm"/>an <code class="literal">index.html</code> file with some text:<div><pre class="programlisting">
<strong>$ echo "Service Workers" &gt; index.html</strong>
</pre></div></li><li class="listitem">Now let's <a id="id34" class="indexterm"/>commit and push our changes to the repository:<div><pre class="programlisting">
<strong>$ git add --all</strong>
<strong>$ git commit -m "initial commit"</strong>
<strong>$ git push -u origin master</strong>
</pre></div></li><li class="listitem">Open up a browser and go to <code class="literal">http://username.github.io/service-workers/</code>.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Registering a service worker</h1></div></div></div><p>Registering <a id="id35" class="indexterm"/>your service worker is the first step to getting a service worker up and running. By registering a service worker, we tell our website to use the service worker. And this registering process happens outside of the service worker, in our case inside the <code class="literal">index.html</code> file. You can do that inside a JavaScript file and then reference it within the <code class="literal">index.html</code> file, but not in the service worker script file.</p><p>In this basic registration demo, we will test to see if our service worker gets registered successfully.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Getting ready</h2></div></div></div><p>To get started, with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to create the <code class="literal">index.html</code> file as follows:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
  &lt;html lang="en"&gt;
   &lt;head&gt;&lt;/head&gt;
       &lt;body&gt;
       &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
       &lt;script&gt;
          if ('serviceWorker' in navigator) {
           navigator.serviceWorker.register(
              'service-worker.js',
              { scope: './' }
            ).then( function(serviceWorker) {
              document.getElementById('status').innerHTML =
                    'successful';
              }).catch(function(error) {
                  document.getElementById('status').innerHTML = error;
              });
          } else {
                document.getElementById('status').innerHTML = 
           'unavailable';
            }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create <a id="id36" class="indexterm"/>an empty JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file.</li><li class="listitem">With your two files in place, you can navigate to the GitHub page, <code class="literal">https://username.github.io/service-workers/01/01/index.html</code>, and you will see the success message in your browser.<div><img src="img/B05381_01_13.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How it works...</h2></div></div></div><p>We started off by making sure that the service worker feature is available with the line <code class="literal">if ('serviceWorker' in navigator)</code>. If that's not the case, then we set the message to unavailable. If your browser does not support service workers, you will get this message.</p><p>Now <a id="id37" class="indexterm"/>we register the service worker with the empty JavaScript file and the scope. To ensure the registration is only applicable to the current directory and those underneath it, we override the default scope of <code class="literal">'/'</code> with <code class="literal">'./'</code> in the line <code class="literal">{ scope: './' }</code> as the scope has to be of the same origin.</p><p>If you decide that your script files should sit elsewhere, you will need a special header, such as <code class="literal">Service-Worker-allowed: true</code> or a specific content-type, such as <code class="literal">text/javascript</code>.</p><p>If the registration was successful, we print the message <code class="literal">successful</code> to the status message.</p><p>Otherwise, we print the error message as the status. The reason for the error could be something going wrong during the registration, for example, the <code class="literal">service-worker.js</code> file may not available or it may contain a syntax error.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>There's more...</h2></div></div></div><p>We can unregister the service worker by calling the following <code class="literal">unregister()</code> function:</p><div><pre class="programlisting">serviceWorker.unregister().then(function() {
    document.getElementById('status').innerHTML = 'unregistered';
})</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Known issues</h3></div></div></div><p>There are a couple of issues with the Chrome browser when working with service workers, which might confuse you.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec01"/>The ERR_FILE_EXISTS error message</h4></div></div></div><p>Reloading pages<a id="id38" class="indexterm"/> with service workers will always show an <code class="literal">ERR_FILE_EXISTS</code> error message, even if there's nothing wrong with your code.</p><p>This seems to occur when we are trying to access an already registered service worker.</p><div><img src="img/B05381_01_14.jpg" alt="The ERR_FILE_EXISTS error message"/></div></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec02"/>Stale console messages</h4></div></div></div><p>Logging <a id="id39" class="indexterm"/>messages from the service worker scripts such as the <code class="literal">console.log</code> may not clear from the console, which seems like the events are being fired too many times on subsequent page loads.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Registering a service worker in detail</h1></div></div></div><p>Understanding <a id="id40" class="indexterm"/>events involved in service worker registration and state transitions will give you greater control over your application by using this feature. In this detailed registration demo, we will take a look at the state transitions of service worker registration.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the previous recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need <a id="id41" class="indexterm"/>to create an <code class="literal">index.html</code> file as follows:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Detailed Registration&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;State: &lt;strong id="state"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
    function printState(state) {
      document.getElementById('state').innerHTML = state;
    }

    if ('serviceWorker' in navigator) {

      navigator.serviceWorker.register(
        'service-worker.js',
        { scope: './' }
      ).then( function(registration) {
        var serviceWorker;

        document.getElementById('status').innerHTML = 'successful';

        if (registration.installing) {
          serviceWorker = registration.installing;
          printState('installing');
        } else if (registration.waiting) {
          serviceWorker = registration.waiting;
          printState('waiting');
        } else if (registration.active) {
          serviceWorker = registration.active;
          printState('active');
        }

        if (serviceWorker) {
          printState(serviceWorker.state);

          serviceWorker.addEventListener('statechange', function(e) {
            printState(e.target.state);
          });
        }
      }).catch(function(error) {
        document.getElementById('status').innerHTML = error;
      });
    } else {
        document.getElementById('status').innerHTML = 'unavailable';
      }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a<a id="id42" class="indexterm"/> JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file with the following code:<div><pre class="programlisting">self.addEventListener('install', function(e) {
  console.log('Install Event:', e);
});

self.addEventListener('activate', function(e) {
  console.log('Activate Event:', e);
});</pre></div></li><li class="listitem">With your two files in place, you can navigate to the GitHub page, <code class="literal">https://username.github.io/service-workers/01/02/index.html</code>, and you will see the success message in your browser.<div><img src="img/B05381_01_15.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works...</h2></div></div></div><p>When the registration is successful, we inspect the state of the registration and print it to the browser. In this case it is installing, waiting, or active:</p><div><pre class="programlisting"> if (registration.installing) {
          serviceWorker = registration.installing;
          printState('installing');
        } else if (registration.waiting) {
          serviceWorker = registration.waiting;
          printState('waiting');
        } else if (registration.active) {
          serviceWorker = registration.active;
          printState('active');
        }</pre></div><p>The <code class="literal">printState(state)</code> helper function will print out the state to the browser.</p><p>At the end we attach <a id="id43" class="indexterm"/>an event listener to the service worker called <code class="literal">statechange</code>. The callback of this event listener will print the state changes to the browser:</p><div><pre class="programlisting">if (serviceWorker) {
          printState(serviceWorker.state);

          serviceWorker.addEventListener('statechange', function(e) {
            printState(e.target.state);
          });
        }</pre></div><p>When the registered service worker is in the activated state, we can refresh the page to see the service worker taking control.</p><p>To demonstrate a page loading, without the service worker taking control, press <em>Shift</em> and refresh the page. You will see the activate event logged in the web console.</p><p>We are subscribing to two event listeners in the <code class="literal">service-worker.js</code> file, <code class="literal">install</code> and <code class="literal">activate</code>:</p><div><pre class="programlisting">self.addEventListener('install', function(e) {
  console.log('Install Event:', e);
});

self.addEventListener('activate', function(e) {
  console.log('Activate Event:', e);
});</pre></div><p>These events get fired when this version of the script first gets registered for the given scope.</p><p>The install event is a good place to prefetch data and initialize caches, and the <code class="literal">activate</code> event works well for cleaning up data from the old version of the script.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>There's more...</h2></div></div></div><p>When the service worker is successfully registered, it will go through the following stages.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Install</h3></div></div></div><p>In the life<a id="id44" class="indexterm"/> cycle of service workers, at the point when the service worker has registered without errors, but is not yet active, any service workers previously activated will still be in control. The service worker is considered new if there is any change in the service worker file between page reloads. It will therefore go through the installation step. At this stage, the service workers are not intercepting any requests.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Activate</h3></div></div></div><p>The<a id="id45" class="indexterm"/> service worker is said to be at the activate stage when it becomes active for the first time. The service worker is now able to intercept requests. This will happen when we close the tab and reopen it, or the page is refreshed by a hard refresh using <em>Shift</em> + reload. It will not occur immediately after the install event.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Fetch</h3></div></div></div><p>The <a id="id46" class="indexterm"/>fetch happens when there is a request being made within the current service worker scope.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Terminate</h3></div></div></div><p>This <a id="id47" class="indexterm"/>can happen at any time, even outside of a request. But the termination happens mostly when the browser needs to reclaim memory. When a new request is made, the service worker will be restarted as needed, or a message will be received, but it will not go back through the activate step.</p><p>The service worker will intercept a request it is registered to catch all the time, even if it needs to be restarted in order to do so. But, having said that, we cannot guarantee it will be around for any length of time. Because of this, the global state will not be preserved, so we have to make sure to avoid using any global variables within the service worker file. Instead, we can use indexed or <code class="literal">localStorage</code> for persistence.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The previous recipe, <em>Registering a service worker</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Debugging</h1></div></div></div><p>Service workers<a id="id48" class="indexterm"/> run in a separate thread in the browser from the pages they control. There are ways to communicate between workers and pages, but they execute in a separate scope. That means you will not have access to the DOM of those web pages from the service worker script, for example. Because of this, we cannot use the DevTools on the same web page to debug service worker scripts. We need to open a separate inspector to debug the service worker thread.</p><p>Service workers <a id="id49" class="indexterm"/>do most of their work by listening for relevant events and responding to them in a productive way. In the life cycle of service workers, different events are triggered at different points in a service worker's life cycle. So, if we want to cache assets, it is a good time to do that during the install state by listening to the <code class="literal">install</code> event. In the same way, we can debug service workers by adding breakpoints to the relevant event handlers.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the previous recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up debugging for service workers:</p><div><ol class="orderedlist arabic"><li class="listitem">To find out your currently running service workers, type the following into your browser: <code class="literal">chrome://inspect/#service-workers</code>:<div><img src="img/B05381_01_16.jpg" alt="How to do it..."/></div></li><li class="listitem">Otherwise, type the following into your browser: <code class="literal">chrome://serviceworker-internals</code> to find out the registered workers. If there aren't<a id="id50" class="indexterm"/> any listed, then there are no currently running service workers.<div><img src="img/B05381_01_17.jpg" alt="How to do it..."/></div></li><li class="listitem">To debug your service worker with Chrome DevTools, navigate to the service worker page and open DevTools. (<em>Cmd</em> + <em>Alt</em> + <em>I</em> in Mac or <em>F12</em> in Windows)</li><li class="listitem">You can add a breakpoint to inspect your code.<div><img src="img/B05381_01_18.jpg" alt="How to do it..."/></div><p>The<a id="id51" class="indexterm"/> service worker will be displayed in the <strong>Threads</strong> list, and the <strong>Service Workers</strong> tab lists all the <strong>Active Running</strong> service workers this page belongs to.</p><div><img src="img/B05381_01_19.jpg" alt="How to do it..."/></div><p>We can use the console for debugging as well. Any errors during the installation <a id="id52" class="indexterm"/>process will be printed on the console page. The console is useful for inspecting the service worker context.</p><div><img src="img/B05381_01_20.jpg" alt="How to do it..."/></div></li><li class="listitem">You will also find the debugging panel in the <strong>Resources</strong> tab of the DevTools useful. In order to view network activity of the worker, click the <code class="literal">inspect</code> link on the <strong>Resources</strong> tab to launch a dedicated DevTools window for the worker.<div><img src="img/B05381_01_21.jpg" alt="How to do it..."/></div></li></ol></div><p>The resulting<a id="id53" class="indexterm"/> page <code class="literal">chrome://serviceworker-internals</code> shows the registered service workers. It also shows basic action buttons, which are explained in detail as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Terminated</strong>: Unregisters the worker.</li><li class="listitem" style="list-style-type: disc"><strong>Start/Stop</strong>: Starts/stops the worker. This will happen automatically when you navigate to a page in the worker's scope.</li><li class="listitem" style="list-style-type: disc"><strong>Sync</strong>: Dispatches a sync event to the worker. If you don't handle this event, nothing will happen.</li><li class="listitem" style="list-style-type: disc"><strong>Push</strong>: Dispatches a push event to the worker. If you don't handle this event, nothing will happen.</li><li class="listitem" style="list-style-type: disc"><strong>Inspect</strong>: Opens the worker in the inspector.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>There's more...</h2></div></div></div><p>When you are working with DevTools open, you might want to check to make sure that the <strong>Disable cache</strong> is not checked in the <strong>Network</strong> tab. If that option is checked, the requests will go to the network instead of the service worker.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Providing a stale version on error</h1></div></div></div><p>If you travel a lot, chances<a id="id54" class="indexterm"/> are you have often experienced a lot of zero network connectivity. This is frustrating, especially if you want to view previously viewed pages. In this recipe, we will look at how we can address this issue by providing the user with the stale version from the cache.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the previous recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure (or you can find the files in the provided directory, <code class="literal">01/05</code>):</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to create an <code class="literal">index.html</code> file as follows:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Stale on Error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;script&gt;
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(
        'service-worker.js',
        { scope: './' }
      ).then( function(serviceWorker) {
        document.getElementById('status').innerHTML = 
        'successful';
      }).catch(function(error) {
        document.getElementById('status').innerHTML = error;
      });

    } else {
        document.getElementById('status').innerHTML = 
        'unavailable';
      }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a <a id="id55" class="indexterm"/>JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file with the following code:<div><pre class="programlisting">var version = 1;
var cacheName = 'stale- ' + version;

self.addEventListener('install', function(event) {
    self.skipWaiting();
});

self.addEventListener('activate', function(event) {
    if (self.clients &amp;&amp; clients.claim) {
        clients.claim();
    }
});

self.addEventListener('fetch', function(event) {
  
    event.respondWith(
        fetch(event.request).then(function(response) {
            caches.open(cacheName).then(function(cache) {
                
                if(response.status &gt;= 500) {
                    cache.match(event.request).
					then(function(response) {
                        
                        return response;
                    }).catch(function() {
                     
                        return response;
                    });
                } else {
                      cache.put(event.request, response.clone());
                    return response;
                }
            });
        })
    );
});</pre></div></li><li class="listitem">With your two files in place, navigate to <code class="literal">index.html</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How it works...</h2></div></div></div><p>When the<a id="id56" class="indexterm"/> registration is successful, we inspect the state of the registration and print it to the browser.</p><p>In the <code class="literal">service-worker.js</code> file, we always fetch the response from the network:</p><div><pre class="programlisting">event.respondWith(
        fetch(event.request).then(function(response) {</pre></div><p>If we received an error response, we return the stale version from the cache:</p><div><pre class="programlisting">if(response.status &gt;= 500) {
                    cache.match(event.request).
					then(function(response) {
                        // Return stale version from cache
                        return response;
})</pre></div><p>If we can't find the stale version, we return the network response, which is the error:</p><div><pre class="programlisting">}).catch(function() {
                        
return response;
});</pre></div><p>If the response was successful (response code 200), we update the cached version:</p><div><pre class="programlisting">} else {
cache.put(event.request, response.clone());
   return response;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>There's more...</h2></div></div></div><p>The <code class="literal">put()</code> method of the cache interface allows key/value pairs to be added to the current cache object. The <code class="literal">put()</code> method also overrides any key/value pair previously stored in the cache that matches the request:</p><div><pre class="programlisting">fetch(url).then(function (response) {
  return cache.put(url, response);
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Creating mock responses</h1></div></div></div><p>In order to<a id="id57" class="indexterm"/> mock API responses from your server to your app, which is instead of actual API responses for the API requests, we can make the service worker return mock responses that will be identical to an API response.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the previous recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure (these can also be found in the provided directory, <code class="literal">01/03</code>):</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to create an <code class="literal">index.html</code> file as follows:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Detailed Registration&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Network status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;div id="request" style="display: none"&gt;
    &lt;input id="long-url" value="https://www.packtpub.com/" size="50"&gt;
      &lt;input type="button" id="url-shorten-btn" value="Shorten URL" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input type="checkbox" id="mock-checkbox" checked&gt;Mock Response&lt;/input&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;br /&gt;
      &lt;a href="" id="short-url"&gt;&lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    function printStatus(status) {
      document.getElementById('status').innerHTML = status;
    }

    function showRequest() {
      document.getElementById('url-shorten-btn')
      .addEventListener('click', sendRequest);
      document.getElementById('request').style.display = 'block';
    }

    function sendRequest() {
      var xhr = new XMLHttpRequest(),
        request;

            xhr.open('POST',
            'https://www.googleapis.com/urlshortener/v1/url?' +
            'key=[Your API Key]');
      xhr.setRequestHeader('Content-Type', 'application/json');

      if (document.getElementById('mock-checkbox').checked) {
                xhr.setRequestHeader('X-Mock-Response', 'yes');
      }

      xhr.addEventListener('load', function() {
        var response = JSON.parse(xhr.response);
        var el = document.getElementById('short-url');

        el.href = response.id;
        el.innerHTML = response.id;
      });

      request = {
        longUrl: document.getElementById('long-url').value
      };

      xhr.send(JSON.stringify(request));
    }

    if ('serviceWorker' in navigator) {

      navigator.serviceWorker.register(
        'service-worker.js',
        { scope: './' }
      ).then( function(registration) {
        if (navigator.serviceWorker.controller) {
            printStatus('The service worker is currently handling ' + 
            'network operations.');
            showRequest();
        } else {
            printStatus('Please reload this page to allow the ' + 'service worker to handle network operations.');
              }
      }).catch(function(error) {
        document.getElementById('status').innerHTML = error;
      });
    } else {
               document.getElementById('status').innerHTML = 'unavailable';
          }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create a JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file with the following code:<div><pre class="programlisting">self.addEventListener('fetch', function(event) {
  console.log('Handling fetch event for', event.request.url);
  var requestUrl = new URL(event.request.url);

  if (requestUrl.pathname === '/urlshortener/v1/url' &amp;&amp;
      event.request.headers.has('X-Mock-Response')) {

    var response = {
      body: {
        kind: 'urlshortener#url',
        id: 'http://goo.gl/IKyjuU',
        longUrl: 'https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html'
      },
      init: {
        status: 200,
        statusText: 'OK',
        headers: {
          'Content-Type': 'application/json',
          'X-Mock-Response': 'yes'
        }
      }
    };

    var mockResponse = new Response(JSON.stringify(response.body),  
        response.init);

    console.log('Responding with a mock response body:', 
        response.body);
    event.respondWith(mockResponse);
  }
});</pre></div></li><li class="listitem">With your<a id="id58" class="indexterm"/> two files in place, you can navigate to the GitHub page, <code class="literal">https://username.github.io/service-workers/01/03/index.html</code>, and you will see the success message in your browser.<div><img src="img/B05381_01_22.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>After the service worker registers itself successfully, we check to make sure that it is currently handling the network operations:</p><div><pre class="programlisting">if (navigator.serviceWorker.controller) {
printStatus('The service worker is currently handling 
network operations.');
…
}</pre></div><p>In this<a id="id59" class="indexterm"/> case, we are calling the <code class="literal">showRequest()</code> function to add an event listener to the URL shorten button, and show the <code class="literal">request</code> block. Otherwise, the whole <code class="literal">request</code> block will be hidden:</p><div><pre class="programlisting">function showRequest() {
   document.getElementById('url-shorten-btn')
.addEventListener('click', sendRequest);
   document.getElementById('request').style.display = 'block';
}</pre></div><p>The <code class="literal">sendRequest()</code> function builds the HTTP request. It creates a <code class="literal">POST</code> request with a URL of the Google API for URL shortening:</p><div><pre class="programlisting">xhr.open('POST',
        'https://www.googleapis.com/urlshortener/v1/url?' +
  'key=[Your API Key]');</pre></div><p>You will have to obtain an API key for this service to be used. For this, follow these instructions:</p><div><ol class="orderedlist arabic"><li class="listitem">Visit the<a id="id60" class="indexterm"/> Google Developers Console page at <a class="ulink" href="https://console.developers.google.com">https://console.developers.google.com</a>.</li><li class="listitem">You can either select an existing project or create a new one.</li><li class="listitem">Expand <strong>APIs &amp; auth</strong>, in the sidebar on the left.</li><li class="listitem">Click <strong>APIs</strong>. Now, in the list of APIs provided, make sure the status is <strong>ON</strong> for the Google URL Shortener API.</li><li class="listitem">Finally, in the sidebar on the left-hand side, select <strong>Credentials</strong>.</li></ol></div><p>If the <strong>Mock Response</strong> is checked, set the request header <code class="literal">X-Mock-Response</code> to <code class="literal">yes</code>:</p><div><pre class="programlisting">if (document.getElementById('mock-checkbox').checked) {
      xhr.setRequestHeader('X-Mock-Response', 'yes');
    }</pre></div><p>Now add an event listener to the load event and pass in a callback to assign the response data to the link displaying the result:</p><div><pre class="programlisting">xhr.addEventListener('load', function() {
var response = JSON.parse(xhr.response);
var el = document.getElementById('short-url');

   el.href = response.id;
   el.innerHTML = response.id;
});</pre></div><p>At the end of the <code class="literal">sendRequest</code> function, we are sending the original URL as well as the <code class="literal">request</code> object we built as a request:</p><div><pre class="programlisting">request = {
        longUrl: document.getElementById('long-url').value
      };
xhr.send(JSON.stringify(request));</pre></div><p>In <a id="id61" class="indexterm"/>the <code class="literal">service-worker.js</code> file, we are adding an event listener for the fetch event. We check that the request URL path has the <code class="literal">urlshortner</code> in it and the request header has <code class="literal">X-Mock-Response</code>:</p><div><pre class="programlisting">if (requestUrl.pathname === '/urlshortener/v1/url' &amp;&amp;
    event.request.headers.has('X-Mock-Response')) {
…
   }</pre></div><p>We build a mock response object with a body, status, and the headers:</p><div><pre class="programlisting">   var response = {
      body: {
        kind: 'urlshortener#url',
        id: 'https://goo.gl/KqR3lJ',
        longUrl: 'https://www.packtpub.com/books/info/packt/about'
      },
      init: {
        status: 200,
        statusText: 'OK',
        headers: {
          'Content-Type': 'application/json',
          'X-Mock-Response': 'yes'
        }
      }
    };</pre></div><p>Finally, we create a response with the mock response:</p><div><pre class="programlisting">var mockResponse = new Response(
JSON.stringify(response.body), response.init);

console.log('Mock Response: ', response.body);
event.respondWith(mockResponse);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Handling request timeouts</h1></div></div></div><p>Long-running <a id="id62" class="indexterm"/>requests can be the result of connectivity issues. Service workers are an ideal solution for overcoming these problems. Let's look at how we can implement a solution with service workers to handle request timeouts.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the previous recipe: <em>Setting up service workers</em>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <em>Setting up GitHub pages for SSL</em>, <em>Setting up SSL for Windows</em>, and <em>Setting up SSL for Mac</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to create an <code class="literal">index.html</code> file as follows:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Request Timeouts&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Registration status: &lt;strong id="status"&gt;&lt;/strong&gt;&lt;/p&gt;

  &lt;script&gt;
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register(
        'service-worker.js',
        { scope: './' }
      ).then(function(serviceWorker) {
        document.getElementById('status').innerHTML = 'successful';
});
    } else {
      document.getElementById('status').innerHTML = 'unavailable';
    }
  &lt;/script&gt;
  &lt;script src="img/jquery-2.2.0.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Create <a id="id63" class="indexterm"/>a JavaScript file called <code class="literal">service-worker.js</code> in the same folder as the <code class="literal">index.html</code> file with the following code:<div><pre class="programlisting">function timeout(delay) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            resolve(new Response('', {
                status: 408,
                statusText: 'Request timed out.'
            }));
        }, delay);
    });
}

self.addEventListener('install', function(event) {
    self.skipWaiting();
});

self.addEventListener('activate', function(event) {
    if (self.clients &amp;&amp; clients.claim) {
        clients.claim();
    }
});

self.addEventListener('fetch', function(event) {
  if (/\.js$/.test(event.request.url)) {
    event.respondWith(Promise.race([timeout(400), fetch(event.request.url)]));
  } else {
    event.respondWith(fetch(event.request));
  }
});</pre></div></li><li class="listitem">With your two files in place, navigate to <code class="literal">index.html</code> and open the DevTools. You will see the time out error logged on the console.<div><img src="img/B05381_01_23.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How it works...</h2></div></div></div><p>In our <code class="literal">index.html</code> file, we're <a id="id64" class="indexterm"/>fetching a large uncompressed jQuery library:</p><div><pre class="programlisting">&lt;script src="img/jquery-2.2.0.js"&gt;&lt;/script&gt;</pre></div><p>In our <code class="literal">service-worker.js</code> file, the event listener of the install event is calling the <code class="literal">skipWaiting()</code> method, which forces the waiting service worker to become the active service worker:</p><div><pre class="programlisting">self.addEventListener('install', function(event) {
    self.skipWaiting();
});</pre></div><p>The <code class="literal">skipWaiting()</code> method is used inside the active event handler, which in turn uses <code class="literal">Clients.claim()</code> to ensure that updates to the underlying service worker take effect immediately, for both the current client and all other active clients:</p><div><pre class="programlisting">self.addEventListener('activate', function(event) {
    if (self.clients &amp;&amp; clients.claim) {
        clients.claim();
    }
});</pre></div><p>In event listener for fetch, we pass in a <code class="literal">Promise.race()</code> function where the first iterable, which is <code class="literal">timeout(400)</code>, gets resolved first:</p><div><pre class="programlisting">self.addEventListener('fetch', function(event) {
  if (/\.js$/.test(event.request.url)) {
    event.respondWith(Promise.race([timeout(400), fetch(event.request.url)]));
  } else {
    event.respondWith(fetch(event.request));
  }
});</pre></div><p>We will elaborate on the <code class="literal">Promise.race()</code> function soon. The <code class="literal">timeout()</code> function returns a promise with 408, which is the code for the request timed out status.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>There's more...</h2></div></div></div><p>The <code class="literal">Promise.race()</code> method <a id="id65" class="indexterm"/>returns a promise that resolves, or rejects, as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise:</p><div><pre class="programlisting">var p1 = new Promise(function(resolve, reject) { 
    setTimeout(resolve, 400, "one"); 
});
var p2 = new Promise(function(resolve, reject) { 
    setTimeout(reject, 100, "two");
});

Promise.race([p1, p2]).then(function(value) {
  // Not called              
}, function(reason) {
  console.log(reason); // "two"
  // p2 is faster, so it rejects
});</pre></div><p>As you can see, <code class="literal">two</code> is faster, so the result is <code class="literal">reject</code>.</p></div></div></body></html>