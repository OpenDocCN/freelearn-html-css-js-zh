- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating the Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: The Space-Truckers application needs to be capable of maintaining and transitioning
    between a set of discrete states that correspond with different screens, such
    as a Menu screen and a Game screen. Transitions between application states typically
    occur as a result of user interaction (e.g., the user selects a menu item) or
    as part of something such as an application launch or exit. Here, we derive our
    basic application flow, which we then use to build a basic framework for presenting
    and transitioning between arbitrary screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Space-Truckers应用程序需要能够维护和在不同屏幕之间切换一组离散状态，例如菜单屏幕和游戏屏幕。应用程序状态之间的转换通常是由于用户交互（例如，用户选择菜单项）或作为某些操作（如应用程序启动或退出）的一部分而发生的。在这里，我们推导出基本的应用程序流程，然后使用它来构建一个基本框架，用于呈现和切换任意屏幕。
- en: 'In the first chapter, we saw the complete Space-Truckers game in all its glory
    and beauty. We then immediately went on to create the loading screen’s animation
    in the Playground before slowing down a bit to build out the supporting application
    infrastructure that the game will need. It may feel seem to be a bit of a let-down
    that we’ve been focusing so much on things that aren’t part of the game’s design,
    and it’s natural to want to focus on activities such as bringing in 3D models
    and textures or programming game mechanics. Fear not – we will be getting there
    in the not-too-distant future! *Part 2: Constructing the Game* is all about those
    sorts of topics, but without the work from this chapter and the accompanying ones,
    there would be nothing to tie together a thematically connected collection of
    interesting Playground snippets and code fragments.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们看到了Space-Truckers游戏的全部辉煌和美丽。然后我们立即在沙盒中创建加载屏幕的动画，然后放慢速度来构建游戏所需的支持应用程序基础设施。我们可能觉得我们一直专注于游戏设计之外的事情，自然地想要专注于诸如引入3D模型和纹理或编程游戏机制等活动。不用担心——我们将在不久的将来达到那里！*第二部分：构建游戏*正是关于这些话题，但没有本章和随附章节的工作，就没有东西可以连接一个主题相关的有趣沙盒片段和代码片段集合。
- en: Important Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter will represent even more of a shift in how the code and content
    are presented. From here on out, code listings will tend towards displaying fragments
    or highlighting interesting areas of a larger piece of code. A link to the repository
    or Playground will always be provided so you can check your work or use the code
    to skip ahead!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将代表代码和内容呈现方式的更大转变。从现在开始，代码列表将倾向于显示代码片段或突出显示更大代码块中的有趣区域。始终会提供链接到仓库或沙盒，以便您可以检查您的作品或使用代码跳过前进！
- en: 'The work of this section and chapter is to build the necessary pieces of software
    and logic to allow a cohesive and compelling experience to emerge from the individual
    pieces. Over the course of this chapter, we will write code to implement state
    management and transitioning logic to support the future development of the core
    game mechanics under these headings:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和本章的工作是构建必要的软件和逻辑组件，以使从单个组件中产生一个统一且引人入胜的体验。在本章的整个过程中，我们将编写代码以实现状态管理和转换逻辑，以支持在这些标题下核心游戏机制的未来开发：
- en: Adding a Custom Loading UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义加载用户界面
- en: 'Space-Truckers: The State Machine'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Space-Truckers：状态机
- en: 'Space-Truckers: The Main Menu'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Space-Truckers：主菜单
- en: Integrating the Main Menu
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成主菜单
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we’ll continue to use the development process covered in
    [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049), *Establishing the Development
    Workflow*. If you’re just joining us on the journey or haven’t been writing code
    on your own, you can catch up by cloning or checking out the `ch3-final` tag from
    Space-Truckers: The GitHub Repository at [https://github.com/jelster/space-truckers/tree/ch3-final](https://github.com/jelster/space-truckers/tree/ch3-final).
    Before writing any code for the material in this chapter, it’s typically a good
    idea to create a new **git** branch that tracks the previous chapter’s **branch**
    or **tag**. This is unusual, as you would normally set up your branch to track
    **develop** or **main**. In this case, however, you want to be comparing commits
    from a specific point in the repository’s commit history prior to where you’re
    starting, and not everything that comes afterward has been covered yet.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将继续使用在[*第3章*](B17266_03_Final_AM.xhtml#_idTextAnchor049)中介绍的开发流程，即*建立开发工作流程*。如果你是刚刚加入我们的旅程或者还没有自己编写代码，你可以通过克隆或检出Space-Truckers：GitHub仓库中的`ch3-final`标签来赶上进度：[https://github.com/jelster/space-truckers/tree/ch3-final](https://github.com/jelster/space-truckers/tree/ch3-final)。在为本章的材料编写任何代码之前，通常一个好的做法是创建一个新的**git**分支来跟踪上一章的**分支**或**标签**。这很不寻常，因为你通常会设置你的分支来跟踪**develop**或**main**。然而，在这种情况下，你想要比较的是在开始之前，从存储库的提交历史中特定点的提交，而不是之后的所有内容都已被涵盖。
- en: Adding a Custom Loading UI
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义加载用户界面
- en: As we start to gain some traction and therefore momentum, we first have to let
    our engines rev up before we can think about shifting gears. A short exercise
    in code management is just the thing to get those RPMs up! Once we’ve hit our
    sweet spot, we’re going to cruise straight into leveraging that work to build
    our loading screen. Remember, as we progress through the metaphorical gearbox
    of complexity, we’ll be seeing fewer details such as the following while at the
    same time covering greater amounts of ground.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始获得一些动力和势头时，我们首先必须让我们的引擎预热，然后才能考虑换挡。进行一次简短的代码管理练习正是提高这些转速的方法！一旦我们找到了最佳点，我们就会直接利用这项工作来构建我们的加载界面。记住，当我们通过复杂性的比喻变速箱前进时，我们将看到更少的细节，例如以下内容，同时也会覆盖更大的范围。
- en: 'Solo Exercise: Refactoring the StartScene to Extract the AstroFactory'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单独练习：重构StartScene以提取AstroFactory
- en: 'To lay the groundwork for this and some future features, we want to extract
    all the logic involved in creating new planets that aren’t specific to the scene
    from the **startScene**. That logic goes into a new **astroFactory** class. The
    essentials of this refactoring are straightforward, but the key to it all is going
    to be creating an array of planetary data objects, then looping through that array,
    calling the **AstroFactory**’s various methods to compose the scene’s objects.
    Consider performing this refactoring a bit of a special exercise or challenge,
    but don’t sweat it too much. The idea is to try and apply the new knowledge, not
    to assign passing or failing grades! Alternatively, if you don’t feel you need
    the practice or want to skip this exercise, start your code by checking out and
    examining the patch diff at the following commit URL: [https://github.com/jelster/space-truckers/commit/9821811](https://github.com/jelster/space-truckers/commit/9821811).
    Take the time you need to understand the material, but don’t forget to come back
    for the rest of the chapter and book!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为这个和未来的某些功能打下基础，我们希望从**startScene**中提取所有与创建新行星相关的逻辑，这些新行星不是特定于场景的。这个逻辑被放入一个新的**astroFactory**类中。这次重构的基本要素很简单，但关键在于创建一个行星数据对象的数组，然后遍历这个数组，调用**AstroFactory**的各种方法来组合场景的对象。将这次重构视为一种特殊的练习或挑战，但不要过于担心。目的是尝试应用新的知识，而不是给予通过或失败的评价！或者，如果你觉得不需要练习或想跳过这个练习，可以从检查以下提交URL的补丁差异开始编写代码：[https://github.com/jelster/space-truckers/commit/9821811](https://github.com/jelster/space-truckers/commit/9821811)。花时间理解材料，但别忘了回来继续本章和整本书的内容！
- en: The CustomLoadingScreen Type
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义加载界面类型
- en: Babylon.js provides a default loading UI that appears automatically during `engine.displayLoadingUI()`
    method. Either way that it is invoked, we’re going to replace the default loading
    UI with one of our own devising. The Babylon.js docs specify the specifics of
    the `displayLoadingUI()` and `hideLoadingUI()` – do those look familiar or what?
    Add a new JS file to the project’s source and name it `createStartScene` function
    from our old friend, **startscene.js**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js提供了一个默认的加载UI，在`engine.displayLoadingUI()`方法调用时自动出现。无论以何种方式调用，我们都会用我们自己设计的UI替换默认的加载UI。Babylon.js文档指定了`displayLoadingUI()`和`hideLoadingUI()`的详细信息——这些看起来熟悉吗？向项目的源代码中添加一个新的JS文件，并将其命名为`createStartScene`函数，来自我们老朋友`**startscene.js**`。
- en: 'The `engine` instance (required by the `createStartScene` method). In the constructor,
    we’ll initialize and assign some class-level properties for later use – including
    `_startScene`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine`实例（`createStartScene`方法所需的）。在构造函数中，我们将初始化并分配一些类级别的属性供以后使用——包括`_startScene`：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That takes care of constructing the loading screen. Now, we need to implement
    the LoadingScreen interface’s members to show and hide the UI at the appropriate
    times. This is just done by having the show and hide methods toggle an `_active`
    Boolean flag; we’ll let other code that we’ll write shortly decide what to do
    about it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了加载界面的构建。现在，我们需要实现`LoadingScreen`接口的成员，以便在适当的时候显示和隐藏UI。这仅仅是通过使用显示和隐藏方法切换一个`_active`布尔标志来完成的；我们将让不久后我们将编写的其他代码来决定如何处理它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The last thing needed is to conditionally render the scene. Since we have the
    engine instance passed into the constructor, we will add a simple render routine
    to call `runRenderLoop` at the end of the constructor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要做的是有条件地渲染场景。由于我们在构造函数中传入了引擎实例，我们将在构造函数的末尾添加一个简单的渲染例程来调用`runRenderLoop`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve gotten the bulk of the work done, but there’s still a bit more to do before
    we can call this a done task.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了大部分工作，但在我们可以称之为完成的任务之前，还有一些事情要做。
- en: Enhancing the Loading Screen with Progress Display
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过进度显示增强加载界面
- en: We’ve added what is called a non-deterministic progress bar, but what if we
    want to display some text along with a percentage of assets loaded? Though our
    project doesn’t quite yet have said assets, it soon will. Fortunately, there are
    only a couple of small things we need to do in order to support this when it’s
    needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个所谓的非确定性进度条，但如果我们想显示一些文本以及已加载资源的百分比呢？尽管我们的项目还没有这些资源，但很快就会有。幸运的是，为了支持这一点，我们只需要做几件小事。
- en: Adding Property Getters
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加属性getter
- en: 'The `loadingUIText`; it will be potentially invoked or queried by external
    code. While we’re at it though, let’s add additional getters as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadingUIText`；它可能会被外部代码调用或查询。不过，既然我们在做这件事，让我们添加以下额外的getter：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A sharp eye may notice that the `progressAvailable` getter uses a field we didn’t
    define in the constructor. The place where this is set and managed is the same
    place where `currentAmountLoaded` and `totalToLoad` get their values from – the
    `onProgressHandler` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的眼睛可能会注意到`progressAvailable`getter使用了一个在构造函数中没有定义的字段。这个设置和管理的地方与`currentAmountLoaded`和`totalToLoad`获取其值的地方相同——`onProgressHandler`函数。
- en: Handling Progress
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理进度
- en: '`onProgressHandler` is an event handler that gets subscribed to HTTP and other
    Progress events emitted by various Babylon.js components such as `AssetManager`
    and `SceneLoader`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`onProgressHandler`是一个事件处理程序，它订阅了由Babylon.js组件（如`AssetManager`和`SceneLoader`）发出的HTTP和其他进度事件：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `evt` event data object is used to set the `progressAvailable` property
    value. If the progress event doesn’t have a computable length, `currentAmountLoaded`
    is set to `0` (false) if incomplete and `1` (true) if complete. Otherwise, it’s
    set to the number of bytes loaded. If we can calculate the percentage loaded,
    we do so and set the `loadingUIText` backing field accordingly. The final piece
    of the loading screen is displaying `loadingText` and the progress string (if
    it’s available).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`evt`事件数据对象用于设置`progressAvailable`属性值。如果进度事件没有可计算的长度，`currentAmountLoaded`在未完成时设置为`0`（false），在完成时设置为`1`（true）。否则，它设置为已加载的字节数。如果我们能计算出加载的百分比，我们就这样做，并相应地设置`loadingUIText`后端字段。加载界面的最后一部分是显示`loadingText`和进度字符串（如果可用）。'
- en: Displaying Loading Text and Progress
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示加载文本和进度
- en: 'To display text in our scene, we’ll use the Babylon.js **2D GUI** system. There’s
    going to be a lot more on this later in this chapter, so for now, copy and paste
    this at the end of the constructor for **SpaceTruckerLoadingScene**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的场景中显示文本，我们将使用Babylon.js的**2D GUI**系统。关于这一点，在本章的后面部分会有更多介绍，所以现在，请将以下内容复制并粘贴到`SpaceTruckerLoadingScene`构造函数的末尾：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we’re doing here is creating a new `AdvancedDynamicTexture` sized to the
    render canvas, then adding a **TextBlock** that we apply a couple of size, color,
    and placement adjustments to before adding it to the texture’s control collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是创建一个新的`AdvancedDynamicTexture`，其大小与渲染画布相匹配，然后添加一个**TextBlock**，我们在将其添加到纹理的控制集合之前对其进行了一些大小、颜色和位置的调整。
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`onProgressHandler` will update the `loadingUIText` value if it’s available.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`onProgressHandler`可用，它将更新`loadingUIText`的值。
- en: 'We’ve completed the loading screen functionality, now it’s time to wire it
    up globally in the `index.js` component. This is just one line of code that is
    added right after the `eng` instance is created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了加载屏幕功能，现在是在`index.js`组件中全局连接它的时候了。这只是一行代码，它是在创建`eng`实例之后立即添加的：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That’s all there is to it! Now, any time that a piece of code asks the Engine
    to show the loading UI, our little planet animations will be shown. Though it
    may seem to be a minor piece of functionality, completing this part of the application
    leaves us ready to change the pace a bit and examine the ins and outs of how we’re
    going to manage the overall behavior of Space-Truckers: The Application.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '就这些了！现在，每当代码请求引擎显示加载UI时，我们的小行星动画就会显示出来。虽然这看起来可能是一个微不足道的功能，但完成这个应用程序的部分使我们准备好稍微改变一下节奏，并检查我们如何管理Space-Truckers:
    The Application的整体行为。'
- en: 'Space-Truckers: The State Machine'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Space-Truckers: 状态机'
- en: People who have some familiarity with game development may be familiar with
    the idea of a game being structured around a series of loops. An Update loop runs
    the simulation and physics, moving objects and applying effects according to the
    latest update. A render loop is when the scene is actually drawn to the screen.
    We’ve seen examples of this previously, such as when we add event observers for
    the **scene.onBeforeRenderObservable**, but that’s at a lower level than what
    we’re looking at currently. Our application is going to be a host for multiple
    different BJS scenes and it will therefore need a way to periodically update the
    application’s state as well as tell the active scene to render. Finally, it must
    be able to manage to transition between different scenes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉游戏开发的人来说，可能会熟悉游戏结构围绕一系列循环的概念。更新循环运行模拟和物理，根据最新更新移动对象并应用效果。渲染循环是场景实际绘制到屏幕上的时刻。我们之前已经看到了这样的例子，比如当我们为`**scene.onBeforeRenderObservable**`添加事件监听器时，但这比我们现在关注的级别要低。我们的应用程序将作为多个不同BJS场景的宿主，因此它需要一种定期更新应用程序状态以及告诉活动场景进行渲染的方法。最后，它必须能够管理在不同场景之间的转换。
- en: An application of the kind we’re building has some implicit requirements when
    it comes to how it responds to input and evolves its internal state over time.
    For instance, when a player selects a menu item or exits their current game, the
    system must respond by altering (or “mutating”) its data to fill and render a
    submenu, or by returning to the main menu. Implicit requirements make for poorly
    designed software, so we’re going to start by making the implicit explicit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的应用程序在如何响应输入以及随时间演变其内部状态方面有一些隐含的要求。例如，当玩家选择菜单项或退出当前游戏时，系统必须通过改变（或“变异”）其数据来填充和渲染子菜单，或者返回主菜单。隐含的要求会导致软件设计不良，因此我们将从使隐含的显式化开始。
- en: Logging Interlude
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志间歇
- en: 'Our application is about to get more complex, so it’s a good time to begin
    adding basic instrumentation and debugging messages – we can always enhance and
    refine the logging routines later, but not having them at all is a much more difficult
    place to begin the more code we write. The source file `logger.js` with its exported
    class, `ConsoleProxy`, is an incredibly basic wrapper around the console object
    that provides functions to log different levels of log messages (INFO, WARN, ERROR,
    and FATAL) to the console (if present). Each of the different logging methods
    has an identical body (if this bothers you, fix it and open a PR! The beauty of
    open source software in action), so in the interest of saving space, only one
    of the functions will be shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序即将变得更加复杂，因此现在是开始添加基本仪表和调试消息的好时机——我们总是可以在以后增强和改进日志程序，但没有它们的话，随着代码量的增加，开始的地方会更加困难。带有其导出类
    `ConsoleProxy` 的源文件 `logger.js` 是一个围绕控制台对象的极其基本的包装器，它提供了将不同级别的日志消息（INFO、WARN、ERROR
    和 FATAL）记录到控制台（如果存在）的功能。不同的日志方法具有相同的主体（如果你觉得这让你感到困扰，修复它并提交一个 PR！开源软件的美丽之处正在发挥作用），为了节省空间，以下代码中只展示了其中一个函数：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Most of the preceding code is pretty bog-standard – the sort of thing you’d
    see in almost any home-brew application framework. The `constructor` accepts a
    `console` parameter, which it uses to set a presence flag. This is because it’s
    not always guaranteed that the `console` object will be available, and we don’t
    want any logging calls to fail and cause problems with the rest of the application
    if that were to be the case. The _`messageBuffer` array is used as a fall-back
    when the console isn’t available. In this case, application logging can still
    be accessed by attaching a debugger and reading the contents of the log array.
    Should it be required, this can easily be extended to suit the scenario at hand.
    Outside of the `theProxy`, is instantiated before being exported as a single object.
    Consumers of the logger don’t instantiate a new log instance – they just call
    `export default` line and change `theProxy` to `logger`. We’ll want to have this
    handy for the next part so that we can easily test and verify proper code behavior,
    or you can refer to snippet **#EK321G** as a starting reference template.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的大部分代码相当标准——你几乎在任何自制的应用程序框架中都能看到这种类型。`constructor` 接受一个 `console` 参数，它使用该参数来设置存在标志。这是因为不能保证
    `console` 对象总是可用，我们不希望任何日志调用失败并导致应用程序的其他部分出现问题。当控制台不可用时，`_`messageBuffer` 数组用作后备。在这种情况下，可以通过附加调试器并读取日志数组的内
    容来访问应用程序日志。如果需要，可以轻松扩展以适应当前场景。`theProxy` 在导出为单个对象之前被实例化。日志记录器的消费者不会实例化一个新的日志实例——他们只需调用
    `export default` 行，并将 `theProxy` 改为 `logger`。我们希望这部分内容方便使用，以便我们可以轻松地测试和验证代码的正确行为，或者你可以参考片段
    **#EK321G** 作为起始参考模板。
- en: Generators and function* Iterators
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器和 function* 迭代器
- en: From the perspective of software design, we will be thinking about our State
    Machine as a type of **iterator**, or a type of looping construct where each iteration
    **yields** the next (or current) state, also allowing callers to specify state
    conditions. The JavaScript language construct that gives us this functionality
    is known as a **Generator** function, or a **function***.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件设计的角度来看，我们将把我们的状态机视为一种 **迭代器**，或者一种循环结构，其中每次迭代 **yield** 下一个（或当前）状态，同时也允许调用者指定状态条件。提供这种功能的
    JavaScript 语言结构被称为 **生成器函数**，或 **函数***。
- en: 'The MDN Web Docs at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
    say this about Generators and their behavior:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MDN Web Docs 在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
    中这样描述生成器和它们的行为：
- en: “Generators are functions that can be exited and later re-entered. Their context
    (variable bindings) will be saved across re-entrances…”
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “生成器是可以退出并在以后重新进入的函数。它们的上下文（变量绑定）将在重新进入时被保存……”
- en: “When the iterator’s `next()` method is called, the generator function’s body
    is executed until the first `yield` expression, which specifies the value to be
    returned from the iterator”
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “当调用迭代器的 `next()` 方法时，生成器函数的主体将执行，直到遇到第一个 `yield` 表达式，该表达式指定了要从迭代器返回的值”
- en: “Calling the `next()` method with an argument will resume the generator function
    execution, replacing the `yield` expression where an execution was paused with
    the argument from `next()`”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: “使用带有参数的`next()`方法将恢复生成器函数的执行，用`next()`的参数替换执行暂停处的`yield`表达式”
- en: “A `return` statement in a generator, when executed, will make the generator
    finish”
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “在生成器中，当执行`return`语句时，将使生成器完成”
- en: Writing a Generator function
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写生成器函数
- en: 'It’s more helpful to see actual code than it is to read descriptions of it,
    so let’s start up a new Playground Snippet and lay down some code. Using the base
    PG snippet (`createScene` function for our Generator function stub:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查看实际代码比阅读其描述更有帮助，因此让我们启动一个新的Playground Snippet并编写一些代码。使用基础PG片段（为我们的生成器函数存根使用`createScene`函数）：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remember that when the body of this function is executed, control is transferred
    any time a `yield` statement is encountered. The `value` is returned by the iterator
    – in the form of an object with a structure that looks as follows: `{ value: <yielded
    value>, done: false|true }`. In the preceding code, we define and set a local
    variable, `currentState`, before `currentState` variable. After execution resumes,
    the code once again yields back – this time with the phrase `“DONE”` before implicitly
    **returning**.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '记住，当此函数体执行时，每当遇到`yield`语句时，控制权都会转移。`value`由迭代器返回，其形式为一个看起来如下结构的对象：`{ value:
    <yielded value>, done: false|true }`。在先前的代码中，我们在`currentState`变量之前定义并设置了一个局部变量`currentState`。在执行恢复后，代码再次产生，这次在隐式**返回**之前带有短语`“DONE”`。'
- en: Using the Generator
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用生成器
- en: To best illustrate some of the non-intuitive behavior of `appStateMachine` Generator
    we just defined. Follow along in your own Playground or skip ahead and load up
    the result of this sub-section as the next snippet revision (we started with 0)
    – **#EK321G#1**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地说明我们刚刚定义的`appStateMachine`生成器的某些非直观行为。请在自己的Playground中跟随，或者跳过并加载本节结果的下一个片段修订版（我们从0开始）——**#EK321G#1**。
- en: 'The first – and arguably the simplest – method of using our `appStateMachine`
    Generator is to use the `yield` statement:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`appStateMachine`生成器的第一种——可以说是最简单的方法——是使用`yield`语句：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous snippet, the value of the index variable is logged to the console
    before being incremented as a convenient way of displaying the behavior of the
    code. Open your browser’s Developer Tools and look at the console output after
    clicking **Run**. The output should look similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的片段中，在递增之前将索引变量的值记录到控制台，这是一种方便显示代码行为的方式。打开您的浏览器开发者工具，在点击**运行**后查看控制台输出。输出应类似于以下内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see from the progression of the `Index` value from `0` to `2` shows
    how the `yield` statement is switching the code execution between the generator
    function and the `for…of` loop. This means `of` iterating over the generator works
    best for situations where the looping logic doesn’t need to do a lot of heavy
    lifting or if the code that you’re writing needs to coordinate many different
    asynchronous operations in the correct order and you don’t need fine control over
    the iteration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Index`值的`0`到`2`的进展中看到，`yield`语句是如何在生成器函数和`for...of`循环之间切换代码执行的。这意味着`of`迭代生成器最适合那些循环逻辑不需要做很多繁重工作或如果您编写的代码需要正确顺序地协调许多不同的异步操作，并且您不需要对迭代有精细控制的情况。
- en: 'An alternative use instead of iterating over the generated function is to manually
    call the `next()` function to transfer control. Each time it is called is equivalent
    to an iteration of the looping construct discussed previously, but recall that
    the difference is that instead of directly getting whatever value was part of
    the `yield` statement, an iterator object is returned with `value` and `done`
    properties:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迭代生成的函数之外，另一种用法是手动调用`next()`函数来转移控制。每次调用都相当于之前讨论的循环结构的迭代，但请记住，区别在于，你不会直接得到`yield`语句中包含的任何值，而是返回一个具有`value`和`done`属性的迭代器对象：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this leads to an identical output to the prior code, but with an extra
    value. Instead of only having three separate index values, this approach leaves
    you with four:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生与先前代码相同的输出，但多出一个值。与只有三个单独的索引值不同，这种方法让你拥有四个：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `“s3”` object doesn’t have a value, and it has the `done` flag set to `true`,
    indicating the sequence is complete. Any further calls to `asm2.next()` will return
    the same `undefined` value and `true` flag. The advantage of this approach is
    that consumers of the Generator have a lot of control over when and how to call
    `next()`, which is a critical feature that we’re about to use when we create our
    first State Machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`“s3”`对象没有值，并且它的`done`标志被设置为`true`，表示序列已完成。任何对`asm2.next()`的进一步调用都将返回相同的`undefined`值和`true`标志。这种方法的优点是，生成器的消费者可以有很多控制权来决定何时以及如何调用`next()`，这是我们创建第一个状态机时即将使用的一个关键特性。
- en: The Definition of a State Machine
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机的定义
- en: 'A core concept in computer science a **Finite State Machine** (**FSM**) – or
    just a **State Machine** – is defined and characterized, for our purposes, by
    these important attributes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的一个核心概念是**有限状态机**（**FSM**）——或者简称为**状态机**——根据我们的目的，它通过以下重要属性被定义和描述：
- en: The system can only ever be in one state at any given time.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统在任何给定时间只能处于一个状态。
- en: The State Machine has a finite number of possible states. For practical purposes,
    at a minimum, there is an initial state and a final state for the system.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态机有有限数量的可能状态。从实用角度来看，至少有一个初始状态和一个最终状态用于系统。
- en: Transitions between states are triggered in response to commands, external input,
    or other changes in the environment (e.g., time passing).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态之间的转换是在响应命令、外部输入或环境中的其他变化（例如，时间流逝）时触发的。
- en: Before a frame is rendered, the State Machine should be updated with the latest
    information about the state.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染帧之前，状态机应该用有关状态的最新信息进行更新。
- en: Let’s look at each of these points in some more detail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些点。
- en: One State at a Time
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次一个状态
- en: This is pretty self-explanatory. A given state machine may only be in a single
    state, no matter how many possible states could be valid – there is no mixing,
    aggregated, or hybrid types of state. In code terms, this means our state machine
    will have a single field or property to represent its current state. This is not
    to say that a particular state machine can’t have attributes that themselves have
    their own states (e.g., an animation might be in the RUNNING state), just that
    the state machine as a whole will only be classified as being in a single state
    at any given time. At the time of writing, quantum computing has not yet reached
    mainstream availability, neatly avoiding any discussion of potential eigenstates
    – a probabilistic combination of potential states – and keeping the subject matter
    firmly rooted in classical computational theory.Phew, what a relief!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点相当直观。一个给定的状态机可能只能处于一个状态，无论可能有多少个有效的状态——不存在混合、聚合或混合类型的状态。在代码术语中，这意味着我们的状态机将只有一个字段或属性来表示其当前状态。这并不是说特定的状态机不能有具有自己状态的属性（例如，一个动画可能处于RUNNING状态），只是整个状态机在任何给定时间只能被分类为处于一个状态。在撰写本文时，量子计算尚未达到主流可用性，巧妙地避免了任何关于潜在本征态的讨论——潜在状态的概率组合——并将主题内容牢固地根植于经典计算理论。呼，真是个解脱！
- en: Finite Number of States, Start and Finish
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限数量的状态，起始和结束状态
- en: There needs to be an initial state for the machine to begin in and there should
    also be an end state. Technically, the end state and the initial state can be
    the same, but it doesn’t make for very interesting or relevant software. In between
    the start and finish can be any number of states, although to keep things practical,
    we’ll only be looking to define a small handful of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 机器需要有一个初始状态来开始，也应该有一个结束状态。技术上，结束状态和初始状态可以是相同的，但这并不构成非常有趣或相关的软件。在起始和结束之间可以有任意数量的状态，尽管为了保持实用性，我们只会关注定义其中的一小部分。
- en: Transitions Happen When Something Happens
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当发生某些事情时发生转换
- en: It sounds silly, but it’s true. During the course of a given Update cycle, the
    application or game logic may receive input events that trigger a state transition.
    Part of our FSM’s definition is the logic to invoke any given state transition.
    That implies our code will contain methods for transitions that have names such
    as `goToMainMenu`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很傻，但这是真的。在给定的更新周期过程中，应用程序或游戏逻辑可能会接收到触发状态转换的输入事件。我们FSM定义的一部分是调用任何给定状态转换的逻辑。这意味着我们的代码将包含具有诸如`goToMainMenu`等名称的转换方法。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If it helps, try to think of a state as being a short-hand way of describing
    a single, discrete combination of the system’s internal data. State transitions
    are the logic controlling the mutation of one combination of internal data into
    another different arrangement of data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助，试着将状态视为描述系统内部数据的单一、离散组合的简写方式。状态转换是控制一个内部数据组合向另一个不同数据排列的突变逻辑。
- en: Updating the State Machine
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新状态机
- en: Wrapping it all up is the mechanism by which we can progress or evolve the machine’s
    state on a frequent basis. Because we’re going to be managing multiple scenes,
    we can’t use something such as `scene.onPreRenderObservable`, as we’ve already
    done for things such as animating the planetary orbits. Instead, we’ll make use
    of the `engine.runRenderLoop` callback as a way of ensuring that our update logic
    is invoked no matter which scene is being rendered. This also fulfills the requirement
    of updating the state before rendering the frame quite nicely.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的总和是我们可以频繁地推进或进化机器状态的机制。因为我们将要管理多个场景，我们不能使用像`scene.onPreRenderObservable`这样的东西，因为我们已经为像动画行星轨道这样的东西使用过了。相反，我们将利用`engine.runRenderLoop`回调作为确保无论渲染哪个场景，我们的更新逻辑都会被调用的方式。这也很好地满足了在渲染帧之前更新状态的要求。
- en: Important Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you need to ensure that animations and physics are synchronized or if you
    need framerate-independent rendering, you’ll need to ensure that you do both of
    the following things:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要确保动画和物理同步，或者如果您需要帧率无关的渲染，您需要确保执行以下两项操作：
- en: a) Set the `deterministicLockstep` flag of the options parameter when creating
    the Engine instance
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: a) 在创建引擎实例时设置选项参数的`deterministicLockstep`标志
- en: b) Use `onBeforeStep` along with the `onAfterStep` observables instead of the
    `onPre/onAfterRenderObservable` sets to perform state updates
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: b) 使用`onBeforeStep`以及`onAfterStep`可观察对象，而不是使用`onPre/onAfterRenderObservable`集合来执行状态更新
- en: With the knowledge of how we’re going to build the next part of our application,
    it’s time to look at the specifics of our design and start to prototype the Playground
    snippet.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了如何构建应用程序的下一部分之后，是时候查看我们设计的具体细节，并开始原型化Playground片段。
- en: 'Space-Truckers: The Application State Diagram'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Space-Truckers：应用程序状态图
- en: 'Before we dive into writing code for our FSM, we should take a moment to figure
    out just what it is that we’re going to need to build. An important distinction
    we need to make out of the gate is between the gameplay and non-gameplay sections
    of the application. The gameplay will have its own state machine to manage the
    different phases of play, and each phase in turn can have its own mini-state machine.
    It’s state machines all the way down! The following diagram shows each state and
    how they transition between them. The circles in the diagram represent events
    or transitions triggered by external input, such as a user clicking a button:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入编写FSM的代码之前，我们应该花点时间弄清楚我们将要构建什么。我们需要在开始时做出的一项重要区分是应用程序的游戏和非游戏部分。游戏将有自己的状态机来管理游戏的各个阶段，每个阶段又可以有自己的迷你状态机。完全是状态机！以下图显示了每个状态以及它们之间的转换。图中的圆圈代表由外部输入触发的事件或转换，例如用户点击按钮：
- en: '![Figure 4.1 – A State diagram, from the early Space-Truckers design process,
    showing the application and game state – transitions between states (lines and
    arrows) happen sequentially (such as Initialized) or as the result of an input
    event (such as user Cancelled)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 来自早期Space-Truckers设计流程的状态图，展示了应用程序和游戏状态 – 状态之间的转换（线条和箭头）是按顺序发生的（例如初始化）或作为输入事件的结果（例如用户取消）'
- en: '](img/Figure_4.01_B17266.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.01_B17266.jpg]'
- en: Figure 4.1 – A State diagram, from the early Space-Truckers design process,
    showing the application and game state – transitions between states (lines and
    arrows) happen sequentially (such as Initialized) or as the result of an input
    event (such as user Cancelled)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 来自早期Space-Truckers设计流程的状态图，展示了应用程序和游戏状态 – 状态之间的转换（线条和箭头）是按顺序发生的（例如初始化）或作为输入事件的结果（例如用户取消）
- en: 'For now, we’ll disregard the lower portion of the diagram. Being an early iteration,
    some of it (that is, the cut scenes) is at any rate aspirational. Looking at the
    diagram’s upper portion, if we consider that the Loading Screen is in the **Initializing**
    state then we can see a 1:1 correspondence between the states and application
    screens. It should also start to become clearer how each screen also corresponds
    to a BJS scene. Reasoning along these lines, we can generalize the different **CutScene**
    and **Splash Screen** items as simply being two separate instances of the same
    thing (save with different actual content, but that’s not relevant here). Here
    are the screens and scenes from the diagram that we’ve identified so far:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将忽略图表的下半部分。作为一个早期迭代版本，其中一些内容（即，剪辑场景）无论如何都是充满希望的。查看图表的上半部分，如果我们考虑加载界面处于**初始化**状态，那么我们可以看到状态和应用屏幕之间的一对一对应关系。这也应该开始变得清楚，每个屏幕也对应一个BJS场景。沿着这些思路推理，我们可以将不同的**CutScene**和**Splash
    Screen**项目概括为同一事物的两个独立实例（尽管内容不同，但这在这里并不相关）。以下是图表中我们已识别出的屏幕和场景：
- en: '![Figure 4.2 – A table of application-level states and transition rules](img/Figure_4.02_B17266.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 应用级状态和转换规则的表格](img/Figure_4.02_B17266.jpg)'
- en: Figure 4.2 – A table of application-level states and transition rules
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 应用级状态和转换规则的表格
- en: This may look like a lot to take in, but it’s really not as complicated as it
    seems. It’s time to open up **VSCode** and start adding some new code. You can
    either follow along here or if you would rather just copy, paste, and modify existing
    code, go to snippet **#EK321G#6**. Bear in mind that you’ll need to make similar
    types of adaptations to the snippet as we made in the previous chapter as you
    progress through incorporating the snippet into your code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能需要吸收很多内容，但实际上并没有看起来那么复杂。现在是时候打开**VSCode**并开始添加一些新的代码了。你可以在这里跟随，或者如果你更愿意复制、粘贴并修改现有代码，请访问片段**#EK321G#6**。记住，随着你将片段整合到代码中，你需要进行类似我们在上一章中进行的类似类型的调整。
- en: Almost Infinitely Looping State
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几乎无限循环状态
- en: 'The first thing we’re going to add to our project is the `appstates.js`, to
    the project’s `/src` directory. Since this is a very simple and unchanging object,
    we can use `Object.freeze` to ensure that the values aren’t changed at runtime:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到我们的项目中的第一个东西是`appstates.js`，到项目的`/src`目录。由于这是一个非常简单且不会改变的对象，我们可以使用`Object.freeze`来确保在运行时值不会被更改：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding the `spaceTruckerApplication.js`, to contain a `class` definition
    named (surprise!) `SpaceTruckerApplication`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`spaceTruckerApplication.js`之后，包含一个名为（惊喜！）`SpaceTruckerApplication`的`class`定义：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class is the central class of this application (as the name implies). It
    will be growing much larger as time passes, so treasure it in all of its adorable
    brevity while you can before breaking ground on it by defining our `appStateMachine`
    function*. Add a function* definition inside the class for it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是这个应用程序的核心类（正如其名称所暗示的）。随着时间的推移，它将变得更大，所以在你开始通过定义我们的`appStateMachine`函数来着手之前，请珍惜它所有可爱的简洁性。在类内部添加一个函数定义。
- en: 'As we discussed earlier, a state machine needs to have one and only one current
    state. It becomes very useful in state calculations to be able to compare the
    present state to whatever value the previous state was, so in the body of the
    function* Generator, add a couple of variable declarations to contain those values,
    along with a helper function to change them:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，状态机需要有一个且只有一个当前状态。在状态计算中，能够将当前状态与之前的状态的任何值进行比较非常有用，因此在`Generator`函数的主体中添加一些变量声明来包含这些值，以及一个辅助函数来更改它们：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now turn our attention to the state machine’s output – what it will
    yield back to callers. Our little sample earlier would simply stop (returning
    `done: true`) once it had reached the end of its sequence, but we want our FSM
    to run for as long as the application is running, and we don’t know ahead of time
    how many times that means calling the Generator’s `next()` method. The way we
    address this is by placing that call inside of an infinite loop.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们可以将注意力转向状态机的输出——它将返回给调用者的内容。我们之前的小样本一旦达到其序列的末尾就会简单地停止（返回`done: true`），但我们希望我们的有限状态机（FSM）在应用程序运行期间一直运行，并且我们事先不知道这意味着要调用生成器的`next()`方法多少次。我们解决这个问题的方法是将这个调用放在一个无限循环中。'
- en: 'Each time, the loop first starts by receiving input from the caller to indicate
    the desired `nextState` – the caller does this by passing the value as an argument
    to `setState` method makes the actual state change. Once that happens, the code
    checks to see whether the conditions have been met to reach the end state (`AppStates.EXITING`),
    returning the `currentState` if so – otherwise, it will `yield` back to the caller
    at the top of the loop:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环首先从调用者那里接收输入，以指示所需的`nextState`——调用者通过将值作为参数传递给`setState`方法来执行实际的状态更改。一旦发生这种情况，代码将检查是否满足达到最终状态（`AppStates.EXITING`）的条件，如果是，则返回`currentState`——否则，它将在循环的顶部`yield`回调用者：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our state machine implementation is done (for now), and now it’s time to hook-up
    the supporting application logic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态机实现（目前）已完成，现在是时候连接支持应用程序逻辑了。
- en: Adding the Constructor and Supporting Logic
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加构造函数和支持逻辑
- en: 'We need to initialize the state machine by creating a function from our Generator
    along with other creation tasks, so add a constructor to our new class. Because
    we are creating and managing scenes with this class, we need to take in `_engine`,
    with it. While we’re here, we might as well call the Generator and add a field
    for tracking which scene to render. Finally, the last action in the constructor
    is to transition the state of the application from its previous value of `undefined`
    to `CREATED`. We’ll do this by invoking the to-be-created `moveNextAppState` function
    (see the following code block):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过从我们的生成器创建一个函数以及其他创建任务来初始化状态机，因此，在我们的新类中添加一个构造函数。由于我们使用这个类创建和管理场景，我们需要带上`_engine`。在此期间，我们不妨调用生成器并添加一个用于跟踪要渲染的场景的字段。最后，构造函数中的最后一个动作是将应用程序的状态从之前的`undefined`值转换为`CREATED`。我们将通过调用即将创建的`moveNextAppState`函数来完成这项工作（请参阅以下代码块）：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It can be cumbersome to have to write statements such as `this._stateMachine.next().value`,
    and worse, it reveals the internal implementation details to code that doesn’t
    need to know about that sort of stuff, making it harder to make changes in the
    future. Let’s insulate the rest of our code from having to deal with that by adding
    some accessor properties to retrieve `currentState` and `activeScene`. Also as
    mentioned previously, we will add the `moveNextAppState` helper method to help
    us to hide the passing of values to and from the state machine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 写出像`this._stateMachine.next().value`这样的语句可能会很繁琐，更糟糕的是，它向不需要知道这类信息的代码揭示了内部实现细节，这使得未来进行更改变得更加困难。让我们通过添加一些访问器属性来获取`currentState`和`activeScene`，来保护我们其余的代码免受这种处理的困扰。此外，正如之前提到的，我们将添加`moveNextAppState`辅助方法来帮助我们隐藏向状态机传递和接收值的过程：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Something important to note before we move any further is that the application
    must respect its boundaries as far as not trying to perform heavy loading tasks
    during construction time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一点非常重要需要注意，即应用程序必须尊重其边界，在构建期间不要尝试执行重型加载任务。
- en: That type of task is reserved for `AppStates.INITIALIZING`, and the reason for
    this is crucial to the user experience. We don’t want to do anything that might
    transfer large amounts of data to the client until they’ve affirmatively decided
    to launch the game. That respects people who might be curious about the game and
    are on limited data or a limited bandwidth connection and enforces a clean separation
    between the HTML-based landing page and the WebGPU or WebGL-based game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的任务是为`AppStates.INITIALIZING`保留的，而这样做的原因对于用户体验至关重要。我们不希望在用户明确决定启动游戏之前执行任何可能将大量数据传输到客户端的操作。这尊重了那些可能对游戏感兴趣但数据或带宽连接有限的人，并强制在基于HTML的着陆页和基于WebGPU或WebGL的游戏之间进行清晰的分离。
- en: Important Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The state diagram we looked at earlier *starts* when the user clicks the **Launch**
    button on our landing page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前查看的状态图是在用户点击我们着陆页上的**启动**按钮时**开始**的。
- en: 'The effect of clicking the landing page’s `run` to the `SpaceTruckerApplication`
    class. This is the place where we hook the engine’s `runRenderLoop` callback up
    with our `applicationStateMachine`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 点击着陆页的`run`按钮对`SpaceTruckerApplication`类的影响。这是我们将引擎的`runRenderLoop`回调与我们的`applicationStateMachine`连接起来的地方：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Within the `runRenderLoop` callback, we retrieve the `currentState` by using
    the getter method to call the `_applicationStateMachine.next()` function without
    any parameters. There’s not much to see at the moment, but the stubbed-out `switch`
    statement shows where each state is handled. The first two, `CREATED` and `INITIALIZING`,
    are grouped because they are not rendered – or at least in the case of `INITIALIZING`,
    the loading UI is the rendered output of that state. Once scene selection and
    management have been completed, the `render()` method of the `_currentScene` (if
    present) is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`runRenderLoop`回调中，我们通过使用getter方法调用`_applicationStateMachine.next()`函数（无任何参数）来获取`currentState`。目前没有什么可看的，但占位符的`switch`语句显示了每个状态的处理位置。前两个状态`CREATED`和`INITIALIZING`被分组，因为它们没有被渲染——或者至少在`INITIALIZING`的情况下，加载UI是该状态的渲染输出。一旦完成场景选择和管理，将调用`_currentScene`的`render()`方法（如果存在）。
- en: Wiring the initial call to `run` is done with two lines that we’ll add to the
    `index.js` file. There’s some cleanup of now-obsolete code needed too – we don’t
    want `index.js` calling `createStartScene`, nor do we want it interacting with
    the engine’s render loop. After creating and setting up `SpaceTruckerLoadingScreen`,
    declare and instantiate a new instance of `SpaceTruckerApplication`. Since it’s
    pretty well named as a type, just call it `theApp`. Next, add a line to invoke
    `theApp.run()` in the **Launch** button’s click handler. It can be useful to add
    logging statements at key areas in the code to help in understanding the app’s
    runtime behavior during development, so make liberal use of them! This is the
    basic framework for our application’s state management functionality all wired
    up and ready to be filled with more interesting states and behaviors. To that
    end, it’s time to start fleshing out these states and behaviors as we get ready
    to build the Main Menu.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将`run`的初始调用连接起来，我们将在`index.js`文件中添加两行。还需要清理一些现在已过时的代码——我们不希望`index.js`调用`createStartScene`，也不希望它与引擎的渲染循环交互。在创建和设置`SpaceTruckerLoadingScreen`之后，声明并实例化一个新的`SpaceTruckerApplication`实例。由于它作为一个类型名称已经相当好，只需将其称为`theApp`。接下来，在**启动**按钮的点击处理程序中添加一行来调用`theApp.run()`。在开发过程中，在代码的关键区域添加日志语句可能会有用，以帮助理解应用程序的运行行为，因此要充分使用它们！这是我们应用程序的状态管理功能的基本框架，已经全部连接好，准备填充更多有趣的状态和行为。为此，我们开始具体化这些状态和行为，为构建主菜单做准备。
- en: Writing the Initialize logic
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写初始化逻辑
- en: Returning to the State Diagram, once the application has finished initialization,
    it should transition to displaying the opening splash screen (cut scene) before
    transitioning to the Main Menu again. This is a nice linear progression, so it
    is simple to implement with the aid of the `await` ES6 feature.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到状态图，一旦应用程序完成初始化，它应该过渡到显示开场画面（场景）然后再过渡到主菜单。这是一个很好的线性进展，因此借助`await` ES6特性实现起来很简单。
- en: 'Since the `INITIALIZING` state is the first state after construction, it should
    be the first thing that happens in the `run()` method. With this change, we’ll
    also need to mark the `run()` method as `async` to allow us to use this language
    feature, so change the first few lines of the function to match the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`INITIALIZING`状态是构建后的第一个状态，它应该是`run()`方法中首先发生的事情。随着这个变化，我们还需要将`run()`方法标记为`async`，以便我们能够使用这个语言特性，因此将函数的前几行更改为以下内容：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, add the function for `initialize`. We want this method to accomplish several
    tasks, some of which we will be simulating for the time being. Another method
    stub, `goToMainMenu`, helps us to complete the first part of the state diagram
    with what we will build next:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`initialize`函数的功能。我们希望这个方法完成几个任务，其中一些我们将暂时进行模拟。另一个方法占位符`goToMainMenu`帮助我们完成状态图的第一个部分，我们将构建以下内容：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we request a fullscreen session from the engine. This is equivalent to
    the user selecting their web browser’s fullscreen option, which we want to do
    before we have to do any serious rendering – applying canvas scaling or a size
    change is faster when there’s not anything being rendered yet. Next, we want to
    display the engine’s Loading UI – which if you recall, we’ve replaced with our
    own custom loading UI in our codebase.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从引擎请求全屏会话。这相当于用户选择他们的网络浏览器的全屏选项，我们希望在开始任何严肃的渲染之前做这件事——在没有渲染内容时应用画布缩放或大小更改要快得多。接下来，我们想要显示引擎的加载UI——如果你还记得，我们在代码库中用我们自己的自定义加载UI替换了它。
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When running this in the Playground, the default Babylon.js loading UI will
    be displayed instead of our customized one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Playground中运行时，将显示默认的Babylon.js加载UI，而不是我们的自定义UI。
- en: After that, we are officially into the `INITITIALIZING` state, so we transition
    to that state by calling `moveNextAppState` with the new state. Lastly, we are
    simulating a 5-second load time by creating a new `Promise` that resolves after
    the timeout period. We `await` this to occur before hiding the loading UI and
    then initiating the next state transition to the `MENU` state.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们就正式进入了`INITITIALIZING`状态，因此我们通过调用带有新状态的`moveNextAppState`来过渡到该状态。最后，我们通过创建一个在超时后解决的新的`Promise`来模拟5秒的加载时间。我们在隐藏加载UI和启动下一个状态转换到`MENU`状态之前等待这个操作完成。
- en: Transitioning to the Main Menu
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换到主菜单
- en: 'The `goToMainMenu` function definition is very simple, as it has a very specific
    task. It needs to create an instance of the (soon-to-be-created) `MainMenuScene`
    class before transitioning to the `MENU` state. Add the following function definition
    to the class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`goToMainMenu`函数定义非常简单，因为它有一个非常具体的任务。它需要在转换到`MENU`状态之前创建一个（即将创建的）`MainMenuScene`类的实例。将以下函数定义添加到类中：'
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There’s one more change needed before we can finish wiring up our state machine.
    In our main `Update` loop, under the `AppStates.MENU` case statement, we need
    to set the `_currentScene` value to our Main Menu’s scene:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以完成连接我们的状态机之前，还需要进行一个更改。在我们的主`Update`循环中，在`AppStates.MENU`情况语句下，我们需要将`_currentScene`值设置为我们的主菜单场景：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Of course, this doesn’t currently exist, and now’s a good time to address that
    deficiency! Create another new JS file, `mainMenuScene.js`, and add a stub class
    to the snippet called `MainMenuScene`. Implement its constructor to take an engine
    instance; it should also create a new `scene`. To keep the scene happy, create
    a new `ArcRotateCamera`, using the final parameter of its constructor to set the
    camera as the scene’s default. To blend with the existing background, we’ll also
    set `scene.clearColor` to an opaque black with `0`, `0`, `0`, and `1` respectively.
    The camera distance parameter is set to `-30` and seems somewhat arbitrary – however,
    the value will be important soon when we are rendering an animated background.
    This is how your class definition should look after putting in the basic elements
    (don’t forget to add `import` statements for `Scene`, `Vector3`, and `ArcRotateCamera`,
    and to add `from “@babylonjs/core”` to the top of the file and `export default
    MainMenuScene` to the bottom!):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这目前还不存在，现在是解决这个缺陷的好时机！创建另一个新的JS文件，`mainMenuScene.js`，并在代码片段中添加一个名为`MainMenuScene`的占位类。实现其构造函数以接受一个引擎实例；它还应该创建一个新的`scene`。为了与现有的背景融合，我们将`scene.clearColor`设置为不透明的黑色，分别为`0`，`0`，`0`和`1`。相机的距离参数设置为`-30`，看起来有些随意——然而，这个值在我们渲染动画背景时将变得非常重要。这是你的类定义在添加基本元素后的样子（不要忘记添加`import`语句为`Scene`，`Vector3`和`ArcRotateCamera`，并在文件顶部添加`from
    “@babylonjs/core”`，在文件底部添加`export default MainMenuScene`！）：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Check to make sure there aren’t any syntax errors or other issues, and make
    sure to save and commit your work. Things are about to get more interesting here!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否有语法错误或其他问题，并确保保存和提交你的工作。这里的事情即将变得更加有趣！
- en: The final listing for our basic state machine is in snippet **#EK321G#6**. Don’t
    be fooled by the seeming lack of accomplishment – it’s not always wise to gauge
    progress using visual indicators. We’ve laid the foundations with this groundwork
    that will help with our future efforts, which will make more sense as we seek
    to coordinate between multiple scenes and screens. The first screen that we’re
    going to build is the Main Menu, which on our diagram isn’t the next state in
    the sequence – the splash scene is what comes next on it – but we will be returning
    to that after we’ve built some of the display and transitioning logic that we’re
    going to need as part of building cut scenes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本状态机的最终列表在代码片段**#EK321G#6**中。不要被看似缺乏成就所欺骗——使用视觉指标来衡量进度并不总是明智的。我们已经通过这个基础工作打下了基础，这将有助于我们未来的努力，随着我们寻求在多个场景和屏幕之间进行协调，这将会更有意义。我们将要构建的第一个屏幕是主菜单，在我们的图中，它不是序列中的下一个状态——启动场景才是——但我们在构建一些作为构建过场场景所需的部分显示和转换逻辑之后将返回那里。
- en: 'Space-Truckers: The Main Menu'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Space-Truckers: 主菜单'
- en: One of the primary features that pretty much every single video game in existence
    has in common with each other is that they all have a Main Menu. Space-Truckers
    is to be no exception, but we first have to sit down and figure out how we want
    our menu to look before we can make it. We start with a basic concept sketch of
    the layout and elements of the menu, which we’ll then use as a guidepost for building
    out a PG snippet of the menu. From the background to the foreground, we’ll build
    up a GUI menu display progressively, adding containers, a title block, and then
    buttons that will be ready to practically drag and drop into the codebase!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现有的视频游戏都有的一个主要共同特征是它们都有一个主菜单。太空卡车手也不例外，但我们首先必须坐下来，弄清楚我们想要我们的菜单看起来如何，然后我们才能制作它。我们从菜单布局和元素的基本概念草图开始，然后将其用作构建菜单片段的指南。从背景到前景，我们将逐步构建GUI菜单显示，添加容器、标题块，然后是准备拖放到代码库中的按钮！
- en: Basic Design
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本设计
- en: 'Firstly, let’s think about the application’s navigational structure. Consulting
    our State Diagram (*Fig. 4.1*), we can see that there are a couple of different
    branches that the state can transition to from the Menu AppState. With the exception
    of the initial transition into the Main Menu, each of the paths represent a different
    menu item or selection option:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑应用程序的导航结构。根据我们的状态图（*图4.1*），我们可以看到有几个不同的分支可以从菜单应用程序状态转换。除了最初进入主菜单的转换外，每条路径都代表一个不同的菜单项或选择选项：
- en: Transitioning from **MENU** to **Running** will be user-triggered by clicking
    a **PLAY** button.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**菜单**转换到**运行**将由用户通过点击**播放**按钮触发。
- en: Exiting the application is triggered by clicking an **EXIT** button.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**退出**按钮可以触发退出应用程序。
- en: Additional menus are accessed by clicking their respective buttons. Initially,
    we’ll only be creating a **High Scores** sub-menu.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击相应的按钮可以访问附加菜单。最初，我们只会创建一个**高分**子菜单。
- en: 'Appearance-wise, we want to make the menu functionally attractive and to show
    a bit of dynamic behavior over time, both in the foreground and the background.
    Another consideration is that because players may be using a gamepad or controller
    instead of a keyboard and mouse, we’ll want to have a **selection indicator**
    that shows the player which menu item will be invoked by clicking or pressing
    the appropriate button on their controllers. The following sketch shows how this
    may look without any background:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在外观上，我们希望菜单功能上吸引人，并在一段时间内在前景和背景中展示一些动态行为。另一个考虑因素是，由于玩家可能使用游戏手柄或控制器而不是键盘和鼠标，我们希望有一个**选择指示器**，显示玩家通过点击或按下他们控制器上的相应按钮将调用哪个菜单项。以下草图显示了在没有背景的情况下这可能看起来如何：
- en: '![Figure 4.3 – A Main Menu design sketch'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – A Main Menu design sketch'
- en: '](img/Figure_4.03_B17266.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.03_B17266.jpg]'
- en: Figure 4.3 – A Main Menu design sketch
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 主菜单设计草图
- en: To help the menu stand out against the background, we’ll fill it with a gradient
    or other semi-opaque image, as well as give the container a border.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让菜单在背景中脱颖而出，我们将用渐变或其他半透明图像填充它，同时给容器添加边框。
- en: The background doesn’t need to have a lot going on – time and bandwidth constraints
    are likely to put this particular piece of content on a low-priority track. That’s
    OK because we can quickly and easily put something in place that looks pretty
    good and does what we want – do you remember our old friend the **Starfield Procedural
    Texture** (**PT**)? We’ll use it to give the menu a cool space-themed background,
    and then we’ll animate it to give the illusion of travel.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 背景不需要有很多内容 – 时间和带宽限制可能会将这块特定内容放在低优先级轨道上。这没关系，因为我们可以快速轻松地放置一些看起来不错且能实现我们想要的功能的东西
    – 你还记得我们那位老朋友**星域程序纹理**（**PT**）吗？我们将使用它为菜单添加一个酷炫的太空主题背景，然后我们将对其进行动画处理，以产生旅行的错觉。
- en: Switch back to the Playground in your web browser and click the **New** icon
    to create a new snippet for our Main Menu.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中切换回游乐场，点击**新建**图标来为我们的主菜单创建一个新的片段。
- en: Setting up the Main Menu snippet
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置主菜单片段
- en: Knowing how we plan to transport the code in our snippet into our codebase at
    some point is a great opportunity to invest the time and effort into making the
    process as quick, reliable, and accurate as possible.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们计划如何将我们的片段中的代码在某个时候传输到我们的代码库中，这是一个很好的机会，投入时间和精力使这个过程尽可能快、可靠和准确。
- en: 'We can start with this by defining some aliases for the various `BABYLON` components
    and namespaces at the top of our snippet, just as we did back in [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049),
    *Establishing the Development Workflow*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在片段顶部定义一些别名来开始，这些别名对应于各种`BABYLON`组件和命名空间，就像我们在[*第3章*](B17266_03_Final_AM.xhtml#_idTextAnchor049)中做的那样，*建立开发工作流程*：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There will be more items to add to this list as we involve additional `MainMenuScene`
    class definition from your local file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们涉及来自本地文件的更多`MainMenuScene`类定义，此列表中将有更多项目需要添加。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The items in the alias list that we just defined will need to be converted into
    **import** statements when integrated into the codebase.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的别名列表中的项目在集成到代码库时需要转换为**导入**语句。
- en: 'When we’re ready to integrate and commit our changes, we’ll update the local
    files by essentially performing the same thing in reverse. In the snippet’s `createScene`
    function, instantiate a new instance of `MainMenuScene` and return its scene property,
    and that will hook up our budding `MainMenuScene` class into the snippet’s rendering
    loop:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备集成和提交更改时，我们将通过本质上执行相同操作的反向操作来更新本地文件。在片段的`createScene`函数中，实例化一个新的`MainMenuScene`实例并返回其场景属性，这样就会将我们的萌芽`MainMenuScene`类连接到片段的渲染循环中：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Short and sweet, we don’t have to think about this part of the snippet ever
    again.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简短明了，我们再也不用考虑这个片段的这一部分了。
- en: Building the Background
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建背景
- en: We’ll start with the general environment and background setup for the scene,
    so scroll back up to the class definition and add a new instance method named
    `_setupBackgroundEnvironment`. This is where we will instantiate and configure
    the Starfield PT that serves as the background for the screen. It’s also where
    we’ll set up the texture to animate gradually over time to give the illusion of
    traveling through the starfield.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从场景的一般环境和背景设置开始，所以滚动到类定义并添加一个名为`_setupBackgroundEnvironment`的新实例方法。这就是我们将实例化和配置作为屏幕背景的星系PT的地方。这也是我们将设置纹理以在一段时间内逐渐动画化，从而产生穿越星系的错觉的地方。
- en: 'Invoke `this._setupBackgroundEnvironment()` at the end of the constructor so
    we can use the run button immediately to see results. Before coding the body of
    the function though, add these types to the top alias definition list:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的末尾调用`this._setupBackgroundEnvironment()`，这样我们就可以立即使用运行按钮来查看结果。然而，在编写函数的主体之前，将这些类型添加到顶部的别名定义列表中：
- en: '`HemisphericLight`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HemisphericLight`'
- en: '`StarfieldProceduralTexture` (put on its own line, you’ll thank yourself later)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StarfieldProceduralTexture`（单独一行，你以后会感谢自己的）'
- en: '`StandardMaterial`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StandardMaterial`'
- en: '`CylinderBuilder`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CylinderBuilder`'
- en: '`Texture`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Texture`'
- en: 'The scene already has a camera placed at -30 units from the origin and pointing
    at the origin, but it’s going to need a light and something for that light to
    illuminate as well. Instead of using a cubical mesh as a skybox, as we did with
    the Loading Screen, we’ll create a conical sort of shape made by making a tube
    with different radii for each end cap. Applying the Starfield PT to the interior
    of the cylinder requires us to set `backFaceCulling` to `false`, since we want
    to see the interior faces. To animate the starfield, we can simply increment the
    `time` property of `StarfieldProceduralTexture` before every frame is rendered:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 场景已经有一个位于原点-30单位处并指向原点的相机，但它还需要一盏灯以及照亮该灯的东西。与我们在加载界面中使用立方体网格作为天空盒不同，我们将创建一个圆锥形形状，通过为每个端盖制作不同半径的管子来实现。将星系PT应用到圆柱体的内部需要我们将`backFaceCulling`设置为`false`，因为我们想看到内部面。为了动画化星系，我们可以在渲染每一帧之前简单地增加`StarfieldProceduralTexture`的`time`属性：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`HemisphericLight` is a type of light source in Babylon.js that simulates an
    ambient environment type of lighting. There are a ton of interesting effects that
    you can achieve by messing around with the combination of **diffuse**, **specular**,
    and, unique to this type of light, **groundColor**, but we don’t need to do that
    right now since our needs are pretty simple.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`HemisphericLight`是Babylon.js中的一种光源，它模拟了环境光照类型。通过玩弄**漫反射**、**镜面反射**以及这种类型的光的独特之处**地面颜色**的组合，你可以实现许多有趣的效果，但鉴于我们的需求相当简单，我们目前不需要这样做。'
- en: Important Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Dividing the scene’s delta time by 1,000 is what sets the rate at which the
    starfield twinkles and shifts. Try removing the division statement and see what
    happens!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景的delta时间除以1,000设置了星系闪烁和移动的速度。尝试删除除法语句，看看会发生什么！
- en: Finishing up the function, we are following a similar pattern to what we did
    when we created the planetary orbits animation for the Loading Screen by registering
    an `onBeforeRenderObservable` and returning the **observer** for tidy later disposal.
    If all went well, clicking the **Run** button should display a nice picture of
    our starfield, twinkling and glittering as it slowly shifts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完成函数，我们遵循与我们在创建加载屏幕的行星轨道动画时相同的模式，通过注册`onBeforeRenderObservable`并返回**观察者**来整洁地处理。如果一切顺利，点击**运行**按钮应该会显示我们星系的美丽画面，随着它缓慢地移动而闪烁和闪耀。
- en: Click `#16XY6Z` to see the full code for this snippet at this point in development.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`#16XY6Z`查看此开发阶段此代码片段的完整代码。
- en: Creating the AdvancedDynamicTexture and GUI
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高级动态纹理和GUI
- en: 'There can be a lot to take in when it comes to the extensive functionality
    present in the Babylon.js 2D GUI system. More extensive documentation on the GUI
    APIs can be found at [https://doc.babylonjs.com/divingDeeper/gui/gui](https://doc.babylonjs.com/divingDeeper/gui/gui),
    but what we’re about to do with it now should either refresh your memory or provide
    enough of a foundation to begin learning. Add new types to the alias list, but
    instead of putting them in the `BABYLON` object, add a new `BABYLON.GUI` entry
    that is similar to the `BABYLON` entry, with the following types from the `BABYLON.GUI`
    namespace:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Babylon.js 2D GUI系统中的广泛功能时，可能会有很多内容需要吸收。更详细的GUI API文档可以在[https://doc.babylonjs.com/divingDeeper/gui/gui](https://doc.babylonjs.com/divingDeeper/gui/gui)找到，但我们现在将要使用它的内容应该要么刷新你的记忆，要么提供足够的基础知识以开始学习。向别名列表添加新类型，但不是将它们放入`BABYLON`对象中，而是添加一个新的`BABYLON.GUI`条目，它与`BABYLON`条目类似，包含来自`BABYLON.GUI`命名空间的下述类型：
- en: '`AdvancedDynamicTexture`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdvancedDynamicTexture`'
- en: '`Rectangle`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle`'
- en: '`Image`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`'
- en: '`StackPanel`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackPanel`'
- en: '`TextBlock`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBlock`'
- en: '`Control`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Control`'
- en: Add a new method called _`setupUi` to `MainMenuClass`, and add a line in the
    constructor to invoke it at the bottom of the function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainMenuClass`中添加一个名为`_setupUi`的新方法，并在构造函数中添加一行代码，在函数底部调用它。
- en: 'We’re not going to try to do anything fancy with the menu UI right now, so
    the first thing the _`setupUi` function needs to do is to create an instance of
    the `BABYLON.GUI.AdvancedDynamicTexture` class in the (default) fullscreen mode.
    This results in a 2D texture the size of the render canvas, with the controls
    painted on it, which is rendered on top of the scene in turn. One minor tweak
    we’ll make is to tell the texture to render at its ideal size – this will help
    avoid fuzziness in rendered text caused by down- or up- sampling effects. To allow
    other class instance methods to access the texture, assign it to the `_guiMenu`
    property:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不会尝试对菜单UI做任何复杂的设计，所以`_setupUi`函数首先需要做的是在（默认的）全屏模式下创建`BABYLON.GUI.AdvancedDynamicTexture`类的一个实例。这将产生一个与渲染画布大小相同的2D纹理，控件被绘制在其上，然后这个纹理被渲染在场景之上。我们将进行的一个小调整是告诉纹理以理想大小渲染——这将有助于避免由于下采样或上采样效果引起的渲染文本的模糊。为了允许其他类实例方法访问纹理，将其分配给`_guiMenu`属性：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next up, we need to add a `Rectangle` control to contain the actual menu items.
    We don’t want it to be completely opaque, but it should have a contrasting background
    color or gradient.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个`Rectangle`控件来包含实际的菜单项。我们不想让它完全不透明，但它应该有一个对比鲜明的背景颜色或渐变。
- en: Adding the Menu Container and Background
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加菜单容器和背景
- en: 'For web developers and designers, there are a lot of what are hopefully comfortingly
    familiar concepts at play. A GUI control tree is a hierarchy similar to an `AdvancedDynamicTexture`
    either directly or indirectly. It’s often easiest to show this rather than describe
    it, so add the following code to define our menu’s container and basic appearance:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网页开发者和设计师来说，有很多希望令人感到舒适熟悉的概念正在发挥作用。GUI控件树是一个类似于`AdvancedDynamicTexture`的层次结构，无论是直接还是间接。通常，展示它比描述它更容易，所以添加以下代码来定义我们的菜单容器和基本外观：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The width is set as a percentage of the canvas size (`0.8`) so that the menu
    doesn’t cover the entire background, while the border width (thickness) is in
    pixels and the corner radius is specified in degrees – got all that?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度设置为画布大小的百分比（`0.8`），这样菜单就不会覆盖整个背景，而边框宽度（厚度）以像素为单位，而角落半径以度为单位——你明白了吗？
- en: Tip
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Intellisense can be your best friend in providing quick descriptions of the
    numerous properties available on GUI controls, particularly when it comes to determining
    which units are in use (e.g., pixels or percentage).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Intellisense 可以成为您的最佳朋友，在提供 GUI 控件上众多属性的快速描述方面，尤其是当涉及到确定使用的单位（例如像素或百分比）时。
- en: Next, we want to add an Image control to hold the background of the menu. Apropos
    of the Image, it’s easy to create a nice background image texture, but what use
    is it if it can’t be seen in the Playground? So, it’s time for a magic trick…
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要添加一个图像控件来持有菜单的背景。关于图像，创建一个漂亮的背景图像纹理很容易，但如果它在 PlayGround 中看不到，那又有什么用呢？所以，现在是时候施展魔法了…
- en: 'Image Aside: Bringing in External Content'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像旁白：引入外部内容
- en: 'The Babylon.js Playground has a feature configured in its web server’s configuration
    to allow **Cross-Origin Resource Sharing** (**CORS**) of content served from a
    number of well-known and established repository hosts, such as GitHub. By crafting
    the appropriate URL to our source repository, we can load textures, sounds, and
    models in our Playground snippet – just as with the **Babylon.js Asset Libraries**!
    By way of demonstrating how this works, add the following line to the very top
    of the snippet (first line):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js PlayGround 在其网络服务器的配置中有一个功能，允许从许多知名和建立的存储库主机（如 GitHub）共享跨源资源（**CORS**）。通过构建到我们源存储库的适当
    URL，我们可以在 PlayGround 片段中加载纹理、声音和模型——就像在 **Babylon.js 资产库** 中一样！为了演示这是如何工作的，请将以下行添加到片段的顶部（第一行）：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Breaking the URL down, here’s how you can apply this tactic to any publicly
    hosted GitHub repository:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将 URL 分解，以下是您如何将此策略应用于任何公开托管的 GitHub 存储库：
- en: Starting with the base URL of [raw.githubusercontent.com](http://raw.githubusercontent.com),
    add the path segments (in order) for the repository owner (or owning Organization)
    name, and the name of the repository itself – for example, `raw.githubusercontent.com/jelster/space-truckers`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从基本 URL [raw.githubusercontent.com](http://raw.githubusercontent.com) 开始，按顺序添加存储库所有者（或拥有组织）的名称和存储库本身的名称——例如，`raw.githubusercontent.com/jelster/space-truckers`。
- en: Next, add a path segment for the name of the branch or tag from which to retrieve
    the asset. For this book, the assets will be listed in their chapter’s respective
    branch, but for many other repositories, this will be `main`, `master`, or possibly
    `develop`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个路径段，用于指定从哪个分支或标签中检索资产。对于本书，资产将列在其章节对应的分支中，但对于许多其他存储库，这将是 `main`、`master`
    或可能是 `develop`。
- en: Finally, add the rest of the path to the asset, including the file extension.
    Because there are pretty robust caching headers accompanying the responses for
    these files, it’s often a good idea during active content production to append
    a cache-using string such as the current date and time to the end of the URL so
    that you can be sure you’re always seeing the most current version of the file.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将路径的其余部分添加到资产中，包括文件扩展名。因为这些文件有相当健壮的缓存头，所以当进行内容生产时，通常将一个使用缓存的字符串（如当前日期和时间）附加到
    URL 的末尾是个好主意，这样您可以确保始终看到文件的最新版本。
- en: 'Using the `menuBackground` URL, create an `Image` and add it to the `menuContainer`
    we previously added:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `menuBackground` URL，创建一个 `Image` 并将其添加到我们之前添加的 `menuContainer`：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Test out your progress by clicking **Run**, fixing any issues, then of course
    make sure to **Save** the snippet. To check yourself or to start with the latest
    snippet for this chapter, use **#16XY6Z#1**. This is how it should look:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 **运行** 测试您的进度，修复任何问题，然后当然要确保 **保存** 片段。要检查自己或从本章的最新片段开始，请使用 **#16XY6Z#1**。它应该看起来是这样的：
- en: '![Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and
    a semi-opaque gradient-filled rectangle that will contain menu items'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – #16XY6Z#1 的主菜单具有星系 PT 背景，以及一个半透明的渐变填充矩形，该矩形将包含菜单项]'
- en: '](img/Figure_4.04_B17266.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.04_B17266.jpg]'
- en: 'Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and
    a semi-opaque gradient-filled rectangle that will contain menu items'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.4 – #16XY6Z#1 的主菜单具有星系 PT 背景，以及一个半透明的渐变填充矩形，该矩形将包含菜单项'
- en: Laying out the Title and Menu Items
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局标题和菜单项
- en: 'Referring back to *Figure 4.2*, we can see that the menu screen can be divided
    up into a grid with two rows – one for the title and one for the menu items. To
    ensure that the buttons and selection icons all line up the way we want them to,
    we’ll need the grid to have three columns, each one-third of the width of the
    grid (which itself has a width of 0.8 or 80%). `addColumnDefinition` and `addRowDefinition`
    methods to accomplish this, making the setup very simple to add to our `_setupUi`
    method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*图4.2*，我们可以看到菜单屏幕可以被分成一个两行的网格——一行用于标题，一行用于菜单项。为了确保按钮和选择图标都按照我们想要的方式对齐，我们需要网格有三个列，每个列宽是网格宽度的三分之一（网格本身的宽度为0.8或80%）。使用
    `addColumnDefinition` 和 `addRowDefinition` 方法来完成此操作，使得设置非常简单，可以添加到我们的 `_setupUi`
    方法中：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The title text is an important factor in defining a game or application’s look
    and feel through its font and display, but we’re going to be circling back to
    that topic in [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142)*, Processing
    Route Data*. For now, we’ll use the default font and ensure that it auto-sizes
    the text as needed. Vertically aligning `TextBlock` with the top of the grid will
    ensure that no matter how many buttons there are, the title will always stay where
    it belongs. A bit of styling to add shadows and padding results in code similar
    to this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 标题文本是定义游戏或应用程序外观和感觉的重要因素，通过其字体和显示方式，但我们将回到这个话题，在[*第7章*](B17266_07_Final_AM.xhtml#_idTextAnchor142)*，处理路由数据*。现在，我们将使用默认字体并确保文本按需自动调整大小。将
    `TextBlock` 垂直对齐到网格的顶部将确保无论有多少按钮，标题都始终保持在正确的位置。添加一些样式以添加阴影和填充，结果代码类似于以下内容：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Check your work by running it and then save your progress. For those following
    along, this can be found at **#16XY6Z#2**. The next task is to write some functionality
    to populate the menu with selectable button items. We’ll be doing a bunch of these,
    so the less we have to repeat ourselves, the more keystrokes we can save.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行它并保存您的进度来检查您的作品。对于跟随的人，这可以在**#16XY6Z#2**中找到。下一个任务是编写一些功能来填充菜单的可选择按钮项。我们将做很多这些，所以我们可以少重复，就能节省更多的按键。
- en: Populating the Menu with Items
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充菜单项
- en: 'Similar to how we added and then implemented the `_setupUi` function, we’ll
    start our latest task by adding an `_addMenuItems` function and constructor invocation
    expression to our class. We know that we want all the buttons of the menu to share
    a certain subset of property values, but not all of them. The properties that
    are unique to a given instance of a menu item can be defined by a simple object
    such as the following one defining the **Play** button’s properties:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们添加并实现 `_setupUi` 函数的方式，我们将通过添加 `_addMenuItems` 函数和构造函数调用表达式到我们的类中开始我们的最新任务。我们知道我们希望菜单中的所有按钮共享某些属性值的子集，但不是全部。特定菜单项实例的独特属性可以通过如下简单对象定义：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A button needs to have a unique name and it also needs some text to display.
    The foreground and background colors ought to be specific to each item, and of
    course, the action that is taken when the button is selected certainly qualifies
    as being specific to a given button. Within the `_addMenuItems` definition but
    before the `pbOpts` expression, add this local helper function to create and populate
    a button control with the given properties:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个按钮需要有一个独特的名称，并且还需要一些文本来显示。前景色和背景色应该针对每个项目具体指定，当然，当按钮被选中时采取的操作当然也符合特定按钮的特性。在
    `_addMenuItems` 定义中但在 `pbOpts` 表达式之前，添加这个局部辅助函数来创建并填充具有给定属性的按钮控件：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the button returned from our helper method, there’s just the matter of
    adding it to the menu grid:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从我们的辅助方法返回的按钮，我们只需将其添加到菜单网格中：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Unlike the same functions of its `addControl` function of **Grid** accepts an
    optional **row** and **column** assignment as its second and third parameters,
    respectively. This lets us insert an item in the last row without knowing its
    index by getting the count of its child rows. We want buttons to be centered,
    so the column will always be the same – one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与其 `addControl` 函数的相同函数不同，**Grid** 的 `addControl` 函数接受可选的 **行** 和 **列** 分配作为其第二个和第三个参数。这使得我们可以通过获取其子行数来在不了解其索引的情况下在最后一行插入一个项。我们希望按钮居中，所以列始终相同——一列。
- en: 'Finish the buttons by adding an exit button according to these options, and
    don’t forget to **Save**! To compare with the checkpoint snippet, see **#16XY6Z#3**:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过根据这些选项添加退出按钮并不要忘记**保存**来完成按钮的设置！要比较检查点片段，请参阅**#16XY6Z#3**：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ve come a long way in this chapter, but we’re not quite done yet. There’s
    been a lot of different things that we’ve been juggling so far, and all of the
    functionality we plan to build is completed – now, we just need to incorporate
    this functionality into the rest of our code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经走了很长的路，但我们还没有完成。到目前为止，我们已经处理了很多不同的事情，我们计划构建的所有功能都已完成——现在，我们只需要将这个功能整合到我们的代码的其余部分。
- en: Adding Menu Item Selection and Indicators
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加菜单项选择和指示器
- en: Although there are a chunk of players who will want to and enjoy using a keyboard
    and mouse to play Space-Truckers, it should also be an enjoyable experience with
    a gamepad. In the next chapter, we’ll look at how to work with gamepad input in
    more detail, and to prepare for that, we need the main menu’s items to be selectable
    without invoking their actions and without the presence of a mouse pointer hovering
    over them. A selection indicator icon will serve this purpose, displaying the
    icon next to the currently selected menu item and showing the player what command
    or option will be invoked on the appropriate button press.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一大批玩家会想要并享受使用键盘和鼠标来玩《太空卡车手》，但它也应该是一个使用游戏手柄也能享受的体验。在下一章中，我们将更详细地探讨如何处理游戏手柄输入，为此，我们需要主菜单的项目可被选择，而无需调用它们的动作，也不需要在它们上方有鼠标指针悬停。一个选择指示器图标将起到这个作用，显示在当前所选菜单项旁边的图标，并显示在适当的按钮按下时将调用的命令或选项。
- en: 'Before we get to the visual aspect of the selected item, let’s add some supporting
    properties to our class in the form of a get and set pair of functions that we’ll
    call `selectedItemIndex`. Retrieving the value is simple using `return this_selectedItemIndex`.
    Setting it is a little bit more complicated. We want to ensure that the index
    doesn’t exceed the number of menu items and that upon reaching the end of the
    menu items, we want it to start over at the first item. There are other things
    that we want to enact when the selected item index changes, but a set method is
    not the place to do anything more than simple logic, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达所选项目的视觉方面之前，让我们以获取和设置函数对的形式给我们的类添加一些辅助属性，我们将称之为 `selectedItemIndex`。获取值很简单，使用
    `return this_selectedItemIndex`。设置它稍微复杂一些。我们想要确保索引不超过菜单项的数量，并且当达到菜单项的末尾时，我们希望它从第一个项目重新开始。当所选项目索引改变时，我们还想执行其他一些操作，但设置方法不是执行任何比简单逻辑更复杂的地方，如下所示：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We saw the usage of `Scalar.Repeat` earlier, when animating planetary orbits.
    Then, we used it to ensure that the radian values stayed smoothly circular. Similarly,
    we want the selection to loop around smoothly once it reaches the end. The new
    item (highlighted in the preceding code) is for a class member that we haven’t
    yet declared, the `_selectedItemChanged` Observer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在动画行星轨道时看到了 `Scalar.Repeat` 的用法。然后，我们使用它来确保弧度值保持平滑的圆形。同样，我们希望选择在达到末尾时平滑地循环。新项目（在前面代码中突出显示）是一个我们尚未声明的类成员，即
    `_selectedItemChanged` 观察者。
- en: Indicating Selection and Reacting to Change
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指示选择并对变化做出反应
- en: 'Calling the `scene.onBeforeRenderObservable`. This time, however, we’re not
    using a built-in observable on a BJS object, but one that we’re declaring ourselves.
    The usage semantics are exactly the same as they are for the other ones we’ve
    used – calling the `add()` method to register a function to be invoked whenever
    the observable is triggered. Creating the observable is just as simple, done by
    creating a new `MainMenuScene` constructor, add code to create the `_selectedItemChanged`
    observable, then call its add method to register our selection’s changed logic:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `scene.onBeforeRenderObservable`。然而，这一次，我们不是在一个BJS对象上使用内置的可观察者，而是我们自己声明的一个。使用语义与我们所使用的其他可观察者完全相同——调用
    `add()` 方法来注册一个函数，每当可观察者被触发时都会调用该函数。创建可观察者同样简单，通过创建一个新的 `MainMenuScene` 构造函数，添加代码来创建
    `_selectedItemChanged` 可观察者，然后调用其 `add` 方法来注册我们的选择改变逻辑：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When the selection changes, the event handler is passed the newly-selected
    item’s index – its row in the grid. Sometimes, we might want to display non-selectable
    menu items, so we retrieve the selected item and then check the item retrieved
    from the second column of the selected row to see whether it’s `isEnabled`. If
    that’s not the case, then we increment `selectedItemIndex` – making sure to use
    the property setter and not directly changing the backing field’s value. The last
    part of our event handler again represents something we haven’t added yet – the
    selection icon. This hides the icon first before removing it from the grid and
    re-adding it at the new position. Moving backward now, again, add a method call
    to `this._createSelectorIcon()` to the `constructor`, then add the eponymous function
    declaration to the class. Here’s how the body of the function should look:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择改变时，事件处理程序会传递新选择项的索引——它在网格中的行。有时，我们可能想要显示不可选的菜单项，因此我们检索所选项目，然后检查从所选行的第二列检索的项目是否`isEnabled`。如果不是这种情况，那么我们就增加`selectedItemIndex`——确保使用属性设置器而不是直接更改后端字段的值。我们事件处理程序的最后部分再次代表了我们还没有添加的内容——选择图标。这首先隐藏图标，然后从网格中移除它，并在新位置重新添加它。现在，再次在构造函数中添加对`this._createSelectorIcon()`的方法调用，然后向类中添加同名的函数声明。函数的主体应该如下所示：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This creates a new `GUI.Image` using the final undeclared constant, the `selectionIcon`
    URL string. The rest of the method is boilerplate code we’ve written in the not-so-distant
    past.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用最终的未声明常量`selectionIcon` URL字符串创建了一个新的`GUI.Image`。方法中的其余部分是我们不久前编写的样板代码。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To avoid ambiguity with the HTML DOM Image type, the fully-qualified name is
    used in the Playground.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与HTML DOM Image类型混淆，Playground中使用的是完全限定的名称。
- en: 'Wrap up the penultimate task of this section by adding the `selectionIcon`
    URL string at the top of the snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在片段顶部添加`selectionIcon` URL字符串来总结本节倒数第二个任务：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Feel free to substitute your image of choice for the one in the repository,
    and if you want to see it used in the production game, send us a **Pull Request**
    with it! Finally, we want to automatically select the first item in the menu,
    but only after the scene has completely finished loading and is waiting for user
    input. We do that by adding a simple line to the end of our constructor:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 随意替换存储库中的图片，如果你想看到它在生产游戏中使用，请发送包含它的**Pull Request**给我们！最后，我们希望在场景完全加载并等待用户输入后自动选择菜单中的第一个项目。我们通过在构造函数末尾添加一行简单的代码来实现这一点：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Clicking **Run** should show a finely crafted main menu – click **Save** and
    congratulate yourself. Look at how much you’ve accomplished during just this one
    pretty small section of one chapter of a (relatively) short book and contemplate
    how far you’ll be by the end! To compare your code for troubleshooting or catching
    up, see snippet **#16XY6Z#4**. The Main Menu looks nice, but despite the starfield
    twinkling in the background, it still needs a little bit of motion to give it
    some life and energy. Let’s be honest too – hornet yellow for the **Exit** button
    isn’t really the look we’re aiming for either, so let’s take a moment to correct
    those matters before moving on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**应该显示一个精心制作的主菜单——点击**保存**并祝贺自己。看看你在这本书的一个相对较短章节的一个相对较小的部分中完成了多少，然后思考你最终会走多远！为了比较你的代码进行故障排除或赶上进度，请参阅片段**#16XY6Z#4**。主菜单看起来不错，但尽管背景中有星系闪烁，它仍然需要一点动作来给它一些活力和能量。坦白说，**退出**按钮的蜂黄色也不是我们想要的外观，所以让我们在继续之前花点时间纠正这些问题。
- en: Visual Improvements and Animating the Selection Idle
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉改进和选择图标动画
- en: The easiest change we want is to set the color property of our `ebOpts` object,
    all the way down in the `_createMenuItems` method, to the string color **black**.
    For the next change, we will add a small animation to the selection icon to make
    it look as though the truck is floating next to the menu item. This is a two-step
    process and the components of each individual step should be familiar from recent
    usage.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的最简单的更改是将我们的`ebOpts`对象的颜色属性设置为字符串颜色**black**。对于下一个更改，我们将在选择图标上添加一个小动画，使其看起来像卡车漂浮在菜单项旁边。这是一个两步的过程，每个步骤的组件应该都来自最近的使用经验。
- en: 'First, we need to track the current animation frame for the icon with a class
    member named `_selectorAnimationFrame`. Second, we need to register an `onBeforeRenderObservable`
    that will execute a new function, `_selectorIconAnimation`, before every frame
    is rendered in the scene. In that function, we increment the current frame (looping
    around if necessary) and use that value to compute the position of the icon along
    the vertical axis according to our circular standby – the **sine** function. This
    is what the animation function should resemble:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用名为 `_selectorAnimationFrame` 的类成员跟踪图标的当前动画帧。其次，我们需要注册一个 `onBeforeRenderObservable`，它将在渲染场景中的每一帧之前执行一个新函数
    `_selectorIconAnimation`。在该函数中，我们增加当前帧（如果需要则循环）并使用该值根据我们的圆形待机 – 正弦函数来计算图标沿垂直轴的位置。这就是动画函数应该类似的样子：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The total time that it takes to go through a complete animation cycle is given
    by the first expression, while the amount of time (in seconds) elapsed since the
    last frame was rendered is given by the second. As we did before with `set selectedItemIndex`,
    we loop `_selectorAnimationFrame` here when it reaches the frame count, but we
    are scaling some values by arbitrary factors at the same time to yield the new
    `top` position (in pixels) that is set in the final line. Running this should
    result in a much more pleasing color for the **Exit** button as well as displaying
    a nice subtle floating appearance for the truck selection icon.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 完成整个动画周期所需的总时间由第一个表达式给出，而自上一帧渲染以来经过的时间（以秒为单位）由第二个表达式给出。正如我们之前在 `set selectedItemIndex`
    中所做的那样，当 `_selectorAnimationFrame` 达到帧计数时，我们在这里循环它，但同时我们通过任意因子缩放一些值，以产生新的 `top`
    位置（以像素为单位），该位置在最后一行中设置。运行此操作应该会导致退出按钮的颜色更加令人愉悦，以及显示卡车选择图标的微妙浮动外观。
- en: '![Figure 4.5 – The Main Menu snippet complete with the floating animation of
    a truck icon](img/Figure_4.05_B17266.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 包含卡车图标浮动动画的主菜单片段](img/Figure_4.05_B17266.jpg)'
- en: Figure 4.5 – The Main Menu snippet complete with the floating animation of a
    truck icon
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 包含卡车图标浮动动画的主菜单片段
- en: If this is starting to feel repetitive, then that’s good, because it means that
    the material in this book is starting to sink in! Snippet **#16XY6Z#5** has the
    latest code; if you’ve not prepared your own, then navigate to this one and make
    sure you have VSCode open and ready to accept the application’s sparkling new
    Main Menu.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这开始感觉重复，那么这是好事，因为这意味着这本书中的材料开始深入人心！片段 **#16XY6Z#5** 有最新的代码；如果您还没有准备自己的，请导航到这个片段，并确保您已经打开了
    VSCode，并准备好接受应用程序的新 Main Menu。
- en: Integrating the Main Menu
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成主菜单
- en: Despite the potentially intimidating heading, there’s really not a whole lot
    we’ll need to do in order to incorporate all of the work from our snippets into
    the application’s code structure. In fact, after all of the effort and journeying
    we’ve done throughout this chapter, it may feel a bit anti-climactic when we finish
    this part of the work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标题可能令人畏惧，但实际上我们不需要做太多工作就能将我们的片段中的所有工作整合到应用程序的代码结构中。事实上，在完成本章的所有努力和旅程之后，当我们完成这部分工作的时候，可能会感觉有点反高潮。
- en: 'The most straightforward and simple way to do it is to copy and paste the whole
    of the `MainMenuScene` class from the snippet into your local file, making sure
    to *entirely* replace the existing class declaration. You’ll need to only slightly
    adjust your `import` statements; here are the two most relevant lines where this
    changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接和简单的方法是将片段中的整个 `MainMenuScene` 类复制粘贴到您的本地文件中，确保完全替换现有的类声明。您只需要稍微调整您的 `import`
    语句；以下是其中两个最相关的行，其中发生了变化：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the selection icon image asset, download the one at the snippet’s URL or
    make your own. Either way, add an `import` statement for it as well:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择图标图像资产，请从片段的 URL 下载或自己制作。无论哪种方式，都要为它添加一个 `import` 语句：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Either wait for the development webpack output to finish or run the webpack
    process to test your changes, and don’t forget to commit and push your work –
    there’s no reason to lose work due to the omission of a few keystrokes. Earlier,
    when we went over our State Machine, we learned that in addition to the state
    behaviors, it’s important to define the transitions to and from those states.On
    the topic of transitions, here's one now!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要么等待开发webpack输出完成，要么运行webpack进程来测试你的更改，并且别忘了提交和推送你的工作——没有理由因为遗漏几个按键而丢失工作。早些时候，当我们讨论我们的状态机时，我们了解到除了状态行为之外，定义从这些状态到其他状态的过渡也很重要。在过渡的话题上，现在有一个新的过渡！
- en: Entering and Leaving Transitions
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入和离开过渡
- en: When we’re looking at the integration of our Main Menu with the SpaceTruckerApplication
    State Machine, there are two functions that we’ve yet to implement and wire up.
    Those functions are the two transition functions for the main menu. In other words,
    we need to define the logic for what happens when we transition to the MENU state,
    as well as out of that state. Naming these new functions is actually pretty easy
    for once – `_onMenuEnter` and `_onMenuLeave`. While there might be more involved
    behavior we’d like to implement later, for now, we will say that when the menu
    either starts or ceases to be the current state of the application, we want it
    to fade in or out accordingly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的主菜单与SpaceTruckerApplication状态机的集成时，有两个函数我们还没有实现和连接。这两个函数是主菜单的两个过渡函数。换句话说，我们需要定义当我们过渡到MENU状态以及从该状态退出时会发生什么逻辑。命名这些新函数实际上相当简单——`_onMenuEnter`和`_onMenuLeave`。虽然我们可能希望在以后实现更多复杂的行为，但现在，我们将说，当菜单开始或停止成为应用程序的当前状态时，我们希望它相应地淡入或淡出。
- en: 'The simplest way to accomplish this is by animating the `menuContainer.alpha`
    property between either `0` to `1` (entering) or `1` to `0` (leaving). As with
    the selection icon animation, we’ll need to store the current frame of `fadeIn`
    and `fadeOut`. Unlike the selection icon animation, we have a finite amount of
    time that the animation should last, so we also need to store the total `duration`
    value of the transition. Between every frame, we should set the current `alpha`
    value to one that is only slightly different from the previous value, so the transition
    appears smooth. Finally, when the animation ends, we want to (in the case of the
    leaving transition) set the menu’s visibility to `false`, along with any other
    clean-up that needs to happen. Interestingly enough, the logic for the enter and
    leave transitions is identical save for swapping the ranges in the `SmoothStep`
    function used to interpolate the `alpha` value. Here’s the `_onMenuEnter` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的最简单方法是通过动画化`menuContainer.alpha`属性，在`0`到`1`（进入）或`1`到`0`（离开）之间。与选择图标动画一样，我们需要存储`fadeIn`和`fadeOut`的当前帧。与选择图标动画不同，动画应该持续的时间是有限的，因此我们还需要存储过渡的总`duration`值。在每一帧之间，我们应该将当前的`alpha`值设置为仅略低于前一个值的值，这样过渡看起来就更加平滑。最后，当动画结束时，我们希望（在离开过渡的情况下）将菜单的可见性设置为`false`，以及任何其他需要进行的清理工作。有趣的是，进入和离开过渡的逻辑几乎相同，只是`SmoothStep`函数中用于插值`alpha`值的范围需要交换。下面是`_onMenuEnter`函数：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of using the standard timer creation method in JavaScript of calling
    `setTimeout`, we’re using the `BABYLON.setAndStartTimer` utility function. By
    attaching `contextObservable` to `scene.onBeforeRenderObservable`, the `onTick`
    method is called consistently before each frame is rendered. The `onEnded` function
    is invoked when the name implies – after the timer has completed. In our case,
    we want to wait until the menu has transitioned in fully before showing the selection
    icon, so we set the `selectedItemIndex` there. In the constructor, we can replace
    the callback used with `scene.whenReadyAsync` to call our `onMenuEnter` function
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用JavaScript中标准的定时器创建方法`setTimeout`，而是使用`BABYLON.setAndStartTimer`实用函数。通过将`contextObservable`附加到`scene.onBeforeRenderObservable`，`onTick`方法会在每一帧渲染之前一致地被调用。当定时器完成时，`onEnded`函数会被调用，正如其名称所暗示的。在我们的情况下，我们希望在菜单完全过渡进来之后再显示选择图标，所以我们将在那里设置`selectedItemIndex`。在构造函数中，我们可以用`scene.whenReadyAsync`调用的`onMenuEnter`函数替换掉使用的回调，如下所示：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Save the file and run the app. You should see the menu fade in over the course
    of a couple of seconds before the selection item shows up. Learn more about this
    and other related functionality at https://doc.babylonjs.com/divingDeeper/events/observables#setandstarttimer,
    but maybe wait a tiny bit to do that – it’s time to finish off this chapter!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行应用程序。你应该会看到菜单在几秒钟内淡入，然后出现选择项。了解更多关于此和其他相关功能的信息，请访问 https://doc.babylonjs.com/divingDeeper/events/observables#setandstarttimer，但也许可以稍等片刻再去做那件事——现在是时候完成本章了！
- en: 'The `onMenuLeave` function is, as was mentioned earlier, almost identical to
    its `onMenuEnter` counterpart (with the exception of the `onEnded` callback),
    just swapping terms in `SmoothStep` (as follows). Add the `onMenuLeave` function
    with the changed expression:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`onMenuLeave` 函数几乎与其 `onMenuEnter` 对应函数相同（除了 `onEnded` 回调），只是在 `SmoothStep`
    中交换了术语（如下）。添加 `onMenuLeave` 函数并使用更改后的表达式：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Hooking up the `onMenuLeave` is easy: in the `_addMenuItems` method’s `ebOpts`
    object definition, change the `onInvoked` function to look something similar to
    the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `onMenuLeave` 很简单：在 `_addMenuItems` 方法的 `ebOpts` 对象定义中，将 `onInvoked` 函数更改为类似以下的内容：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Save again and test your work to ensure it’s behaving as expected. This is looking
    and behaving excellently, but before we can pull over and rest, there’s one last
    thing left to accomplish.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 再次保存并测试你的工作以确保它按预期运行。看起来和表现都非常出色，但在我们能够停下来休息之前，还有最后一件事要做。
- en: Menu Finishing Touches
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单收尾工作
- en: 'It’s a bit too quiet here for what should be an engaging and interesting main
    menu screen. We can fix that though, with the power of music! Although we’ll be
    covering the playing of sounds and music in more detail later, it’s too simple
    to pass the opportunity up, so here’s the quick and dirty version in as few words
    as possible:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有点太安静了，对于一个应该吸引人并有趣的主菜单屏幕来说。不过，我们可以用音乐的力量来解决这个问题！虽然我们将在后面更详细地介绍播放声音和音乐，但机会难得，所以这里尽可能用最少的字数给出快速且简单的版本：
- en: Add an import statement
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加导入语句
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Load and play the music from the constructor
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从构造函数加载并播放音乐
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Enjoy the vibes
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 享受这些感觉
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: OK, so maybe the last part is getting a bit carried away; we do want to stop
    the music at some point. In the `onEnded` callback of `_onMenuLeave`, call `this._music.stop()`
    to stop the sound from playing when the **Exit** button is clicked. Once you’ve
    run the app and corrected any issues, it’s time to commit changes to source control
    and have a nice refreshing beverage – we’ve completed the chapter!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许最后一部分有点过于夸张；我们确实想在某个时候停止音乐。在 `_onMenuLeave` 的 `onEnded` 回调中调用 `this._music.stop()`
    以在点击 **退出** 按钮时停止播放声音。一旦你运行了应用程序并纠正了任何问题，就是时候将更改提交到源代码控制，并享受一杯提神的饮料——我们完成了本章！
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: What a journey we’ve taken during this chapter. Some might prefer to think of
    it as more of a slog, and that’s not unfair – we’ve been wading through some pretty
    dense material here! Despite there being a fair bit of theory and high-level concepts
    tossed around, think back to what’s been accomplished over the course of this
    chapter – where we started was with a landing page that launches into an animation.
    Now, we have a landing page that launches into an *application*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了一段旅程。有些人可能会认为这更像是一场艰难的跋涉，这并不不公平——我们在这里已经艰难地穿越了一些相当密集的材料！尽管有相当多的理论和高级概念被抛出，但回想一下本章所取得的成就——我们最初是从一个启动动画的着陆页开始的。现在，我们有一个启动到
    *应用程序* 的着陆页。
- en: Coming up next, we’re going to look at how to address the problem of accepting
    different forms and methods of input in a way that produces consistent and predictable
    behavior from the application – stick with us, and don’t be afraid to take your
    time to go back and re-read anything you didn’t understand the first time around.
    It’s amazing how much comprehension can require multiple passes to really take
    hold, but if that’s not working and you find you’re struggling to understand or
    follow along, no worries. Navigate to the Space-Trucker Discussions or the Babylon.js
    forums and post your question or problem to the community – you aren’t alone!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何以产生一致和可预测的行为的方式处理接受不同形式和方法的输入问题——请继续关注我们，不要害怕花时间回顾你第一次没有理解的内容。令人惊讶的是，理解需要多次阅读才能真正掌握，但如果这不起作用，你发现自己在理解或跟随上遇到困难，请不要担心。导航到
    Space-Trucker 讨论区或 Babylon.js 论坛，向社区发布你的问题或问题——你不是一个人在战斗！
- en: Extended Topics
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'Things are just getting some momentum, but that doesn’t mean there isn’t more
    to explore and extend what we’ve got already! Here are some ideas for things that
    you might look at, explore, or build into this chapter’s code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 事情正在逐渐积累动力，但这并不意味着没有更多可以探索和扩展的东西！以下是一些你可能想要查看、探索或构建到本章代码中的想法：
- en: Create or extend the regular Babylon.js **Animation** type’s capabilities to
    include 2D **GUI** controls – or – implement a class that mimics the behavior
    of the Animation object with **GUI** controls.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或扩展 Babylon.js 的常规 **Animation** 类型功能，以包括 2D **GUI** 控制 – 或者 – 实现一个模拟 Animation
    对象行为的具有 **GUI** 控制的类。
- en: Can you spot the defect in the `SpaceTruckerLoadingScreen.js` code? It’s a bit
    subtle if you’re reading through it in your head, but there’s definitely a logical
    defect in the code. Running it won’t cause any errors to be thrown but it does
    have effects that are visible at runtime under the right conditions.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否在 `SpaceTruckerLoadingScreen.js` 代码中找到缺陷？如果你在脑海中阅读它，这可能会有些微妙，但代码中确实存在逻辑缺陷。运行它不会抛出任何错误，但在某些条件下，它确实会在运行时产生可见的效果。
- en: Instead of using a single, full-screen `AdvancedDynamicTexture`, use one or
    more mesh-attached textures that are painted onto the meshes in the scene, which
    can then be animated in interesting ways.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用单个全屏的 `AdvancedDynamicTexture`，而是使用一个或多个绘制到场景中网格上的网格附加纹理，这些纹理可以以有趣的方式动画化。
- en: Add an attract mode that engages after the Main Menu has been displayed without
    user input for more than 30 seconds. An attract mode was an arcade game feature
    that puts the game into a non-interactive demo mode intended to catch the attention
    of passers-by. What is your idea for an attract mode?
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主菜单显示超过 30 秒且没有用户输入后，添加一个吸引模式。吸引模式是街机游戏的一个功能，它将游戏置于一个非交互式演示模式，旨在吸引路人的注意。你对于吸引模式有什么想法？
