- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Space-Truckers application needs to be capable of maintaining and transitioning
    between a set of discrete states that correspond with different screens, such
    as a Menu screen and a Game screen. Transitions between application states typically
    occur as a result of user interaction (e.g., the user selects a menu item) or
    as part of something such as an application launch or exit. Here, we derive our
    basic application flow, which we then use to build a basic framework for presenting
    and transitioning between arbitrary screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first chapter, we saw the complete Space-Truckers game in all its glory
    and beauty. We then immediately went on to create the loading screen’s animation
    in the Playground before slowing down a bit to build out the supporting application
    infrastructure that the game will need. It may feel seem to be a bit of a let-down
    that we’ve been focusing so much on things that aren’t part of the game’s design,
    and it’s natural to want to focus on activities such as bringing in 3D models
    and textures or programming game mechanics. Fear not – we will be getting there
    in the not-too-distant future! *Part 2: Constructing the Game* is all about those
    sorts of topics, but without the work from this chapter and the accompanying ones,
    there would be nothing to tie together a thematically connected collection of
    interesting Playground snippets and code fragments.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will represent even more of a shift in how the code and content
    are presented. From here on out, code listings will tend towards displaying fragments
    or highlighting interesting areas of a larger piece of code. A link to the repository
    or Playground will always be provided so you can check your work or use the code
    to skip ahead!
  prefs: []
  type: TYPE_NORMAL
- en: 'The work of this section and chapter is to build the necessary pieces of software
    and logic to allow a cohesive and compelling experience to emerge from the individual
    pieces. Over the course of this chapter, we will write code to implement state
    management and transitioning logic to support the future development of the core
    game mechanics under these headings:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Custom Loading UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Space-Truckers: The State Machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Space-Truckers: The Main Menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Main Menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this chapter, we’ll continue to use the development process covered in
    [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049), *Establishing the Development
    Workflow*. If you’re just joining us on the journey or haven’t been writing code
    on your own, you can catch up by cloning or checking out the `ch3-final` tag from
    Space-Truckers: The GitHub Repository at [https://github.com/jelster/space-truckers/tree/ch3-final](https://github.com/jelster/space-truckers/tree/ch3-final).
    Before writing any code for the material in this chapter, it’s typically a good
    idea to create a new **git** branch that tracks the previous chapter’s **branch**
    or **tag**. This is unusual, as you would normally set up your branch to track
    **develop** or **main**. In this case, however, you want to be comparing commits
    from a specific point in the repository’s commit history prior to where you’re
    starting, and not everything that comes afterward has been covered yet.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Custom Loading UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start to gain some traction and therefore momentum, we first have to let
    our engines rev up before we can think about shifting gears. A short exercise
    in code management is just the thing to get those RPMs up! Once we’ve hit our
    sweet spot, we’re going to cruise straight into leveraging that work to build
    our loading screen. Remember, as we progress through the metaphorical gearbox
    of complexity, we’ll be seeing fewer details such as the following while at the
    same time covering greater amounts of ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solo Exercise: Refactoring the StartScene to Extract the AstroFactory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To lay the groundwork for this and some future features, we want to extract
    all the logic involved in creating new planets that aren’t specific to the scene
    from the **startScene**. That logic goes into a new **astroFactory** class. The
    essentials of this refactoring are straightforward, but the key to it all is going
    to be creating an array of planetary data objects, then looping through that array,
    calling the **AstroFactory**’s various methods to compose the scene’s objects.
    Consider performing this refactoring a bit of a special exercise or challenge,
    but don’t sweat it too much. The idea is to try and apply the new knowledge, not
    to assign passing or failing grades! Alternatively, if you don’t feel you need
    the practice or want to skip this exercise, start your code by checking out and
    examining the patch diff at the following commit URL: [https://github.com/jelster/space-truckers/commit/9821811](https://github.com/jelster/space-truckers/commit/9821811).
    Take the time you need to understand the material, but don’t forget to come back
    for the rest of the chapter and book!'
  prefs: []
  type: TYPE_NORMAL
- en: The CustomLoadingScreen Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Babylon.js provides a default loading UI that appears automatically during `engine.displayLoadingUI()`
    method. Either way that it is invoked, we’re going to replace the default loading
    UI with one of our own devising. The Babylon.js docs specify the specifics of
    the `displayLoadingUI()` and `hideLoadingUI()` – do those look familiar or what?
    Add a new JS file to the project’s source and name it `createStartScene` function
    from our old friend, **startscene.js**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `engine` instance (required by the `createStartScene` method). In the constructor,
    we’ll initialize and assign some class-level properties for later use – including
    `_startScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes care of constructing the loading screen. Now, we need to implement
    the LoadingScreen interface’s members to show and hide the UI at the appropriate
    times. This is just done by having the show and hide methods toggle an `_active`
    Boolean flag; we’ll let other code that we’ll write shortly decide what to do
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing needed is to conditionally render the scene. Since we have the
    engine instance passed into the constructor, we will add a simple render routine
    to call `runRenderLoop` at the end of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’ve gotten the bulk of the work done, but there’s still a bit more to do before
    we can call this a done task.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the Loading Screen with Progress Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve added what is called a non-deterministic progress bar, but what if we
    want to display some text along with a percentage of assets loaded? Though our
    project doesn’t quite yet have said assets, it soon will. Fortunately, there are
    only a couple of small things we need to do in order to support this when it’s
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Property Getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `loadingUIText`; it will be potentially invoked or queried by external
    code. While we’re at it though, let’s add additional getters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A sharp eye may notice that the `progressAvailable` getter uses a field we didn’t
    define in the constructor. The place where this is set and managed is the same
    place where `currentAmountLoaded` and `totalToLoad` get their values from – the
    `onProgressHandler` function.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`onProgressHandler` is an event handler that gets subscribed to HTTP and other
    Progress events emitted by various Babylon.js components such as `AssetManager`
    and `SceneLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `evt` event data object is used to set the `progressAvailable` property
    value. If the progress event doesn’t have a computable length, `currentAmountLoaded`
    is set to `0` (false) if incomplete and `1` (true) if complete. Otherwise, it’s
    set to the number of bytes loaded. If we can calculate the percentage loaded,
    we do so and set the `loadingUIText` backing field accordingly. The final piece
    of the loading screen is displaying `loadingText` and the progress string (if
    it’s available).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Loading Text and Progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display text in our scene, we’ll use the Babylon.js **2D GUI** system. There’s
    going to be a lot more on this later in this chapter, so for now, copy and paste
    this at the end of the constructor for **SpaceTruckerLoadingScene**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All we’re doing here is creating a new `AdvancedDynamicTexture` sized to the
    render canvas, then adding a **TextBlock** that we apply a couple of size, color,
    and placement adjustments to before adding it to the texture’s control collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`onProgressHandler` will update the `loadingUIText` value if it’s available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve completed the loading screen functionality, now it’s time to wire it
    up globally in the `index.js` component. This is just one line of code that is
    added right after the `eng` instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all there is to it! Now, any time that a piece of code asks the Engine
    to show the loading UI, our little planet animations will be shown. Though it
    may seem to be a minor piece of functionality, completing this part of the application
    leaves us ready to change the pace a bit and examine the ins and outs of how we’re
    going to manage the overall behavior of Space-Truckers: The Application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Space-Truckers: The State Machine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People who have some familiarity with game development may be familiar with
    the idea of a game being structured around a series of loops. An Update loop runs
    the simulation and physics, moving objects and applying effects according to the
    latest update. A render loop is when the scene is actually drawn to the screen.
    We’ve seen examples of this previously, such as when we add event observers for
    the **scene.onBeforeRenderObservable**, but that’s at a lower level than what
    we’re looking at currently. Our application is going to be a host for multiple
    different BJS scenes and it will therefore need a way to periodically update the
    application’s state as well as tell the active scene to render. Finally, it must
    be able to manage to transition between different scenes.
  prefs: []
  type: TYPE_NORMAL
- en: An application of the kind we’re building has some implicit requirements when
    it comes to how it responds to input and evolves its internal state over time.
    For instance, when a player selects a menu item or exits their current game, the
    system must respond by altering (or “mutating”) its data to fill and render a
    submenu, or by returning to the main menu. Implicit requirements make for poorly
    designed software, so we’re going to start by making the implicit explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Interlude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application is about to get more complex, so it’s a good time to begin
    adding basic instrumentation and debugging messages – we can always enhance and
    refine the logging routines later, but not having them at all is a much more difficult
    place to begin the more code we write. The source file `logger.js` with its exported
    class, `ConsoleProxy`, is an incredibly basic wrapper around the console object
    that provides functions to log different levels of log messages (INFO, WARN, ERROR,
    and FATAL) to the console (if present). Each of the different logging methods
    has an identical body (if this bothers you, fix it and open a PR! The beauty of
    open source software in action), so in the interest of saving space, only one
    of the functions will be shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most of the preceding code is pretty bog-standard – the sort of thing you’d
    see in almost any home-brew application framework. The `constructor` accepts a
    `console` parameter, which it uses to set a presence flag. This is because it’s
    not always guaranteed that the `console` object will be available, and we don’t
    want any logging calls to fail and cause problems with the rest of the application
    if that were to be the case. The _`messageBuffer` array is used as a fall-back
    when the console isn’t available. In this case, application logging can still
    be accessed by attaching a debugger and reading the contents of the log array.
    Should it be required, this can easily be extended to suit the scenario at hand.
    Outside of the `theProxy`, is instantiated before being exported as a single object.
    Consumers of the logger don’t instantiate a new log instance – they just call
    `export default` line and change `theProxy` to `logger`. We’ll want to have this
    handy for the next part so that we can easily test and verify proper code behavior,
    or you can refer to snippet **#EK321G** as a starting reference template.
  prefs: []
  type: TYPE_NORMAL
- en: Generators and function* Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the perspective of software design, we will be thinking about our State
    Machine as a type of **iterator**, or a type of looping construct where each iteration
    **yields** the next (or current) state, also allowing callers to specify state
    conditions. The JavaScript language construct that gives us this functionality
    is known as a **Generator** function, or a **function***.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MDN Web Docs at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
    say this about Generators and their behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: “Generators are functions that can be exited and later re-entered. Their context
    (variable bindings) will be saved across re-entrances…”
  prefs: []
  type: TYPE_NORMAL
- en: “When the iterator’s `next()` method is called, the generator function’s body
    is executed until the first `yield` expression, which specifies the value to be
    returned from the iterator”
  prefs: []
  type: TYPE_NORMAL
- en: “Calling the `next()` method with an argument will resume the generator function
    execution, replacing the `yield` expression where an execution was paused with
    the argument from `next()`”
  prefs: []
  type: TYPE_NORMAL
- en: “A `return` statement in a generator, when executed, will make the generator
    finish”
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Generator function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s more helpful to see actual code than it is to read descriptions of it,
    so let’s start up a new Playground Snippet and lay down some code. Using the base
    PG snippet (`createScene` function for our Generator function stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that when the body of this function is executed, control is transferred
    any time a `yield` statement is encountered. The `value` is returned by the iterator
    – in the form of an object with a structure that looks as follows: `{ value: <yielded
    value>, done: false|true }`. In the preceding code, we define and set a local
    variable, `currentState`, before `currentState` variable. After execution resumes,
    the code once again yields back – this time with the phrase `“DONE”` before implicitly
    **returning**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Generator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To best illustrate some of the non-intuitive behavior of `appStateMachine` Generator
    we just defined. Follow along in your own Playground or skip ahead and load up
    the result of this sub-section as the next snippet revision (we started with 0)
    – **#EK321G#1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first – and arguably the simplest – method of using our `appStateMachine`
    Generator is to use the `yield` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, the value of the index variable is logged to the console
    before being incremented as a convenient way of displaying the behavior of the
    code. Open your browser’s Developer Tools and look at the console output after
    clicking **Run**. The output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the progression of the `Index` value from `0` to `2` shows
    how the `yield` statement is switching the code execution between the generator
    function and the `for…of` loop. This means `of` iterating over the generator works
    best for situations where the looping logic doesn’t need to do a lot of heavy
    lifting or if the code that you’re writing needs to coordinate many different
    asynchronous operations in the correct order and you don’t need fine control over
    the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative use instead of iterating over the generated function is to manually
    call the `next()` function to transfer control. Each time it is called is equivalent
    to an iteration of the looping construct discussed previously, but recall that
    the difference is that instead of directly getting whatever value was part of
    the `yield` statement, an iterator object is returned with `value` and `done`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this leads to an identical output to the prior code, but with an extra
    value. Instead of only having three separate index values, this approach leaves
    you with four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This `“s3”` object doesn’t have a value, and it has the `done` flag set to `true`,
    indicating the sequence is complete. Any further calls to `asm2.next()` will return
    the same `undefined` value and `true` flag. The advantage of this approach is
    that consumers of the Generator have a lot of control over when and how to call
    `next()`, which is a critical feature that we’re about to use when we create our
    first State Machine.
  prefs: []
  type: TYPE_NORMAL
- en: The Definition of a State Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A core concept in computer science a **Finite State Machine** (**FSM**) – or
    just a **State Machine** – is defined and characterized, for our purposes, by
    these important attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The system can only ever be in one state at any given time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The State Machine has a finite number of possible states. For practical purposes,
    at a minimum, there is an initial state and a final state for the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transitions between states are triggered in response to commands, external input,
    or other changes in the environment (e.g., time passing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before a frame is rendered, the State Machine should be updated with the latest
    information about the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at each of these points in some more detail.
  prefs: []
  type: TYPE_NORMAL
- en: One State at a Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is pretty self-explanatory. A given state machine may only be in a single
    state, no matter how many possible states could be valid – there is no mixing,
    aggregated, or hybrid types of state. In code terms, this means our state machine
    will have a single field or property to represent its current state. This is not
    to say that a particular state machine can’t have attributes that themselves have
    their own states (e.g., an animation might be in the RUNNING state), just that
    the state machine as a whole will only be classified as being in a single state
    at any given time. At the time of writing, quantum computing has not yet reached
    mainstream availability, neatly avoiding any discussion of potential eigenstates
    – a probabilistic combination of potential states – and keeping the subject matter
    firmly rooted in classical computational theory.Phew, what a relief!
  prefs: []
  type: TYPE_NORMAL
- en: Finite Number of States, Start and Finish
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There needs to be an initial state for the machine to begin in and there should
    also be an end state. Technically, the end state and the initial state can be
    the same, but it doesn’t make for very interesting or relevant software. In between
    the start and finish can be any number of states, although to keep things practical,
    we’ll only be looking to define a small handful of them.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions Happen When Something Happens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It sounds silly, but it’s true. During the course of a given Update cycle, the
    application or game logic may receive input events that trigger a state transition.
    Part of our FSM’s definition is the logic to invoke any given state transition.
    That implies our code will contain methods for transitions that have names such
    as `goToMainMenu`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If it helps, try to think of a state as being a short-hand way of describing
    a single, discrete combination of the system’s internal data. State transitions
    are the logic controlling the mutation of one combination of internal data into
    another different arrangement of data.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the State Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wrapping it all up is the mechanism by which we can progress or evolve the machine’s
    state on a frequent basis. Because we’re going to be managing multiple scenes,
    we can’t use something such as `scene.onPreRenderObservable`, as we’ve already
    done for things such as animating the planetary orbits. Instead, we’ll make use
    of the `engine.runRenderLoop` callback as a way of ensuring that our update logic
    is invoked no matter which scene is being rendered. This also fulfills the requirement
    of updating the state before rendering the frame quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to ensure that animations and physics are synchronized or if you
    need framerate-independent rendering, you’ll need to ensure that you do both of
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Set the `deterministicLockstep` flag of the options parameter when creating
    the Engine instance
  prefs: []
  type: TYPE_NORMAL
- en: b) Use `onBeforeStep` along with the `onAfterStep` observables instead of the
    `onPre/onAfterRenderObservable` sets to perform state updates
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of how we’re going to build the next part of our application,
    it’s time to look at the specifics of our design and start to prototype the Playground
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Space-Truckers: The Application State Diagram'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into writing code for our FSM, we should take a moment to figure
    out just what it is that we’re going to need to build. An important distinction
    we need to make out of the gate is between the gameplay and non-gameplay sections
    of the application. The gameplay will have its own state machine to manage the
    different phases of play, and each phase in turn can have its own mini-state machine.
    It’s state machines all the way down! The following diagram shows each state and
    how they transition between them. The circles in the diagram represent events
    or transitions triggered by external input, such as a user clicking a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A State diagram, from the early Space-Truckers design process,
    showing the application and game state – transitions between states (lines and
    arrows) happen sequentially (such as Initialized) or as the result of an input
    event (such as user Cancelled)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.01_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – A State diagram, from the early Space-Truckers design process,
    showing the application and game state – transitions between states (lines and
    arrows) happen sequentially (such as Initialized) or as the result of an input
    event (such as user Cancelled)
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we’ll disregard the lower portion of the diagram. Being an early iteration,
    some of it (that is, the cut scenes) is at any rate aspirational. Looking at the
    diagram’s upper portion, if we consider that the Loading Screen is in the **Initializing**
    state then we can see a 1:1 correspondence between the states and application
    screens. It should also start to become clearer how each screen also corresponds
    to a BJS scene. Reasoning along these lines, we can generalize the different **CutScene**
    and **Splash Screen** items as simply being two separate instances of the same
    thing (save with different actual content, but that’s not relevant here). Here
    are the screens and scenes from the diagram that we’ve identified so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A table of application-level states and transition rules](img/Figure_4.02_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A table of application-level states and transition rules
  prefs: []
  type: TYPE_NORMAL
- en: This may look like a lot to take in, but it’s really not as complicated as it
    seems. It’s time to open up **VSCode** and start adding some new code. You can
    either follow along here or if you would rather just copy, paste, and modify existing
    code, go to snippet **#EK321G#6**. Bear in mind that you’ll need to make similar
    types of adaptations to the snippet as we made in the previous chapter as you
    progress through incorporating the snippet into your code.
  prefs: []
  type: TYPE_NORMAL
- en: Almost Infinitely Looping State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we’re going to add to our project is the `appstates.js`, to
    the project’s `/src` directory. Since this is a very simple and unchanging object,
    we can use `Object.freeze` to ensure that the values aren’t changed at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the `spaceTruckerApplication.js`, to contain a `class` definition
    named (surprise!) `SpaceTruckerApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This class is the central class of this application (as the name implies). It
    will be growing much larger as time passes, so treasure it in all of its adorable
    brevity while you can before breaking ground on it by defining our `appStateMachine`
    function*. Add a function* definition inside the class for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed earlier, a state machine needs to have one and only one current
    state. It becomes very useful in state calculations to be able to compare the
    present state to whatever value the previous state was, so in the body of the
    function* Generator, add a couple of variable declarations to contain those values,
    along with a helper function to change them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now turn our attention to the state machine’s output – what it will
    yield back to callers. Our little sample earlier would simply stop (returning
    `done: true`) once it had reached the end of its sequence, but we want our FSM
    to run for as long as the application is running, and we don’t know ahead of time
    how many times that means calling the Generator’s `next()` method. The way we
    address this is by placing that call inside of an infinite loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time, the loop first starts by receiving input from the caller to indicate
    the desired `nextState` – the caller does this by passing the value as an argument
    to `setState` method makes the actual state change. Once that happens, the code
    checks to see whether the conditions have been met to reach the end state (`AppStates.EXITING`),
    returning the `currentState` if so – otherwise, it will `yield` back to the caller
    at the top of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our state machine implementation is done (for now), and now it’s time to hook-up
    the supporting application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Constructor and Supporting Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to initialize the state machine by creating a function from our Generator
    along with other creation tasks, so add a constructor to our new class. Because
    we are creating and managing scenes with this class, we need to take in `_engine`,
    with it. While we’re here, we might as well call the Generator and add a field
    for tracking which scene to render. Finally, the last action in the constructor
    is to transition the state of the application from its previous value of `undefined`
    to `CREATED`. We’ll do this by invoking the to-be-created `moveNextAppState` function
    (see the following code block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be cumbersome to have to write statements such as `this._stateMachine.next().value`,
    and worse, it reveals the internal implementation details to code that doesn’t
    need to know about that sort of stuff, making it harder to make changes in the
    future. Let’s insulate the rest of our code from having to deal with that by adding
    some accessor properties to retrieve `currentState` and `activeScene`. Also as
    mentioned previously, we will add the `moveNextAppState` helper method to help
    us to hide the passing of values to and from the state machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Something important to note before we move any further is that the application
    must respect its boundaries as far as not trying to perform heavy loading tasks
    during construction time.
  prefs: []
  type: TYPE_NORMAL
- en: That type of task is reserved for `AppStates.INITIALIZING`, and the reason for
    this is crucial to the user experience. We don’t want to do anything that might
    transfer large amounts of data to the client until they’ve affirmatively decided
    to launch the game. That respects people who might be curious about the game and
    are on limited data or a limited bandwidth connection and enforces a clean separation
    between the HTML-based landing page and the WebGPU or WebGL-based game.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The state diagram we looked at earlier *starts* when the user clicks the **Launch**
    button on our landing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect of clicking the landing page’s `run` to the `SpaceTruckerApplication`
    class. This is the place where we hook the engine’s `runRenderLoop` callback up
    with our `applicationStateMachine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Within the `runRenderLoop` callback, we retrieve the `currentState` by using
    the getter method to call the `_applicationStateMachine.next()` function without
    any parameters. There’s not much to see at the moment, but the stubbed-out `switch`
    statement shows where each state is handled. The first two, `CREATED` and `INITIALIZING`,
    are grouped because they are not rendered – or at least in the case of `INITIALIZING`,
    the loading UI is the rendered output of that state. Once scene selection and
    management have been completed, the `render()` method of the `_currentScene` (if
    present) is called.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the initial call to `run` is done with two lines that we’ll add to the
    `index.js` file. There’s some cleanup of now-obsolete code needed too – we don’t
    want `index.js` calling `createStartScene`, nor do we want it interacting with
    the engine’s render loop. After creating and setting up `SpaceTruckerLoadingScreen`,
    declare and instantiate a new instance of `SpaceTruckerApplication`. Since it’s
    pretty well named as a type, just call it `theApp`. Next, add a line to invoke
    `theApp.run()` in the **Launch** button’s click handler. It can be useful to add
    logging statements at key areas in the code to help in understanding the app’s
    runtime behavior during development, so make liberal use of them! This is the
    basic framework for our application’s state management functionality all wired
    up and ready to be filled with more interesting states and behaviors. To that
    end, it’s time to start fleshing out these states and behaviors as we get ready
    to build the Main Menu.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Initialize logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returning to the State Diagram, once the application has finished initialization,
    it should transition to displaying the opening splash screen (cut scene) before
    transitioning to the Main Menu again. This is a nice linear progression, so it
    is simple to implement with the aid of the `await` ES6 feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `INITIALIZING` state is the first state after construction, it should
    be the first thing that happens in the `run()` method. With this change, we’ll
    also need to mark the `run()` method as `async` to allow us to use this language
    feature, so change the first few lines of the function to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the function for `initialize`. We want this method to accomplish several
    tasks, some of which we will be simulating for the time being. Another method
    stub, `goToMainMenu`, helps us to complete the first part of the state diagram
    with what we will build next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we request a fullscreen session from the engine. This is equivalent to
    the user selecting their web browser’s fullscreen option, which we want to do
    before we have to do any serious rendering – applying canvas scaling or a size
    change is faster when there’s not anything being rendered yet. Next, we want to
    display the engine’s Loading UI – which if you recall, we’ve replaced with our
    own custom loading UI in our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When running this in the Playground, the default Babylon.js loading UI will
    be displayed instead of our customized one.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we are officially into the `INITITIALIZING` state, so we transition
    to that state by calling `moveNextAppState` with the new state. Lastly, we are
    simulating a 5-second load time by creating a new `Promise` that resolves after
    the timeout period. We `await` this to occur before hiding the loading UI and
    then initiating the next state transition to the `MENU` state.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the Main Menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `goToMainMenu` function definition is very simple, as it has a very specific
    task. It needs to create an instance of the (soon-to-be-created) `MainMenuScene`
    class before transitioning to the `MENU` state. Add the following function definition
    to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one more change needed before we can finish wiring up our state machine.
    In our main `Update` loop, under the `AppStates.MENU` case statement, we need
    to set the `_currentScene` value to our Main Menu’s scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this doesn’t currently exist, and now’s a good time to address that
    deficiency! Create another new JS file, `mainMenuScene.js`, and add a stub class
    to the snippet called `MainMenuScene`. Implement its constructor to take an engine
    instance; it should also create a new `scene`. To keep the scene happy, create
    a new `ArcRotateCamera`, using the final parameter of its constructor to set the
    camera as the scene’s default. To blend with the existing background, we’ll also
    set `scene.clearColor` to an opaque black with `0`, `0`, `0`, and `1` respectively.
    The camera distance parameter is set to `-30` and seems somewhat arbitrary – however,
    the value will be important soon when we are rendering an animated background.
    This is how your class definition should look after putting in the basic elements
    (don’t forget to add `import` statements for `Scene`, `Vector3`, and `ArcRotateCamera`,
    and to add `from “@babylonjs/core”` to the top of the file and `export default
    MainMenuScene` to the bottom!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check to make sure there aren’t any syntax errors or other issues, and make
    sure to save and commit your work. Things are about to get more interesting here!
  prefs: []
  type: TYPE_NORMAL
- en: The final listing for our basic state machine is in snippet **#EK321G#6**. Don’t
    be fooled by the seeming lack of accomplishment – it’s not always wise to gauge
    progress using visual indicators. We’ve laid the foundations with this groundwork
    that will help with our future efforts, which will make more sense as we seek
    to coordinate between multiple scenes and screens. The first screen that we’re
    going to build is the Main Menu, which on our diagram isn’t the next state in
    the sequence – the splash scene is what comes next on it – but we will be returning
    to that after we’ve built some of the display and transitioning logic that we’re
    going to need as part of building cut scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Space-Truckers: The Main Menu'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary features that pretty much every single video game in existence
    has in common with each other is that they all have a Main Menu. Space-Truckers
    is to be no exception, but we first have to sit down and figure out how we want
    our menu to look before we can make it. We start with a basic concept sketch of
    the layout and elements of the menu, which we’ll then use as a guidepost for building
    out a PG snippet of the menu. From the background to the foreground, we’ll build
    up a GUI menu display progressively, adding containers, a title block, and then
    buttons that will be ready to practically drag and drop into the codebase!
  prefs: []
  type: TYPE_NORMAL
- en: Basic Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, let’s think about the application’s navigational structure. Consulting
    our State Diagram (*Fig. 4.1*), we can see that there are a couple of different
    branches that the state can transition to from the Menu AppState. With the exception
    of the initial transition into the Main Menu, each of the paths represent a different
    menu item or selection option:'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from **MENU** to **Running** will be user-triggered by clicking
    a **PLAY** button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the application is triggered by clicking an **EXIT** button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional menus are accessed by clicking their respective buttons. Initially,
    we’ll only be creating a **High Scores** sub-menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appearance-wise, we want to make the menu functionally attractive and to show
    a bit of dynamic behavior over time, both in the foreground and the background.
    Another consideration is that because players may be using a gamepad or controller
    instead of a keyboard and mouse, we’ll want to have a **selection indicator**
    that shows the player which menu item will be invoked by clicking or pressing
    the appropriate button on their controllers. The following sketch shows how this
    may look without any background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A Main Menu design sketch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.03_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – A Main Menu design sketch
  prefs: []
  type: TYPE_NORMAL
- en: To help the menu stand out against the background, we’ll fill it with a gradient
    or other semi-opaque image, as well as give the container a border.
  prefs: []
  type: TYPE_NORMAL
- en: The background doesn’t need to have a lot going on – time and bandwidth constraints
    are likely to put this particular piece of content on a low-priority track. That’s
    OK because we can quickly and easily put something in place that looks pretty
    good and does what we want – do you remember our old friend the **Starfield Procedural
    Texture** (**PT**)? We’ll use it to give the menu a cool space-themed background,
    and then we’ll animate it to give the illusion of travel.
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the Playground in your web browser and click the **New** icon
    to create a new snippet for our Main Menu.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Main Menu snippet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing how we plan to transport the code in our snippet into our codebase at
    some point is a great opportunity to invest the time and effort into making the
    process as quick, reliable, and accurate as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start with this by defining some aliases for the various `BABYLON` components
    and namespaces at the top of our snippet, just as we did back in [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049),
    *Establishing the Development Workflow*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There will be more items to add to this list as we involve additional `MainMenuScene`
    class definition from your local file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The items in the alias list that we just defined will need to be converted into
    **import** statements when integrated into the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re ready to integrate and commit our changes, we’ll update the local
    files by essentially performing the same thing in reverse. In the snippet’s `createScene`
    function, instantiate a new instance of `MainMenuScene` and return its scene property,
    and that will hook up our budding `MainMenuScene` class into the snippet’s rendering
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Short and sweet, we don’t have to think about this part of the snippet ever
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with the general environment and background setup for the scene,
    so scroll back up to the class definition and add a new instance method named
    `_setupBackgroundEnvironment`. This is where we will instantiate and configure
    the Starfield PT that serves as the background for the screen. It’s also where
    we’ll set up the texture to animate gradually over time to give the illusion of
    traveling through the starfield.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke `this._setupBackgroundEnvironment()` at the end of the constructor so
    we can use the run button immediately to see results. Before coding the body of
    the function though, add these types to the top alias definition list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HemisphericLight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StarfieldProceduralTexture` (put on its own line, you’ll thank yourself later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StandardMaterial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CylinderBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Texture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The scene already has a camera placed at -30 units from the origin and pointing
    at the origin, but it’s going to need a light and something for that light to
    illuminate as well. Instead of using a cubical mesh as a skybox, as we did with
    the Loading Screen, we’ll create a conical sort of shape made by making a tube
    with different radii for each end cap. Applying the Starfield PT to the interior
    of the cylinder requires us to set `backFaceCulling` to `false`, since we want
    to see the interior faces. To animate the starfield, we can simply increment the
    `time` property of `StarfieldProceduralTexture` before every frame is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`HemisphericLight` is a type of light source in Babylon.js that simulates an
    ambient environment type of lighting. There are a ton of interesting effects that
    you can achieve by messing around with the combination of **diffuse**, **specular**,
    and, unique to this type of light, **groundColor**, but we don’t need to do that
    right now since our needs are pretty simple.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the scene’s delta time by 1,000 is what sets the rate at which the
    starfield twinkles and shifts. Try removing the division statement and see what
    happens!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the function, we are following a similar pattern to what we did
    when we created the planetary orbits animation for the Loading Screen by registering
    an `onBeforeRenderObservable` and returning the **observer** for tidy later disposal.
    If all went well, clicking the **Run** button should display a nice picture of
    our starfield, twinkling and glittering as it slowly shifts.
  prefs: []
  type: TYPE_NORMAL
- en: Click `#16XY6Z` to see the full code for this snippet at this point in development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AdvancedDynamicTexture and GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be a lot to take in when it comes to the extensive functionality
    present in the Babylon.js 2D GUI system. More extensive documentation on the GUI
    APIs can be found at [https://doc.babylonjs.com/divingDeeper/gui/gui](https://doc.babylonjs.com/divingDeeper/gui/gui),
    but what we’re about to do with it now should either refresh your memory or provide
    enough of a foundation to begin learning. Add new types to the alias list, but
    instead of putting them in the `BABYLON` object, add a new `BABYLON.GUI` entry
    that is similar to the `BABYLON` entry, with the following types from the `BABYLON.GUI`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AdvancedDynamicTexture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackPanel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextBlock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new method called _`setupUi` to `MainMenuClass`, and add a line in the
    constructor to invoke it at the bottom of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not going to try to do anything fancy with the menu UI right now, so
    the first thing the _`setupUi` function needs to do is to create an instance of
    the `BABYLON.GUI.AdvancedDynamicTexture` class in the (default) fullscreen mode.
    This results in a 2D texture the size of the render canvas, with the controls
    painted on it, which is rendered on top of the scene in turn. One minor tweak
    we’ll make is to tell the texture to render at its ideal size – this will help
    avoid fuzziness in rendered text caused by down- or up- sampling effects. To allow
    other class instance methods to access the texture, assign it to the `_guiMenu`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we need to add a `Rectangle` control to contain the actual menu items.
    We don’t want it to be completely opaque, but it should have a contrasting background
    color or gradient.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Menu Container and Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For web developers and designers, there are a lot of what are hopefully comfortingly
    familiar concepts at play. A GUI control tree is a hierarchy similar to an `AdvancedDynamicTexture`
    either directly or indirectly. It’s often easiest to show this rather than describe
    it, so add the following code to define our menu’s container and basic appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The width is set as a percentage of the canvas size (`0.8`) so that the menu
    doesn’t cover the entire background, while the border width (thickness) is in
    pixels and the corner radius is specified in degrees – got all that?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Intellisense can be your best friend in providing quick descriptions of the
    numerous properties available on GUI controls, particularly when it comes to determining
    which units are in use (e.g., pixels or percentage).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to add an Image control to hold the background of the menu. Apropos
    of the Image, it’s easy to create a nice background image texture, but what use
    is it if it can’t be seen in the Playground? So, it’s time for a magic trick…
  prefs: []
  type: TYPE_NORMAL
- en: 'Image Aside: Bringing in External Content'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Babylon.js Playground has a feature configured in its web server’s configuration
    to allow **Cross-Origin Resource Sharing** (**CORS**) of content served from a
    number of well-known and established repository hosts, such as GitHub. By crafting
    the appropriate URL to our source repository, we can load textures, sounds, and
    models in our Playground snippet – just as with the **Babylon.js Asset Libraries**!
    By way of demonstrating how this works, add the following line to the very top
    of the snippet (first line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Breaking the URL down, here’s how you can apply this tactic to any publicly
    hosted GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the base URL of [raw.githubusercontent.com](http://raw.githubusercontent.com),
    add the path segments (in order) for the repository owner (or owning Organization)
    name, and the name of the repository itself – for example, `raw.githubusercontent.com/jelster/space-truckers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a path segment for the name of the branch or tag from which to retrieve
    the asset. For this book, the assets will be listed in their chapter’s respective
    branch, but for many other repositories, this will be `main`, `master`, or possibly
    `develop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add the rest of the path to the asset, including the file extension.
    Because there are pretty robust caching headers accompanying the responses for
    these files, it’s often a good idea during active content production to append
    a cache-using string such as the current date and time to the end of the URL so
    that you can be sure you’re always seeing the most current version of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the `menuBackground` URL, create an `Image` and add it to the `menuContainer`
    we previously added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Test out your progress by clicking **Run**, fixing any issues, then of course
    make sure to **Save** the snippet. To check yourself or to start with the latest
    snippet for this chapter, use **#16XY6Z#1**. This is how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and
    a semi-opaque gradient-filled rectangle that will contain menu items'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and
    a semi-opaque gradient-filled rectangle that will contain menu items'
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the Title and Menu Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Referring back to *Figure 4.2*, we can see that the menu screen can be divided
    up into a grid with two rows – one for the title and one for the menu items. To
    ensure that the buttons and selection icons all line up the way we want them to,
    we’ll need the grid to have three columns, each one-third of the width of the
    grid (which itself has a width of 0.8 or 80%). `addColumnDefinition` and `addRowDefinition`
    methods to accomplish this, making the setup very simple to add to our `_setupUi`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The title text is an important factor in defining a game or application’s look
    and feel through its font and display, but we’re going to be circling back to
    that topic in [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142)*, Processing
    Route Data*. For now, we’ll use the default font and ensure that it auto-sizes
    the text as needed. Vertically aligning `TextBlock` with the top of the grid will
    ensure that no matter how many buttons there are, the title will always stay where
    it belongs. A bit of styling to add shadows and padding results in code similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Check your work by running it and then save your progress. For those following
    along, this can be found at **#16XY6Z#2**. The next task is to write some functionality
    to populate the menu with selectable button items. We’ll be doing a bunch of these,
    so the less we have to repeat ourselves, the more keystrokes we can save.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the Menu with Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to how we added and then implemented the `_setupUi` function, we’ll
    start our latest task by adding an `_addMenuItems` function and constructor invocation
    expression to our class. We know that we want all the buttons of the menu to share
    a certain subset of property values, but not all of them. The properties that
    are unique to a given instance of a menu item can be defined by a simple object
    such as the following one defining the **Play** button’s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A button needs to have a unique name and it also needs some text to display.
    The foreground and background colors ought to be specific to each item, and of
    course, the action that is taken when the button is selected certainly qualifies
    as being specific to a given button. Within the `_addMenuItems` definition but
    before the `pbOpts` expression, add this local helper function to create and populate
    a button control with the given properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the button returned from our helper method, there’s just the matter of
    adding it to the menu grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the same functions of its `addControl` function of **Grid** accepts an
    optional **row** and **column** assignment as its second and third parameters,
    respectively. This lets us insert an item in the last row without knowing its
    index by getting the count of its child rows. We want buttons to be centered,
    so the column will always be the same – one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish the buttons by adding an exit button according to these options, and
    don’t forget to **Save**! To compare with the checkpoint snippet, see **#16XY6Z#3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We’ve come a long way in this chapter, but we’re not quite done yet. There’s
    been a lot of different things that we’ve been juggling so far, and all of the
    functionality we plan to build is completed – now, we just need to incorporate
    this functionality into the rest of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Menu Item Selection and Indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are a chunk of players who will want to and enjoy using a keyboard
    and mouse to play Space-Truckers, it should also be an enjoyable experience with
    a gamepad. In the next chapter, we’ll look at how to work with gamepad input in
    more detail, and to prepare for that, we need the main menu’s items to be selectable
    without invoking their actions and without the presence of a mouse pointer hovering
    over them. A selection indicator icon will serve this purpose, displaying the
    icon next to the currently selected menu item and showing the player what command
    or option will be invoked on the appropriate button press.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the visual aspect of the selected item, let’s add some supporting
    properties to our class in the form of a get and set pair of functions that we’ll
    call `selectedItemIndex`. Retrieving the value is simple using `return this_selectedItemIndex`.
    Setting it is a little bit more complicated. We want to ensure that the index
    doesn’t exceed the number of menu items and that upon reaching the end of the
    menu items, we want it to start over at the first item. There are other things
    that we want to enact when the selected item index changes, but a set method is
    not the place to do anything more than simple logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We saw the usage of `Scalar.Repeat` earlier, when animating planetary orbits.
    Then, we used it to ensure that the radian values stayed smoothly circular. Similarly,
    we want the selection to loop around smoothly once it reaches the end. The new
    item (highlighted in the preceding code) is for a class member that we haven’t
    yet declared, the `_selectedItemChanged` Observer.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating Selection and Reacting to Change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calling the `scene.onBeforeRenderObservable`. This time, however, we’re not
    using a built-in observable on a BJS object, but one that we’re declaring ourselves.
    The usage semantics are exactly the same as they are for the other ones we’ve
    used – calling the `add()` method to register a function to be invoked whenever
    the observable is triggered. Creating the observable is just as simple, done by
    creating a new `MainMenuScene` constructor, add code to create the `_selectedItemChanged`
    observable, then call its add method to register our selection’s changed logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the selection changes, the event handler is passed the newly-selected
    item’s index – its row in the grid. Sometimes, we might want to display non-selectable
    menu items, so we retrieve the selected item and then check the item retrieved
    from the second column of the selected row to see whether it’s `isEnabled`. If
    that’s not the case, then we increment `selectedItemIndex` – making sure to use
    the property setter and not directly changing the backing field’s value. The last
    part of our event handler again represents something we haven’t added yet – the
    selection icon. This hides the icon first before removing it from the grid and
    re-adding it at the new position. Moving backward now, again, add a method call
    to `this._createSelectorIcon()` to the `constructor`, then add the eponymous function
    declaration to the class. Here’s how the body of the function should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new `GUI.Image` using the final undeclared constant, the `selectionIcon`
    URL string. The rest of the method is boilerplate code we’ve written in the not-so-distant
    past.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid ambiguity with the HTML DOM Image type, the fully-qualified name is
    used in the Playground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the penultimate task of this section by adding the `selectionIcon`
    URL string at the top of the snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to substitute your image of choice for the one in the repository,
    and if you want to see it used in the production game, send us a **Pull Request**
    with it! Finally, we want to automatically select the first item in the menu,
    but only after the scene has completely finished loading and is waiting for user
    input. We do that by adding a simple line to the end of our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Clicking **Run** should show a finely crafted main menu – click **Save** and
    congratulate yourself. Look at how much you’ve accomplished during just this one
    pretty small section of one chapter of a (relatively) short book and contemplate
    how far you’ll be by the end! To compare your code for troubleshooting or catching
    up, see snippet **#16XY6Z#4**. The Main Menu looks nice, but despite the starfield
    twinkling in the background, it still needs a little bit of motion to give it
    some life and energy. Let’s be honest too – hornet yellow for the **Exit** button
    isn’t really the look we’re aiming for either, so let’s take a moment to correct
    those matters before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Improvements and Animating the Selection Idle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest change we want is to set the color property of our `ebOpts` object,
    all the way down in the `_createMenuItems` method, to the string color **black**.
    For the next change, we will add a small animation to the selection icon to make
    it look as though the truck is floating next to the menu item. This is a two-step
    process and the components of each individual step should be familiar from recent
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to track the current animation frame for the icon with a class
    member named `_selectorAnimationFrame`. Second, we need to register an `onBeforeRenderObservable`
    that will execute a new function, `_selectorIconAnimation`, before every frame
    is rendered in the scene. In that function, we increment the current frame (looping
    around if necessary) and use that value to compute the position of the icon along
    the vertical axis according to our circular standby – the **sine** function. This
    is what the animation function should resemble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The total time that it takes to go through a complete animation cycle is given
    by the first expression, while the amount of time (in seconds) elapsed since the
    last frame was rendered is given by the second. As we did before with `set selectedItemIndex`,
    we loop `_selectorAnimationFrame` here when it reaches the frame count, but we
    are scaling some values by arbitrary factors at the same time to yield the new
    `top` position (in pixels) that is set in the final line. Running this should
    result in a much more pleasing color for the **Exit** button as well as displaying
    a nice subtle floating appearance for the truck selection icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The Main Menu snippet complete with the floating animation of
    a truck icon](img/Figure_4.05_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The Main Menu snippet complete with the floating animation of a
    truck icon
  prefs: []
  type: TYPE_NORMAL
- en: If this is starting to feel repetitive, then that’s good, because it means that
    the material in this book is starting to sink in! Snippet **#16XY6Z#5** has the
    latest code; if you’ve not prepared your own, then navigate to this one and make
    sure you have VSCode open and ready to accept the application’s sparkling new
    Main Menu.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Main Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the potentially intimidating heading, there’s really not a whole lot
    we’ll need to do in order to incorporate all of the work from our snippets into
    the application’s code structure. In fact, after all of the effort and journeying
    we’ve done throughout this chapter, it may feel a bit anti-climactic when we finish
    this part of the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward and simple way to do it is to copy and paste the whole
    of the `MainMenuScene` class from the snippet into your local file, making sure
    to *entirely* replace the existing class declaration. You’ll need to only slightly
    adjust your `import` statements; here are the two most relevant lines where this
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the selection icon image asset, download the one at the snippet’s URL or
    make your own. Either way, add an `import` statement for it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Either wait for the development webpack output to finish or run the webpack
    process to test your changes, and don’t forget to commit and push your work –
    there’s no reason to lose work due to the omission of a few keystrokes. Earlier,
    when we went over our State Machine, we learned that in addition to the state
    behaviors, it’s important to define the transitions to and from those states.On
    the topic of transitions, here's one now!
  prefs: []
  type: TYPE_NORMAL
- en: Entering and Leaving Transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we’re looking at the integration of our Main Menu with the SpaceTruckerApplication
    State Machine, there are two functions that we’ve yet to implement and wire up.
    Those functions are the two transition functions for the main menu. In other words,
    we need to define the logic for what happens when we transition to the MENU state,
    as well as out of that state. Naming these new functions is actually pretty easy
    for once – `_onMenuEnter` and `_onMenuLeave`. While there might be more involved
    behavior we’d like to implement later, for now, we will say that when the menu
    either starts or ceases to be the current state of the application, we want it
    to fade in or out accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to accomplish this is by animating the `menuContainer.alpha`
    property between either `0` to `1` (entering) or `1` to `0` (leaving). As with
    the selection icon animation, we’ll need to store the current frame of `fadeIn`
    and `fadeOut`. Unlike the selection icon animation, we have a finite amount of
    time that the animation should last, so we also need to store the total `duration`
    value of the transition. Between every frame, we should set the current `alpha`
    value to one that is only slightly different from the previous value, so the transition
    appears smooth. Finally, when the animation ends, we want to (in the case of the
    leaving transition) set the menu’s visibility to `false`, along with any other
    clean-up that needs to happen. Interestingly enough, the logic for the enter and
    leave transitions is identical save for swapping the ranges in the `SmoothStep`
    function used to interpolate the `alpha` value. Here’s the `_onMenuEnter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the standard timer creation method in JavaScript of calling
    `setTimeout`, we’re using the `BABYLON.setAndStartTimer` utility function. By
    attaching `contextObservable` to `scene.onBeforeRenderObservable`, the `onTick`
    method is called consistently before each frame is rendered. The `onEnded` function
    is invoked when the name implies – after the timer has completed. In our case,
    we want to wait until the menu has transitioned in fully before showing the selection
    icon, so we set the `selectedItemIndex` there. In the constructor, we can replace
    the callback used with `scene.whenReadyAsync` to call our `onMenuEnter` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and run the app. You should see the menu fade in over the course
    of a couple of seconds before the selection item shows up. Learn more about this
    and other related functionality at https://doc.babylonjs.com/divingDeeper/events/observables#setandstarttimer,
    but maybe wait a tiny bit to do that – it’s time to finish off this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onMenuLeave` function is, as was mentioned earlier, almost identical to
    its `onMenuEnter` counterpart (with the exception of the `onEnded` callback),
    just swapping terms in `SmoothStep` (as follows). Add the `onMenuLeave` function
    with the changed expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Hooking up the `onMenuLeave` is easy: in the `_addMenuItems` method’s `ebOpts`
    object definition, change the `onInvoked` function to look something similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Save again and test your work to ensure it’s behaving as expected. This is looking
    and behaving excellently, but before we can pull over and rest, there’s one last
    thing left to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Menu Finishing Touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s a bit too quiet here for what should be an engaging and interesting main
    menu screen. We can fix that though, with the power of music! Although we’ll be
    covering the playing of sounds and music in more detail later, it’s too simple
    to pass the opportunity up, so here’s the quick and dirty version in as few words
    as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an import statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Load and play the music from the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Enjoy the vibes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: OK, so maybe the last part is getting a bit carried away; we do want to stop
    the music at some point. In the `onEnded` callback of `_onMenuLeave`, call `this._music.stop()`
    to stop the sound from playing when the **Exit** button is clicked. Once you’ve
    run the app and corrected any issues, it’s time to commit changes to source control
    and have a nice refreshing beverage – we’ve completed the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What a journey we’ve taken during this chapter. Some might prefer to think of
    it as more of a slog, and that’s not unfair – we’ve been wading through some pretty
    dense material here! Despite there being a fair bit of theory and high-level concepts
    tossed around, think back to what’s been accomplished over the course of this
    chapter – where we started was with a landing page that launches into an animation.
    Now, we have a landing page that launches into an *application*.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up next, we’re going to look at how to address the problem of accepting
    different forms and methods of input in a way that produces consistent and predictable
    behavior from the application – stick with us, and don’t be afraid to take your
    time to go back and re-read anything you didn’t understand the first time around.
    It’s amazing how much comprehension can require multiple passes to really take
    hold, but if that’s not working and you find you’re struggling to understand or
    follow along, no worries. Navigate to the Space-Trucker Discussions or the Babylon.js
    forums and post your question or problem to the community – you aren’t alone!
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Things are just getting some momentum, but that doesn’t mean there isn’t more
    to explore and extend what we’ve got already! Here are some ideas for things that
    you might look at, explore, or build into this chapter’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or extend the regular Babylon.js **Animation** type’s capabilities to
    include 2D **GUI** controls – or – implement a class that mimics the behavior
    of the Animation object with **GUI** controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you spot the defect in the `SpaceTruckerLoadingScreen.js` code? It’s a bit
    subtle if you’re reading through it in your head, but there’s definitely a logical
    defect in the code. Running it won’t cause any errors to be thrown but it does
    have effects that are visible at runtime under the right conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using a single, full-screen `AdvancedDynamicTexture`, use one or
    more mesh-attached textures that are painted onto the meshes in the scene, which
    can then be animated in interesting ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an attract mode that engages after the Main Menu has been displayed without
    user input for more than 30 seconds. An attract mode was an arcade game feature
    that puts the game into a non-interactive demo mode intended to catch the attention
    of passers-by. What is your idea for an attract mode?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
