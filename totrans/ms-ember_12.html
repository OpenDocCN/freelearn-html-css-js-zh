<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;12.&#xA0;Modularizing Your Project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Modularizing Your Project</h1></div></div></div><p class="calibre7">Many Ember.js projects get complex, and so it may be necessary to modularize the project for maintainability through a combination of any of the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Split the project into a number of script files and load them individually.</li><li class="listitem">Concatenate the script files into one build file. This reduces the number of requests the browser needs to make to the backend; hence, the page load time is reduced.</li><li class="listitem">Maintain reusable components that can be used on a number of projects.</li></ul></div><p class="calibre7">There are a number of open source tools that can be used to perform such tasks. These tools may contain the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A package manager that installs external reusable components</li><li class="listitem">A build process that intelligently concatenates all the project files into a single build file</li></ul></div><p class="calibre7">The following are some of these popular tools:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Grunt (a build tool)</li><li class="listitem">Gulp (a build tool)</li><li class="listitem">Bower (a package manager)</li><li class="listitem">NPM (a package manager)</li><li class="listitem">Browserify (a build tool)</li><li class="listitem">Ember CLI (a build tool)</li><li class="listitem">Brocolli (a build tool)</li><li class="listitem">Ember add-ons (<a class="calibre1" href="http://emberaddons.com">http://emberaddons.com</a>)</li><li class="listitem">Duojs (build tool and package manager based on Component and Browserify)</li><li class="listitem">Component (a build tool and package manager)</li></ul></div><p class="calibre7">Any of these can be used to get the job done in any combination. In this chapter, we will be discussing how to use <span class="strong"><strong class="calibre8">Component</strong></span> to easily manage complex Ember.js projects. It's worth noting that the ES6 module feature is being worked on to tackle these problems. Luckily, some of these tools are compliant with the specifications, thereby enabling easy migration.</p></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Modularizing Your Project">
<div class="book" title="Installing the Component build tool"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec112" class="calibre1"/>Installing the Component build tool</h1></div></div></div><p class="calibre7">Component is both <a id="id547" class="calibre1"/>a package manager and a build tool for client-side web projects. It provides the ability to install external project dependencies as<a id="id548" class="calibre1"/> well as organize a project into several local components that later can be built into a single build file. The chapter sample uses the tool to install and use the required project dependencies. To run the sample, we first need to install Node.js, which can be downloaded from <a class="calibre1" href="http://nodejs.org/download">http://nodejs.org/download</a>. To run the project, simply execute <code class="email">make</code> in a terminal shell. If the system doesn't have <code class="email">make</code> installed, the project can still be run with the following commands, the first of which installs the tool:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install</strong></span>
</pre></div><p class="calibre7">Component is an NPM package and can therefore be installed by adding the dependency to <code class="email">package.json</code>:</p><div class="informalexample"><pre class="programlisting">{ 
  "name": "2048", 
  "private": true, 
  "dependencies": { 
    "component": "^0.19.9" 
  } 
} </pre></div><p class="calibre7">Next, we install the external component dependencies and build the file using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">./node_modules/component/bin/component install</strong></span>
<span class="strong"><strong class="calibre8">./node_modules/component/bin/component build -n public -o public</strong></span>
</pre></div><p class="calibre7">The app can finally be opened by loading <code class="email">index.html</code> in the browser. This app is an implementation of the popular 2048 game (<a class="calibre1" href="http://gabrielecirulli.github.io/2048/">http://gabrielecirulli.github.io/2048/</a>) by Gabriele Cirulli, and takes advantage of the Ember.js' runtime. </p><p class="calibre7">The open source game, shown in the following screenshot, is a good introduction to web game development:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Installing the Component build tool" class="calibre10"/></div><p class="calibre11"> </p></div></div>
<div class="book" title="Code organization"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec113" class="calibre1"/>Code organization</h1></div></div></div><p class="calibre7">The Component tool <a id="id549" class="calibre1"/>requires a project to be organized into <code class="email">components</code>. A component is a reusable module that can contain scripts, styles, images, templates, and fonts defined in a <code class="email">component.json</code> configuration file. It can also optionally define dependencies that are themselves components. These dependencies can be local or remote. Therefore, a project can be thought of as a tree of components, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Code organization" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In this project, the <a id="id550" class="calibre1"/>root of the project defines a component <code class="email">2048</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">  "name": "2048", 
  "local": ["app"], 
  "paths": ["lib"] 
}</pre></div><p class="calibre7">This component doesn't include any scripts or styles because these are contained in child components, and so we do not have to specify them. It does, however, specify that it depends on a local component named <code class="email">app</code> that is found in the <code class="email">lib</code> relative directory, which in turn defines yet another local component dependency <code class="email">game</code>:</p><div class="informalexample"><pre class="programlisting">"local": [ 
  "game" 
],</pre></div></div>
<div class="book" title="Installing components"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec114" class="calibre1"/>Installing components</h1></div></div></div><p class="calibre7">A component<a id="id551" class="calibre1"/> can define remote components as dependencies. A remote component is an external Git repository that is hosted in either Github or BitBucket. Some versions of components allow the installation of components from other remote components as long as they adhere to a <code class="email">&lt;username&gt;/&lt;repo&gt;</code> format. In this case, the app component defines one dependency that will be installed from <a class="calibre1" href="http://github.com/kelonye/ember">http://github.com/kelonye/ember</a>:</p><div class="informalexample"><pre class="programlisting">"dependencies": { 
  "kelonye/ember": "1.7.0" 
}</pre></div><p class="calibre7">The game component, on the other hand, also defines three dependencies:</p><div class="informalexample"><pre class="programlisting">"dependencies": { 
  "yields/keycode": "1.1.0" ,
  "component/raf": "1.1.3", 
  "yields/store": "0.2.0"
}</pre></div><p class="calibre7">These components can be installed into the <code class="email">components/</code> relative directory by invoking the following in the project's root directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">./node_modules/component/bin/component install</strong></span>
</pre></div><p class="calibre7">We could also simply ask <code class="email">component install</code> if the module is installed globally with <code class="email">npm install -g component</code> or if <code class="email">./node_modules/.bin</code> is added to the bash profile PATH.</p></div>
<div class="book" title="Building components"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec115" class="calibre1"/>Building components</h1></div></div></div><p class="calibre7">Once the <a id="id552" class="calibre1"/>remote components have been installed, the project can be built by invoking the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">./node_modules/component/bin/component build</strong></span>
</pre></div><p class="calibre7">This concatenates scripts and styles into a <code class="email">builds</code> folder. By default, the folder is named <code class="email">build</code> but can be changed by passing the <code class="email">–out</code> or <code class="email">-o</code> flag. Also, by default, the built files are named <code class="email">build.js</code> and <code class="email">build.css</code>, but this can be altered using the <code class="email">–name</code> or <code class="email">-n</code> flag, for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">component build -o public -n public</strong></span>
</pre></div></div>
<div class="book" title="Loading the built files"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec116" class="calibre1"/>Loading the built files</h1></div></div></div><p class="calibre7">The built files <a id="id553" class="calibre1"/>are referenced from the build folder as follows:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" href="public/public.css"&gt;

&lt;script src="public/public.js"&gt;&lt;/script&gt; 
&lt;script&gt;require('app');&lt;/script&gt;</pre></div><p class="calibre7">Notice that the <a id="id554" class="calibre1"/>application is booted by <span class="strong"><em class="calibre9">requiring</em></span> the <code class="email">app</code> component. The <code class="email">app</code> component includes an <code class="email">index.js</code> file that gets executed in the process. Every requirable component needs to specify this file in its <code class="email">.scripts</code> property in the configuration file. It may also specify the main file via the <code class="email">.main</code> flag, so we can name the <code class="email">index.js</code> file as <code class="email">app.js</code> and then set the main flag as <code class="email">"app.js"</code>. The script requires the remotely-installed <code class="email">ember.js</code> component, creates the application, and defines the router:</p><div class="informalexample"><pre class="programlisting">require('ember'); 

window.App = Em.Application.create(); 

require('game'); 

App.Router.map(function(){ 
  this.route('game'); 
});</pre></div><p class="calibre7">A good way to organize local components is to separate them by the routes or resources defined in the router; in this case, the <code class="email">app</code> and <code class="email">game</code> components. Each of the components contains corresponding controllers, views, models, routes, and template scripts, explicitly defined in the configuration files:</p><div class="informalexample"><pre class="programlisting">"scripts": [ 
  "index.js", 
  "views.js", 
  "models.js", 
  "routes.js", 
  "templates.js", 
  "controllers.js" 
],</pre></div><p class="calibre7">These are required in the main script as follows:</p><div class="informalexample"><pre class="programlisting">require('./templates'); 
require('./models'); 
require('./views'); 
require('./controllers'); 
require('./routes'); </pre></div><p class="calibre7">The <code class="email">app</code> component defines two templates that are required accordingly:</p><div class="informalexample"><pre class="programlisting">// component.json
"templates": [ 
  "templates/application.html", 
  "templates/index.html" 
],

// template.js
function compile (template){ 
  return Em.Handlebars.compile(require(template)); 
}; 
[ 
  'application', 
  'index' 
].forEach(function(tmpl){ 
  Em.TEMPLATES[tmpl] = compile('./templates/'+tmpl+'.html'); 
});</pre></div><p class="calibre7">The preceding <a id="id555" class="calibre1"/>snippet registers the <code class="email">application</code> and <code class="email">index</code> templates to <code class="email">Em.TEMPLATES</code>. The application, index controllers, and routes are then required accordingly, as follows:</p><div class="informalexample"><pre class="programlisting">App.ApplicationController = Em.Controller.extend({ 
}); 

App.IndexController = Em.Controller.extend({ 
  needs: ['application'] 
});

App.ApplicationRoute = Em.Route.extend(); 

App.IndexRoute = Em.Route.extend({ 
  redirect: function(){ 
    this.transitionTo('game'); 
  } 
});</pre></div><p class="calibre7">Notice that the <code class="email">index</code> route redirects the application state to the game route.</p></div>
<div class="book" title="Game logic"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec117" class="calibre1"/>Game logic</h1></div></div></div><p class="calibre7">Before we <a id="id556" class="calibre1"/>discuss the <code class="email">game</code> component, it's a good idea to discuss the game logic:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The game is a 4 by 4 grid whose moves are made by sliding tiles using the keyboard arrow keys</li><li class="listitem">The tiles merge if they are of equal magnitude</li><li class="listitem">Each move generates a new random tile</li><li class="listitem">The objective of the game is to slide these tiles until one of them merges to a value of 2048</li></ul></div><p class="calibre7">The grid cells <a id="id557" class="calibre1"/>are represented by the <code class="email">App.Cell</code> model located in <code class="email">models.js</code>:</p><div class="informalexample"><pre class="programlisting">App.Cell = Em.Object.extend({ 

  x: null, 
  y: null, 
  value: null, 

  move: function(cell){ 
    var value = this.get('value'); 
    var nvalue = cell.get('value'); 
    var score = nvalue+this.get('value'); 
    cell.set('value', score); 
    this.set('value', 0); 
    if (value &amp;&amp; nvalue) return score; 
    return 0;
  },

  isTile: function(){ 
    return !!this.get('value'); 
  }.property('value'),

  is2048: function(){ 
    return this.get('value') == 2048; 
  }.property('value'),

});</pre></div><p class="calibre7">A cell is considered a tile if its value is defined. When the game begins, we first populate the game with the cells:</p><div class="informalexample"><pre class="programlisting">App.GameRoute = Em.Route.extend({ 
  setupController: function(controller, model) { 
    this._super(); 
    controller.addStartTiles(); 
  } 
});</pre></div><p class="calibre7">The game controller houses the cells and so we populate it accordingly:</p><div class="informalexample"><pre class="programlisting">App.GameController = Em.ArrayController.extend({ 
  needs: ['application'], 
  size: 4, 
  score: 0, 

  addStartTiles: function () { 

    var size = this.get('size'); 
    var rows; 

    this.setProperties({ 
      model: [], 
      tiles: [] 
    }); 

    for (var x = 0; x &lt; 4; x++){ 
      for (var y = 0; y &lt; 4; y++){ 
        var cell = App.Cell.create({ 
          x: x, 
          y: y 
        }); 
        this.pushObject(cell); 
      } 
    } 
  } 
});</pre></div><p class="calibre7">At this stage, we<a id="id558" class="calibre1"/> restore the saved game from the local storage using the <code class="email">store</code> component:</p><div class="informalexample"><pre class="programlisting">// restore 

var tiles = store('tiles'); 
var score = store('score'); 
var restored = tiles &amp;&amp; score; 
if (restored){ 
  
  tiles.forEach(function(tile){ 
    var x = Em.get(tile, 'next.x') || Em.get(tile, 'prev.x'); 
    var y = Em.get(tile, 'next.y') || Em.get(tile, 'prev.y'); 
    var value = Em.get(tile, 'next.value') || Em.get(tile, 'prev.value'); 
    var cell = self.find(function(_cell){ 
      return _cell.get('x') == x &amp;&amp; _cell.get('y') == y; 
    }); 
    if (cell) cell.set('value', value); 
  }); 

  this.get('tiles').pushObjects(tiles); 
  this.set('score', Number(score)); 

  store('tiles', undefined); 
  store('score', undefined); 
} </pre></div><p class="calibre7">In addition, we<a id="id559" class="calibre1"/> cache the traversals for the four possible game move directions that we will need to make at this stage. For example, when the user makes an upward move, we will traverse cells from the left to the right and downwards:</p><div class="informalexample"><pre class="programlisting">var traversals = Em.Object.create(); 

// 'up' 

rows = []; 
for (var x = 0; x &lt; size; x++){ 
  var row = []; 
  for (var y = 0; y &lt; size; y++){ 
    var cell = this.find(function(_cell){ 
      return _cell.get('x') == x &amp;&amp; _cell.get('y') == y; 
    }); 
    row.pushObject(cell); 
  } 
  rows.pushObject(row); 
} 
traversals.set('up', rows);</pre></div><p class="calibre7">Next, we will generate the first two tiles of the game if its state is not restored:</p><div class="informalexample"><pre class="programlisting">// generate 2 random tiles 

if (!restored){ 
  for (var i = 0; i &lt; 2; i++) { 
    this.get('tiles').pushObject(this.getRandomTile()); 
  } 
}</pre></div><p class="calibre7">The random tile generator simply picks a random cell and converts it into a tile by setting its value to either <code class="email">2</code> or <code class="email">4</code> if the game hasn't ended:</p><div class="informalexample"><pre class="programlisting">getRandomTile: function () { 
  if (this.hasAvailableCells()) { 
    var value = Math.random() &lt; 0.9 
      ? 2 
      : 4; 
    var tile = this.getRandomAvailableCell(); 
    tile.set('value', value); 
    return { 
      prev: tile 
    }; 
  } 
},</pre></div><p class="calibre7">The game view sets up a listener to play the moves:</p><div class="informalexample"><pre class="programlisting">App.GameView = Em.View.extend({ 
  didInsertElement: function(){ 
    var self = this; 
    this._super(); 
    $(document).on('keydown', function(event){ 
      event.preventDefault(); 
      self.get('controller').send('onMove', event.which); 
    }); 
  }, 
});</pre></div><p class="calibre7">When the user <a id="id560" class="calibre1"/>makes a play, we send the key code of the pressed key to the game controller's <code class="email">onMove</code> action. If the game hasn't ended, the action will first determine which direction the play was made in, with the help of the <code class="email">keycode</code> component:</p><div class="informalexample"><pre class="programlisting">if (self.hasEnded()) return self.endGame(false);

var dir = [ 
  { 
    name: 'up', 
    vector: {x: 0, y: -1} 
  }, { 
    name: 'right', 
    vector: {x: 1, y: 0} 
  }, { 
    name: 'down', 
    vector: {x: 0, y: 1} 
  }, { 
    name: 'left', 
    vector: {x: -1, y: 0} 
  } 
].find(function(_dir){ 
  return keycode(_dir.name) == code; 
});</pre></div><p class="calibre7">The next step is to find the traversal matrix that corresponds to the direction of the play:</p><div class="informalexample"><pre class="programlisting">if (dir){ 
  var traversals = self.get('traversals.'+dir.name); 
}</pre></div><p class="calibre7">We then traverse through the cells and attempt to move the tile, if eligible:</p><div class="informalexample"><pre class="programlisting">try { 
  var tiles = [];
  var moved;
  var traversals = self.get('traversals.'+dir.name); 
  traversals.forEach(function(row){ 
    row.forEach(function(cell){ 
      if (cell.get('isTile')){ 

      } 
    }); 
  }); 

} catch (e) { 
  self.endGame(e.won); 
}</pre></div><p class="calibre7">For each of these<a id="id561" class="calibre1"/> tiles, we find the farthest new cell that it can occupy, by calling the <code class="email">getNewFarthestCell</code> controller method:</p><div class="informalexample"><pre class="programlisting">var ncell = self.getNewFarthestCell(cell, dir.vector, 0);</pre></div><p class="calibre7">This method takes the cell to move the trajectory vector and the magnitude of the movement:</p><div class="informalexample"><pre class="programlisting">getNewFarthestCell: function(cell, dir, mag){

},</pre></div><p class="calibre7">The method is meant to be recursive, that is, we incrementally move the cell in the direction of the game until we find the farthest cell. First, we find the position of the current, previous, and next cells, as follows:</p><div class="informalexample"><pre class="programlisting">++mag; 

var traversals = this.get('traversals.up'); 
var x = cell.get('x'); 
var y = cell.get('y'); 
var value = cell.get('value'); 

var nx = x + dir.x * mag; 
var ny = y + dir.y * mag; 

var px = x + dir.x * (mag - 1); 
var py = y + dir.y * (mag - 1);
  var pcell = traversals[px][py];</pre></div><p class="calibre7">We then check to see whether the cell is off the grid:</p><div class="informalexample"><pre class="programlisting">var nrow = traversals[nx]; // cell is x outbound 
if (!nrow) return ret();

  var ncell = nrow[ny]; // cell is y outbound 
  if (!ncell) return ret(); </pre></div><p class="calibre7">If the new<a id="id562" class="calibre1"/> cell is indeed outbound, we return the previous cell as the new position of the tile. However, if we encounter a tile, we test whether the two can be merged:</p><div class="informalexample"><pre class="programlisting">// cell cannot be merged 
var nvalue = ncell.get('value'); 
if (nvalue &amp;&amp; value &amp;&amp; nvalue != value) return ret();</pre></div><p class="calibre7">If the preceding conditions aren't met, we proceed to test the next cell:</p><div class="informalexample"><pre class="programlisting">return this.getNewFarthestCell(cell, dir, mag);</pre></div><p class="calibre7">Next, we check to see whether the cell can actually move to the new position:</p><div class="informalexample"><pre class="programlisting">if (ncell &amp;&amp; ncell != cell){
}</pre></div><p class="calibre7">Then, we need a state that determines whether a cell moved within that iteration for later reference:</p><div class="informalexample"><pre class="programlisting">if (!moved){ 
  moved = true; 
}</pre></div><p class="calibre7">If a merge has already occurred, then we need to use the cell just before it:</p><div class="informalexample"><pre class="programlisting">if (merged &amp;&amp; ncell.get('isTile')) { 
  ncell = pcell; 
}</pre></div><p class="calibre7">Finally, we move the tile and increment the game's score:</p><div class="informalexample"><pre class="programlisting">var score = cell.move(ncell); 
self.set('score', self.get('score') + score); </pre></div><p class="calibre7">Since the tile has moved, we add it to the new set of tiles that would be rendered on repaint:</p><div class="informalexample"><pre class="programlisting">tiles.pushObject({ 
  prev: cell, 
  next: ncell 
});</pre></div><p class="calibre7">For each merge in the iteration, we need to check whether the game has been won or lost:</p><div class="informalexample"><pre class="programlisting">if (self.hasEnded()){ 
  var err = new Error; 
  err.type = 'end-game'; 
  err.won = false; 
  throw err; 
} else if (ncell.get('is2048')){ 
  var err = new Error; 
  err.type = 'end-game'; 
  err.won = true; 
  throw err; 
}</pre></div><p class="calibre7">As per Gabriele's game <a id="id563" class="calibre1"/>specification, a new random tile can only be generated if any of the existing tiles move after the end of the iterations:</p><div class="informalexample"><pre class="programlisting">if (moved){ 
  tiles.pushObject(self.getRandomTile()); 
  self.set('tiles', tiles); 
}</pre></div><p class="calibre7">Finally, we need to check if the game has ended by catching the raised exception:</p><div class="informalexample"><pre class="programlisting">if (e.type == 'end-game'){ 
  self.set('tiles', tiles); 
  self.endGame(e.won); 
} else { 
  console.err(err); 
}</pre></div><p class="calibre7">The method that is called displays a message overlay, indicating whether the game has been won or not:</p><div class="informalexample"><pre class="programlisting">endGame: function(won){ 
  var classes = ['game-won', 'game-over']; 
  var type    = won ? classes[0] : classes[1]; 
  var message = won ? 'You win!' : 'Game over!'; 
  $('.game-message') 
    .removeClass(classes) 
    .addClass(type) 
    .html('&lt;p&gt;'+message+'&lt;/p&gt;') 
    .show(); 
  }, </pre></div><p class="calibre7">The <code class="email">game</code> template, found in <code class="email">templates/game.html</code>, reacts to changes in the bound controller. First, the <code class="email">New Game</code> button's click event is bound to the <code class="email">createNewGame</code> action:</p><div class="informalexample"><pre class="programlisting">&lt;a class="restart-button" {{action 'createNewGame'}}&gt;New Game&lt;/a&gt;

createNewGame: function(){ 
  this.addStartTiles(); 
  this.set('score', 0); 
  $('.game-message').hide(); 
}</pre></div><p class="calibre7">The score label is bound to the controller's <code class="email">score</code> property:</p><div class="informalexample"><pre class="programlisting">&lt;div class="score-container"&gt;{{score}}&lt;/div&gt;</pre></div><p class="calibre7">The grid is <a id="id564" class="calibre1"/>composed of cells overlaid by tiles, and so we first lay out the 16 cells as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="grid-container"&gt; 
  {{#each row in traversals.up}} 
  &lt;div class="grid-row"&gt; 
    {{#each cell in row}} 
    &lt;div class="grid-cell"&gt;&lt;/div&gt; 
    {{/each}} 
  &lt;/div&gt; 
  {{/each}} 
&lt;/div&gt;</pre></div><p class="calibre7">Next, we lay out the tiles:</p><div class="informalexample"><pre class="programlisting">&lt;div class="tile-container"&gt; 

  {{#each tiles}} 
  {{#view App.TileView prevBinding='prev' nextBinding='next'}} 
    &lt;div class="tile-inner"&gt;{{view.value}}&lt;/div&gt; 
  {{/view}} 
  {{/each}}

&lt;/div&gt;</pre></div><p class="calibre7">The main role of <code class="email">App.TileView</code>
<a id="id565" class="calibre1"/> is to animate the tile movement as well as showing the different tile shades based on their values. Now, getting a smooth slide transition is a bit tricky. Once a tile view has been inserted into the DOM, we first set the initial position of the tile in <code class="email">didInsertElement</code>:</p><div class="informalexample"><pre class="programlisting">var prev = classes('prev'); 
var next = classes('next'); 
var hasNext = !!self.get('next.value'); 

if (!hasNext) prev.pushObject('tile-new'); 

self.set('tileClasses', prev.join(' ')); </pre></div><p class="calibre7">If the tile is in motion, we use the <code class="email">requestAnimationFrame</code> component<a id="id566" class="calibre1"/> to set the new position before the next browser repaint:</p><div class="informalexample"><pre class="programlisting">if (hasNext){ 
  raf(function(){ 
    self.set('tileClasses', next.join(' ')); 
  }); 
}</pre></div></div>
<div class="book" title="Serving images and fonts"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec118" class="calibre1"/>Serving images and fonts</h1></div></div></div><p class="calibre7">Images and fonts <a id="id567" class="calibre1"/>specified in styles can be referenced using their corresponding relative paths, as shown in the first line of the game component's style sheet:</p><div class="informalexample"><pre class="programlisting">@import url(fonts/clear-sans.css);</pre></div><p class="calibre7">Component automatically resolves these paths:</p><div class="informalexample"><pre class="programlisting">@import url("game/styles/fonts/clear-sans.css");</pre></div><p class="calibre7">Notice that the assets are symbolically linked to the build folder. If needed, we can prefix these paths with the required static root. For example, if Django was used to server these files, we would add a prefix flag to the build command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">component build –prefix /static</strong></span>
</pre></div><p class="calibre7">This would result in a path such as this:</p><div class="informalexample"><pre class="programlisting">@import url("/static/game/styles/fonts/clear-sans.css");</pre></div><p class="calibre7">On some platforms, symbolical links may cause problems, so you can pass the <code class="email">copy</code> flag to copy the files instead of linking them, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">component build --copy</strong></span>
</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec119" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">Component is a great tool that you can use to organize your Ember.js project. It's a great tool that can be used to install and reuse tiny components hosted in Github. As a rule of thumb, publish Ember.js components as either mixins or those that extend the <code class="email">Em.Component</code> class. For example, the component at <a class="calibre1" href="http://github.com/kelonye/ember-link">http://github.com/kelonye/ember-link</a> is an example of a good minimal component that can be extended into any project view:</p><div class="informalexample"><pre class="programlisting">require('ember'); 

module.exports = Em.Mixin.create({ 
  tagName: 'a', 
  href: 'javascript:', 
  attributeBindings: 'href target'.w() 
});</pre></div><p class="calibre7">This way, the Ember.js community can benefit from commonly used snippets that result in faster project developments.</p></div></body></html>