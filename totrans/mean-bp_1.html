<html><head></head><body>
<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager"><div class="book" id="F8902-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Contact Manager</h1></div></div></div><p class="calibre8">In this chapter, you'll learn how to build a Contact manager application. The application will be divided into two separate parts: one part consisting of the backend, our Node.js API written using Express, and the client application crafted using Angular 2.</p><p class="calibre8">Don't worry! This chapter <a id="id0" class="calibre1"/>will be more of a guideline, setting up a base project and wrapping your head around TDD (short for <span class="strong"><strong class="calibre2">Test-driven development</strong></span>) in <a id="id1" class="calibre1"/>Node.js. We'll also get to see Angular 2 in action. We are not going to write tests on the client side as there are enough things to accumulate in one chapter.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>Setting up the base application</h1></div></div></div><p class="calibre8">The best <a id="id2" class="calibre1"/>way to start is with a solid base. That's why we are going to focus on building the base structure of our application. A good <a id="id3" class="calibre1"/>base gives you modularity and flexibility and also files should be easily located by you and even your team members.</p><p class="calibre8">Always start with something simple and start building around it. As your application grows, you'll probably outgrow your initial application structure, so thinking ahead will bring you big benefits in the long run.</p></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="Folder structure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Folder structure</h2></div></div></div><p class="calibre8">Before <a id="id4" class="calibre1"/>jumping in and building your features right away, you should take a moment and sketch out your initial application's structure. In the planning process, a pen and paper should always do it, but I've already saved some time and come up with an initial version:</p><div class="informalexample"><pre class="programlisting">app/
--controllers/
--middlewares/
--models/
--routes/
config/
--environments/
--strategies/
tests/
--integration/
--unit/
public/
--app/
--src/
--assets/
--typings/
--package.json
--tsconfig.json
--typings.json
package.json
server.js</pre></div><p class="calibre8">Let's take a look at a more detailed explanation of our folder structure:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">app</code>: This folder contains all the server files used in the application:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">controllers</code>: This folder is going to store the application controllers, mainly the backend business logic.</li><li class="listitem"><code class="email">middlewares</code>: In this folder, we'll store all our pieces of functions that will manipulate the request and response object. A good <a id="id5" class="calibre1"/>example would be an authentication middleware.</li><li class="listitem"><code class="email">models</code>: This folder will store all the backend models.</li><li class="listitem"><code class="email">routes</code>: This folder will contain all the routing files, which is where we are going to define all Express routes.</li></ul></div></li><li class="listitem"><code class="email">config</code>: All application configuration files go here:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">environments</code>: This folder contains files loaded according to the current environment</li><li class="listitem"><code class="email">strategies</code>: All your authentication strategies should go here</li></ul></div></li><li class="listitem"><code class="email">tests</code>: This folder contains all the tests necessary to test the application backend logic:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">integration</code>: If something uses external modules, it's good practice to create an integration test</li><li class="listitem"><code class="email">unit</code>: This should contain tests for small units of code, such as password hashing</li></ul></div></li><li class="listitem"><code class="email">public</code>: This should contain all the static files served by our application. I like this separation because it's easy to just tell another web server to handle our static files. Let's say you want nginx to handle static file serving:<div class="book"><ul class="itemizedlist1"><li class="listitem"><code class="email">app</code>: This is our client-side application's folder. All compiled TypeScript files will go here. This folder should be automatically populated.</li><li class="listitem"><code class="email">src</code>: This folder contains all the client-side files used to build our application. We are going to use TypeScript to build our Angular application.</li><li class="listitem"><code class="email">typings</code>: This <a id="id6" class="calibre1"/>contains TypeScript definitions.</li></ul></div></li></ul></div></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="Server-side package.json"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>Server-side package.json</h2></div></div></div><p class="calibre8">After <a id="id7" class="calibre1"/>setting up the initial folder structure, the next thing to do is to create the <code class="email">package.json</code> file. This file will hold all the application's metadata and dependencies. The <code class="email">package.json</code> file will be placed at the root of our project folder. The path should be <code class="email">contact-manager/package.json</code>:</p><div class="informalexample"><pre class="programlisting">{
  "name": "mean-blueprints-contact-manager",
  "version": "0.0.9",
  "repository": {
    "type": "git",
    "url": "https://github.com/robert52/mean-blueprints-cm.git"
  },
  "engines": {
    "node": "&gt;=4.4.3"
  },
  "scripts": {
    "start": "node app.js",
    "unit": "node_modules/.bin/mocha tests/unit/ --ui bdd --recursive --reporter spec --timeout 10000 --slow 900",
    "integration": "node_modules/.bin/mocha tests/integration/ --ui bdd --recursive --reporter spec --timeout 10000 --slow 900",
    "less": "node_modules/.bin/autoless public/assets/less public/assets/css --no-watch",
    "less-watch": "node_modules/.bin/autoless public/assets/less public/assets/css"
  },
  "dependencies": {
    "async": "^0.9.2",
    "body-parser": "^1.15.0",
    "connect-mongo": "^1.1.0",
    "express": "^4.13.4",
    "express-session": "^1.13.0",
    "lodash": "^3.10.1",
    "method-override": "^2.3.5",
    "mongoose": "^4.4.12",
    "passport": "^0.2.2",
    "passport-local": "^1.0.0",
    "serve-static": "^1.10.2"
  },
  "devDependencies": {
    "autoless": "^0.1.7",
    "chai": "^2.3.0",
    "chai-things": "^0.2.0",
    "mocha": "^2.4.5",
    "request": "^2.71.0"
  }
}</pre></div><p class="calibre8">We added a few scripts to our <code class="email">package.json</code> file to run our unit and integration tests and compile the Less files. You can always use <code class="email">npm</code> to directly run different scripts instead of using build <a id="id8" class="calibre1"/>tools such as Grunt or Gulp.</p><p class="calibre8">At the time of writing this book, we are using the defined dependencies and their versions. This should do it for now. Let's install them using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ npm install</strong></span>
</pre></div><p class="calibre8">You should see <code class="email">npm</code> pulling a bunch of files and adding the necessary dependencies to the <code class="email">node_modules</code> folder. Wait patiently until everything is installed and done. You will be returned to Command Prompt. Now you should see the <code class="email">node_modules</code> folder created and with all the dependencies in place.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="The first application file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec10" class="calibre1"/>The first application file</h2></div></div></div><p class="calibre8">Before <a id="id9" class="calibre1"/>everything, we need to create a simple configuration file for our environment. Let's create the file in the <code class="email">config</code> folder at <code class="email">contact-manager/config/environments/development.js</code> and add the following content:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports = {
  port: 3000,
  hostname: '127.0.0.1',
  baseUrl: 'http://localhost:3000',
  mongodb: {
    uri: 'mongodb://localhost/cm_dev_db'
  },
  app: {
    name: 'Contact manager'
  },
  serveStatic: true,
  session: {
    type: 'mongo',
    secret: 'u+J%E^9!hx?piXLCfiMY.EDc',
    resave: false,
    saveUninitialized: true
  }
};</pre></div><p class="calibre8">Now let's <a id="id10" class="calibre1"/>create the main <code class="email">server.js</code> file for our application. This file will be the heart of our application. The file should be in the root of our folder, <code class="email">contact-manager/server.js</code>. Start with the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

// Get environment or set default environment to development
const ENV = process.env.NODE_ENV || 'development';
const DEFAULT_PORT = 3000;
const DEFAULT_HOSTNAME = '127.0.0.1';

const http = require('http');
const express = require('express');
const config = require('./config');
const app = express();

var server;

// Set express variables
app.set('config', config);
app.set('root', __dirname);
app.set('env', ENV);

require('./config/mongoose').init(app);
require('./config/models').init(app);
require('./config/passport').init(app);
require('./config/express').init(app);
require('./config/routes').init(app);

// Start the app if not loaded by another module
if (!module.parent) {
  server = http.createServer(app);
  server.listen(
    config.port || DEFAULT_PORT,
    config.hostname || DEFAULT_HOSTNAME,
    () =&gt; {
      console.log(`${config.app.name} is running`);
      console.log(`   listening on port: ${config.port}`);
      console.log(`   environment: ${ENV.toLowerCase()}`);
    }
  );
}

module.exports = app;</pre></div><p class="calibre8">We define some of our main dependencies and initialize the necessary modules of our application. To <a id="id11" class="calibre1"/>modularize things, we are going to put each package of our stack into a separate configuration file. These configuration files will have some logic in them. I like to call them smart configuration files. </p><p class="calibre8">Don't worry! We are going to go through each config file one by one. Finally, we will export our Express app instance. If our module is not loaded by another module, for example, a test case, then we can safely start listening to incoming requests.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="Creating the Express configuration file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec11" class="calibre1"/>Creating the Express configuration file</h2></div></div></div><p class="calibre8">We <a id="id12" class="calibre1"/>need to <a id="id13" class="calibre1"/>create a configuration file for Express. The file should be created in the <code class="email">config</code> folder at <code class="email">contact-manager/config/express.js</code> and we have to add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const path = require('path');
const bodyParser = require('body-parser');
const methodOverride = require('method-override');
const serveStatic = require('serve-static');
const session = require('express-session');
const passport = require('passport');
const MongoStore = require('connect-mongo')(session);
const config = require('./index');

module.exports.init = initExpress;

function initExpress(app) {
  const root = app.get('root');
  const sessionOpts = {
    secret: config.session.secret,
    key: 'skey.sid',
    resave: config.session.resave,
    saveUninitialized: config.session.saveUninitialized
  };

  //common express configs
  app.use(bodyParser.urlencoded({ extended: true }));
  app.use(bodyParser.json());
  app.use(methodOverride());
  app.disable('x-powered-by');

  if (config.session.type === 'mongo') {
    sessionOpts.store = new MongoStore({
      url: config.mongodb.uri
    });
  }

  app.use(session(sessionOpts));
  app.use(passport.initialize());
  app.use(passport.session());

  app.use(function(req, res, next) {
    res.locals.app = config.app;

    next();
  });

  // always load static files if dev env
  if (config.serveStatic) {
    app.use(serveStatic(path.join(root, 'public')));
  }
};</pre></div><p class="calibre8">You should <a id="id14" class="calibre1"/>be familiar with many lines from the preceding code by now, for example, setting the desired <a id="id15" class="calibre1"/>body parser of our Express application. Also, we set up the session management, and just in case we set to the server static files, we define the path to the server files.</p><p class="calibre8">In a production environment, you should use something different from the default in-memory storage for sessions. That's why we added a special session store, which will store data in MongoDB.</p><p class="calibre8">A good practice to get the global environment configuration file is to set a root config file that all application files will load, create a new file called <code class="email">contact-manager/config/index.js</code>, and add this code to it:</p><div class="informalexample"><pre class="programlisting">'use strict';

var ENV = process.env.NODE_ENV || 'development';
var config = require('./environments/'+ENV.toLowerCase());

module.exports = config;</pre></div><p class="calibre8">The preceding <a id="id16" class="calibre1"/>code will just load the necessary environment configuration file based on the <code class="email">NODE_ENV</code> process environment variable. If the environment variable is not present, a default development <a id="id17" class="calibre1"/>state will be considered for the application. This is a good practice so that we don't make mistakes and connect to the wrong database. </p><p class="calibre8">Usually, the <code class="email">NODE_ENV</code> variable can be set when you start your node server; for example, under Unix systems, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ NODE_ENV=production node server.js</strong></span>
</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="Setting up mocha for testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec12" class="calibre1"/>Setting up mocha for testing</h2></div></div></div><p class="calibre8">Before we <a id="id18" class="calibre1"/>implement <a id="id19" class="calibre1"/>any functionality, we are going to write tests for it. Mocha is a testing framework built on Node.js. This approach will give us the advantage of knowing what code we are going to write and testing our Node.js API before even writing a single line of the client application.</p><p class="calibre8">If you don't have Mocha, you can install it globally. If you want Mocha to be globally available in your command line, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ npm install -g mocha</strong></span>
</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Contact Manager">
<div class="book" title="Setting up the base application">
<div class="book" title="Setting up Mongoose"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch01lvl2sec13" class="calibre1"/>Setting up Mongoose</h2></div></div></div><p class="calibre8">In order to <a id="id20" class="calibre1"/>store data in MongoDB, we <a id="id21" class="calibre1"/>are going to use Mongoose. Mongoose provides an easy way to define schemas to model application data. We have already included mongoose in the <code class="email">package.json</code> file, so it should be installed.</p><p class="calibre8">We need to create a config file for our mongoose library. Let's create our config file <code class="email">contact-manager/config/mongoose.js</code>. First, we start by loading the Mongoose library, getting the appropriate environment config, and establishing a connection with the database. Add <a id="id22" class="calibre1"/>the following <a id="id23" class="calibre1"/>code to the <code class="email">mongoose.js</code> file:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const config = require('./index');

module.exports.init = initMongoose;

function initMongoose(app) {
  mongoose.connect(config.mongodb.uri);

  // If the Node process ends, cleanup existing connections
  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('SIGHUP', cleanup);

  if (app) {
    app.set('mongoose', mongoose);
  }

  return mongoose;
};

function cleanup() {
  mongoose.connection.close(function () {
    console.log('Closing DB connections and stopping the app. Bye bye.');
    process.exit(0);
  });
}</pre></div><p class="calibre8">Also, we are using a <code class="email">cleanup()</code> function to close all connections to the MongoDB database. The preceding code will export the necessary <code class="email">init()</code> function used in the main <code class="email">server.js</code> file.</p></div></div></div>

<div class="book" title="Managing contacts"><div class="book" id="G6PI2-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Managing contacts</h1></div></div></div><p class="calibre8">Now that we <a id="id24" class="calibre1"/>have the files necessary to start <a id="id25" class="calibre1"/>development and add features, we can start implementing all of the business logic related to managing contacts. To do this, we first need to define the data model of a contact.</p></div>

<div class="book" title="Managing contacts">
<div class="book" title="Creating the contact mongoose schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec14" class="calibre1"/>Creating the contact mongoose schema</h2></div></div></div><p class="calibre8">Our system <a id="id26" class="calibre1"/>needs some sort of functionality to store the possible clients or just contact persons of other companies. For this, we are going to create a contact schema that will represent the same collection storing all the contacts in MongoDB. We are going to keep our contact schema simple. Let's create a model file in <code class="email">contact-manager/app/models/contact.js</code>, which will hold the schema, and add the following code to it:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

var ContactSchema = new Schema({
  email:  {
    type: String
  },
  name: {
    type: String
  },
  city: {
    type: String
  },
  phoneNumber: {
    type: String
  },
  company: {
    type: String
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// compile and export the Contact model
module.exports = mongoose.model('Contact', ContactSchema);</pre></div><p class="calibre8">The following table gives a description of the fields in the schema:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Field</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">email</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The e-mail of the contact</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">name</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The full name of the contact</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">company</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The name of the company at which the contact person works</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">phoneNumber</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The full phone number of the person or company</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">city</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The location of the contact</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">createdAt</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The date at which the contact object was created</p>
</td></tr></tbody></table></div><p class="calibre8">All our <a id="id27" class="calibre1"/>model files will be registered in the following configuration file, found under <code class="email">contact-manager/config/models.js</code>. The final version of this file will look something like this:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports.init = initModels;

function initModels(app) {
  let modelsPath = app.get('root') + '/app/models/';

  ['user', 'contact'].forEach(function(model) {
    require(modelsPath + model);
  });
};</pre></div></div></div>

<div class="book" title="Managing contacts">
<div class="book" title="Describing the contact route"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec15" class="calibre1"/>Describing the contact route</h2></div></div></div><p class="calibre8">In order to <a id="id28" class="calibre1"/>communicate with the server, we need to expose routes for client applications to consume. These are going to be endpoints (URIs) that respond to client requests. Mainly, our routes will send a JSON response.</p><p class="calibre8">We are going to start by describing the CRUD functionality of the contact module. The routes should expose the following functionalities:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create a new contact</li><li class="listitem">Get a contact by ID</li><li class="listitem">Get all contacts</li><li class="listitem">Update a contact</li><li class="listitem">Delete a contact by ID</li></ul></div><p class="calibre8">We are not going to cover bulk insert and delete in this application.</p><p class="calibre8">The <a id="id29" class="calibre1"/>following table shows how these operations can be mapped to HTTP routes and verbs:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Route</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Verb</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Data</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/contacts</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">POST</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Create a new contact</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">email</code>, <code class="literal">name</code>, <code class="literal">company</code>, <code class="literal">phoneNumber</code>, and <code class="literal">city</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/contacts</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">GET</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Get all contacts from the system</p>
</td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/contacts/&lt;id&gt;</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">GET</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Get a particular contact</p>
</td><td valign="top" class="calibre21"> </td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/contacts/&lt;id&gt;</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">PUT</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Update a particular contact</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">email</code>, <code class="literal">name</code>, <code class="literal">company</code>, <code class="literal">phoneNumber</code>, and <code class="literal">city</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">/contacts/&lt;id&gt;</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">DELETE</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Delete a particular contact</p>
</td><td valign="top" class="calibre21"> </td></tr></tbody></table></div><p class="calibre8">Following the earlier table as a guide, we are going to describe our main functionality and test using Mocha. Mocha allows us to describe the features that we are implementing by giving us the ability to use a describe function that encapsulates our expectations. The first argument of the function is a simple string that describes the feature. The second argument is a function body that represents the description.</p><p class="calibre8">You have already created a folder called <code class="email">contact-manger/tests</code>. In your <code class="email">tests</code> folder, create another folder called <code class="email">integration</code>. Create a file called <code class="email">contact-manager/tests/integration/contact_test.js</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

/**
 * Important! Set the environment to test
 */
process.env.NODE_ENV = 'test';

const http = require('http');
const request = require('request');
const chai = require('chai');
const userFixture = require('../fixtures/user');
const should = chai.should();

let app;
let appServer;
let mongoose;
let User;
let Contact;
let config;
let baseUrl;
let apiUrl;

describe('Contacts endpoints test', function() {

  before((done) =&gt; {
    // boot app
    // start listening to requests
  });

  after(function(done) {
    // close app
    // cleanup database
    // close connection to mongo
  });

  afterEach((done) =&gt; {
    // remove contacts
  });

  describe('Save contact', () =&gt; {});

  describe('Get contacts', () =&gt; {});

  describe('Get contact', function() {});

  describe('Update contact', function() {});

  describe('Delete contact', function() {});
});</pre></div><p class="calibre8">In our test file, we required our dependencies and used Chai as our assertion library. As you can see, besides the <code class="email">describe()</code> function, mocha gives us additional methods: <code class="email">before()</code>, <code class="email">after()</code>, <code class="email">beforeEach()</code>, and <code class="email">afterEach()</code>.</p><p class="calibre8">These are <a id="id30" class="calibre1"/>hooks and they can be async or sync, but we are going to use the async version of them. Hooks are useful for preparing preconditions before running tests; for example, you can populate your database with mock data or clean it up.</p><p class="calibre8">In the main description body, we used three hooks: <code class="email">before()</code>, <code class="email">after()</code>, and <code class="email">afterEach()</code>. In the <code class="email">before()</code> hook, which will run before any of the <code class="email">describe()</code> functions, we set up our server to listen on a given port, and we called the <code class="email">done()</code> function when the server started listening.</p><p class="calibre8">The <code class="email">after()</code> function will run after all the <code class="email">describe()</code> functions have finished running and will stop the server from running. Now, the <code class="email">afterEach()</code> hook will run after each <code class="email">describe()</code> function, and it will grant us the ability to remove all the contacts from the database after running each test.</p><p class="calibre8">The final version can be found in the code bundle of the application. You can still follow how we add all the necessary descriptions.</p><div class="book" title="Creating a contact"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Creating a contact</h3></div></div></div><p class="calibre8">We also added <a id="id31" class="calibre1"/>four to five individual descriptions that will define CRUD operations from the earlier table. First, we want to be able to create a new contact. Add the following code to the test case:</p><div class="informalexample"><pre class="programlisting">  describe('Create contact', () =&gt; {
    it('should create a new contact', (done) =&gt; {
      request({
        method: 'POST',
        url: `${apiUrl}/contacts`,
        form: {
          'email': 'jane.doe@test.com',
          'name': 'Jane Doe'
        },
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(201);
        body.email.should.equal('jane.doe@test.com');
        body.name.should.equal('Jane Doe');
        done();
      });
    });
  });</pre></div></div><div class="book" title="Getting contacts"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Getting contacts</h3></div></div></div><p class="calibre8">Next, we want <a id="id32" class="calibre1"/>to get all contacts from the system. The following code should describe this functionality:</p><div class="informalexample"><pre class="programlisting">  describe('Get contacts', () =&gt; {
    before((done) =&gt; {
      Contact.collection.insert([
        { email: 'jane.doe@test.com' },
        { email: 'john.doe@test.com' }
      ], (err, contacts) =&gt; {
        if (err) throw err;

        done();
      });
    });

    it('should get a list of contacts', (done) =&gt; {
      request({
        method: 'GET',
        url: `${apiUrl}/contacts`,
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.should.be.instanceof(Array);
        body.length.should.equal(2);
        body.should.contain.a.thing.with.property('email', 'jane.doe@test.com');
        body.should.contain.a.thing.with.property('email', 'john.doe@test.com');
        done();
      });
    });
  });</pre></div><p class="calibre8">As you can see, we've also added a <code class="email">before()</code> hook in the description. This is absolutely normal and can be done. Mocha permits this behavior in order to easily set up preconditions. We used a bulk insert, <code class="email">Contact.collection.insert()</code>, to add data into MongoDB before <a id="id33" class="calibre1"/>getting all the contacts.</p></div><div class="book" title="Getting a contact by ID"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Getting a contact by ID</h3></div></div></div><p class="calibre8">When getting a <a id="id34" class="calibre1"/>contact by ID, we would also want to check whether the inserted ID meets our <code class="email">ObjectId</code> criteria. If a contact is not found, we will want to return a 404 HTTP status code:</p><div class="informalexample"><pre class="programlisting">  describe('Get contact', function() {
    let _contact;

    before((done) =&gt; {
      Contact.create({
        email: 'john.doe@test.com'
      }, (err, contact) =&gt; {
        if (err) throw err;

        _contact = contact;
        done();
      });
    });

    it('should get a single contact by id', (done) =&gt; {
      request({
        method: 'GET',
        url: `${apiUrl}/contacts/${_contact.id}`,
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.email.should.equal(_contact.email);
        done();
      });
    });

    it('should not get a contact if the id is not 24 characters', (done) =&gt; {
      request({
        method: 'GET',
        url: `${apiUrl}/contacts/U5ZArj3hjzj3zusT8JnZbWFu`,
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(404);
        done();
      });
    });
  });</pre></div><p class="calibre8">We used the <code class="email">.create()</code> method. It's more convenient to use it for single inserts, to prepopulate the database with data. When getting a single contact by ID we want to ensure that it's a valid <a id="id35" class="calibre1"/>ID, so we added a test which should reflect this and get a <code class="email">404 Not Found</code> response if it's invalid, or no contact was found.</p></div><div class="book" title="Updating a contact"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>Updating a contact</h3></div></div></div><p class="calibre8">We also want to be <a id="id36" class="calibre1"/>able to update an existing contact with a given ID. Add the following code to describe this functionality:</p><div class="informalexample"><pre class="programlisting">  describe('Update contact', () =&gt; {
    let _contact;

    before((done) =&gt; {
      Contact.create({
        email: 'jane.doe@test.com'
      }, (err, contact) =&gt; {
        if (err) throw err;

        _contact = contact;
        done();
      });
    });

    it('should update an existing contact', (done) =&gt; {
      request({
        method: 'PUT',
        url: `${apiUrl}/contacts/${_contact.id}`,
        form: {
          'name': 'Jane Doe'
        },
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.email.should.equal(_contact.email);
        body.name.should.equal('Jane Doe');
        done();
      });
    });
  });</pre></div></div><div class="book" title="Removing a contact"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Removing a contact</h3></div></div></div><p class="calibre8">Finally, we'll <a id="id37" class="calibre1"/>describe the remove contact operation (DELETE from CRUD) by adding the following code:</p><div class="informalexample"><pre class="programlisting">  describe('Delete contact', () =&gt; {
    var _contact;

    before((done) =&gt; {
      Contact.create({
        email: 'jane.doe@test.com'
      }, (err, contact) =&gt; {
        if (err) throw err;

        _contact = contact;
        done();
      });
    });

    it('should update an existing contact', (done) =&gt; {
      request({
        method: 'DELETE',
        url: `${apiUrl}/contacts/${_contact.id}`,
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(204);
        should.not.exist(body);
        done();
      });
    });
  });</pre></div><p class="calibre8">After deleting a contact, the server should respond with an <code class="email">HTTP 204 No Content</code> status code, meaning that the server has successfully interpreted the request and processed it, but no content should be returned due to the fact that the contact was deleted successfully.</p></div><div class="book" title="Running our tests"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>Running our tests</h3></div></div></div><p class="calibre8">Suppose we <a id="id38" class="calibre1"/>run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ mocha test/integration/contact_test.js</strong></span>
</pre></div><p class="calibre8">At this point, we will get a bunch of <code class="email">HTTP 404 Not Found</code> status codes, because our routes are not implemented yet. The output should be similar to something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  Contact</strong></span>
<span class="strong"><strong class="calibre2">    Save contact</strong></span>
<span class="strong"><strong class="calibre2">      1) should save a new contact</strong></span>
<span class="strong"><strong class="calibre2">    Get contacts</strong></span>
<span class="strong"><strong class="calibre2">      2) should get a list of contacts</strong></span>
<span class="strong"><strong class="calibre2">    Get contact</strong></span>
<span class="strong"><strong class="calibre2">      3) should get a single contact by id</strong></span>
<span class="strong"><strong class="calibre2">      √ should not get a contact if the id is not 24 characters</strong></span>
<span class="strong"><strong class="calibre2">    Update contact</strong></span>
<span class="strong"><strong class="calibre2">      4) should update an existing contact</strong></span>
<span class="strong"><strong class="calibre2">    Delete contact</strong></span>
<span class="strong"><strong class="calibre2">      5) should update an existing contact</strong></span>

<span class="strong"><strong class="calibre2">  1 passing (485ms)</strong></span>
<span class="strong"><strong class="calibre2">  5 failing</strong></span>
<span class="strong"><strong class="calibre2">  1) Contact Save contact should save a new contact:</strong></span>

<span class="strong"><strong class="calibre2">      Uncaught AssertionError: expected 404 to equal 201</strong></span>
<span class="strong"><strong class="calibre2">      + expected - actual</strong></span>

<span class="strong"><strong class="calibre2">      +201</strong></span>
<span class="strong"><strong class="calibre2">      -404</strong></span>
</pre></div></div></div></div>

<div class="book" title="Managing contacts">
<div class="book" title="Implementing the contact routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec16" class="calibre1"/>Implementing the contact routes</h2></div></div></div><p class="calibre8">Now, we'll <a id="id39" class="calibre1"/>start implementing <a id="id40" class="calibre1"/>the contact CRUD operations. We'll begin by creating our controller. Create a new file, <code class="email">contact-manager/app/controllers/contact.js</code>, and add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const _ = require('lodash');
const mongoose = require('mongoose');
const Contact = mongoose.model('Contact');
const ObjectId = mongoose.Types.ObjectId;

module.exports.create = createContact;
module.exports.findById = findContactById;
module.exports.getOne = getOneContact;
module.exports.getAll = getAllContacts;
module.exports.update = updateContact;
module.exports.remove = removeContact;

function createContact(req, res, next) {
  Contact.create(req.body, (err, contact) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(201).json(contact);
  });
}</pre></div><p class="calibre8">What the preceding code does is export all methods of the controller for CRUD operations. To create a new contact, we use the <code class="email">create()</code> method from the <code class="email">Contact</code> schema.</p><p class="calibre8">We are returning a JSON response with the newly created contact. In case of an error, we just call the <code class="email">next()</code> function with the error object. We will add a special handler to catch all of our errors later.</p><p class="calibre8">Let's create a new <a id="id41" class="calibre1"/>file for our <a id="id42" class="calibre1"/>routes, <code class="email">contact-manager/app/routes/contacts.js</code>. The following lines of code should be a good start for our router:</p><div class="informalexample"><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const contactController = require('../controllers/contact');

router.post('/contacts', auth.ensured, contactController.create);

module.exports = router;</pre></div><p class="calibre8">Suppose we run our test now using this, like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ mocha tests/integration/contact_test.js</strong></span>
</pre></div><p class="calibre8">We should get something similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">Contact</strong></span>
<span class="strong"><strong class="calibre2">  Create contact</strong></span>
<span class="strong"><strong class="calibre2">      √ should save a new contact</strong></span>
<span class="strong"><strong class="calibre2">  Get contacts</strong></span>
<span class="strong"><strong class="calibre2">      1) should get a list of contacts</strong></span>
<span class="strong"><strong class="calibre2">  Get contact</strong></span>
<span class="strong"><strong class="calibre2">      2) should get a single contact by id</strong></span>
<span class="strong"><strong class="calibre2">      √ should not get a contact if the id is not 24 characters</strong></span>
<span class="strong"><strong class="calibre2">    Update contact</strong></span>
<span class="strong"><strong class="calibre2">      3) should update an existing contact</strong></span>
<span class="strong"><strong class="calibre2">  Delete contact</strong></span>
<span class="strong"><strong class="calibre2">      4) should update an existing contact</strong></span>


<span class="strong"><strong class="calibre2">  2 passing (502ms)</strong></span>
<span class="strong"><strong class="calibre2">  4 failing</strong></span>
</pre></div><div class="book" title="Adding all endpoints"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>Adding all endpoints</h3></div></div></div><p class="calibre8">Next, we will <a id="id43" class="calibre1"/>add the rest of the routes, by adding the following code into the <code class="email">contact-manager/app/routes/contact.js</code> file:</p><div class="informalexample"><pre class="programlisting">router.param('contactId', contactController.findById);

router.get('/contacts', auth.ensured, contactController.getAll);
router.get('/contacts/:contactId', auth.ensured, contactController.getOne);
router.put('/contacts/:contactId', auth.ensured, contactController.update);
router.delete('/contacts/:contactId', auth.ensured, contactController.remove);</pre></div><p class="calibre8">We defined all the routes and also added a callback trigger to the <code class="email">contactId</code> route parameter. In Express, we can add callback triggers on route parameters using the <code class="email">param()</code> method with the name of a parameter and a callback function. </p><p class="calibre8">The callback function is similar to any normal route callback, but it gets an extra parameter representing the value of the route parameter. A concrete example would be as follows:</p><div class="informalexample"><pre class="programlisting">app.param('contactId', function(req, res, next, id) { 
  // do something with the id ...
});</pre></div><p class="calibre8">Following the preceding example, when :<code class="email">contactId</code> is present in a route path, we can map a contact loading logic and provide the contact to the next handler.</p></div><div class="book" title="Finding a contact by ID"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Finding a contact by ID</h3></div></div></div><p class="calibre8">We are going <a id="id44" class="calibre1"/>to add the rest of the missing functionalities in our controller file, located at <code class="email">contact-manager/app/controllers/contact.js</code>:</p><div class="informalexample"><pre class="programlisting">function findContactById(req, res, next, id) {
  if (!ObjectId.isValid(id)) {
    res.status(404).send({ message: 'Not found.'});
  }

  Contact.findById(id, (err, contact) =&gt; {
    if (err) {
      next(err);
    } else if (contact) {
      req.contact = contact;
      next();
    } else {
      next(new Error('failed to find contact'));
    }
  });
}</pre></div><p class="calibre8">The preceding function is a special case. It will get four parameter, and the last one will be the ID matching the triggered parameters value.</p></div><div class="book" title="Getting contact information"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec09" class="calibre1"/>Getting contact information</h3></div></div></div><p class="calibre8">To get <a id="id45" class="calibre1"/>all contacts, we are going to query the database. We will sort our results based on the creation date. One good practice is to always limit your returned dataset's size. For that, we use a <code class="email">MAX_LIMIT</code> constant:</p><div class="informalexample"><pre class="programlisting">function getAllContacts(req, res, next) {
  const limit = +req.query.limit || MAX_LIMIT;
  const skip = +req.query.offset || 0;
  const query = {};

  if (limit &gt; MAX_LIMIT) {
    limit = MAX_LIMIT;
  }

  Contact
  .find(query)
  .skip(skip)
  .limit(limit)
  .sort({createdAt: 'desc'})
  .exec((err, contacts) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(contacts);
  });
}</pre></div><p class="calibre8">To return a <a id="id46" class="calibre1"/>single contact, you can use the following code:</p><div class="informalexample"><pre class="programlisting">function getOneContact(req, res, next) {
  if (!req.contact) {
    return next(err);
  }

  res.json(req.contact);
}</pre></div><p class="calibre8">Theoretically, we'll have the :<code class="email">contactId</code> parameter in a route definition. In that case, the <code class="email">param</code> callback is triggered, populating the <code class="email">req</code> object with the requested contact.</p></div><div class="book" title="Updating a contact"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec10" class="calibre1"/>Updating a contact</h3></div></div></div><p class="calibre8">The same <a id="id47" class="calibre1"/>principle is applied when updating a contact; the requested entity should be populated by the <code class="email">param</code> callback. We just need to assign the incoming data to the contact object and save the changes into MongoDB:</p><div class="informalexample"><pre class="programlisting">function updateContact(req, res, next) {
  let contact = req.contact;
  _.assign(contact, req.body);

  contact.save((err, updatedContact) =&gt; {
    if (err) {
      return next(err);
    }

    res.json(updatedContact);
  });
}</pre></div></div><div class="book" title="Removing a contact"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec11" class="calibre1"/>Removing a contact</h3></div></div></div><p class="calibre8">Removing a <a id="id48" class="calibre1"/>contact should be fairly simple, as it has no dependent documents. So, we can just remove the document from the database, using the following code:</p><div class="informalexample"><pre class="programlisting">function removeContact(req, res, next) {
  req.contact.remove((err) =&gt; {
    if (err) {
      return next(err);
    }

    res.status(204).json();
  });
}</pre></div></div></div></div>

<div class="book" title="Managing contacts">
<div class="book" title="Running the contact test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec17" class="calibre1"/>Running the contact test</h2></div></div></div><p class="calibre8">At this point, we <a id="id49" class="calibre1"/>should have implemented all the requirements for managing contacts on the backend. To test everything, we run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ mocha tests/integration/contact.test.js</strong></span>
</pre></div><p class="calibre8">The output should be similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  Contact</strong></span>

<span class="strong"><strong class="calibre2">    Save contact</strong></span>
<span class="strong"><strong class="calibre2">      √ should save a new contact</strong></span>
<span class="strong"><strong class="calibre2">    Get contacts</strong></span>
<span class="strong"><strong class="calibre2">      √ should get a list of contacts</strong></span>
<span class="strong"><strong class="calibre2">    Get contact</strong></span>
<span class="strong"><strong class="calibre2">      √ should get a single contact by id</strong></span>
<span class="strong"><strong class="calibre2">      √ should not get a contact if the id is not 24 characters</strong></span>
<span class="strong"><strong class="calibre2">    Update contact</strong></span>
<span class="strong"><strong class="calibre2">      √ should update an existing contact</strong></span>
<span class="strong"><strong class="calibre2">    Delete contact</strong></span>
<span class="strong"><strong class="calibre2">      √ should update an existing contact</strong></span>


<span class="strong"><strong class="calibre2">  6 passing (576ms)</strong></span>
</pre></div><p class="calibre8">This means that all the tests have passed successfully and we have implemented all the requirements.</p></div></div>

<div class="book" title="Securing your application routes"><div class="book" id="H5A42-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Securing your application routes</h1></div></div></div><p class="calibre8">You probably <a id="id50" class="calibre1"/>don't want to let <a id="id51" class="calibre1"/>anyone see your contacts, so it's time to secure your endpoints. There are many strategies that we can use to authenticate trusted users in an application. We are going to use a classic, state-full e-mail and password based authentication. This means that the session will be stored on the server side.</p><p class="calibre8">Remember we discussed at the beginning of the chapter how we are going to store our session on the server side? We choose two integrations, one with default in-memory session management and one that stores sessions in MongoDB. Everything is configurable from the environment configuration file.</p><p class="calibre8">When it comes to handling authentication in Node.js, a good go-to module is Passport, which is a piece of authentication middleware. Passport has a comprehensive set of authentication strategies using a simple username-and-password combination for Facebook, Google, Twitter, and many more.</p><p class="calibre8">We have already added this dependency to our application and made the necessary initializations in the express configuration file. We still need to add a few things, but before that, we have to create some reusable components in our backend application. We are going to create a helper file that will ease our interactions with passwords.</p></div>

<div class="book" title="Securing your application routes">
<div class="book" title="Describing the password helper"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec18" class="calibre1"/>Describing the password helper</h2></div></div></div><p class="calibre8">Before we <a id="id52" class="calibre1"/>dive deeper into the authentication mechanism, we need to be able to store in MongoDB a password hash instead of the plain password. We want to create a helper for this task that enables us to make operations related to passwords.</p><p class="calibre8">Create a new folder in the <code class="email">tests</code> folder, named <code class="email">unit</code>. Add a new file, <code class="email">contact-manager/tests/unit/password.test.js</code>, and then add the following code to it:</p><div class="informalexample"><pre class="programlisting">'use strict';

const chai = require('chai');
const should = chai.should();
const passwordHelper = require('../../app/helpers/password');

describe('Password Helper', () =&gt; {
});</pre></div><p class="calibre8">In our main description body, we are going to add segments that represent our features in more detail. Add this code:</p><div class="informalexample"><pre class="programlisting">describe('#hash() - password hashing', () =&gt; {
});
describe('#verify() - compare a password with a hash', () =&gt; {
});</pre></div><p class="calibre8">Mocha also provides an <code class="email">it()</code> function, which we are going to use to set up a concrete test. The <code class="email">it()</code> function is very similar to <code class="email">describe()</code>, except that we put only what the feature is supposed <a id="id53" class="calibre1"/>to do. For assertion, we are going to use the Chai library. Add the following code to the <code class="email">tests/unit/password.test.js</code> file:</p><div class="informalexample"><pre class="programlisting">  describe('#hash() - password hashing', () =&gt; {
    it('should return a hash and a salt from a plain string', (done) =&gt; {
      passwordHelper.hash('P@ssw0rd!', (err, hash, salt) =&gt; {
        if (err) throw err;

        should.exist(hash);
        should.exist(salt);
        hash.should.be.a('string');
        salt.should.be.a('string');
        hash.should.not.equal('P@ssw0rd!');
        done();
      });
    });

    it('should return only a hash from a plain string if salt is given', (done) =&gt; {
      passwordHelper.hash('P@ssw0rd!', 'secret salt', (err, hash, salt) =&gt; {
        if (err) throw err;

        should.exist(hash);
        should.not.exist(salt);
        hash.should.be.a('string');
        hash.should.not.equal('P@ssw0rd!');
        done();
      });
    });

    it('should return the same hash if the password and salt ar the same', (done) =&gt; {
      passwordHelper.hash('P@ssw0rd!', (err, hash, salt) =&gt; {
        if (err) throw err;

        passwordHelper.hash('P@ssw0rd!', salt, function(err, hashWithSalt) {
          if (err) throw err;

          should.exist(hash);
          hash.should.be.a('string');
          hash.should.not.equal('P@ssw0rd!');
          hash.should.equal(hashWithSalt);
          done();
        });
      });
    });
  });</pre></div><p class="calibre8">The <code class="email">passwordHelper</code> should also test whether a password matches the given hash and salt <a id="id54" class="calibre1"/>combo. For this, we are going to add the following describe method:</p><div class="informalexample"><pre class="programlisting">  describe('#verify() - compare a password with a hash', () =&gt; {
    it('should return true if the password matches the hash', (done) =&gt; {
      passwordHelper.hash('P@ssw0rd!', (err, hash, salt) =&gt; {
        if (err) throw err;

        passwordHelper.verify('P@ssw0rd!', hash, salt, (err, result) =&gt; {
          if (err) throw err;

          should.exist(result);
          result.should.be.a('boolean');
          result.should.equal(true);
          done();
        });
      });
    });

    it('should return false if the password does not matches the hash', (done) =&gt; {
      passwordHelper.hash('P@ssw0rd!', (err, hash, salt) =&gt; {
        if (err) throw err;

        passwordHelper.verify('password!', hash, salt, (err, result) =&gt; {
          if (err) throw err;

          should.exist(result);
          result.should.be.a('boolean');
          result.should.equal(false);
          done();
        });
      });
    });
  });</pre></div></div></div>

<div class="book" title="Securing your application routes">
<div class="book" title="Implementing the password helper"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec19" class="calibre1"/>Implementing the password helper</h2></div></div></div><p class="calibre8">We will <a id="id55" class="calibre1"/>implement our password helper in the following file: <code class="email">contact-manager/app/helpers/password.js</code>.</p><p class="calibre8">The first description of our password helper describes a function that creates a hash from a plain password. In our implementation, we will use a key derivation function that will compute a hash from our password, also known as key stretching. </p><p class="calibre8">We are going to use the <code class="email">pbkdf2</code> function from the built-in Node.js <code class="email">crypto</code> library. The asynchronous version of the function takes a plain password and applies an HMAC digest function. We will use <code class="email">sha256</code> to get a derived key of a given length, combined with a salt through a number of iterations.</p><p class="calibre8">We want to use the same hashing function for both cases: when we already have a password hash and a salt and when we have only a plain password. Let's see the final code for our hashing function. Add the following:</p><div class="informalexample"><pre class="programlisting">'use strict';

const crypto = require('crypto');
const len = 512;
const iterations = 18000;
const digest = 'sha256';

module.exports.hash = hashPassword;
module.exports.verify = verify;

function hashPassword(password, salt, callback) {
  if (3 === arguments.length) {
    crypto.pbkdf2(password, salt, iterations, len, digest, (err, derivedKey) =&gt; {
      if (err) {
        return callback(err);
      }

      return callback(null, derivedKey.toString('base64'));
    });
  } else {
    callback = salt;
    crypto.randomBytes(len, (err, salt) =&gt; {
      if (err) {
        return callback(err);
      }

      salt = salt.toString('base64');
      crypto.pbkdf2(password, salt, iterations, len, digest, (err, derivedKey) =&gt; {
        if (err) {
          return callback(err);
        }

        callback(null, derivedKey.toString('base64'), salt);
      });
    });
  }
}</pre></div><p class="calibre8">Let's see what we get if we run our tests now. Run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ mocha tests/unit/password.test.js</strong></span>
</pre></div><p class="calibre8">The output <a id="id56" class="calibre1"/>should be similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">  Password Helper</strong></span>
<span class="strong"><strong class="calibre2">    #hash() - password hashing</strong></span>
<span class="strong"><strong class="calibre2">      √ should return a hash and a salt from a plain string (269ms)</strong></span>
<span class="strong"><strong class="calibre2">      √ should return only a hash from a plain string if salt is given (274ms)</strong></span>
<span class="strong"><strong class="calibre2">      √ should return the same hash if the password and salt are the same (538ms)</strong></span>

<span class="strong"><strong class="calibre2">3 passing (2s)</strong></span>
</pre></div><p class="calibre8">As you can see, we have successfully implemented our hashing function. All the requirements from the test case have passed. Notice that it takes up to 2 seconds to run the tests. Don't worry about this; it's because of the key stretching function taking time to generate the hash from the password.</p><p class="calibre8">Next, we are going to implement the <code class="email">verify()</code> function, which checks whether a password matches an existing user's password-hash-and-salt combination. From the description in our tests, this function accepts four parameters: the plain password, a hash that was generated using the third salt parameter, and a callback function. </p><p class="calibre8">The callback gets two arguments: <code class="email">err</code> and <code class="email">result</code>. The <code class="email">result</code> can be <code class="email">true</code> or <code class="email">false</code>. This will reflect whether the password matches the existing hash or not. Considering the constraints from the tests and the preceding explanation, we can append the following code to our <code class="email">password.helpr.js</code> file:</p><div class="informalexample"><pre class="programlisting">function verify(password, hash, salt, callback) {
  hashPassword(password, salt, (err, hashedPassword) =&gt; {
    if (err) {
      return callback(err);
    }

    if (hashedPassword === hash) {
      callback(null, true);
    } else {
      callback(null, false);
    }
  });
}</pre></div><p class="calibre8">By now, we <a id="id57" class="calibre1"/>should have implemented all the specifications from our tests.</p></div></div>

<div class="book" title="Securing your application routes">
<div class="book" title="Creating the user Mongoose schema"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec20" class="calibre1"/>Creating the user Mongoose schema</h2></div></div></div><p class="calibre8">In order to <a id="id58" class="calibre1"/>grant access to users in the application, we need to store them in a MongoDB collection. We'll <a id="id59" class="calibre1"/>create a new file called <code class="email">contact-manager/app/models/user.model.js</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';

const mongoose = require('mongoose');
const passwordHelper = require('../helpers/password');
const Schema = mongoose.Schema;
const _ = require('lodash');

var UserSchema = new Schema({
  email:  {
    type: String,
    required: true,
    unique: true
  },
  name: {
    type: String
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  passwordSalt: {
    type: String,
    required: true,
    select: false
  },
  active: {
    type: Boolean,
    default: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});</pre></div><p class="calibre8">The following <a id="id60" class="calibre1"/>table <a id="id61" class="calibre1"/>gives a description of the fields in the schema:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Field</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">email</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The e-mail of the user. This is used to identify the user. E-mails will be unique in the system.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">name</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The full name of the user.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">password</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This is the password provided by the user. It will not be stored in plaintext in the database but in a hashed form instead.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">passwordSalt</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Every password will be generated using a unique salt for the given user.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">active</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This specifies the state of the user. It can be active or inactive.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">createdAt</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">The date when the user was created.</p>
</td></tr></tbody></table></div><div class="book" title="Describing the authentication method from the user model"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec12" class="calibre1"/>Describing the authentication method from the user model</h3></div></div></div><p class="calibre8">We'll <a id="id62" class="calibre1"/>describe a user authentication method. It will check whether a user has valid credentials. The following file, <code class="email">contact-manager/tests/integration/user.model.test.js</code>, should contain all the test cases regarding the <a id="id63" class="calibre1"/><code class="email">User</code> model. These lines of code will test the <code class="email">authenticate()</code> method:</p><div class="informalexample"><pre class="programlisting">  it('should authenticate a user with valid credentials', done =&gt; {
    User.authenticate(newUserData.email, newUserData.password, (err, user) =&gt; {
      if (err) throw err;

      should.exist(user);
      should.not.exist(user.password);
      should.not.exist(user.passwordSalt);
      user.email.should.equal(newUserData.email);
      done();
    });
  });

  it('should not authenticate user with invalid credentials', done =&gt; {
    User.authenticate(newUserData.email, 'notuserpassowrd', (err, user) =&gt; {
      if (err) throw err;

      should.not.exist(user);
      done();
    });
  });</pre></div></div><div class="book" title="Implementing the authentication method"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec13" class="calibre1"/>Implementing the authentication method</h3></div></div></div><p class="calibre8">Mongoose lets <a id="id64" class="calibre1"/>us add static methods to compiled models from schemas. The <code class="email">authenticate()</code> method will search for a user in the database by its e-mail and use the password helper's <code class="email">verify()</code> function to check whether the sent password is a match.</p><p class="calibre8">Add the following lines of code to the <code class="email">contact-manager/app/models/user.js</code> file:</p><div class="informalexample"><pre class="programlisting">UserSchema.statics.authenticate = authenticateUser;

function authenticateUser(email, password, callback) {
  this
  .findOne({ email: email })
  .select('+password +passwordSalt')
  .exec((err, user) =&gt; {
    if (err) {
      return callback(err, null);
    }

    // no user found just return the empty user
    if (!user) {
      return callback(err, user);
    }

    // verify the password with the existing hash from the user
    passwordHelper.verify(
      password,
      user.password,
      user.passwordSalt,
      (err, result) =&gt; {
        if (err) {
          return callback(err, null);
        }

        // if password does not match don't return user
        if (result === false) {
          return callback(err, null);
        }

        // remove password and salt from the result
        user.password = undefined;
        user.passwordSalt = undefined;
        // return user if everything is ok
        callback(err, user);
      }
    );
  });
}</pre></div><p class="calibre8">In the preceding code, when selecting the user from MongoDB, we explicitly selected the password and <a id="id65" class="calibre1"/><code class="email">passwordSalt</code> fields. This was necessary because we set the password and <code class="email">passwordSalt</code> fields to not be selected in the query result. Another thing to note is that we want to remove the password and salt from the result when returning the user.</p></div></div></div>

<div class="book" title="Securing your application routes">
<div class="book" title="Authentication routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec21" class="calibre1"/>Authentication routes</h2></div></div></div><p class="calibre8">In order <a id="id66" class="calibre1"/>to authenticate <a id="id67" class="calibre1"/>in the system we are building, we need to expose some endpoints that will execute the necessary business logic to authenticate a user with valid credentials. Before jumping into <a id="id68" class="calibre1"/>any code, we are <a id="id69" class="calibre1"/>going to describe the desired behavior.</p><div class="book" title="Describing the authentication routes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec14" class="calibre1"/>Describing the authentication routes</h3></div></div></div><p class="calibre8">We are <a id="id70" class="calibre1"/>only going to take a look at a partial code from the integration test of the authentication functionality, found in <code class="email">contact-manager/tests/integration/authentication.test.js</code>. It should look something like this:</p><div class="informalexample"><pre class="programlisting">  describe('Sign in user', () =&gt; {
    it('should sign in a user with valid credentials', (done) =&gt; {
      request({
        method: 'POST',
        url: baseUrl + '/auth/signin',
        form: {
          'email': userFixture.email,
          'password': 'P@ssw0rd!'
        },
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(200);
        body.email.should.equal(userFixture.email);
        should.not.exist(body.password);
        should.not.exist(body.passwordSalt);
        done();
      });
    });

    it('should not sign in a user with invalid credentials', (done) =&gt; {
      request({
        method: 'POST',
        url: baseUrl + '/auth/signin',
        form: {
          'email': userFixture.email,
          'password': 'incorrectpassword'
        },
        json:true
      }, (err, res, body) =&gt; {
        if (err) throw err;

        res.statusCode.should.equal(400);
        body.message.should.equal('Invalid email or password.');
        done();
      });
    });
  });</pre></div><p class="calibre8">So, we've described an <code class="email">auth/signin</code> endpoint; it will authenticate a user using an e-mail-and-password combination. We are testing two scenarios. The first one is when a user has valid <a id="id71" class="calibre1"/>credentials and the second is when an incorrect password is sent.</p></div><div class="book" title="Integrating Passport"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec15" class="calibre1"/>Integrating Passport</h3></div></div></div><p class="calibre8">We <a id="id72" class="calibre1"/>mentioned Passport earlier in the chapter and added some basic logic for this purpose, but we still need to make a proper integration. The Passport module should already be installed and the session management is already in place. So next, we need to create a proper configuration file, <code class="email">contact-manager/config/passport.js</code>, and add the following:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');
const mongoose = require('mongoose');
const User = mongoose.model('User');

module.exports.init = initPassport;

function initPassport(app) {
  passport.serializeUser((user, done) =&gt; {
    done(null, user.id);
  });

  passport.deserializeUser((id, done) =&gt; {
    User.findById(id, done);
  });

  // load strategies
  require('./strategies/local').init();
}</pre></div><p class="calibre8">For each subsequent request, we need to serialize and deserialize the user instance to and from the session. We are only going to serialize the user's ID into the session. When subsequent requests are made, the user's ID is used to find the matching user and restore the data in <code class="email">req.user</code>.</p><p class="calibre8">Passport gives us the ability to use different strategies to authenticate our users. We are only going to use e-mail and password to authenticate a user. To keep everything modular, we are going to move the strategies into separate files. The so-called local strategy, which <a id="id73" class="calibre1"/>will be used to authenticate users using an e-mail and a password, is going to be in the <code class="email">contact-manager/config/strategies/local.js</code> file:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const User = require('mongoose').model('User');

module.exports.init = initLocalStrategy;

function initLocalStrategy() {
  passport.use('local', new LocalStrategy({
      usernameField: 'email',
      passwordField: 'password'
    },
    (email, password, done) =&gt; {
      User.authenticate(email, password, (err, user) =&gt; {
        if (err) {
          return done(err);
        }

        if (!user) {
          return done(null, false, { message: 'Invalid email or password.' });
        }

        return done(null, user);
      });
    }
  ));
}</pre></div></div><div class="book" title="Implementing the authentication routes"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec16" class="calibre1"/>Implementing the authentication routes</h3></div></div></div><p class="calibre8">Now that we <a id="id74" class="calibre1"/>have passport up and running, we can define our authentication controller logic and a proper route to sign in users. Create a new file called <code class="email">contact-manager/app/controllers/authentication.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const passport = require('passport');
const mongoose = require('mongoose');
const User = mongoose.model('User');

module.exports.signin = signin;

function signin(req, res, next) {
  passport.authenticate('local', (err, user, info) =&gt; {
    if (err) {
      return next(err);
    }

    if (!user) {
      return res.status(400).send(info);
    }

    req.logIn(user, (err) =&gt; {
      if (err) {
        return next(err);
      }

      res.status(200).json(user);
    });
  })(req, res, next);
}</pre></div><p class="calibre8">Here, we use the <code class="email">.authenticate()</code> function from Passport to check a user's credentials using the local strategy implemented earlier. Next, we are going to add the authentication route, create a new <a id="id75" class="calibre1"/>file called <code class="email">contact-manager/app/routes/auth.js</code>, and add the following lines of code:</p><div class="informalexample"><pre class="programlisting">'use strict';

var express = require('express');
var router = express.Router();
var authCtrl = require('../controllers/authentication');

router.post('/signin', authCtrl.signin);
router.post('/register', authCtrl.register);

module.exports = router;</pre></div><p class="calibre8">Note that we skipped the register user functionality, but don't worry! The final bundled project source <a id="id76" class="calibre1"/>code will have all of the necessary logic.</p></div></div></div>

<div class="book" title="Securing your application routes">
<div class="book" title="Restricting access to contacts routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec22" class="calibre1"/>Restricting access to contacts routes</h2></div></div></div><p class="calibre8">We <a id="id77" class="calibre1"/>created all the requirements to authenticate our users. Now it's time to restrict access to some of the routes, so technically we are going to create a simple ACL. To restrict access, we are going to use a piece of middleware that will check whether users are authenticated or not.</p><p class="calibre8">Let's create our middleware file, <code class="email">contact-manager/app/middlewares/authentication.js</code>. This should contain these lines of carefully crafted code:</p><div class="informalexample"><pre class="programlisting">'use strict';

module.exports.ensured = ensureAuthenticated;

function ensureAuthenticated(req, res, next) {
  if (req.isAuthenticated()) {
    return next();
  }

  res.status(401).json({
    message: 'Please authenticate.'
  });
}</pre></div><p class="calibre8">We have already added the necessary logic to restrict users to the contact routes; that was when we first created them. We succeeded in adding all the necessary pieces of code to manage contacts and restrict access to our endpoints. Now we can continue and start building our Angular 2 application.</p></div></div>
<div class="book" title="Integrating Angular 2 into our application" id="I3QM1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Integrating Angular 2 into our application</h1></div></div></div><p class="calibre8">The frontend <a id="id78" class="calibre1"/>application is going to be built using Angular 2. At the time of writing this book, the project is still in beta, but it will come in handy to start playing around with Angular and have a good understanding of the environment. Most of the code will follow the official docs view of the tooling and integration methods.</p><p class="calibre8">When we first described our folder structure, we saw a <code class="email">package.json</code> file for the client application too. Let's take a look at it, found under the <code class="email">contact-manager/public/package.json</code> path:</p><div class="informalexample"><pre class="programlisting">{
  "private": true,
  "name": "mean-blueprints-contact-manager-client",
  "dependencies": {
    "systemjs": "^0.19.25",
    "es6-shim": "^0.35.0",
    "es6-promise": "^3.0.2",
    "rxjs": "^5.0.0-beta.2",
    "reflect-metadata": "^0.1.2",
    "zone.js": "^0.6.6",
    "angular2": "^2.0.0-beta.14"
  },
  "devDependencies": {
    "typings": "^0.7.12",
    "typescript": "^1.8.9"
  }
}</pre></div><p class="calibre8">To install the necessary dependencies, just use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ npm install</strong></span>
</pre></div><p class="calibre8">You will see <code class="email">npm</code> pulling down different packages, specified in the <code class="email">package.json</code> file.</p><p class="calibre8">As you can see, we'll use TypeScript in our client-side application. If you have installed it globally, you can use the following command to compile and watch for changes to your <code class="email">.ts</code> files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ tsc -w</strong></span>
</pre></div><p class="calibre8">Only the most important parts of the application will be discussed. The rest of the necessary files and <a id="id79" class="calibre1"/>folders can be found in the final bundled source code.</p></div>

<div class="book" title="Granting access to our application"><div class="book" id="J2B82-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Granting access to our application</h1></div></div></div><p class="calibre8">We have restricted <a id="id80" class="calibre1"/>access to our API's endpoints, so <a id="id81" class="calibre1"/>now we have to grant users sign-in functionality from the client application. I like to group the Angular 2 application files based on their domain context. So, for example, all our authentication, registration, and business logic should go into a separate folder; we can call it <code class="email">auth</code>.</p><p class="calibre8">If your module directory grows, it's good practice to break it down into separate folders based on their context by type. There is no magic number for the file count. Usually, you will get a good feeling when it's time to move files around. Your files should always be easy to locate and give you enough information from their placement in a certain context.</p></div>

<div class="book" title="Granting access to our application">
<div class="book" title="AuthService"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec23" class="calibre1"/>AuthService</h2></div></div></div><p class="calibre8">We are going to <a id="id82" class="calibre1"/>use <code class="email">AuthService</code> to implement the data access layer and make calls to the backend. This service is going to be the bridge between our API's sign-in and register features. Create a new file called <code class="email">contact-manager/src/auth/auth.service.ts</code>, and add the following TypeScript code into it:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers } from 'angular2/http';
import { contentHeaders } from '../common/headers';

@Injectable()
export class AuthService {
  private _http: Http;

  constructor(http: Http) {
    this._http = http;
  }
}</pre></div><p class="calibre8">We import the necessary modules, define the <code class="email">AuthService</code> class, and export it. The Injectable marker metadata will mark our class to be available to be injected. In order to communicate with the backend, we use the HTTP service. Don't forget to add the <code class="email">HTTP_PROVIDERS</code> when bootstrapping the application so that the service is available to be injected in the whole application.</p><p class="calibre8">To sign in a user, we are going to add the following method:</p><div class="informalexample"><pre class="programlisting">  public signin(user: any) {
    let body = this._serialize(user);

    return this._http
    .post('/auth/signin', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json());
  }</pre></div><p class="calibre8">We can use the <code class="email">.map()</code> operator to transform the response into a JSON file. When performing HTTP requests, this will return an <code class="email">Observable</code>. You have probably already figured it out—we are going to use <span class="strong"><strong class="calibre2">RxJs</strong></span> (<span class="strong"><strong class="calibre2">Reactive Extensions</strong></span>) heavily, which is a third-party library favored by Angular.</p><p class="calibre8">RxJs implements asynchronous observable pattern. In other words, it enables you to work with asynchronous data streams and apply different operators. Observables are used widely in Angular applications. At the time of writing this book, Angular 2 exposes a stripped-down version of the <code class="email">Observable</code> module from RxJs.</p><p class="calibre8">Don't worry; we'll get familiar with this technique and the benefits of it as we dive further into the book. Now let's continue with the rest of the missing methods we want to expose:</p><div class="informalexample"><pre class="programlisting">  public register(user: any) {
    let body = this._serialize(user);

    return this._http
    .post('/auth/register', body, { headers: contentHeaders })
    .map((res: Response) =&gt; res.json());
  }

  private _serialize(data) {
    return JSON.stringify(data);
  }</pre></div><p class="calibre8">We added the <code class="email">register()</code> method to our service, which will handle user registration. Also note that we moved our serialization into a separate private method. I've left this method in the same <a id="id83" class="calibre1"/>class so that it's easier to follow, but you can move it into a helper class.</p></div></div>

<div class="book" title="Granting access to our application">
<div class="book" title="User sign-in component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec24" class="calibre1"/>User sign-in component</h2></div></div></div><p class="calibre8">For a start, we <a id="id84" class="calibre1"/>are going to implement the sign-in component. Let's create a new file called <code class="email">contact-manager/public/src/auth/sigin.ts</code> and add the following lines of TypeScript code:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { AuthService } from './auth.service';

export class Signin {
  private _authService: AuthService;
  private _router: Router;

  constructor(
    authService: AuthService,
    router: Router
  ) {
    this._authService = authService;
    this._router = router;
  }

  signin(event, email, password) {
    event.preventDefault();

    let data = { email, password };

    this._authService
    .signin(data)
    .subscribe((user) =&gt; {
      this._router.navigateByUrl('/');
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">We still <a id="id85" class="calibre1"/>need to add the <code class="email">Component</code> annotation before our <code class="email">Signin</code> class:</p><div class="informalexample"><pre class="programlisting">@Component({
    selector: 'signin',
    directives: [
      RouterLink
    ],
    template: `
      &lt;div class="login jumbotron center-block"&gt;
        &lt;h1&gt;Login&lt;/h1&gt;
        &lt;form role="form" (submit)="signin($event, email.value, password.value)"&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="email"&gt;E-mail&lt;/label&gt;
            &lt;input type="text" #email class="form-control" id="email" placeholder="enter your e-mail"&gt;
          &lt;/div&gt;
          &lt;div class="form-group"&gt;
            &lt;label for="password"&gt;Password&lt;/label&gt;
            &lt;input type="password" #password class="form-control" id="password" placeholder="now your password"&gt;
          &lt;/div&gt;
          &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;
          &lt;a href="#" [routerLink]="['Register']"&gt;Click here to register&lt;/a&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    `
})</pre></div><p class="calibre8">The <code class="email">Signin</code> component is going to be our sign-in form and it uses the <code class="email">AuthService</code> to communicate with the backend. In the component's template, we are using local variables marked with a <code class="email">#</code> sign for the email and password fields. </p><p class="calibre8">As we said earlier, the HTTP service returns an <code class="email">Observable</code> when making a request. This is the reason we can subscribe to the response generated by the requests made from our <code class="email">AuthService</code>. On successful authentication, the user is redirected to the default home path.</p><p class="calibre8">The <code class="email">Register</code> <a id="id86" class="calibre1"/>component will look similar to the <code class="email">Signin</code> component, so there is no need to detail this scenario. The final version of the <code class="email">auth</code> module will be available in the source code.</p></div></div>

<div class="book" title="Granting access to our application">
<div class="book" title="Custom HTTP service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec25" class="calibre1"/>Custom HTTP service</h2></div></div></div><p class="calibre8">In order to <a id="id87" class="calibre1"/>restrict access to our API endpoints, we have to make sure that, if a request is unauthorized, we redirect the user to the sign-in page. Angular 2 has no support for Interceptors and we don't want to add a handler for each request we integrate into our services.</p><p class="calibre8">A more convenient solution would be to build our own custom service on top of the built-in HTTP service. We could call it <code class="email">AuthHttp</code>, from authorized HTTP requests. Its purpose would be to check whether a request returned a <code class="email">401 Unauthorized HTTP status</code> code.</p><p class="calibre8">I would like to take this thought even further and bring a hint of reactive programming, because we are already using RxJS. So, we can benefit from the full set of functionalities it provides. Reactive programming is oriented around data. Streams of data propagate in your application and it reacts to those changes.</p><p class="calibre8">Let's get to business and start building our custom service. Create a file called <code class="email">contact-manager/public/src/auth/auth-http.ts</code>. We are going to add a few lines of code:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Http, Response, Headers, BaseRequestOptions, Request, RequestOptions, RequestOptionsArgs, RequestMethod } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { BehaviorSubject } from 'rxjs/Subject/BehaviorSubject';

@Injectable()
export class AuthHttp {
  public unauthorized: Subject&lt;Response&gt;;
  private _http: Http;

  constructor(http: Http) {
    this._http = http;
    this.unauthorized = new BehaviorSubject&lt;Response&gt;(null);
  }
}</pre></div><p class="calibre8">There are a few things we imported at the top of the file. We'll need all of them in this module. We defined a public property named <code class="email">unauthorized</code>, which is a Subject. A <span class="strong"><strong class="calibre2">Subject</strong></span> is both an <code class="email">Observable</code> and <code class="email">Observer</code>. This means that we can subscribe our subject to a backend data source and also all observers can subscribe to the subject.</p><p class="calibre8">In our case, the <a id="id88" class="calibre1"/>subject will be a proxy between our data source and all the subscribed observers. If a request is unauthorized, all subscribers get notified with the change. This enables us to just subscribe to the subject and redirect the user to the sign-in page when we detect an unauthorized request.</p><p class="calibre8">To succeed in doing this, we have to add a few more methods to our <code class="email">AuthHttp</code> service:</p><div class="informalexample"><pre class="programlisting">  private request(requestArgs: RequestOptionsArgs, additionalArgs?: RequestOptionsArgs) {
    let opts = new RequestOptions(requestArgs);

    if (additionalArgs) {
      opts = opts.merge(additionalArgs);
    }

    let req:Request = new Request(opts);

    return this._http.request(req).catch((err: any) =&gt; {
      if (err.status === 401) {
        this.unauthorized.next(err);
      }

      return Observable.throw(err);
    });
  }</pre></div><p class="calibre8">The preceding method creates a new request with the desired <code class="email">RequestOptions</code> and invokes the <code class="email">request</code> method from the base HTTP service. Additionally, the <code class="email">catch</code> method captures all requests with status code not 200-level.</p><p class="calibre8">Using this technique, we can send the unauthorized request to all subscribers by using our <code class="email">unauthorized</code> subject. Now that we have our private <code class="email">request</code> method, we just need to add the rest of the public HTTP methods:</p><div class="informalexample"><pre class="programlisting">  public get(url: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Get}, opts);
  }

  public post(url: string, body?: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Post, body: body}, opts);
  }

  public put(url: string, body?: string, opts?: RequestOptionsArgs) {
    return this.request({ url: url, method: RequestMethod.Put, body: body}, opts);
  }

  // rest of the HTTP methods ...</pre></div><p class="calibre8">I've added only the most commonly used methods; the rest is available in the full version. The preceding <a id="id89" class="calibre1"/>code calls our request method and sets the necessary options for each request type. Theoretically, we have created a façade to handle unauthorized requests.</p><p class="calibre8">I think we've made good progress and it's time to move on to the rest of the modules of our contact manager application.</p></div></div>

<div class="book" title="The Contact module"><div class="book" id="K0RQ2-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>The Contact module</h1></div></div></div><p class="calibre8">This module will hold <a id="id90" class="calibre1"/>all the necessary files to <a id="id91" class="calibre1"/>manage contacts. As we discussed earlier, we are grouping our files by context, related to their domain. The starting point of our module will be the data layer, which means we'll start implementing the necessary service.</p></div>

<div class="book" title="The Contact module">
<div class="book" title="Contact service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec26" class="calibre1"/>Contact service</h2></div></div></div><p class="calibre8">Our <a id="id92" class="calibre1"/>contact service will have basic CRUD operations and Observable streams to subscribe to. This implementation will use the backend API built using Node.js and Express, but it can be converted anytime to a WebSocket-based API with little effort.</p><p class="calibre8">Create a new service file called <code class="email">contact-manager/src/contact/contact.service.ts</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">import { Injectable } from 'angular2/core';
import { Response, Headers } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import { contentHeaders } from '../common/headers';
import { AuthHttp } from '../auth/auth-http';
import { Contact } from '../contact';

type ObservableContacts = Observable&lt;Array&lt;Contact&gt;&gt;;
type ObservableContact = Observable&lt;Contact&gt;;

const DEFAULT_URL = '/api/contacts';

@Injectable()
export class ContactService {
  public contact: ObservableContact;
  public contacts: ObservableContacts;

  private _authHttp: AuthHttp;
  private _dataStore: { contacts: Array&lt;Contact&gt;, contact: Contact };
  private _contactsObserver: any;
  private _contactObserver: any;
  private _url: string;

  constructor(authHttp: AuthHttp) {
    this._authHttp = authHttp;
    this._url = DEFAULT_URL;
    this._dataStore = { contacts: [], contact: new Contact() };
    this.contacts = new Observable(
      observer =&gt; this._contactsObserver = observer
    ).share();
    this.contact = new Observable(
      observer =&gt; this._contactObserver = observer
    ).share();
  }
}</pre></div><p class="calibre8">In the contact service, we have a few moving parts. First we defined our Observables so that any other component or module can subscribe and start getting the streams of data.</p><p class="calibre8">Second, we declared a private data store. This is where we are going to store our contacts. This is good practice as you can easily return all resources from memory.</p><p class="calibre8">Also, in our <a id="id93" class="calibre1"/>service, we are going to keep private the returned Observers when new instances of Observables are generated. Using the Observers, we can push new data streams to our Observables.</p><p class="calibre8">In our public methods, we are going to expose the get all contacts, get one, update, and delete functionalities. To get all contacts, we are going to add the following method to our <code class="email">ContactService</code>:</p><div class="informalexample"><pre class="programlisting">  public getAll() {
    return this._authHttp
    .get(`${this._url}`, { headers: contentHeaders} )
    .map((res: Response) =&gt; res.json())
    .map(data =&gt; {
      return data.map(contact =&gt; {
        return new Contact(
          contact._id,
          contact.email,
          contact.name,
          contact.city,
          contact.phoneNumber,
          contact.company,
          contact.createdAt
        )
      });
    })
    .subscribe((contacts: Array&lt;Contact&gt;) =&gt; {
      this._dataStore.contacts = contacts;
      this._contactsObserver.next(this._dataStore.contacts);
    }, err =&gt; console.error(err));
  }</pre></div><p class="calibre8">We use our custom build <code class="email">AuthHttp</code> service to load data from our Express application. When a response is received, we transform it into a JSON file, and after that, we just instantiate a new contact for each entity from the dataset. </p><p class="calibre8">Instead of <a id="id94" class="calibre1"/>returning the whole <code class="email">Observable</code> from the HTTP service, we use our internal data store to persist all the contacts. After we have successfully updated the data store with the new data, we push the changes to our <code class="email">contactsObserver</code>.</p><p class="calibre8">Any component that is subscribed to our stream of contacts will get the new values from the <code class="email">Observable</code> data stream. In this way, we always keep our components synced using one single point of entry.</p><p class="calibre8">Much of our public method's logic is the same, but we still have a few distinct elements, for example, the update method:</p><div class="informalexample"><pre class="programlisting">  public update(contact: Contact) {
    return this._authHttp
    .put(
      `${this._url}/${contact._id}`,
      this._serialize(contact),
      { headers: contentHeaders}
    )
    .map((res: Response) =&gt; res.json())
    .map(data =&gt; {
      return new Contact(
        data._id,
        data.email,
        data.name,
        data.city,
        data.phoneNumber,
        contact.company,
        data.createdAt
      )
    })
    .subscribe((contact: Contact) =&gt; {
      // update the current list of contacts
      this._dataStore.contacts.map((c, i) =&gt; {
        if (c._id === contact._id) {
          this._dataStore.contacts[i] = contact;
        }
      });
      // update the current contact
      this._dataStore.contact = contact;
      this._contactObserver.next(this._dataStore.contact);
      this._contactsObserver.next(this._dataStore.contacts);
    }, err =&gt; console.error(err));
  }</pre></div><p class="calibre8">The <code class="email">update</code> method is almost the same as the <code class="email">create()</code> method, however it takes the contact's ID as <a id="id95" class="calibre1"/>the URL param. Instead of pushing new values down a data stream, we return the <code class="email">Observable</code> from the <code class="email">Http</code> service, in order to apply operations from the caller module.</p><p class="calibre8">Now, if we would like to make changes directly on the <code class="email">datastore</code> and push the new values through the <code class="email">contacts</code> data stream, we could showcase this in the remove contact method:</p><div class="informalexample"><pre class="programlisting">  public remove(contactId: string) {
    this._authHttp
    .delete(`${this._url}/${contactId}`)
    .subscribe(() =&gt; {
      this._dataStore.contacts.map((c, i) =&gt; {
        if (c._id === contactId) {
          this._dataStore.contacts.splice(i, 1);
        }
      });
      this._contactsObserver.next(this._dataStore.contacts);
    }, err =&gt; console.error(err));
  }</pre></div><p class="calibre8">We simply use the <code class="email">map()</code> function to find the contact we deleted and remove it from the internal store. Afterwards, we send new data to the subscribers.</p></div></div>

<div class="book" title="The Contact module">
<div class="book" title="Contact component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec27" class="calibre1"/>Contact component</h2></div></div></div><p class="calibre8">As we <a id="id96" class="calibre1"/>have moved everything related to the contact domain, we can define a main component in our module. Let's call it <code class="email">contact-manager/public/src/contact/contact.component.ts</code>. Add the following lines of code:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { RouteConfig, RouterOutlet } from 'angular2/router';
import { ContactListComponent } from './contact-list.component';
import { ContactCreateComponent } from './contact-create.component';
import { ContactEditComponent } from './contact-edit.component';

@RouteConfig([
  { path: '/', as: 'ContactList', component: ContactListComponent, useAsDefault: true },
  { path: '/:id', as: 'ContactEdit', component: ContactEditComponent },
  { path: '/create', as: 'ContactCreate', component: ContactCreateComponent }
])
@Component({
    selector: 'contact',
    directives: [
      ContactListComponent,
      RouterOutlet
    ],
    template: `
      &lt;router-outlet&gt;&lt;/router-outlet&gt;
    `
})
export class ContactComponent {
  constructor() {}
}</pre></div><p class="calibre8">Our component has no logic associated with it, but we used the <code class="email">RouterConfig</code> annotation. The route config decorator takes an array of routes. Each path specified in the config will match the browser's URL. Each route will load the mounted component. In order to reference routes in the template, we need to give them a name.</p><p class="calibre8">Now, the most appealing part is that we can take this component with the configured routes and mount it on another component to have <code class="email">Child</code>/<code class="email">Parent</code> routes. In this case, it becomes nested routing, which is a very powerful feature added to Angular 2.</p><p class="calibre8">Our application's routes will have a tree-like structure; other components load components with their configured routes. I was pretty amazed by this feature because it enables us <a id="id97" class="calibre1"/>to truly modularize our application and create amazing, reusable modules.</p></div></div>

<div class="book" title="The Contact module">
<div class="book" title="List contacts component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec28" class="calibre1"/>List contacts component</h2></div></div></div><p class="calibre8">In the <a id="id98" class="calibre1"/>previous component, we used three different components and mounted them on different routes. We are not going to discuss each of them, so we will choose one. As we have already worked with forms in the <code class="email">Signin</code> component, let's try something different and implement the list contacts functionality.</p><p class="calibre8">Create a new file called <code class="email">contact-manager/public/src/contact/contact-list.component.ts</code> and add the following code for your component:</p><div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouterLink } from 'angular2/router';
import { ContactService } from '../contact.service';
import { Contact } from '../contact';

@Component({
    selector: 'contact-list',
    directives: [RouterLink],
    template: `
      &lt;div class="row"&gt;
        &lt;h4&gt;
          Total contacts: &lt;span class="muted"&gt;({{contacts.length}})&lt;/span&gt;
          &lt;a href="#" [routerLink]="['ContactCreate']"&gt;add new&lt;/a&gt;
        &lt;/h4&gt;
        &lt;div class="contact-list"&gt;
          &lt;div class="card-item col col-25 contact-item"
            *ngFor="#contact of contacts"&gt;
            &lt;img src="{{ contact.image }}" /&gt;
            &lt;h3&gt;
              &lt;a href="#" [routerLink]="['ContactEdit', { id: contact._id }]"&gt;
                {{ contact.name }}
              &lt;/a&gt;
            &lt;/h3&gt;
            &lt;p&gt;
              &lt;span&gt;{{ contact.city }}&lt;/span&gt;
              &lt;span&gt;·&lt;/span&gt;
              &lt;span&gt;{{ contact.company }}&lt;/span&gt;
            &lt;/p&gt;
            &lt;p&gt;&lt;span&gt;{{ contact.email }}&lt;/span&gt;&lt;/p&gt;
            &lt;p&gt;&lt;span&gt;{{ contact.phoneNumber }}&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `
})
export class ContactListComponent implements OnInit {
  public contacts: Array&lt;Contact&gt; = [];
  private _contactService: ContactService;

  constructor(contactService: ContactService) {
    this._contactService = contactService;
  }

  ngOnInit() {
    this._contactService.contacts.subscribe(contacts =&gt; {
      this.contacts = contacts;
    });
    this._contactService.getAll();
  }
}</pre></div><p class="calibre8">In our <a id="id99" class="calibre1"/>component's <code class="email">ngOnInit()</code>, we subscribe to the contacts data stream. Afterwards, we retrieve all the contacts from the backend. In the template, we use <code class="email">ngFor</code> to iterate over the dataset and display each contact.</p></div></div>

<div class="book" title="The Contact module">
<div class="book" title="Creating a contact component"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec29" class="calibre1"/>Creating a contact component</h2></div></div></div><p class="calibre8">Now that <a id="id100" class="calibre1"/>we can list contacts in our application, we should also be able to add new entries. Remember that earlier we used the <code class="email">RouterLink</code> to be able to navigate to the <code class="email">CreateContact</code> route.</p><p class="calibre8">The preceding route will load the <code class="email">CreateContactComponent</code>, which will enable us to add new contact entries into our database, through the Express API. Let's create a new component file <code class="email">public/src/contact/components/contact-create.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { Router, RouterLink } from 'angular2/router';
import { ContactService } from '../contact.service';
import { Contact } from '../contact';

@Component({
    selector: 'contact-create,
    directives: [RouterLink],
    templateUrl: 'src/contact/components/contact-form.html'
})
export class ContactCreateComponent implements OnInit {
  public contact: Contact;
  private _router: Router;
  private _contactService: ContactService;

  constructor(
    contactService: ContactService,
    router: Router
  ) {
    this._contactService = contactService;
    this._router = router;
  }

  ngOnInit() {
    this.contact = new Contact();
  }

  onSubmit(event) {
    event.preventDefault();

    this._contactService
    .create(this.contact)
    .subscribe((contact) =&gt; {
      this._router.navigate(['ContactList']);
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">Instead of <a id="id101" class="calibre1"/>using an embedded template, we are using an external template file that is configured using the <code class="email">templateUrl</code> property in the component annotation. There are pros and cons for each situation. The benefits of using an external template file would be that you can reuse the same file for more than one component.</p><p class="calibre8">The downfall, at the moment of writing the book, in Angular 2 is that it's hard to use relative paths to your template files, so this would make your components less portable. Also I like to keep my templates short, so they can fit easily inside the component, so in most cases I'll probably use embedded templates.</p><p class="calibre8">Let's take a look at the template before further discussing the component, <code class="email">public/src/contact/components/contact-form.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="row contact-form-wrapper"&gt;
  &lt;a href="#" [routerLink]="['ContactList']"&gt;&amp;lt; back to contacts&lt;/a&gt;
  &lt;h2&gt;Add new contact&lt;/h2&gt;
  &lt;form role="form"
    (submit)="onSubmit($event)"&gt;

    &lt;div class="form-group"&gt;
      &lt;label for="name"&gt;Full name&lt;/label&gt;
      &lt;input type="text" [(ngModel)]="contact.name"
        class="form-control" id="name" placeholder="Jane Doe"&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
      &lt;label for="email"&gt;E-mail&lt;/label&gt;
      &lt;input type="text" [(ngModel)]="contact.email"
        class="form-control" id="email" placeholder="jane.doe@example.com"&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
      &lt;label for="city"&gt;City&lt;/label&gt;
      &lt;input type="text"
        [(ngModel)]="contact.city"
        class="form-control" id="city" placeholder="a nice place ..."&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
      &lt;label for="company"&gt;Company&lt;/label&gt;
      &lt;input type="text"
        [(ngModel)]="contact.company"
        class="form-control" id="company" placeholder="working at ..."&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
      &lt;label for="phoneNumber"&gt;Phone&lt;/label&gt;
      &lt;input type="text"
        [(ngModel)]="contact.phoneNumber"
        class="form-control" id="phoneNumber" placeholder="mobile or landline"&gt;
    &lt;/div&gt;

    &lt;button type="submit" class="button"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;</pre></div><p class="calibre8">In the template <a id="id102" class="calibre1"/>we are using a <code class="email">onSubmit()</code> method from the component to piggyback the form submission and in this case create a new contact and store the data in MongoDB. When we successfully create the contact we want to navigate to the <code class="email">ContactList</code> route.</p><p class="calibre8">We are not using local variables, instead we are using two-way data binding with the <code class="email">ngModel</code> for each input, mapped to the properties of the contact object. Now, each time the user <a id="id103" class="calibre1"/>changes the inputs value, this is stored in the contact object and on submit it's sent across the wire to the backend.</p><p class="calibre8">The <code class="email">RouterLink</code> is used to construct the navigation to the <code class="email">ContactList</code> component from the template. I've left a small improvement, the view title will be the same both for creating and editing, more precisely "Add new contact", and I'll let you figure it out.</p></div></div>

<div class="book" title="The Contact module">
<div class="book" title="Editing an existing contact"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec30" class="calibre1"/>Editing an existing contact</h2></div></div></div><p class="calibre8">When <a id="id104" class="calibre1"/>editing a contact, we want to load a specific resource by ID from the backend API and make changes for that contact. Lucky for us this is quite simple to achieve in Angular. Create a new file <code class="email">public/src/contact/components/contact-edit.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component, OnInit } from 'angular2/core';
import { RouteParams, RouterLink } from 'angular2/router';
import { ContactService } from '../contact.service';
import { Contact } from '../contact';

@Component({
    selector: 'contact-edit',
    directives: [RouterLink],
    templateUrl: 'src/contact/components/contact-form.html'
})
export class ContactEditComponent implements OnInit {
  public contact: Contact;
  private _contactService: ContactService;
  private _routeParams: RouteParams;

  constructor(
    contactService: ContactService,
    routerParams: RouteParams
  ) {
    this._contactService = contactService;
    this._routeParams = routerParams;
  }

  ngOnInit() {
    const id: string = this._routeParams.get('id');
    this.contact = new Contact();
    this._contactService
    .contact.subscribe((contact) =&gt; {
      this.contact = contact;
    });
    this._contactService.getOne(id);
  }

  onSubmit(event) {
    event.preventDefault();

    this._contactService
    .update(this.contact)
    .subscribe((contact) =&gt; {
      this.contact = contact;
    }, err =&gt; console.error(err));
  }
}</pre></div><p class="calibre8">We are not so far away from the <code class="email">ContactCreateComponent</code>, the structure of the class is almost the same. Instead of the <code class="email">Router</code>, we are using <code class="email">RouteParams</code> to load the ID from the URL and retrieve the desired contact from the Express application. </p><p class="calibre8">We subscribe <a id="id105" class="calibre1"/>to the contact <code class="email">Observable</code> returned by the <code class="email">ContactService</code> to get the new data. In other words our component will react to the data stream and when the data is available it will display it to the user.</p><p class="calibre8">When submitting the form, we update the contact persisted in MongoDB and change the view's <code class="email">contact</code> object with the freshly received data from the backend.</p></div></div>
<div class="book" title="Finishing touch" id="KVCC1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Finishing touch</h1></div></div></div><p class="calibre8">We have added all the <a id="id106" class="calibre1"/>necessary modules into our application. We should also take a final look at our main app component, found under the following path—<code class="email">contact-manager/public/src/app.component.ts</code>:</p><div class="informalexample"><pre class="programlisting">import { Component } from 'angular2/core';
import { RouteConfig, RouterOutlet } from 'angular2/router';
import { Router } from 'angular2/router';
import { AuthHttp } from './auth/auth-http';
import { Signin } from './auth/signin';
import { Register } from './auth/register';
import { ContactComponent } from './contact/components/contact.component';

@RouteConfig([
  { path: '/signin', as: 'Signin', component: Signin },
  { path: '/register', as: 'Register', component: Register },
  { path: '/contacts/...', as: 'Contacts', component: ContactComponent, useAsDefault: true }
])
@Component({
    selector: 'cm-app',
    directives: [
      Signin,
      Register,
      ContactComponent,
      RouterOutlet
    ],
    template: `
      &lt;div class="app-wrapper col card whiteframe-z2"&gt;
        &lt;div class="row"&gt;
          &lt;h3&gt;Contact manager&lt;/h3&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      &lt;/div&gt;
    `
})
export class AppComponent {
  private _authHttp: AuthHttp;
  private _router: Router;

  constructor(authHttp: AuthHttp, router: Router) {
    this._authHttp = authHttp;
    this._router = router;
    this._authHttp.unauthorized.subscribe((res) =&gt; {
      if (res) {
        this._router.navigate(['./Signin']);
      }
    });
  }
}</pre></div><p class="calibre8">We mount all the components to their specific routes. Also, when we mount the <code class="email">Contact</code> component, we'll bring in all the configured routes from the component. </p><p class="calibre8">In order to be notified when a request is unauthorized, we subscribe to the <code class="email">AuthHttp</code> service's <code class="email">unauthorized</code> data stream. If a request needs authentication, we redirect the user to the sign-in page.</p><p class="calibre8">The boot file for our <a id="id107" class="calibre1"/>application will look something like this:</p><div class="informalexample"><pre class="programlisting">import { bootstrap } from 'angular2/platform/browser';
import { provide } from 'angular2/core';
import { HTTP_PROVIDERS } from 'angular2/http';
import { ROUTER_PROVIDERS, LocationStrategy, HashLocationStrategy } from 'angular2/router';
import { AuthHttp } from './auth/auth-http';
import { AuthService } from './auth/auth.service';
import { ContactService } from './contact/contact.service';
import { AppComponent } from './app.component';

import 'rxjs/add/operator/map';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';

bootstrap(AppComponent, [
  ROUTER_PROVIDERS,
  HTTP_PROVIDERS,
  AuthService,
  AuthHttp,
  ContactService,
  provide(LocationStrategy, {useClass: HashLocationStrategy})
]);</pre></div><p class="calibre8">We import and define the necessary providers and also add the operators we used from RxJs. This is because Angular, by default, uses only a stripped-down version of the Observable module.</p><p class="calibre8">Through the contact module we used a custom class named <code class="email">Contact</code>, which plays the role of a <code class="email">Contact</code> model. This will be instantiated any time we want to make sure we are working with a contact entity. Besides, the nice thing about TypeScript is that it enables us to use structured code.</p><p class="calibre8">Classes come in handy when we want to have initial values, for example, in our components we used a <code class="email">contact.image</code> property to display a contact's profile image. This was not <a id="id108" class="calibre1"/>implemented in the backend, so we use a mock URL for an image. Let's see the <code class="email">Contact</code> class, <code class="email">public/src/contact/contact.ts</code>:</p><div class="informalexample"><pre class="programlisting">export class Contact {
  _id: string;
  email: string;
  name: string;
  city: string;
  phoneNumber: string;
  company: string;
  image: string;
  createdAt: string;

  constructor(
    _id?: string,
    email?: string,
    name?: string,
    city?: string,
    phoneNumber?: string,
    company?: string,
    createdAt?: string
  ) {
    this._id = _id;
    this.email = email;
    this.name = name;
    this.city = city;
    this.phoneNumber = phoneNumber;
    this.company = company;
    this.image = 'http://placehold.it/171x100';
    this.createdAt = createdAt;
  }
}</pre></div><p class="calibre8">As you can see we just define what properties a contact instance can have and create a default value for the <code class="email">image</code> property. Arguments passed to the <code class="email">constructor</code> marked with <code class="email">?</code> are optional.</p><p class="calibre8">At this moment, we should have everything in place; in case you missed something, you can check out the final version of the code.</p><p class="calibre8">The key takeaways from this chapter are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Building backend web services using Node.js, Express, and MongoDB</li><li class="listitem">Writing tests first, before actually implementing functionalities</li><li class="listitem">Securing our <a id="id109" class="calibre1"/>API routes using Passport</li><li class="listitem">Making Angular 2 and Express communicate and work together</li><li class="listitem">Getting into Reactive Extensions and reactive programming</li><li class="listitem">Building a custom Angular HTTP service</li></ul></div></div>
<div class="book" title="Summary" id="LTSU1-5c78d361d97340239270192b72d53e7b"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This brings us to the end of this rather introductory chapter.</p><p class="calibre8">We went full stack, right from implementing our backend logic to learning to write tests before actual implementations. We exposed a RESTful route for our resources from MongoDB. We also built a small Angular 2 frontend application that interacts with the web server.</p><p class="calibre8">In the next chapter, we'll dive deeper into MongoDB and start working with monetary data. It should be a fun ride!</p></div></body></html>