<html><head></head><body>
        

                            
                    <h1 class="header-title">Animations</h1>
                
            
            
                
<p>In the previous chapter, we covered matrices, transformations, and cameras. So far, we have only discussed static scenes, where all interactions are done by moving the camera. With these interactions, a camera transformation is applied to all objects in the 3D scene; we therefore call it a <em>global</em> transform. However, objects in 3D scenes can have actions of their own. For instance, in a car-racing game, each car has its own speed and trajectory. In a first-person shooter game, enemies can hide behind barricades, come to fight, or simply run away. In general, each one of these actions is modeled as a matrix transformation that is attached to the corresponding actor in the scene. These are called <em>local</em> transforms.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn the difference between global and local transformations.</li>
<li>Learn about matrix stacks and how to use them to perform animations.</li>
<li>Use JavaScript timers to do time-based animations.</li>
<li>Learn about parametric curves.</li>
<li>Learn about interpolation.</li>
<li>Explore various interpolation techniques.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">WebGL Matrix Naming Conventions</h1>
                
            
            
                
<p>Before we go any further, let's take a moment to quickly summarize some of the conventions around matrix-naming. As we've seen, WebGL is a simple API with nearly everything – except for a few predefined names, such as <kbd>gl_Position</kbd> – defined by you, the programmer. That being said, common and semi-common naming conventions do exist. This is especially true for matrices. Here are a few important ones we’ve already covered, along with a few new ones that we’ll cover shortly:</p>
<ul>
<li><strong>World Matrix:</strong> Sometimes referred to as the <strong>Model matrix</strong>, this is a matrix that takes the vertices of a model and moves them to world space.</li>
<li><strong>Camera Matrix:</strong> This matrix positions the camera in the world. You can also think of it as the World matrix for the camera.</li>
<li><strong>View Matrix:</strong> This matrix moves everything else in the world in front of the camera. As we've seen, this is the inverse of the Camera matrix.</li>
<li><strong>Projection Matrix:</strong> This is the matrix that converts a frustum of space into clip space. You can also think of it as the matrix returned by your matrix math library's perspective or orthographic function.</li>
<li><strong>Local Matrix</strong>: The matrix is used in scene graphs, where the matrix, at any particular node on the graph, is used before multiplying with any other nodes.</li>
</ul>
<div><strong>Scene Graph<br/>
<br/></strong> This is a data structure, commonly used by vector-based graphics-editing applications and modern computer games, that arranges the logical and often spatial representation of a graphical scene. A scene graph is a collection of nodes in a graph or tree structure. For more information, please visit <a href="https://en.wikipedia.org/wiki/Scene_graph">https://en.wikipedia.org/wiki/Scene_graph</a><a href="https://en.wikipedia.org/wiki/Scene_graph">.</a><strong><br/></strong></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Matrix Stacks</h1>
                
            
            
                
<p>A <strong>matrix stack</strong> provides a way to apply local transforms to individual objects in our scene while preserving global transforms.</p>
<p>The matrix stack works as each rendering cycle (each call to our <kbd>render</kbd> function) requires calculating the scene matrices to react to camera movements. We first update the Model-View matrix for each object in our scene before passing the matrices to the shading program (as <kbd>attributes</kbd>). We do this in three steps:</p>
<ol>
<li>Once the global Model-View matrix (such as camera transform) has been calculated, we save (push) it onto a stack. This allows us to recover the original matrix once we’ve applied local transforms.</li>
<li>Calculate an updated Model-View matrix for each object in the scene. This update consists of multiplying the original Model-View matrix by a matrix that represents the rotation, translation, and/or scaling of each object in the scene. The updated Model-View matrix is passed to the program and the respective object then appears in the location indicated by its local transform.</li>
<li>Recover the original matrix from the stack, and then repeat steps one to three for the next object that needs to be rendered.</li>
</ol>
<p>The following diagram shows this three-step procedure for one object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/642dbed2-267e-4027-babe-57452aa9d79a.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating a 3D scene</h1>
                
            
            
                
<p>Animating a scene is nothing more than applying the appropriate local transformations to the objects in the scene. For instance, if we want to move a cone and a sphere, each one of them will have a corresponding local transformation that will describe its location, orientation, and scale. In the previous section, we learned that matrix stacks allow us to preserve the original Model-View transform so that we can apply the correct local transforms to each object.</p>
<p>Now that we know how to move objects with local transforms and matrix stacks, we should address w<em>hen</em> to apply these transforms.</p>
<p>If we calculate the position to apply to the cone and sphere in our example every time we call the <kbd>render</kbd> function, this would imply that the animation rate would depend on the speed of our rendering cycle. A slow rendering cycle would produce choppy animations and too fast a rendering cycle would create the illusion of objects jumping from one side to the other without smooth transitions.</p>
<p>Therefore, it is important to make the animation independent of the rendering cycle. There are a couple of solutions that we can use to achieve this goal: the <kbd>requestAnimationFrame</kbd> function and JavaScript timers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The requestAnimationFrame Function</h1>
                
            
            
                
<p>The <kbd>requestAnimationFrame</kbd> function is available in all WebGL-enabled browsers. One of the advantages of leveraging this function is that it is designed to call the rendering function (whatever function we indicate) only when the browser/tab window is in focus. Otherwise, there is no call. This saves precious CPU, GPU, and memory resources. By using the <kbd>requestAnimationFrame</kbd> function, we can obtain a rendering cycle that is in sync with hardware capabilities and one that will automatically suspend itself when the window is out of focus.</p>
<p>requestAnimationFrame<br/>
<br/>
To check out the status of <kbd>requestAnimationFrame</kbd> in your browser, visit <a href="https://caniuse.com/#search=requestanimationframe">https://caniuse.com/#search=requestanimationframe</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript Timers</h1>
                
            
            
                
<p>That said, <kbd>requestAnimationFrame</kbd> is not a magical function that is a complete black box. It’s important to remember that we can implement our own in situations where it's not available or if we want a tailored animation experience. To do so, we will use two JavaScript timers to isolate the rendering rate from the animation rate.</p>
<p>Unlike the <kbd>requestAnimationFrame</kbd> function, JavaScript timers continue running in the background, even when the page is not in focus. This is not optimal performance since computer resources are allocated toward a scene that is not in view. To mimic some of the intelligent behavior of <kbd>requestAnimationFrame</kbd>, we can use the <kbd>onblur</kbd> and <kbd>onfocus</kbd> events of the JavaScript window object.</p>
<p>Let's see what we can do:</p>
<table border="1" style="border-collapse: collapse;width: 100%;border-color: #000000">
<tbody>
<tr>
<td style="width: 12.5847%"><strong>Action (What)</strong></td>
<td style="width: 34.6563%"><strong>Goal (Why)</strong></td>
<td style="width: 51.8877%"><strong>Method (How)</strong></td>
</tr>
<tr>
<td style="width: 12.5847%">Pause the rendering</td>
<td style="width: 34.6563%">To stop the rendering until the window is in focus.</td>
<td style="width: 51.8877%">Clear the timer calling <kbd>clearInterval</kbd> in the <kbd>window.onblur</kbd> function.</td>
</tr>
<tr>
<td style="width: 12.5847%">Slow the rendering</td>
<td style="width: 34.6563%">To reduce resource consumption but make sure that the 3D scene keeps evolving, even if we’re not looking at it.</td>
<td style="width: 51.8877%">We can clear current timer calling <kbd>clearInterval</kbd> in the <kbd>window.onblur</kbd> function and create a new timer with a more relaxed interval (higher value).</td>
</tr>
<tr>
<td style="width: 12.5847%">Resume the rendering</td>
<td style="width: 34.6563%">To activate the 3D scene at full speed when the browser window recovers its focus.</td>
<td style="width: 51.8877%">We start a new timer with the original render rate in the <kbd>window.onfocus</kbd> function.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>By reducing the JavaScript timer rate or clearing the timer, we can handle hardware resources more efficiently.</p>
<p>Controlling the Render Cycle<br/>
<br/>
An example of this sort of low-level functionality can be seen in the <kbd>common/js/Clock.js</kbd> file. With this universal clock, you can see how the <kbd>onblur</kbd> and <kbd>onfocus</kbd> events have been used to control the clock ticking (the rendering cycle), as we described previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Timing Strategies</h1>
                
            
            
                
<p>If you've programmed animations in JavaScript before, you may have used either <kbd>setInterval</kbd> or <kbd>setTimeout</kbd> to get your drawing function to be called.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The problem with using these two approaches for drawing is that they have no relation to the browser's render cycle. That is, they aren't synced to when the browser is going to draw a new frame, which can leave the animation out of sync with the user's machine. For example, if you use <kbd>setInterval</kbd> or <kbd>setTimeout</kbd> and assume <kbd>60</kbd> frames a second, and the user's machine is actually running a different frame rate, you'll be out of sync with their machine.</p>
<p>Even though <kbd>requestAnimationFrame</kbd> is available on all WebGL-enabled browsers, we'll leverage our own animation JavaScript timers for educational purposes. In production, it is recommended that you leverage the browser's optimized version.</p>
<p>In this section, we will create a JavaScript timer that will allow us to control the animation. As we mentioned previously, we will implement a JavaScript timing strategy that provides independence between how fast your computer can render frames and how fast you want the animation to go. We will refer to this property as the <strong>animation rate</strong>.</p>
<p>Before moving forward, we must address a caveat about working with timers: <em>JavaScript is not a multithreaded language</em>. This means that if there are several asynchronous events occurring at the same time (blocking events), the browser will queue them for posterior execution. Each browser has a different mechanism to deal with blocking event queues.</p>
<p>There are two blocking event-handling alternatives for the purpose of developing an animation timer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animation Strategy</h1>
                
            
            
                
<p>The first alternative is to calculate the elapsed time inside the timer callback. The pseudocode looks like this:</p>
<pre>const animationRate = 30; // 30 ms<br/><br/>let initialTime, elapsedTime;<br/><br/>function animate(deltaT) {<br/>  // calculate object positions based on deltaT<br/>}<br/><br/>function onFrame() {<br/>  const currentTime = new Date().getTime();<br/>  elapsedTime = currentTime - initialTime;<br/>  if (elapsedTime &lt; animationRate) return; // come back later<br/>  animate(elapsedTime);<br/>  initialTime = currentTime;<br/>}<br/><br/>function startAnimation() {<br/>  setInterval(onFrame, animationRate / 1000);<br/>}</pre>
<p>In doing so, we guarantee that the animation time is independent of how often the timer callback is actually executed. If there are big delays (due to other blocking events), this method may result in <strong>dropped frames</strong>. This means that the object's positions in our scene will immediately be moved to the current position that they should be in according to the elapsed time (between consecutive animation timer callbacks), and then the intermediate positions will be ignored. The motion on screen may jump, but often, a dropped animation frame is an acceptable loss in a real-time application. One example is the movement of one object from point <kbd>A</kbd> to point <kbd>B</kbd> over a given period of time. However, if we used this strategy when shooting a target in a 3D shooting game, we could quickly run into problems. Imagine that you are trying to shoot a target where there is a delay. The next thing you know, the target is no longer there! Since we need to calculate a collision in this case, we cannot afford to miss frames. This is because the collision could occur in any of the frames that we would drop without analyzing. The following strategy solves this problem.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simulation Strategy</h1>
                
            
            
                
<p>There are several applications, such as the shooting game example, that require all intermediate frames to ensure the integrity of the outcome. These applications include working with collision detection, physics simulations, or artificial intelligence for games. For games, we need to update the object's positions at a constant rate. We do so by directly calculating the next position for the objects inside the timer callback:</p>
<div><pre>const animationRate = 30; // 30 ms<br/>const deltaPosition = 0.1;<br/><br/>function animate(deltaP) {<br/>  // Calculate object positions based on deltaP<br/>}<br/><br/>function onFrame() {<br/>  animate(deltaPosition);<br/>}<br/><br/>function startAnimation() {<br/>  setInterval(onFrame, animationRate / 1000);<br/>}</pre></div>
<p>This may lead to <strong>frozen frames</strong> that occur when there is a long list of blocking events because the object's positions would not be updated in a timely manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combined Approach: Animation and Simulation</h1>
                
            
            
                
<p>Generally speaking, browsers can efficiently handle blocking events, and in most cases, performance would be similar regardless of the chosen strategy. Deciding to calculate the elapsed time or the next position in timer callbacks will then depend on your particular application.</p>
<p>Nonetheless, there are cases where it is desirable to combine both animation and simulation strategies. We can create a timer callback that calculates the elapsed time and updates the animation as many times as required per frame. The pseudocode looks like the following:</p>
<div><pre>const animationRate = 30; // 30 ms<br/>const deltaPosition = 0.1;<br/><br/>let initialTime, elapsedTime;<br/><br/>function animate(delta) {<br/>  // Calculate object positions based on delta<br/>}<br/><br/>function onFrame() {<br/>  const currentTime = new Date().getTime();<br/>  elapsedTime = currentTime - initialTime;<br/>  if (elapsedTime &lt; animationRate) return; // come back later!<br/>  let steps = Math.floor(elapsedTime / animationRate);<br/>  while (steps &gt; 0) {<br/>    animate(deltaPosition);<br/>    steps -= 1;<br/>  }<br/>  initialTime = currentTime;<br/>}<br/><br/>function startAnimation() {<br/>  initialTime = new Date().getTime();<br/>  setInterval(onFrame, animationRate / 1000);<br/>}</pre></div>
<p>The preceding code snippet demonstrates that the animation will always update at a fixed rate, regardless of how much time elapses between frames. If the app is running at <kbd>60</kbd> Hz, the animation will update once every other frame; if the app runs at <kbd>30</kbd> Hz, the animation will update once per frame; if the app runs at <kbd>15</kbd> Hz, the animation will update twice per frame. The animation remains far more stable and deterministic if it is always moved forward by a fixed amount.</p>
<p>The following sequence shows the responsibilities of each function in the call stack for the combined approach:</p>
<ul>
<li><kbd>render</kbd>:
<ul>
<li>Starts the timer</li>
<li>Sets the animation rate</li>
<li>The timer callback is the <kbd>onFrame</kbd> function</li>
</ul>
</li>
<li><kbd>onFrame</kbd>:
<ul>
<li>Calculates the elapsed time since the last call.</li>
<li>If the elapsed time is less than the animation rate, then it returns without further processing. Otherwise, it calculates the number of frames that the animation needs to be updated.</li>
<li>Updates the animation by calling the <kbd>animate</kbd> function.</li>
</ul>
</li>
<li><kbd>animate</kbd>:
<ul>
<li>Updates the object positions by a fixed increment. In this example, the sphere is updated by <kbd>0.1</kbd> units every time <kbd>animate</kbd> is called.</li>
<li>It calls <kbd>draw</kbd> to update the object on screen. This is <em>optional</em>, since the rendering loop calls <kbd>draw</kbd> periodically anyway.</li>
</ul>
</li>
<li><kbd>draw</kbd>:
<ul>
<li>Creates a local transformation using the new position calculated in <kbd>animate</kbd>, and it applies it to the corresponding object.</li>
</ul>
</li>
</ul>
<p>The code looks something like this:</p>
<pre>transforms.calculateModelView();<br/>transforms.push();<br/><br/>if (object.alias === 'sphere') {<br/>  const sphereTransform = transforms.modelViewMatrix;<br/>  mat4.translate(sphereTransform, sphereTransform, [0, 0, spherePosition]);<br/>}<br/>else if (object.alias === 'cone') {<br/>  const coneTransform = transforms.modelViewMatrix;<br/>  mat4.translate(coneTransform, coneTransform, [conePosition, 0, 0]);<br/>}<br/><br/>transforms.setMatrixUniforms();<br/>transforms.pop();</pre>
<p>This approach may cause issues if an animation step actually takes longer to compute than the fixed step. If this occurs, you should simplify your animation code or release a recommended minimum system spec for your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web Workers: Multithreading in JavaScript</h1>
                
            
            
                
<p>Though outside the scope of this book, you should consider using <strong>Web Workers</strong> if performance is critical to you. Doing so will ensure that a particular update loop always fires at a consistent rate.</p>
<p>Web Workers is an API that allows web applications to spawn background processes that run scripts in parallel to their main page. This allows for thread-like operation with message-passing as the coordination mechanism.</p>
<p>Web Workers<br/>
<br/>
You can find the Web Workers specification at <a href="http://dev.w3.org/html5/workers/">http://dev.w3.org/html5/workers/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architectural Updates</h1>
                
            
            
                
<p>Let's review the structure of the examples developed in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">App Review</h1>
                
            
            
                
<p>The <kbd>init</kbd> function defines three function hooks that control the life cycle of the application. As we've covered in previous chapters, we create our application by invoking the <kbd>init</kbd> function. Then, we call the hooks to the <kbd>configure</kbd>, <kbd>load</kbd>, and <kbd>render</kbd> functions. Also, please note that the <kbd>init</kbd> function is the entry point for the application and it is automatically invoked using the <kbd>onload</kbd> event of the web page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Support for Matrix Stacks</h1>
                
            
            
                
<p>We've also added a new script: <kbd>Transforms.js</kbd>. This file contains the <kbd>Transforms</kbd> class that encapsulate the matrix-handling operations, including the <kbd>push</kbd> and <kbd>pop</kbd> matrix stack operations. The <kbd>Transforms</kbd> class replaces the functionality behind the <kbd>initTransforms</kbd>, <kbd>updateTransforms</kbd>, and <kbd>setMatrixUniforms</kbd> functions.</p>
<p>You can find the source code for SceneTransforms in <kbd>common/js/Transforms.js</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting Matrix Stacks and JavaScript Timers</h1>
                
            
            
                
<p>In the following section, we will investigate a simple scene where we’ve animated a cone and a sphere. We will use matrix stacks to implement local transformations and JavaScript timers to implement the animation sequence.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Simple Animation</h1>
                
            
            
                
<p>Let's look at an example covering a simple animation technique:</p>
<ol>
<li>Open <kbd>ch05_01_simple-animation.html</kbd> in your browser:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d37c4b9e-baa4-4ed9-aa77-47337b58ccb2.png"/></p>
<ol start="2">
<li>Move the camera around (left mouse-click + drag) and see how the objects (sphere and cone) move independently of one another (local transformations) and the camera (global transformation).</li>
<li>You can also dolly the camera (left mouse-click + <em>Alt</em> + drag).</li>
<li>Change the camera type to Tracking. If for any reason you lose your bearings, click on Go Home.</li>
<li>Let's examine the source code to see how we’ve implemented this example. Open <kbd>ch05_01_simple-animation.html</kbd> in a code editor.</li>
<li>Take a look at the <kbd>render</kbd>, <kbd>onFrame</kbd>, and <kbd>animate</kbd> functions. Which timing strategy are we using here?</li>
</ol>
<ol start="7">
<li>The <kbd>spherePosition</kbd> and <kbd>conePosition</kbd> global variables contain the position of the sphere and the cone, respectively. Scroll up to the <kbd>draw</kbd> function. Inside the main loop where each object scene is rendered, a different local transformation is calculated depending on the current object being rendered. The code looks like the following:</li>
</ol>
<div><pre style="padding-left: 60px">function draw() {<br/>  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);<br/>  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<br/><br/>  <strong>transforms.updatePerspective();<br/></strong><br/>  try {<br/>    gl.uniform1i(program.uUpdateLight, fixedLight);<br/><br/>    scene.traverse(object =&gt; {<br/>      <strong>transforms.calculateModelView();<br/>      transforms.push();<br/><br/>      if (object.alias === 'sphere') {</strong><br/><strong>        const sphereTransform = transforms.modelViewMatrix;<br/>        mat4.translate(sphereTransform, sphereTransform, [0, 0, <br/>         spherePosition]);<br/>      }</strong><br/><strong>      else if (object.alias === 'cone') {</strong><br/><strong>        const coneTransform = transforms.modelViewMatrix;<br/>        mat4.translate(coneTransform, coneTransform, [conePosition, <br/>         0, 0]);<br/>      }</strong><br/><br/><strong>      transforms.setMatrixUniforms();<br/>      transforms.pop();<br/></strong><br/>      gl.uniform4fv(program.uMaterialDiffuse, object.diffuse);<br/>      gl.uniform4fv(program.uMaterialSpecular, object.specular);<br/>      gl.uniform4fv(program.uMaterialAmbient, object.ambient);<br/>      gl.uniform1i(program.uWireframe, object.wireframe);<br/><br/>      // Bind VAO<br/>      gl.bindVertexArray(object.vao);<br/><br/>      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);<br/><br/>      if (object.wireframe) {<br/>        gl.drawElements(gl.LINES, object.indices.length, <br/>         gl.UNSIGNED_SHORT, 0);<br/>      }<br/>      else {<br/>        gl.drawElements(gl.TRIANGLES, object.indices.length, <br/>         gl.UNSIGNED_SHORT, 0);<br/>      }<br/><br/>      // Clean<br/>      gl.bindVertexArray(null);<br/>      gl.bindBuffer(gl.ARRAY_BUFFER, null);<br/>      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);<br/>    });<br/>  }<br/>  catch (error) {<br/>    console.error(error);<br/>  }<br/>}</pre></div>
<ol start="8">
<li>Using the transforms object (which is an instance of <kbd>Transforms</kbd>), we obtain the global Model-View matrix by calling <kbd>transforms.calculateModelView()</kbd>. Push it into a matrix stack by calling the <kbd>push</kbd> method. We can now apply any transform that we want, knowing that we can retrieve the global transform since it is available for the next object on the list. We do so at the end of the code snippet by calling the <kbd>pop</kbd> method. Between the <kbd>push</kbd> and <kbd>pop</kbd> calls, we determine which object is currently being rendered and use the <kbd>spherePosition</kbd> or <kbd>conePosition</kbd> global variable to apply a translation to the current Model-View matrix. By doing so, we create a local transform.</li>
<li>Take a second look at the preceding code. As you saw at the beginning of this exercise, the cone is moving in the x-axis while the sphere is moving in the z-axis. What do you need to change to animate the cone in the y-axis? Test your hypothesis by modifying this code, saving the web page, and opening it again in your web browser.</li>
<li>Let's return to the <kbd>animate</kbd> function. What should we modify here to make the objects move faster?</li>
</ol>
<p>Hint<strong><br/>
<br/></strong> Take a look at the global variables this function uses.</p>
<p><em><strong>What just happened?</strong></em></p>
<p>In this exercise, we saw a simple animation of two objects. We examined the source code to understand the call stack of functions that makes the animation possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Have a Go: Simulating Dropped and Frozen Frames</h1>
                
            
            
                
<p>Let's see how we can control the render rate:</p>
<ol>
<li>Open the <kbd>ch05_02_dropping-frames.html</kbd> file using your browser. Here, you will see the same scene we analyzed in the previous section. You’ll notice that the animation is not smooth because we are simulating dropping frames:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2ed16d5f-554b-4a79-a902-90640efc94f6.png" style="width:61.42em;height:32.50em;"/></p>
<ol start="2">
<li>Take a look at the source code in your editor.</li>
<li>Scroll to the <kbd>onFrame</kbd> function. You can see that we’ve included a new variable: <kbd>simulationRate</kbd>. In the <kbd>onFrame</kbd> function, this variable calculates how many simulation steps need to be performed when the time elapsed is around <kbd>300 ms</kbd> (<kbd>animationRate</kbd>). Given that <kbd>simulationRate</kbd> is <kbd>30 ms</kbd>, this will produce a total of <kbd>10</kbd> simulation steps. These steps can increase if there are unexpected delays and the elapsed time is considerably higher. This is the behavior that we expect.</li>
<li>Experiment with different values for the <kbd>animationRate</kbd> and <kbd>simulationRate</kbd> variables to answer the following questions:
<ul>
<li>How do we get rid of the dropping frames issue?</li>
<li>How can we simulate frozen frames?</li>
<li>What is the relationship between the <kbd>animationRate</kbd> and <kbd>simulationRate</kbd> variables when simulating frozen frames?</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Parametric Curves</h1>
                
            
            
                
<p>There are many situations where we don't know the exact position of an object at a given time, but we do know an equation that describes its movement. These equations are known as <strong>parametric curves</strong>; they are parametric because the position depends on one parameter—for example, the time.</p>
<p>There are many examples of parametric curves. For example, a projectile shot in a game, a car going downhill, or a bouncing ball. In each case, there are equations that describe the motion of these objects under ideal conditions. The following diagram shows the parametric equation that describes the free-fall motion:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fa1aee03-0e31-469f-a5f5-8c68f39fb723.png" style="width:52.83em;height:32.17em;"/></p>
<pre class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="img/fb4b2754-516b-4b2a-831b-ceabc9274148.png" style="width:12.08em;height:2.83em;"/></pre>
<p>Where:</p>
<ul>
<li><kbd><img class="fm-editor-equation" src="img/f9b25215-a7b1-4e98-9f13-401c373d2969.png" style="width:0.58em;height:1.00em;"/></kbd>: Gravity at <kbd><img class="fm-editor-equation" src="img/1a9485fd-ce69-4ce7-9a9c-231b2e71a06f.png" style="width:3.75em;height:1.33em;"/></kbd></li>
<li><kbd><img class="fm-editor-equation" src="img/8bb375bf-01ed-4cde-9cda-2c7ac33d0807.png" style="width:1.17em;height:1.08em;"/></kbd>: Initial velocity</li>
<li><kbd><img class="fm-editor-equation" src="img/3176d700-ce2d-48ee-912f-243c75e96a4a.png" style="width:1.42em;height:1.08em;"/></kbd>: Initial Position</li>
<li><kbd><img class="fm-editor-equation" src="img/bb542fe3-b290-46fe-a77f-13ba6d11434d.png" style="width:0.42em;height:0.92em;"/></kbd>: Time</li>
<li><kbd><img class="fm-editor-equation" src="img/525e9640-f7e2-4759-999c-ab45bbf9fb68.png" style="width:0.67em;height:1.00em;"/></kbd>: Position</li>
</ul>
<p>We are going to use parametric curves to animate objects in a WebGL scene. In this example, we will model a set of bouncing balls. The complete source code for this exercise can be found in <kbd>ch05_03_bouncing-balls.html</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initialization Steps</h1>
                
            
            
                
<p>We will create a global variable that will store the (simulation) time. We will also create the global variables that regulate the animation:</p>
<div><pre>let<br/>  gl, scene, program, camera, transforms,<br/>  elapsedTime, initialTime,<br/>  fixedLight = false,<br/>  balls = [],<br/>  sceneTime = 0,<br/>  animationRate = 15,<br/>  gravity = 9.8,<br/>  ballsCount = 50;</pre></div>
<p>The <kbd>load</kbd> function is updated to load a bunch of balls using the same geometry (same JSON file), but we are adding it several times to the <kbd>scene</kbd> object. The code looks like this:</p>
<div><pre>function load() {<br/>  scene.add(new Floor(80, 2));<br/>  for (let i = 0; i &lt; ballsCount; i++) {<br/>    balls.push(new BouncingBall());<br/>    scene.load('/common/models/geometries/ball.json', `ball${i}`);<br/>  }<br/>}</pre></div>
<p>ES6 Template Literals<strong><br/>
<br/></strong> If you're not familiar with the <kbd>`ball${i}`</kbd> syntax, it's equivalent to <kbd>'ball' + i</kbd>. Instead of concatenating strings, we can leverage template literals in ES6 for dynamic string values. For more information, check out <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</a>.</p>
<p>Notice that we’ve also populated an array named <kbd>balls[]</kbd>. We do this so that we can store the ball positions every time the global time changes. We will talk in depth about the bouncing ball simulation in the next <em>Time for action</em> section. For the moment, it’s worth mentioning that it is on the <kbd>load</kbd> function that we load the geometry and initialize the ball array with the initial ball positions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the Animation Timer</h1>
                
            
            
                
<p>The <kbd>render</kbd> and <kbd>onFrame</kbd> functions look exactly the same as in the previous examples:</p>
<div><pre>function onFrame() {<br/>  elapsedTime = (new Date).getTime() - initialTime;<br/>  if (elapsedTime &lt; animationRate) return;<br/><br/>  let steps = Math.floor(elapsedTime / animationRate);<br/>  while (steps &gt; 0) {<br/>    animate();<br/>    steps -= 1;<br/>  }<br/><br/>  initialTime = (new Date).getTime();<br/>}<br/><br/>function render() {<br/>  initialTime = (new Date).getTime();<br/>  setInterval(onFrame, animationRate / 1000);<br/>}</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the Animation</h1>
                
            
            
                
<p>The <kbd>animate</kbd> function passes the <kbd>sceneTime</kbd> variable to the <kbd>update</kbd> method of every ball in the ball array. Then, <kbd>sceneTime</kbd> updates by a fixed amount. The code looks like this:</p>
<div><pre>function animate() {<br/>  balls.forEach(ball =&gt; ball.update(sceneTime));<br/>  sceneTime += 33 / 1000;<br/>  draw();<br/>}</pre></div>
<p>Again, parametric curves are very helpful because they don’t require us to know the location of every object that we want to move beforehand. We just apply a parametric equation that gives us the location based on the current time. This occurs for every ball inside its update method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing Each Ball in Its Current Position</h1>
                
            
            
                
<p>In the <kbd>draw</kbd> function, we use a matrix stack to save the state of the Model-View matrix before applying a local transformation for each one of the balls. The code looks like this:</p>
<div><pre>function draw() {<br/>  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);<br/>  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);<br/>  <br/><strong>  transforms.updatePerspective();<br/></strong><br/>  try {<br/>    gl.uniform1i(program.uUpdateLight, fixedLight);<br/><br/>    scene.traverse(object =&gt; {<br/>      <strong>transforms.calculateModelView();<br/> transforms.push();<br/><br/> if (~object.alias.indexOf('ball')) {</strong><br/><strong> const index = parseInt(object.alias.substring(4, 8));<br/> const ballTransform = transforms.modelViewMatrix;<br/> mat4.translate(ballTransform, ballTransform, balls[index].position);<br/> object.diffuse = balls[index].color;<br/> }</strong><br/><br/><strong> transforms.setMatrixUniforms();<br/> transforms.pop();<br/></strong><br/>      gl.uniform4fv(program.uMaterialDiffuse, object.diffuse);<br/>      gl.uniform4fv(program.uMaterialSpecular, object.specular);<br/>      gl.uniform4fv(program.uMaterialAmbient, object.ambient);<br/><br/>      gl.uniform1i(program.uWireframe, object.wireframe);<br/>      gl.uniform1i(program.uPerVertexColor, object.perVertexColor);<br/><br/>      // Bind<br/>      gl.bindVertexArray(object.vao);<br/>      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);<br/><br/>      if (object.wireframe) {<br/>        gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, <br/>         0);<br/>      }<br/>      else {<br/>        gl.drawElements(gl.TRIANGLES, object.indices.length, <br/>         gl.UNSIGNED_SHORT, 0);<br/>      }<br/><br/>      // Clean<br/>      gl.bindVertexArray(null);<br/>      gl.bindBuffer(gl.ARRAY_BUFFER, null);<br/>      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);<br/>    });<br/>  }<br/>  catch (error) {<br/>    console.error(error);<br/>  }<br/>}</pre></div>
<p>The trick here is to use the number that makes up part of the ball alias to look up the respective ball position in the <kbd>balls</kbd> array. For example, if the ball being rendered has the <kbd>ball32</kbd> alias, then this code will look for the current position of the ball whose index is <kbd>32</kbd> in the <kbd>balls</kbd> array. This one-to-one correspondence between the <kbd>ball</kbd> alias and its location in the ball array was established in the <kbd>load</kbd> function.</p>
<p>In the following <em>Time for Action</em> section, we will see the bouncing balls animation in action. We will also discuss some of the code detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Bouncing Ball</h1>
                
            
            
                
<p>Let's look at an example covering how we'd animate many objects in our scene:</p>
<ol>
<li>Open <kbd>ch05_03_bouncing-balls.html</kbd> in your browser:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/093df5f6-3ddc-40bd-8125-5fe9ba38125c.png"/></p>
<ol start="2">
<li>The orbiting camera is activated by default. Move the camera and you will see how all the objects adjust to the global transform (camera) and continue bouncing according to their local transforms.</li>
<li>Let's explain how we keep track of each ball in more detail.</li>
<li>Define the appropriate global variables and constants:</li>
</ol>
<div><pre style="padding-left: 60px">let<br/>  gl, scene, program, camera, transforms,<br/>  elapsedTime, initialTime,<br/>  fixedLight = false,<br/>  balls = [],<br/>  sceneTime = 0,<br/>  animationRate = 15,<br/>  gravity = 9.8,<br/>  ballsCount = 50;</pre></div>
<ol start="5">
<li>Initialize the <kbd>balls</kbd> array. We use a <kbd>for</kbd> loop in the <kbd>load</kbd> function to achieve this:</li>
</ol>
<div><pre style="padding-left: 60px">function load() {<br/>  scene.add(new Floor(80, 2));<br/>  for (let i = 0; i &lt; ballsCount; i++) {<br/>    balls.push(new BouncingBall());<br/>    scene.load('/common/models/geometries/ball.json', `ball${i}`);<br/>  }<br/>}</pre></div>
<ol start="6">
<li>The <kbd>BouncingBall</kbd> class initializes the simulation variables for each ball in the <kbd>balls</kbd> array. One of these attributes is the position, which we select randomly. You can see how we do this by using the <kbd>generatePosition</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">function generatePosition() {<br/>  return [<br/>    Math.floor(Math.random() * 50) - Math.floor(Math.random() * <br/>     50),<br/>    Math.floor(Math.random() * 30) + 50,<br/>    Math.floor(Math.random() * 50)<br/>  ];<br/>}</pre>
<ol start="7">
<li>After adding a new ball to the <kbd>balls</kbd> array, we add a new ball object (geometry) to the <kbd>scene</kbd> instance. Please note that the alias we create includes the current index of the ball object in the <kbd>balls</kbd> array. For example, if we add the 32nd ball to the array, the alias that the corresponding geometry will have in <kbd>scene</kbd> will be <kbd>ball32</kbd>.</li>
<li>The only other object that we add to the scene here is <kbd>Floor</kbd>. We have used this object in previous exercises. You can find the code for the <kbd>Floor</kbd> class in <kbd>common/js/Floor.js</kbd>.</li>
<li>Let's talk about the <kbd>draw</kbd> function. Here, we go through the elements of <kbd>scene</kbd> and retrieve each object's alias. If the alias contains the word <kbd>ball</kbd>, we know that the alias corresponds to its <kbd>index</kbd> in the ball array. We could have probably used an associative array here to make it look nicer, but doing so does not really change our goal. The main point here is to make sure that we can associate the simulation variables for each ball with the corresponding object (geometry) in <kbd>scene</kbd>.</li>
</ol>
<ol start="10">
<li>Notice that for each object (ball geometry) in <kbd>scene</kbd>, we extract the current position and the color from the respective <kbd>BouncingBall</kbd> instance in the <kbd>balls</kbd> array.</li>
<li>Alter the current Model-View matrix for each ball by using a matrix stack to handle local transformations, as described previously. In our case, we want the animation for each ball to be independent from the transformations of the camera and one another.</li>
<li>So far, we’ve described how the bouncing balls are created (<kbd>load</kbd>) and how they are rendered (<kbd>draw</kbd>). None of these functions modifies the current position of the balls. We do that by using <kbd>BouncingBall.update</kbd>. This code uses the animation time (the <kbd>sceneTime</kbd> global variable) to calculate the position for the bouncing ball. Since each <kbd>BouncingBall</kbd> has its own simulation parameters, we can calculate the position for each given position when <kbd>sceneTime</kbd> is provided . In short, the ball position is a function of time and, as such, it falls into the category of motion described by parametric curves.</li>
<li>The <kbd>BouncingBall.update</kbd> method is called inside the <kbd>animate</kbd> function. As we saw previously, this function is invoked by the animation timer each time the timer is up. Inside this function, you can see how the simulation variables are updated to reflect the current state of that ball in the simulation.</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>We’ve learned how to handle several object-local transformations while preserving global transformations by using a matrix stack strategy. In the bouncing ball example, we used an animation timer for the animation that is independent from the rendering timer. Finally, we saw how the bouncing ball <kbd>update</kbd> method shows how parametric curves work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimization Strategies</h1>
                
            
            
                
<p>If you play around a little bit and increase the value of the <kbd>ballsCount</kbd> global constant from <kbd>50</kbd> to <kbd>500</kbd>, you will start to notice that the frame rate degrades:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7cafae70-a0f1-4436-bcb8-5c180c2e0354.png"/></p>
<p>In the preceding screenshot, the rendering hovered roughly around <kbd>30</kbd> frames per second. Depending on your computer, the average time for the <kbd>draw</kbd> function can be higher than the frequency at which the animation timer callback is invoked. This will result in dropped frames. To correct this, we need to make the <kbd>draw</kbd> function faster. Let's see a couple of strategies to do this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing Batch Performance</h1>
                
            
            
                
<p>WebGL 2 adds some interesting features, such as <strong>geometry-instancing.</strong> This feature allows us to render the same instance of a single mesh with differing shader attributes using <strong>instancing</strong> and only one <kbd>render</kbd> call. Though instancing is limited, as it’s based on the same mesh only, it’s still a great way to improve performance if you have to draw the same meshes multiple times, especially if combined with shaders. While this functionality is provided in WebGL 2, we'll build our own geometry-optimization techniques for educational purposes. We will cover WebGL 2's geometry instancing feature in <a href="9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml">Chapter 11</a>, <em>WebGL 2 Highlights</em>.</p>
<p>How do we optimize our scene without using the WebGL 2 geometry-instancing API? We can use geometry-caching as a way to optimize the animation of a scene full of similar objects. This is the case in the bouncing balls example. Each bouncing ball has a different position and color. These features are unique and independent for each ball. However, all of the balls share the same geometry.</p>
<p>In the <kbd>load</kbd> function, for <kbd>ch05_03_bouncing-balls.html</kbd>, we created <kbd>50</kbd> vertex buffer objects (VBOs) for each ball. Additionally, the same geometry is loaded <kbd>50</kbd> times, and on every rendering loop (<kbd>draw</kbd> function), a different VBO is bound, despite the geometry being the same for all the balls!</p>
<p>In <kbd>ch05_04_bouncing-balls-optimized.html</kbd>, we modified the <kbd>load</kbd> and <kbd>draw</kbd> functions to handle geometry-caching. In the first place, the geometry is loaded just once (<kbd>load</kbd> function):</p>
<div><pre>function load() {<br/>  scene.add(new Floor(80, 2));<br/>  scene.add(new Axis(82));<br/>  scene.load('/common/models/geometries/ball.json', 'ball');<br/>}</pre></div>
<p>Second, when the object with the <kbd>'ball'</kbd> alias is the current object in the rendering loop (the <kbd>draw</kbd> function), the <kbd>drawBalls</kbd> delegate function is invoked. This function sets some of the uniforms that are common to all bouncing balls (so that we do not waste time passing them every time to <kbd>program</kbd> for every ball). After that, the <kbd>drawBall</kbd> function is invoked. This function will set up those elements that are unique for each ball. In our case, we set up the <kbd>program</kbd> uniform that corresponds to the ball color and the Model-View matrix, which is unique for each ball because of the local transformation (ball position):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/24f0cb7b-5c28-42c5-83d0-328ff3f9391e.png" style="width:39.75em;height:27.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing Translations in the Vertex Shader</h1>
                
            
            
                
<p>If you take a look at the code in <kbd>ch05_04_bouncing-balls-optimized.html</kbd>, you will see that we have taken an extra step to cache the Model-View matrix.</p>
<p>The basic idea behind this is to transfer the original matrix to the GPU (global) once and then perform the translation for each ball (local) inside the vertex shader. This change significantly improves the performance because of the parallel nature of the vertex shader.</p>
<p>This is what we do, step by step:</p>
<ol>
<li>Create a new uniform that tells the vertex shader whether it should perform a translation (<kbd>uTranslate</kbd>).</li>
<li>Create a new uniform that contains the ball position for each ball (<kbd>uTranslation</kbd>).</li>
</ol>
<ol start="3">
<li>Map these two new uniforms to JavaScript variables (we do this in the <kbd>configure</kbd> function):</li>
</ol>
<div><pre style="padding-left: 60px">// Create program variable that maps the uniform uTranslation<br/>gl.uniform3fv(program.uTranslation, [0, 0, 0]);<br/><br/>// Create program variable that maps the uniform uTranslate<br/>gl.uniform1i(program.uTranslate, false);</pre></div>
<ol start="4">
<li>Perform the translation inside the vertex shader. This part is probably the trickiest part since it requires a little bit of ESSL programming:</li>
</ol>
<div><pre style="padding-left: 60px">// Transformed vertex position<br/>vec3 vecPosition = aVertexPosition;<br/>if (uTranslate) {<br/>  vecPosition += uTranslation;<br/>}</pre></div>
<ol start="5">
<li>In this code fragment, we are defining <kbd>vecPosition</kbd>, a variable of the <kbd>vec3</kbd> type. If the <kbd>uTranslate</kbd> uniform is <kbd>true</kbd> (meaning we are trying to render a bouncing ball), then we update <kbd>vecPosition</kbd> with the translation. This is implemented using vector-addition.</li>
<li>Make sure that the transformed vertex carries the translation in case of having one, so the following line looks like this:</li>
</ol>
<div><pre style="padding-left: 60px">vec4 vertex = uModelViewMatrix * vec4(vecPosition, 1.0);</pre></div>
<ol start="7">
<li>In <kbd>drawBall</kbd>, pass the current ball position as the content for the <kbd>uTranslation</kbd> uniform:</li>
</ol>
<div><pre style="padding-left: 60px">gl.uniform3fv(program.uTranslation, ball.position);</pre></div>
<ol start="8">
<li>In <kbd>drawBalls</kbd>, set the <kbd>uTranslate</kbd> uniform to <kbd>true</kbd>:</li>
</ol>
<div><pre style="padding-left: 60px">gl.uniform1i(program.uTranslate, true);</pre></div>
<ol start="9">
<li>In <kbd>draw</kbd>, pass the Model-View matrix once for all balls by using the following line of code:</li>
</ol>
<div><pre style="padding-left: 60px">transforms.setMatrixUniforms();</pre></div>
<ol start="10">
<li>Increase the <kbd>ballsCount</kbd> global variable from <kbd>50</kbd> to <kbd>500</kbd> and watch how the application continues to perform reasonably well, regardless of the increased scene complexity. The improvement in execution times is shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c835db02-7b8a-4f89-ad15-4d7d7320ed9e.png"/></p>
<ol start="11">
<li>After these optimizations, the example runs at a smooth <kbd>60</kbd> frames per second. The optimized source code is available at <kbd>ch05_bouncing-balls-optimized.html</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Interpolation</h1>
                
            
            
                
<p>Interpolation greatly simplifies a 3D objects’ animation. Unlike parametric curves, it is not necessary to define the position of the object as a function of time. When interpolation is used, we only need to define control points or knots. The set of control points describes the path that a particular animate object will follow. There are many interpolation methods; however, it’s always a good idea to start with the basics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Linear Interpolation</h1>
                
            
            
                
<p>This method requires that we define the starting and ending points of the location of our object, along with the number of interpolating steps. The object will move on the line determined by the starting and ending points:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d131837a-66c0-4948-927f-a51d3512721b.png" style="width:31.67em;height:17.42em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Polynomial Interpolation</h1>
                
            
            
                
<p>This method allows us to determine as many control points as we want. The object will move from the starting point to the ending point and will pass through each one of the control points in between:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0828ec46-3b85-4064-863a-6816dfd6213d.png" style="width:33.50em;height:16.50em;"/></p>
<p>While using polynomials, an increasing number of control points can produce undesired oscillations on the object's path described by this technique. This is known as <strong>Runge's phenomenon</strong>. The following diagram illustrates the result of moving one of the control points of a polynomial described with <kbd>11</kbd> control points:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d62c7061-455c-4f57-9bbf-e7177702ea53.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">B-Splines</h1>
                
            
            
                
<p>This method is similar to polynomial interpolation with the difference that the control points are outside of the object's path. In other words, the object does not pass through the control points as it moves. In general, this method is common in computer graphics because the knots allow for much smoother path-generation than the polynomial equivalent at the same time that fewer knots are required. B-splines also respond better to Runge's phenomenon:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1725689b-aa39-4bd5-84f2-4a559af72f9d.png"/></p>
<p>In the following <em>Time for action</em> section, we will see in the three different interpolation techniques that have been introduced in practice: <strong>linear</strong>, <strong>polynomial</strong>, and <strong>b-spline</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Time for Action: Interpolation</h1>
                
            
            
                
<p>Let's cover an example showcasing various interpolation techniques:</p>
<ol>
<li>Open <kbd>ch05_05_interpolation.html</kbd> using your browser. You should see something similar to the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8043fa8a-ae62-4586-ba80-64153008709a.png"/></p>
<ol start="2">
<li>Inspect the code in an editor. Nearly all of the functions are the same as before, except for the new function called <kbd>interpolate</kbd>. This function interpolates the position in a linear fashion:</li>
</ol>
<pre style="padding-left: 60px">function interpolate() {<br/>  const [X0, Y0, Z0] = initialPosition;<br/>  const [X1, Y1, Z1] = finalPosition;<br/><br/>  const dX = (X1 - X0) / incrementSteps;<br/>  const dY = (Y1 - Y0) / incrementSteps;<br/>  const dZ = (Z1 - Z0) / incrementSteps;<br/><br/>  for (let i = 0; i &lt; incrementSteps; i++) {<br/>    position.push([X0 + (dX * i), Y0 + (dY * i), Z0 + (dZ * i)]);<br/>  }<br/>}</pre>
<ol start="3">
<li>Open up <kbd>ch05_06_interpolation-final.html</kbd> in your browser. You should see something similar to the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/65e81e88-8c6b-499f-9bcd-84cfcaffa39b.png"/></p>
<ol start="4">
<li>Select <strong>Linear</strong> interpolation if it is not already selected.</li>
<li>Move the start and end points using the slider provided.</li>
<li>Change the number of interpolation steps. What happens to the animation when you decrease the number of steps?</li>
<li>The code for the linear interpolation has been implemented in the <kbd>doLinearInterpolation</kbd> function.</li>
<li>Select <strong>Polynomial</strong> interpolation. In this example, we have implemented Lagrange's interpolation method. You can see the source code in the <kbd>doLagrangeInterpolation</kbd> function.</li>
<li>Three new control points (flags) appear on screen. Using the sliders provided on the web page, you can change the location of these control points. You can also change the number of interpolation steps:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/29507453-9d0a-45d5-831b-a5d0183ea39d.png"/></p>
<ol start="10">
<li>You may have also noticed that whenever the ball approaches one of the flags (with the exception of the start and end points), the flag changes color. To do that, we have written the ancillary <kbd>close</kbd> function. We use this function inside the <kbd>draw</kbd> routine to determine the color of the flags. If the current position of the ball, determined by <kbd>position[sceneTime]</kbd>, is close to one of the flag positions, the respective flag changes color. When the ball is far from the flag, the flag changes back to its original color.</li>
<li>Modify the source code so that each flag remains <em>activated</em>; that is, activated with the new color after the ball passes by until the animation loops back to the beginning. This happens when <kbd>sceneTime</kbd> is equal to <kbd>incrementSteps</kbd> (see the <kbd>animate</kbd> function).</li>
<li>Select the <strong>B-Spline</strong> interpolation. Notice how the ball does not reach any of the intermediate flags in the initial configuration. Is there any configuration you can test so that the ball passes through at least two of the flags?</li>
</ol>
<p><em><strong>What just happened?</strong></em></p>
<p>We’ve learned how to use interpolation to describe the movement of an object in our 3D world. We've also created very simple scripts to detect object proximity and alter our scene accordingly (changing flag colors, in this example). Reaction to proximity is a key element in game design!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Let’s summarize what we learned in this chapter:</p>
<ul>
<li>We saw how we can leverage matrix stacks to preserve global transformations while applying local transformations.</li>
<li>We covered the basic concepts behind object animations in WebGL. More specifically, we learned about the differences between local and global transformations.</li>
<li>We learned about the <kbd>requestAnimationFrame</kbd> browser and built our own version with JavaScript timers for animation.</li>
<li>An animation timer that is not tied up to the rendering cycle provides a lot of flexibility by ensuring that the time in the scene is independent of how fast it can be rendered on screen.</li>
<li>We distinguished between animation and simulation strategies for various problem-solving approaches.</li>
<li>We looked at interpolation methods and their various approaches.</li>
</ul>
<p>In the next chapter, we will play with colors and blending in a WebGL scene. We will study the interaction between objects and light colors, and learn how to create translucent objects.</p>


            

            
        
    </body></html>