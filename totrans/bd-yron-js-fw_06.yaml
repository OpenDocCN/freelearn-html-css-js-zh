- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Framework by Example
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter combines all the insight and architectural knowledge from *Parts
    1* and *2* of the book and puts it into practice. Follow along as we develop a
    simple JavaScript testing framework based on the patterns and best techniques
    we have seen so far. The practical approach will enable us to learn by example,
    as it is a great educational approach for software topics of this kind. The framework
    we build here is a new project developed specifically for this chapter. We can
    treat this new sample framework project as a “Hello World” exercise for JavaScript
    framework development. Our aim through this exercise is to train our abilities
    and apply them later on in real-world projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics for building a framework by example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll structure our initial approach for a new framework project, including
    determining the goals, stakeholders, and branding for creating something from
    scratch. This will largely involve putting the learnings of project considerations
    from [*Chapter 5*](B19014_05.xhtml#_idTextAnchor073) into practice.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll learn to outline a typical initial architecture design to get our
    implementation of a testing framework off the ground. This includes outlining
    how the components fit together and the unique features of the project and its
    interfaces. In addition, we’ll summarize the public interfaces that are expected
    by developers who will be utilizing our project.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we’ll walk through the implementation of our testing framework based
    on the created design, including core feature components, command-line implementation,
    browser testing integration, and more.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implemented framework code is in the book repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    The code for our sample framework is included in the `chapter6` directory. To
    follow the implementation explanation in this chapter, it is recommended to follow
    along with the framework files in the chapter directory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: To run the code, make sure to have *Node.js v20 or higher* installed (you can
    download it from [nodejs.org](http://nodejs.org)). To make it easier to manage
    different versions of Node.js, you can use a Node.js version manager tool such
    as `nvm` ([github.com/nvm-sh/nvm](http://github.com/nvm-sh/nvm)). Running `nvm`
    will automatically install the appropriate version of Node.js from the framework
    project directory, as the project is configured and tested for a particular version.
    Make sure to run `npm install` to fetch the project’s dependencies. Running `npm
    test` should output a set of passing tests. This means that your local configuration
    is all correctly set up. The interactive script will perform all these steps for
    you if you run `npm start` from the `chapter6` directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To test the frontend portion of this sample framework, please use the latest
    version of Chromium-based browsers or an updated version of Firefox. To debug
    the framework, refer to the *About debugging* section of [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030).
    You can use the approach as documented in that chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Determining goals and stakeholders and framework branding
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The subject of our framework practical exercise is a new JavaScript code testing
    framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Goals
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal we will try to achieve is to provide robust test tooling for projects
    of variable complexity. The primary objective of testing frameworks is to provide
    developers with a reliable, fast, and versatile platform for verifying their code’s
    functionality, performance, and stability. In addition, they aim to minimize the
    risk of potential errors and create a seamless development experience that ultimately
    results in a high-quality product.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish these project goals, our JavaScript framework will focus on executing
    tests quickly and accurately, supporting various reporter output formats, and
    fostering a developer-friendly environment. By prioritizing ease of use and integration
    with other JavaScript tools and application frameworks, we will aim to make the
    testing process as seamless and efficient as possible. The framework will also
    enable cross-platform testing across Node.js and real web browser environments,
    ensuring that code performs consistently and as expected in various contexts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A side condition of this particular project is to create a sandbox-like environment
    for you, the reader, by providing an extensible and more straightforward project
    that you can learn from. You are encouraged to run the code and play the role
    of a potential framework contributor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Stakeholders
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stakeholders of a new JavaScript code testing framework could include a
    variety of software engineers and web developers who have specific software testing
    needs. First and foremost, JavaScript developers can utilize this framework in
    their user-facing projects and include it in the development of other JavaScript
    software. This framework can be a full stack solution for testing code in multiple
    environments. In the developer community, we are trying to develop a framework
    that is suitable for frontend, backend, full stack developers, QA and DevOps engineers,
    and finally, other framework/library authors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Our stakeholders can benefit from the architectural features of this project.
    For example, if we are testing the code in a real browser environment, the developed
    framework could be a good selling point for frontend engineers. The choice of
    the JavaScript testing feature set that we enable by building this project might
    also create friction or incompatibility with some engineering workflows, such
    as running tests in older runtimes and browsers. Thus, mainly, we are targeting
    a subset of developers that can live on the bleeding edge of new features and
    easily keep their code base up to date with the latest environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: If we were developing a JavaScript code testing framework internally, our stakeholders
    would be the internal developers of a start-up or a bigger company. In this case,
    we could gather insights about which feature sets were most needed in the internal
    teams. In addition, particular features could be developed to target specific
    organizational needs. The iteration and stability of the project would depend
    on how it was used internally as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Both stakeholders and framework developers benefit from consistent project communication
    and identity. This is where our new framework can benefit a bit from adding some
    branding. More on that in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Framework branding
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into architecture and coding, spending some time on the branding
    and identity of our project can be beneficial for the sake of the project structure.
    Creating an identity around the framework is a common pattern in internal and
    public projects, as it clearly defines the project’s logical boundaries and provides
    context around the project in general. Creating an identity could be as simple
    as picking a temporary name for your new project. It can also be a more involved
    creative process as we establish a project name. The name will be useful for creating
    a *namespace* for our project and utilized internally by the code base and by
    tests/dependent projects as they load this new project. The name can, of course,
    be changed later with some *find and replace*, so the decision does not have to
    be final.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a new framework name for our new project and repurpose it for subsequent
    project advancements in *Chapters 7* and *8*. We define **Componium** as the overarching
    brand for the frameworks we develop in this book. The name is a play on the word
    *Component*, combined with a *-nium* ending, which gives this name a technological
    and software sound. Besides, the name is not fully unique, as a musical instrument
    from 1821 shares the name with our framework: [mim.be/en/collection-piece/componium](http://mim.be/en/collection-piece/componium).
    More importantly, it is not a problem for us because there are no conflicts for
    this name in the JavaScript ecosystem. Choosing a namespace has to come with some
    uniqueness, avoiding naming conflicts with existing developer tools.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the creative process, in *Figure 6**.1*, you can see our framework’s
    logo and color scheme, which can be used in documentation and presented in the
    project’s visual features:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: New framework name and logo](img/Figure_6.1_B19014.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: New framework name and logo'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The testing framework will be specifically known as *Componium Test*. The addition
    of identity assets is beneficial to make the project more identifiable and establish
    a stronger brand presence in the developer community, fostering trust and recognition.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: On the more technical side of things, creating a namespace for your project,
    as we did here with *componium*, can help on several occasions. Namespacing eliminates
    potential naming conflicts and collisions with other frameworks and helps us logically
    group the code base with its components for both internal and external developers.
    Depending on the type of framework project, creating a namespace can also make
    the code base approach more modular. We saw an example of this in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030),
    where Vue.js had the approach to namespace many of its packages in a `vue-*` namespace.
    In addition, namespacing can help facilitate framework customizations and extensions,
    such as other developers contributing plugins and additions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about creating an identity for our projects and with our
    branding exercise complete, we can move to the exciting part of architecting our
    new framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Architecting the new framework
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we’ll get to the architectural part of our practical approach. So far,
    we know what we are building and who we are building it for. It is now time to
    determine the shape of our feature set and see how we can enable those features
    for our users. The most basic use case that we would like to cover is generating
    assertions for JavaScript code, as presented here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code example tests the `helloReader()` function and verifies that
    the correct string is returned. Starting from these basics, to take things further,
    we spend time on core functionality and identifying out-of-scope features first.
    Later, this can help drive technical decisions, as we brainstorm the set of extended
    features that can be suitable for our project. Our strategy consists of comparing
    the features offered by existing testing tools, developing unique characteristics,
    and contemplating which capabilities are out of the initial scope.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To draw some feature comparisons, we can look at some frameworks from [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015). *Jest* and *Vitest* come to mind as they
    are frameworks comparable to what we are building in this chapter. In addition,
    other projects in the ecosystem are `jasmine`, `ava`, `tap`, `tape`, and `mocha`.
    Most of these projects provide an advanced testing interface with a specific test
    life cycle and different ways to create assertions. All these existing open source
    projects also provide a common set of core functionalities, such as executability
    to run the framework in different projects, different output formatting options,
    the ability to stub or spy on interfaces, and more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will examine some of the unique features that
    can be implemented as part of our initial approach to the *Componium* *Test* project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Selecting features
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Brainstorming a list of features for a testing framework can be both exhausting
    and exciting. There are just so many areas to cover in terms of testing tool development,
    with most of the feature set covering different areas of development. In the architecting
    example from the beginning of this section, we listed basic test use cases, and
    now we can expand on them. Here are some of the additional types of functionality
    that could help our project provide a better feature set to its stakeholders:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Capable test runner**: The framework exposes a test runner executable with
    the ability to execute a single or full suite of tests. It provides its users
    with a selective execution format to specify which tests to run, a feature that''s
    useful during development and debugging situations. The test runner also allows
    the users to define test cases using a particular syntax.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform testing**: The framework enables testing in different JavaScript
    environments, such as providing some support for Node.js and web API testing.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertion types**: Users are able to use different types of assertion styles,
    which provides flexible options for structuring tests. These different assertion
    styles cater to different preferences and can impact the readability and maintainability
    of test code. Offering a variety of assertion types allows developers to pick
    the one that best suits their needs and coding style.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test suite interface**: Provide a rich interface that includes setup functions
    and life cycle hooks. These features are necessary for organizing and managing
    tests effectively. A good test suite interface enables necessary actions before
    and after tests or test suites, enabling a more structured approach to testing.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ability to stub code**: Enable capabilities for spying, stubbing, and mocking
    of existing code to allow implementation substitution. This is a crucial feature
    to determine all possible ways the application code can be called. For instance,
    the Jest framework has the following capabilities built in: [jestjs.io/docs/jest-object#mock-functions](http://jestjs.io/docs/jest-object#mock-functions).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code coverage**: Output a report of code coverage that shows a percentage
    of the code base that is covered by the tests.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack`, `rollup.js`, and others.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.` for passing tests or `F` for failures. Usually, these reporter types can
    be specified by the environment or flag while running the test framework executable.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin interface**: Expose a plugin interface to make it possible to extend
    the framework feature set. For a testing framework, this could be an option to
    provide additional reporters or swap out built-in libraries.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides this list of features, our framework can also focus on improving the
    developer experience around JavaScript features such as handling ES module environments
    or asynchronous behavior in tests. It may also choose to cater to many niche JavaScript
    use cases, such as being able to work with particular libraries and test media
    and graphics-related features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We now have a generous list of conceivable features that will produce a reasonable
    foundation for our framework implementation. Part of the feature planning and
    development process also includes figuring out which functionality will be out
    of scope. This is what we will briefly cover in the following section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Identifying out-of-scope features
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though we have identified a rich feature set, it does not cover all potential
    use cases of a testing framework. To further improve the ergonomics of the project,
    there are components that would need to be developed in the follow-up versions.
    In particular, this initial version aims to create a foundation for the framework
    that will allow us to quickly iterate and add new features. It is better to focus
    on creating a continuous and intuitive development environment rather than rushing
    a slew of features immediately. In a real-world use case, as a framework developer,
    it would be important to gather user feedback and address the most pressing needs
    of your stakeholders as you iterate on your project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some features and components that could serve as potential additions
    to follow-up releases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Test watcher**: Providing a test runner mode that is watching for file changes
    and rerunning the tests as underlying components change. This could be a welcoming
    feature for developers as it provides real-time feedback during the development
    process.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock and date manipulation**: An additional improvement on top of existing
    mocking functionality, built-in clock and date mocking in JavaScript projects
    can make it much easier to freeze or manipulate dates. Providing this interface
    further improves ergonomics.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snapshot testing**: Involves capturing and comparing the output of complex
    components. It can save time by simplifying assertion methods and separating the
    expected output source from the test file structure.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retries**: The ability to retry failed tests could improve the ergonomics
    in different testing environments. This feature requires a careful approach to
    make sure that only expected failures are retried and the test runner does not
    report passing results for broken tests.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are definitely more components that can be developed for such frameworks,
    but the feature collection we have identified is enough for us to construct the
    architectural design outline. The next part of the development process is to pick
    out the most consequential parts from the feature set and devise an architecture
    to make this functionality a reality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Designing the outline
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to introduce an executable interface to enable the test runner features
    with cross-platform testing behavior. This interface, implemented as a command-line
    tool, must handle users’ running options within different environments. Finally,
    to fulfill our main goal of asserting code behavior, the execution modes must
    return the testing assertions’ status.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As the executable triggers the tests, the tests will emit their status and events.
    The runner needs to respect the life cycles of those tests and subscribe to the
    events related to the testing workflow. Potential events could include passing
    or failing state or bubbling up assertion errors if those occur.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a design diagram such as the one seen here makes it easier to see
    how the components that enable the feature set can interact with one another:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Initial design diagram](img/Figure_6.2_B19014.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Initial design diagram'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.2*, the flow of execution starts from the executable or the command
    line, defined on the left side of the diagram. In this case, the executable is
    the `ct` command, which is short for *Componium Test*. If the developer uses the
    command line as an entry point, then the **CLI handler** parses through the provided
    flags and options, determining if the tests will be running in the Node.js environment
    or the web browser environment. This will enable the cross-platform testing capabilities
    we evaluated during the feature planning process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the Node.js context, the `NodeExecutor` class can parse the provided test
    files and run their assertions, logging the real-time status of the execution
    and outputting the final results of the tests. The `chapter6/componium-test/packages/node/executor.js`
    file has the contents of `NodeExecutor`. The code is programmed to spawn worker
    environments for each test suite and run assertions in the test cases. Later,
    a summary of passing and failing tests is collected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In the browser context, the `BrowserExecutor` class relies on an external web
    browser bridge, provided by the `puppeteer` library. It creates a communication
    channel between the test runner and a real browser environment, queues the expected
    test suites, and uses a similar interface to capture test assertion and life cycle
    output. The browser environment also has distinct running methods, such as the
    *headless* and *headful* modes, where the browser is either hidden or displayed
    to the user while the tests run. This feature requires integrating the library
    and the test runner executable. This executor can be found in `chapter6/componium-test/packages/browser/executor.js`.
    This code works in a similar way to the Node.js method, but due to the fact that
    it runs in the web browser context, it has to send the results of the test suite
    back to the Node.js test runner running in the terminal process. The environmental
    difference makes the technical design of these two executors vastly different.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in *Figure 6**.2* also outlines potential support for running tests
    directly as a script file via the `node` CLI. In this case, the tests bypass the
    `ct` interface and directly output the results as the script runs. It is a handy
    feature that supports direct testing workflows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The outline and diagram in *Figure 6**.2* do not capture the full details of
    the test runner workflow, but they are helpful for our development process. As
    you develop your own frameworks, you will find that creating such artifacts can
    help you be more efficient and precise in architecting different kinds of software
    solutions. With the architecture and features outlined, we can continue to the
    interface design part of the process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Designing the interfaces and API
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two main interfaces are used as the point of interaction with our framework:
    the main framework module and the test runner executable. Developers must be acquainted
    with these interfaces through API documentation, examples, and more. In addition,
    introducing breaking changes or modifications to these APIs’ functionality will
    affect projects already integrated into the framework.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The first interface we are looking at is the imported `componium-test` framework
    module. This module exports the main testing object that can accept the testing
    function through **JavaScript Object Notation** (**JSON**). The module also exports
    additional framework interfaces, such as the assertion and mocking libraries.
    Here’s an example of using this module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Code snippet 1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code example of using the module in the test file can be found
    in the `tests/calc-tests.js` path of the framework. In this code, we see the inclusion
    of basic assertions for a sample `Calculator` script; those are made possible
    by importing the `assert` function. Based on the expected feature set, we have
    the test life cycle methods, such as `beforeEach`. Additionally, mocking functionality
    that replaces the return point of `multiply` is enabled by the `fake` and `replace`
    functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The second interface is the command-line utility provided when the users install
    the framework. This is a test runner that enables interaction with a large number
    of test suites:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The executable supports a variety of options to enable the expected feature
    set. In addition, the `--help` flag can also display available commands and their
    shortcuts. The `ct` executable accepts one or more test suites as arguments, visible
    through the `ct [<tests>...]` notation. The presence of the `ct` executable is
    expected by developers after installing the framework from JavaScript’s `npm`
    package registry.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We now have knowledge of these two developer-level APIs—the test executable
    and the test interface. We can now proceed to the implementation of features that
    power the functionality behind those two framework features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new frameworks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation process guides us further on how frameworks in JavaScript
    can be created. In this implementation process, we’ll see the different entry
    points of a test runner combined with distinguishable features. This section roughly
    follows the diagram in *Figure 6**.2*, where we outlined the framework design.
    Now that we know our features and have a rough idea of the project’s architecture,
    let’s broadly outline the steps of the internal implementation of this project,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Determine how the designed test suite configuration can be implemented within
    the Node.js environment.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create internal packages to execute the test suites in different environments.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the infrastructure for real web browser-mode testing.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect results from the test runner and output them to the user.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following *steps 1* to *4*, we begin our implementation by examining how our
    tests are structured and executed. In the preceding `Calculator Tests` snippet,
    we can examine the JavaScript object structure, consisting of a `ct` functional
    call and accepting a test suite object. Some special properties include describing
    the test suite name and running life cycle methods such as `before` and `after`.
    The execution life cycle of these methods can be seen in the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Test life cycle](img/Figure_6.3_B19014.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Test life cycle'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: To enable the `ct` function call, the test suites can access the `componium-test`
    package and our framework’s public interfaces, such as the assertion library features.
    We can see an example of including the framework in the `calc-tests.js` code block
    in *Code snippet 1*. Besides importing the framework features, the test file imports
    the code we aim to test.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing our framework in the Node.js context will require properly exporting
    it as part of the package. To do that, we define an `exports` property in our
    `package.json` file. This allows projects to configure *Componium Test* as a dependency
    to import the module by name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Code Snippet 2
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding configuration pinpoints our `tester.js` file, which handles most
    of the test-running logic, referenced from our `runner` package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Once the test object is loaded into the framework, it is directed to the appropriately
    named `packages/runner/tester.js` file. The `tester.js` file is where most of
    the testing happens, including the life cycle methods, executed at appropriate
    times, alongside the main test function. Provided that a test suite can have many
    tests, the tester proceeds to call through all the provided functions. To measure
    the speed of the tests, we can rely on the `performance` APIs ([developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)).
    These APIs provide high-resolution timestamps to provide us with data on how long
    the tests take to run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Testing functionality
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enabling an excellent testing experience through detailed test assertions, our
    project needs an assertion library that can be used within the newly written tests.
    The assertion interfaces should include equality comparison, value size comparison,
    object value evaluation, and others.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: To focus on broad framework development, we will import an external test assertion
    library called `should`, `expect`, and `assert`. Subsequently, we can develop
    our own assertion infrastructure or replace Chai with a different library, which
    we can potentially develop by ourselves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'As the testing script executes our provided tests, our handy assertion library
    will throw an exception if any comparison functions are unsuccessful, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding output shown is a snippet of a failure in one of the tests, where
    the imported `Calculator` module does not correctly perform the `multiply` operation.
    The framework needs to handle this type of code behavior. In the case of assertion
    or other errors, the test runner needs to signal back to the running process of
    at least one or more failed tests. If at least something flips the `errorOccurred`
    flag, then it will result in our testing node process exiting with a failure status.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Besides the assertion library, we want to provide mocking and stubbing functionality
    in the developed framework. Using a similar pattern where we include the Chai.js
    library and expose it as a test API interface, we will include the **Sinon.js**
    ([sinonjs.org](http://sinonjs.org)) library, which has a rich interface for creating
    test stubs, spies, and mocks. It is an excellent fit for our project because it
    supports many JavaScript environments and has been battle-tested in other projects
    for many years. The presence of this library will make it easier for developers
    to increase code coverage and write more effective tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippet (*Code snippet 1*) of the example test file, we use Sinon.js’
    functions to create a fake `mockMultiply` return point. The Sinon.js methods are
    also abstracted away from direct usage. Instead, they are exposed as part of the
    `componium-test` package. Users can access the library’s mocking, faking, and
    stubbing mechanisms configured in the framework’s `packages/mock/lib.js` mock
    package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The inclusion of powerful assertions and mocking libraries, exposed in a simple
    interface, allows our framework to gain rich functionality from the first version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Creating a command-line tool
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sections, we talked about making our `tester.js` file the imported
    entry point to run tests. To match the expected feature set, the framework needs
    to support running multiple sets of tests from a given directory. This means supporting
    a number of suites of a given format in bulk. This means that the number of test
    suites will be structured in the following format:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get this bulk execution feature, we need to create a command-line tool for
    our framework. To integrate with the Node.js command-line environment, we need
    to provide a `bin` key in the `package.json` file to export the command-line file,
    like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The binary shortcut that we export is just `ct` to make it really easy to execute
    the framework commands from other projects. To develop the binary file, we can
    rely on the `yargs` library ([yargs.js.org](http://yargs.js.org)) to handle user
    input, parsing the provided process arguments from the `process.argv` variable.
    See the `packages/bin/ct.js` file for details on the executable structure. There
    are several features to remember with the structure of the executable, focusing
    on developing a good interface and enabling particular features of the framework,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Include the interpretation in the file’s first line with `#!/usr/bin/env node`.
    This signals to the system shell to use the node executable for this file. This
    is known as the *Shebang* ([wikipedia.org/wiki/Shebang_%28Unix%29](http://wikipedia.org/wiki/Shebang_%28Unix%29)),
    where an interpreter executable is provided within the script.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the binary package logic focused on the code related to parsing command-line
    flags and ensuring a good CLI experience. This includes supporting the `--help`
    flag, providing shortcuts to flags, and testing for edge cases of how an executable
    can be used. The flags or options of the CLI should follow the double-hyphenated
    (`--`) structure or a single one (`-`) for short options.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The executable should follow the standard rules of CLIs. The CLI process should
    exit with an appropriate status code and indicate if the process failed. This
    is especially important in the case of the test runner that we are working with
    in this chapter.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the execution mode, Node.js, or the browser, the CLI file (`packages/runner/cli.js`)
    chooses the right executor class, providing this class with a list of target files.
    The `NodeExecutor` and `BrowserExecutor` classes have the job of processing all
    the test files and evaluating if any of the tests in those files fail any assertions.
    In the Node.js testing environment, we use the `NodeExecutor` class to run the
    tests. The class spawns new worker threads to execute test suites concurrently.
    The main purpose of this interface is to run tests for multiple target files and
    return an overall pass or fail result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing workflow
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another feature we are exploring in the developed framework is the ability
    to execute tests in a real web browser environment. To enable this, the CLI accepts
    a `–browser` flag that switches the running mode of the test framework. The entry
    point to this interface for a developer may look something like this: `ct –browser
    test/some_test.js`. Depending on the approach to the framework executables, we
    can also introduce a separate `ct-browser` executable to directly execute the
    test in the browser context without worrying about extra parameters. To implement
    this functionality, the framework relies on the `puppeteer` library to spawn a
    new browser instance and establish a communication channel with it.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.4* shows the debugging view of the browser test runner workflow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Debugging view of the browser test runner workflow](img/Figure_6.4_B19014.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Debugging view of the browser test runner workflow'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: This operation mode is helpful to get access to the tests if they are failing
    in the browser. This environment allows developers to set breakpoints in their
    code and debug the tests. The `BrowserExecutor` file in `packages/browser/executor.js`
    takes care of launching a new instance of a real web browser. The communication
    channel it establishes can rely on messaging from the console or through more
    advanced `window.postMessage` function calls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a simple Node.js server paired with a small templating library called
    `eta` to create a browser page that executes the tests. We can create a valid
    HTML document with the templating library that includes the dependencies and test
    files. To properly load the framework files, the page relies on `importmap` ([developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap))
    to map ES module names to URLs. The code is illustrated in the following snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The initial implementation of the frontend test runner has a minimal interface,
    but it can be further developed to show a more interactive dashboard of tests.
    This can be a potential feature investment, adding additional frontend features
    if a test runner is used heavily in browser-related testing. The import map structure
    can be found in the `chapter6/componium-test/packages/browser/views/layout.eta`
    file. Besides the framework files, this file also consists of parsing a dynamic
    list of test suites that need to be included in the frontend. This makes it possible
    to include and run a number of test suites in the frontend testing harness.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Testing the framework
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we develop the testing framework, we must ensure its reliability and correctness.
    However, using another external framework for testing might not be ideal, and
    we can’t use the framework itself to test its features as it is still under development.
    We use simple approaches to address this challenge, enabling unit, snapshot, and
    **end-to-end** (**E2E**) testing to ensure our project works correctly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of our project can primarily rely on the existing test runner implementation.
    However, we need to integrate snapshot testing, which includes comparing the test
    runner’s output with snapshotted versions of the desired output. As we refactor
    certain features, we should verify with the snapshot test to detect unintended
    changes. Including such tests gives us more confidence as we push new updates
    and improvements to the project. In particular, unit tests that require more attention
    are related to the exit status codes of the test runner.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important testing addition is the inclusion of E2E tests that cover
    the whole framework workflow. This includes installing packages, importing the
    testing package, and executing tests. These tests are made possible by creating
    a separate testing package that includes our framework as a dependency, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sample testing project includes `componium-test` as a dependency in its
    `package.json` file and points to the parent directory to load the files. These
    E2E tests can be found in the `e2e` directory of the project. In [*Chapter 9*](B19014_09.xhtml#_idTextAnchor156),
    we will explore additional ways to improve and validate project quality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Framework packages
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shown in *Figure 6**.5* are the initial packages of the project. They are situated
    in the `packages` directory, similar to how many other frameworks choose to organize
    their projects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The framework packages of the project](img/Figure_6.5_B19014.png.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The framework packages of the project'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'These packages are logically split by their responsibility. Here is a brief
    outline of what they do:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`assert`: Contains the assertion library-related configuration'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bin`: Contains the executable, which is exported by the `package.json` file'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browser`: Files related to test execution in the browser environment'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views`: Template files that make it possible to load tests in the frontend
    context'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mock`: Mocking library-related features'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`: Files related to the Node.js execution environment'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner`: Global test runner interfaces that are shared between the execution
    contexts'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`: Miscellaneous utility functions that are used across the framework'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides assembling together all the self-developed packages into a cohesive
    design, our project also relies on external libraries. Here is a list of some
    of the dependencies that are utilized in the framework to achieve the desired
    feature set:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`chai`: This library allows us to quickly set up a test assertion interface
    to make the testing experience much nicer. It provides our framework with assertion
    interfaces useful for `github.com/chaijs/chai`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sinon`: This library allows us to provide an interface for creating test spies,
    stubs, and mocks. Enabling this feature makes our framework more suitable for
    testing JavaScript applications, as it enables more comprehensive unit testing
    coverage.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: A small utility that makes it easier to develop the framework by introducing
    filtered debug logging. By namespacing the debug level after each package of our
    framework, it makes it easier to understand the framework’s internals as it executes
    tests.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eta`: This is a lightweight templating engine that helps us construct the
    test runner in the browser. It produces an HTML document with the necessary framework
    files and test suites.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glob`: This module enables pattern matching for test directories. It allows
    us to run a command such as `ct tests` where `tests` is a directory, resulting
    in finding all test files for a particular directory. Generally, `glob` saves
    us much time writing filesystem-related code by providing an easy-to-use file
    pattern matching system.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yargs`: This is used as the argument parser for the framework’s CLI. It makes
    it easier for us to create a better command-line experience for the test runner.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`puppeteer`: This library is included to provide the `BrowserExecutor` class
    with a real web-browser testing interface. `puppeteer` enables headless browser
    testing by controlling a Chromium or Firefox instance and running tests within
    that environment.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are highlights of the dependencies that we’ll use in this project. For
    some of the framework logic, we have built out our own solutions, organized within
    packages. At the same time, we are relying on external libraries to address the
    complexities of specific technical challenges. The current structure allows us
    to introduce new packages or expand existing ones. The defined abstractions also
    allow us to swap out external dependencies in favor of other solutions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在项目中使用的依赖项的亮点。对于一些框架逻辑，我们已经构建了自己的解决方案，并组织在包中。同时，我们依赖外部库来解决特定技术挑战的复杂性。当前的架构允许我们引入新的包或扩展现有的包。定义的抽象也允许我们用其他解决方案替换外部依赖。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided us with a walkthrough on integrating the concepts and
    architectural principles from earlier sections of the book to build a basic JavaScript
    testing framework. The practical approach provides us with insights into building
    out testing framework internals. Even if we do not end up coding a new testing
    project, it still trains our software muscles to have general knowledge of architecting
    something from scratch. Our method uses a combination of libraries and packages
    to enable a hybrid of standard and unique features.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了一个了解如何将本书早期章节中的概念和架构原则整合到构建基本JavaScript测试框架中的指南。这种实用方法为我们提供了构建测试框架内部结构的见解。即使我们最终没有编码一个新的测试项目，它仍然训练我们的软件肌肉，使我们具备从零开始构建某物的通用知识。我们的方法结合了库和包的组合，以实现标准和独特功能的混合。
- en: 'We covered three parts of the framework development workflow: setting up a
    new project, drafting an initial design, and working through the first version
    of the goal brainstorming, architectural design, and implementation. As we put
    these skills into practice, the goal is to make you as a developer more comfortable
    with architecting, developing, and producing successful projects for others. In
    the upcoming chapters, we will focus on framework publishing and maintenance.
    We will also continue these practical exercises as we walk through building more
    projects.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了框架开发工作流程的三个部分：设置新项目、制定初步设计和完成目标头脑风暴的第一版，包括架构设计和实现。随着我们将这些技能付诸实践，目标是使你作为一个开发者对架构、开发和为他人制作成功的项目感到更加舒适。在接下来的章节中，我们将关注框架的发布和维护。我们还将继续这些实践练习，当我们逐步构建更多项目时。
