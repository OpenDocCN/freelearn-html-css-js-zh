- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building a Framework by Example
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例构建框架
- en: This chapter combines all the insight and architectural knowledge from *Parts
    1* and *2* of the book and puts it into practice. Follow along as we develop a
    simple JavaScript testing framework based on the patterns and best techniques
    we have seen so far. The practical approach will enable us to learn by example,
    as it is a great educational approach for software topics of this kind. The framework
    we build here is a new project developed specifically for this chapter. We can
    treat this new sample framework project as a “Hello World” exercise for JavaScript
    framework development. Our aim through this exercise is to train our abilities
    and apply them later on in real-world projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结合了书籍第一部分和第二部分的所有见解和架构知识，并将其付诸实践。随着我们开发一个基于迄今为止所见模式和最佳技术的简单JavaScript测试框架，请跟随我们的步伐。这种实用方法将使我们能够通过示例学习，这对于此类软件主题来说是一种很好的教育方法。我们在这里构建的框架是一个专门为本章开发的新项目。我们可以将这个新的示例框架项目视为JavaScript框架开发的“Hello
    World”练习。通过这个练习，我们的目标是训练我们的能力，并将其应用于后续的实际项目中。
- en: 'This chapter will cover the following topics for building a framework by example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过示例介绍构建框架的以下主题：
- en: First, we’ll structure our initial approach for a new framework project, including
    determining the goals, stakeholders, and branding for creating something from
    scratch. This will largely involve putting the learnings of project considerations
    from [*Chapter 5*](B19014_05.xhtml#_idTextAnchor073) into practice.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将为新的框架项目制定初始方法，包括确定目标、利益相关者和品牌，以从头开始创建某些内容。这主要涉及将[第5章](B19014_05.xhtml#_idTextAnchor073)中关于项目考虑因素的学习付诸实践。
- en: Next, we’ll learn to outline a typical initial architecture design to get our
    implementation of a testing framework off the ground. This includes outlining
    how the components fit together and the unique features of the project and its
    interfaces. In addition, we’ll summarize the public interfaces that are expected
    by developers who will be utilizing our project.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何概述一个典型的初始架构设计，以便将我们的测试框架实现启动。这包括概述组件如何组合以及项目的独特特性和接口。此外，我们还将总结开发人员期望利用我们的项目时所需的公共接口。
- en: Finally, we’ll walk through the implementation of our testing framework based
    on the created design, including core feature components, command-line implementation,
    browser testing integration, and more.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将基于创建的设计实现我们的测试框架，包括核心功能组件、命令行实现、浏览器测试集成等。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The implemented framework code is in the book repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    The code for our sample framework is included in the `chapter6` directory. To
    follow the implementation explanation in this chapter, it is recommended to follow
    along with the framework files in the chapter directory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的框架代码位于[https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)的书籍仓库中。我们的示例框架代码包含在`chapter6`目录中。为了跟随本章的实现说明，建议您与章节目录中的框架文件一起进行操作。
- en: To run the code, make sure to have *Node.js v20 or higher* installed (you can
    download it from [nodejs.org](http://nodejs.org)). To make it easier to manage
    different versions of Node.js, you can use a Node.js version manager tool such
    as `nvm` ([github.com/nvm-sh/nvm](http://github.com/nvm-sh/nvm)). Running `nvm`
    will automatically install the appropriate version of Node.js from the framework
    project directory, as the project is configured and tested for a particular version.
    Make sure to run `npm install` to fetch the project’s dependencies. Running `npm
    test` should output a set of passing tests. This means that your local configuration
    is all correctly set up. The interactive script will perform all these steps for
    you if you run `npm start` from the `chapter6` directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请确保已安装*Node.js v20或更高版本*（您可以从[nodejs.org](http://nodejs.org)下载）。为了更容易地管理不同版本的Node.js，您可以使用Node.js版本管理工具，例如`nvm`([github.com/nvm-sh/nvm](http://github.com/nvm-sh/nvm))。运行`nvm`将从框架项目目录自动安装适当的Node.js版本，因为项目已针对特定版本进行配置和测试。请确保运行`npm
    install`以获取项目的依赖项。运行`npm test`应输出一系列通过测试。这意味着您的本地配置已经全部正确设置。如果您从`chapter6`目录运行`npm
    start`，交互式脚本将为您执行所有这些步骤。
- en: To test the frontend portion of this sample framework, please use the latest
    version of Chromium-based browsers or an updated version of Firefox. To debug
    the framework, refer to the *About debugging* section of [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030).
    You can use the approach as documented in that chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此示例框架的前端部分，请使用基于Chromium的最新浏览器版本或Firefox的更新版本。要调试框架，请参考[*第2章*](B19014_02.xhtml#_idTextAnchor030)中的*关于调试*部分。您可以使用该章节中记录的方法。
- en: Determining goals and stakeholders and framework branding
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定目标和利益相关者以及框架品牌
- en: The subject of our framework practical exercise is a new JavaScript code testing
    framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们框架实践练习的主题是一个新的JavaScript代码测试框架。
- en: Goals
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: The goal we will try to achieve is to provide robust test tooling for projects
    of variable complexity. The primary objective of testing frameworks is to provide
    developers with a reliable, fast, and versatile platform for verifying their code’s
    functionality, performance, and stability. In addition, they aim to minimize the
    risk of potential errors and create a seamless development experience that ultimately
    results in a high-quality product.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将努力实现的目标是为不同复杂度的项目提供稳健的测试工具。测试框架的主要目标是向开发者提供一个可靠、快速且多功能的平台，以验证其代码的功能性、性能和稳定性。此外，它们旨在最大限度地减少潜在错误的风险，并创造一个无缝的开发体验，最终产生高质量的产品。
- en: To accomplish these project goals, our JavaScript framework will focus on executing
    tests quickly and accurately, supporting various reporter output formats, and
    fostering a developer-friendly environment. By prioritizing ease of use and integration
    with other JavaScript tools and application frameworks, we will aim to make the
    testing process as seamless and efficient as possible. The framework will also
    enable cross-platform testing across Node.js and real web browser environments,
    ensuring that code performs consistently and as expected in various contexts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些项目目标，我们的JavaScript框架将专注于快速准确地执行测试，支持各种报告输出格式，并营造一个对开发者友好的环境。通过优先考虑易用性和与其他JavaScript工具和应用框架的集成，我们力求使测试过程尽可能无缝和高效。该框架还将支持跨平台测试，包括Node.js和真实网络浏览器环境，确保代码在各种环境中表现一致并符合预期。
- en: A side condition of this particular project is to create a sandbox-like environment
    for you, the reader, by providing an extensible and more straightforward project
    that you can learn from. You are encouraged to run the code and play the role
    of a potential framework contributor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的附带条件之一是为您，即读者，创建一个类似沙盒的环境，通过提供一个可扩展且更直观的项目，您可以从中学习。我们鼓励您运行代码并扮演潜在框架贡献者的角色。
- en: Stakeholders
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利益相关者
- en: The stakeholders of a new JavaScript code testing framework could include a
    variety of software engineers and web developers who have specific software testing
    needs. First and foremost, JavaScript developers can utilize this framework in
    their user-facing projects and include it in the development of other JavaScript
    software. This framework can be a full stack solution for testing code in multiple
    environments. In the developer community, we are trying to develop a framework
    that is suitable for frontend, backend, full stack developers, QA and DevOps engineers,
    and finally, other framework/library authors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 新的JavaScript代码测试框架的利益相关者可能包括各种具有特定软件测试需求的软件工程师和网络开发者。首先，JavaScript开发者可以在他们的面向用户的项目中使用此框架，并将其包含在其他JavaScript软件的开发中。此框架可以是多环境测试代码的全栈解决方案。在开发者社区中，我们正在努力开发一个适合前端、后端、全栈开发者、质量保证和DevOps工程师，以及最终其他框架/库作者的框架。
- en: Our stakeholders can benefit from the architectural features of this project.
    For example, if we are testing the code in a real browser environment, the developed
    framework could be a good selling point for frontend engineers. The choice of
    the JavaScript testing feature set that we enable by building this project might
    also create friction or incompatibility with some engineering workflows, such
    as running tests in older runtimes and browsers. Thus, mainly, we are targeting
    a subset of developers that can live on the bleeding edge of new features and
    easily keep their code base up to date with the latest environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目利益相关者可以从这个项目的架构特性中受益。例如，如果我们正在真实浏览器环境中测试代码，那么开发的框架可能对前端工程师来说是一个很好的卖点。通过构建这个项目，我们选择的JavaScript测试功能集可能会与某些工程工作流程产生摩擦或不兼容，例如在较旧的运行时和浏览器中运行测试。因此，主要来说，我们针对的是那些能够生活在新功能的前沿并且能够轻松地将他们的代码库与最新环境保持同步的开发者子集。
- en: If we were developing a JavaScript code testing framework internally, our stakeholders
    would be the internal developers of a start-up or a bigger company. In this case,
    we could gather insights about which feature sets were most needed in the internal
    teams. In addition, particular features could be developed to target specific
    organizational needs. The iteration and stability of the project would depend
    on how it was used internally as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是在内部开发一个JavaScript代码测试框架，我们的利益相关者将是初创公司或大公司的内部开发者。在这种情况下，我们可以收集有关内部团队中最需要的功能集的见解。此外，可以开发特定的功能来满足特定的组织需求。项目的迭代和稳定性将取决于它在内部的使用情况。
- en: Both stakeholders and framework developers benefit from consistent project communication
    and identity. This is where our new framework can benefit a bit from adding some
    branding. More on that in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者和框架开发者都能从一致的项目沟通和身份认同中受益。这就是我们的新框架可以通过添加一些品牌标识来获得一些好处的地方。更多内容将在下一节中介绍。
- en: Framework branding
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架品牌
- en: Before diving into architecture and coding, spending some time on the branding
    and identity of our project can be beneficial for the sake of the project structure.
    Creating an identity around the framework is a common pattern in internal and
    public projects, as it clearly defines the project’s logical boundaries and provides
    context around the project in general. Creating an identity could be as simple
    as picking a temporary name for your new project. It can also be a more involved
    creative process as we establish a project name. The name will be useful for creating
    a *namespace* for our project and utilized internally by the code base and by
    tests/dependent projects as they load this new project. The name can, of course,
    be changed later with some *find and replace*, so the decision does not have to
    be final.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入架构和编码之前，花一些时间在我们的项目品牌和身份上，对项目结构来说是有益的。围绕框架创建一个身份是内部和公共项目中的一种常见模式，因为它清楚地定义了项目的逻辑边界，并为项目提供了总体背景。创建一个身份可能只是为你的新项目选择一个临时名称那么简单。它也可以是一个更复杂的创造性过程，正如我们建立项目名称时那样。这个名称将有助于为我们的项目创建一个*命名空间*，并由代码库以及加载此新项目的测试/依赖项目内部使用。当然，名称可以在稍后通过一些*查找和替换*来更改，所以这个决定不必是最终的。
- en: 'We will use a new framework name for our new project and repurpose it for subsequent
    project advancements in *Chapters 7* and *8*. We define **Componium** as the overarching
    brand for the frameworks we develop in this book. The name is a play on the word
    *Component*, combined with a *-nium* ending, which gives this name a technological
    and software sound. Besides, the name is not fully unique, as a musical instrument
    from 1821 shares the name with our framework: [mim.be/en/collection-piece/componium](http://mim.be/en/collection-piece/componium).
    More importantly, it is not a problem for us because there are no conflicts for
    this name in the JavaScript ecosystem. Choosing a namespace has to come with some
    uniqueness, avoiding naming conflicts with existing developer tools.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的新项目使用一个新的框架名称，并在第7章和第8章中将其用于后续项目的进步。我们将**Componium**定义为我们在本书中开发的框架的总品牌。这个名字是对单词*Component*的戏谑，结合了*-nium*结尾，这使得这个名字听起来具有技术和软件感。此外，这个名字并不完全独特，因为1821年的一种乐器与我们的框架共享了同一个名字：[mim.be/en/collection-piece/componium](http://mim.be/en/collection-piece/componium)。更重要的是，这对我们来说不是问题，因为在JavaScript生态系统中没有这个名字的冲突。选择一个命名空间必须伴随着一些独特性，避免与现有的开发者工具发生命名冲突。
- en: 'Continuing the creative process, in *Figure 6**.1*, you can see our framework’s
    logo and color scheme, which can be used in documentation and presented in the
    project’s visual features:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创意过程，在 *图6**.1* 中，你可以看到我们框架的标志和配色方案，这些可以在文档中使用，并在项目的视觉特征中展示：
- en: '![Figure 6.1: New framework name and logo](img/Figure_6.1_B19014.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：新框架名称和标志](img/Figure_6.1_B19014.jpg)'
- en: 'Figure 6.1: New framework name and logo'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：新框架名称和标志
- en: The testing framework will be specifically known as *Componium Test*. The addition
    of identity assets is beneficial to make the project more identifiable and establish
    a stronger brand presence in the developer community, fostering trust and recognition.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架将特别称为 *Componium Test*。添加身份资产有助于使项目更具辨识度，并在开发者社区中建立更强的品牌影响力，培养信任和认可。
- en: On the more technical side of things, creating a namespace for your project,
    as we did here with *componium*, can help on several occasions. Namespacing eliminates
    potential naming conflicts and collisions with other frameworks and helps us logically
    group the code base with its components for both internal and external developers.
    Depending on the type of framework project, creating a namespace can also make
    the code base approach more modular. We saw an example of this in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030),
    where Vue.js had the approach to namespace many of its packages in a `vue-*` namespace.
    In addition, namespacing can help facilitate framework customizations and extensions,
    such as other developers contributing plugins and additions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在更技术性的方面，为你的项目创建一个命名空间，就像我们在这里用 *componium* 做的那样，可以在多个场合提供帮助。命名空间消除了潜在的命名冲突，并有助于与其他框架的冲突，同时帮助我们逻辑上对代码库及其组件进行分组，这对内部和外部开发者都有帮助。根据框架项目的类型，创建命名空间还可以使代码库的模块化方法更加完善。我们在
    [*第2章*](B19014_02.xhtml#_idTextAnchor030) 中看到了一个例子，Vue.js 采用 `vue-*` 命名空间来命名其许多包。此外，命名空间还可以帮助促进框架的定制和扩展，例如其他开发者贡献插件和补充。
- en: Now that we know more about creating an identity for our projects and with our
    branding exercise complete, we can move to the exciting part of architecting our
    new framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对为我们的项目创建身份有了更多的了解，并且我们的品牌练习已经完成，我们可以转向构建我们新框架的激动人心的部分。
- en: Architecting the new framework
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建新框架
- en: 'Now, we’ll get to the architectural part of our practical approach. So far,
    we know what we are building and who we are building it for. It is now time to
    determine the shape of our feature set and see how we can enable those features
    for our users. The most basic use case that we would like to cover is generating
    assertions for JavaScript code, as presented here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入我们实用方法的架构部分。到目前为止，我们知道我们在构建什么，以及我们为谁构建它。现在是时候确定我们的功能集的形状，并看看我们如何为我们的用户启用这些功能。我们希望覆盖的最基本用例是生成JavaScript代码的断言，如这里所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code example tests the `helloReader()` function and verifies that
    the correct string is returned. Starting from these basics, to take things further,
    we spend time on core functionality and identifying out-of-scope features first.
    Later, this can help drive technical decisions, as we brainstorm the set of extended
    features that can be suitable for our project. Our strategy consists of comparing
    the features offered by existing testing tools, developing unique characteristics,
    and contemplating which capabilities are out of the initial scope.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例测试了 `helloReader()` 函数，并验证返回了正确的字符串。从这些基础知识开始，为了更进一步，我们花费时间在核心功能上，并首先确定超出范围的特性。稍后，这可以帮助推动技术决策，当我们头脑风暴适合我们项目的扩展功能集时。我们的策略包括比较现有测试工具提供的功能，开发独特的特性，并思考哪些功能超出了初始范围。
- en: To draw some feature comparisons, we can look at some frameworks from [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015). *Jest* and *Vitest* come to mind as they
    are frameworks comparable to what we are building in this chapter. In addition,
    other projects in the ecosystem are `jasmine`, `ava`, `tap`, `tape`, and `mocha`.
    Most of these projects provide an advanced testing interface with a specific test
    life cycle and different ways to create assertions. All these existing open source
    projects also provide a common set of core functionalities, such as executability
    to run the framework in different projects, different output formatting options,
    the ability to stub or spy on interfaces, and more.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行一些功能比较，我们可以参考[*第一章*](B19014_01.xhtml#_idTextAnchor015)中的一些框架。*Jest*和*Vitest*是值得考虑的框架，因为它们与我们本章构建的框架相似。此外，生态系统中的其他项目还包括`jasmine`、`ava`、`tap`、`tape`和`mocha`。这些项目中的大多数都提供了一个高级测试接口，具有特定的测试生命周期和创建断言的不同方式。所有这些现有的开源项目还提供了一套常见的核心功能，例如在各个项目中运行框架的可执行性、不同的输出格式选项、对接口进行存根或间谍的能力，等等。
- en: In the following subsections, we will examine some of the unique features that
    can be implemented as part of our initial approach to the *Componium* *Test* project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将探讨一些可以作为我们针对*Componium* *Test*项目初始方法的一部分实现的一些独特功能。
- en: Selecting features
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择功能
- en: 'Brainstorming a list of features for a testing framework can be both exhausting
    and exciting. There are just so many areas to cover in terms of testing tool development,
    with most of the feature set covering different areas of development. In the architecting
    example from the beginning of this section, we listed basic test use cases, and
    now we can expand on them. Here are some of the additional types of functionality
    that could help our project provide a better feature set to its stakeholders:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为测试框架构思一系列功能可能既令人疲惫又令人兴奋。在测试工具开发方面，需要涵盖的领域非常多，大部分功能集覆盖了不同的开发领域。在本节开头提到的架构示例中，我们列出了基本的测试用例，现在我们可以在此基础上进行扩展。以下是一些可能有助于我们的项目为其利益相关者提供更完善功能集的附加功能类型：
- en: '**Capable test runner**: The framework exposes a test runner executable with
    the ability to execute a single or full suite of tests. It provides its users
    with a selective execution format to specify which tests to run, a feature that''s
    useful during development and debugging situations. The test runner also allows
    the users to define test cases using a particular syntax.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的测试运行器**：该框架提供了一个具有执行单个或完整测试套件能力的测试运行器可执行文件。它为用户提供了一种选择性的执行格式，可以指定要运行的测试，这在开发和调试情况下非常有用。测试运行器还允许用户使用特定的语法定义测试用例。'
- en: '**Cross-platform testing**: The framework enables testing in different JavaScript
    environments, such as providing some support for Node.js and web API testing.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台测试**：该框架支持在不同的JavaScript环境中进行测试，例如提供对Node.js和Web API测试的一些支持。'
- en: '**Assertion types**: Users are able to use different types of assertion styles,
    which provides flexible options for structuring tests. These different assertion
    styles cater to different preferences and can impact the readability and maintainability
    of test code. Offering a variety of assertion types allows developers to pick
    the one that best suits their needs and coding style.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言类型**：用户可以使用不同类型的断言样式，这为测试的结构化提供了灵活的选项。这些不同的断言样式满足了不同的偏好，并可能影响测试代码的可读性和可维护性。提供多种断言类型允许开发者选择最适合他们需求和编码风格的选项。'
- en: '**Test suite interface**: Provide a rich interface that includes setup functions
    and life cycle hooks. These features are necessary for organizing and managing
    tests effectively. A good test suite interface enables necessary actions before
    and after tests or test suites, enabling a more structured approach to testing.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件接口**：提供一个丰富的接口，包括设置函数和生命周期钩子。这些功能对于有效地组织和管理工作是必要的。一个良好的测试套件接口允许在测试或测试套件之前和之后执行必要的操作，从而实现更结构化的测试方法。'
- en: '**Ability to stub code**: Enable capabilities for spying, stubbing, and mocking
    of existing code to allow implementation substitution. This is a crucial feature
    to determine all possible ways the application code can be called. For instance,
    the Jest framework has the following capabilities built in: [jestjs.io/docs/jest-object#mock-functions](http://jestjs.io/docs/jest-object#mock-functions).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码桩功能**：启用对现有代码的监视、桩化和模拟的能力，以允许实现替换。这是确定应用程序代码所有可能调用方式的关键特性。例如，Jest 框架内置了以下功能：[jestjs.io/docs/jest-object#mock-functions](http://jestjs.io/docs/jest-object#mock-functions)。'
- en: '**Code coverage**: Output a report of code coverage that shows a percentage
    of the code base that is covered by the tests.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码覆盖率**：输出代码覆盖率报告，显示被测试覆盖的代码库的百分比。'
- en: '`webpack`, `rollup.js`, and others.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack`、`rollup.js`以及其他。'
- en: '`.` for passing tests or `F` for failures. Usually, these reporter types can
    be specified by the environment or flag while running the test framework executable.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.`表示通过测试或使用`F`表示失败。通常，这些报告类型可以在运行测试框架可执行文件时通过环境或标志来指定。
- en: '**Plugin interface**: Expose a plugin interface to make it possible to extend
    the framework feature set. For a testing framework, this could be an option to
    provide additional reporters or swap out built-in libraries.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件接口**：公开一个插件接口，使其能够扩展框架的功能集。对于测试框架来说，这可能是一个提供额外报告者或替换内置库的选项。'
- en: Besides this list of features, our framework can also focus on improving the
    developer experience around JavaScript features such as handling ES module environments
    or asynchronous behavior in tests. It may also choose to cater to many niche JavaScript
    use cases, such as being able to work with particular libraries and test media
    and graphics-related features.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个特性列表之外，我们的框架还可以专注于改善围绕 JavaScript 特性的开发者体验，例如处理 ES 模块环境或测试中的异步行为。它还可以选择满足许多特定的
    JavaScript 使用场景，例如能够与特定库一起工作，并测试媒体和图形相关功能。
- en: We now have a generous list of conceivable features that will produce a reasonable
    foundation for our framework implementation. Part of the feature planning and
    development process also includes figuring out which functionality will be out
    of scope. This is what we will briefly cover in the following section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一份丰富的可想象特性列表，这将为我们框架的实现提供一个合理的基石。特性规划和开发过程的一部分也包括确定哪些功能将超出范围。这就是我们在下一节中简要介绍的内容。
- en: Identifying out-of-scope features
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定超出范围的功能
- en: Even though we have identified a rich feature set, it does not cover all potential
    use cases of a testing framework. To further improve the ergonomics of the project,
    there are components that would need to be developed in the follow-up versions.
    In particular, this initial version aims to create a foundation for the framework
    that will allow us to quickly iterate and add new features. It is better to focus
    on creating a continuous and intuitive development environment rather than rushing
    a slew of features immediately. In a real-world use case, as a framework developer,
    it would be important to gather user feedback and address the most pressing needs
    of your stakeholders as you iterate on your project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经确定了一个丰富的功能集，但它并没有涵盖测试框架所有潜在的使用场景。为了进一步提高项目的易用性，后续版本中还需要开发一些组件。特别是，这个初始版本旨在为框架创建一个基础，使我们能够快速迭代并添加新功能。专注于创建一个持续和直观的开发环境，而不是立即匆忙添加大量功能，会更好。在实际应用场景中，作为一个框架开发者，在迭代项目时收集用户反馈并解决利益相关者的最紧迫需求是非常重要的。
- en: 'Here are some features and components that could serve as potential additions
    to follow-up releases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些可以作为后续版本潜在添加的功能和组件：
- en: '**Test watcher**: Providing a test runner mode that is watching for file changes
    and rerunning the tests as underlying components change. This could be a welcoming
    feature for developers as it provides real-time feedback during the development
    process.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试监视器**：提供一个测试运行器模式，该模式监视文件更改，并在底层组件更改时重新运行测试。这对于开发者来说可能是一个受欢迎的功能，因为它在开发过程中提供了实时反馈。'
- en: '**Clock and date manipulation**: An additional improvement on top of existing
    mocking functionality, built-in clock and date mocking in JavaScript projects
    can make it much easier to freeze or manipulate dates. Providing this interface
    further improves ergonomics.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟和日期操作**：在现有模拟功能的基础上进行改进，JavaScript 项目中内置的时钟和日期模拟可以使冻结或操作日期变得更加容易。提供这个接口进一步提高了易用性。'
- en: '**Snapshot testing**: Involves capturing and comparing the output of complex
    components. It can save time by simplifying assertion methods and separating the
    expected output source from the test file structure.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快照测试**：涉及捕获和比较复杂组件的输出。通过简化断言方法和将预期输出源与测试文件结构分离，可以节省时间。'
- en: '**Retries**: The ability to retry failed tests could improve the ergonomics
    in different testing environments. This feature requires a careful approach to
    make sure that only expected failures are retried and the test runner does not
    report passing results for broken tests.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**：能够重试失败的测试可以改善不同测试环境中的用户体验。这个功能需要谨慎处理，以确保只有预期的失败才会重试，并且测试运行者不会报告已损坏测试的通过结果。'
- en: There are definitely more components that can be developed for such frameworks,
    but the feature collection we have identified is enough for us to construct the
    architectural design outline. The next part of the development process is to pick
    out the most consequential parts from the feature set and devise an architecture
    to make this functionality a reality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的框架，肯定还有更多可以开发的组件，但我们已经识别出的功能集合足以让我们构建架构设计大纲。开发过程的下一部分是从功能集中挑选出最重要的部分，并设计一个架构来实现这一功能。
- en: Designing the outline
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计大纲
- en: We need to introduce an executable interface to enable the test runner features
    with cross-platform testing behavior. This interface, implemented as a command-line
    tool, must handle users’ running options within different environments. Finally,
    to fulfill our main goal of asserting code behavior, the execution modes must
    return the testing assertions’ status.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入一个可执行接口，以启用具有跨平台测试行为的测试运行者功能。这个接口作为命令行工具实现，必须处理用户在不同环境中的运行选项。最后，为了实现我们的主要目标——断言代码行为，执行模式必须返回测试断言的状态。
- en: As the executable triggers the tests, the tests will emit their status and events.
    The runner needs to respect the life cycles of those tests and subscribe to the
    events related to the testing workflow. Potential events could include passing
    or failing state or bubbling up assertion errors if those occur.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件触发测试时，测试将发出其状态和事件。运行者需要尊重这些测试的生命周期，并订阅与测试工作流程相关的事件。可能的事件包括通过或失败状态，或者在出现断言错误时向上冒泡。
- en: 'Creating a design diagram such as the one seen here makes it easier to see
    how the components that enable the feature set can interact with one another:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个如图所示的设计图，可以更容易地看到使功能集能够相互交互的组件：
- en: '![Figure 6.2: Initial design diagram](img/Figure_6.2_B19014.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：初始设计图](img/Figure_6.2_B19014.png.jpg)'
- en: 'Figure 6.2: Initial design diagram'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：初始设计图
- en: In *Figure 6**.2*, the flow of execution starts from the executable or the command
    line, defined on the left side of the diagram. In this case, the executable is
    the `ct` command, which is short for *Componium Test*. If the developer uses the
    command line as an entry point, then the **CLI handler** parses through the provided
    flags and options, determining if the tests will be running in the Node.js environment
    or the web browser environment. This will enable the cross-platform testing capabilities
    we evaluated during the feature planning process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.2*中，执行流程从左侧图中定义的可执行文件或命令行开始。在这种情况下，可执行文件是`ct`命令，代表*Componium Test*。如果开发者使用命令行作为入口点，那么**CLI处理器**会解析提供的标志和选项，确定测试是在Node.js环境还是网页浏览器环境中运行。这将使我们能够在功能规划过程中评估的跨平台测试能力。
- en: In the Node.js context, the `NodeExecutor` class can parse the provided test
    files and run their assertions, logging the real-time status of the execution
    and outputting the final results of the tests. The `chapter6/componium-test/packages/node/executor.js`
    file has the contents of `NodeExecutor`. The code is programmed to spawn worker
    environments for each test suite and run assertions in the test cases. Later,
    a summary of passing and failing tests is collected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js环境中，`NodeExecutor`类可以解析提供的测试文件并运行其断言，记录执行的真实状态并输出测试的最终结果。`chapter6/componium-test/packages/node/executor.js`文件包含`NodeExecutor`的内容。代码被编程为为每个测试套件生成工作环境，并在测试用例中运行断言。随后，收集通过和失败的测试摘要。
- en: In the browser context, the `BrowserExecutor` class relies on an external web
    browser bridge, provided by the `puppeteer` library. It creates a communication
    channel between the test runner and a real browser environment, queues the expected
    test suites, and uses a similar interface to capture test assertion and life cycle
    output. The browser environment also has distinct running methods, such as the
    *headless* and *headful* modes, where the browser is either hidden or displayed
    to the user while the tests run. This feature requires integrating the library
    and the test runner executable. This executor can be found in `chapter6/componium-test/packages/browser/executor.js`.
    This code works in a similar way to the Node.js method, but due to the fact that
    it runs in the web browser context, it has to send the results of the test suite
    back to the Node.js test runner running in the terminal process. The environmental
    difference makes the technical design of these two executors vastly different.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上下文中，`BrowserExecutor` 类依赖于由 `puppeteer` 库提供的外部网络浏览器桥接器。它创建测试运行器和真实浏览器环境之间的通信通道，排队预期的测试套件，并使用类似的接口捕获测试断言和生命周期输出。浏览器环境还有不同的运行方法，例如
    *无头* 和 *有头* 模式，在测试运行时浏览器对用户是隐藏还是显示。此功能需要集成库和测试运行器可执行文件。此执行器位于 `chapter6/componium-test/packages/browser/executor.js`。此代码与
    Node.js 方法类似，但由于它在浏览器上下文中运行，它必须将测试套件的结果发送回在终端进程中运行的 Node.js 测试运行器。环境差异使得这两个执行器的技术设计大相径庭。
- en: The diagram in *Figure 6**.2* also outlines potential support for running tests
    directly as a script file via the `node` CLI. In this case, the tests bypass the
    `ct` interface and directly output the results as the script runs. It is a handy
    feature that supports direct testing workflows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.2* 中的图表还概述了直接通过 `node` CLI 运行测试作为脚本文件的支持。在这种情况下，测试绕过 `ct` 接口，并在脚本运行时直接输出结果。这是一个方便的特性，支持直接测试工作流程。'
- en: The outline and diagram in *Figure 6**.2* do not capture the full details of
    the test runner workflow, but they are helpful for our development process. As
    you develop your own frameworks, you will find that creating such artifacts can
    help you be more efficient and precise in architecting different kinds of software
    solutions. With the architecture and features outlined, we can continue to the
    interface design part of the process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.2* 中的概述和图表没有捕捉到测试运行器工作流程的全部细节，但它们对我们的开发过程很有帮助。当你开发自己的框架时，你会发现创建这样的工件可以帮助你在构建不同类型的软件解决方案时更加高效和精确。有了概述的架构和功能，我们可以继续到接口设计过程的下一部分。'
- en: Designing the interfaces and API
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计接口和 API
- en: 'Two main interfaces are used as the point of interaction with our framework:
    the main framework module and the test runner executable. Developers must be acquainted
    with these interfaces through API documentation, examples, and more. In addition,
    introducing breaking changes or modifications to these APIs’ functionality will
    affect projects already integrated into the framework.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与框架交互的两个主要接口是主框架模块和测试运行器可执行文件。开发者必须通过 API 文档、示例等熟悉这些接口。此外，对这些 API 功能的破坏性更改或修改将影响已集成到框架中的项目。
- en: 'The first interface we are looking at is the imported `componium-test` framework
    module. This module exports the main testing object that can accept the testing
    function through **JavaScript Object Notation** (**JSON**). The module also exports
    additional framework interfaces, such as the assertion and mocking libraries.
    Here’s an example of using this module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看的第一个接口是导入的 `componium-test` 框架模块。此模块导出主测试对象，该对象可以通过 **JavaScript 对象表示法**
    (**JSON**) 接受测试函数。该模块还导出其他框架接口，例如断言和模拟库。以下是如何使用此模块的示例：
- en: Code snippet 1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 1
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code example of using the module in the test file can be found
    in the `tests/calc-tests.js` path of the framework. In this code, we see the inclusion
    of basic assertions for a sample `Calculator` script; those are made possible
    by importing the `assert` function. Based on the expected feature set, we have
    the test life cycle methods, such as `beforeEach`. Additionally, mocking functionality
    that replaces the return point of `multiply` is enabled by the `fake` and `replace`
    functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块在测试文件中的代码示例可以在框架的 `tests/calc-tests.js` 路径中找到。在这段代码中，我们看到包含了一个示例 `Calculator`
    脚本的基本断言；这些是通过导入 `assert` 函数实现的。根据预期的功能集，我们有测试生命周期方法，如 `beforeEach`。此外，通过 `fake`
    和 `replace` 函数启用了替换 `multiply` 返回点的模拟功能。
- en: 'The second interface is the command-line utility provided when the users install
    the framework. This is a test runner that enables interaction with a large number
    of test suites:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个接口是当用户安装框架时提供的命令行实用程序。这是一个测试运行器，允许与大量测试套件交互：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The executable supports a variety of options to enable the expected feature
    set. In addition, the `--help` flag can also display available commands and their
    shortcuts. The `ct` executable accepts one or more test suites as arguments, visible
    through the `ct [<tests>...]` notation. The presence of the `ct` executable is
    expected by developers after installing the framework from JavaScript’s `npm`
    package registry.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件支持多种选项以启用预期的功能集。此外，`--help` 标志还可以显示可用的命令及其快捷键。`ct` 可执行文件接受一个或多个测试套件作为参数，通过
    `ct [<tests>...]` 语法可见。开发者在从 JavaScript 的 `npm` 包注册表中安装框架后应期望存在 `ct` 可执行文件。
- en: We now have knowledge of these two developer-level APIs—the test executable
    and the test interface. We can now proceed to the implementation of features that
    power the functionality behind those two framework features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解这两个开发者级别的 API——测试可执行文件和测试接口。现在我们可以继续实现那些两个框架功能背后的功能特性。
- en: Implementing the new frameworks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新的框架
- en: 'The implementation process guides us further on how frameworks in JavaScript
    can be created. In this implementation process, we’ll see the different entry
    points of a test runner combined with distinguishable features. This section roughly
    follows the diagram in *Figure 6**.2*, where we outlined the framework design.
    Now that we know our features and have a rough idea of the project’s architecture,
    let’s broadly outline the steps of the internal implementation of this project,
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实施过程进一步指导我们如何创建 JavaScript 框架。在这个实施过程中，我们将看到测试运行器的不同入口点以及可区分的特性。本节大致遵循 *图 6**.2*
    中的图，其中我们概述了框架设计。现在我们知道了我们的功能和项目架构的大致想法，让我们广泛概述这个项目的内部实施步骤，如下：
- en: Determine how the designed test suite configuration can be implemented within
    the Node.js environment.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定设计的测试套件配置如何在 Node.js 环境中实现。
- en: Create internal packages to execute the test suites in different environments.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建内部包以在不同的环境中执行测试套件。
- en: Implement the infrastructure for real web browser-mode testing.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现真实网页浏览器模式测试的基础设施。
- en: Collect results from the test runner and output them to the user.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试运行器收集结果并将其输出给用户。
- en: 'Following *steps 1* to *4*, we begin our implementation by examining how our
    tests are structured and executed. In the preceding `Calculator Tests` snippet,
    we can examine the JavaScript object structure, consisting of a `ct` functional
    call and accepting a test suite object. Some special properties include describing
    the test suite name and running life cycle methods such as `before` and `after`.
    The execution life cycle of these methods can be seen in the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第 *1* 到 *4* 步，我们开始实施，首先检查我们的测试是如何构建和执行的。在先前的 `Calculator Tests` 片段中，我们可以检查
    JavaScript 对象结构，包括一个 `ct` 函数调用，接受一个测试套件对象。一些特殊属性包括描述测试套件名称和运行生命周期方法，如 `before`
    和 `after`。这些方法的执行生命周期可以在以下图中看到：
- en: '![Figure 6.3: Test life cycle](img/Figure_6.3_B19014.png.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：测试生命周期](img/Figure_6.3_B19014.png.jpg)'
- en: 'Figure 6.3: Test life cycle'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：测试生命周期
- en: To enable the `ct` function call, the test suites can access the `componium-test`
    package and our framework’s public interfaces, such as the assertion library features.
    We can see an example of including the framework in the `calc-tests.js` code block
    in *Code snippet 1*. Besides importing the framework features, the test file imports
    the code we aim to test.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`ct`函数调用，测试套件可以访问`componium-test`包以及我们框架的公共接口，例如断言库功能。我们可以在*代码片段1*中看到将框架包含在`calc-tests.js`代码块中的示例。除了导入框架功能外，测试文件还导入了我们要测试的代码。
- en: 'Importing our framework in the Node.js context will require properly exporting
    it as part of the package. To do that, we define an `exports` property in our
    `package.json` file. This allows projects to configure *Componium Test* as a dependency
    to import the module by name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js环境中导入我们的框架需要将其正确导出作为包的一部分。为此，我们在`package.json`文件中定义一个`exports`属性。这允许项目将*Componium
    Test*配置为依赖项，通过名称导入模块：
- en: Code Snippet 2
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段2
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding configuration pinpoints our `tester.js` file, which handles most
    of the test-running logic, referenced from our `runner` package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置指向我们的`tester.js`文件，该文件处理大多数测试运行逻辑，它由我们的`runner`包引用。
- en: Once the test object is loaded into the framework, it is directed to the appropriately
    named `packages/runner/tester.js` file. The `tester.js` file is where most of
    the testing happens, including the life cycle methods, executed at appropriate
    times, alongside the main test function. Provided that a test suite can have many
    tests, the tester proceeds to call through all the provided functions. To measure
    the speed of the tests, we can rely on the `performance` APIs ([developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)).
    These APIs provide high-resolution timestamps to provide us with data on how long
    the tests take to run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试对象被加载到框架中，它将被引导到名为`packages/runner/tester.js`的文件。`tester.js`文件是大多数测试发生的地方，包括在适当时间执行的生命周期方法，以及主测试函数。由于测试套件可以包含许多测试，测试器将继续调用所有提供的函数。为了测量测试的速度，我们可以依赖`performance`
    API（[developer.mozilla.org/en-US/docs/Web/API/Performance/now](http://developer.mozilla.org/en-US/docs/Web/API/Performance/now)）。这些API提供了高分辨率的时间戳，为我们提供了关于测试运行所需时间的数据。
- en: Testing functionality
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试功能
- en: Enabling an excellent testing experience through detailed test assertions, our
    project needs an assertion library that can be used within the newly written tests.
    The assertion interfaces should include equality comparison, value size comparison,
    object value evaluation, and others.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过详细的测试断言实现卓越的测试体验，我们的项目需要一个可以在新编写的测试中使用的断言库。断言接口应包括相等比较、值大小比较、对象值评估等。
- en: To focus on broad framework development, we will import an external test assertion
    library called `should`, `expect`, and `assert`. Subsequently, we can develop
    our own assertion infrastructure or replace Chai with a different library, which
    we can potentially develop by ourselves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于广泛的框架开发，我们将导入一个名为`should`、`expect`和`assert`的外部测试断言库。随后，我们可以开发自己的断言基础设施或用不同的库替换Chai，我们可能可以自己开发这个库。
- en: 'As the testing script executes our provided tests, our handy assertion library
    will throw an exception if any comparison functions are unsuccessful, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试脚本执行我们提供的测试时，如果任何比较函数失败，我们方便的断言库将抛出异常，如下所示：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding output shown is a snippet of a failure in one of the tests, where
    the imported `Calculator` module does not correctly perform the `multiply` operation.
    The framework needs to handle this type of code behavior. In the case of assertion
    or other errors, the test runner needs to signal back to the running process of
    at least one or more failed tests. If at least something flips the `errorOccurred`
    flag, then it will result in our testing node process exiting with a failure status.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是测试中失败的片段之一，其中导入的`Calculator`模块未能正确执行`multiply`操作。框架需要处理这种代码行为。在断言或其他错误的情况下，测试运行器需要至少向运行进程发出至少一个或多个失败测试的信号。如果至少有某个东西翻转了`errorOccurred`标志，那么它将导致我们的测试节点进程以失败状态退出。
- en: Besides the assertion library, we want to provide mocking and stubbing functionality
    in the developed framework. Using a similar pattern where we include the Chai.js
    library and expose it as a test API interface, we will include the **Sinon.js**
    ([sinonjs.org](http://sinonjs.org)) library, which has a rich interface for creating
    test stubs, spies, and mocks. It is an excellent fit for our project because it
    supports many JavaScript environments and has been battle-tested in other projects
    for many years. The presence of this library will make it easier for developers
    to increase code coverage and write more effective tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了断言库之外，我们希望在开发的框架中提供模拟和存根功能。使用类似的模式，我们包括Chai.js库并将其作为测试API接口暴露，我们将包括**Sinon.js**
    ([sinonjs.org](http://sinonjs.org))库，它具有创建测试存根、间谍和模拟的丰富接口。它非常适合我们的项目，因为它支持许多JavaScript环境，并且在其他项目中经过多年的实战考验。这个库的存在将使开发者更容易增加代码覆盖率并编写更有效的测试。
- en: In the code snippet (*Code snippet 1*) of the example test file, we use Sinon.js’
    functions to create a fake `mockMultiply` return point. The Sinon.js methods are
    also abstracted away from direct usage. Instead, they are exposed as part of the
    `componium-test` package. Users can access the library’s mocking, faking, and
    stubbing mechanisms configured in the framework’s `packages/mock/lib.js` mock
    package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例测试文件的代码片段(*代码片段1*)中，我们使用Sinon.js的函数创建一个假的`mockMultiply`返回点。Sinon.js方法也被从直接使用中抽象出来。相反，它们作为`componium-test`包的一部分被暴露。用户可以通过框架的`packages/mock/lib.js`模拟包访问库的模拟、伪造和存根机制。
- en: The inclusion of powerful assertions and mocking libraries, exposed in a simple
    interface, allows our framework to gain rich functionality from the first version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单界面暴露强大的断言和模拟库，我们的框架可以从一开始就获得丰富的功能。
- en: Creating a command-line tool
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令行工具
- en: 'In the previous sections, we talked about making our `tester.js` file the imported
    entry point to run tests. To match the expected feature set, the framework needs
    to support running multiple sets of tests from a given directory. This means supporting
    a number of suites of a given format in bulk. This means that the number of test
    suites will be structured in the following format:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了将我们的`tester.js`文件作为导入的入口点来运行测试。为了匹配预期的功能集，框架需要支持从给定目录运行多组测试。这意味着以批量方式支持给定格式的多个测试套件。这意味着测试套件的数量将以以下格式组织：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get this bulk execution feature, we need to create a command-line tool for
    our framework. To integrate with the Node.js command-line environment, we need
    to provide a `bin` key in the `package.json` file to export the command-line file,
    like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这个批量执行功能，我们需要为我们的框架创建一个命令行工具。为了与Node.js命令行环境集成，我们需要在`package.json`文件中提供一个`bin`键来导出命令行文件，如下所示：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The binary shortcut that we export is just `ct` to make it really easy to execute
    the framework commands from other projects. To develop the binary file, we can
    rely on the `yargs` library ([yargs.js.org](http://yargs.js.org)) to handle user
    input, parsing the provided process arguments from the `process.argv` variable.
    See the `packages/bin/ct.js` file for details on the executable structure. There
    are several features to remember with the structure of the executable, focusing
    on developing a good interface and enabling particular features of the framework,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出的二进制快捷键只是`ct`，以便从其他项目中轻松执行框架命令。为了开发二进制文件，我们可以依赖`yargs`库 ([yargs.js.org](http://yargs.js.org))来处理用户输入，解析从`process.argv`变量提供的进程参数。有关可执行文件结构的详细信息，请参阅`packages/bin/ct.js`文件。在可执行文件的结构中有几个需要记住的功能，重点是开发良好的接口并启用框架的特定功能，如下所示：
- en: Include the interpretation in the file’s first line with `#!/usr/bin/env node`.
    This signals to the system shell to use the node executable for this file. This
    is known as the *Shebang* ([wikipedia.org/wiki/Shebang_%28Unix%29](http://wikipedia.org/wiki/Shebang_%28Unix%29)),
    where an interpreter executable is provided within the script.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#!/usr/bin/env node`将解释器包含在文件的第一个行中。这会向系统shell发出信号，使用node可执行文件来处理此文件。这被称为*Shebang*
    ([wikipedia.org/wiki/Shebang_%28Unix%29](http://wikipedia.org/wiki/Shebang_%28Unix%29))，其中在脚本中提供了解释器可执行文件。
- en: Keep the binary package logic focused on the code related to parsing command-line
    flags and ensuring a good CLI experience. This includes supporting the `--help`
    flag, providing shortcuts to flags, and testing for edge cases of how an executable
    can be used. The flags or options of the CLI should follow the double-hyphenated
    (`--`) structure or a single one (`-`) for short options.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制包逻辑集中在与解析命令行标志和确保良好的命令行界面体验相关的代码上。这包括支持`--help`标志，提供快捷方式到标志，以及测试可执行文件的使用边缘情况。命令行界面（CLI）的标志或选项应遵循双短横线（`--`）结构或单个短横线（`-`）结构。
- en: The executable should follow the standard rules of CLIs. The CLI process should
    exit with an appropriate status code and indicate if the process failed. This
    is especially important in the case of the test runner that we are working with
    in this chapter.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件应遵循 CLI 的标准规则。CLI 进程应以适当的退出状态码退出，并指示进程是否失败。这对于我们在本章中使用的测试运行器尤为重要。
- en: Depending on the execution mode, Node.js, or the browser, the CLI file (`packages/runner/cli.js`)
    chooses the right executor class, providing this class with a list of target files.
    The `NodeExecutor` and `BrowserExecutor` classes have the job of processing all
    the test files and evaluating if any of the tests in those files fail any assertions.
    In the Node.js testing environment, we use the `NodeExecutor` class to run the
    tests. The class spawns new worker threads to execute test suites concurrently.
    The main purpose of this interface is to run tests for multiple target files and
    return an overall pass or fail result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据执行模式，Node.js 或浏览器，CLI 文件（`packages/runner/cli.js`）选择正确的执行器类，并向该类提供一个目标文件列表。`NodeExecutor`
    和 `BrowserExecutor` 类负责处理所有测试文件，并评估这些文件中的任何测试是否失败任何断言。在 Node.js 测试环境中，我们使用 `NodeExecutor`
    类来运行测试。该类会启动新的工作线程以并发执行测试套件。此接口的主要目的是为多个目标文件运行测试，并返回一个总体通过或失败的结果。
- en: Browser testing workflow
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器测试工作流程
- en: 'Another feature we are exploring in the developed framework is the ability
    to execute tests in a real web browser environment. To enable this, the CLI accepts
    a `–browser` flag that switches the running mode of the test framework. The entry
    point to this interface for a developer may look something like this: `ct –browser
    test/some_test.js`. Depending on the approach to the framework executables, we
    can also introduce a separate `ct-browser` executable to directly execute the
    test in the browser context without worrying about extra parameters. To implement
    this functionality, the framework relies on the `puppeteer` library to spawn a
    new browser instance and establish a communication channel with it.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发的框架中探索的另一个功能是在真实浏览器环境中执行测试的能力。为此，CLI 接受一个 `–browser` 标志，该标志切换测试框架的运行模式。对于开发者来说，此接口的入口点可能看起来像这样：`ct
    –browser test/some_test.js`。根据框架可执行文件的方法，我们还可以引入一个单独的 `ct-browser` 可执行文件，直接在浏览器上下文中执行测试，而无需担心额外的参数。为了实现此功能，框架依赖于
    `puppeteer` 库来启动一个新的浏览器实例，并与它建立通信通道。
- en: '*Figure 6**.4* shows the debugging view of the browser test runner workflow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.4* 展示了浏览器测试运行器工作流程的调试视图：'
- en: '![Figure 6.4: Debugging view of the browser test runner workflow](img/Figure_6.4_B19014.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：浏览器测试运行器工作流程的调试视图](img/Figure_6.4_B19014.png.jpg)'
- en: 'Figure 6.4: Debugging view of the browser test runner workflow'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：浏览器测试运行器工作流程的调试视图
- en: This operation mode is helpful to get access to the tests if they are failing
    in the browser. This environment allows developers to set breakpoints in their
    code and debug the tests. The `BrowserExecutor` file in `packages/browser/executor.js`
    takes care of launching a new instance of a real web browser. The communication
    channel it establishes can rely on messaging from the console or through more
    advanced `window.postMessage` function calls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作模式有助于在浏览器测试失败时访问测试。此环境允许开发者在其代码中设置断点并调试测试。`packages/browser/executor.js`
    中的 `BrowserExecutor` 文件负责启动一个真实的浏览器的新实例。它建立的通信通道可以依赖于控制台的消息或通过更高级的 `window.postMessage`
    函数调用。
- en: 'We can use a simple Node.js server paired with a small templating library called
    `eta` to create a browser page that executes the tests. We can create a valid
    HTML document with the templating library that includes the dependencies and test
    files. To properly load the framework files, the page relies on `importmap` ([developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap))
    to map ES module names to URLs. The code is illustrated in the following snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用简单的Node.js服务器和一个小型模板库`eta`来创建一个执行测试的浏览器页面。我们可以使用模板库创建一个有效的HTML文档，该文档包含依赖项和测试文件。为了正确加载框架文件，页面依赖于`importmap`（[developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap)）将ES模块名称映射到URL。以下代码片段展示了代码：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The initial implementation of the frontend test runner has a minimal interface,
    but it can be further developed to show a more interactive dashboard of tests.
    This can be a potential feature investment, adding additional frontend features
    if a test runner is used heavily in browser-related testing. The import map structure
    can be found in the `chapter6/componium-test/packages/browser/views/layout.eta`
    file. Besides the framework files, this file also consists of parsing a dynamic
    list of test suites that need to be included in the frontend. This makes it possible
    to include and run a number of test suites in the frontend testing harness.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前端测试运行器的初始实现具有最小的接口，但它可以进一步开发以显示更交互式的测试仪表板。这可能是一个潜在的功能投资，如果测试运行器在浏览器相关测试中被大量使用，可以添加额外的前端功能。导入映射结构可以在`chapter6/componium-test/packages/browser/views/layout.eta`文件中找到。除了框架文件外，此文件还包括解析需要包含在前端中的动态测试套件列表。这使得在前端测试工具中包含和运行多个测试套件成为可能。
- en: Testing the framework
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: As we develop the testing framework, we must ensure its reliability and correctness.
    However, using another external framework for testing might not be ideal, and
    we can’t use the framework itself to test its features as it is still under development.
    We use simple approaches to address this challenge, enabling unit, snapshot, and
    **end-to-end** (**E2E**) testing to ensure our project works correctly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发测试框架时，我们必须确保其可靠性和正确性。然而，使用另一个外部测试框架可能并不理想，而且我们不能使用该框架本身来测试其功能，因为它仍在开发中。我们使用简单的方法来应对这一挑战，使单元、快照和**端到端**（**E2E**）测试成为可能，以确保我们的项目正确运行。
- en: Unit testing of our project can primarily rely on the existing test runner implementation.
    However, we need to integrate snapshot testing, which includes comparing the test
    runner’s output with snapshotted versions of the desired output. As we refactor
    certain features, we should verify with the snapshot test to detect unintended
    changes. Including such tests gives us more confidence as we push new updates
    and improvements to the project. In particular, unit tests that require more attention
    are related to the exit status codes of the test runner.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目单元测试主要可以依赖于现有的测试运行器实现。然而，我们需要集成快照测试，这包括将测试运行器的输出与期望输出的快照版本进行比较。在我们重构某些功能时，我们应该使用快照测试来验证，以检测意外的变化。包含此类测试在我们推送新的更新和改进到项目中时，能让我们更有信心。特别是，需要更多关注的单元测试与测试运行器的退出状态码相关。
- en: 'Another important testing addition is the inclusion of E2E tests that cover
    the whole framework workflow. This includes installing packages, importing the
    testing package, and executing tests. These tests are made possible by creating
    a separate testing package that includes our framework as a dependency, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的测试补充是包含覆盖整个框架工作流程的端到端测试。这包括安装包、导入测试包和执行测试。这些测试是通过创建一个单独的测试包来实现的，该测试包将我们的框架作为依赖项，如下所示：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sample testing project includes `componium-test` as a dependency in its
    `package.json` file and points to the parent directory to load the files. These
    E2E tests can be found in the `e2e` directory of the project. In [*Chapter 9*](B19014_09.xhtml#_idTextAnchor156),
    we will explore additional ways to improve and validate project quality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试项目在`package.json`文件中将`componium-test`作为依赖项，并指向父目录以加载文件。这些端到端测试可以在项目的`e2e`目录中找到。在[*第9章*](B19014_09.xhtml#_idTextAnchor156)中，我们将探讨改进和验证项目质量的其他方法。
- en: Framework packages
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架包
- en: 'Shown in *Figure 6**.5* are the initial packages of the project. They are situated
    in the `packages` directory, similar to how many other frameworks choose to organize
    their projects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 6**.5* 所示是项目的初始包。它们位于 `packages` 目录中，类似于许多其他框架选择组织他们的项目：
- en: '![Figure 6.5: The framework packages of the project](img/Figure_6.5_B19014.png.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：项目的框架包](img/Figure_6.5_B19014.png.jpg)'
- en: 'Figure 6.5: The framework packages of the project'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：项目的框架包
- en: 'These packages are logically split by their responsibility. Here is a brief
    outline of what they do:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包根据它们的职责进行逻辑划分。以下是它们简要概述的功能：
- en: '`assert`: Contains the assertion library-related configuration'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`: 包含断言库相关的配置'
- en: '`bin`: Contains the executable, which is exported by the `package.json` file'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`: 包含可执行文件，由 `package.json` 文件导出'
- en: '`browser`: Files related to test execution in the browser environment'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser`: 与浏览器环境中的测试执行相关的文件'
- en: '`views`: Template files that make it possible to load tests in the frontend
    context'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`: 模板文件，使得在前端上下文中加载测试成为可能'
- en: '`mock`: Mocking library-related features'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock`: 模拟库相关的功能'
- en: '`node`: Files related to the Node.js execution environment'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`: 与 Node.js 执行环境相关的文件'
- en: '`runner`: Global test runner interfaces that are shared between the execution
    contexts'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner`: 在执行上下文之间共享的全局测试运行器接口'
- en: '`util`: Miscellaneous utility functions that are used across the framework'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`: 在框架中使用的各种实用函数'
- en: 'Besides assembling together all the self-developed packages into a cohesive
    design, our project also relies on external libraries. Here is a list of some
    of the dependencies that are utilized in the framework to achieve the desired
    feature set:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将所有自开发的包组合成一个统一的设计外，我们的项目还依赖于外部库。以下是框架中用于实现所需功能集的一些依赖项列表：
- en: '`chai`: This library allows us to quickly set up a test assertion interface
    to make the testing experience much nicer. It provides our framework with assertion
    interfaces useful for `github.com/chaijs/chai`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chai`: 此库允许我们快速设置一个测试断言接口，使测试体验更加愉快。它为我们提供了 `github.com/chaijs/chai` 中有用的断言接口。'
- en: '`sinon`: This library allows us to provide an interface for creating test spies,
    stubs, and mocks. Enabling this feature makes our framework more suitable for
    testing JavaScript applications, as it enables more comprehensive unit testing
    coverage.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinon`: 此库允许我们提供一个用于创建测试间谍、存根和模拟的接口。启用此功能使我们的框架更适合测试 JavaScript 应用程序，因为它允许更全面的单元测试覆盖率。'
- en: '`debug`: A small utility that makes it easier to develop the framework by introducing
    filtered debug logging. By namespacing the debug level after each package of our
    framework, it makes it easier to understand the framework’s internals as it executes
    tests.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`: 一个小型实用工具，通过引入过滤后的调试日志，使开发框架变得更加容易。通过在每个框架包之后命名空间调试级别，它在执行测试时使理解框架的内部结构变得更加容易。'
- en: '`eta`: This is a lightweight templating engine that helps us construct the
    test runner in the browser. It produces an HTML document with the necessary framework
    files and test suites.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eta`: 这是一个轻量级的模板引擎，帮助我们构建浏览器中的测试运行器。它生成一个包含必要的框架文件和测试套件的 HTML 文档。'
- en: '`glob`: This module enables pattern matching for test directories. It allows
    us to run a command such as `ct tests` where `tests` is a directory, resulting
    in finding all test files for a particular directory. Generally, `glob` saves
    us much time writing filesystem-related code by providing an easy-to-use file
    pattern matching system.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glob`: 此模块使测试目录可以进行模式匹配。它允许我们运行 `ct tests` 这样的命令，其中 `tests` 是一个目录，结果是在特定目录中找到所有测试文件。通常，`glob`
    通过提供易于使用的文件模式匹配系统，为我们节省了大量编写文件系统相关代码的时间。'
- en: '`yargs`: This is used as the argument parser for the framework’s CLI. It makes
    it easier for us to create a better command-line experience for the test runner.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yargs`: 这被用作框架 CLI 的参数解析器。它使我们能够为测试运行器创建更好的命令行体验。'
- en: '`puppeteer`: This library is included to provide the `BrowserExecutor` class
    with a real web-browser testing interface. `puppeteer` enables headless browser
    testing by controlling a Chromium or Firefox instance and running tests within
    that environment.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`puppeteer`: 包含此库是为了向 `BrowserExecutor` 类提供一个真实的网页浏览器测试接口。`puppeteer` 通过控制一个
    Chromium 或 Firefox 实例并在该环境中运行测试，实现了无头浏览器测试。'
- en: These are highlights of the dependencies that we’ll use in this project. For
    some of the framework logic, we have built out our own solutions, organized within
    packages. At the same time, we are relying on external libraries to address the
    complexities of specific technical challenges. The current structure allows us
    to introduce new packages or expand existing ones. The defined abstractions also
    allow us to swap out external dependencies in favor of other solutions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在项目中使用的依赖项的亮点。对于一些框架逻辑，我们已经构建了自己的解决方案，并组织在包中。同时，我们依赖外部库来解决特定技术挑战的复杂性。当前的架构允许我们引入新的包或扩展现有的包。定义的抽象也允许我们用其他解决方案替换外部依赖。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided us with a walkthrough on integrating the concepts and
    architectural principles from earlier sections of the book to build a basic JavaScript
    testing framework. The practical approach provides us with insights into building
    out testing framework internals. Even if we do not end up coding a new testing
    project, it still trains our software muscles to have general knowledge of architecting
    something from scratch. Our method uses a combination of libraries and packages
    to enable a hybrid of standard and unique features.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了一个了解如何将本书早期章节中的概念和架构原则整合到构建基本JavaScript测试框架中的指南。这种实用方法为我们提供了构建测试框架内部结构的见解。即使我们最终没有编码一个新的测试项目，它仍然训练我们的软件肌肉，使我们具备从零开始构建某物的通用知识。我们的方法结合了库和包的组合，以实现标准和独特功能的混合。
- en: 'We covered three parts of the framework development workflow: setting up a
    new project, drafting an initial design, and working through the first version
    of the goal brainstorming, architectural design, and implementation. As we put
    these skills into practice, the goal is to make you as a developer more comfortable
    with architecting, developing, and producing successful projects for others. In
    the upcoming chapters, we will focus on framework publishing and maintenance.
    We will also continue these practical exercises as we walk through building more
    projects.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了框架开发工作流程的三个部分：设置新项目、制定初步设计和完成目标头脑风暴的第一版，包括架构设计和实现。随着我们将这些技能付诸实践，目标是使你作为一个开发者对架构、开发和为他人制作成功的项目感到更加舒适。在接下来的章节中，我们将关注框架的发布和维护。我们还将继续这些实践练习，当我们逐步构建更多项目时。
