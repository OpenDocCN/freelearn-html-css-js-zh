["```js\ninterface Person {\n [id: string]: string;\n}\n```", "```js\nconst p: Person = {};\n\np[\"id-1\"] = \"Name1\";\np[\"string-2\"] = \"Name12\";\n\nconsole.log(p[\"string-2\"]); // Name12 \n```", "```js\nconst c: Person = {\n  \"test\": \"compile\", \n  123: \"compile too\" // Key is number even if Person requires string: it compiles\n};\n\ninterface NotAPerson {\n  [id: number]: string;\n}\n\n// DOES NOT COMPILE:\nconst c2: NotAPerson = {\n  \"test\": \"compile\", // THIS LINE DOES NOT COMPILE\n  123: \"compile too\"\n};\n```", "```js\ninterface NotIndexSignatureObject {\n    name: string;\n    count: number;\n}\n\nconst obj: NotIndexSignatureObject = {\n    name: \"My Name\",\n    count: 123\n};\n\nconsole.log(obj[\"doesNotExist\"]); // Does not compile\nconsole.log(obj[\"name\"]); // Compile\n```", "```js\n interface ObjWithMembersAndIndexSignature {\n    name: string;\n    count: number;\n    when: Date;\n    [id: string]: string; // DOES NOT COMPILE\n}\n```", "```js\ninterface ObjWithMembersAndIndexSignature {\n name: string;\n count: number;\n when: Date;\n [id: number]: string; // COMPILE\n}\n```", "```js\ninterface ObjWithMembersAndIndexSignature2 {\n name: string;\n count: number;\n when: Date;\n obj: { s: string }; // DOES NOT COMPILE\n [id: number]: string | number | Date;\n}\n```", "```js\nconst obj2: ObjWithMembersAndIndexSignature = {\n    name: \"My Name\",\n    count: 123,\n    when: new Date(),\n    \"more\": \"nooo\" // DOES NOT COMPILE\n};\n```", "```js\n  const obj3: ObjWithMembersAndIndexSignature = {\n    name: \"My Name\",\n    count: 123,\n    when: new Date(),\n    12: \"string only\" // Good if number->string\n};\n```", "```js\n  interface ObjWithMembersAndIndexSignature2 {\n    name: string;\n    count: number;\n    when: Date;\n    [id: string]: string | number | Date;\n}\n```", "```js\ninterface MyMap<T> {\n    [index: string]: T;\n}\n\ninterface YourBusinessLogicObject {\n    oneProps: string;\n    secondProps: number;\n    thirdProps: Date;\n    yourDictionary: MyMap<string>;\n}\n```", "```js\nlet map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\n\nlet value1: string | undefined = map.get(\"key1\");\n```", "```js\nlet map2 = new Map(); // Key any, value any\nlet map3 = new Map<string, number>(); // Key string, value number\n```", "```js\nlet map4 = new Map([[1, \"value1\"], [\"key2\", \"value2\"]]); // Doesn't compile\n```", "```js\nmap.set(\"key3\", \"value3\");\nmap.has(\"key1\");\nmap.delete(\"key1\"); // Similar to delete obj.key1 (index signature)\n```", "```js\ntoString(): string;\ntoLocaleString(): string;\nvalueOf(): Object;\nhasOwnProperty(v: string): boolean;\nisPrototypeOf(v: Object): boolean;\npropertyIsEnumerable(v: string): boolean;\n```", "```js\nlet bigObject: Object;\nbigObject = 1;\nbigObject = \"1\";\nbigObject = true;\nbigObject = Symbol(\"123\");\nbigObject = { a: \"test\" };\nbigObject = () => { };\nbigObject = [1, 2, 3];\nbigObject = new Date();\nbigObject = new MyClass();\nbigObject = Object.create({});\n```", "```js\nlet littleObject: object;\n\nlittleObject = { a: \"test\" };\nlittleObject = new Date();\nlittleObject = () => { };\nlittleObject = [1, 2, 3];\nlittleObject = new MyClass();\nlittleObject = Object.create({});\n```", "```js\nlet acceptNull: number | null = null;\nacceptNull = 1;\n\nlet acceptUndefined: number | undefined = 1;\nacceptUndefined = null;\n```", "```js\nlet obj1: Object = {};\nlet obj2: object = {};\nlet obj3: {} = {};\nlet obj4: any = {};\n\nobj1.test = \"2\"; // Does not compile\nobj2.test = \"2\"; // Does not compile\nobj3.test = \"2\"; // Does not compile\nobj4.test = \"2\";\n\nobj1.toString();\nobj2.toString();\nobj3.toString();\nobj4.toString();\n```", "```js\ntype ObjLiteralType = { x: number, y: number };\ninterface ObjLiteralType2 {\n  x: number;\n  y: number;\n}\n```", "```js\nfunction uppercaseObject(obj: Object): void { }\nfunction lowercaseObject(obj: object): void { }\nfunction anyObject(obj: any): void { }\nfunction objectLiteral(obj: {}): void { }\n\nuppercaseObject({ x: 1 });\nlowercaseObject({ x: 1 });\nanyObject({ x: 1 });\nobjectLiteral({ x: 1 });\n```", "```js\nlet literalObject: ObjLiteralType = { x: 1, y: 2 };\nlet literalObject2: ObjLiteralType2 = { x: 1, y: 2 };\nlet literalObject3: { x: number, y: number } = { x: 1, y: 2 };\nlet literalObject4 = { x: 1, y: 2 };\n\nliteralObject = literalObject2 = literalObject3 = literalObject4;\n```", "```js\nclass ClassWithConstructor {\n    constructor(){\n        console.log(\"Object instantiated\");\n    }\n}\nconst cwc = new ClassWithConstructor();\n```", "```js\ninterface MyObject {\n    a: number;\n    b: string;\n}\nconst newObject1: MyObject = { a: 1, b: \"2\" };\n```", "```js\n  const newObject2 = { a: 1, b: \"2\" } as MyObject;\n```", "```js\nconst newObject3 = { a: 1, b: \"2\", c: \"OH NO\" } as MyObject;\nconst newObject4 = { a: 1 } as MyObject;\n```", "```js\ntype MyType = \"a\" | \"b\" | \"c\";\nconst m1: MyType = \"a\";\nconst m2: MyType = \"no\"; // Doesnâ€™t compile\n```", "```js\ntype AcceptedOption = number | string | { option1: string, option2: number };\nconst myOption1: AcceptedOption = \"run\";\nconst myOption2: AcceptedOption = 123;\nconst myOption3: AcceptedOption = { option1: \"run\", option2: 123 };\n```", "```js\nfunction functWithUnion(p: boolean | undefined): undefined | null{\n      return undefined;\n}\n```", "```js\ninterface TypeA {\n    a: string;\n    b: string;\n}\n\ninterface TypeB {\n    b: string;\n    c: string;\n}\n\nfunction functionWithUnion(param1: TypeA | TypeB): void {\n    console.log(param1.b);\n}\n```", "```js\ninterface TypeA {\n    a: string;\n    b: string;\n}\ninterface TypeB {\n    b: string;\n    c: string;\n}\n\ntype TypeC = TypeA & TypeB;\nconst m: TypeC = {\n    a: \"A\",\n    b: \"B\",\n    c: \"C\",\n};\n```", "```js\ninterface TypeA {\n    a: string;\n    b: string;\n}\nfunction intersectGeneric<TT1>(t1: TT1): TT1 & TypeA {\n    const x: TypeA = { a: \"a\", b: \"b\" };\n    return (<any>Object).assign({}, x, t1);\n}\n\nconst result = intersectGeneric({ c: \"c\" });\nconsole.log(result); // { a: 'a', b: 'b', c: 'c' }\n```", "```js\ntype TypeD1 = TypeA & TypeB;\ntype TypeD2 = TypeB & TypeA;\n```", "```js\n let d1: TypeD1 = { a: \"a\", b: \"b\", c: \"c\" };\n let d2: TypeD2 = { a: \"a\", b: \"b\", c: \"c\" };\n\n console.log(typeof d1); // Object\n console.log(typeof d2); // Object\n console.log(d1 === d2); // False\n\n d2 = d1;\n console.log(d1 === d2); // True\n```", "```js\ntype TypeD3 = (TypeA & TypeB) | (TypeB & TypeA);\ntype TypeD4 = TypeA & TypeB | TypeB & TypeA;\ntype TypeD5 = (TypeA & TypeB);\n\ntype TypeD6 = TypeA & TypeB;\n\nlet d3: TypeD3 = { a: \"a\", b: \"b\", c: \"c\" };\nlet d4: TypeD4 = { a: \"a\", b: \"b\", c: \"c\" };\nlet d5: TypeD5 = { a: \"a\", b: \"b\", c: \"c\" };\nlet d6: TypeD6 = { a: \"a\", b: \"b\", c: \"c\" };\n```", "```js\ninterface InterfaceA {\n m1: string;\n}\n\ninterface InterfaceB {\n m2: string;\n}\n\ntype TypeAB = InterfaceA & InterfaceB;\n```", "```js\ntype ClassAb = ClassA & ClassB;\nconst classAb: ClassAb = { m1: \"test\", m2: \"test2\" };\n```", "```js\n interface InterfaceSameField1 {\n    m1: string;\n }\n\n interface InterfaceSameField2 {\n    m1?: string;\n }\n\n type Same = InterfaceSameField1 & InterfaceSameField2;\n let same: Same = { m1: \"This is required\" };\n```", "```js\ninterface InterfaceA {\n  m1: string;\n}\n\ninterface InterfaceB {\n  m2: string;\n}\n\ninterface InterfaceMergeAB extends InterfaceA, InterfaceB {\n  m3: string;\n}\n```", "```js\ninterface IA {\n  m1: string;\n}\n\ninterface IA {\n\n  m2: string;\n}\n\nconst ia: IA = { m1: \"m1\", m2: \"m2\" };\n```", "```js\ntype TPrimitive1 = string;\ntype TPrimitive2 = { m1: string };\n\nclass ExtendPrimitiv1 implements TPrimitive1 { // Does not compile\n}\n\nclass ExtendPrimitiv2 implements TPrimitive2 { // Compile\n public m1: string = \"Compile\";\n}\n```", "```js\ntype TypeWithIndex = {\n  [key: string]: string;\n  m1: string;\n}\n\nconst c: TypeWithIndex = {\n  m1: \"m1\"\n};\n\nc[\"m2\"] = \"m2\";\n```", "```js\ninterface MyObject {\n  id: number;\n  time: number;\n  name: string;\n  startTime: Date;\n  stopTime: Date;\n  category: string;\n}\n\nconst obj: MyObject = {\n  id: 1,\n  time: 100,\n  name: \"MyName\",\n  startTime: new Date(),\n  stopTime: new Date(),\n  category: \"Cat5\"\n};\n\nconst id = obj.id;\nconst name = obj.name;\nconst category = obj.category;\n```", "```js\nconst { id, name, category } = obj;\n```", "```js\nconst { id, name, category, ...remainingMembers } = obj;\n\nremainingMembers.startTime;\nremainingMembers.stopTime;\nremainingMembers.time;\n```", "```js\n const values = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n const [value1, value2, ...value3To9] = values;\n```", "```js\nconst values = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst [value1, value2, ...value3To9] = values;\nconst [value_1, , value_3, ...value4To9] = values;\n```", "```js\nlet tuple1 = [\"First name\", \"Last Name\", 1980]; // Infered as (string | number)[]\ntuple1[2] = \"Not a number\";\nlet tuple2: [string, string, number] = [\"First name\", \"Last Name\", 1980]; // Tuple\ntuple2[2] = \"Not a number\"; // Does not compile\n```", "```js\nlet tuple3: [string, string, number]\ntuple3 = [\"Only One\"]; // Does not compile\ntuple3 = [\"One\", \"Two\", 3, \"four\"]; // Does not compile\ntuple3[5] = \"12\"; // Compile\n```", "```js\ntuple3[5] = \"12\"; // Compile, do not mind the type\ntuple3[1]= 2; // Does not compile, require to be a string\n```", "```js\nfunction restFunction(...args: [number, string, boolean]): void{\n const p1:number = args[0];\n const p2:string = args[1];\n const p3:boolean = args[2];\n // Code\n}\n\nfunction resultFunction(p1: number, p2: string, p3: boolean): void{\n // Code\n}\n\nlet tuple4: [number, string, boolean] = [0, \"one\", false];\nlet array4: (number | string | boolean )[] = [0, \"one\", false];\n\nrestFunction(...tuple4);\nrestFunction(...array4); // Doesn't compile\n\nrestFunction(tuple4[0],tuple4[1],tuple4[2]);\nrestFunction(array4[0],array4[1],array4[2]); // Does not compile\n```", "```js\nlet tuple5: [number, string?, boolean?];\ntuple5 = [1];\ntuple5 = [1, \"two\"];\ntuple5 = [1, \"two\", false];\n```", "```js\nlet tuple5: [number, (string | undefined)?, (boolean | undefined)?]\n```", "```js\ntype MyTuple = [number, string];\nlet tuple6:MyTuple = [1, \"Test\"];\n```", "```js\ndeclare let myVariable: string;\n```", "```js\ndeclare module \"messageformat\" {\n}\n```"]