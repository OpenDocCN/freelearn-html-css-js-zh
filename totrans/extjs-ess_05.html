<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Modeling Data Structures for Your UI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Modeling Data Structures for Your UI</h1></div></div></div><p>Representing your system's data accurately is extremely important for every application. Being able <a id="id146" class="indexterm"/>to access and manipulate datasets in a logical and organized way is essential to creating a maintainable code base.</p><p>Ext JS has <a id="id147" class="indexterm"/>a comprehensive data package which makes this task very easy. It has a huge number of features, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Numerous data field types</li><li class="listitem" style="list-style-type: disc">Automatic value conversion</li><li class="listitem" style="list-style-type: disc">Validation rules</li><li class="listitem" style="list-style-type: disc">Associations, including one-to-many, one-to-one, and many-to-many</li><li class="listitem" style="list-style-type: disc">Abstracted reading and writing mechanisms, including AJAX, LocalStorage, and REST</li></ul></div><p>In this chapter, we will demonstrate how to create the data structures required for our business dashboard application, how to join these data models with associations, and how to read and write data from a backend.</p><p>The following diagram demonstrates the data entities and their relationships that we will be representing in our application:</p><div class="mediaobject"><img src="graphics/3717_05_01.jpg" alt="Modeling Data Structures for Your UI"/></div><p>The main relationships are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>Location</strong></span> can contain one or more Products</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>Product</strong></span> can be found in one or more Locations</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>Product</strong></span> can have multiple Sales</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>Sale</strong></span> can involve one or more Products</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>User</strong></span> can have multiple Sales</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>User</strong></span> can have multiple Messages</li></ul></div><div class="section" title="Defining models"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Defining models</h1></div></div></div><p>Data models<a id="id148" class="indexterm"/> are defined as regular Ext JS classes and should extend the <code class="literal">Ext.data.Model</code> class. Model classes are generally located in the app's model folder and can have any number of subnamespaces to allow for grouping of related models.</p><p>We will start by defining our Product model in a file named <code class="literal">Product.js</code> in the <code class="literal">model</code> folder:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.Product', {
  extend: 'Ext.data.Model',
  fields: [
    {
      name: 'Name',
      type: 'string'
    },
    {
      name: 'Description',
      type: 'string'
    },
    {
      name: 'Quantity',
      type: 'int'
    },
    {
      name: 'Price',
      type: 'float'
    }
  ]
});</pre></div><p>To save on some key strokes, you can generate models in the command line using Sencha Cmd. Refer to <a class="link" href="ch04.html" title="Chapter 4. Architecting an Ext JS Application">Chapter 4</a>, <span class="emphasis"><em>Architecting an Ext JS Application</em></span>, for details on how to do this.</p><div class="section" title="Fields"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Fields</h2></div></div></div><p>The <code class="literal">fields</code> property in the product model defines the name and type of each piece of data<a id="id149" class="indexterm"/> attached to the model. Each object in the fields array is a configuration object for the <code class="literal">Ext.data.Field</code> class, which provides various options for how the field is interpreted and stored.</p><p>The main configurations are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: This is the name of the field. It is used as the mapping key when reading data from a data source and retrieving it later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: This is data type the assigned value should be parsed into. Possible values include <code class="literal">string</code>, <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">date</code>, <code class="literal">boolean</code>, and <code class="literal">auto</code>. If set to <code class="literal">auto</code>, no automatic conversion will take place.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mapping</code>: This allows the field's value to be pulled from a property that doesn't match the field's name.</li></ul></div></div><div class="section" title="Field validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Field validation</h2></div></div></div><p>Validation<a id="id150" class="indexterm"/> logic for data structures can be baked right into the definition, thus ensuring that the same logic isn't scattered all through your application. This can be added with the <code class="literal">validators</code> option which lets you define what validation rules should be applied to each field.</p><p>We can add validation rules to our Product model to ensure each field's data is correct. We do this by defining an object with each key referring to a field's name. The value of this property can be a simple string referring to the name of a validation type, an object configuring the validation, or an array of objects so multiple rules can be applied.</p><p>The following snippet shows the configuration used to validate the fields in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Name</code> field is valid by being present (that is, not empty) and by being at least three characters long</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Quantity</code> field must be present</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Price</code> field is greater than 0</li></ul></div><div class="informalexample"><pre class="programlisting">...
  validators: {
    Name: [
      {
        type : 'presence'
      },
      {
        type : 'length',
        min  : 3
      }
    ],
    Quantity: 'presence',
    Price: {
      type: 'range',
      min: 0
    }
  }
...</pre></div><p>The <code class="literal">type</code> config defines the rule we want to apply: out of the box the possibilities are <code class="literal">presence</code>, <code class="literal">length</code>, <code class="literal">format</code>, <code class="literal">inclusion</code>, <code class="literal">exclusion</code>, <code class="literal">range</code>, and <code class="literal">email</code>. Details of each can be found in the <code class="literal">Ext.data.validator.*</code> namespace.</p><p>Any other properties added are then used as options to customize that specific validator; for example, min defines the minimum length the <code class="literal">Name</code> must have.</p><p>We can apply the validation rules on a model instance (sometimes referred to as a <span class="emphasis"><em>record</em></span>) using the <code class="literal">getValidation</code> method. This method will return an instance of the <code class="literal">Ext.data.Validation</code> class, which we can then query to determine which fields are invalid <a id="id151" class="indexterm"/>and retrieve error messages from.</p></div><div class="section" title="Custom field types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Custom field types</h2></div></div></div><p>Although Ext JS has five field types that cover the majority of scenarios required, the latest <a id="id152" class="indexterm"/>version introduces the ability to create your own custom field type that can have conversions, validations, and serializations built in. This feature can help reduce duplicated code across models that share the same field type.</p><p>In our Product model, we defined a validation rule for the <code class="literal">Price</code> field to ensure it has a positive value. We will have to apply this same rule to every model which has a field holding a monetary value. This would be a prime candidate for a custom field type that would allow this configuration to be shared.</p><p>Custom field types are declared in the same way as other classes and should extend the <code class="literal">Ext.data.field.Field</code> class (or one of its subclasses if you want to build upon their existing functionality). We will extend the <code class="literal">Ext.data.field.Number</code> type, which provides us with the logic to ensure the value is numeric.</p><p>The validation we added to the Product model can then be added to this class:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.field.Money', {
  extend: 'Ext.data.field.Number',
  alias: 'data.field.money',
  validators: [
    {
      type: 'range',
      min : 0
    }
  ],
  getType: function() {
    return 'money';
  }
});</pre></div><p>This custom field type can now be used by assigning any field a type of <code class="literal">money</code>. The Product model's <code class="literal">Price</code> field will be rewritten as follows, and will automatically have the validation rules we specified applied to it:</p><div class="informalexample"><pre class="programlisting">...
  {
    name: 'Price',
    type: 'money' 
  }
...</pre></div></div><div class="section" title="Custom data converters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Custom data converters</h2></div></div></div><p>A field's value <a id="id153" class="indexterm"/>can be automatically processed before being stored, in order to modify it in some way based on other field values, or to parse its value into a different type; for example, splitting a currency value received as "USD10.00" to its two component parts: currency and value.</p><p>The first way to do this is to add a <code class="literal">convert</code> property to the field's configuration and assign it a function. This function will be passed the field's value and the record instance it is being stored in and should return the processed value which will then be stored.</p><p>It should be noted that the record instance may be incomplete depending on the order in which the fields are populated, so it can't be guaranteed that other field values will be available.</p><p>The following example shows how we might implement a <code class="literal">StockValue</code> field, which uses the current <code class="literal">Quantity</code> and <code class="literal">Price</code> values to calculate the total value of the stock:</p><div class="informalexample"><pre class="programlisting">{
  name   : 'StockValue',
  type   : 'money',
  convert: function(val, rec) {
    return rec.get('Quantity') * rec.get('Price');
  },
  depends: ['Price', 'Quantity']
}</pre></div><p>We have <a id="id154" class="indexterm"/>also included the <code class="literal">depends</code> config, which creates a dependency between our <code class="literal">StockValue</code> field and the fields we use in its <code class="literal">convert</code> function. This means that when the <code class="literal">Price</code> or <code class="literal">Quantity</code> fields are updated, the <code class="literal">StockValue</code> field is recalculated ensuring everything is kept in sync.</p><p>Another way of doing this, is to use the <code class="literal">calculate</code> option, which behaves in a very similar way, but is designed to be used for purely calculated fields rather than manipulating actual values. We could rewrite the <code class="literal">StockValue</code> field using <code class="literal">calculate</code>, as follows:</p><div class="informalexample"><pre class="programlisting">{
  name     : 'StockValue',
  type     : 'money',
  calculate: function(data) {
    return data.Quantity * data.Price;
  }
}</pre></div><p>The <code class="literal">calculate</code> function accepts one parameter containing the record's data object, which can be used to access the other fields. As with the <code class="literal">convert</code> function, it should return the value to be stored.</p><p>By using <code class="literal">calculate</code>, the dependencies are automatically determined based on the function's contents. So, there is no need for an explicit <code class="literal">depends</code> configuration.</p></div></div></div>
<div class="section" title="Working with stores"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Working with stores</h1></div></div></div><p>Stores<a id="id155" class="indexterm"/> are a collection of model instances that allow these models to be manipulated (for example, sorted, filtered, searched, and so on). They also provide a platform for backend interaction. Many of Ext JS' components can be bound to data stores and take care of a lot of the plumbing required to react to changes in the data held within it.</p><p>In this section, we will discuss how to construct a simple store and how to perform simple manipulation of the data within it; how to create different views of a dataset using Chained stores; and finally, how hierarchical data can be stored using TreeStores.</p><div class="section" title="Simple stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Simple stores</h2></div></div></div><p>To define<a id="id156" class="indexterm"/> a store, you must extend the <code class="literal">Ext.data.Store</code> class and configure it with a <code class="literal">model</code> class that it will hold a collection of. The following store definition shows a store containing a collection of user records:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User'
});</pre></div><p>We can <a id="id157" class="indexterm"/>now add our store to the <code class="literal">stores</code> config option in our <code class="literal">Application.js</code> file. This will result in the file being loaded and automatically instantiated, making it accessible using the <code class="literal">Ext.getStore</code> method. We can then populate it with some sample data using the <code class="literal">add</code> method:</p><div class="informalexample"><pre class="programlisting">// Application.js
stores: [
  'Users'
],
launch: function() {
  var usersStore = Ext.getStore('Users');
  usersStore.add([
    {
      Name : 'John',
      Email : 'john@gmail.com',
      TelNumber: ' 0330 122 2800',
      Role : 'Administrator'
    },
    {
      Name : 'Sarah',
      Email : 'sarah@hotmail.com',
      TelNumber: ' 0330 122 2800',
      Role : 'Customer'
    },
    {
      Name : 'Brian',
      Email : 'brian@aol.com',
      TelNumber: ' 0330 122 2800',
      Role : 'Supplier'
    },
    {
      Name : 'Karen',
      Email : 'karen@gmail.com',
      TelNumber: ' 0330 122 2800',
      Role : 'Administrator'
    }
  ]);
}</pre></div><p>Now that we have a store filled with data, we can start exploring the various methods to interrogate and manipulate the data.</p><div class="section" title="Store stats"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Store stats</h3></div></div></div><p>We <a id="id158" class="indexterm"/>often need to know how many records there are within a store, and this can be done easily with the <code class="literal">getCount</code> method:</p><div class="informalexample"><pre class="programlisting">usersStore.getCount() // returns 4</pre></div></div><div class="section" title="Retrieving a record"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Retrieving a record</h3></div></div></div><p>The<a id="id159" class="indexterm"/> simplest way to retrieve a record instance is to access it based on its (zero-based) index. To do this, we use the <code class="literal">getAt</code> method, which returns the <code class="literal">Ext.data.Model</code> subclass at that position (or null if none was found):</p><div class="informalexample"><pre class="programlisting">var userRecord = usersStore.getAt(0); // { Name: "John" ... }</pre></div></div><div class="section" title="Finding specific records"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Finding specific records</h3></div></div></div><p>In <a id="id160" class="indexterm"/>order to find a specific record based on a field's value, we use the <code class="literal">findRecord</code> method which, in its simplest form, accepts a field name and value to match. This will return the first record that matches, or null if none was found:</p><div class="informalexample"><pre class="programlisting">var userRecord = usersStore.findRecord('Name', 'Karen');</pre></div><p>By default, this will search all records and will look for the search value at the beginning of the record's value. It will be case insensitive and will allow partial matches. These options can be changed by passing the following parameters to the <code class="literal">findRecord</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Field Name (String)</strong></span>: The field to match against</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Search Value (String/Number/Date)</strong></span>: The value to find</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Start Index (Number)</strong></span>: The index at which to start searching</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Any Match (Boolean)</strong></span>: True to match the search value anywhere (not just at the beginning)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Case Sensitive (Boolean)</strong></span>: True to match the case</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Exact Match (Boolean)</strong></span>: True to match the whole value</li></ul></div><p>If you <a id="id161" class="indexterm"/>would prefer to retrieve the index of the record, rather than the actual record instance, you can use the <code class="literal">find</code> method, which will return the record's position, or -1 if not found.</p></div><div class="section" title="Complex searches"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Complex searches</h3></div></div></div><p>If your<a id="id162" class="indexterm"/> search criteria are more complex than a simple field match, you can use your own custom matching functions to introduce multiple criteria. For example, you may want to find a user by name and telephone number.</p><p>You can do this using the <code class="literal">findBy</code> method, passing it a function that will have one parameter, a <code class="literal">record</code> instance, and it should return true if it is deemed a match or false if it isn't. This function will be executed once for each record in the store or until it finds a match:</p><div class="informalexample"><pre class="programlisting">var userRecord = usersStore.findBy(function(record){
  return record.get('Name') === 'John' &amp;&amp; record.get('TelNumber') === '0330 122 2800';
});</pre></div></div><div class="section" title="Filtering a store"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Filtering a store</h3></div></div></div><p>Stores<a id="id163" class="indexterm"/> can be filtered at any time with similar basic or complex queries. Doing so, will result in the store exposing a subset of its original dataset. The filters can be removed at any time to restore the full dataset once again.</p><p>We can filter a store by using the <code class="literal">addFilter</code> method, which accepts a single <code class="literal">Ext.util.Filter</code> instance or an array of <code class="literal">Ext.util.Filter</code> instances or configuration objects. These should specify the name of the field being filtered on and the value to compare against. The following example filters the store to only users named "Brian":</p><div class="informalexample"><pre class="programlisting">console.log(usersStore.getCount()); // 4
usersStore.addFilter({
  property: 'Name',
  value: 'Brian'
});
console.log(usersStore.getCount()); // 1</pre></div><p>In a way similar to the <code class="literal">findBy</code> method, we can also filter with a function that allows more complex queries to be constructed. The following example shows the store being filtered by name and e-mail:</p><div class="informalexample"><pre class="programlisting">console.log(usersStore.getCount()); // 4
usersStore.filterBy(function(record){
  return record.get('Name') === 'John' &amp;&amp; record.get('Email') === 'john@swarmonline.com';
});
console.log(usersStore.getCount()); // 1</pre></div><p>While a<a id="id164" class="indexterm"/> store is filtered, all query operations (<code class="literal">find</code>, <code class="literal">getAt</code>, and so on) are performed on the filtered dataset and won't search any filtered items. To return the store to its unfiltered state, simply call the <code class="literal">clearFilter</code> method:</p><div class="informalexample"><pre class="programlisting">console.log(usersStore.getCount()); // 1
usersStore.clearFilter();
console.log(usersStore.getCount()); // 4</pre></div><div class="section" title="Configuration-based filtering"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec09"/>Configuration-based filtering</h4></div></div></div><p>All the<a id="id165" class="indexterm"/> preceding examples show the store being filtered programmatically. It is also possible to define a default filter when the store is configured, and which will be applied to all new records being added to the store. This can be a full <code class="literal">Ext.util.Filter</code> configuration object with a simple property/value combination or a more complex <code class="literal">filterFn</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  filters: [
    {
      property: 'Name',
      value: 'John'
    }
  ]
});</pre></div></div></div><div class="section" title="Sorting a store"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Sorting a store</h3></div></div></div><p>We can <a id="id166" class="indexterm"/>also change the sort order of a store's records by using the <code class="literal">sort</code> or <code class="literal">sortBy</code> methods. As with filtering and finding, these allow for simple sorting in one or more fields, or more complex sorting using a function. Note that if no sorting options are provided, the records will remain in the order they are added.</p><p>A simple sort on <code class="literal">Name</code> can be seen as follows:</p><div class="informalexample"><pre class="programlisting">console.log(usersStore.getAt(0).get('Name')); // John

  usersStore.sort('Name', 'ASC');

console.log(usersStore.getAt(0).get('Name')); // Brian 

console.log(usersStore.getAt(3).get('Name')); // Sarah

  usersStore.sort('Name', 'DESC');

console.log(usersStore.getAt(0).get('Name')); // Sarah 

console.log(usersStore.getAt(3).get('Name')); // Brian</pre></div><p>To perform more complex sorting, you can provide an object that will configure an instance of the <code class="literal">Ext.util.Sorter</code> class. This example sorts by the reverse of each user's name (for example, nhoJ, haraS):</p><div class="informalexample"><pre class="programlisting">usersStore.sort({
  sorterFn: function(a, b) {
    var aName = a.get('Name').split('').reverse().join(''),
      bName = b.get('Name').split('').reverse().join('');
    return ((aName &lt; bName) ? -1 : ((aName &gt; bName) ? 1 : 0));
  },
  direction: 'ASC'
});</pre></div><div class="section" title="Configuration-based sorting"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec10"/>Configuration-based sorting</h4></div></div></div><p>Once<a id="id167" class="indexterm"/> again, we can define a default sorter on a store that will be reapplied after each new record is added. This should be an <code class="literal">Ext.util.Sorter</code> configuration object:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  sorters: [
    {
      property: 'Name',
      direction: 'DESC'
    }
  ]
});</pre></div></div></div><div class="section" title="Grouping"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Grouping</h3></div></div></div><p>A store's <a id="id168" class="indexterm"/>records can also be grouped by specific fields or combination of fields, which can be very useful to display data in grouped grids. We use the <code class="literal">group</code> method as follows, passing in the <code class="literal">Role</code> field, as the field to group on and <code class="literal">ASC</code> to determine the sort direction of the groups:</p><div class="informalexample"><pre class="programlisting">usersStore.group('Role', 'ASC');</pre></div><p>By calling this method, the store remains unchanged. This means all its records can be accessed as before, but it now gives us access to an <code class="literal">Ext.util.GroupCollection</code> instance, which is a collection of <code class="literal">Ext.util.Group</code> instances that holds a set of grouped records in each instance.</p><p>We can interrogate the grouped data using the <code class="literal">getGroups</code> method:</p><div class="informalexample"><pre class="programlisting">var groups = usersStore.getGroups();
console.log(groups.getCount()); // 3 groups: Administrator, Supplier, Customer
console.log(groups.getAt(0).getGroupKey()); // Administrator
console.log(groups.getAt(1).getGroupKey()); // Customer
console.log(groups.getAt(2).getGroupKey()); // Supplier
console.log(groups.getAt(0).getCount()); // 2
console.log(groups.getAt(0).getAt(0).get('Name')); // John
console.log(groups.getAt(0).getAt(1).get('Name')); // Karen</pre></div><p>In addition to accepting these parameters, we can also pass in an <code class="literal">Ext.util.Grouper</code> config object to define a more complex grouping setup. In the following example, we group by each user's email address domain (notice that we use the <code class="literal">clearGrouping</code> method to reset any existing groupings already in place):</p><div class="informalexample"><pre class="programlisting">usersStore.clearGrouping();
usersStore.group({
  groupFn: function(rec){
    var email = rec.get('Email'),
      emailSplit = email.split('@'),
      domain = emailSplit[1];
    return domain;
  },
  direction: 'DESC'
});
groups = usersStore.getGroups();
console.log(groups.getCount()); // 3 groups: hotmail.com,
//gmail.com, aol.com
console.log(groups.getAt(0).getGroupKey()); // hotmail.com 
console.log(groups.getAt(1).getGroupKey()); // gmail.com 
console.log(groups.getAt(2).getGroupKey()); // aol.com
console.log(groups.getAt(0).getCount()); // 1 
console.log(groups.getAt(0).getAt(0).get('Name')); // Sarah</pre></div><div class="section" title="Configuration-based grouping"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec11"/>Configuration-based grouping</h4></div></div></div><p>Grouping <a id="id169" class="indexterm"/>can also be done in the store's definition by using the <code class="literal">groupField</code> and <code class="literal">groupDirection</code> options together, or the <code class="literal">grouper</code> option on its own. The following snippets show the store grouped in <code class="literal">Role</code> using each combination:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  grouper: [
    {
      property: 'Role',
      direction: 'ASC'
    }
  ]
});</pre></div><p>And, here is the another one:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  groupField: 'Role',
  groupDir: 'ASC'
});</pre></div></div></div></div><div class="section" title="Chained stores"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Chained stores</h2></div></div></div><p>Chained<a id="id170" class="indexterm"/> stores are a new addition to Ext JS 5 and allow us to create different <a id="id171" class="indexterm"/>views of the same underlying data store without it affecting the base data or other chained stores.</p><p>Imagine that we want to display the data within our <code class="literal">usersStore</code> in separate grids for each role. We would want one grid attached to the <code class="literal">usersStore</code> with a filter of <span class="emphasis"><em>Role=Administrator</em></span>, the next grid with <span class="emphasis"><em>Role=Supplier</em></span>, and so on. Unfortunately, before Ext JS 5, this was not possible to do with just one store and so, we would have to create multiple stores with multiple copies of the same data and manage them all separately. Chained stores take this problem away and allow us to attach to an underlying base data store and apply any filters and sorters to the view of the data, without them affecting the base store or any other linked chained stores.</p><p>The following diagram explains this concept:</p><div class="mediaobject"><img src="graphics/3717_05_02.jpg" alt="Chained stores"/></div><p>Key things<a id="id172" class="indexterm"/> to remember about chained stores are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id173" class="indexterm"/> record instances are shared between all chained stores and the base store</li><li class="listitem" style="list-style-type: disc">Any updates made to any of the records will be propagated through to all linked stores</li></ul></div><p>Going back to our roles example, we can now solve the problem by defining three chained stores that can be bound to separate grids or data views.</p><p>We link them to the base data store using the <code class="literal">source</code> configuration option, which can accept a store instance or a store ID. We can then add any sorters or filters to the chained store, as we would to a regular store.</p><p>We <a id="id174" class="indexterm"/>create <a id="id175" class="indexterm"/>these in the folder <code class="literal">store/users/</code> to keep things organized:</p><div class="informalexample"><pre class="programlisting">// store/users/Admins.js
Ext.define('BizDash.store.users.Admins', {
  extend: 'Ext.data.ChainedStore',
  config: {
    source: 'Users',
    filters: [
      {
        property: 'Role',
        value: 'Administrator'
      }
    ]
  }
});

// store/users/Customers.js
Ext.define('BizDash.store.users.Customers', {
  extend: 'Ext.data.ChainedStore',
  config: {
    source: 'Users',
    filters: [
      {
        property: 'Role',
        value: 'Customer'
      }
    ]
  }
});

// store/users/Suppliers.js
Ext.define('BizDash.store.users.Suppliers', {
  extend: 'Ext.data.ChainedStore',
  config: {
    source: 'Users',
    filters: [
      {
        property: 'Role',
        value: 'Supplier'
      }
    ]
  }
});</pre></div><p>We then add the new stores to the <code class="literal">stores</code> config within <code class="literal">Application.js</code> and create an instance of each and see the record counts in each:</p><div class="informalexample"><pre class="programlisting">var adminStore = Ext.create('BizDash.store.users.Admins');
var customerStore = Ext.create('BizDash.store.users.Customers');
var supplierStore = Ext.create('BizDash.store.users.Suppliers');
console.log(usersStore.getCount()); // 4
console.log(adminStore.getCount()); // 2
console.log(customerStore.getCount()); // 1
console.log(supplierStore.getCount()); // 1</pre></div></div><div class="section" title="TreeStores"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>TreeStores</h2></div></div></div><p>The <code class="literal">Ext.data.TreeStore</code> class is a specialist store, extending from the regular <code class="literal">Ext.data.Store</code> class, which<a id="id176" class="indexterm"/> manages hierarchical data. This type of store<a id="id177" class="indexterm"/> must be used to bind to Tree Panels and other components, where data is required to have a hierarchical structure.</p><p>TreeStores are created in the same way as regular stores except for one main difference. The collection of the model that a TreeStore manages must extend from the <code class="literal">Ext.data.TreeModel</code> class, rather than the usual <code class="literal">Ext.data.Model</code>.</p><div class="section" title="Ext.data.TreeModels"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Ext.data.TreeModels</h3></div></div></div><p>The reason that a TreeStore's model must extend the <code class="literal">Ext.data.TreeModel</code> class is that each <a id="id178" class="indexterm"/>model instance must be decorated with additional properties and methods to allow the models' hierarchy to be managed correctly, and to allow the tree components to display them correctly. These extra properties and methods come from the <code class="literal">Ext.data.NodeInterface</code> class, whose members are all applied to each model instance in the TreeStore.</p><p>We will create a simple tree example by first defining the model that will be stored. Our data will represent our application's navigation structure and will form the basis of our menu:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.NavigationItem', {
  extend: 'Ext.data.TreeModel',
  fields: [
    {
      name: 'Label',
      type: 'string'
    },
    {
      name: 'Route',
      type: 'string'
    }
  ]
});</pre></div><p>If you require this class within your <code class="literal">Application.js</code> file, create an instance of this model and inspect its contents. You will see that the model now has over 20 additional data fields. These fields are all used to describe each node for various purposes, for example, tracking its location, its state, and its appearance.</p><p>By default, these fields have their <code class="literal">persist</code> configs set to <code class="literal">false</code>, so they won't be included in any save operations initiated.</p><div class="mediaobject"><img src="graphics/3717_05_03.jpg" alt="Ext.data.TreeModels"/></div><p>If you<a id="id179" class="indexterm"/> look further, you will also see numerous extra methods added to the model. These methods can be used to manage the node and its children, traverse the tree structure, and interrogate its position in the hierarchy. Some of the more <a id="id180" class="indexterm"/>useful methods are detailed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">appendChild</code>: This<a id="id181" class="indexterm"/> adds the specified node(s) as the last child of the current node</li><li class="listitem" style="list-style-type: disc"><code class="literal">insertChild</code>: This <a id="id182" class="indexterm"/>inserts the new node at the specified position</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeChild</code>: This<a id="id183" class="indexterm"/> removes the specified node from the child collection</li><li class="listitem" style="list-style-type: disc"><code class="literal">eachChild</code>: This<a id="id184" class="indexterm"/> executes a function on each of the child nodes</li><li class="listitem" style="list-style-type: disc"><code class="literal">findChild</code>: This <a id="id185" class="indexterm"/>finds the first child that matches the given property/value given</li><li class="listitem" style="list-style-type: disc"><code class="literal">isLeaf</code>: This <a id="id186" class="indexterm"/>determines if the current node is a leaf without any further children</li></ul></div></div><div class="section" title="Creating a TreeStore"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Creating a TreeStore</h3></div></div></div><p>We will <a id="id187" class="indexterm"/>create a simple TreeStore called <code class="literal">BizDash.store.Navigation</code>, which will contain a collection of <code class="literal">BizDash.model.NavigationItem</code> model instances. This store extends the base <code class="literal">Ext.data.TreeStore</code> class:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Navigation', {
  extend: 'Ext.data.TreeStore',
  model: 'BizDash.model.NavigationItem'
});</pre></div><p>We include this store in the <code class="literal">Application.js</code> file's <code class="literal">stores</code> array, where it will be automatically loaded and instantiated, and will be accessible via a call to <code class="literal">Ext.getStore('Navigation')</code>.</p></div><div class="section" title="Populating a TreeStore"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Populating a TreeStore</h3></div></div></div><p>TreeStores<a id="id188" class="indexterm"/> must always have a <span class="emphasis"><em>root node</em></span>, which is the root parent of all child nodes within the store. It is common for this node to always be hidden and never actually seen in tree views. To populate our TreeStore programmatically (that is, not from an external data source—we'll talk about that in the next section), we can either add the full hierarchy using the <code class="literal">setRoot</code> method, or add child nodes individually using the <code class="literal">appendChild</code> or <code class="literal">insertChild</code> methods.</p><p>We will start by using the <code class="literal">setRoot</code> method, which builds a hierarchy of <code class="literal">NavigationItem</code> instances expanding outward from the root:</p><div class="informalexample"><pre class="programlisting">var navigationStore = Ext.getStore('Navigation');
navigationStore.setRoot({
  Label : 'Root',
  children: [
    {
      Label: 'Home',
      Route: '/home'
    },
    {
      Label : 'Users',
      Route : '',
      children: [
      {
        Label: 'Manage Users',
        Route: '/manage-users',
        leaf : true
      },
      {
        Label: 'Add User',
        Route: '/add-user',
      leaf : true
      }
    ]}
  ]
});</pre></div><p>This will produce a structure, as follows:</p><div class="mediaobject"><img src="graphics/3717_05_04.jpg" alt="Populating a TreeStore"/></div><p>Note that <a id="id189" class="indexterm"/>our own fields (<code class="literal">Label</code> and <code class="literal">Route</code>) are combined with some of the <code class="literal">Ext.data.NodeInterface</code> fields (children and leaf); we do this to indicate the parent-child relationship between the nodes, and to indicate which nodes do not have any children, respectively.</p><p>Once a root node exists, we can also start adding nodes using the <code class="literal">appendChild</code> method, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">// append a node at the same level as 'Home' and 'Users'
navigationStore.getRoot().appendChild({
  Label: 'Orders',
  Route: '/orders'
});
// find the 'Users' node and append a node to it
navigationStore.getRoot().findChild('Label', 'Users', true).appendChild({
  Label: 'Import Users',
  Route: '/import-users'
});</pre></div></div></div></div>
<div class="section" title="Getting data into your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Getting data into your application</h1></div></div></div><p>So far, <a id="id190" class="indexterm"/>we have only dealt with hard-coded data and not with real-world examples of loading and saving data from/to external sources, whether they are REST endpoints, local databases, or third party APIs. Ext JS supports a number of different ways of assisting with data loading and persistence, including AJAX and LocalStorage.</p><div class="section" title="Ext.Ajax"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Ext.Ajax</h2></div></div></div><p>Although<a id="id191" class="indexterm"/> only indirectly related to stores, we are first going to discuss AJAX requests in a more general sense and how we can perform them to make calls to a server backend.</p><p>
<code class="literal">Ext.Ajax</code> is a singleton instance of the <code class="literal">Ext.data.Connection</code> class, which provides us with a very simple interface for making AJAX calls to a server and handling the response. We will primarily focus on the <code class="literal">request</code> method, which initiates this call and allows us to specify how it should be made.</p><div class="section" title="Simple AJAX calls"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Simple AJAX calls</h3></div></div></div><p>We will <a id="id192" class="indexterm"/>start by demonstrating how to make a simple AJAX request to a static JSON file. We simply pass in a configuration object to the request method, telling the framework where to make the AJAX request to, in this case specifying the <code class="literal">url</code> property:</p><div class="informalexample"><pre class="programlisting">Ext.Ajax.request({
  url: 'user.json'
});</pre></div><p>If we run this in the console of the Ext JS app, we should see the request being made in the <span class="strong"><strong>Network</strong></span> tab. At the moment, we are ignoring the response given to us, so now we will include a callback function to process the received data.</p><p>As we're sure you know, AJAX calls are asynchronous, meaning the rest of the code will carry on while the request is made and will not wait for it to complete. This means we must handle the response in a callback function that will get executed when the response has been received. We do this by specifying the <code class="literal">success</code> property, whose function will be given two parameters: a response object and an options object.</p><p>In our success handler, we will decode the JSON string received and log the output to the console:</p><div class="informalexample"><pre class="programlisting">Ext.Ajax.request({
  url: 'user.json',
  success: function(response, options){
    var user = Ext.decode(response.responseText);
    console.log(user);
  }
});</pre></div></div><div class="section" title="Handling errors"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Handling errors</h3></div></div></div><p>Obviously <a id="id193" class="indexterm"/>we can't just rely on the fairytale case where all our AJAX requests complete successfully, so we must include some alternative should our request fail (that is, return a non-200 response code). We can do this by specifying a <code class="literal">failure</code> config and defining a function that will be executed should the request fail. The following example console logs the response status code when an error occurs:</p><div class="informalexample"><pre class="programlisting">Ext.Ajax.request({
  url: 'user.json',
  success: function(response, options){
    var user = Ext.decode(response.responseText);
    console.log(user);
  },
  failure: function(response, options){
    console.log('The request failed! Response Code: ' + response.status);
  }
});</pre></div><p>You can try this out by modifying the <code class="literal">url</code> property to a non-existent one to force a 404 error.</p></div><div class="section" title="Other useful configurations"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec26"/>Other useful configurations</h3></div></div></div><p>You <a id="id194" class="indexterm"/>can pass a lot of configuration options to the <code class="literal">request</code> method. We run down a few of these as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">params</code>: This<a id="id195" class="indexterm"/> is an object whose key/value pairs will be sent along with the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: This <a id="id196" class="indexterm"/>is the method by which the request is sent (defaults to <code class="literal">GET</code> when no <code class="literal">params</code> are present, or <code class="literal">POST</code> if they are)</li><li class="listitem" style="list-style-type: disc"><code class="literal">callback</code>: The <a id="id197" class="indexterm"/>function defined here will be called following the request, regardless of the success or failure</li><li class="listitem" style="list-style-type: disc"><code class="literal">timeout</code>: This<a id="id198" class="indexterm"/> defines the timeout length, in seconds, for the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">headers</code>: This<a id="id199" class="indexterm"/> defines the headers that are sent with the request</li></ul></div></div></div><div class="section" title="Proxies"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Proxies</h2></div></div></div><p>Now that<a id="id200" class="indexterm"/> we have discussed performing simple AJAX requests, which<a id="id201" class="indexterm"/> could quite happily be used to populate stores, we will move on to explain proxies, which provide us with a simple mechanism for our stores to communicate with data sources.</p><p>A store or model can be configured with a proxy, which provides an abstracted layer above the specifics of each possible data source (be it an external server or LocalStorage). This abstraction allows us to provide a simple configuration and have the store take care of performing the intricacies of communicating with the source.</p><p>Proxies are<a id="id202" class="indexterm"/> linked to two other class types: <code class="literal">Reader</code> and <code class="literal">Writer</code>. The <code class="literal">Reader</code> class is<a id="id203" class="indexterm"/> responsible for interpreting the received data and parsing it correctly, so it can be turned into Model instances. The <code class="literal">Writer</code> class on the other hand, looks after collecting the data to be saved.</p><p>The following diagram shows how these classes are linked:</p><div class="mediaobject"><img src="graphics/3717_05_05.jpg" alt="Proxies"/></div><div class="section" title="AJAX proxies"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec27"/>AJAX proxies</h3></div></div></div><p>The most<a id="id204" class="indexterm"/> common type of proxy is an AJAX proxy (<code class="literal">Ext.data.proxy.Ajax</code>), which allows us to load and save data to server endpoints via an AJAX call. We<a id="id205" class="indexterm"/> will add an AJAX proxy to our users store to load the data from a simple JSON file:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  proxy: {
    type : 'ajax',
    url : 'users.json',
    reader: {
      type : 'json',
      rootProperty: 'rows'
    }
  }
});</pre></div><p>Let's break down this code. We start by adding a <code class="literal">proxy</code> config option with a <code class="literal">config</code> object. We specify the type of <code class="literal">proxy</code> we want (we'll talk about other types shortly)—in this case an AJAX proxy which equates to the <code class="literal">Ext.data.proxy.Ajax</code> class. We next specify the <code class="literal">url</code> to load the data from. Finally, we tell the proxy how to interpret the results by giving it a <code class="literal">reader</code> configuration. The type tells it we're going to be receiving JSON data and so we want to use the <code class="literal">Ext.data.reader.Json</code> class. The <code class="literal">rootProperty</code> tells the reader which property of the received JSON object to look in for the data records.</p><p>This setup <a id="id206" class="indexterm"/>will load data from the <code class="literal">users.json</code> file, which<a id="id207" class="indexterm"/> contains the following data:</p><div class="informalexample"><pre class="programlisting">{
  "success": true,
  "results": 4,
  "rows": [
    {
      "Name"     : "John",
      "Email"    : "john@gmail.com",
      "TelNumber": "0330 122 2800",
      "Role"     : "Administrator"
    },
    {
      "Name"     : "Sarah",
      "Email"    : "sarah@hotmail.com",
      "TelNumber": "0330 122 2800",
      "Role"     : "Customer"
    },
    {
      "Name"     : "Brian",
      "Email"    : "brian@aol.com",
      "TelNumber": "0330 122 2800",
      "Role"     : "Supplier"
    },
    {
      "Name"     : "Karen",
      "Email"    : "karen@gmail.com",
      "TelNumber": "0330 122 2800",
      "Role"     : "Administrator"
    }
  ]
}</pre></div><p>We can now call the load method of the users store and it will make an AJAX request to the <code class="literal">users.json</code> file and populate itself with four records. The following code will load the store and log the loaded records once it has completed:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').load(function(records, operation, success){
  console.log(Ext.getStore('Users').getCount()); // 4
  console.log(records); // [ ...record instances... ]
});</pre></div></div><div class="section" title="LocalStorage proxies"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec28"/>LocalStorage proxies</h3></div></div></div><p>Another<a id="id208" class="indexterm"/> type of proxy is the <code class="literal">localstorage</code> proxy, which<a id="id209" class="indexterm"/> allows us to load and save data to the LocalStorage within the browser. It is extremely simple to configure a store to communicate with the LocalStorage, and it follows the same pattern as the AJAX proxy, as seen here:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.store.Users', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.User',
  proxy: {
    type: 'localstorage',
    id : 'users'
  }
});</pre></div><p>Again, we specify the proxy type, which in this case, will use the <code class="literal">Ext.data.proxy.LocalStorage</code> class. We also specify an <code class="literal">id</code> which will be used to identify items that belong to this store within the LocalStorage. This <code class="literal">id</code> must be unique across all proxies.</p><p>We will first demonstrate saving records, so we have some data to load in LocalStorage. We can save the store's records by calling the <code class="literal">sync</code> method after adding some records:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').add([
  {
    Name : 'John',
    Email : 'john@gmail.com',
    TelNumber: ' 0330 122 2800',
    Role : 'Administrator'
  },
  {
    Name : 'Sarah',
    Email : 'sarah@hotmail.com',
    TelNumber: ' 0330 122 2800',
    Role : 'Customer'
  },
  {
    Name : 'Brian',
    Email : 'brian@aol.com',
    TelNumber: ' 0330 122 2800',
    Role : 'Supplier'
  },
  {
    Name : 'Karen',
    Email : 'karen@gmail.com',
    TelNumber: ' 0330 122 2800',
    Role : 'Administrator'
  }
]);

Ext.getStore('Users').sync();</pre></div><p>If you open up the <span class="strong"><strong>Resources</strong></span> tab of Developer Tools and inspect the LocalStorage area, you will see the records with keys based on the <code class="literal">id</code> we provided.</p><p>There are<a id="id210" class="indexterm"/> three types of items stored:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;id&gt;-counter</code>, which<a id="id211" class="indexterm"/> holds the number of records stored</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;id&gt;</code>, which contains a comma-separated list of the stored records' IDs</li><li class="listitem" style="list-style-type: disc">Each record's JSON encoded data stored with a key in the format of <code class="literal">&lt;id&gt;-&lt;Record ID&gt;</code></li></ul></div><div class="mediaobject"><img src="graphics/3717_05_14.jpg" alt="LocalStorage proxies"/></div><p>Now that we have records saved in LocalStorage, we can call the store's <code class="literal">load</code> method, in the same way as we did with the AJAX proxy, to retrieve these saved records and repopulate the store.</p></div></div><div class="section" title="REST proxies"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>REST proxies</h2></div></div></div><p>Many <a id="id212" class="indexterm"/>APIs are RESTful and so Ext JS has a proxy to make integration <a id="id213" class="indexterm"/>with them extremely easy. By defining a REST proxy, our CRUD requests will be executed to the endpoint with the correct method type. We can update our users store to use a REST proxy (the <code class="literal">Ext.data.writer.Rest</code> class), by changing the type to <code class="literal">rest</code>:</p><div class="informalexample"><pre class="programlisting">proxy: {
  type  : 'rest',
  url   : 'users',
  reader: {
    type        : 'json',
    rootProperty: 'rows'
  }
}</pre></div><p>Now that we have our store, by using a REST proxy, we can update one of the records and sync the store and see a <code class="literal">GET</code> request made to retrieve the records and a <code class="literal">PUT</code> request being made to update the data:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').getAt(0).set('Email', 'john@hotmail.com');
Ext.getStore('Users').sync();</pre></div><p>Here<a id="id214" class="indexterm"/> is <a id="id215" class="indexterm"/>the screenshot of it:</p><div class="mediaobject"><img src="graphics/3717_05_15.jpg" alt="REST proxies"/></div></div></div>
<div class="section" title="Data associations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Data associations</h1></div></div></div><p>Our <a id="id216" class="indexterm"/>application's data models will always have associations between them, which must be represented in our client-side applications, so that they can be manipulated easily and consistently. Ext JS offers the ability to model one-to-one, one-to-many, and many-to-many relationships between Model types.</p><div class="section" title="One-to-many"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>One-to-many</h2></div></div></div><p>One-to-many <a id="id217" class="indexterm"/>relationships exist when<a id="id218" class="indexterm"/> a single entity owns multiple entities of a different type. For example, an author <span class="emphasis"><em>has many</em></span> books or a recipe <span class="emphasis"><em>has many</em></span> ingredients. In our example project, we will model the association between users and sales—a user can have many sales and each sale only has one user.</p><div class="mediaobject"><img src="graphics/3717_05_11.jpg" alt="One-to-many"/></div><div class="section" title="Configuring a proxy and data source"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec29"/>Configuring a proxy and data source</h3></div></div></div><p>We will <a id="id219" class="indexterm"/>start by defining a proxy and<a id="id220" class="indexterm"/> simple static data source to connect our models to so that they can be populated. We do this with the following code pointing to two simple JSON files:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.Sale', {
  extend: 'Ext.data.Model',
  ...
  proxy: {
    type : 'ajax',
    url : 'sale.json',
    reader: {
      type: 'json'
    }
  }
  ...
});

// sale.json
[
  {
    "id": 1,
    "userId": 1,
    "productId": 1,
    "Date" : "2014-08-04T14:41:17.220Z",
    "Quantity" : 1,
    "TotalCost": 9.99
  },
  {
    "id": 2,
    "userId": 1,
    "productId": 1,
    "Date" : "2014-08-03T14:41:17.220Z",
    "Quantity" : 2,
    "TotalCost": 19.98
  }
]

Ext.define('BizDash.model.User', {
  extend: 'Ext.data.Model',
  ...
  proxy: {
    type : 'ajax',
    url : 'user.json',
    reader: {
      type: 'json'
    }
  }
  ...
});

// user.json
{
  "id" : 99,
  "Name" : "Joe Bloggs",
  "Email" : "joe@gmail.com",
  "TelNumber": " 07777777777",
  "Role" : "Salesman"
}</pre></div></div><div class="section" title="Defining the association"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec30"/>Defining the association</h3></div></div></div><p>Now<a id="id221" class="indexterm"/> that we have our infrastructure in place to allow data to be loaded into each model, we can define the relationship between these two entities. There are two ways this can be done: <code class="literal">hasMany</code> and <code class="literal">reference</code>.</p><div class="section" title="hasMany config"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec12"/>hasMany config</h4></div></div></div><p>The <code class="literal">hasMany</code> configuration option is the way these associations have always been created <a id="id222" class="indexterm"/>and allow us to define the models that would be related, and the names and data sources of each. This approach allows for more explicit control over the details of the association, making it more appropriate for more custom situations:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.User', {
  extend: 'Ext.data.Model',
  ...
  hasMany: [
    {
      model: 'BizDash.model.Sale',
      name: 'sales'
    }
  ],
  ...
});</pre></div><p>The <code class="literal">hasMany</code> config accepts an array of association definitions and should include a model option, defining the name of the model that the association data represents, and a name option which will be used to access the associated data.</p><p>To access the associated data via the defined proxy, we use the user model's static <code class="literal">load</code> method to load the user with an ID of <code class="literal">1</code> and specify a callback function to execute when it is successfully loaded:</p><div class="informalexample"><pre class="programlisting">BizDash.model.User.load(1, {
  success: function(userRecord) {
  }
});</pre></div><p>We can now load in the sale records that are associated with this user. We do this by calling the <code class="literal">sales</code> method (so called based on the <code class="literal">name</code> config we gave it in our <code class="literal">hasMany</code> configuration), which will return an <code class="literal">Ext.data.Store</code> instance that will contain our sale record instances. We then call that store's <code class="literal">load</code> method, which will hit the <code class="literal">sale.json</code> file and return the related sale records. Within a callback function, we can then see the data items loaded:</p><div class="informalexample"><pre class="programlisting">BizDash.model.User.load(1, {
  success: function(userRecord) {
    userRecord.sales().load(function() {
      console.log('User: ', userRecord.get('Name')); // Joe Bloggs
      console.log('Sales: ', userRecord.sales().getCount()); // 2
    });
  }
});</pre></div></div></div><div class="section" title="The reference config"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec31"/>The reference config</h3></div></div></div><p>The <a id="id223" class="indexterm"/>new way in Ext JS 5 to define associations is<a id="id224" class="indexterm"/> to use the <code class="literal">reference</code> config on a model's field, which will link the foreign key in a model to a related model type. This greatly simplifies the construction of associations and means both directions of the association can be accessed easily.</p><p>The following code shows the <code class="literal">reference</code> config added to the <code class="literal">BizDash.model.Sale</code> model, linking it to the <code class="literal">BizDash.model.User</code> model:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.Sale', {
  extend: 'Ext.data.Model',
  fields: [
    ...
    {
      name: 'userId',
      type: 'int',
      reference: 'BizDash.model.User'
    },
    ...
  ]
});</pre></div><p>We can <a id="id225" class="indexterm"/>now use the same code to load the user<a id="id226" class="indexterm"/> and then its associated sale records:</p><div class="informalexample"><pre class="programlisting">BizDash.model.User.load(1, {
  success: function(userRecord) {
    userRecord.sales().load(function(){
      console.log('User: ', userRecord.get('Name')); // Joe Bloggs
      console.log('Sales: ', userRecord.sales().getCount()); // 2
    });
  }
});</pre></div><p>This technique also makes it easy to gain access to a sale record associated to a user. We make use of the generated <code class="literal">getUser</code> method, which is added to the sale record because of the reference we created. Calling this method will load the relevant user model based on the foreign key (<code class="literal">userId</code>) defined in the sale:</p><div class="informalexample"><pre class="programlisting">var saleRecord = Ext.create('BizDash.model.Sale', {
  id : 1,
  userId : 1,
  productId: 1,
  Date : new Date(),
  Quantity : 1,
  TotalCost: 9.99
});
saleRecord.getUser(function(userRecord){
  console.log(userRecord.get('Name')) // Joe Bloggs
});</pre></div></div><div class="section" title="Exploring requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Exploring requests</h3></div></div></div><p>Each time <a id="id227" class="indexterm"/>we did a <code class="literal">load</code> or <code class="literal">getUser</code> call in our associations, an AJAX request was made to our server resources. In our case, we just had simple static JSON files, but in real life, we would have a proper server implementation which would return the correct data, based on the sale or user being requested. If we look at the <span class="strong"><strong>Network</strong></span> tab of Developer Tools, we can see that the request to the <code class="literal">user.json</code> and <code class="literal">sale.json</code> files passed up parameters that we can then use to retrieve the correct data from our server database.</p><p>The following screenshot shows the user with ID of 1 loading. It passes the ID value as a query string parameter:</p><div class="mediaobject"><img src="graphics/3717_05_12.jpg" alt="Exploring requests"/></div><p>When <a id="id228" class="indexterm"/>loading the sales relating to this user, the server is given a slightly more complex JSON string with details of the filter that should be applied to retrieve the correct data. In our server-side code, we would parse this and use it in our database queries.</p><div class="mediaobject"><img src="graphics/3717_05_13.jpg" alt="Exploring requests"/></div></div></div><div class="section" title="Many-to-many"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Many-to-many</h2></div></div></div><p>Another<a id="id229" class="indexterm"/> relationship type that can be modeled is<a id="id230" class="indexterm"/> many-to-many. In our application, we want to define a many-to-many relationship between Products and Locations, meaning that one Product can be stored in multiple Locations and one Location can have multiple Products. For example, Product 1 could be located in Warehouse 1 and Warehouse 2, and Warehouse 1 could store Product 1 and Product 2.</p><div class="section" title="Configuring a proxy and data source"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec33"/>Configuring a proxy and data source</h3></div></div></div><p>As we<a id="id231" class="indexterm"/> did earlier, we will start by defining<a id="id232" class="indexterm"/> a proxy and simple static data source to connect our models to so that they can be populated. We do this with the following code pointing to two simple JSON files:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.Product', {
  extend: 'Ext.data.Model',
  ...
  proxy: {
    type : 'ajax',
    url : 'product.json',
    reader: {
      type: 'json'
    }
  }
  ...
});

// product.json
{
  "id" : 1,
  "Name" : "Product 1",
  "Description": "Product 1 Description",
  "Quantity" : 10,
  "Price" : 9.99
}

Ext.define('BizDash.model.Locations', {
  extend: 'Ext.data.Model',
  ...
  proxy: {
    type : 'ajax',
    url : 'location.json',
    reader: {
      type: 'json'
    }
  }
  ...
});

// location.json
[
  {
    "id" : 1,
    "Name" : "Location 1",
    "Row" : 20,
    "Shelf": 10
  },
  {
    "id" : 2,
    "Name" : "Location 2",
    "Row" : 11,
    "Shelf": 22
  }
]</pre></div></div><div class="section" title="Defining the association"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec34"/>Defining the association</h3></div></div></div><p>The <a id="id233" class="indexterm"/>simplest way to define this relationship is to add the <code class="literal">manyToMany</code> config option to the models on both sides of the association (Product and Location) and by providing the name of the model that should be on the other side:</p><div class="informalexample"><pre class="programlisting">Ext.define('BizDash.model.Product', {
  extend: 'Ext.data.Model',
  ...
  manyToMany: [
    'Location'
  ]
  ...
});

Ext.define('BizDash.model.Location', {
  extend: 'Ext.data.Model',
  ...
  manyToMany: [
    'Product'
  ]
  ...
});</pre></div></div><div class="section" title="Loading the associated data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec35"/>Loading the associated data</h3></div></div></div><p>Like <a id="id234" class="indexterm"/>the one-to-many association, by defining this link, Ext JS will generate new methods called <code class="literal">locations</code> and <code class="literal">products</code> in the Product and Location models respectively. These methods will return an <code class="literal">Ext.data.Store</code> instance and will contain our associated data:</p><div class="informalexample"><pre class="programlisting">BizDash.model.Product.load(1, {
  success: function(productRecord) {
    productRecord.locations().load(function() {
      console.log(productRecord.locations().getCount()); // 2
    });
  }
});</pre></div><p>From a Location record, the related Products can be loaded in an identical way.</p></div></div></div>
<div class="section" title="Saving data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Saving data</h1></div></div></div><p>Now that we are able to load data successfully into our application, we can move on to persisting<a id="id235" class="indexterm"/> changes that we've made to this data within our client-side application. In most applications, when a change is made to a data store or record, we want to persist that change back to the data source, be it a server-side database or LocalStorage store. As mentioned previously, Ext JS provides us with the <code class="literal">Ext.data.writer.Writer</code> class (and its sub-classes) to manage the fields required to be written.</p><p>In its most simple and standard form, a store will save any changes made when the <code class="literal">sync</code> method is called, without any further additions to our <code class="literal">proxy</code> configuration.</p><p>If we continue with our users store example, we can update one of the <code class="literal">record</code> fields and then call the <code class="literal">sync</code> method:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').getAt(0).set('Email', 'john@hotmail.com');
Ext.getStore('Users').sync();</pre></div><p>If we inspect the <span class="strong"><strong>Network</strong></span> tab of our Developer Tools, we will see a <code class="literal">POST</code> request being made to our <code class="literal">users.json</code> file passing along the changed field and the record's ID:</p><div class="mediaobject"><img src="graphics/3717_05_06.jpg" alt="Saving data"/></div><p>Similarly, we can add or remove records and call the <code class="literal">sync</code> method and an equivalent <code class="literal">POST</code> request will be made:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').add({
  Name: 'Stuart',
  Email: 'stuart@gmail.com',
  Role: 'Customer',
  TelNumber: ' 0330 122 2800'
});
Ext.getStore('Users').sync();</pre></div><p>Here is the screenshot of the request that is made:</p><div class="mediaobject"><img src="graphics/3717_05_07.jpg" alt="Saving data"/></div><p>The preceding<a id="id236" class="indexterm"/> request, after a record has been added, shows all fields being sent as <code class="literal">POST</code> parameters:</p><div class="informalexample"><pre class="programlisting">Ext.getStore('Users').removeAt(0)
Ext.getStore('Users').sync();</pre></div><div class="mediaobject"><img src="graphics/3717_05_08.jpg" alt="Saving data"/></div><p>When a record is<a id="id237" class="indexterm"/> removed, the <code class="literal">id</code> field is POSTed to the server.</p><div class="section" title="CRUD endpoints"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>CRUD endpoints</h2></div></div></div><p>Obviously<a id="id238" class="indexterm"/> the preceding example is a little flawed, in that we are <a id="id239" class="indexterm"/>POSTing changes to a static JSON file. By default, Ext JS will send all changes to the URL specified in the proxy, regardless of whether they are adds, updates, or deletes. This is often undesirable when separate endpoints exist for each of these actions. We can easily configure our proxy to contact a different endpoint for each action using the <code class="literal">api</code> configuration property. Our <code class="literal">proxy</code> configuration could be rewritten as follows:</p><div class="informalexample"><pre class="programlisting">proxy: {
  type  : 'ajax',
  url   : 'users.json',
  api   : {
    create : 'user-add.php',
    read   : 'users.json',
    update : 'user-update.php',
    destroy: 'user-delete.php'
  },
  reader: {
    type        : 'json',
     rootProperty: 'rows'
  }
}</pre></div><p>If we rerun the add, update, and delete actions, we will see calls being made to each of the PHP files specified in our <code class="literal">api</code> configuration.</p></div><div class="section" title="Data writers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Data writers</h2></div></div></div><p>Data <a id="id240" class="indexterm"/>writers allow us to control how a store's data is constructed for sending out to be saved and give us a variety of options to customize this process. By default, a proxy will use a JSON writer (<code class="literal">Ext.data.writer.Json</code>), which will result in the to-be-saved data being encoded as a JSON string. Alternatively, the XML writer (<code class="literal">Ext.data.writer.Writer</code>) could be used, which would transfer data as XML.</p><p>To define a writer, we use the <code class="literal">writer</code> config of the proxy and give it its own configuration object. The <code class="literal">type</code> property determines which writer class is used—either JSON or XML.</p><p>We can configure our users store to use a JSON writer, as follows:</p><div class="informalexample"><pre class="programlisting">proxy: {
  ...
  writer: {
    type: 'json'
  }
}</pre></div><p>We'll now take a look at a couple of the configuration options the writer class offers to allow us to customize how and what data is sent to the server.</p><p>In our previous update example, we saw the edited field (in this case the <code class="literal">Email</code> field) being sent, along with the record's ID, to the server. Sometimes, we will want to send all the fields to the server regardless of whether they have been edited or not. We can do this easily with the <code class="literal">writeAllFields</code> config as demonstrated here:</p><div class="informalexample"><pre class="programlisting">proxy: {
  ...   writer: {
    type: 'json',
    writeAllFields: true
  }
}</pre></div><p>Here is the screenshot of this update request:</p><div class="mediaobject"><img src="graphics/3717_05_09.jpg" alt="Data writers"/></div><p>On occasion, you<a id="id241" class="indexterm"/> might want to do some additional processing on a dataset before it is sent up to the server. We can define this extra processing step by using the <code class="literal">transform</code> config, giving it a function to execute during the writing process. This function will accept the <code class="literal">data</code> object that will be sent and should return the processed <code class="literal">data</code> object. The following example shows how we can ensure that the given e-mail address is always in lowercase:</p><div class="informalexample"><pre class="programlisting">proxy: {
  ...
  writer: {
    type : 'json',
    writeAllFields: true,
    transform : {
      fn: function(data, request) {
        data.Email = data.Email.toLowerCase();
        return data;
      }
    }
  }
}</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Summary</h1></div></div></div><p>Throughout this chapter, we have explored the details of how to model our application's data structure with Ext JS. We have covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining models</li><li class="listitem" style="list-style-type: disc">Loading and saving data to server and LocalStorage</li><li class="listitem" style="list-style-type: disc">Defining relationships between models through associations</li><li class="listitem" style="list-style-type: disc">How to work with data within data stores</li></ul></div><p>We will make use of all of these lessons throughout the rest of the book as our example application comes to life and we start to integrate data sources and data visualizations to it.</p></div></body></html>