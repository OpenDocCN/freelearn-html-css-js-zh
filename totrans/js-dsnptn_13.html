<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor272" class="pcalibre1 calibre6 pcalibre"/>10</h1>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor273" class="pcalibre1 calibre6 pcalibre"/>Asset Loading Strategies and Executing Code off the Main Thread</h1>
<p class="calibre3">There are situations in the life cycle of an application where loading more JavaScript is inevitable. This chapter details techniques to mitigate the impact of such situations. You’ll learn about asset loading optimizations such as a script element’s <code>async</code>, the <code>defer</code> attribute, the impact of <code>type="module"</code>, and the link element’s <code>rel</code> (relationship) attribute’s <code>preconnect</code>, <code>preload</code>, and <code>prefetch</code> values. Next, you will further optimize script loading using Next.js’ <code>Script</code> component and its different options. The chapter wraps up with an exploration of reasons to execute JavaScript code off the main thread and an approach to do so.</p>
<p class="calibre3">In this chapter, we’ll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">How to control asset loading more granularly with a script’s <strong class="source-inline1">async</strong> and <strong class="source-inline1">defer</strong> attributes, and links with <strong class="source-inline1">preconnect</strong>, <strong class="source-inline1">preload</strong>, and <strong class="source-inline1">prefetch</strong></li>
<li class="calibre11">Further optimization opportunities in Next.js using the <strong class="source-inline1">Script</strong> component and its <strong class="source-inline1">strategy</strong> prop</li>
<li class="calibre11">When and how to run code off the main thread via Next.js and Partytown</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll have the skills to exert more control over asset loading and JavaScript loading and execution in a web context.</p>
<h1 id="_idParaDest-150" class="calibre5"><a id="_idTextAnchor274" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-151" class="calibre5"><a id="_idTextAnchor275" class="pcalibre1 calibre6 pcalibre"/>Asset loading optimization – async, defer, preconnect, preload, and prefetch</h1>
<p class="calibre3">When using <code>script</code> to load and execute JavaScript, there are HTML attributes of <code>script</code> we can use to control the loading and execution.</p>
<p class="calibre3">We can rely on the<a id="_idIndexMarker589" class="pcalibre1 calibre6 pcalibre"/> difference between external scripts and inline <a id="_idIndexMarker590" class="pcalibre1 calibre6 pcalibre"/>scripts; we can also use the <code>async</code>, <code>defer</code>, and <code>type="module"</code> attributes.</p>
<p class="calibre3">We’ll start by defining external and inline scripts, then the <code>async</code> and <code>defer</code> attributes. Finally, we’ll look at <code>type="module"</code> attribute.</p>
<p class="calibre3">External scripts use the <code>src</code> attribute to point to a separate JavaScript file; for example, what follows is an external script that will load and evaluate <code>./script.js</code> when it’s encountered:</p>
<p class="source-code1" lang="en-US" xml:lang="en-US"><strong class="source-inline1">&lt;script src="img/script.js"&gt;&lt;/script&gt;</strong></p>
<p class="calibre3">Contrast this with inline scripts, where there is no <code>src</code> attribute; instead, the JavaScript code is in the <code>script</code> tag contents:</p>
<pre class="source-code">
&lt;script&gt;
  console.log('inline script');
&lt;/script&gt;</pre> <p class="calibre3">The default load/execution cycle of scripts is what we call <code>script</code> tag’s JavaScript to complete execution.</p>
<p class="calibre3">The <code>async</code> and <code>defer</code> attributes on the <code>script</code> HTML tag can change the behavior of loading and executing scripts.</p>
<p class="calibre3">Adding <code>async</code> to a script will mean it’s fetched while the rest of the HTML document is parsed. An <code>async</code> script will be evaluated as soon as it’s loaded. This is a large change to the default document parsing behavior of <code>script</code>.</p>
<p class="calibre3">Say we have an <code>async.js</code> file that inserts a paragraph with the text <code>async.js: async </code><code>script executed</code>:</p>
<pre class="source-code">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'async.js: async script executed';
  document.body.appendChild(node);
})();</pre> <p class="calibre3">Say we also have a <code>script.js</code> file that <a id="_idIndexMarker591" class="pcalibre1 calibre6 pcalibre"/>also inserts a paragraph with <code>script.js: blocking </code><code>script executed</code>:</p>
<pre class="source-code">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'script.js: blocking script executed';
  document.body.appendChild(node);
})();</pre> <p class="calibre3">Finally, say we have a document that has inline script snippets that also add paragraphs to track their execution before and after two additional <code>script</code> tags. One script loads <code>async.js</code> with an <code>async</code> attribute on the script, and the second script loads the <code>script.js</code> element using the default render-blocking load:</p>
<pre class="source-code">
&lt;script&gt;
  (() =&gt; {
    const node = document.createElement('p');
    node.innerText = 'inline: script 1 executed';
    document.body.appendChild(node);
  })();
&lt;/script&gt;
&lt;script src="img/async.js" async&gt;&lt;/script&gt;
&lt;script src="img/script.js"&gt;&lt;/script&gt;
&lt;script&gt;
  (() =&gt; {
    const node = document.createElement('p');
    node.innerText = 'inline: script 2 executed';
    document.body.appendChild(node);
  })();
&lt;/script&gt;</pre> <p class="calibre3">This is displayed as follows in<a id="_idIndexMarker592" class="pcalibre1 calibre6 pcalibre"/> a browser when loaded with an empty cache: the inline script 1 executes first, then <code>script.js</code>, then inline script 2, and finally <code>async.js</code>. Note how <code>async.js</code> was in the document <em class="italic">before</em> <code>script.js</code> but executed after; that’s the effect of the <code>async</code> attribute:</p>
<div><div><img alt="Figure 10.1: Inline scripts, external script, and external script with async execution order" src="img/B19109_10_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.1: Inline scripts, external script, and external script with async execution order</p>
<p class="calibre3">Next, we’ll see how <code>defer</code> affects<a id="_idIndexMarker593" class="pcalibre1 calibre6 pcalibre"/> the loading of a script.</p>
<p class="calibre3"><code>defer</code> indicates to the browser that the script should only be loaded <em class="italic">after</em> the document has been parsed. However, the <code>DOMContentLoaded</code> event will not fire until all scripts with the <code>defer</code> attribute are loaded and executed.</p>
<p class="calibre3">Say we add a <code>defer.js</code> file that will insert a paragraph with <code>defer.js: defer script executed</code>, as shown in the following code block:</p>
<pre class="source-code">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'defer.js: defer script executed';
  document.body.appendChild(node);
})();</pre> <p class="calibre3">Next, we extend the HTML document from the previous <code>async</code> example by adding <code>&lt;script src="img/defer.js" defer&gt;&lt;/script&gt;</code> before <code>&lt;script src="img/async.js" async&gt;&lt;/script&gt;</code>. This will look as follows:</p>
<pre class="source-code">
&lt;!-- no change to inline script 1 --&gt;
&lt;script src="img/defer.js" defer&gt;&lt;/script&gt;
&lt;script src="img/async.js" async&gt;&lt;/script&gt;
&lt;script src="img/script.js"&gt;&lt;/script&gt;
&lt;!-- no change to inline script 2 --&gt;</pre> <p class="calibre3">When we load this document in a browser, we see the following output where the deferred script adds its paragraph <a id="_idIndexMarker594" class="pcalibre1 calibre6 pcalibre"/>after all the other ones despite being <em class="italic">before</em> the <code>async.js</code>, <code>script.js</code>, and inline script 2 in the parse order of the document.</p>
<div><div><img alt="Figure 10.2: Inline scripts, external script, external script with async, and external script with the defer execution order" src="img/B19109_10_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.2: Inline scripts, external script, external script with async, and external script with the defer execution order</p>
<p class="calibre3">Next, we’ll see how “module” and “classic” scripts are affected differently by <code>async</code> and <code>defer</code>.</p>
<p class="calibre3">When a script receives the type of attribute with the <code>module</code> value, that script will get interpreted as a JavaScript module. We’ll call these “module” scripts, as opposed to “classic” scripts, which don’t <a id="_idIndexMarker595" class="pcalibre1 calibre6 pcalibre"/>have a type of attribute.</p>
<p class="calibre3"><code>type="module"</code> defers the execution of the script. This means that “module” scripts aren’t affected by the <code>defer</code> attribute (since that behavior is applied to their execution by default).</p>
<p class="calibre3">The <code>async</code> attribute overall has a <a id="_idIndexMarker596" class="pcalibre1 calibre6 pcalibre"/>similar effect on “module” scripts as it does on “classic” scripts, in that the script will be loaded in parallel to document parsing and executed once loading has been completed.</p>
<p class="calibre3">One additional effect of the <code>async</code> attribute on “module” scripts is that since JavaScript modules have syntax to denote dependency loading, the module script itself, and once loaded, all the dependencies it loads via the <code>import</code> syntax, will be loaded in parallel to the document parsing.</p>
<p class="calibre3">Say we have the following <code>module.js</code>, which inserts <code>module.js: type="module" executed</code> when it runs:</p>
<pre class="source-code">
const node = document.createElement('p');
node.innerText = 'module.js: type="module" executed';
document.body.appendChild(node);</pre> <p class="calibre3">Say we also have the following <code>module-async.js</code>, which inserts <code>module-async.js: type="module" async executed</code> when it runs:</p>
<pre class="source-code">
const node = document.createElement('p');
node.innerText = 'module-async.js: type="module"
  async executed';
document.body.appendChild(node);</pre> <p class="calibre3">We add script tags with <code>type="module"</code> with an inline module that inserts <code>inline: type="module" executed</code>, and module scripts referencing <code>module.js</code> and <code>module-async.js</code>:</p>
<pre class="source-code">
&lt;!-- no change to inline scripts --&gt;
&lt;script type="module"&gt;
  const node = document.createElement('p');
  node.innerText = 'inline: type="module" executed';
  document.body.appendChild(node);
&lt;/script&gt;
&lt;script src="img/module-async.js" type="module" async&gt;
  &lt;/script&gt;
&lt;script src="img/module.js" type="module"&gt;&lt;/script&gt;
&lt;!-- no change to existing external scripts --&gt;</pre> <p class="calibre3">When we load this document in the<a id="_idIndexMarker597" class="pcalibre1 calibre6 pcalibre"/> browser, we see the following. This illustrates that the default load/execution of <code>type="module"</code> is deferred since even the inline module script executes after <code>async</code> scripts. One point of interest is that <code>async</code> on module scripts can make it execute earlier than scripts without <code>async</code>. This makes <a id="_idIndexMarker598" class="pcalibre1 calibre6 pcalibre"/>sense since <code>async</code> means there’s parallel loading and execution is “as soon as available,” as opposed to the module script’s default execution method, which is <code>defer</code>:</p>
<div><div><img alt="Figure 10.3: Inline scripts, external script, external script with async, external script with the defer execution order, inline module script, and external module scripts with async and without" src="img/B19109_10_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.3: Inline scripts, external script, external script with async, external script with the defer execution order, inline module script, and external module scripts with async and without</p>
<p class="calibre3">We’ve now contrasted different characteristics of script load/execution: inline versus external, the impact of <code>async</code> and <code>defer</code> attributes, and classic versus module. The following diagram recapitulates the execution order:</p>
<div><div><img alt="Figure 10.4: Script load/execute order versus browser document parsing" src="img/B19109_10_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.4: Script load/execute order versus browser document parsing</p>
<p class="calibre3">We’ve now seen how<a id="_idIndexMarker599" class="pcalibre1 calibre6 pcalibre"/> to improve page performance by adapting <a id="_idIndexMarker600" class="pcalibre1 calibre6 pcalibre"/>how JavaScript is loaded and executed. Next, we’ll learn how to use resource hints to improve page performance.</p>
<p class="calibre3">Resource hints, per the HTML specification, allow consumers to preemptively complete an operation. They’re used as <code>rel</code> values on link elements. The values relevant to our use case are <code>preconnect</code>, <code>prefetch</code>, and <code>preload</code>.</p>
<p class="calibre3"><code>preconnect</code>’s definition per the<a id="_idIndexMarker601" class="pcalibre1 calibre6 pcalibre"/> HTML standard is as follows:</p>
<p class="calibre3">“<code>preconnect</code>: Specifies that the user agent should preemptively connect to the target resource’s origin”, HTML standard – 4.6.7 link types: <a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre">https://html.spec.whatwg.org/#linkTypes</a></p>
<p class="calibre3">In summary, <code>preconnect</code> allows <a id="_idIndexMarker602" class="pcalibre1 calibre6 pcalibre"/>developers to “tell” browsers to create a connection to an origin, enabling subsequent requests to the origin to occur faster, especially in an HTTP/2 context where more requests can be done in parallel (via multiplexing) and connections are efficiently reused.</p>
<pre>link</strong> element:</pre>
<pre class="source-code">
&lt;head&gt;
  &lt;link rel="preconnect" href="https://example.com" /&gt;
&lt;/head&gt;</pre> <p class="calibre3">Next, <code>preload</code>’s definition <a id="_idIndexMarker603" class="pcalibre1 calibre6 pcalibre"/>per the HTML specification is as follows:</p>
<p class="calibre3">“<code>preload</code>: Specifies that the user agent must preemptively fetch and cache the target resource for current navigation according to the potential destination given by the as attribute (and the priority associated with the corresponding destination).” HTML standard – 4.6.7 link types: <a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre">https://html.spec.whatwg.org/#linkTypes</a></p>
<p class="calibre3"><code>preload</code> can be used to load resources before they’re detected on the page. This can be especially useful in single-page applications or other highly dynamic JavaScript-driven contexts where resources might not be in the initial returned HTML payload, but we know which resources might be necessary.</p>
<p class="calibre3">Note that <code>preload</code> requires a fully qualified resource path (e.g., <a href="https://example.com/assets/resource-1.js" class="pcalibre1 calibre6 pcalibre">https://example.com/assets/resource-1.js</a>), as opposed to <code>preconnect</code>, which uses the origin only. Also, note that <code>preload</code> is not designed for use on module scripts; for that, we need <code>rel="modulepreload"</code>, which is defined as follows in the HTML standard specification:</p>
<p class="calibre3">“<code>modulepreload</code>: Specifies that the user agent must preemptively fetch the module script and store it in the document’s module map for later evaluation. Optionally, the module’s dependencies can be fetched as well.” HTML standard – 4.6.7 link types: <a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre">https://html.spec.whatwg.org/#linkTypes</a></p>
<p class="calibre3">In our current example, we could request pre-loading of some of our <code>async</code> resources ahead of time (before they’re “seen” by the browser in the HTML), where our resource loading looks <a id="_idIndexMarker604" class="pcalibre1 calibre6 pcalibre"/>as follows by default. The load order is defined by the order of the script tags in the HTML element and the priority for all resources is <code>Normal</code>:</p>
<div><div><img alt="Figure 10.5: Page load including the Network tab without any preload" src="img/B19109_10_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.5: Page load including the Network tab without any preload</p>
<p class="calibre3">To illustrate preload, we can add a <code>preload</code> link for <code>async.js</code> and a <code>modulepreload</code> link for <code>module-async.js</code> inside the HTML <code>head</code> element like in the following snippet:</p>
<pre class="source-code">
&lt;head&gt;
  &lt;link rel="preload" href="async.js" as="script" /&gt;
  &lt;link rel="modulepreload" href="module-async.js"
    as="script" /&gt;
&lt;/head&gt;</pre> <p class="calibre3">If we reload our example<a id="_idIndexMarker605" class="pcalibre1 calibre6 pcalibre"/> page, we’ll see that <code>async.js</code> and <code>module-async.js</code> are now loaded with <code>Highest</code> priority, and before the rest of the scripts on the page. Also note that due to the <code>async</code> attribute being loaded earlier, the scripts are executed earlier.</p>
<div><div><img alt="Figure 10.6: Page load including Network tab with async.js having preload and module-async.js having modulepreload" src="img/B19109_10_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.6: Page load including Network tab with async.js having preload and module-async.js having modulepreload</p>
<p class="calibre3">Finally, <code>prefetch</code> is defined <a id="_idIndexMarker606" class="pcalibre1 calibre6 pcalibre"/>as follows in the HTML specification:</p>
<p class="calibre3">“<code>prefetch</code>: Specifies that the user agent should preemptively fetch and cache the target resource as it is likely to be required for a follow-up navigation” HTML standard – 4.6.7 link types: <a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre">https://html.spec.whatwg.org/#linkTypes</a></p>
<p class="calibre3">This means that <code>prefetch</code> will not only connect (like <code>preconnect</code> does), but do a full load and cache cycle. <code>prefetch</code> is useful for when resources will be necessary on the next load as opposed to for the current page (which is where <code>preload</code> and <code>modulepreload</code> should be used).</p>
<p class="calibre3">We’ve now seen how to optimize asset loading via the <code>async</code> and <code>defer</code> attributes on <code>script</code> elements and via <code>preconnect</code>, <code>preload</code>, and <code>prefetch</code> on <code>link</code> elements. Next, we’ll look<a id="_idIndexMarker607" class="pcalibre1 calibre6 pcalibre"/> at how the Next.js <code>Script</code> component’s <code>strategy</code> can be used to achieve similar results in a Next.js <a id="_idTextAnchor276" class="pcalibre1 calibre6 pcalibre"/>application.</p>
<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor277" class="pcalibre1 calibre6 pcalibre"/>Using Next.js Script’s strategy option to optimize asset loading</h1>
<p class="calibre3">The Next.js <code>Script</code> component <a id="_idIndexMarker608" class="pcalibre1 calibre6 pcalibre"/>gives us more control over script loading behavior, allowing us to improve page load performance.</p>
<p class="calibre3">The <code>strategy</code> prop allows <a id="_idIndexMarker609" class="pcalibre1 calibre6 pcalibre"/>us to control the loading strategy; it defaults to <code>afterInteractive</code>, which will begin loading after some of the Next.js code has run. It can be set to <code>beforeInteractive</code>, in which case the script is loaded and executed before all Next.js code. <code>lazyOnLoad</code> can be used for lower-priority scripts to delay loading until there’s browser idle time.</p>
<p class="calibre3">The final option is experimental; it’s the <code>worker</code> strategy, which will load and run the script in a web worker.</p>
<p class="calibre3">Per the Next.js docs for the <code>Script#strategy</code> option, the following list contains the loading strategies of the script (see the docs: <a href="https://nextjs.org/docs/pages/api-reference/components/script#strategy" class="pcalibre1 calibre6 pcalibre">https://nextjs.org/docs/pages/api-reference/components/script#strategy</a>).</p>
<p class="calibre3">There are four different strategies that can be used:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">beforeInteractive</strong>: Load before any Next.js code and before any page hydration occurs</li>
<li class="calibre11"><strong class="source-inline1">afterInteractive</strong> (default): Load early but after some hydration on the page occurs</li>
<li class="calibre11"><strong class="source-inline1">lazyOnload</strong>: Load during browser idle time</li>
<li class="calibre11"><strong class="source-inline1">worker</strong> (experimental): Load in a web worker</li>
</ul>
<p class="calibre3">One of the benefits of the <code>Script</code> component over the <code>script</code> native element is that the loading strategy can be used even on inline scripts. For example, say we have a <code>pages/index.js</code> page in a Next.js application; we add some <code>Script</code> components with two approaches to <a id="_idIndexMarker610" class="pcalibre1 calibre6 pcalibre"/>adding inline scripts. We set the latter <code>Script</code> to use <code>beforeInteractive</code>, remembering<a id="_idIndexMarker611" class="pcalibre1 calibre6 pcalibre"/> that the default strategy is <code>afterInteractive</code>:</p>
<pre class="source-code">
import React from 'react';
import Script from 'next/script';
export default function Index() {
  return (
    &lt;&gt;
      &lt;h1&gt;Next.js Script Strategy&lt;/h1&gt;
      &lt;Script&gt;{`console.log('inline script 1');`}&lt;/Script&gt;
      &lt;Script
        strategy="beforeInteractive"
        dangerouslySetInnerHTML={{
          __html: `console.log('inline script 2');`,
        }}
      &gt;&lt;/Script&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we run the Next.js server with <code>npx next dev</code> or <code>npx next build &amp;&amp; npx next start</code>, we see that <code>inline script 2</code> is printed in the console before <code>inline script 1</code> is; this is the <code>Script</code> strategies being applied:</p>
<div><div><img alt="Figure 10.7: Second inline Script logging to the console before the first due to the strategy of each Script" src="img/B19109_10_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.7: Second inline Script logging to the console before the first due to the strategy of each Script</p>
<p class="calibre3">We’ll now showcase<a id="_idIndexMarker612" class="pcalibre1 calibre6 pcalibre"/> how we can use the loading strategy with external scripts.</p>
<p class="calibre3">Say we have <code>public/afterInteractive.js</code>, which contains the following:</p>
<p class="source-code1" lang="en-US" xml:lang="en-US"><strong class="source-inline1">console.log('afterInteractive.js: loaded');</strong></p>
<p class="calibre3">Similarly, <code>public/beforeInteractive.js</code> and <code>public/lazyOnload.js</code> contain a <code>console.log</code> function call with the relevant content, <code>beforeInteractive.js: loaded</code> and <code>lazyOnload.js: </code><code>loaded</code> respectively.</p>
<p class="calibre3">We can load them using the following changes to <code>pages/index.js</code>; note that we’ve put them in a rough “reverse” order of loading to showcase the effect of <code>strategy</code>:</p>
<pre class="source-code">
import React from 'react';
import Script from 'next/script';
export default function Index() {
  return (
    &lt;&gt;
      {/* no change to h1 or inline script 1 */}
      &lt;Script src="img/lazyOnload.js" strategy="lazyOnload" /&gt;
      &lt;Script src="img/afterInteractive.js" strategy=\
        "afterInteractive" /&gt;
      &lt;Script src="img/beforeInteractive.js" strategy=
        "beforeInteractive" /&gt;
      {/* no change to inline script 2 */}
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we run the Next.js <a id="_idIndexMarker613" class="pcalibre1 calibre6 pcalibre"/>server with <code>npx next dev</code> or <code>npx next build &amp;&amp; npx next start</code>, we see that <code>beforeInteractive</code> is printed on the console before <code>afterInteractive</code>, which is <a id="_idIndexMarker614" class="pcalibre1 calibre6 pcalibre"/>printed before <code>lazyOnLoad</code>:</p>
<div><div><img alt="Figure 10.8: Script’s logging in order based on strategy" src="img/B19109_10_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.8: Script’s logging in order based on strategy</p>
<p class="calibre3">We’ve now seen how Next.js <code>Script</code> and its <code>strategy</code> prop allow us to control script asset loading in a Next.js context to achieve additional page load performance. Next, we’ll cover how to run scripts in<a id="_idTextAnchor278" class="pcalibre1 calibre6 pcalibre"/> a worker thread.</p>
<h1 id="_idParaDest-153" class="calibre5"><a id="_idTextAnchor279" class="pcalibre1 calibre6 pcalibre"/>Loading and running scripts in a worker thread</h1>
<p class="calibre3">One of the Next.js <code>Script</code> strategy options is <code>worker</code>, which loads and runs the script in a web worker. In current Next.js versions, this is achieved via a library called <strong class="bold">Partytown</strong> (<a href="https://partytown.builder.io/" class="pcalibre1 calibre6 pcalibre">https://partytown.builder.io/</a>). The<a id="_idIndexMarker615" class="pcalibre1 calibre6 pcalibre"/> following is from the Partytown documentation:</p>
<p class="calibre3">“Partytown is a lazy-loaded library <a id="_idIndexMarker616" class="pcalibre1 calibre6 pcalibre"/>to help relocate resource-intensive scripts into a web worker, and off of the main thread. Its goal is to help speed up sites by dedicating the main thread to your code, and offloading third-party scripts to a web worker.” Partytown home page – <a href="https://partytown.builder.io/" class="pcalibre1 calibre6 pcalibre">https://partytown.builder.io/</a></p>
<p class="calibre3">To expand on that definition, JavaScript runs in a single-threaded environment in the browser. “Single-threaded” means we only have one entity able to execute compute operations; non-asynchronous work cannot be done in parallel. The main thread in this context is the browser’s JavaScript execution thread. When loading and executing compute-heavy <a id="_idIndexMarker617" class="pcalibre1 calibre6 pcalibre"/>scripts, they can starve other scripts of the execution environment. By running said compute-heavy scripts in a web worker, it gets a different JavaScript environment or execution thread, meaning the main thread is freed up to service the rest of the JavaScript execution.</p>
<p class="calibre3">Since <code>strategy="worker"</code> for Next.js <code>Script</code> is experimental, in order to use it, we need to enable it in <code>next.config.js</code> like so:</p>
<pre class="source-code">
const nextConfig = {
  // no change necessary to other config fields
  experimental: {
    nextScriptWorkers: true,
  },
};
module.exports = nextConfig;</pre> <p class="calibre3">When running <code>npx run dev</code>, you’ll see a warning about the <code>nextScriptWorkers</code> experimental feature in the terminal in which you’re running the command:</p>
<pre class="console">
▲ Next.js 13.5.4
- Local:        http://localhost:3000
- Experiments (use at your own risk):
    · nextScriptWorkers
✓ Ready in 2.4s</pre> <p class="calibre3">To illustrate how we can use <code>strategy="worker"</code> powered by Partytown, we can write an <code>analytics.js</code> script that <a id="_idIndexMarker618" class="pcalibre1 calibre6 pcalibre"/>will log on, load, and make an API call to <code>jsonplaceholder</code> with some information about the page. We store <code>analytics.js</code> in <code>public/analytics.js</code> to simulate a third-party script being loaded (or more generally, a <a id="_idIndexMarker619" class="pcalibre1 calibre6 pcalibre"/>dependency that cannot be bundled, i.e., one we can’t import into our application code):</p>
<pre class="source-code">
console.log('analytics.js: loaded');
async function trackPageLoad() {
  const responseJson = await fetch(
    'https://jsonplaceholder.typicode.com/posts',
    {
      method: 'POST',
      body: JSON.stringify({
        page: window.location.pathname,
        origin: window.location.origin,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    },
  ).then((response) =&gt; response.json());
  console.log('analytics.js: page load fetch response',
    responseJson);
}
trackPageLoad();</pre> <p class="calibre3">We can then create a new <code>pages/worker.js</code> file in our Next.js application, which renders a heading and a few <a id="_idIndexMarker620" class="pcalibre1 calibre6 pcalibre"/>Next.js scripts, including <code>/analytics.js</code>. The other scripts are to <a id="_idIndexMarker621" class="pcalibre1 calibre6 pcalibre"/>illustrate the load order of the <code>worker</code> strategy versus alternative strategy values:</p>
<pre class="source-code">
import React from 'react';
import Script from 'next/script';
export default function Worker() {
  return (
    &lt;&gt;
      &lt;h1&gt;Next.js Script "worker" experimental
         Strategy&lt;/h1&gt;
      &lt;Script src="img/analytics.js" strategy="worker" /&gt;
      &lt;Script src="img/lazyOnload.js" strategy="lazyOnload" /&gt;
      &lt;Script src="img/afterInteractive.js" strategy=
        "afterInteractive" /&gt;
      &lt;Script src="img/beforeInteractive.js" strategy=
        "beforeInteractive" /&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">When we load <code>npx next build &amp;&amp; npx next start</code>, the production server starts, and with the <code>strategy="worker"</code> loads after all <a id="_idIndexMarker622" class="pcalibre1 calibre6 pcalibre"/>the other strategies. We also see that the <code>fetch()</code> call to <code>jsonplaceholder</code> completed successfully:</p>
<div><div><img alt="Figure 10.9: worker strategy loading after other strategies and fetch call response logging" src="img/B19109_10_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.9: worker strategy loading after other strategies and fetch call response logging</p>
<p class="calibre3">Another aspect of loading via the <code>worker</code> strategy is that <code>analytics.js</code> is not loaded as a script; it’s loaded<a id="_idIndexMarker623" class="pcalibre1 calibre6 pcalibre"/> via <code>fetch</code>. This can be seen by inspecting the <code>XMLHttpRequest</code>, the precursor to <code>fetch</code>) and inspecting the <code>jsonplaceholder</code> request appears here (as two requests, an <code>OPTIONS</code> request to ensure we can make the cross-origin request followed by the <code>POST</code> request).</p>
<div><div><img alt="Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder" src="img/B19109_10_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder</p>
<p class="calibre3">If we dig into the <code>analytics.js</code> request <a id="_idIndexMarker624" class="pcalibre1 calibre6 pcalibre"/>further, we’ll see<a id="_idIndexMarker625" class="pcalibre1 calibre6 pcalibre"/> that the <code>Referer</code> header value (which helps us keep track of the source of the request) is <code>_next/static/~partytown/partytown-sandbox-sw.html</code>, which is a Partytown-generated document.</p>
<div><div><img alt="Figure 10.11: analytics.js Referer is the Partytown service worker-generated HTML file" src="img/B19109_10_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 10.11: analytics.js Referer is the Partytown service worker-generated HTML file</p>
<p class="calibre3">In short, using <code>strategy="worker"</code> loads and executes our script in a different JavaScript context to the main <a id="_idIndexMarker626" class="pcalibre1 calibre6 pcalibre"/>window, although Partytown is designed so that it should have a high level <a id="_idIndexMarker627" class="pcalibre1 calibre6 pcalibre"/>of similarity with the origin window.</p>
<p class="calibre3">We’ve now seen how to use <code>strategy="worker"</code> and Partytown to execute scripts off the main thre<a id="_idTextAnchor280" class="pcalibre1 calibre6 pcalibre"/>ad in a web worker context.</p>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor281" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve covered techniques to control asset and JavaScript loading more granularly.</p>
<p class="calibre3">In order to control script loading using browser built-in functionality, we can use <code>async</code> and <code>defer</code> attributes; we covered their effect on module scripts versus classic scripts. We also looked at using the <code>rel</code> attribute on a <code>link</code> element for resource hints, and what impact <code>preconnect</code>, <code>preload</code>, <code>modulepreload</code>, and <code>prefetch</code> have on resource loading.</p>
<p class="calibre3">We can leverage the Next.js <code>Script</code> component’s <code>strategy</code> prop to control script loading and execution beyond <code>async</code> and <code>defer</code> in the context of a Next.js application.</p>
<p class="calibre3">Finally, we looked at the possibility of running certain scripts off the main JavaScript thread using the Next.js <code>Script</code> <code>worker</code> strategy, powered by the Partytown library.</p>
<p class="calibre3">In this final chapter, we covered asset loading strategies and optimizations such as executing code off the main thread.</p>
<p class="calibre3">This brings us to the end of this book. Hopefully, you’ve achieved a better understanding of design patterns in JavaScript and how to implement them. You will be able to discuss and contrast implementations and the usefulness of language-agnostic patterns that fall into the creational, structural, and behavioral design pattern categories. In addition, you should be confident with JavaScript-specific patterns that will help you scale your applications, reactive view library patterns, rendering strategies, and asynchronous and event-driven programming patterns in JavaScript. Furthermore, you are now familiar with performance and architecture patterns relevant to JavaScript such as micro frontends, lazy-loading, code-splitting, and further asset loading optimizations.</p>
<p class="calibre3">Of course, all these patterns are meant to be used and you will discover new ways to compose them and even notice them in places you didn’t expect. The JavaScript and web platform space is ever-evolving, and I hope this book stands you in good stead for using more of its great features.</p>
</div>
</body></html>