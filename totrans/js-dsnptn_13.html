<html><head></head><body>
<div id="_idContainer127" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor272" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor273" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Asset Loading Strategies and Executing Code off the Main Thread</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">There are situations in the life cycle of an application where loading more JavaScript is inevitable. </span><span class="kobospan" id="kobo.3.2">This chapter details techniques to mitigate the impact of such situations. </span><span class="kobospan" id="kobo.3.3">You’ll learn about asset loading optimizations such as a script element’s </span><strong class="source-inline"><span class="kobospan" id="kobo.4.1">async</span></strong><span class="kobospan" id="kobo.5.1">, the </span><strong class="source-inline"><span class="kobospan" id="kobo.6.1">defer</span></strong><span class="kobospan" id="kobo.7.1"> attribute, the impact of </span><strong class="source-inline"><span class="kobospan" id="kobo.8.1">type="module"</span></strong><span class="kobospan" id="kobo.9.1">, and the link element’s </span><strong class="source-inline"><span class="kobospan" id="kobo.10.1">rel</span></strong><span class="kobospan" id="kobo.11.1"> (relationship) attribute’s </span><strong class="source-inline"><span class="kobospan" id="kobo.12.1">preconnect</span></strong><span class="kobospan" id="kobo.13.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.14.1">preload</span></strong><span class="kobospan" id="kobo.15.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.16.1">prefetch</span></strong><span class="kobospan" id="kobo.17.1"> values. </span><span class="kobospan" id="kobo.17.2">Next, you will further optimize script loading using Next.js’ </span><strong class="source-inline"><span class="kobospan" id="kobo.18.1">Script</span></strong><span class="kobospan" id="kobo.19.1"> component and its different options. </span><span class="kobospan" id="kobo.19.2">The chapter wraps up with an exploration of reasons to execute JavaScript code off the main thread and an approach to </span><span><span class="kobospan" id="kobo.20.1">do so.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">In this chapter, we’ll cover the </span><span><span class="kobospan" id="kobo.22.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.23.1">How to control asset loading more granularly with a script’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.24.1">async</span></strong><span class="kobospan" id="kobo.25.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.26.1">defer</span></strong><span class="kobospan" id="kobo.27.1"> attributes, and links with </span><strong class="source-inline1"><span class="kobospan" id="kobo.28.1">preconnect</span></strong><span class="kobospan" id="kobo.29.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.30.1">preload</span></strong><span class="kobospan" id="kobo.31.1">, </span><span><span class="kobospan" id="kobo.32.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.33.1">prefetch</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.34.1">Further optimization opportunities in Next.js using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.35.1">Script</span></strong><span class="kobospan" id="kobo.36.1"> component and its </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.37.1">strategy</span></strong></span><span><span class="kobospan" id="kobo.38.1"> prop</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.39.1">When and how to run code off the main thread via Next.js </span><span><span class="kobospan" id="kobo.40.1">and Partytown</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">By the end of this chapter, you’ll have the skills to exert more control over asset loading and JavaScript loading and execution in a </span><span><span class="kobospan" id="kobo.42.1">web context.</span></span></p>
<h1 id="_idParaDest-150" class="calibre5"><a id="_idTextAnchor274" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.43.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.44.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.45.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.46.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-151" class="calibre5"><a id="_idTextAnchor275" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.47.1">Asset loading optimization – async, defer, preconnect, preload, and prefetch</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">When using </span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">script</span></strong><span class="kobospan" id="kobo.50.1"> to load and execute JavaScript, there are HTML attributes of </span><strong class="source-inline"><span class="kobospan" id="kobo.51.1">script</span></strong><span class="kobospan" id="kobo.52.1"> we can use to control the loading </span><span><span class="kobospan" id="kobo.53.1">and execution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">We can rely on the</span><a id="_idIndexMarker589" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.55.1"> difference between external scripts and inline </span><a id="_idIndexMarker590" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.56.1">scripts; we can also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.57.1">async</span></strong><span class="kobospan" id="kobo.58.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">defer</span></strong><span class="kobospan" id="kobo.60.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.61.1">type="module"</span></strong></span><span><span class="kobospan" id="kobo.62.1"> attributes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">We’ll start by defining external and inline scripts, then the </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">async</span></strong><span class="kobospan" id="kobo.65.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.66.1">defer</span></strong><span class="kobospan" id="kobo.67.1"> attributes. </span><span class="kobospan" id="kobo.67.2">Finally, we’ll look at </span><strong class="bold"><span class="kobospan" id="kobo.68.1">classic</span></strong><span class="kobospan" id="kobo.69.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.70.1">module</span></strong><span class="kobospan" id="kobo.71.1"> scripts via the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.72.1">type="module"</span></strong></span><span><span class="kobospan" id="kobo.73.1"> attribute.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">External scripts use the </span><strong class="source-inline"><span class="kobospan" id="kobo.75.1">src</span></strong><span class="kobospan" id="kobo.76.1"> attribute to point to a separate JavaScript file; for example, what follows is an external script that will load and evaluate </span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">./script.js</span></strong><span class="kobospan" id="kobo.78.1"> when </span><span><span class="kobospan" id="kobo.79.1">it’s encountered:</span></span></p>
<p class="source-code1" lang="en-US" xml:lang="en-US"><strong class="source-inline1"><span class="kobospan" id="kobo.80.1">&lt;script src="./script.js"&gt;&lt;/script&gt;</span></strong></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">Contrast this with inline scripts, where there is no </span><strong class="source-inline"><span class="kobospan" id="kobo.82.1">src</span></strong><span class="kobospan" id="kobo.83.1"> attribute; instead, the JavaScript code is in the </span><strong class="source-inline"><span class="kobospan" id="kobo.84.1">script</span></strong> <span><span class="kobospan" id="kobo.85.1">tag contents:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.86.1">
&lt;script&gt;
  console.log('inline script');
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.87.1">The default load/execution cycle of scripts is what we call </span><strong class="bold"><span class="kobospan" id="kobo.88.1">blocking</span></strong><span class="kobospan" id="kobo.89.1">. </span><span class="kobospan" id="kobo.89.2">The evaluation of the HTML document will wait for the </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">script</span></strong><span class="kobospan" id="kobo.91.1"> tag’s JavaScript to </span><span><span class="kobospan" id="kobo.92.1">complete execution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">async</span></strong><span class="kobospan" id="kobo.95.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">defer</span></strong><span class="kobospan" id="kobo.97.1"> attributes on the </span><strong class="source-inline"><span class="kobospan" id="kobo.98.1">script</span></strong><span class="kobospan" id="kobo.99.1"> HTML tag can change the behavior of loading and </span><span><span class="kobospan" id="kobo.100.1">executing scripts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">Adding </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">async</span></strong><span class="kobospan" id="kobo.103.1"> to a script will mean it’s fetched while the rest of the HTML document is parsed. </span><span class="kobospan" id="kobo.103.2">An </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">async</span></strong><span class="kobospan" id="kobo.105.1"> script will be evaluated as soon as it’s loaded. </span><span class="kobospan" id="kobo.105.2">This is a large change to the default document parsing behavior </span><span><span class="kobospan" id="kobo.106.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">script</span></strong></span><span><span class="kobospan" id="kobo.108.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">Say we have an </span><strong class="source-inline"><span class="kobospan" id="kobo.110.1">async.js</span></strong><span class="kobospan" id="kobo.111.1"> file that inserts a paragraph with the text </span><strong class="source-inline"><span class="kobospan" id="kobo.112.1">async.js: async </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">script executed</span></strong></span><span><span class="kobospan" id="kobo.114.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.115.1">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'async.js: async script executed';
  document.body.appendChild(node);
})();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.116.1">Say we also have a </span><strong class="source-inline"><span class="kobospan" id="kobo.117.1">script.js</span></strong><span class="kobospan" id="kobo.118.1"> file that </span><a id="_idIndexMarker591" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.119.1">also inserts a paragraph with </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">script.js: blocking </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.121.1">script executed</span></strong></span><span><span class="kobospan" id="kobo.122.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.123.1">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'script.js: blocking script executed';
  document.body.appendChild(node);
})();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.124.1">Finally, say we have a document that has inline script snippets that also add paragraphs to track their execution before and after two additional </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">script</span></strong><span class="kobospan" id="kobo.126.1"> tags. </span><span class="kobospan" id="kobo.126.2">One script loads </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">async.js</span></strong><span class="kobospan" id="kobo.128.1"> with an </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">async</span></strong><span class="kobospan" id="kobo.130.1"> attribute on the script, and the second script loads the </span><strong class="source-inline"><span class="kobospan" id="kobo.131.1">script.js</span></strong><span class="kobospan" id="kobo.132.1"> element using the default </span><span><span class="kobospan" id="kobo.133.1">render-blocking load:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.134.1">
&lt;script&gt;
  (() =&gt; {
    const node = document.createElement('p');
    node.innerText = 'inline: script 1 executed';
    document.body.appendChild(node);
  })();
&lt;/script&gt;
&lt;script src="./async.js" async&gt;&lt;/script&gt;
&lt;script src="./script.js"&gt;&lt;/script&gt;
&lt;script&gt;
  (() =&gt; {
    const node = document.createElement('p');
    node.innerText = 'inline: script 2 executed';
    document.body.appendChild(node);
  })();
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.135.1">This is displayed as follows in</span><a id="_idIndexMarker592" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.136.1"> a browser when loaded with an empty cache: the inline script 1 executes first, then </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">script.js</span></strong><span class="kobospan" id="kobo.138.1">, then inline script 2, and finally </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">async.js</span></strong><span class="kobospan" id="kobo.140.1">. </span><span class="kobospan" id="kobo.140.2">Note how </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">async.js</span></strong><span class="kobospan" id="kobo.142.1"> was in the document </span><em class="italic"><span class="kobospan" id="kobo.143.1">before</span></em> <strong class="source-inline"><span class="kobospan" id="kobo.144.1">script.js</span></strong><span class="kobospan" id="kobo.145.1"> but executed after; that’s the effect of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">async</span></strong></span><span><span class="kobospan" id="kobo.147.1"> attribute:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer116">
<span class="kobospan" id="kobo.148.1"><img alt="Figure 10.1: Inline scripts, external script, and external script with async execution order" src="image/B19109_10_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.149.1">Figure 10.1: Inline scripts, external script, and external script with async execution order</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.150.1">Next, we’ll see how </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">defer</span></strong><span class="kobospan" id="kobo.152.1"> affects</span><a id="_idIndexMarker593" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.153.1"> the loading of </span><span><span class="kobospan" id="kobo.154.1">a script.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.155.1">defer</span></strong><span class="kobospan" id="kobo.156.1"> indicates to the browser that the script should only be loaded </span><em class="italic"><span class="kobospan" id="kobo.157.1">after</span></em><span class="kobospan" id="kobo.158.1"> the document has been parsed. </span><span class="kobospan" id="kobo.158.2">However, the </span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">DOMContentLoaded</span></strong><span class="kobospan" id="kobo.160.1"> event will not fire until all scripts with the </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">defer</span></strong><span class="kobospan" id="kobo.162.1"> attribute are loaded </span><span><span class="kobospan" id="kobo.163.1">and executed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">Say we add a </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">defer.js</span></strong><span class="kobospan" id="kobo.166.1"> file that will insert a paragraph with </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">defer.js: defer script executed</span></strong><span class="kobospan" id="kobo.168.1">, as shown in the following </span><span><span class="kobospan" id="kobo.169.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.170.1">
(() =&gt; {
  const node = document.createElement('p');
  node.innerText = 'defer.js: defer script executed';
  document.body.appendChild(node);
})();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.171.1">Next, we extend the HTML document from the previous </span><strong class="source-inline"><span class="kobospan" id="kobo.172.1">async</span></strong><span class="kobospan" id="kobo.173.1"> example by adding </span><strong class="source-inline"><span class="kobospan" id="kobo.174.1">&lt;script src="./defer.js" defer&gt;&lt;/script&gt;</span></strong><span class="kobospan" id="kobo.175.1"> before </span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">&lt;script src="./async.js" async&gt;&lt;/script&gt;</span></strong><span class="kobospan" id="kobo.177.1">. </span><span class="kobospan" id="kobo.177.2">This will look </span><span><span class="kobospan" id="kobo.178.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.179.1">
&lt;!-- no change to inline script 1 --&gt;
&lt;script src="./defer.js" defer&gt;&lt;/script&gt;
&lt;script src="./async.js" async&gt;&lt;/script&gt;
&lt;script src="./script.js"&gt;&lt;/script&gt;
&lt;!-- no change to inline script 2 --&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.180.1">When we load this document in a browser, we see the following output where the deferred script adds its paragraph </span><a id="_idIndexMarker594" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.181.1">after all the other ones despite being </span><em class="italic"><span class="kobospan" id="kobo.182.1">before</span></em><span class="kobospan" id="kobo.183.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">async.js</span></strong><span class="kobospan" id="kobo.185.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">script.js</span></strong><span class="kobospan" id="kobo.187.1">, and inline script 2 in the parse order of </span><span><span class="kobospan" id="kobo.188.1">the document.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer117">
<span class="kobospan" id="kobo.189.1"><img alt="Figure 10.2: Inline scripts, external script, external script with async, and external script with the defer execution order" src="image/B19109_10_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.190.1">Figure 10.2: Inline scripts, external script, external script with async, and external script with the defer execution order</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.191.1">Next, we’ll see how “module” and “classic” scripts are affected differently by </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">async</span></strong> <span><span class="kobospan" id="kobo.193.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">defer</span></strong></span><span><span class="kobospan" id="kobo.195.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.196.1">When a script receives the type of attribute with the </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">module</span></strong><span class="kobospan" id="kobo.198.1"> value, that script will get interpreted as a JavaScript module. </span><span class="kobospan" id="kobo.198.2">We’ll call these “module” scripts, as opposed to “classic” scripts, which don’t </span><a id="_idIndexMarker595" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.199.1">have a type </span><span><span class="kobospan" id="kobo.200.1">of attribute.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.201.1">type="module"</span></strong><span class="kobospan" id="kobo.202.1"> defers the execution of the script. </span><span class="kobospan" id="kobo.202.2">This means that “module” scripts aren’t affected by the </span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">defer</span></strong><span class="kobospan" id="kobo.204.1"> attribute (since that behavior is applied to their execution </span><span><span class="kobospan" id="kobo.205.1">by default).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.207.1">async</span></strong><span class="kobospan" id="kobo.208.1"> attribute overall has a </span><a id="_idIndexMarker596" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.209.1">similar effect on “module” scripts as it does on “classic” scripts, in that the script will be loaded in parallel to document parsing and executed once loading has </span><span><span class="kobospan" id="kobo.210.1">been completed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">One additional effect of the </span><strong class="source-inline"><span class="kobospan" id="kobo.212.1">async</span></strong><span class="kobospan" id="kobo.213.1"> attribute on “module” scripts is that since JavaScript modules have syntax to denote dependency loading, the module script itself, and once loaded, all the dependencies it loads via the </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">import</span></strong><span class="kobospan" id="kobo.215.1"> syntax, will be loaded in parallel to the </span><span><span class="kobospan" id="kobo.216.1">document parsing.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">Say we have the following </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">module.js</span></strong><span class="kobospan" id="kobo.219.1">, which inserts </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">module.js: type="module" executed</span></strong><span class="kobospan" id="kobo.221.1"> when </span><span><span class="kobospan" id="kobo.222.1">it runs:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.223.1">
const node = document.createElement('p');
node.innerText = 'module.js: type="module" executed';
document.body.appendChild(node);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.224.1">Say we also have the following </span><strong class="source-inline"><span class="kobospan" id="kobo.225.1">module-async.js</span></strong><span class="kobospan" id="kobo.226.1">, which inserts </span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">module-async.js: type="module" async executed</span></strong><span class="kobospan" id="kobo.228.1"> when </span><span><span class="kobospan" id="kobo.229.1">it runs:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.230.1">
const node = document.createElement('p');
node.innerText = 'module-async.js: type="module"
  async executed';
document.body.appendChild(node);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.231.1">We add script tags with </span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">type="module"</span></strong><span class="kobospan" id="kobo.233.1"> with an inline module that inserts </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">inline: type="module" executed</span></strong><span class="kobospan" id="kobo.235.1">, and module scripts referencing </span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">module.js</span></strong> <span><span class="kobospan" id="kobo.237.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.238.1">module-async.js</span></strong></span><span><span class="kobospan" id="kobo.239.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.240.1">
&lt;!-- no change to inline scripts --&gt;
&lt;script type="module"&gt;
  const node = document.createElement('p');
  node.innerText = 'inline: type="module" executed';
  document.body.appendChild(node);
&lt;/script&gt;
&lt;script src="./module-async.js" type="module" async&gt;
  &lt;/script&gt;
&lt;script src="./module.js" type="module"&gt;&lt;/script&gt;
&lt;!-- no change to existing external scripts --&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.241.1">When we load this document in the</span><a id="_idIndexMarker597" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.242.1"> browser, we see the following. </span><span class="kobospan" id="kobo.242.2">This illustrates that the default load/execution of </span><strong class="source-inline"><span class="kobospan" id="kobo.243.1">type="module"</span></strong><span class="kobospan" id="kobo.244.1"> is deferred since even the inline module script executes after </span><strong class="source-inline"><span class="kobospan" id="kobo.245.1">async</span></strong><span class="kobospan" id="kobo.246.1"> scripts. </span><span class="kobospan" id="kobo.246.2">One point of interest is that </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">async</span></strong><span class="kobospan" id="kobo.248.1"> on module scripts can make it execute earlier than scripts without </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">async</span></strong><span class="kobospan" id="kobo.250.1">. </span><span class="kobospan" id="kobo.250.2">This makes </span><a id="_idIndexMarker598" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.251.1">sense since </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">async</span></strong><span class="kobospan" id="kobo.253.1"> means there’s parallel loading and execution is “as soon as available,” as opposed to the module script’s default execution method, which </span><span><span class="kobospan" id="kobo.254.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.255.1">defer</span></strong></span><span><span class="kobospan" id="kobo.256.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer118">
<span class="kobospan" id="kobo.257.1"><img alt="Figure 10.3: Inline scripts, external script, external script with async, external script with the defer execution order, inline module script, and external module scripts with async and without" src="image/B19109_10_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.258.1">Figure 10.3: Inline scripts, external script, external script with async, external script with the defer execution order, inline module script, and external module scripts with async and without</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.259.1">We’ve now contrasted different characteristics of script load/execution: inline versus external, the impact of </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">async</span></strong><span class="kobospan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">defer</span></strong><span class="kobospan" id="kobo.263.1"> attributes, and classic versus module. </span><span class="kobospan" id="kobo.263.2">The following diagram recapitulates the </span><span><span class="kobospan" id="kobo.264.1">execution order:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer119">
<span class="kobospan" id="kobo.265.1"><img alt="Figure 10.4: Script load/execute order versus browser document parsing" src="image/B19109_10_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.266.1">Figure 10.4: Script load/execute order versus browser document parsing</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.267.1">We’ve now seen how</span><a id="_idIndexMarker599" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.268.1"> to improve page performance by adapting </span><a id="_idIndexMarker600" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.269.1">how JavaScript is loaded and executed. </span><span class="kobospan" id="kobo.269.2">Next, we’ll learn how to use resource hints to improve </span><span><span class="kobospan" id="kobo.270.1">page performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.271.1">Resource hints, per the HTML specification, allow consumers to preemptively complete an operation. </span><span class="kobospan" id="kobo.271.2">They’re used as </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">rel</span></strong><span class="kobospan" id="kobo.273.1"> values on link elements. </span><span class="kobospan" id="kobo.273.2">The values relevant to our use case are </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">preconnect</span></strong><span class="kobospan" id="kobo.275.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">prefetch</span></strong><span class="kobospan" id="kobo.277.1">, </span><span><span class="kobospan" id="kobo.278.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">preload</span></strong></span><span><span class="kobospan" id="kobo.280.1">.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.281.1">preconnect</span></strong><span class="kobospan" id="kobo.282.1">’s definition per the</span><a id="_idIndexMarker601" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.283.1"> HTML standard is </span><span><span class="kobospan" id="kobo.284.1">as follows:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.285.1">“</span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">preconnect</span></strong><span class="kobospan" id="kobo.287.1">: Specifies that the user agent should preemptively connect to the target resource’s origin”, HTML standard – 4.6.7 link </span><span><span class="kobospan" id="kobo.288.1">types: </span></span><a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.289.1">https://html.spec.whatwg.org/#linkTypes</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.290.1">In summary, </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">preconnect</span></strong><span class="kobospan" id="kobo.292.1"> allows </span><a id="_idIndexMarker602" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.293.1">developers to “tell” browsers to create a connection to an origin, enabling subsequent requests to the origin to occur faster, especially in an HTTP/2 context where more requests can be done in parallel (via multiplexing) and connections are </span><span><span class="kobospan" id="kobo.294.1">efficiently reused.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.295.1">For example, we can preconnect to </span><a href="https://example.com" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.296.1">https://example.com</span></a><span class="kobospan" id="kobo.297.1"> using the following snippet of code which contains </span><span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">link</span></strong></span><span><span class="kobospan" id="kobo.299.1"> element:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.300.1">
&lt;head&gt;
  &lt;link rel="preconnect" href="https://example.com" /&gt;
&lt;/head&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.301.1">Next, </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">preload</span></strong><span class="kobospan" id="kobo.303.1">’s definition </span><a id="_idIndexMarker603" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.304.1">per the HTML specification is </span><span><span class="kobospan" id="kobo.305.1">as follows:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">“</span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">preload</span></strong><span class="kobospan" id="kobo.308.1">: Specifies that the user agent must preemptively fetch and cache the target resource for current navigation according to the potential destination given by the as attribute (and the priority associated with the corresponding destination).” </span><span class="kobospan" id="kobo.308.2">HTML standard – 4.6.7 link </span><span><span class="kobospan" id="kobo.309.1">types: </span></span><a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.310.1">https://html.spec.whatwg.org/#linkTypes</span></span></a></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.311.1">preload</span></strong><span class="kobospan" id="kobo.312.1"> can be used to load resources before they’re detected on the page. </span><span class="kobospan" id="kobo.312.2">This can be especially useful in single-page applications or other highly dynamic JavaScript-driven contexts where resources might not be in the initial returned HTML payload, but we know which resources might </span><span><span class="kobospan" id="kobo.313.1">be necessary.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">Note that </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">preload</span></strong><span class="kobospan" id="kobo.316.1"> requires a fully qualified resource path (e.g., </span><a href="https://example.com/assets/resource-1.js" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.317.1">https://example.com/assets/resource-1.js</span></a><span class="kobospan" id="kobo.318.1">), as opposed to </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">preconnect</span></strong><span class="kobospan" id="kobo.320.1">, which uses the origin only. </span><span class="kobospan" id="kobo.320.2">Also, note that </span><strong class="source-inline"><span class="kobospan" id="kobo.321.1">preload</span></strong><span class="kobospan" id="kobo.322.1"> is not designed for use on module scripts; for that, we need </span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">rel="modulepreload"</span></strong><span class="kobospan" id="kobo.324.1">, which is defined as follows in the HTML </span><span><span class="kobospan" id="kobo.325.1">standard specification:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.326.1">“</span><strong class="source-inline"><span class="kobospan" id="kobo.327.1">modulepreload</span></strong><span class="kobospan" id="kobo.328.1">: Specifies that the user agent must preemptively fetch the module script and store it in the document’s module map for later evaluation. </span><span class="kobospan" id="kobo.328.2">Optionally, the module’s dependencies can be fetched as well.” </span><span class="kobospan" id="kobo.328.3">HTML standard – 4.6.7 link </span><span><span class="kobospan" id="kobo.329.1">types: </span></span><a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.330.1">https://html.spec.whatwg.org/#linkTypes</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.331.1">In our current example, we could request pre-loading of some of our </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">async</span></strong><span class="kobospan" id="kobo.333.1"> resources ahead of time (before they’re “seen” by the browser in the HTML), where our resource loading looks </span><a id="_idIndexMarker604" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.334.1">as follows by default. </span><span class="kobospan" id="kobo.334.2">The load order is defined by the order of the script tags in the HTML element and the priority for all resources </span><span><span class="kobospan" id="kobo.335.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.336.1">Normal</span></strong></span><span><span class="kobospan" id="kobo.337.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer120">
<span class="kobospan" id="kobo.338.1"><img alt="Figure 10.5: Page load including the Network tab without any preload" src="image/B19109_10_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.339.1">Figure 10.5: Page load including the Network tab without any preload</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.340.1">To illustrate preload, we can add a </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">preload</span></strong><span class="kobospan" id="kobo.342.1"> link for </span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">async.js</span></strong><span class="kobospan" id="kobo.344.1"> and a </span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">modulepreload</span></strong><span class="kobospan" id="kobo.346.1"> link for </span><strong class="source-inline"><span class="kobospan" id="kobo.347.1">module-async.js</span></strong><span class="kobospan" id="kobo.348.1"> inside the HTML </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">head</span></strong><span class="kobospan" id="kobo.350.1"> element like in the </span><span><span class="kobospan" id="kobo.351.1">following snippet:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.352.1">
&lt;head&gt;
  &lt;link rel="preload" href="async.js" as="script" /&gt;
  &lt;link rel="modulepreload" href="module-async.js"
    as="script" /&gt;
&lt;/head&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.353.1">If we reload our example</span><a id="_idIndexMarker605" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.354.1"> page, we’ll see that </span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">async.js</span></strong><span class="kobospan" id="kobo.356.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">module-async.js</span></strong><span class="kobospan" id="kobo.358.1"> are now loaded with </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">Highest</span></strong><span class="kobospan" id="kobo.360.1"> priority, and before the rest of the scripts on the page. </span><span class="kobospan" id="kobo.360.2">Also note that due to the </span><strong class="source-inline"><span class="kobospan" id="kobo.361.1">async</span></strong><span class="kobospan" id="kobo.362.1"> attribute being loaded earlier, the scripts are </span><span><span class="kobospan" id="kobo.363.1">executed earlier.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer121">
<span class="kobospan" id="kobo.364.1"><img alt="Figure 10.6: Page load including Network tab with async.js having preload and module-async.js having modulepreload" src="image/B19109_10_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.365.1">Figure 10.6: Page load including Network tab with async.js having preload and module-async.js having modulepreload</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">Finally, </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">prefetch</span></strong><span class="kobospan" id="kobo.368.1"> is defined </span><a id="_idIndexMarker606" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.369.1">as follows in the </span><span><span class="kobospan" id="kobo.370.1">HTML specification:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">“</span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">prefetch</span></strong><span class="kobospan" id="kobo.373.1">: Specifies that the user agent should preemptively fetch and cache the target resource as it is likely to be required for a follow-up navigation” HTML standard – 4.6.7 link </span><span><span class="kobospan" id="kobo.374.1">types: </span></span><a href="https://html.spec.whatwg.org/#linkTypes" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.375.1">https://html.spec.whatwg.org/#linkTypes</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.376.1">This means that </span><strong class="source-inline"><span class="kobospan" id="kobo.377.1">prefetch</span></strong><span class="kobospan" id="kobo.378.1"> will not only connect (like </span><strong class="source-inline"><span class="kobospan" id="kobo.379.1">preconnect</span></strong><span class="kobospan" id="kobo.380.1"> does), but do a full load and cache cycle. </span><strong class="source-inline"><span class="kobospan" id="kobo.381.1">prefetch</span></strong><span class="kobospan" id="kobo.382.1"> is useful for when resources will be necessary on the next load as opposed to for the current page (which is where </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">preload</span></strong><span class="kobospan" id="kobo.384.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">modulepreload</span></strong><span class="kobospan" id="kobo.386.1"> should </span><span><span class="kobospan" id="kobo.387.1">be used).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.388.1">We’ve now seen how to optimize asset loading via the </span><strong class="source-inline"><span class="kobospan" id="kobo.389.1">async</span></strong><span class="kobospan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.391.1">defer</span></strong><span class="kobospan" id="kobo.392.1"> attributes on </span><strong class="source-inline"><span class="kobospan" id="kobo.393.1">script</span></strong><span class="kobospan" id="kobo.394.1"> elements and via </span><strong class="source-inline"><span class="kobospan" id="kobo.395.1">preconnect</span></strong><span class="kobospan" id="kobo.396.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">preload</span></strong><span class="kobospan" id="kobo.398.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">prefetch</span></strong><span class="kobospan" id="kobo.400.1"> on </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">link</span></strong><span class="kobospan" id="kobo.402.1"> elements. </span><span class="kobospan" id="kobo.402.2">Next, we’ll look</span><a id="_idIndexMarker607" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.403.1"> at how the Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">Script</span></strong><span class="kobospan" id="kobo.405.1"> component’s </span><strong class="source-inline"><span class="kobospan" id="kobo.406.1">strategy</span></strong><span class="kobospan" id="kobo.407.1"> can be used to achieve similar results in a </span><span><span class="kobospan" id="kobo.408.1">Next.js </span><a id="_idTextAnchor276" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.409.1">application.</span></span></p>
<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor277" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.410.1">Using Next.js Script’s strategy option to optimize asset loading</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.411.1">The Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">Script</span></strong><span class="kobospan" id="kobo.413.1"> component </span><a id="_idIndexMarker608" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.414.1">gives us more control over script loading behavior, allowing us to improve page </span><span><span class="kobospan" id="kobo.415.1">load performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.416.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.417.1">strategy</span></strong><span class="kobospan" id="kobo.418.1"> prop allows </span><a id="_idIndexMarker609" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.419.1">us to control the loading strategy; it defaults to </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">afterInteractive</span></strong><span class="kobospan" id="kobo.421.1">, which will begin loading after some of the Next.js code has run. </span><span class="kobospan" id="kobo.421.2">It can be set to </span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">beforeInteractive</span></strong><span class="kobospan" id="kobo.423.1">, in which case the script is loaded and executed before all Next.js code. </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">lazyOnLoad</span></strong><span class="kobospan" id="kobo.425.1"> can be used for lower-priority scripts to delay loading until there’s browser </span><span><span class="kobospan" id="kobo.426.1">idle time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">The final option is experimental; it’s the </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">worker</span></strong><span class="kobospan" id="kobo.429.1"> strategy, which will load and run the script in a </span><span><span class="kobospan" id="kobo.430.1">web worker.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">Per the Next.js docs for the </span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">Script#strategy</span></strong><span class="kobospan" id="kobo.433.1"> option, the following list contains the loading strategies of the script (see the </span><span><span class="kobospan" id="kobo.434.1">docs: </span></span><a href="https://nextjs.org/docs/pages/api-reference/components/script#strategy" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.435.1">https://nextjs.org/docs/pages/api-reference/components/script#strategy</span></span></a><span><span class="kobospan" id="kobo.436.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.437.1">There are four different strategies that can </span><span><span class="kobospan" id="kobo.438.1">be used:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.439.1">beforeInteractive</span></strong><span class="kobospan" id="kobo.440.1">: Load before any Next.js code and before any page </span><span><span class="kobospan" id="kobo.441.1">hydration occurs</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.442.1">afterInteractive</span></strong><span class="kobospan" id="kobo.443.1"> (default): Load early but after some hydration on the </span><span><span class="kobospan" id="kobo.444.1">page occurs</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.445.1">lazyOnload</span></strong><span class="kobospan" id="kobo.446.1">: Load during browser </span><span><span class="kobospan" id="kobo.447.1">idle time</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">worker</span></strong><span class="kobospan" id="kobo.449.1"> (experimental): Load in a </span><span><span class="kobospan" id="kobo.450.1">web worker</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.451.1">One of the benefits of the </span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">Script</span></strong><span class="kobospan" id="kobo.453.1"> component over the </span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">script</span></strong><span class="kobospan" id="kobo.455.1"> native element is that the loading strategy can be used even on inline scripts. </span><span class="kobospan" id="kobo.455.2">For example, say we have a </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">pages/index.js</span></strong><span class="kobospan" id="kobo.457.1"> page in a Next.js application; we add some </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">Script</span></strong><span class="kobospan" id="kobo.459.1"> components with two approaches to </span><a id="_idIndexMarker610" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.460.1">adding inline scripts. </span><span class="kobospan" id="kobo.460.2">We set the latter </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">Script</span></strong><span class="kobospan" id="kobo.462.1"> to use </span><strong class="source-inline"><span class="kobospan" id="kobo.463.1">beforeInteractive</span></strong><span class="kobospan" id="kobo.464.1">, remembering</span><a id="_idIndexMarker611" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.465.1"> that the default strategy </span><span><span class="kobospan" id="kobo.466.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.467.1">afterInteractive</span></strong></span><span><span class="kobospan" id="kobo.468.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.469.1">
import React from 'react';
import Script from 'next/script';
export default function Index() {
  return (
    &lt;&gt;
      &lt;h1&gt;Next.js Script Strategy&lt;/h1&gt;
      &lt;Script&gt;{`console.log('inline script 1');`}&lt;/Script&gt;
      &lt;Script
        strategy="beforeInteractive"
        dangerouslySetInnerHTML={{
          __html: `console.log('inline script 2');`,
        }}
      &gt;&lt;/Script&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.470.1">When we run the Next.js server with </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">npx next dev</span></strong><span class="kobospan" id="kobo.472.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">npx next build &amp;&amp; npx next start</span></strong><span class="kobospan" id="kobo.474.1">, we see that </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">inline script 2</span></strong><span class="kobospan" id="kobo.476.1"> is printed in the console before </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">inline script 1</span></strong><span class="kobospan" id="kobo.478.1"> is; this is the </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">Script</span></strong><span class="kobospan" id="kobo.480.1"> strategies </span><span><span class="kobospan" id="kobo.481.1">being applied:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer122">
<span class="kobospan" id="kobo.482.1"><img alt="Figure 10.7: Second inline Script logging to the console before the first due to the strategy of each Script" src="image/B19109_10_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.483.1">Figure 10.7: Second inline Script logging to the console before the first due to the strategy of each Script</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.484.1">We’ll now showcase</span><a id="_idIndexMarker612" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.485.1"> how we can use the loading strategy with </span><span><span class="kobospan" id="kobo.486.1">external scripts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.487.1">Say we have </span><strong class="source-inline"><span class="kobospan" id="kobo.488.1">public/afterInteractive.js</span></strong><span class="kobospan" id="kobo.489.1">, which contains </span><span><span class="kobospan" id="kobo.490.1">the following:</span></span></p>
<p class="source-code1" lang="en-US" xml:lang="en-US"><strong class="source-inline1"><span class="kobospan" id="kobo.491.1">console.log('afterInteractive.js: loaded');</span></strong></p>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">Similarly, </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">public/beforeInteractive.js</span></strong><span class="kobospan" id="kobo.494.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.495.1">public/lazyOnload.js</span></strong><span class="kobospan" id="kobo.496.1"> contain a </span><strong class="source-inline"><span class="kobospan" id="kobo.497.1">console.log</span></strong><span class="kobospan" id="kobo.498.1"> function call with the relevant content, </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">beforeInteractive.js: loaded</span></strong><span class="kobospan" id="kobo.500.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.501.1">lazyOnload.js: </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.502.1">loaded</span></strong></span><span><span class="kobospan" id="kobo.503.1"> respectively.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">We can load them using the following changes to </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">pages/index.js</span></strong><span class="kobospan" id="kobo.506.1">; note that we’ve put them in a rough “reverse” order of loading to showcase the effect </span><span><span class="kobospan" id="kobo.507.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.508.1">strategy</span></strong></span><span><span class="kobospan" id="kobo.509.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.510.1">
import React from 'react';
import Script from 'next/script';
export default function Index() {
  return (
    &lt;&gt;
      {/* no change to h1 or inline script 1 */}
      &lt;Script src="/lazyOnload.js" strategy="lazyOnload" /&gt;
      &lt;Script src="/afterInteractive.js" strategy=\
        "afterInteractive" /&gt;
      &lt;Script src="/beforeInteractive.js" strategy=
        "beforeInteractive" /&gt;
      {/* no change to inline script 2 */}
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.511.1">When we run the Next.js </span><a id="_idIndexMarker613" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.512.1">server with </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">npx next dev</span></strong><span class="kobospan" id="kobo.514.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">npx next build &amp;&amp; npx next start</span></strong><span class="kobospan" id="kobo.516.1">, we see that </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">beforeInteractive</span></strong><span class="kobospan" id="kobo.518.1"> is printed on the console before </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">afterInteractive</span></strong><span class="kobospan" id="kobo.520.1">, which is </span><a id="_idIndexMarker614" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.521.1">printed </span><span><span class="kobospan" id="kobo.522.1">before </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">lazyOnLoad</span></strong></span><span><span class="kobospan" id="kobo.524.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer123">
<span class="kobospan" id="kobo.525.1"><img alt="Figure 10.8: Script’s logging in order based on strategy" src="image/B19109_10_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.526.1">Figure 10.8: Script’s logging in order based on strategy</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">We’ve now seen how Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">Script</span></strong><span class="kobospan" id="kobo.529.1"> and its </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">strategy</span></strong><span class="kobospan" id="kobo.531.1"> prop allow us to control script asset loading in a Next.js context to achieve additional page load performance. </span><span class="kobospan" id="kobo.531.2">Next, we’ll cover how to run scripts in</span><a id="_idTextAnchor278" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.532.1"> a </span><span><span class="kobospan" id="kobo.533.1">worker thread.</span></span></p>
<h1 id="_idParaDest-153" class="calibre5"><a id="_idTextAnchor279" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.534.1">Loading and running scripts in a worker thread</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">One of the Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">Script</span></strong><span class="kobospan" id="kobo.537.1"> strategy options is </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">worker</span></strong><span class="kobospan" id="kobo.539.1">, which loads and runs the script in a web worker. </span><span class="kobospan" id="kobo.539.2">In current Next.js versions, this is achieved via a library called </span><strong class="bold"><span class="kobospan" id="kobo.540.1">Partytown</span></strong><span class="kobospan" id="kobo.541.1"> (</span><a href="https://partytown.builder.io/" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.542.1">https://partytown.builder.io/</span></a><span class="kobospan" id="kobo.543.1">). </span><span class="kobospan" id="kobo.543.2">The</span><a id="_idIndexMarker615" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.544.1"> following is from the </span><span><span class="kobospan" id="kobo.545.1">Partytown documentation:</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.546.1">“Partytown is a lazy-loaded library </span><a id="_idIndexMarker616" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.547.1">to help relocate resource-intensive scripts into a web worker, and off of the main thread. </span><span class="kobospan" id="kobo.547.2">Its goal is to help speed up sites by dedicating the main thread to your code, and offloading third-party scripts to a web worker.” </span><span class="kobospan" id="kobo.547.3">Partytown home page – </span><a href="https://partytown.builder.io/" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.548.1">https://partytown.builder.io/</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.549.1">To expand on that definition, JavaScript runs in a single-threaded environment in the browser. </span><span class="kobospan" id="kobo.549.2">“Single-threaded” means we only have one entity able to execute compute operations; non-asynchronous work cannot be done in parallel. </span><span class="kobospan" id="kobo.549.3">The main thread in this context is the browser’s JavaScript execution thread. </span><span class="kobospan" id="kobo.549.4">When loading and executing compute-heavy </span><a id="_idIndexMarker617" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.550.1">scripts, they can starve other scripts of the execution environment. </span><span class="kobospan" id="kobo.550.2">By running said compute-heavy scripts in a web worker, it gets a different JavaScript environment or execution thread, meaning the main thread is freed up to service the rest of the </span><span><span class="kobospan" id="kobo.551.1">JavaScript execution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.552.1">Since </span><strong class="source-inline"><span class="kobospan" id="kobo.553.1">strategy="worker"</span></strong><span class="kobospan" id="kobo.554.1"> for Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">Script</span></strong><span class="kobospan" id="kobo.556.1"> is experimental, in order to use it, we need to enable it in </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">next.config.js</span></strong> <span><span class="kobospan" id="kobo.558.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.559.1">
const nextConfig = {
  // no change necessary to other config fields
  experimental: {
    nextScriptWorkers: true,
  },
};
module.exports = nextConfig;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.560.1">When running </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">npx run dev</span></strong><span class="kobospan" id="kobo.562.1">, you’ll see a warning about the </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">nextScriptWorkers</span></strong><span class="kobospan" id="kobo.564.1"> experimental feature in the terminal in which you’re running </span><span><span class="kobospan" id="kobo.565.1">the command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.566.1">
▲ Next.js 13.5.4
- Local:        http://localhost:3000
- Experiments (use at your own risk):
    · nextScriptWorkers
✓ Ready in 2.4s</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.567.1">To illustrate how we can use </span><strong class="source-inline"><span class="kobospan" id="kobo.568.1">strategy="worker"</span></strong><span class="kobospan" id="kobo.569.1"> powered by Partytown, we can write an </span><strong class="source-inline"><span class="kobospan" id="kobo.570.1">analytics.js</span></strong><span class="kobospan" id="kobo.571.1"> script that </span><a id="_idIndexMarker618" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.572.1">will log on, load, and make an API call to </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">jsonplaceholder</span></strong><span class="kobospan" id="kobo.574.1"> with some information about the page. </span><span class="kobospan" id="kobo.574.2">We store </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">analytics.js</span></strong><span class="kobospan" id="kobo.576.1"> in </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">public/analytics.js</span></strong><span class="kobospan" id="kobo.578.1"> to simulate a third-party script being loaded (or more generally, a </span><a id="_idIndexMarker619" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.579.1">dependency that cannot be bundled, i.e., one we can’t import into our </span><span><span class="kobospan" id="kobo.580.1">application code):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.581.1">
console.log('analytics.js: loaded');
async function trackPageLoad() {
  const responseJson = await fetch(
    'https://jsonplaceholder.typicode.com/posts',
    {
      method: 'POST',
      body: JSON.stringify({
        page: window.location.pathname,
        origin: window.location.origin,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    },
  ).then((response) =&gt; response.json());
  console.log('analytics.js: page load fetch response',
    responseJson);
}
trackPageLoad();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.582.1">We can then create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.583.1">pages/worker.js</span></strong><span class="kobospan" id="kobo.584.1"> file in our Next.js application, which renders a heading and a few </span><a id="_idIndexMarker620" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.585.1">Next.js scripts, including </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">/analytics.js</span></strong><span class="kobospan" id="kobo.587.1">. </span><span class="kobospan" id="kobo.587.2">The other scripts are to </span><a id="_idIndexMarker621" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.588.1">illustrate the load order of the </span><strong class="source-inline"><span class="kobospan" id="kobo.589.1">worker</span></strong><span class="kobospan" id="kobo.590.1"> strategy versus alternative </span><span><span class="kobospan" id="kobo.591.1">strategy values:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.592.1">
import React from 'react';
import Script from 'next/script';
export default function Worker() {
  return (
    &lt;&gt;
      &lt;h1&gt;Next.js Script "worker" experimental
         Strategy&lt;/h1&gt;
      &lt;Script src="/analytics.js" strategy="worker" /&gt;
      &lt;Script src="/lazyOnload.js" strategy="lazyOnload" /&gt;
      &lt;Script src="/afterInteractive.js" strategy=
        "afterInteractive" /&gt;
      &lt;Script src="/beforeInteractive.js" strategy=
        "beforeInteractive" /&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.593.1">When we load </span><strong class="source-inline"><span class="kobospan" id="kobo.594.1">npx next build &amp;&amp; npx next start</span></strong><span class="kobospan" id="kobo.595.1">, the production server starts, and with the </span><strong class="bold"><span class="kobospan" id="kobo.596.1">Console</span></strong><span class="kobospan" id="kobo.597.1"> tab of DevTools open, we can see that </span><strong class="source-inline"><span class="kobospan" id="kobo.598.1">strategy="worker"</span></strong><span class="kobospan" id="kobo.599.1"> loads after all </span><a id="_idIndexMarker622" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.600.1">the other strategies. </span><span class="kobospan" id="kobo.600.2">We also see that the </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">fetch()</span></strong><span class="kobospan" id="kobo.602.1"> call to </span><strong class="source-inline"><span class="kobospan" id="kobo.603.1">jsonplaceholder</span></strong> <span><span class="kobospan" id="kobo.604.1">completed successfully:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer124">
<span class="kobospan" id="kobo.605.1"><img alt="Figure 10.9: worker strategy loading after other strategies and fetch call response logging" src="image/B19109_10_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.606.1">Figure 10.9: worker strategy loading after other strategies and fetch call response logging</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.607.1">Another aspect of loading via the </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">worker</span></strong><span class="kobospan" id="kobo.609.1"> strategy is that </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">analytics.js</span></strong><span class="kobospan" id="kobo.611.1"> is not loaded as a script; it’s loaded</span><a id="_idIndexMarker623" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.612.1"> via </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">fetch</span></strong><span class="kobospan" id="kobo.614.1">. </span><span class="kobospan" id="kobo.614.2">This can be seen by inspecting the </span><strong class="bold"><span class="kobospan" id="kobo.615.1">Network</span></strong><span class="kobospan" id="kobo.616.1"> tab in DevTools, filtering by </span><strong class="bold"><span class="kobospan" id="kobo.617.1">XHR</span></strong><span class="kobospan" id="kobo.618.1"> (</span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">XMLHttpRequest</span></strong><span class="kobospan" id="kobo.620.1">, the precursor to </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">fetch</span></strong><span class="kobospan" id="kobo.622.1">) and inspecting the </span><strong class="bold"><span class="kobospan" id="kobo.623.1">Initiator</span></strong><span class="kobospan" id="kobo.624.1"> field. </span><span class="kobospan" id="kobo.624.2">Note that the </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">jsonplaceholder</span></strong><span class="kobospan" id="kobo.626.1"> request appears here (as two requests, an </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">OPTIONS</span></strong><span class="kobospan" id="kobo.628.1"> request to ensure we can make the cross-origin request followed by the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">POST</span></strong></span><span><span class="kobospan" id="kobo.630.1"> request).</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer125">
<span class="kobospan" id="kobo.631.1"><img alt="Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder" src="image/B19109_10_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.632.1">Figure 10.10: analytics.js is loaded via fetch, as are requests to jsonplaceholder</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.633.1">If we dig into the </span><strong class="source-inline"><span class="kobospan" id="kobo.634.1">analytics.js</span></strong><span class="kobospan" id="kobo.635.1"> request </span><a id="_idIndexMarker624" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.636.1">further, we’ll see</span><a id="_idIndexMarker625" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.637.1"> that the </span><strong class="source-inline"><span class="kobospan" id="kobo.638.1">Referer</span></strong><span class="kobospan" id="kobo.639.1"> header value (which helps us keep track of the source of the request) is </span><strong class="source-inline"><span class="kobospan" id="kobo.640.1">_next/static/~partytown/partytown-sandbox-sw.html</span></strong><span class="kobospan" id="kobo.641.1">, which is a </span><span><span class="kobospan" id="kobo.642.1">Partytown-generated document.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer126">
<span class="kobospan" id="kobo.643.1"><img alt="Figure 10.11: analytics.js Referer is the Partytown service worker-generated HTML file" src="image/B19109_10_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.644.1">Figure 10.11: analytics.js Referer is the Partytown service worker-generated HTML file</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.645.1">In short, using </span><strong class="source-inline"><span class="kobospan" id="kobo.646.1">strategy="worker"</span></strong><span class="kobospan" id="kobo.647.1"> loads and executes our script in a different JavaScript context to the main </span><a id="_idIndexMarker626" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.648.1">window, although Partytown is designed so that it should have a high level </span><a id="_idIndexMarker627" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.649.1">of similarity with the </span><span><span class="kobospan" id="kobo.650.1">origin window.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.651.1">We’ve now seen how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">strategy="worker"</span></strong><span class="kobospan" id="kobo.653.1"> and Partytown to execute scripts off the main thre</span><a id="_idTextAnchor280" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.654.1">ad in a web </span><span><span class="kobospan" id="kobo.655.1">worker context.</span></span></p>
<h1 id="_idParaDest-154" class="calibre5"><a id="_idTextAnchor281" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.656.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.657.1">In this chapter, we’ve covered techniques to control asset and JavaScript loading </span><span><span class="kobospan" id="kobo.658.1">more granularly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">In order to control script loading using browser built-in functionality, we can use </span><strong class="source-inline"><span class="kobospan" id="kobo.660.1">async</span></strong><span class="kobospan" id="kobo.661.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.662.1">defer</span></strong><span class="kobospan" id="kobo.663.1"> attributes; we covered their effect on module scripts versus classic scripts. </span><span class="kobospan" id="kobo.663.2">We also looked at using the </span><strong class="source-inline"><span class="kobospan" id="kobo.664.1">rel</span></strong><span class="kobospan" id="kobo.665.1"> attribute on a </span><strong class="source-inline"><span class="kobospan" id="kobo.666.1">link</span></strong><span class="kobospan" id="kobo.667.1"> element for resource hints, and what impact </span><strong class="source-inline"><span class="kobospan" id="kobo.668.1">preconnect</span></strong><span class="kobospan" id="kobo.669.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.670.1">preload</span></strong><span class="kobospan" id="kobo.671.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.672.1">modulepreload</span></strong><span class="kobospan" id="kobo.673.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.674.1">prefetch</span></strong><span class="kobospan" id="kobo.675.1"> have on </span><span><span class="kobospan" id="kobo.676.1">resource loading.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">We can leverage the Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.678.1">Script</span></strong><span class="kobospan" id="kobo.679.1"> component’s </span><strong class="source-inline"><span class="kobospan" id="kobo.680.1">strategy</span></strong><span class="kobospan" id="kobo.681.1"> prop to control script loading and execution beyond </span><strong class="source-inline"><span class="kobospan" id="kobo.682.1">async</span></strong><span class="kobospan" id="kobo.683.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">defer</span></strong><span class="kobospan" id="kobo.685.1"> in the context of a </span><span><span class="kobospan" id="kobo.686.1">Next.js application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.687.1">Finally, we looked at the possibility of running certain scripts off the main JavaScript thread using the Next.js </span><strong class="source-inline"><span class="kobospan" id="kobo.688.1">Script</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.689.1">worker</span></strong><span class="kobospan" id="kobo.690.1"> strategy, powered by the </span><span><span class="kobospan" id="kobo.691.1">Partytown library.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.692.1">In this final chapter, we covered asset loading strategies and optimizations such as executing code off the </span><span><span class="kobospan" id="kobo.693.1">main thread.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.694.1">This brings us to the end of this book. </span><span class="kobospan" id="kobo.694.2">Hopefully, you’ve achieved a better understanding of design patterns in JavaScript and how to implement them. </span><span class="kobospan" id="kobo.694.3">You will be able to discuss and contrast implementations and the usefulness of language-agnostic patterns that fall into the creational, structural, and behavioral design pattern categories. </span><span class="kobospan" id="kobo.694.4">In addition, you should be confident with JavaScript-specific patterns that will help you scale your applications, reactive view library patterns, rendering strategies, and asynchronous and event-driven programming patterns in JavaScript. </span><span class="kobospan" id="kobo.694.5">Furthermore, you are now familiar with performance and architecture patterns relevant to JavaScript such as micro frontends, lazy-loading, code-splitting, and further asset </span><span><span class="kobospan" id="kobo.695.1">loading optimizations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.696.1">Of course, all these patterns are meant to be used and you will discover new ways to compose them and even notice them in places you didn’t expect. </span><span class="kobospan" id="kobo.696.2">The JavaScript and web platform space is ever-evolving, and I hope this book stands you in good stead for using more of its </span><span><span class="kobospan" id="kobo.697.1">great features.</span></span></p>
</div>
</body></html>