<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor070"/>4</h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Creating the Application</h1>
<p>The Space-Truckers application needs to be capable of maintaining and transitioning between a set of discrete states that correspond with different screens, such as a Menu screen and a Game screen. Transitions between application states typically occur as a result of user interaction (e.g., the user selects a menu item) or as part of something such as an application launch or exit. Here, we derive our basic application flow, which we then use to build a basic framework for presenting and transitioning between arbitrary screens.</p>
<p>In the first chapter, we saw the complete Space-Truckers game in all its glory and beauty. We then immediately went on to create the loading screen’s animation in the Playground before slowing down a bit to build out the supporting application infrastructure that the game will need. It may feel seem to be a bit of a let-down that we’ve been focusing so much on things that aren’t part of the game’s design, and it’s natural to want to focus on activities such as bringing in 3D models and textures or programming game mechanics. Fear not – we will be getting there in the not-too-distant future! <em class="italic">Part 2: Constructing the Game</em> is all about those sorts of topics, but without the work from this chapter and the accompanying ones, there would be nothing to tie together a thematically connected collection of interesting Playground snippets and code fragments. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">This chapter will represent even more of a shift in how the code and content are presented. From here on out, code listings will tend towards displaying fragments or highlighting interesting areas of a larger piece of code. A link to the repository or Playground will always be provided so you can check your work or use the code to skip ahead!</p>
<p>The work of this section and chapter is to build the necessary pieces of software and logic to allow a cohesive and compelling experience to emerge from the individual pieces. Over the course of this chapter, we will write code to implement state management and transitioning logic to support the future development of the core game mechanics under these headings:</p>
<ul>
<li>Adding a Custom Loading UI</li>
<li>Space-Truckers: The State Machine</li>
<li>Space-Truckers: The Main Menu</li>
<li>Integrating the Main Menu</li>
</ul>
<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Technical Requirements</h2>
<p>For this chapter, we’ll continue to use the development process covered in <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Establishing the Development Workflow</em>. If you’re just joining us on the journey or haven’t been writing code on your own, you can catch up by cloning or checking out the <strong class="source-inline">ch3-final</strong> tag from Space-Truckers: The GitHub Repository at <a href="https://github.com/jelster/space-truckers/tree/ch3-final">https://github.com/jelster/space-truckers/tree/ch3-final</a>. Before writing any code for the material in this chapter, it’s typically a good idea to create a new <strong class="bold">git</strong> branch that tracks the previous chapter’s <strong class="bold">branch</strong> or <strong class="bold">tag</strong>. This is unusual, as you would normally set up your branch to track <strong class="bold">develop</strong> or <strong class="bold">main</strong>. In this case, however, you want to be comparing commits from a specific point in the repository’s commit history prior to where you’re starting, and not everything that comes afterward has been covered yet.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Adding a Custom Loading UI</h1>
<p>As we start to gain some traction and therefore momentum, we first have to let our engines rev up<a id="_idIndexMarker154"/> before we can think about shifting gears. A short exercise in code management is just the thing to get those RPMs up! Once we’ve hit our sweet spot, we’re going to cruise straight into leveraging that work to build our loading screen. Remember, as we progress through the metaphorical gearbox of complexity, we’ll be seeing fewer details such as the following while at the same time covering greater amounts of ground.  </p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Solo Exercise: Refactoring the StartScene to Extract the AstroFactory</h2>
<p>To lay the<a id="_idIndexMarker155"/> groundwork for this and some future features, we<a id="_idIndexMarker156"/> want to extract all the logic involved in creating new planets that aren’t specific to the scene from the <strong class="bold">startScene</strong>. That logic goes into a new <strong class="bold">astroFactory</strong> class. The essentials of this refactoring are straightforward, but the key to it all is going to be creating an array of planetary data objects, then looping through that array, calling the <strong class="bold">AstroFactory</strong>’s various methods to compose the scene’s objects. Consider performing this refactoring a bit of a special exercise or challenge, but don’t sweat it too much. The idea is to try and apply the new knowledge, not to assign passing or failing grades! Alternatively, if you don’t feel you need the practice or want to skip this exercise, start your code by checking out and examining the patch diff at the following commit URL: <a href="https://github.com/jelster/space-truckers/commit/9821811">https://github.com/jelster/space-truckers/commit/9821811</a>. Take the time you need to understand the material, but don’t forget to come back for the rest of the chapter and book! </p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>The CustomLoadingScreen Type</h2>
<p>Babylon.js provides a default loading UI that appears automatically during <strong class="bold">AssetContainer</strong> operations, or manually by calling the <strong class="source-inline">engine.displayLoadingUI()</strong> method. Either way that it is invoked, we’re going to replace the default loading UI with <a id="_idIndexMarker157"/>one of our own devising. The Babylon.js docs specify the specifics of the <strong class="bold">LoadingScreen</strong> TypeScript interface that will be implemented in JavaScript, but there are really only two that are required: <strong class="source-inline">displayLoadingUI()</strong> and <strong class="source-inline">hideLoadingUI()</strong> – do those look familiar or what? Add a new JS file to the project’s source and name it <strong class="bold">SpaceTruckerLoadingScreen</strong>. Before declaring the <strong class="bold">class</strong>, add an <strong class="bold">import</strong> for the <strong class="source-inline">createStartScene</strong> function from our old friend, <strong class="bold">startscene.js</strong>. </p>
<p>The <strong class="bold">CustomLoadingScreen</strong> we’ll be implementing will use it to host the planets animating on the render canvas during loading operations. Declare the <strong class="bold">SpaceTruckerLoadingScreen</strong> class and define a constructor for it that takes an <strong class="source-inline">engine</strong> instance (required by the <strong class="source-inline">createStartScene</strong> method). In the constructor, we’ll initialize and assign some class-level properties for later use – including <strong class="source-inline">_startScene</strong>:</p>
<pre class="source-code">&#13;
constructor(engine) {&#13;
    this._totalToLoad = 0.00;&#13;
    this._loadingText = "Loading Space-Truckers: The Video &#13;
        Game...";&#13;
    this._currentAmountLoaded = 0.00;&#13;
    this._engine = engine;&#13;
    this._startScene = createStartScene(engine);&#13;
}</pre>
<p>That takes care of constructing the loading screen. Now, we need to implement the LoadingScreen interface’s members to show and hide the UI at the appropriate times. This is just done by <a id="_idIndexMarker158"/>having the show and hide methods toggle an <strong class="source-inline">_active</strong> Boolean flag; we’ll let other code that we’ll write shortly decide what to do about it:</p>
<pre class="source-code">&#13;
displayLoadingUI() {&#13;
    this._active = true;        &#13;
}&#13;
hideLoadingUI() {&#13;
    this._active = false;   &#13;
}</pre>
<p>The last thing needed is to conditionally render the scene. Since we have the engine instance passed into the constructor, we will add a simple render routine to call <strong class="source-inline">runRenderLoop</strong> at the end of the constructor:</p>
<pre class="source-code">&#13;
 engine.runRenderLoop(() =&gt; {&#13;
    if (this._startScene &amp;&amp; this._active === true) {&#13;
        this._startScene.scene.render();&#13;
    }&#13;
});</pre>
<p>We’ve gotten the bulk of the work done, but there’s still a bit more to do before we can call this a done task.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Enhancing the Loading Screen with Progress Display</h2>
<p>We’ve added what is<a id="_idIndexMarker159"/> called a non-deterministic progress bar, but what if we want to display some text along with a percentage of assets loaded? Though our project doesn’t quite yet have said assets, it soon will. Fortunately, there are only a couple of small things we need to do in order to support this when it’s needed. </p>
<h3>Adding Property Getters</h3>
<p>The <strong class="bold">SpaceTruckerLoadingScreen</strong> class already contains definitions for properties to hold the data we’re interested in, but it <a id="_idIndexMarker160"/>makes for a lot more maintainable design if we make these fields available as properties. The only one we need to make available in this fashion is <strong class="source-inline">loadingUIText</strong>; it will be<a id="_idIndexMarker161"/> potentially invoked or queried by external code. While we’re at it though, let’s add additional getters as follows:</p>
<pre class="source-code">&#13;
get progressAvailable() {&#13;
    return this._progressAvailable;&#13;
}&#13;
get currentAmountLoaded() {&#13;
    return this._currentAmountLoaded;&#13;
}&#13;
get totalToLoad() {&#13;
    return this._totalToLoad;&#13;
}&#13;
get loadingUIText() {&#13;
    return this._loadingText;&#13;
}</pre>
<p>A sharp eye may notice that the <strong class="source-inline">progressAvailable</strong> getter uses a field we didn’t define in the constructor. The place <a id="_idIndexMarker162"/>where this is set and managed is the same place where <strong class="source-inline">currentAmountLoaded</strong> and <strong class="source-inline">totalToLoad</strong> get their values from – the <strong class="source-inline">onProgressHandler</strong> function. </p>
<h3>Handling Progress</h3>
<p><strong class="source-inline">onProgressHandler</strong> is an event handler <a id="_idIndexMarker163"/>that gets subscribed to HTTP and other Progress events emitted by various Babylon.js components such as <strong class="source-inline">AssetManager</strong> and <strong class="source-inline">SceneLoader</strong>:</p>
<pre class="source-code">&#13;
onProgressHandler(evt) {&#13;
    this._progressAvailable = evt.lengthComputable === true;&#13;
    this._currentAmountLoaded = evt.loaded || this.&#13;
        currentAmountLoaded;&#13;
    this._totalToLoad = evt.total || this.&#13;
        currentAmountLoaded;&#13;
    if (this._progressAvailable) {&#13;
        this._loadingText = "Loading Space-Truckers: &#13;
            The Video Game... " + ((this._current&#13;
                AmountLoaded / this._totalToLoad) * 100).&#13;
                    toFixed(2);&#13;
    }        &#13;
}</pre>
<p>The <strong class="source-inline">evt</strong> event data object is used to set the <strong class="source-inline">progressAvailable</strong> property value. If the progress event doesn’t have a computable length, <strong class="source-inline">currentAmountLoaded</strong> is set to <strong class="source-inline">0</strong> (false) if incomplete and <strong class="source-inline">1</strong> (true) if complete. Otherwise, it’s set to the number of bytes loaded. If we can calculate the percentage loaded, we do so and set the <strong class="source-inline">loadingUIText</strong> backing field accordingly. The final piece of the loading screen is displaying <strong class="source-inline">loadingText</strong> and the progress string (if it’s available). </p>
<h3>Displaying Loading Text and Progress</h3>
<p>To display text in our <a id="_idIndexMarker164"/>scene, we’ll use the Babylon.js <strong class="bold">2D GUI</strong> system. There’s going to be a lot more on this later in this chapter, so for now, copy and paste this at the end <a id="_idIndexMarker165"/>of the constructor for <strong class="bold">SpaceTruckerLoadingScene</strong>:</p>
<pre class="source-code">&#13;
this._textContainer = AdvancedDynamicTexture.CreateFullscre&#13;
    enUI("loadingUI", true, this._startScene.scene);&#13;
const textBlock = new TextBlock("textBlock", this._&#13;
    loadingText);&#13;
textBlock.fontSize = "62pt";&#13;
textBlock.color = "antiquewhite";&#13;
textBlock.verticalAlignment = Container.VERTICAL_ALIGNMENT_&#13;
    BOTTOM;&#13;
textBlock.paddingTop = "15%";&#13;
this._textContainer.addControl(textBlock);</pre>
<p>All we’re doing here is creating a new <strong class="source-inline">AdvancedDynamicTexture</strong> sized to the render canvas, then adding a <strong class="bold">TextBlock</strong> that we apply a couple of size, color, and placement adjustments to before adding it to the texture’s control collection. </p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="source-inline">onProgressHandler</strong> will update the <strong class="source-inline">loadingUIText</strong> value if it’s available.</p>
<p>We’ve completed the loading screen functionality, now it’s time to wire it up globally in the <strong class="source-inline">index.js</strong> component. This is just one line of code that is added right after the <strong class="source-inline">eng</strong> instance is created:</p>
<pre class="source-code">&#13;
const eng = new Engine(canvas, true, null, true);&#13;
logger.logInfo("Created BJS engine");&#13;
eng.loadingScreen = new SpaceTruckerLoadingScreen(eng);</pre>
<p>That’s all there is to it! Now, any time that a piece of code asks the Engine to show the loading UI, our little planet animations will be shown. Though it may seem to be a minor piece of functionality, completing<a id="_idIndexMarker166"/> this part of the application leaves us ready to change the pace a bit and examine the ins and outs of how we’re going to manage the overall behavior of Space-Truckers: The Application.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Space-Truckers: The State Machine</h1>
<p>People who have some familiarity <a id="_idIndexMarker167"/>with game development may be familiar with the idea of a game being structured around a series of loops. An Update loop runs the simulation and physics, moving objects and applying effects according to the latest update. A render loop is when the scene is actually drawn to the screen. We’ve seen examples of this previously, such as when we add event observers for the <strong class="bold">scene.onBeforeRenderObservable</strong>, but that’s at a lower level than what we’re looking at currently. Our application is going to be a host for multiple different BJS scenes and it will therefore need a way to periodically update the application’s state as well as tell the active scene to render. Finally, it must be able to manage to transition between different scenes.   </p>
<p>An application of the kind we’re building has some implicit requirements when it comes to how it responds to input and evolves its internal state over time. For instance, when a player selects a menu item or exits their current game, the system must respond by altering (or “mutating”) its data to fill and render a submenu, or by returning to the main menu. Implicit requirements make for poorly designed software, so we’re going to start by making the implicit explicit.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Logging Interlude</h2>
<p>Our application is about to get more complex, so it’s a good time to begin adding basic instrumentation and <a id="_idIndexMarker168"/>debugging messages – we can always enhance and refine the logging routines later, but not having them at all is a much more difficult place to begin the more code we write. The source file <strong class="source-inline">logger.js</strong> with its exported class, <strong class="source-inline">ConsoleProxy</strong>, is an incredibly basic wrapper around the console object that provides functions to log different levels of log messages (INFO, WARN, ERROR, and FATAL) to the console (if present). Each of the different logging methods has an identical body (if this bothers you, fix it and open a PR! The beauty of open source software in action), so in the interest of saving space, only one of the functions will be shown in the following code: </p>
<pre class="source-code">&#13;
class ConsoleProxy {&#13;
    constructor(console) {&#13;
        this._console = console;&#13;
        this._consoleIsPresent = this._console == true;&#13;
        this._messageBuffer = [];&#13;
    }&#13;
    logInfo(message) {&#13;
        const logObj = { type: "INFO", message: message};&#13;
        if (this._consoleIsPresent) { &#13;
            this._console.log(logObj);&#13;
            return;&#13;
        }&#13;
        this._messageBuffer.push(message);&#13;
    }&#13;
// …&#13;
}&#13;
const theProxy = new ConsoleProxy(console);&#13;
export default theProxy;</pre>
<p>Most of the preceding code is pretty bog-standard – the sort of thing you’d see in almost any home-brew<a id="_idIndexMarker169"/> application framework. The <strong class="source-inline">constructor</strong> accepts a <strong class="source-inline">console</strong> parameter, which it uses to set a presence flag. This is because it’s not always guaranteed that the <strong class="source-inline">console</strong> object will be available, and we don’t want any logging calls to fail and cause problems with the rest of the application if that were to be the case. The _<strong class="source-inline">messageBuffer</strong> array is used as a fall-back when the console isn’t available. In this case, application logging can still be accessed by attaching a debugger and reading the contents of the log array. Should it be required, this can easily be <a id="_idIndexMarker170"/>extended to suit the scenario at hand.  Outside of the <strong class="bold">class</strong> definition, a new const instance, <strong class="source-inline">theProxy</strong>, is instantiated before being exported as a single object. Consumers of the logger don’t instantiate a new log instance – they just call <strong class="bold">logger.logXXX</strong>. When using this logger in Playground snippets, don’t forget to omit the last <strong class="source-inline">export default</strong> line and change <strong class="source-inline">theProxy</strong> to <strong class="source-inline">logger</strong>. We’ll want to have this handy for the next part so that we can easily test and verify proper code behavior, or you can refer to snippet <strong class="bold">#EK321G</strong> as a starting reference template. </p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Generators and function* Iterators</h2>
<p>From the perspective of <a id="_idIndexMarker171"/>software design, we will be thinking about our State Machine as a type of <strong class="bold">iterator</strong>, or a type of looping construct where each iteration <a id="_idIndexMarker172"/><strong class="bold">yields</strong> the next (or current) state, also allowing <a id="_idIndexMarker173"/>callers to specify state conditions. The JavaScript language construct that gives us this functionality is known as a <strong class="bold">Generator</strong> function, or a <strong class="bold">function*</strong>. </p>
<p>The MDN Web Docs at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*</a> say this about Generators and their behavior:</p>
<p class="author-quote">“Generators are functions that can be exited and later re-entered. Their context (variable bindings) will be saved across re-entrances…”</p>
<p class="author-quote">“When the iterator’s <strong class="source-inline">next()</strong> method is called, the generator function’s body is executed until the first <strong class="source-inline">yield</strong> expression, which specifies the value to be returned from the iterator”</p>
<p class="author-quote">“Calling the <strong class="source-inline">next()</strong> method with an argument will resume the generator function execution, replacing the <strong class="source-inline">yield</strong> expression where an execution was paused with the argument from <strong class="source-inline">next()</strong>”</p>
<p class="author-quote">“A <strong class="source-inline">return</strong> statement in a generator, when executed, will make the generator finish”</p>
<h3>Writing a Generator function</h3>
<p>It’s more helpful to <a id="_idIndexMarker174"/>see actual code than it is to read descriptions of it, so let’s start up a new Playground Snippet and lay down some code. Using the base PG snippet (<strong class="bold">#EK321G</strong>), add some room in the <strong class="source-inline">createScene</strong> function for our Generator function stub:</p>
<pre class="source-code">&#13;
    function* appStateMachine() {&#13;
        let currentState = "INDETERMINATE";&#13;
        yield currentState;&#13;
        yield currentState + "-POST";&#13;
        yield "DONE";&#13;
    }</pre>
<p>Remember that when the body of this function is executed, control is transferred any time a <strong class="source-inline">yield</strong> statement is encountered. The <strong class="source-inline">value</strong> is returned by the iterator – in the form of an object with a structure that looks as follows: <strong class="source-inline">{ value: &lt;yielded value&gt;, done: false|true }</strong>. In the preceding code, we define and set a local variable, <strong class="source-inline">currentState</strong>, before <strong class="bold">yielding</strong> its value. Execution stops in this method until <strong class="bold">next</strong> is called on the <strong class="bold">iterator</strong>, at which <a id="_idIndexMarker175"/>point the code immediately yields back a modified version of the <strong class="source-inline">currentState</strong> variable. After execution resumes, the code once again yields back – this time with the phrase <strong class="source-inline">“DONE”</strong> before implicitly <strong class="bold">returning</strong>. </p>
<h3>Using the Generator</h3>
<p>To best illustrate <a id="_idIndexMarker176"/>some of<a id="_idIndexMarker177"/> the non-intuitive behavior of <strong class="bold">iterator functions</strong>, let’s write two different ways of using the <strong class="source-inline">appStateMachine</strong> Generator we just defined. Follow along in your own Playground or skip ahead and load up the result of this sub-section as the next snippet revision (we started with 0) – <strong class="bold">#EK321G#1</strong>. </p>
<p>The first – and arguably the simplest – method of using our <strong class="source-inline">appStateMachine</strong> Generator is to use the <strong class="bold">for…of</strong> ES6 iteration construct to progressively swap execution through each <strong class="source-inline">yield</strong> statement:</p>
<pre class="source-code">&#13;
    let index = 0;&#13;
    const asm = appStateMachine();&#13;
    for (const a of asm) {&#13;
        logger.logInfo("Index " + index++, a);&#13;
    }</pre>
<p>In the previous snippet, the value of the index variable is logged to the console before being incremented as a<a id="_idIndexMarker178"/> convenient way of displaying the behavior of the code. Open your browser’s Developer Tools and look at the console output after clicking <strong class="bold">Run</strong>. The output should look similar to this:</p>
<p class="source-code">{type: "INFO", message: "Index 0"} "INDETERMINATE"</p>
<p class="source-code">{type: "INFO", message: "Index 1"} "INDETERMINATE-POST"</p>
<p class="source-code">{type: "INFO", message: "Index 2"} "DONE"</p>
<p>You can see from the progression of the <strong class="source-inline">Index</strong> value from <strong class="source-inline">0</strong> to <strong class="source-inline">2</strong> shows how the <strong class="source-inline">yield</strong> statement is switching the code execution between the generator function and the <strong class="source-inline">for…of</strong> loop. This means <strong class="source-inline">of</strong> iterating over the generator works best for situations where the looping logic doesn’t need to do a lot of heavy lifting or if the code that you’re writing needs to coordinate many different asynchronous operations in the correct order and you don’t need fine control over the iteration. </p>
<p>An alternative use instead of iterating over the generated function is to manually call the <strong class="source-inline">next()</strong> function to transfer control. Each time it is called is equivalent to an iteration of the looping construct discussed previously, but recall that the difference is that instead of directly getting whatever value was part of the <strong class="source-inline">yield</strong> statement, an iterator object is returned with <strong class="source-inline">value</strong> and <strong class="source-inline">done</strong> properties:</p>
<pre class="source-code">&#13;
    const asm2 = appStateMachine();&#13;
    let s0 = asm2.next();&#13;
    let s1 = asm2.next();&#13;
    let s2 = asm2.next();&#13;
    let s3 = asm2.next();&#13;
    logger.logInfo("s0", s0);&#13;
    logger.logInfo("s1", s1);&#13;
    logger.logInfo("s2", s2);&#13;
    logger.logInfo("s3", s3);</pre>
<p>Running this leads to an identical output to the prior code, but with an extra value. Instead of only having three separate index values, this approach leaves you with four:</p>
<p class="source-code">{type: "INFO", message: "s3"} {value: undefined, done: true}</p>
<p> This <strong class="source-inline">“s3”</strong> object doesn’t have a value, and it has the <strong class="source-inline">done</strong> flag set to <strong class="source-inline">true</strong>, indicating the sequence is complete. Any further calls to <strong class="source-inline">asm2.next()</strong> will return the same <strong class="source-inline">undefined</strong> value and <strong class="source-inline">true</strong> flag. The advantage of this approach is that consumers of the Generator have a<a id="_idIndexMarker179"/> lot of control over when and how to call <strong class="source-inline">next()</strong>, which is a critical feature that we’re about to use when we create our first State Machine. </p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>The Definition of a State Machine</h2>
<p>A core concept in computer<a id="_idIndexMarker180"/> science a <strong class="bold">Finite State Machine</strong> (<strong class="bold">FSM</strong>) – or just a <strong class="bold">State Machine</strong> – is defined and characterized, for our purposes, by these<a id="_idIndexMarker181"/> important attributes:</p>
<ol>
<li>The system can only ever be in one state at any given time. </li>
<li>The State Machine has a finite number of possible states. For practical purposes, at a minimum, there is an initial state and a final state for the system.</li>
<li>Transitions between states are triggered in response to commands, external input, or other changes in the environment (e.g., time passing).</li>
<li>Before a frame is rendered, the State Machine should be updated with the latest information about the state.</li>
</ol>
<p>Let’s look at each of these points in some more detail.</p>
<h3>One State at a Time</h3>
<p>This is pretty self-explanatory. A given state machine may only be in a single state, no matter how many possible states could be <a id="_idIndexMarker182"/>valid – there is no mixing, aggregated, or hybrid types of state. In code terms, this means our state machine will have a single field or property to represent its current state. This is not to say that a particular state machine can’t have attributes that themselves have their own states (e.g., an animation might be in the RUNNING state), just that the state machine as a whole will only be classified as being in a single state at any given time. At the time of writing, quantum computing has not yet reached mainstream availability, neatly avoiding any <a id="_idIndexMarker183"/>discussion of potential eigenstates – a probabilistic combination of potential states – and keeping the subject matter firmly rooted in classical computational theory.Phew, what a relief!</p>
<h3>Finite Number of States, Start and Finish</h3>
<p>There needs to<a id="_idIndexMarker184"/> be an initial state for the machine to begin in and there should also be an end state. Technically, the end state and the initial state can be the same, but it doesn’t make for very interesting or relevant software. In between the start and finish can be any number of states, although to keep things practical, we’ll only be looking to define a small handful of them. </p>
<h3>Transitions Happen When Something Happens</h3>
<p>It sounds silly, but it’s true. During the course of a given Update cycle, the application or game logic may receive<a id="_idIndexMarker185"/> input events that trigger a state transition. Part of our FSM’s definition is the logic to invoke any given state transition. That implies our code will contain methods for transitions that have names such as <strong class="source-inline">goToMainMenu</strong>. </p>
<p class="callout-heading">Note</p>
<p class="callout">If it helps, try to think of a state as being a short-hand way of describing a single, discrete combination of the system’s internal data. State transitions are the logic controlling the mutation of one combination of internal data into another different arrangement of data.</p>
<h3>Updating the State Machine </h3>
<p>Wrapping it all up is the<a id="_idIndexMarker186"/> mechanism by which we can progress or evolve the machine’s state on a frequent basis. Because we’re going to be managing multiple scenes, we can’t use something such as <strong class="source-inline">scene.onPreRenderObservable</strong>, as we’ve already done for things such as animating the planetary orbits. Instead, we’ll make use of the <strong class="source-inline">engine.runRenderLoop</strong> callback as a way of ensuring that our update logic is invoked no matter which scene is being rendered. This also fulfills the requirement of updating the state before rendering the frame quite nicely.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">If you need to ensure that animations and physics are synchronized or if you need framerate-independent rendering, you’ll need to ensure that you do both of the following things:</p>
<p class="callout">a) Set the <strong class="source-inline">deterministicLockstep</strong> flag of the options parameter when creating the Engine instance</p>
<p class="callout">b) Use <strong class="source-inline">onBeforeStep</strong> along with the <strong class="source-inline">onAfterStep</strong> observables instead of the <strong class="source-inline">onPre/onAfterRenderObservable</strong> sets to perform state updates</p>
<p>With the knowledge <a id="_idIndexMarker187"/>of how we’re going to build the next part of our application, it’s time to look at the specifics of our design and start to prototype the Playground snippet.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Space-Truckers: The Application State Diagram</h2>
<p>Before we dive into writing <a id="_idIndexMarker188"/>code for our FSM, we should take a moment to figure out just what it is that we’re going to need to build. An important distinction we need to make out of the gate is between the gameplay and non-gameplay sections of the application. The gameplay will have its own state machine to manage the different phases of play, and each phase in turn can have its own mini-state machine. It’s state machines all the way down! The following diagram shows each state and how they transition between them. The circles in the diagram represent events or transitions triggered by external input, such as a user clicking a button:</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 4.1 – A State diagram, from the early Space-Truckers design process, showing the application and game state – transitions between states (lines and arrows) happen sequentially (such as Initialized) or as the result of an input event (such as user Cancelled)&#13;&#10;" height="1507" src="image/Figure_4.01_B17266.jpg" width="1653"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A State diagram, from the early Space-Truckers design process, showing the application and game state – transitions between states (lines and arrows) happen sequentially (such as Initialized) or as the result of an input event (such as user Cancelled)</p>
<p>For now, we’ll disregard the lower portion of the diagram. Being an early iteration, some of it (that is, the cut scenes) is at any rate aspirational. Looking at the diagram’s upper portion, if we <a id="_idIndexMarker189"/>consider that the Loading Screen is in the <strong class="bold">Initializing</strong> state then we can see a 1:1 correspondence between the states and application screens. It should also start to become clearer how each screen also corresponds to a BJS scene. Reasoning along these lines, we can generalize the different <strong class="bold">CutScene</strong> and <strong class="bold">Splash Screen</strong> items as simply being two separate instances of the same thing (save with different actual content, but that’s not relevant here). Here are the screens and scenes from the diagram that we’ve identified so far:</p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 4.2 – A table of application-level states and transition rules" height="495" src="image/Figure_4.02_B17266.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A table of application-level states and transition rules</p>
<p>This may look like a lot to<a id="_idIndexMarker190"/> take in, but it’s really not as complicated as it seems. It’s time to open up <strong class="bold">VSCode</strong> and start adding some new code. You can either follow along here or if you would rather just copy, paste, and modify existing code, go to snippet <strong class="bold">#EK321G#6</strong>. Bear in mind that you’ll need to make similar types of adaptations to the snippet as we made in the previous chapter as you progress through incorporating the snippet into your code.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Almost Infinitely Looping State</h2>
<p>The first thing <a id="_idIndexMarker191"/>we’re going to add to our project is the <strong class="bold">AppStates</strong> enumeration. This is a simple object defining constants and values for the different states in the preceding table. Add a new file, <strong class="source-inline">appstates.js</strong>, to the project’s <strong class="source-inline">/src</strong> directory. Since this is a very simple and unchanging object, we can use <strong class="source-inline">Object.freeze</strong> to ensure that the values aren’t changed at runtime:</p>
<pre class="source-code">&#13;
export default Object.freeze({&#13;
    CREATED: 0,&#13;
    INITIALIZING: 2,&#13;
    CUTSCENE: 3,&#13;
    MENU: 4,&#13;
    RUNNING: 5,&#13;
    EXITING: 6&#13;
});</pre>
<p>After adding the <strong class="bold">AppStates</strong> enumeration, add a new file, <strong class="source-inline">spaceTruckerApplication.js</strong>, to contain a <strong class="source-inline">class</strong> definition named (surprise!) <strong class="source-inline">SpaceTruckerApplication</strong>:</p>
<pre class="source-code">&#13;
class SpaceTruckerApplication {&#13;
}</pre>
<p>This class is the central class of this application (as the name implies). It will be growing much larger as time<a id="_idIndexMarker192"/> passes, so treasure it in all of its adorable brevity while you can before breaking ground on it by defining our <strong class="source-inline">appStateMachine</strong> function*. Add a function* definition inside the class for it. </p>
<p>As we discussed earlier, a state machine needs to have one and only one current state. It becomes very useful in state calculations to be able to compare the present state to whatever value the previous state was, so in the body of the function* Generator, add a couple of variable declarations to contain those values, along with a helper function to change them:</p>
<pre class="source-code">&#13;
function* appStateMachine() {&#13;
        let previousState = null;&#13;
        let currentState = null;&#13;
        function setState(newState) {&#13;
            previousState = currentState;&#13;
            currentState = newState;&#13;
            logger.logInfo("App state changed. Previous &#13;
                state:" + previousState + « &#13;
                    New state: " + newState);&#13;
            return newState;&#13;
        }&#13;
}&#13;
// … create scene, camera return scene</pre>
<p>We can now turn our attention to the state machine’s output – what it will yield back to callers. Our little sample earlier would simply stop (returning <strong class="source-inline">done: true</strong>) once it had reached the end of its sequence, but we want our FSM to run for as long as the application is running, and we don’t know ahead of time how many times that means calling the Generator’s <strong class="source-inline">next()</strong> method. The way we address this is by placing that call inside of an infinite loop. </p>
<p>Each time, the loop<a id="_idIndexMarker193"/> first starts by receiving input from the caller to indicate the desired <strong class="source-inline">nextState</strong> – the caller does this by passing the value as an argument to <strong class="bold">next</strong> – and assuming the state is valid, then our <strong class="source-inline">setState</strong> method makes the actual state change. Once that happens, the code checks to see whether the conditions have been met to reach the end state (<strong class="source-inline">AppStates.EXITING</strong>), returning the <strong class="source-inline">currentState</strong> if so – otherwise, it will <strong class="source-inline">yield</strong> back to the caller at the top of the loop:</p>
<pre class="source-code">&#13;
while (true) {&#13;
    let nextState = yield;&#13;
      if (nextState !== null &amp;&amp; nextState !== undefined) {&#13;
            setState(nextState);&#13;
            if (nextState === AppStates.EXITING) {&#13;
                return currentState;&#13;
            }&#13;
        }&#13;
}</pre>
<p>Our state machine implementation is done (for now), and now it’s time to hook-up the supporting application logic.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Adding the Constructor and Supporting Logic</h2>
<p>We need to initialize the<a id="_idIndexMarker194"/> state machine by creating a function from our Generator along with other creation tasks, so add a constructor to<a id="_idIndexMarker195"/> our new class. Because we are creating and managing scenes with this class, we need to take in <strong class="bold">BABYLON.Engine</strong> as a parameter in the constructor and initialize the private property, <strong class="source-inline">_engine</strong>, with it. While we’re here, we might as well call the Generator and add a field for tracking which scene to render. Finally, the last action in the constructor is to transition the state of the application from its previous value of <strong class="source-inline">undefined</strong> to <strong class="source-inline">CREATED</strong>. We’ll do this by invoking the to-be-created <strong class="source-inline">moveNextAppState</strong> function (see the following code block): </p>
<pre class="source-code">&#13;
constructor(engine) {&#13;
    this._engine = engine;&#13;
    this._currentScene = null;&#13;
    this._stateMachine = this.appStateMachine();&#13;
    <strong class="bold">this.moveNextAppState(AppStates.CREATED);</strong>&#13;
}</pre>
<p>It can be cumbersome to have to write statements such as <strong class="source-inline">this._stateMachine.next().value</strong>, and worse, it reveals the internal implementation details to code that doesn’t need to know about that sort of stuff, making it harder to make changes in the future. Let’s insulate the rest of our code from having to deal with that by adding some accessor properties to retrieve <strong class="source-inline">currentState</strong> and <strong class="source-inline">activeScene</strong>. Also as mentioned previously, we will add the <strong class="source-inline">moveNextAppState</strong> helper method to help us to hide the passing of values to and from the state machine:</p>
<pre class="source-code">&#13;
    get currentState() {&#13;
        return this._stateMachine.next();&#13;
    }&#13;
    get activeScene() {&#13;
        return this._currentScene;&#13;
    }&#13;
    moveNextAppState(state) {&#13;
        return this._stateMachine.next(state).value;&#13;
    }</pre>
<p>Something important to note before we move any further is that the application must respect its boundaries as far as not trying to perform heavy loading tasks during construction time. </p>
<p>That type of task is reserved for <strong class="source-inline">AppStates.INITIALIZING</strong>, and the reason for this is crucial to the user <a id="_idIndexMarker196"/>experience. We don’t want to do anything that might transfer large amounts of data to the client until they’ve affirmatively decided to launch the game. That respects people <a id="_idIndexMarker197"/>who might be curious about the game and are on limited data or a limited bandwidth connection and enforces a clean separation between the HTML-based landing page and the WebGPU or WebGL-based game. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">The state diagram we looked at earlier <em class="italic">starts</em> when the user clicks the <strong class="bold">Launch</strong> button on our landing page.</p>
<p>The effect of clicking the landing page’s <strong class="bold">Launch</strong> button is a mini-transition in and of itself – a transition between the DOM-focused HTML page and the Canvas-rendered game application. The first step towards implementing this is to add a new function we’ll name <strong class="source-inline">run</strong> to the <strong class="source-inline">SpaceTruckerApplication</strong> class. This is the place where we hook the engine’s <strong class="source-inline">runRenderLoop</strong> callback up with our <strong class="source-inline">applicationStateMachine</strong>:</p>
<pre class="source-code">&#13;
    run() {&#13;
        this._engine.runRenderLoop(() =&gt; {&#13;
            // update loop&#13;
            let state = this.currentState;&#13;
            switch (state) {&#13;
                case AppStates.CREATED:&#13;
                case AppStates.INITIALIZING:&#13;
                    break;&#13;
                case AppStates.CUTSCENE:&#13;
                    break;&#13;
                case AppStates.MENU:&#13;
                    break;&#13;
                case AppStates.RUNNING:&#13;
                    break;&#13;
                case AppStates.EXITING:&#13;
                    break;&#13;
                default:&#13;
                    break;&#13;
            }&#13;
            this._currentScene?.render();&#13;
        });&#13;
    }</pre>
<p>Within the <strong class="source-inline">runRenderLoop</strong> callback, we retrieve the <strong class="source-inline">currentState</strong> by using the getter method to call the <strong class="source-inline">_applicationStateMachine.next()</strong> function without any parameters. There’s not much to see at the moment, but the stubbed-out <strong class="source-inline">switch</strong> statement<a id="_idIndexMarker198"/> shows where each state is handled. The first two, <strong class="source-inline">CREATED</strong> and <strong class="source-inline">INITIALIZING</strong>, are grouped because they are not rendered – or at least in<a id="_idIndexMarker199"/> the case of <strong class="source-inline">INITIALIZING</strong>, the loading UI is the rendered output of that state. Once scene selection and management have been completed, the <strong class="source-inline">render()</strong> method of the <strong class="source-inline">_currentScene</strong> (if present) is called. </p>
<p>Wiring the initial call to <strong class="source-inline">run</strong> is done with two lines that we’ll add to the <strong class="source-inline">index.js</strong> file. There’s some cleanup of now-obsolete code needed too – we don’t want <strong class="source-inline">index.js</strong> calling <strong class="source-inline">createStartScene</strong>, nor do we want it interacting with the engine’s render loop. After creating and setting up <strong class="source-inline">SpaceTruckerLoadingScreen</strong>, declare and instantiate a new instance of <strong class="source-inline">SpaceTruckerApplication</strong>. Since it’s pretty well named as a type, just call it <strong class="source-inline">theApp</strong>. Next, add a line to invoke <strong class="source-inline">theApp.run()</strong> in the <strong class="bold">Launch</strong> button’s click handler. It can be useful to add logging statements at key areas in the code to help in<a id="_idIndexMarker200"/> understanding the app’s runtime behavior during development, so make liberal use of them! This is the basic framework for our application’s<a id="_idIndexMarker201"/> state management functionality all wired up and ready to be filled with more interesting states and behaviors. To that end, it’s time to start fleshing out these states and behaviors as we get ready to build the Main Menu.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>Writing the Initialize logic</h2>
<p>Returning to the State <a id="_idIndexMarker202"/>Diagram, once the application has finished initialization, it should transition to displaying the opening splash screen (cut scene) before transitioning to the Main Menu again. This is a nice linear progression, so it is simple to implement with the aid of the <strong class="source-inline">await</strong> ES6 feature. </p>
<p>Since the <strong class="source-inline">INITIALIZING</strong> state is the first state after construction, it should be the first thing that happens in the <strong class="source-inline">run()</strong> method. With this change, we’ll also need to mark the <strong class="source-inline">run()</strong> method as <strong class="source-inline">async</strong> to allow us to use this language feature, so change the first few lines of the function to match the following:</p>
<pre class="source-code">&#13;
    <strong class="bold">async</strong> run() {&#13;
        <strong class="bold">await this.initialize();</strong>&#13;
    // …</pre>
<p>Now, add the function for <strong class="source-inline">initialize</strong>. We want this method to accomplish several tasks, some of which we will be simulating for the time being. Another method stub, <strong class="source-inline">goToMainMenu</strong>, helps us to complete the first part of the state diagram with what we will build next:</p>
<pre class="source-code">&#13;
    async initialize() {&#13;
        this._engine.enterFullscreen(true);&#13;
        this._engine.displayLoadingUI();&#13;
        this.moveNextAppState(AppStates.INITIALIZING)&#13;
        // for simulating loading times&#13;
        const p = new Promise((res, rej) =&gt; {&#13;
            setTimeout(() =&gt; res(), 5000);&#13;
        });&#13;
        await p;&#13;
        this._engine.hideLoadingUI();&#13;
        <strong class="bold">this.goToMainMenu();</strong>       &#13;
    }</pre>
<p>First, we request a fullscreen session from the engine. This is equivalent to the user selecting their web <a id="_idIndexMarker203"/>browser’s fullscreen option, which we want to do before we have to do any serious rendering – applying canvas scaling or a size change is faster when there’s not anything being rendered yet. Next, we want to display the engine’s Loading UI – which if you recall, we’ve replaced with our own custom loading UI in our codebase.</p>
<p class="callout-heading">Note</p>
<p class="callout">When running this in the Playground, the default Babylon.js loading UI will be displayed instead of our customized one. </p>
<p>After that, we are officially into the <strong class="source-inline">INITITIALIZING</strong> state, so we transition to that state by calling <strong class="source-inline">moveNextAppState</strong> with the new state. Lastly, we are simulating a 5-second load time by creating a new <strong class="source-inline">Promise</strong> that resolves after the timeout period. We <strong class="source-inline">await</strong> this to occur before hiding the loading UI and then initiating the next state transition to the <strong class="source-inline">MENU</strong> state.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Transitioning to the Main Menu</h2>
<p>The <strong class="source-inline">goToMainMenu</strong> function<a id="_idIndexMarker204"/> definition is very simple, as it has a very specific task. It needs to create an instance of the (soon-to-be-created) <strong class="source-inline">MainMenuScene</strong> class before transitioning to the <strong class="source-inline">MENU</strong> state. Add the following function definition to the class:</p>
<pre class="source-code">&#13;
    goToMainMenu() {&#13;
        this._engine.displayLoadingUI();        &#13;
        this._mainMenu = new MainMenuScene(this._engine);&#13;
        this._engine.hideLoadingUI();&#13;
        this.moveNextAppState(AppStates.MENU);        &#13;
    }</pre>
<p>There’s one more change needed before we can finish wiring up our state machine. In our main <strong class="source-inline">Update</strong> loop, under the <strong class="source-inline">AppStates.MENU</strong> case statement, we need to set the <strong class="source-inline">_currentScene</strong> value to our Main Menu’s scene:</p>
<pre class="source-code">&#13;
    case AppStates.MENU:&#13;
       this._currentScene = this._mainMenu.scene;&#13;
       break;</pre>
<p>Of course, this doesn’t currently exist, and now’s a good time to address that deficiency! Create another new JS file, <strong class="source-inline">mainMenuScene.js</strong>, and add a stub class to the snippet called <strong class="source-inline">MainMenuScene</strong>. Implement its constructor to take an engine instance; it should also create a new <strong class="bold">Scene</strong> instance that is exposed via a public <strong class="bold">get</strong> accessor named <strong class="source-inline">scene</strong>. To keep the scene happy, create a new <strong class="source-inline">ArcRotateCamera</strong>, using the final parameter of its constructor to set the camera as the scene’s default. To blend with the existing background, we’ll also set <strong class="source-inline">scene.clearColor</strong> to an opaque black with <strong class="bold">RGBA</strong> values of <strong class="source-inline">0</strong>, <strong class="source-inline">0</strong>, <strong class="source-inline">0</strong>, and <strong class="source-inline">1</strong> respectively. The camera distance parameter is set to <strong class="source-inline">-30</strong> and seems somewhat arbitrary – however, the value will be important soon when we are rendering an animated background. This is how your class definition should look after putting in the basic elements (don’t forget to add <strong class="source-inline">import</strong> statements for <strong class="source-inline">Scene</strong>, <strong class="source-inline">Vector3</strong>, and <strong class="source-inline">ArcRotateCamera</strong>, and to add <strong class="source-inline">from “@babylonjs/core”</strong> to the top of the file and <strong class="source-inline">export default MainMenuScene</strong> to the bottom!): </p>
<pre class="source-code">&#13;
class MainMenuScene {&#13;
    get scene() {&#13;
        return this._scene;&#13;
    }&#13;
    constructor(engine) {&#13;
        this._engine = engine;&#13;
        let scene = this._scene = new Scene(engine);&#13;
        const camera = new ArcRotateCamera("menuCam",&#13;
            0, 0, -30, Vector3.Zero(), scene, true);&#13;
    }&#13;
}&#13;
export default MainMenuScene;</pre>
<p>Check to make sure there aren’t any syntax errors or other issues, and make sure to save and commit your work. Things are about to get more interesting here! </p>
<p>The final listing for our <a id="_idIndexMarker205"/>basic state machine is in snippet <strong class="bold">#EK321G#6</strong>. Don’t be fooled by the seeming lack of accomplishment – it’s not always wise to gauge progress using visual indicators. We’ve laid the foundations with this groundwork that will help with our future efforts, which will make more sense as we seek to coordinate between multiple scenes and screens. The first screen that we’re going to build is the Main Menu, which on our diagram isn’t the next state in the sequence – the splash scene is what comes next on it – but we will be returning to that after we’ve built some of the display and transitioning logic that we’re going to need as part of building cut scenes. </p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Space-Truckers: The Main Menu</h1>
<p>One of the primary features that <a id="_idIndexMarker206"/>pretty much every single video game in existence has in common with each other is that they all have a Main Menu. Space-Truckers is to be no exception, but we first have to sit down and figure out how we want our menu to look before we can make it. We start with a basic concept sketch of the layout and elements of the menu, which we’ll then use as a guidepost for building out a PG snippet of the menu. From the background to the foreground, we’ll build up a GUI <a id="_idIndexMarker207"/>menu display progressively, adding containers, a title block, and then buttons that will be ready to practically drag and drop into the codebase!</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Basic Design</h2>
<p>Firstly, let’s think about the<a id="_idIndexMarker208"/> application’s navigational structure. Consulting our State Diagram (<em class="italic">Fig. 4.1</em>), we can see that there are a couple of different branches that the state can transition to from the Menu AppState. With the exception of the initial transition into the Main Menu, each of the paths represent a different menu item or selection option:</p>
<ul>
<li>Transitioning from <strong class="bold">MENU</strong> to <strong class="bold">Running</strong> will be user-triggered by clicking a <strong class="bold">PLAY</strong> button.</li>
<li>Exiting the application is triggered by clicking an <strong class="bold">EXIT</strong> button.</li>
<li>Additional menus are accessed by clicking their respective buttons. Initially, we’ll only be creating a <strong class="bold">High Scores</strong> sub-menu.</li>
</ul>
<p>Appearance-wise, we want to make the menu functionally attractive and to show a bit of dynamic behavior over time, both in the foreground and the background. Another consideration is that because players may be using a gamepad or controller instead of a keyboard and mouse, we’ll want to have a <strong class="bold">selection indicator</strong> that shows the player which menu item will be invoked by clicking or pressing the appropriate button on their controllers. The following sketch shows how this may look without any background:</p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 4.3 – A Main Menu design sketch&#13;&#10;" height="836" src="image/Figure_4.03_B17266.jpg" width="1039"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – A Main Menu design sketch</p>
<p>To help the menu stand out against the background, we’ll fill it with a gradient or other semi-opaque image, as well as give the container a border. </p>
<p>The background doesn’t <a id="_idIndexMarker209"/>need to have a lot going on – time and bandwidth constraints are likely to put this particular piece of content on a low-priority track. That’s OK because we can quickly and easily put something in place that looks<a id="_idIndexMarker210"/> pretty good and does what we want – do you remember our old friend the <strong class="bold">Starfield Procedural Texture</strong> (<strong class="bold">PT</strong>)? We’ll use it to give the menu a cool space-themed background, and then we’ll animate it to give the illusion of travel. </p>
<p>Switch back to the Playground in your web browser and click the <strong class="bold">New</strong> icon to create a new snippet for our Main Menu.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Setting up the Main Menu snippet</h2>
<p>Knowing how we plan to<a id="_idIndexMarker211"/> transport the code in our snippet into our codebase at some point is a great opportunity to invest the time and effort into making the process as quick, reliable, and accurate as possible. </p>
<p>We can start with this by defining some aliases for the various <strong class="source-inline">BABYLON</strong> components and namespaces at the top of our snippet, just as we did back in <a href="B17266_03_Final_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>,<em class="italic"> Establishing the Development Workflow</em>:</p>
<pre class="source-code">&#13;
const {&#13;
    Color4,&#13;
    Vector3,    &#13;
    ArcRotateCamera,&#13;
    Scene    &#13;
} = BABYLON;</pre>
<p>There will be more items to add to this list as we involve additional <strong class="bold">Babylon.js</strong> APIs, so don’t forget to update this list when that happens! Below the alias declarations in the snippet, copy and paste just the <strong class="source-inline">MainMenuScene</strong> class definition from your local file. </p>
<p class="callout-heading">Note</p>
<p class="callout">The items in the alias list that we just defined will need to be converted into <strong class="bold">import</strong> statements when integrated into the codebase.</p>
<p>When we’re ready to integrate and commit our changes, we’ll update the local files by essentially performing the same thing in reverse. In the snippet’s <strong class="source-inline">createScene</strong> function, instantiate a new instance of <strong class="source-inline">MainMenuScene</strong> and return its scene property, and that will hook up our budding <strong class="source-inline">MainMenuScene</strong> class into the snippet’s rendering loop:</p>
<pre class="source-code">&#13;
var createScene = function () {&#13;
    const mainMenu = new MainMenuScene(engine);&#13;
    <strong class="bold">return mainMenu.scene;</strong>&#13;
};</pre>
<p>Short and sweet, we don’t <a id="_idIndexMarker212"/>have to think about this part of the snippet ever again. </p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>Building the Background</h2>
<p>We’ll start with the general environment <a id="_idIndexMarker213"/>and background setup for the scene, so scroll back up to the class definition and add a new instance method named <strong class="source-inline">_setupBackgroundEnvironment</strong>. This is where we will instantiate and configure the Starfield PT that serves as the background for the screen. It’s also where we’ll set up the texture to animate gradually over time to give the illusion of traveling through the starfield. </p>
<p>Invoke <strong class="source-inline">this._setupBackgroundEnvironment()</strong> at the end of the constructor so we can use the run button immediately to see results. Before coding the body of the function though, add these types to the top alias definition list:</p>
<ul>
<li><strong class="source-inline">HemisphericLight</strong></li>
<li><strong class="source-inline">StarfieldProceduralTexture</strong> (put on its own line, you’ll thank yourself later)</li>
<li><strong class="source-inline">StandardMaterial</strong></li>
<li><strong class="source-inline">CylinderBuilder</strong></li>
<li><strong class="source-inline">Texture</strong></li>
</ul>
<p>The scene already has a camera placed at -30 units from the origin and pointing at the origin, but it’s going to need a light and something for that light to illuminate as well. Instead of using a cubical mesh as a skybox, as we did with the Loading Screen, we’ll create a conical sort of shape made by making a tube with different radii for each end cap. Applying the Starfield PT to the interior of the cylinder requires us to set <strong class="source-inline">backFaceCulling</strong> to <strong class="source-inline">false</strong>, since we want to see the interior faces. To animate the starfield, we can simply increment the <strong class="source-inline">time</strong> property of <strong class="source-inline">StarfieldProceduralTexture</strong> before every frame is rendered:</p>
<pre class="source-code">&#13;
_setupBackgroundEnvironment() {&#13;
    const light = new HemisphericLight("light", new Vector3&#13;
        (0, 0.5, 0), this._scene);&#13;
    const starfieldPT = new StarfieldProceduralTexture&#13;
        ("starfieldPT", 1024, this._scene);&#13;
    const starfieldMat = new StandardMaterial("starfield", &#13;
        this._scene);&#13;
    const space = CylinderBuilder.CreateCylinder("space", &#13;
          { height: 64, diameterTop: 0, diameterBottom: 64,&#13;
              tessellation: 512 }, &#13;
          this._scene);&#13;
    starfieldMat.diffuseTexture = starfieldPT;&#13;
    starfieldMat.diffuseTexture.coordinatesMode = Texture.&#13;
        SKYBOX_MODE;&#13;
    starfieldMat.backFaceCulling = false;&#13;
    starfieldPT.beta = 0.1;&#13;
    space.material = starfieldMat;&#13;
    return this._scene.onBeforeRenderObservable.add(() =&gt; {&#13;
        starfieldPT.time += this._scene.getEngine().&#13;
            getDeltaTime() / 1000;&#13;
    });&#13;
}</pre>
<p><strong class="source-inline">HemisphericLight</strong> is a type <a id="_idIndexMarker214"/>of light source in Babylon.js that simulates an ambient environment type of lighting. There are a ton of interesting effects that you can achieve by messing around with the combination of <strong class="bold">diffuse</strong>, <strong class="bold">specular</strong>, and, unique to this type of light, <strong class="bold">groundColor</strong>, but we don’t need to do that right now since our needs are pretty simple.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Dividing the scene’s delta time by 1,000 is what sets the rate at which the starfield twinkles and shifts. Try removing the division statement and see what happens!</p>
<p>Finishing up the function, we <a id="_idIndexMarker215"/>are following a similar pattern to what we did when we created the planetary orbits animation for the Loading Screen by registering an <strong class="bold">observer</strong> in <strong class="source-inline">onBeforeRenderObservable</strong> and returning the <strong class="bold">observer</strong> for tidy later disposal. If all went well, clicking the <strong class="bold">Run</strong> button should display a nice picture of our starfield, twinkling and glittering as it slowly shifts. </p>
<p>Click <strong class="bold">Save</strong> and let’s move on! If you find that your snippet isn’t working the way it should be, or are having any other trouble, pull up Playground snippet <strong class="source-inline">#16XY6Z</strong> to see the full code for this snippet at this point in development.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor090"/>Creating the AdvancedDynamicTexture and GUI</h2>
<p>There can be a lot to<a id="_idIndexMarker216"/> take in when it comes to the extensive<a id="_idIndexMarker217"/> functionality present in the Babylon.js 2D GUI system. More extensive documentation on the GUI APIs can be found at <a href="https://doc.babylonjs.com/divingDeeper/gui/gui">https://doc.babylonjs.com/divingDeeper/gui/gui</a>, but what we’re about to do with it now should either refresh your memory or provide enough of a foundation to begin learning. Add new types to the alias list, but instead of putting them in the <strong class="source-inline">BABYLON</strong> object, add a new <strong class="source-inline">BABYLON.GUI</strong> entry that is similar to the <strong class="source-inline">BABYLON</strong> entry, with the following types from the <strong class="source-inline">BABYLON.GUI</strong> namespace:</p>
<ul>
<li><strong class="source-inline">AdvancedDynamicTexture </strong></li>
<li><strong class="source-inline">Rectangle </strong></li>
<li><strong class="source-inline">Image </strong></li>
<li><strong class="source-inline">StackPanel </strong></li>
<li><strong class="source-inline">TextBlock </strong></li>
<li><strong class="source-inline">Control</strong></li>
</ul>
<p>Add a new method called _<strong class="source-inline">setupUi</strong> to <strong class="source-inline">MainMenuClass</strong>, and add a line in the constructor to invoke it at the bottom of the function. </p>
<p>We’re not going to try to do anything fancy with the menu UI right now, so the first thing the _<strong class="source-inline">setupUi</strong> function needs to do is to create an instance of the <strong class="source-inline">BABYLON.GUI.AdvancedDynamicTexture</strong> class in the (default) fullscreen mode. This results in a 2D texture the size of the render canvas, with the controls painted on it, which is rendered on <a id="_idIndexMarker218"/>top of the scene in turn. One <a id="_idIndexMarker219"/>minor tweak we’ll make is to tell the texture to render at its ideal size – this will help avoid fuzziness in rendered text caused by down- or up- sampling effects. To allow other class instance methods to access the texture, assign it to the <strong class="source-inline">_guiMenu</strong> property:</p>
<pre class="source-code">&#13;
const gui = AdvancedDynamicTexture.CreateFullscreenUI("UI");&#13;
gui.renderAtIdealSize = true;&#13;
this._guiMenu = gui;</pre>
<p>Next up, we need to add a <strong class="source-inline">Rectangle</strong> control to contain the actual menu items. We don’t want it to be completely opaque, but it should have a contrasting background color or gradient. </p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>Adding the Menu Container and Background</h2>
<p>For web developers and <a id="_idIndexMarker220"/>designers, there are a lot of what are hopefully comfortingly familiar concepts at play. A GUI control tree is a hierarchy similar to an <strong class="bold">HTML DOM</strong>, where controls can be nested inside of each other, with <a id="_idIndexMarker221"/>siblings inheriting some of their layouts from the parent element or control. In order to be rendered, a control needs to be able to trace its parentage back to <strong class="source-inline">AdvancedDynamicTexture</strong> either directly or indirectly. It’s often easiest to show this rather than describe it, so add the following code to define our menu’s container and basic appearance:</p>
<pre class="source-code">&#13;
        const menuContainer = new Rectangle("menuContainer");&#13;
        menuContainer.width = 0.8;&#13;
        menuContainer.thickness = 5;&#13;
        menuContainer.cornerRadius = 13;&#13;
        this._<strong class="bold">guiMenu.addControl(menuContainer);</strong>&#13;
        this._menuContainer = menuContainer;</pre>
<p>The width is set as a<a id="_idIndexMarker222"/> percentage of the canvas size (<strong class="source-inline">0.8</strong>) so that the menu doesn’t cover the entire background, while the border width (thickness) is in pixels and the corner radius is specified in degrees – got all that? </p>
<p class="callout-heading">Tip</p>
<p class="callout">Intellisense can be your best friend in providing quick descriptions of the numerous properties available on GUI controls, particularly when it comes to determining which units are in use (e.g., pixels or percentage). </p>
<p>Next, we want to add<a id="_idIndexMarker223"/> an Image control to hold the background of the menu. Apropos of the Image, it’s easy to create a nice background image texture, but what use is it if it can’t be seen in the Playground? So, it’s time for a magic trick…</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Image Aside: Bringing in External Content</h2>
<p>The Babylon.js Playground <a id="_idIndexMarker224"/>has a feature configured in its web server’s configuration to allow <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) of content served <a id="_idIndexMarker225"/>from a number of well-known and established repository hosts, such as GitHub. By crafting the appropriate URL to our source repository, we can load textures, sounds, and models in our Playground snippet – just as with the <strong class="bold">Babylon.js Asset Libraries</strong>! By way of demonstrating how this works, add the following line to the very top of the snippet (first line):</p>
<pre class="source-code">&#13;
const menuBackground = https://raw.githubusercontent.com/jelster/space-truckers/ch4/assets/menuBackground.png&#13;
     + "?" + Number(new Date());</pre>
<p>Breaking the URL down, here’s how you can apply this tactic to any publicly hosted GitHub repository:</p>
<ol>
<li value="1">Starting with the base URL of <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a>, add the path segments (in order) for the repository owner (or owning Organization) name, and the name of the repository itself – for example, <strong class="source-inline">raw.githubusercontent.com/jelster/space-truckers</strong>.</li>
<li>Next, add a path segment for the name of the branch or tag from which to retrieve the asset. For this book, the assets will be listed in their chapter’s respective branch, but for many other repositories, this will be <strong class="source-inline">main</strong>, <strong class="source-inline">master</strong>, or possibly <strong class="source-inline">develop</strong>.</li>
<li>Finally, add the rest of the path to the asset, including the file extension. Because there are pretty robust caching headers accompanying the responses for these files, it’s often a good idea during active content production to append a cache-using string such<a id="_idIndexMarker226"/> as the current date and time to the end of the URL so that you can be sure you’re always seeing the most current version of the file.</li>
</ol>
<p>Using the <strong class="source-inline">menuBackground</strong> URL, create an <strong class="source-inline">Image</strong> and add it to the <strong class="source-inline">menuContainer</strong> we previously added:</p>
<pre class="source-code">&#13;
        const menuBg = new Image("menuBg", menuBackground);&#13;
        menuContainer.addControl(menuBg);</pre>
<p>Test out your progress by clicking <strong class="bold">Run</strong>, fixing any issues, then of course make sure to <strong class="bold">Save</strong> the snippet. To check yourself or to start with the latest snippet for this chapter, use <strong class="bold">#16XY6Z#1</strong>. This is how it should look:</p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and a semi-opaque gradient-filled rectangle that will contain menu items&#13;&#10;" height="1013" src="image/Figure_4.04_B17266.jpg" width="972"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The main menu at #16XY6Z#1 has the Starfield PT background and a semi-opaque gradient-filled rectangle that will contain menu items</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Laying out the Title and Menu Items</h2>
<p>Referring back to <em class="italic">Figure 4.2</em>, we can see<a id="_idIndexMarker227"/> that the menu screen can be divided up into a grid with two rows – one for the title and one for the menu items. To ensure that the buttons and selection icons all line up the way we want them to, we’ll need the grid to have three columns, each one-third of the width of the grid (which itself has a width of 0.8 or 80%). <strong class="bold">Grid</strong> has the <strong class="source-inline">addColumnDefinition</strong> and <strong class="source-inline">addRowDefinition</strong> methods to accomplish this, making the setup very simple to add to our <strong class="source-inline">_setupUi</strong> method:</p>
<pre class="source-code">&#13;
        const menuGrid = new GUI.Grid("menuGrid");&#13;
        menuGrid.addColumnDefinition(0.33);&#13;
        menuGrid.addColumnDefinition(0.33);&#13;
        menuGrid.addColumnDefinition(0.33);&#13;
        menuGrid.addRowDefinition(0.5);&#13;
        menuGrid.addRowDefinition(0.5);&#13;
        menuContainer.addControl(menuGrid);        &#13;
        this._menuGrid = menuGrid;</pre>
<p>The title text is an important factor in defining a game or application’s look and feel through its font and display, but we’re going to be circling back to that topic in <a href="B17266_07_Final_AM.xhtml#_idTextAnchor142"><em class="italic">Chapter 7</em></a><em class="italic">, Processing Route Data</em>. For now, we’ll use the default font <a id="_idIndexMarker228"/>and ensure that it auto-sizes the text as needed. Vertically aligning <strong class="source-inline">TextBlock</strong> with the top of the grid will ensure that no matter how many buttons there are, the title will always stay where it belongs. A bit of styling to add shadows and padding results in code similar to this:</p>
<pre class="source-code">&#13;
        const titleText = new TextBlock("title", "Space-&#13;
            Truckers");&#13;
        titleText.resizeToFit = true;&#13;
        titleText.textWrapping = GUI.TextWrapping.Ellipse;&#13;
        titleText.fontSize = "72pt";&#13;
        titleText.color = "white";&#13;
        titleText.width = 0.9;&#13;
        titleText.verticalAlignment = Control.&#13;
            VERTICAL_ALIGNMENT_TOP;&#13;
        titleText.paddingTop = titleText.paddingBottom = &#13;
            "18px";&#13;
        titleText.shadowOffsetX = 3;&#13;
        titleText.shadowOffsetY = 6;&#13;
        titleText.shadowBlur = 2;&#13;
        menuContainer.addControl(titleText);</pre>
<p>Check your work by running it and then save your progress. For those following along, this can be found at <strong class="bold">#16XY6Z#2</strong>. The next<a id="_idIndexMarker229"/> task is to write some functionality to populate the menu with selectable button items. We’ll be doing a bunch of these, so the less we have to repeat ourselves, the more keystrokes we can save.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Populating the Menu with Items</h2>
<p>Similar to how we <a id="_idIndexMarker230"/>added and then implemented the <strong class="source-inline">_setupUi</strong> function, we’ll start our latest task by adding an <strong class="source-inline">_addMenuItems</strong> function and constructor invocation expression to our class. We know that we want all the buttons of the menu to share a certain subset of property values, but not all of them. The properties that are unique to a given instance of a menu item can be defined by a simple object such as the following one defining the <strong class="bold">Play</strong> button’s properties:</p>
<pre class="source-code">&#13;
const pbOpts = {&#13;
    name: "btPlay",&#13;
    title: "Play",&#13;
    background: "red",&#13;
    color: "white",&#13;
    onInvoked: () =&gt; console.log("Play button clicked")&#13;
};</pre>
<p>A button needs to have a unique name and it also needs some text to display. The foreground and background colors ought to be specific to each item, and of course, the action that is taken when the button is selected certainly qualifies as being specific to a given button. Within the <strong class="source-inline">_addMenuItems</strong> definition but before the <strong class="source-inline">pbOpts</strong> expression, add this local helper<a id="_idIndexMarker231"/> function to create and populate a button control with the given properties:</p>
<pre class="source-code">&#13;
function createMenuItem(opts) {&#13;
    const btn = Button.CreateSimpleButton(opts.name || "", &#13;
        opts.title);&#13;
    btn.color = opts.color || "white";&#13;
    btn.background = opts.background || "green";&#13;
    btn.height = "80px";&#13;
    btn.thickness = 4;&#13;
    btn.cornerRadius = 80;&#13;
    btn.shadowOffsetY = 12;&#13;
    btn.horizontalAlignment = Control.&#13;
        HORIZONTAL_ALIGNMENT_CENTER;&#13;
    btn.fontSize = "36pt";&#13;
    if (opts.onInvoked) {&#13;
        btn.onPointerClickObservable.add((ed, es) =&gt; &#13;
            opts.onInvoked(ed, es));&#13;
    }&#13;
    return btn;&#13;
}</pre>
<p>With the button returned from our helper method, there’s just the matter of adding it to the menu grid:</p>
<pre class="source-code">&#13;
const playButton = createMenuItem(pbOpts);&#13;
this._menuGrid.addControl(playButton, this._menuGrid.&#13;
    children.length, 1);</pre>
<p>Unlike the same functions of its <strong class="bold">Control</strong> relatives, the <strong class="source-inline">addControl</strong> function of <strong class="bold">Grid</strong> accepts an optional <strong class="bold">row</strong> and <strong class="bold">column</strong> assignment as its second and third parameters, respectively. This lets us insert an item in the last row without knowing its index by getting the count of its child rows. We want buttons to be centered, so the column will always be the same – one. </p>
<p>Finish the buttons by <a id="_idIndexMarker232"/>adding an exit button according to these options, and don’t forget to <strong class="bold">Save</strong>! To compare with the checkpoint snippet, see <strong class="bold">#16XY6Z#3</strong>:</p>
<pre class="source-code">&#13;
const ebOpts = {&#13;
    name: "btExit",&#13;
    title: "Exit",&#13;
    background: "yellow",&#13;
    color: "black",&#13;
    onInvoked: () =&gt; console.log("Exit button clicked")&#13;
}</pre>
<p>We’ve come a long way in this chapter, but we’re not quite done yet. There’s been a lot of different things that we’ve been juggling so far, and all of the functionality we plan to build is completed – now, we just need to incorporate this functionality into the rest of our code.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Adding Menu Item Selection and Indicators</h2>
<p>Although there are a chunk of <a id="_idIndexMarker233"/>players who will want to and enjoy using a keyboard and mouse to play Space-Truckers, it should also be an enjoyable experience <a id="_idIndexMarker234"/>with a gamepad. In the next chapter, we’ll look at how to work with gamepad input in more detail, and to prepare for that, we need the main menu’s items to be selectable without invoking their actions and without the presence of a mouse pointer hovering over them. A selection indicator icon will serve this purpose, displaying the icon next to the currently selected menu item and showing the player what command or option will be invoked on the appropriate button press.</p>
<p>Before we get to the visual aspect of the selected item, let’s add some supporting properties to our class in the form of a get and set pair of functions that we’ll call <strong class="source-inline">selectedItemIndex</strong>. Retrieving the value is simple using <strong class="source-inline">return this_selectedItemIndex</strong>. Setting it is a little bit more complicated. We want to ensure that the index doesn’t exceed<a id="_idIndexMarker235"/> the number of menu items and that upon reaching the end of the menu items, we want it to start over at the first item. There are other things that we want to enact <a id="_idIndexMarker236"/>when the selected item index changes, but a set method is not the place to do anything more than simple logic, as follows:</p>
<pre class="source-code">&#13;
   get selectedItemIndex() {&#13;
       return this._selectedItemIndex || -1;&#13;
   }   &#13;
   set selectedItemIndex(idx) {&#13;
        const itemCount = this._menuGrid.rowCount;&#13;
        const newIdx = Scalar.Repeat(idx, itemCount);&#13;
        this._selectedItemIndex = newIdx;&#13;
        <strong class="bold">this._selectedItemChanged.notifyObservers(newIdx);</strong>&#13;
    }</pre>
<p>We saw the usage of <strong class="source-inline">Scalar.Repeat</strong> earlier, when animating planetary orbits. Then, we used it to ensure that the radian values stayed smoothly circular. Similarly, we want the selection to loop around smoothly once it reaches the end. The new item (highlighted in the preceding code) is for a class member that we haven’t yet declared, the <strong class="source-inline">_selectedItemChanged</strong> Observer. </p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Indicating Selection and Reacting to Change</h2>
<p>Calling the <strong class="bold">Observer</strong> something new is a<a id="_idIndexMarker237"/> bit of a misnomer; we’ve been using <a id="_idIndexMarker238"/>the Babylon.js <strong class="bold">Observable</strong> since the very second chapter, when we used <strong class="source-inline">scene.onBeforeRenderObservable</strong>. This time, however, we’re not using a built-in observable on a BJS object, but one that we’re declaring ourselves. The usage semantics are exactly the same as they are for the other ones we’ve used – calling the <strong class="source-inline">add()</strong> method to register a function to be invoked whenever the observable is triggered. Creating the observable is just as simple, done by creating a new <strong class="bold">Observable</strong> instance. At the end of the <strong class="source-inline">MainMenuScene</strong> constructor, add code to create the <strong class="source-inline">_selectedItemChanged</strong> observable, then call its add method to register our selection’s changed logic:</p>
<pre class="source-code">&#13;
this._selectedItemChanged = new Observable();&#13;
this._selectedItemChanged.add((idx) =&gt; {&#13;
    const menuGrid = this._menuGrid;&#13;
    const selectedItem = menuGrid.getChildrenAt(idx, 1);&#13;
    if (selectedItem[0].isEnabled !== true) {&#13;
        this.selectedItemIndex = 1 + idx;&#13;
    }&#13;
    this._selectorIcon.isVisible = true;&#13;
    menuGrid.removeControl(this._selectorIcon);&#13;
    menuGrid.addControl(this._selectorIcon, idx);&#13;
});</pre>
<p>When the selection changes, the event handler is passed the newly-selected item’s index – its row in the grid. Sometimes, we might want to display non-selectable menu items, so we retrieve the <a id="_idIndexMarker239"/>selected item and then check the item retrieved from the second column of the selected row to see whether it’s <strong class="source-inline">isEnabled</strong>. If that’s not the case, then we increment <strong class="source-inline">selectedItemIndex</strong> – making<a id="_idIndexMarker240"/> sure to use the property setter and not directly changing the backing field’s value. The last part of our event handler again represents something we haven’t added yet – the selection icon. This hides the icon first before removing it from the grid and re-adding it at the new position. Moving backward now, again, add a method call to <strong class="source-inline">this._createSelectorIcon()</strong> to the <strong class="source-inline">constructor</strong>, then add the eponymous function declaration to the class. Here’s how the body of the function should look:</p>
<pre class="source-code">&#13;
_createSelectorIcon() {&#13;
    const selectorIcon = new BABYLON.GUI.Image&#13;
        ("selectorIcon", selectionIcon);&#13;
    selectorIcon.width = "160px";&#13;
    selectorIcon.height = "60px";&#13;
    selectorIcon.horizontalAlignment = Control.&#13;
        HORIZONTAL_ALIGNMENT_CENTER;&#13;
    selectorIcon.shadowOffsetX = 5;&#13;
    selectorIcon.shadowOffsetY = 3;&#13;
    selectorIcon.isVisible = false;&#13;
    this._menuGrid.addControl(selectorIcon, 1, 0);&#13;
    this._selectorIcon = selectorIcon;&#13;
}</pre>
<p>This creates a new <strong class="source-inline">GUI.Image</strong> using the final undeclared constant, the <strong class="source-inline">selectionIcon</strong> URL string. The<a id="_idIndexMarker241"/> rest of the method is boilerplate code we’ve written in the not-so-distant past.</p>
<p class="callout-heading">Note</p>
<p class="callout">To avoid ambiguity with the HTML DOM Image type, the fully-qualified name is used in the Playground.</p>
<p>Wrap up the penultimate<a id="_idIndexMarker242"/> task of this section by adding the <strong class="source-inline">selectionIcon</strong> URL string at the top of the snippet: </p>
<pre class="source-code">&#13;
const selectionIcon = "https://raw.githubusercontent.com/jelster/space-truckers/ch4/assets/ui-selection-icon.PNG" + "?" + Number(new Date());<strong class="source-inline"> </strong></pre>
<p>Feel free to substitute your image of choice for the one in the repository, and if you want to see it used in the production<a id="_idIndexMarker243"/> game, send us a <strong class="bold">Pull Request</strong> with it! Finally, we want to automatically select the first item in the menu, but only after the scene has completely finished loading and is waiting for user input. We do that by adding a simple line to the end of our constructor:</p>
<pre class="source-code">&#13;
scene.whenReadyAsync().then(() =&gt; this.selectedItemIndex = 0);</pre>
<p>Clicking <strong class="bold">Run</strong> should show a finely crafted main menu – click <strong class="bold">Save</strong> and congratulate yourself. Look at how much you’ve accomplished during just this one pretty small section of one chapter of a (relatively) short book and contemplate how far you’ll be by the end! To compare your code for<a id="_idIndexMarker244"/> troubleshooting or catching up, see snippet <strong class="bold">#16XY6Z#4</strong>. The Main<a id="_idIndexMarker245"/> Menu looks nice, but despite the starfield twinkling in the background, it still needs a little bit of motion to give it some life and energy. Let’s be honest too – hornet yellow for the <strong class="bold">Exit</strong> button isn’t really the look we’re aiming for either, so let’s take a moment to correct those matters before moving on. </p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Visual Improvements and Animating the Selection Idle</h2>
<p>The easiest change we want is to set the color property of our <strong class="source-inline">ebOpts</strong> object, all the way down in the <strong class="source-inline">_createMenuItems</strong> method, to the string color <strong class="bold">black</strong>. For the next change, we will add a <a id="_idIndexMarker246"/>small animation to the selection icon to make it look as though the truck is floating next to the <a id="_idIndexMarker247"/>menu item. This is a two-step process and the components of each individual step should be familiar from recent usage.</p>
<p>First, we need to track the current animation frame for the icon with a class member named <strong class="source-inline">_selectorAnimationFrame</strong>. Second, we need to register an <strong class="source-inline">onBeforeRenderObservable</strong> that will execute a new function, <strong class="source-inline">_selectorIconAnimation</strong>, before every frame is rendered in the scene. In that function, we increment the current frame (looping around if necessary) and use that value to compute the position of the icon along the vertical axis according to our circular standby – the <strong class="bold">sine</strong> function. This is what the animation function should resemble:</p>
<pre class="source-code">&#13;
_selectorIconAnimation() {&#13;
    const animTimeSeconds = Math.PI * 2;&#13;
    const dT = this._scene.getEngine().&#13;
        getDeltaTime() / 1000;&#13;
    this._selectorAnimationFrame = Scalar.Repeat(this._&#13;
    selectorAnimationFrame + dT * 5, animTimeSeconds * 10);&#13;
    this._selectorIcon.top = Math.sin(this.&#13;
        _selectorAnimationFrame).toFixed(0) + "px";&#13;
}</pre>
<p>The total time that it takes to go through a complete animation cycle is given by the first expression, while the amount<a id="_idIndexMarker248"/> of time (in seconds) elapsed since the last frame was rendered is given by the second. As we did before with <strong class="bold">Scalar</strong> in <strong class="source-inline">set selectedItemIndex</strong>, we loop <strong class="source-inline">_selectorAnimationFrame</strong> here <a id="_idIndexMarker249"/>when it reaches the frame count, but we are scaling some values by arbitrary factors at the same time to yield the new <strong class="source-inline">top</strong> position (in pixels) that is set in the final line. Running this should result in a much more pleasing color for the <strong class="bold">Exit</strong> button as well as displaying a nice subtle floating appearance for the truck selection icon.</p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 4.5 – The Main Menu snippet complete with the floating animation of a truck icon" height="1012" src="image/Figure_4.05_B17266.jpg" width="973"/>
</div>
</div>
<p class="IMG---Figure"><span lang="en-US" xml:lang="en-US">Figure 4.5 – The Main Menu snippet complete with the floating animation of a truck icon</span></p>
<p>If this is starting to<a id="_idIndexMarker250"/> feel repetitive, then that’s good, because it means<a id="_idIndexMarker251"/> that the material in this book is starting to sink in! Snippet <strong class="bold">#16XY6Z#5</strong> has the latest code; if you’ve not prepared your own, then navigate to this one and make sure you have VSCode open and ready to accept the application’s sparkling new Main Menu.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Integrating the Main Menu</h1>
<p>Despite the potentially intimidating heading, there’s really not a whole lot we’ll need to do in order to incorporate all of the work from our snippets into the application’s code structure. In fact, after all <a id="_idIndexMarker252"/>of the effort and journeying we’ve done throughout this chapter, it may feel a bit anti-climactic when we finish this part of the work. </p>
<p>The most straightforward and simple way to do it is to copy and paste the whole of the <strong class="source-inline">MainMenuScene</strong> class from the snippet into your local file, making sure to <em class="italic">entirely</em> replace the existing class declaration. You’ll need to only slightly adjust your <strong class="source-inline">import</strong> statements; here are the two most relevant lines where this changes:</p>
<pre class="source-code">&#13;
import { Scene, Vector3, <strong class="bold">Scalar</strong>, <strong class="bold">Observable</strong>, Sound, HemisphericLight } from "@babylonjs/core";&#13;
import { AdvancedDynamicTexture, Rectangle, Image, Button, Control, TextBlock, <strong class="bold">Grid</strong>, TextWrapping } from "@babylonjs/gui";</pre>
<p>For the selection icon image asset, download the one at the snippet’s URL or make your own. Either way, add an <strong class="source-inline">import</strong> statement for it as well:</p>
<pre class="source-code">&#13;
import selectionIcon from "../assets/&#13;
    ui-selection-icon.PNG";</pre>
<p>Either wait for the development webpack output to finish or run the webpack process to test your changes, and don’t forget to commit and push your work – there’s no reason to lose work due to the omission of a few keystrokes. Earlier, when we went over our State Machine, we learned that in addition to the state behaviors, it’s important to define the transitions to and from those states.On the topic of transitions, here's one now! </p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Entering and Leaving Transitions</h2>
<p>When we’re looking at the<a id="_idIndexMarker253"/> integration of our Main Menu with the SpaceTruckerApplication State Machine, there are two functions that we’ve yet to implement and wire up. Those functions are the two transition functions for the main menu. In other words, we need to define the logic for what happens when we transition to the MENU state, as well as out of that state. Naming these new functions is actually pretty easy for once – <strong class="source-inline">_onMenuEnter</strong> and <strong class="source-inline">_onMenuLeave</strong>. While there might be more involved behavior we’d like to implement later, for now, we will say that when the menu either starts or ceases to be the current state of the application, we want it to fade in or out accordingly. </p>
<p>The simplest way to accomplish this is by animating the <strong class="source-inline">menuContainer.alpha</strong> property between either <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> (entering) or <strong class="source-inline">1</strong> to <strong class="source-inline">0</strong> (leaving). As with the selection icon animation, we’ll need to store the current frame of <strong class="source-inline">fadeIn</strong> and <strong class="source-inline">fadeOut</strong>. Unlike the selection icon animation, we have a finite amount of time that the animation should last, so we also need to store the total <strong class="source-inline">duration</strong> value of the transition. Between every frame, we should <a id="_idIndexMarker254"/>set the current <strong class="source-inline">alpha</strong> value to one that is only slightly different from the previous value, so the transition appears smooth. Finally, when the animation ends, we want to (in the case of the leaving transition) set the menu’s visibility to <strong class="source-inline">false</strong>, along with any other clean-up that needs to happen. Interestingly enough, the logic for the enter and leave transitions is identical save for swapping the ranges in the <strong class="source-inline">SmoothStep</strong> function used to interpolate the <strong class="source-inline">alpha</strong> value. Here’s the <strong class="source-inline">_onMenuEnter</strong> function:</p>
<pre class="source-code">&#13;
_onMenuEnter(duration) {&#13;
    let fadeIn = 0;&#13;
    const fadeTime = duration || 1500;&#13;
    const timer = BABYLON.setAndStartTimer({&#13;
        timeout: fadeTime,&#13;
        contextObservable: this._scene.&#13;
            onBeforeRenderObservable,&#13;
        onTick: () =&gt; {&#13;
            const dT = this._scene.getEngine().&#13;
                getDeltaTime();&#13;
            fadeIn += dT;&#13;
            <strong class="bold">const currAmt = Scalar.SmoothStep(0, 1, fadeIn </strong>&#13;
<strong class="bold">                / fadeTime);</strong>&#13;
            this._menuContainer.alpha = currAmt;&#13;
        },&#13;
        onEnded: () =&gt; {&#13;
            this.selectedItemIndex = 0;&#13;
        }&#13;
    });&#13;
    return timer;&#13;
}</pre>
<p>Instead of using the standard timer creation method in JavaScript of calling <strong class="source-inline">setTimeout</strong>, we’re using the <strong class="source-inline">BABYLON.setAndStartTimer</strong> utility function. By attaching <strong class="source-inline">contextObservable</strong> to <strong class="source-inline">scene.onBeforeRenderObservable</strong>, the <strong class="source-inline">onTick</strong> method is called consistently before each frame is rendered. The <strong class="source-inline">onEnded</strong> function is invoked <a id="_idIndexMarker255"/>when the name implies – after the timer has completed. In our case, we want to wait until the menu has transitioned in fully before showing the selection icon, so we set the <strong class="source-inline">selectedItemIndex</strong> there. In the constructor, we can replace the callback used with <strong class="source-inline">scene.whenReadyAsync</strong> to call our <strong class="source-inline">onMenuEnter</strong> function as follows:</p>
<pre class="source-code">&#13;
       scene.whenReadyAsync().then(() =&gt; this._onMenuEnter());</pre>
<p>Save the file and run the app. You should see the menu fade in over the course of a couple of seconds before the selection item shows up. Learn more about this and other related functionality at https://doc.babylonjs.com/divingDeeper/events/observables#setandstarttimer, but maybe wait a tiny bit to do that – it’s time to finish off this chapter! </p>
<p>The <strong class="source-inline">onMenuLeave</strong> function is, as was mentioned earlier, almost identical to its <strong class="source-inline">onMenuEnter</strong> counterpart (with the exception of the <strong class="source-inline">onEnded</strong> callback), just swapping terms in <strong class="source-inline">SmoothStep</strong> (as follows). Add the <strong class="source-inline">onMenuLeave</strong> function with the changed expression:</p>
<pre class="source-code">&#13;
const currAmt = Scalar.SmoothStep(1, 0, fadeOut / fadeTime);</pre>
<p>Hooking up the <strong class="bold">Exit</strong> button to <strong class="source-inline">onMenuLeave</strong> is easy: in the <strong class="source-inline">_addMenuItems</strong> method’s <strong class="source-inline">ebOpts</strong> object definition, change the <strong class="source-inline">onInvoked</strong> function to look something similar to the following:</p>
<pre class="source-code">&#13;
onInvoked: () =&gt; {&#13;
    console.log("Exit button clicked");&#13;
    this._onMenuLeave(1000);&#13;
}</pre>
<p>Save again and test <a id="_idIndexMarker256"/>your work to ensure it’s behaving as expected. This is looking and behaving excellently, but before we can pull over and rest, there’s one last thing left to accomplish.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Menu Finishing Touches</h2>
<p>It’s a bit too quiet here for<a id="_idIndexMarker257"/> what should be an engaging and interesting main menu screen. We can fix that though, with the power of music! Although we’ll be covering the playing of sounds and music in more detail later, it’s too simple to pass the opportunity up, so here’s the quick and dirty version in as few words as <a id="_idIndexMarker258"/>possible: </p>
<h3>Add an import statement</h3>
<pre class="source-code">&#13;
import titleMusic from "../assets/sounds/space-trucker-title-theme.m4a";</pre>
<h3>Load and play the music from the constructor</h3>
<pre class="source-code">&#13;
this._music = new Sound("titleMusic", titleMusic, scene, () =&gt; console.log("loaded title music"), { autoplay: true, loop: true, volume: 0.5 });</pre>
<h3>Enjoy the vibes</h3>
<pre class="source-code">&#13;
&lt;enjoy the music&gt; </pre>
<p>OK, so maybe<a id="_idIndexMarker259"/> the last part is getting a bit carried away; we do want to stop the music at some point. In the <strong class="source-inline">onEnded</strong> callback of <strong class="source-inline">_onMenuLeave</strong>, call <strong class="source-inline">this._music.stop()</strong> to stop the sound from playing when the <strong class="bold">Exit</strong> button is clicked. Once you’ve run the app and corrected any issues, it’s time<a id="_idIndexMarker260"/> to commit changes to source control and have a nice refreshing beverage – we’ve completed the chapter! </p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Summary</h1>
<p>What a journey we’ve taken during this chapter. Some might prefer to think of it as more of a slog, and that’s not unfair – we’ve been wading through some pretty dense material here! Despite there being a fair bit of theory and high-level concepts tossed around, think back to what’s been accomplished over the course of this chapter – where we started was with a landing page that launches into an animation. Now, we have a landing page that launches into an <em class="italic">application</em>. </p>
<p>Coming up next, we’re going to look at how to address the problem of accepting different forms and methods of input in a way that produces consistent and predictable behavior from the application – stick with us, and don’t be afraid to take your time to go back and re-read anything you didn’t understand the first time around. It’s amazing how much comprehension can require multiple passes to really take hold, but if that’s not working and you find you’re struggling to understand or follow along, no worries. Navigate to the Space-Trucker Discussions or the Babylon.js forums and post your question or problem to the community – you aren’t alone!</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Extended Topics</h1>
<p>Things are just getting some momentum, but that doesn’t mean there isn’t more to explore and extend what we’ve got already! Here are some ideas for things that you might look at, explore, or build into this chapter’s code:</p>
<ul>
<li>Create or extend the regular Babylon.js <strong class="bold">Animation</strong> type’s capabilities to include 2D <strong class="bold">GUI</strong> controls – or – implement a class that mimics the behavior of the Animation object with <strong class="bold">GUI</strong> controls.</li>
<li>Can you spot the defect in the <strong class="source-inline">SpaceTruckerLoadingScreen.js</strong> code? It’s a bit subtle if you’re reading through it in your head, but there’s definitely a logical defect in the code. Running it won’t cause any errors to be thrown but it does have effects that are visible at runtime under the right conditions.</li>
<li>Instead of using a single, full-screen <strong class="source-inline">AdvancedDynamicTexture</strong>, use one or more mesh-attached textures that are painted onto the meshes in the scene, which can then be animated in interesting ways.</li>
<li>Add an attract mode that engages after the Main Menu has been displayed without user input for more than 30 seconds. An attract mode was an arcade game feature that puts the game into a non-interactive demo mode intended to catch the attention of passers-by. What is your idea for an attract mode?</li>
</ul>
</div>
<div>
<div id="_idContainer038">
</div>
</div>
</div></body></html>