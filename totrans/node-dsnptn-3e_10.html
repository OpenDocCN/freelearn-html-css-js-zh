<html><head></head><body>
  <div id="_idContainer204">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-268" class="chapterTitle">Universal JavaScript for Web Applications</h1>
    <p class="normal">JavaScript was born with the goal of giving web developers the power to execute code directly on the browser and build dynamic and interactive websites.</p>
    <p class="normal">Since its inception, JavaScript has grown up a lot. If, at the very beginning, JavaScript was a very simple and limited language, today, it can be considered a complete general-purpose language that can be used even outside the browser to build almost any kind of application. In fact, JavaScript now powers frontend applications, web servers, and mobile applications, as well as embedded devices such as wearable devices, thermostats, and flying drones.</p>
    <p class="normal">The language's availability across platforms and devices is fostering a new trend among JavaScript developers: being able to simplify code reuse across different environments in the same project. With Node.js, developers have the opportunity to build web applications where it is easy to share code between the server (backend) and the browser (frontend). This quest for code reuse was originally identified with the term <strong class="keyword">Isomorphic JavaScript</strong>, but today, it's mostly recognized as <strong class="keyword">Universal JavaScript</strong>.</p>
    <p class="normal">In this chapter, we are going to explore the wonders of Universal JavaScript, specifically in the field of web development, and discover many tools and techniques we can use to share code between the server and the browser.</p>
    <p class="normal">We will explore what a module bundler is and why we need one. We will then learn how module bundlers work and we will practice with one of the most popular, webpack. Then, we will discuss some generic patterns that can help us with code reuse across platforms.</p>
    <p class="normal">Finally, we will learn the basic functionalities of React and we will use it to build a complete Universal JavaScript application that features universal rendering, universal routing, and universal data loading.</p>
    <p class="normal">To summarize, here's a list of topics we will be covering in this chapter:</p>
    <ul>
      <li class="Bullet--PACKT-">How to share code between the browser and Node.js</li>
      <li class="Bullet--PACKT-">Fundamentals of cross-platform development (code branching, module swapping, and other useful patterns)</li>
      <li class="Bullet--PACKT-">A brief introduction to React</li>
      <li class="Bullet-End--PACKT-">How to build a complete Universal JavaScript application using React and Node.js</li>
    </ul>
    <p class="normal">Sit tight, this is going to be an exciting chapter!</p>
    <h1 id="_idParaDest-269" class="title">Sharing code with the browser</h1>
    <p class="normal">One<a id="_idIndexMarker861"/> of the main selling points of Node.js is the fact that it's based on<a id="_idIndexMarker862"/> JavaScript and runs on V8, a JavaScript engine that actually powers some of the most popular browsers: Google Chrome and Microsoft Edge. We might think that sharing the same JavaScript engine is enough to make sharing code between Node.js and the browser an easy task; however, as we will see in this chapter, this is not always true, unless we want to share only simple, self-contained, and generic fragments of code.</p>
    <p class="normal">Developing code for both the client and the server requires a non-negligible level of effort in making sure that the same code can run properly in two environments that are intrinsically different. For example, in Node.js, we don't have the DOM or long-living views, while on the browser, we surely don't have the filesystem and many other interfaces to interact with the underlying operating system.</p>
    <p class="normal">Another contention point is the level of support for modern JavaScript features. When we target Node.js, we can safely adopt modern language features because we know which Node.js version runs on our servers. For instance, for our server code, we can safely decide to adopt async/await if we know it will run on Node.js version 8 (or on a more recent version). Unfortunately, we can't have the same confidence when writing JavaScript code for the browser. </p>
    <p class="normal">This is because different users will have different browsers with different levels of compatibility with the latest language features. Some users might be using a modern browser with full support for async/await, while other users might still be using an old device with an old browser that does not support async/await.</p>
    <p class="normal">So, most of the effort required when developing for both platforms is to make sure to reduce those differences to a minimum. This can be done with the help of abstractions, patterns, and tools that enable the application to switch, dynamically or at build time, between browser-compatible code and Node.js code.</p>
    <p class="normal">Luckily, with the rising interest in this new mind-blowing possibility, many libraries and frameworks in the ecosystem have started to support both environments. This evolution is also backed by a growing number of tools supporting this new kind of workflow, which, over the years, have been refined and perfected. This means that if we are using an npm package on Node.js, there is a good probability that it will work seamlessly on the browser as well. However, this is often not enough to guarantee that our application can run without<a id="_idIndexMarker863"/> problems on both the browser and Node.js. As we will see, a <a id="_idIndexMarker864"/>careful design is always needed when developing cross-platform code.</p>
    <p class="normal">In this section, we are going to explore the fundamental problems we might encounter when writing code for both Node.js and the browser, and we are going to propose some tools and patterns that can help us with tackling this new and exciting challenge.</p>
    <h2 id="_idParaDest-270" class="title">JavaScript modules in a cross-platform context</h2>
    <p class="normal">The first wall we <a id="_idIndexMarker865"/>hit when we want to share some code<a id="_idIndexMarker866"/> between the browser and the server is the mismatch between the module system used by Node.js and the heterogeneous landscape of the module systems used on the browser. Another problem is that on the browser, we don't have a <code class="Code-In-Text--PACKT-">require()</code> function or the filesystem from which we can resolve modules. Most modern browsers support <code class="Code-In-Text--PACKT-">import</code> and ES modules, but again, some of the users visiting our website might not have already adopted one of those modern browsers.</p>
    <p class="normal">In addition to these problems, we have to take into account the differences in distributing code for the server and the browser. On the server, modules are loaded directly from the filesystem. This is generally a performant operation and therefore developers are encouraged to split their code into small modules to keep the different logic units small and organized.</p>
    <p class="normal">On the browser, the script loading model is totally different. The process generally starts with the browser downloading an HTML page from a remote endpoint. The HTML code is parsed by the browser, which might find references to script files that need to be downloaded and executed. If we are dealing with a large application, there might be many scripts to download, so the browser will have to issue a significant number of HTTP requests and download and parse multiple script files before the application can be fully initialized. The higher the number of script files, the larger the performance penalty that we will have to pay to run an application on the browser, especially on slow networks. Even though some of this performance penalty can be mitigated with the adoption <a id="_idIndexMarker867"/>of <strong class="keyword">HTTP/2 Server Push</strong> (<a href="http://nodejsdp.link/http2-server-push"><span class="url">nodejsdp.link/http2-server-push</span></a>), client-side caching, preloading, or similar techniques, the underlying problem still stands: having to receive and parse a large number of files is generally worse than having to deal with a few optimized files.</p>
    <p class="normal">A common practice to<a id="_idIndexMarker868"/> address this problem is to "build" packages (or <strong class="keyword">bundles</strong>) for the browser. A typical build process will collate all the source files into a <a id="_idIndexMarker869"/>very small number of bundles (for instance, one JavaScript file per page) so that the browser won't have to download a huge number of scripts for each page visit. A build process is not limited to just reducing the number of files, in fact, it can perform other interesting optimizations. Another common optimization is <em class="italic">code minification</em>, which allows us to reduce the number of characters to a minimum <a id="_idIndexMarker870"/>without altering the functionality. This is generally done by removing comments, removing unused code, and renaming function and variable names.</p>
    <h3 id="_idParaDest-271" class="title">Module bundlers</h3>
    <p class="normal">If we want to write<a id="_idIndexMarker871"/> large portions of code that can work as seamlessly as possible both on the server and on the browser, we need a tool to help us with "bundling" all the dependencies together at build time. These tools are generally called <strong class="keyword">module bundlers</strong>. Let's visualize this with an example of how shared code can be loaded on to the server and the client using a module bundler:</p>
    <figure class="mediaobject"><img src="../Images/B15729_10_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.1: Loading shared modules on the server and on the browser (using a module bundler)</p>
    <p class="normal">By looking at <em class="italic">Figure 10.1</em>, we can see that the code is processed and loaded differently on the server side and on the browser:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">On the server side</strong>: Node.js can directly execute our <code class="Code-In-Text--PACKT-">serverApp.js</code>, which, in turn, will import the modules <code class="Code-In-Text--PACKT-">moduleA.js</code>, <code class="Code-In-Text--PACKT-">moduleB.js</code>, and <code class="Code-In-Text--PACKT-">moduleC.js</code>.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">On the browser</strong>: We have <code class="Code-In-Text--PACKT-">browserApp.js</code>, which also imports <code class="Code-In-Text--PACKT-">moduleA.js</code>, <code class="Code-In-Text--PACKT-">moduleB.js</code>, and <code class="Code-In-Text--PACKT-">moduleC.js</code>. If our index file were to include <code class="Code-In-Text--PACKT-">browserApp.js</code> directly, we would have to download a total of five files (<code class="Code-In-Text--PACKT-">index.html</code>, <code class="Code-In-Text--PACKT-">browserApp.js</code>, and the three dependency modules) before the app would be fully initialized. The module bundler allows us to reduce the total number of files to only two by preprocessing <code class="Code-In-Text--PACKT-">browserApp.js</code> and all its dependencies and producing a single equivalent bundle called <code class="Code-In-Text--PACKT-">main.js</code>, which is then referenced by <code class="Code-In-Text--PACKT-">index.html</code> and therefore loaded by the browser.</li>
    </ul>
    <p class="normal">To summarize, on the browser, we generally have to deal with two logical phases, build and runtime, while on the server, we generally don't need a build phase and we can execute our source code directly.</p>
    <p class="normal">When it comes to picking a module bundler, the most popular option is probably <strong class="keyword">webpack</strong> (<a href="http://nodejsdp.link/webpack"><span class="url">nodejsdp.link/webpack</span></a>). Webpack is <a id="_idIndexMarker872"/>one of the most complete and mature module bundlers currently available and it is the one we are going to use in this chapter. It's worth mentioning, though, that there is a quite prosperous ecosystem full of alternatives, each one with its own strengths. If you are curious, here are some of the most well-known alternatives to webpack:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Parcel</strong> (<a href="http://nodejsdp.link/parcel"><span class="url">nodejsdp.link/parcel</span></a>): Aims to<a id="_idIndexMarker873"/> be fast <a id="_idIndexMarker874"/>and to work "<em class="italic">auto-magically</em>" without any configuration.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Rollup</strong> (<a href="http://nodejsdp.link/rollup"><span class="url">nodejsdp.link/rollup</span></a>): One of the<a id="_idIndexMarker875"/> first module <a id="_idIndexMarker876"/>bundlers to fully support ESM and to offer a number of optimizations like tree shaking and dead code elimination.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Browserify</strong> (<a href="http://nodejsdp.link/browserify"><span class="url">nodejsdp.link/browserify</span></a>): The first module <a id="_idIndexMarker877"/>bundler with support for CommonJS <a id="_idIndexMarker878"/>and is still widely adopted.</li>
    </ul>
    <p class="normal">Other <a id="_idIndexMarker879"/>trending <a id="_idIndexMarker880"/>module bundlers <a id="_idIndexMarker881"/>are <strong class="keyword">FuseBox</strong> (<a href="http://nodejsdp.link/fusebox"><span class="url">nodejsdp.link/fusebox</span></a>), <strong class="keyword">Brunch</strong> (<a href="http://nodejsdp.link/brunch"><span class="url">nodejsdp.link/brunch</span></a>), and <strong class="keyword">Microbundle</strong> (<a href="http://nodejsdp.link/microbundle"><span class="url">nodejsdp.link/microbundle</span></a>).</p>
    <p class="normal">In the next section, we will discuss in greater detail how a module bundler works.</p>
    <h3 id="_idParaDest-272" class="title">How a module bundler works</h3>
    <p class="normal">We can define a<a id="_idIndexMarker882"/> module bundler as a tool that takes the source code of an application (in the form of an entry module and its dependencies) and produces one or more bundle files. The bundling process doesn't change the business logic of the app; it just creates files that are optimized to run on the browser. In a way, we can think of a bundler as a compiler for the browser.</p>
    <p class="normal">In the previous section, we saw how a bundler can help to reduce the total number of files that the browser will need to load, but in reality, a bundler can do so much more than that. For instance, it can <a id="_idIndexMarker883"/>use a <strong class="keyword">transpiler</strong> like <strong class="keyword">Babel</strong> (<a href="http://nodejsdp.link/babel"><span class="url">nodejsdp.link/babel</span></a>). A transpiler is a tool that processes the source code and makes sure that modern JavaScript syntax is converted into equivalent ECMAScript 5 syntax so that a large variety of browsers (including older ones) can run the application correctly. Some module bundlers allow us to preprocess and optimize not just JavaScript code but also other assets such as images and stylesheets.</p>
    <p class="normal">In this section, we will provide a simplified view of how a module bundler works and how it navigates the code of a given application to produce an equivalent bundle optimized for the browser. The work of a module bundler can be divided into two steps that we will call <strong class="keyword">dependency resolution</strong> and <strong class="keyword">packing</strong>.</p>
    <h4 class="title">Dependency resolution</h4>
    <p class="normal">The <a id="_idIndexMarker884"/>dependency resolution step has the goal of traversing the codebase, starting from the main module (also called the <strong class="keyword">entry point</strong>), and discovering all the dependencies. The way a bundler can do this is by representing dependencies as an acyclic direct graph, known <a id="_idIndexMarker885"/>as a <strong class="keyword">dependency graph</strong>.</p>
    <p class="normal">Let's explore this concept with an example: a fictional calculator application. The implementation is intentionally incomplete as we only want to focus on the module structure, how the different modules depend on each other, and how the module bundler can build the dependency graph of this application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// app.js                                                   (1)</span>
<span class="hljs-keyword">import</span> { calculator } <span class="hljs-keyword">from</span> <span class="hljs-string">'./calculator.js'</span>
<span class="hljs-keyword">import</span> { display } <span class="hljs-keyword">from</span> <span class="hljs-string">'./display.js'</span>
display(calculator(<span class="hljs-string">'2 + 2 / 4'</span>))
<span class="hljs-comment">// display.js                                               (5)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">display</span><span class="hljs-function"> () </span>{
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-comment">// calculator.js                                            (2)</span>
<span class="hljs-keyword">import</span> { parser } <span class="hljs-keyword">from</span> <span class="hljs-string">'./parser.js'</span>
<span class="hljs-keyword">import</span> { resolver } <span class="hljs-keyword">from</span> <span class="hljs-string">'./resolver.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">calculator</span><span class="hljs-function"> (</span><span class="hljs-params">expr</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> resolver(parser(expr))
}
<span class="hljs-comment">// parser.js                                                (3)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">parser</span><span class="hljs-function"> (</span><span class="hljs-params">expr</span><span class="hljs-function">) </span>{
  <span class="hljs-comment">// ...</span>
}
<span class="hljs-comment">// resolver.js                                              (4)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">resolver</span><span class="hljs-function"> (</span><span class="hljs-params">tokens</span><span class="hljs-function">) </span>{
  <span class="hljs-comment">// ...</span>
}
</code></pre>
    <p class="normal">Let's see how the module<a id="_idIndexMarker886"/> bundler will walk through this code to figure out the dependency graph:</p>
    <ol>
      <li class="numbered">The module bundler starts its analysis from the entry point of the application, the module <code class="Code-In-Text--PACKT-">app.js</code>. In this phase, the module bundler will discover dependencies by looking at <code class="Code-In-Text--PACKT-">import</code> statements. The bundler starts to scan the code of the entry point and the first <code class="Code-In-Text--PACKT-">import</code> it finds references the <code class="Code-In-Text--PACKT-">calculator.js</code> module. Now, the bundler suspends the analysis of <code class="Code-In-Text--PACKT-">app.js</code> and jumps immediately into <code class="Code-In-Text--PACKT-">calculator.js</code>. The bundler will keep tabs on the open files: it will remember that the first line of <code class="Code-In-Text--PACKT-">app.js</code> was already scanned so that when it eventually restarts processing this file, it will continue from the second line.</li>
      <li class="numbered">In <code class="Code-In-Text--PACKT-">calculator.js</code>, the bundler immediately finds a new import for <code class="Code-In-Text--PACKT-">parser.js</code> so that the processing of <code class="Code-In-Text--PACKT-">calculator.js</code> is interrupted to move into <code class="Code-In-Text--PACKT-">parser.js</code>.</li>
      <li class="numbered">In <code class="Code-In-Text--PACKT-">parser.js</code>, there's no <code class="Code-In-Text--PACKT-">import</code> statement, so after the file has been scanned entirely, the bundler goes back into <code class="Code-In-Text--PACKT-">calculator.js</code>, where the next <code class="Code-In-Text--PACKT-">import</code> statement refers to <code class="Code-In-Text--PACKT-">resolver.js</code>. Again, the analysis of <code class="Code-In-Text--PACKT-">calculator.js</code> is suspended and the bundler jumps immediately into <code class="Code-In-Text--PACKT-">resolver.js</code>.</li>
      <li class="numbered">The module <code class="Code-In-Text--PACKT-">resolver.js</code> does not contain any imports, so the control goes back to <code class="Code-In-Text--PACKT-">calculator.js</code>. The <code class="Code-In-Text--PACKT-">calculator.js</code> module does not contain other imports, so the control goes back to <code class="Code-In-Text--PACKT-">app.js</code>. In <code class="Code-In-Text--PACKT-">app.js</code>, the next import is <code class="Code-In-Text--PACKT-">display.js</code> and the bundler jumps straight into it.</li>
      <li class="numbered"><code class="Code-In-Text--PACKT-">display.js</code> does not contain any imports. So, again the control goes back to <code class="Code-In-Text--PACKT-">app.js</code>. There are no more imports in <code class="Code-In-Text--PACKT-">app.js</code>, so the code has been fully explored, and the dependency graph has been fully constructed.</li>
    </ol>
    <p class="normal">Every time the module bundler jumps from one file to another, it means we are discovering a new dependency and adding a new node to the dependency graph. A visual representation of the steps described in the preceding list can be found in <em class="italic">Figure 10.2</em>:</p>
    <figure class="mediaobject"><img src="../Images/B15729_10_02.png" alt="../../../Downloads/Untitled%20Diagram%20(15).png"/></figure>
    <p class="packt_figref">Figure 10.2: Dependency graph resolution</p>
    <p class="normal">This way of resolving <a id="_idIndexMarker887"/>dependencies also works with cyclic dependencies. In fact, if the bundler encounters the same dependency for a second time, the dependency will be skipped because it's already present in the dependency graph.</p>
    <div class="note">
      <p class="Information-Box--PACKT-"><strong class="screenText">Tree shaking</strong></p>
      <p class="Information-Box--PACKT-">It's worth noting that if we have entities (for example, functions, classes, or variables) in our project modules that are never imported, then these won't appear in this dependency graph, so they won't be included in the final bundle.</p>
      <p class="Information-Box--PACKT-">A more advanced module bundler could also keep track of the entities imported from every module and the exported entities found in the dependency graph. This allows the bundle to figure out if there are exported functionalities that are never used in the <a id="_idIndexMarker888"/>application so that they can be pruned from the final bundle. This optimization technique is called <strong class="keyword">tree shaking</strong> (<a href="http://nodejsdp.link/tree-shaking"><span class="url">nodejsdp.link/tree-shaking</span></a>).</p>
    </div>
    <p class="normal">During the dependency<a id="_idIndexMarker889"/> resolution phase, the module bundler builds a data structure called <strong class="keyword">modules map</strong>. This data structure is a hash map that has unique module identifiers (for example, file paths) as keys and a representation of the module source code as values. In our example, a simplified representation of the modules map might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">'app.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
  <span class="hljs-string">'calculator.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
  <span class="hljs-string">'display.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
  <span class="hljs-string">'parser.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
  <span class="hljs-string">'resolver.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>}
}
</code></pre>
    <p class="normal">Every module in the modules map is a <em class="italic">factory function</em> that accepts two arguments: <code class="Code-In-Text--PACKT-">module</code> and <code class="Code-In-Text--PACKT-">require</code>. We will see in more detail what those arguments are in the next section. What is important to understand now is that every module here is a complete representation of the code in the original source module. If we take, for example, the code for the <code class="Code-In-Text--PACKT-">calculator.js</code> module, it might be represented as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">(<span class="hljs-built_in">module</span>, <span class="hljs-built_in">require</span>) =&gt; {
  <span class="hljs-keyword">const</span> { parser } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'parser.js'</span>)
  <span class="hljs-keyword">const</span> { resolver } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'resolver.js'</span>)
  <span class="hljs-built_in">module</span>.exports.calculator = <span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">expr</span><span class="hljs-function">) </span>{
    <span class="hljs-keyword">return</span> resolver(parser(expr))
  }
}
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note how the ESM syntax has been converted into something that resembles the syntax of the CommonJS module system. Remember that the browser does not support CommonJS and that these variables are not global, so there is no risk of a naming collision here. In this simplified implementation, we decided to use exactly the same identifiers as in CommonJS (<code class="Code-In-Text--PACKT-">module</code>, <code class="Code-In-Text--PACKT-">require</code>, and <code class="Code-In-Text--PACKT-">module.exports</code>) to make the similarity with CommonJS look more apparent. In reality, every module bundler will use its own unique identifiers. For instance, webpack uses identifiers such as <code class="Code-In-Text--PACKT-">__webpack_require__</code> and <code class="Code-In-Text--PACKT-">__webpack_exports__</code>.</p>
    </div>
    <h4 class="title">Packing</h4>
    <p class="normal">The modules map is<a id="_idIndexMarker890"/> the final output of the dependency resolution phase. In the packing phase, the module bundler takes the modules map and converts it into an <em class="italic">executable bundle</em>: a single JavaScript file that contains all the business logic of the original application.</p>
    <p class="normal">The idea is simple: we already have a representation of the original codebase of our application inside the modules map; we have to find a way to convert it into something that the browser can execute correctly and save it into the resulting bundle file.</p>
    <p class="normal">Given the structure of our modules map, this can actually be done with just a few lines of code wrapping the modules map:</p>
    <pre class="programlisting code"><code class="hljs-code">(<span class="hljs-function">(</span><span class="hljs-params">modulesMap</span><span class="hljs-function">) =&gt;</span> {                                       <span class="hljs-comment">// (1)</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">require</span> = <span class="hljs-function">(</span><span class="hljs-params">name</span><span class="hljs-function">) =&gt;</span> {                            <span class="hljs-comment">// (2)</span>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = { <span class="hljs-attr">exports</span>: {} }                       <span class="hljs-comment">// (3)</span>
    modulesMap[name](<span class="hljs-built_in">module</span>, <span class="hljs-built_in">require</span>)                    <span class="hljs-comment">// (4)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports                                <span class="hljs-comment">// (5)</span>
  }
  <span class="hljs-built_in">require</span>(<span class="hljs-string">'app.js'</span>)                                      <span class="hljs-comment">// (6)</span>
})(
  {
    <span class="hljs-string">'app.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
    <span class="hljs-string">'calculator.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
    <span class="hljs-string">'display.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
    <span class="hljs-string">'parser.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
    <span class="hljs-string">'resolver.js'</span>: <span class="hljs-function">(</span><span class="hljs-built_in">module</span><span class="hljs-params">, </span><span class="hljs-built_in">require</span><span class="hljs-function">) =&gt;</span> {<span class="hljs-comment">/* ... */</span>},
  }
)
</code></pre>
    <p class="normal">This is not a lot of code, but there's a lot happening here, so let's go through it together, step by step:</p>
    <ol>
      <li class="numbered">In this code snippet, we have an <strong class="keyword">Immediately Invoked Function Expression</strong> (<strong class="keyword">IIFE</strong>) that receives the entire modules <a id="_idIndexMarker891"/>map as an argument.</li>
      <li class="numbered">When the function is executed, it defines a <em class="italic">custom</em> <code class="Code-In-Text--PACKT-">require</code> function. This function receives a module <code class="Code-In-Text--PACKT-">name</code> as input and it will load and execute the corresponding module from <code class="Code-In-Text--PACKT-">modulesMap</code>.</li>
      <li class="numbered">In the <code class="Code-In-Text--PACKT-">require</code> function, a <code class="Code-In-Text--PACKT-">module</code> object is initialized. This object has only one property called <code class="Code-In-Text--PACKT-">exports</code>, which is an object with no attributes.</li>
      <li class="numbered">At this point, the factory function of the given module is invoked and we pass to it the <code class="Code-In-Text--PACKT-">module</code> object we just created and a reference to the <code class="Code-In-Text--PACKT-">require</code> function itself. Note that this is essentially an implementation<a id="_idIndexMarker892"/> of the Service Locator pattern (<a href="http://nodejsdp.link/service-locator-pattern"><span class="url">nodejsdp.link/service-locator-pattern</span></a>). Here, the factory function, once executed, modifies the <code class="Code-In-Text--PACKT-">module</code> object by attaching to it the functionality that the module exports. The factory function can also recursively require other modules by using the <code class="Code-In-Text--PACKT-">require</code> function passed as an argument.</li>
      <li class="numbered">Finally, the <code class="Code-In-Text--PACKT-">require</code> function returns the <code class="Code-In-Text--PACKT-">module.exports</code> object, which was populated by the factory function that was invoked in the previous step.</li>
      <li class="numbered">The last step is to<a id="_idIndexMarker893"/> require the entry point of our dependency graph, which in our case is the module <code class="Code-In-Text--PACKT-">app.js</code>. This last step is what actually bootstraps the entire application. In fact, by loading the entry point, it will, in turn, load and execute all its dependencies in the right order and then execute its own business logic.</li>
    </ol>
    <p class="normal">With this process, we essentially created a self-sufficient module system that is capable of loading modules that have been properly organized within the same file. In other words, we managed to convert an app originally organized in multiple files into an equivalent app where all the code has been moved into a single file. This is the resulting bundle file.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that the preceding code has been intentionally simplified just to illustrate how module bundlers work. There are many edge cases that we did not take into account. For instance, what happens if we require a module that does not exist in the modules map?</p>
    </div>
    <h3 id="_idParaDest-273" class="title">Using webpack</h3>
    <p class="normal">Now that we <a id="_idIndexMarker894"/>know how a module bundler works, let's build a simple application that can work both on Node.js and on the browser. Throughout this exercise, we will learn how to write a simple library that can be used without changes from the browser app and the server app. We will be using webpack to build the browser bundle.</p>
    <p class="normal">To keep things simple, our application will be nothing more than a simple "hello world" for now, but don't worry, we will be building a more realistic application in the <em class="italic">Creating a Universal JavaScript app</em> section, later in this chapter.</p>
    <p class="normal">Let's start by installing the webpack CLI in our system with:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --global webpack-cli
</code></pre>
    <p class="normal">Let's now initialize a new project in a new folder with:</p>
    <pre class="programlisting con"><code class="hljs-con">npm init
</code></pre>
    <p class="normal">Once the guided <a id="_idIndexMarker895"/>project initialization is complete, since we want to use ESM in Node.js, we need to add the property <code class="Code-In-Text--PACKT-">"type": "module"</code> to our <code class="Code-In-Text--PACKT-">package.json</code>.</p>
    <p class="normal">Now, we can run:</p>
    <pre class="programlisting con"><code class="hljs-con">webpack-cli init
</code></pre>
    <p class="normal">This guided procedure will install webpack in your project and it will help you to automatically generate a webpack configuration file. At the time of writing, using webpack 4, the guided procedure does not realize that we want to use ESM in Node.js, so we have to apply two small changes to the generated files:</p>
    <ul>
      <li class="Bullet--PACKT-">Rename <code class="Code-In-Text--PACKT-">webpack.config.js</code> to <code class="Code-In-Text--PACKT-">webpack.config.cjs</code></li>
      <li class="Bullet--PACKT-">Change the following npm scripts in <code class="Code-In-Text--PACKT-">package.json</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"build"</span>: <span class="hljs-string">"webpack --config webpack.config.cjs"</span>
<span class="hljs-string">"start"</span>: <span class="hljs-string">"webpack-dev-server --config webpack.config.cjs"</span>
</code></pre>
      </li>
    </ul>
    <p class="normal">Now, we are ready to start writing our application.</p>
    <p class="normal">Let's first write the module we want to share in <code class="Code-In-Text--PACKT-">src/say-hello.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> nunjucks <span class="hljs-keyword">from</span> <span class="hljs-string">'nunjucks'</span>
<span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
}
</code></pre>
    <p class="normal">In this code, we are using the <code class="Code-In-Text--PACKT-">nunjucks</code> template library (<a href="http://nodejsdp.link/nunjucks"><span class="url">nodejsdp.link/nunjucks</span></a>), which must be installed with npm. This <a id="_idIndexMarker896"/>module is exporting a simple <code class="Code-In-Text--PACKT-">sayHello</code> function that accepts a <code class="Code-In-Text--PACKT-">name</code> as the only argument and uses it to construct an HTML string.</p>
    <p class="normal">Let's now write the browser application that will use this module (<code class="Code-In-Text--PACKT-">src/index.js</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">'./say-hello.js'</span>
<span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]
body.innerHTML = sayHello(<span class="hljs-string">'Browser'</span>)
</code></pre>
    <p class="normal">This code uses the <code class="Code-In-Text--PACKT-">sayHello</code> function to build an HTML fragment saying <em class="italic">Hello Browser</em> and then inserts it into the <code class="Code-In-Text--PACKT-">body</code> section of the current HTML page.</p>
    <p class="normal">If you want to preview this application, you can run <code class="Code-In-Text--PACKT-">npm start</code> in your terminal. This should open your default browser and you should see the application running.</p>
    <p class="normal">If you want to generate a <a id="_idIndexMarker897"/>static version of the application, you can run:</p>
    <pre class="programlisting con"><code class="hljs-con">npm run build
</code></pre>
    <p class="normal">This will generate a folder called <code class="Code-In-Text--PACKT-">dist</code> containing two files: an <code class="Code-In-Text--PACKT-">index.html</code> and our bundle file (whose name will look like <code class="Code-In-Text--PACKT-">main.12345678901234567890.js</code>).</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The file name of the bundle is generated by using a hash of the file content. This way, every time our source code changes, we will obtain a new bundle with a different name. This is a useful optimization technique, called <strong class="keyword">cache busting</strong>, that webpack adopts by default and it is particularly convenient when deploying our assets to a <strong class="keyword">content delivery network</strong> (<strong class="keyword">CDN</strong>). With CDNs, it is <a id="_idIndexMarker898"/>generally quite expensive to override files that are geographically distributed across multiple servers and already cached in multiple layers, possibly including our users' browsers. By generating new files with every change, we avoid cache invalidation entirely.</p>
    </div>
    <p class="normal">You can open the <code class="Code-In-Text--PACKT-">index.html</code> file with your browser to see a preview of your application.</p>
    <p class="normal">If you are curious, you can have a look at the generated bundle file. You will notice that it is a bit more convoluted and verbose than the sample bundle we illustrated in the previous section. However, you should be able to recognize the structure and notice that the entire <code class="Code-In-Text--PACKT-">nunjucks</code> library, as well as our <code class="Code-In-Text--PACKT-">sayHello</code> module, have been embedded in the bundle code.</p>
    <p class="normal">Now, what if we want to build an equivalent application that runs in Node.js? For instance, we could use the <code class="Code-In-Text--PACKT-">sayHello</code> function and display the resulting code in the terminal:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/server.js</span>
<span class="hljs-keyword">import</span> { sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">'./say-hello.js'</span>
<span class="hljs-built_in">console</span>.log(sayHello(<span class="hljs-string">'Node.js'</span>))
</code></pre>
    <p class="normal">That's it!</p>
    <p class="normal">If we run this code with:</p>
    <pre class="programlisting con"><code class="hljs-con">node src/server.js
</code></pre>
    <p class="normal">We will see the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;h1&gt;Hello &lt;i&gt;Node.js&lt;/i&gt;&lt;/h1&gt;
</code></pre>
    <p class="normal">Yes, displaying HTML in<a id="_idIndexMarker899"/> the terminal is not particularly useful, but right now we achieved our goal of being able to use a library from both the browser and the server without any changes in the library codebase.</p>
    <p class="normal">In the next sections, we will discuss some patterns that allow us to actually change the code where necessary if we want to provide more specialized behaviors on the browser or Node.js.</p>
    <h1 id="_idParaDest-274" class="title">Fundamentals of cross-platform development</h1>
    <p class="normal">When developing for<a id="_idIndexMarker900"/> different platforms, the most common problem we face is how can we reuse as much code as possible and, at the same time, provide specialized implementations for details that are platform-specific. We will now explore some of the principles and the patterns to use when facing this challenge, such as code branching and module swapping.</p>
    <h2 id="_idParaDest-275" class="title">Runtime code branching</h2>
    <p class="normal">The most simple and <a id="_idIndexMarker901"/>intuitive technique for <a id="_idIndexMarker902"/>providing different implementations based on the host platform is to dynamically branch our code. This requires that we have a mechanism to recognize the host platform at runtime and then dynamically switch the implementation with an <code class="Code-In-Text--PACKT-">if...else</code> statement. Some generic approaches involve checking global variables that are available only on Node.js or only on the browser.</p>
    <p class="normal">For example, we can check the existence of the <code class="Code-In-Text--PACKT-">window</code> global variable. Let's modify our <code class="Code-In-Text--PACKT-">say-hello.js</code> module to use this technique to provide a slightly different functionality depending on whether the module is running on the browser or on the server:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> nunjucks <span class="hljs-keyword">from</span> <span class="hljs-string">'nunjucks'</span>
<span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">window</span>.document) {
    <span class="hljs-comment">// client-side code</span>
    <span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
  }
  <span class="hljs-comment">// Node.js code</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello \u001b[1m</span><span class="hljs-subst">${name}</span><span class="hljs-string">\u001b[0m`</span>
}
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The escape sequence <code class="Code-In-Text--PACKT-">\u001b[1m</code> is a special terminal formatting indicator that sets the text to bold. The sequence <code class="Code-In-Text--PACKT-">\u001b[0m</code> instead resets the formatting to normal. If you are curious to find out more about escape sequences and their history, check out <a id="_idIndexMarker903"/>ANSI escape sequences: <a href="http://nodejsdp.link/ansi-escape-sequences"><span class="url">nodejsdp.link/ansi-escape-sequences</span></a>.</p>
    </div>
    <p class="normal">Try again to run our application<a id="_idIndexMarker904"/> on Node.js and on the browser and see the<a id="_idIndexMarker905"/> differences! If you do that, you will not see HTML code on the terminal when running the Node.js application. Instead, you will see a string with proper terminal formatting. The frontend application on the browser remains unchanged.</p>
    <h3 id="_idParaDest-276" class="title">Challenges of runtime code branching</h3>
    <p class="normal">Using a runtime branching <a id="_idIndexMarker906"/>approach for switching between Node.js and the browser is definitely the most intuitive and simple pattern we can use for this purpose; however, there are some inconveniences:</p>
    <ul>
      <li class="Bullet--PACKT-">The code for both platforms is included in the same module and therefore in the final bundle. This increases the bundle size, adding unreachable and unnecessary code. It is also possible that the unreachable code contains sensitive information like encryption keys or API keys that are not meant to be sent to a user's browser. In this case, this approach might also raise significant security concerns.</li>
      <li class="Bullet--PACKT-">If used too extensively, it can considerably reduce the readability of the code, as the business logic would be mixed with logic meant only to add cross-platform compatibility.</li>
      <li class="Bullet--PACKT-">Using dynamic branching to load a different module, depending on the platform, will result in all the modules being added to the final bundle, regardless of their target platform. For example, if we consider the following code fragment, both <code class="Code-In-Text--PACKT-">clientModule</code> and <code class="Code-In-Text--PACKT-">serverModule</code> will be included in a bundle generated with webpack, unless we explicitly exclude one of them from the build:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { clientFunctionality } <span class="hljs-keyword">from</span> <span class="hljs-string">'clientModule'</span>
<span class="hljs-keyword">import</span> { serverFunctionality } <span class="hljs-keyword">from</span> <span class="hljs-string">'serverModule'</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">window</span>.document) {
  clientFunctionality()
} <span class="hljs-keyword">else</span> {
  serverFunctionality()
}
</code></pre>
      </li>
    </ul>
    <p class="normal">This last inconvenience happens because of the following reasons:</p>
    <ul>
      <li class="Bullet--PACKT-">Bundlers have no sure way of knowing the value of a runtime variable at build time (unless the variable is a constant), so, in the preceding example, both branches of the <code class="Code-In-Text--PACKT-">if...else</code> statement are always included in the final bundle, even though it is obvious that the browser will always execute only one of them.</li>
      <li class="Bullet-End--PACKT-">ES module imports <a id="_idIndexMarker907"/>are always defined declaratively at the top of the file and we don't have a way to filter the imports based on the current environment. The bundler will not try to understand whether you are conditionally using only a subset of the imported feature and it will include all the imported code anyway.</li>
    </ul>
    <p class="normal">A consequence of this last property is that modules imported dynamically using variables are not included in the bundle. For example, from the following code, no module will be bundled:</p>
    <pre class="programlisting code"><code class="hljs-code">moduleList.forEach(<span class="hljs-keyword">function</span><span class="hljs-function">(</span><span class="hljs-params">module</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">import</span>(<span class="hljs-built_in">module</span>)
})
</code></pre>
    <p class="normal">It's worth underlining that webpack overcomes some of these limitations and, under certain specific circumstances, it is able to guess all the possible values for a dynamic requirement. For instance, if you<a id="_idIndexMarker908"/> have a snippet of code like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getControllerModule</span><span class="hljs-function"> (</span><span class="hljs-params">controllerName</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">`./controller/</span><span class="hljs-subst">${controllerName}</span><span class="hljs-string">`</span>)
}
</code></pre>
    <p class="normal">Webpack will include all the modules available in the <code class="Code-In-Text--PACKT-">controller</code> folder in the final bundle.</p>
    <p class="normal">It's highly recommended to have a look at the official documentation to understand all the supported cases (<a href="http://nodejsdp.link/webpack-dynamic-imports"><span class="url">nodejsdp.link/webpack-dynamic-imports</span></a>).</p>
    <h2 id="_idParaDest-277" class="title">Build-time code branching</h2>
    <p class="normal">In this section, we are going <a id="_idIndexMarker909"/>to see how to use<a id="_idIndexMarker910"/> webpack plugins to remove, at build time, all parts of the code that we want to run only on the server. This allows us to obtain lighter bundle files and to avoid accidentally exposing code containing sensible information (for instance, secrets, passwords, or API keys) that should only live on the server.</p>
    <p class="normal">Webpack offers support for plugins, which allows us to extend webpack's capabilities and add new processing steps that can be used to produce the bundle file. To perform build-time code branching, we can leverage a built-in plugin called <code class="Code-In-Text--PACKT-">DefinePlugin</code> and a third-party plugin called <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> (<a href="http://nodejsdp.link/terser-webpack"><span class="url">nodejsdp.link/terser-webpack</span></a>).</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">DefinePlugin</code> can be used to replace specific code occurrences in our source files with custom code or variables. <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> allows us to compress the resulting code and remove unreachable statements (<strong class="keyword">dead code elimination</strong>).</p>
    <p class="normal">Let's start by rewriting our <code class="Code-In-Text--PACKT-">say-hello.js</code> module to explore these concepts:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> nunjucks <span class="hljs-keyword">from</span> <span class="hljs-string">'nunjucks'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> __BROWSER__ !== <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-comment">// client-side code</span>
    <span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
    <span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
  }
  <span class="hljs-comment">// Node.js code</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello \u001b[1m</span><span class="hljs-subst">${name}</span><span class="hljs-string">\u001b[0m`</span>
}
</code></pre>
    <p class="normal">Note that we are checking for the existence of a generic variable called <code class="Code-In-Text--PACKT-">__BROWSER__</code> to enable the browser code. This is the variable that we will replace at build time using <code class="Code-In-Text--PACKT-">DefinePlugin</code>.</p>
    <p class="normal">Now, let's install <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> with:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --save-dev terser-webpack-plugin
</code></pre>
    <p class="normal">Finally, let's update our <code class="Code-In-Text--PACKT-">webpack.config.cjs</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> TerserPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>)
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-comment">// ...</span>
  plugins: [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">new</span> webpack.DefinePlugin({
      <span class="hljs-attr">__BROWSER__</span>: <span class="hljs-literal">true</span>
    })
  ],
  <span class="hljs-comment">// ...</span>
  optimization: {
    <span class="hljs-comment">// ...</span>
    minimize: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> TerserPlugin()]
  }
}
</code></pre>
    <p class="normal">The first change here is to <a id="_idIndexMarker911"/>set the option <code class="Code-In-Text--PACKT-">mode</code> to <code class="Code-In-Text--PACKT-">production</code>. This option will enable optimizations such as code <strong class="keyword">minification </strong>(or minimization). Optimization<a id="_idIndexMarker912"/> options are defined in the dedicated <code class="Code-In-Text--PACKT-">optimization</code> object. Here, we are enabling minification by setting <code class="Code-In-Text--PACKT-">minimize</code> to <code class="Code-In-Text--PACKT-">true</code> and we are providing a new instance of <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> as the minimizer. Finally, we are also adding <code class="Code-In-Text--PACKT-">webpack.DefinePlugin</code> and configuring it to replace the string <code class="Code-In-Text--PACKT-">__BROWSER__</code> with the value <code class="Code-In-Text--PACKT-">true</code>.</p>
    <p class="normal">Every value in the configuration object of <code class="Code-In-Text--PACKT-">DefinePlugin</code> represents a piece of code that will be evaluated by webpack at build time and then used to replace the currently matched snippet of code. This allows us to add external dynamic values containing, for instance, the content of an environment variable, the current timestamp, or the hash of the last git commit to the bundle.</p>
    <p class="normal">With this configuration, when we build a new bundle, every occurrence of <code class="Code-In-Text--PACKT-">__BROWSER__</code> is replaced with <code class="Code-In-Text--PACKT-">true</code>. The first <code class="Code-In-Text--PACKT-">if</code> statement will internally look like <code class="Code-In-Text--PACKT-">if (true !== 'undefined')</code>, but webpack is smart enough to understand that this expression will always be evaluated as <code class="Code-In-Text--PACKT-">true</code>, so it transforms the resulting code again into <code class="Code-In-Text--PACKT-">if (true)</code>.</p>
    <p class="normal">Once webpack has finished processing all the code, it will invoke <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> to minimize the resulting code. <code class="Code-In-Text--PACKT-">terser-webpack-plugin</code> is a wrapper <a id="_idIndexMarker913"/>around Terser (<a href="http://nodejsdp.link/terser"><span class="url">nodejsdp.link/terser</span></a>), a modern JavaScript minifier. Terser is capable of removing dead code as part of its minimization algorithm, so given that, at this stage, our code will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
  <span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
}
<span class="hljs-keyword">return</span> <span class="hljs-string">`Hello \u001b[1m</span><span class="hljs-subst">${name}</span><span class="hljs-string">\u001b[0m`</span>
</code></pre>
    <p class="normal">Terser will reduce it to:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
<span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
</code></pre>
    <p class="normal">This way, we got rid of all the server-side code in our browser bundle.</p>
    <p class="normal">Even if build-time code<a id="_idIndexMarker914"/> branching is way better than <a id="_idIndexMarker915"/>runtime code branching because it produces much leaner bundle files, it can still make our source code cumbersome when abused. In fact, if you overuse this technique, you will end up with code that contains too many <code class="Code-In-Text--PACKT-">if</code> statements, which will be hard to understand and debug.</p>
    <p class="normal">When this happens, it is generally better to move all the platform-specific code into dedicated modules. We will discuss this alternative approach in the next section.</p>
    <h2 id="_idParaDest-278" class="title">Module swapping</h2>
    <p class="normal">Most of the time, we already know<a id="_idIndexMarker916"/> at build time what code has to be included in the client bundle and what shouldn't. This means that we can take this decision upfront and instruct the bundler to replace the implementation of an entire module at build time. This often results in a leaner bundle, as we are excluding unnecessary modules, and more readable code because we don't have all the <code class="Code-In-Text--PACKT-">if...else</code> statements required by runtime and build-time branching.</p>
    <p class="normal">Let's find out how to adopt module swapping with webpack by updating our example.</p>
    <p class="normal">The main idea is that we want to have two separate implementations of our <code class="Code-In-Text--PACKT-">sayHello</code> functionality: one optimized for the server (<code class="Code-In-Text--PACKT-">say-hello.js</code>) and one optimized for the browser (<code class="Code-In-Text--PACKT-">say-hello-browser.js</code>). We will then tell webpack to replace any import of <code class="Code-In-Text--PACKT-">say-hello.js</code> with <code class="Code-In-Text--PACKT-">say-hello-browser.js</code>. Let's<a id="_idIndexMarker917"/> see what our new implementation looks like now:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/say-hello.js</span>
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">'chalk'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello </span><span class="hljs-subst">${</span>chalk.<span class="hljs-subst">green(name)}</span><span class="hljs-string">`</span>
}
<span class="hljs-comment">// src/say-hello-browser.js</span>
<span class="hljs-keyword">import</span> nunjucks <span class="hljs-keyword">from</span> <span class="hljs-string">'nunjucks'</span>
<span class="hljs-keyword">const</span> template = <span class="hljs-string">'&lt;h1&gt;Hello &lt;i&gt;{{ name }}&lt;/i&gt;&lt;/h1&gt;'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">sayHello</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> nunjucks.renderString(template, { name })
}
</code></pre>
    <p class="normal">Note that, on the server-side version, we introduced a<a id="_idIndexMarker918"/> new dependency, <code class="Code-In-Text--PACKT-">chalk</code> (<a href="http://nodejsdp.link/chalk"><span class="url">nodejsdp.link/chalk</span></a>), a utility library that allows us to format text for the terminal. This is to demonstrate one of the main advantages of this approach. Now that we've separated our server-side code from the client-side code, we can introduce new functionalities and libraries without worrying about the impact that those might have on the frontend-only bundle. At this point, in order to tell webpack to swap the modules at build time, we have to replace <code class="Code-In-Text--PACKT-">webpack.DefinePlugin</code> with a new plugin in our <code class="Code-In-Text--PACKT-">webpack.config.cjs</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">plugins: [
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">new</span> webpack.NormalModuleReplacementPlugin(
    <span class="hljs-regexp">/src\/say-hello\.js$/</span>,
    path.resolve(__dirname, <span class="hljs-string">'src'</span>, <span class="hljs-string">'say-hello-browser.js'</span>)
  )
]
</code></pre>
    <p class="normal">We are using <code class="Code-In-Text--PACKT-">webpack.NormalModuleReplacementPlugin</code>, which accepts two arguments. The first argument is a regular expression and the second one is a string representing a path to a resource. At build time, if a module path matches the given regular expression, it is replaced with the one provided in the second argument.</p>
    <p class="normal">Note that this technique is not limited to <a id="_idIndexMarker919"/>our internal modules, but it can also be used with external libraries in our <code class="Code-In-Text--PACKT-">node_modules</code> folder.</p>
    <p class="normal">Thanks to webpack and the module replacement plugin, we can easily deal with structural differences between platforms. We can focus on writing separate modules that are meant to provide platform-specific code and we can then swap Node.js-only modules with browser-specific ones in the final bundle.</p>
    <h2 id="_idParaDest-279" class="title">Design patterns for cross-platform development</h2>
    <p class="normal">Let's now revise some of the design patterns<a id="_idIndexMarker920"/> we discussed in the previous chapters to see how we can leverage those for cross-platform development:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Strategy and template</strong>: These <a id="_idIndexMarker921"/>two are probably the most useful patterns when sharing code with the browser. Their intent is, in fact, to define the common steps of an algorithm, allowing <a id="_idIndexMarker922"/>some of its parts to be replaced, which is exactly what we need! In cross-platform development, these patterns allow us to share the platform-agnostic part of our components, while allowing their platform-specific parts to be changed using a different strategy or template method (which can be changed using code branching (runtime or build-time) or module swapping).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Adapter</strong>: This<a id="_idIndexMarker923"/> pattern is probably the most useful when we need to swap an entire component. We have already seen several examples in <em class="chapterRef">Chapter 8</em>, <em class="italic">Structural Design Patterns</em>. If your server application is using a database like SQLite, you could use the Adapter pattern to provide an alternative data storage implementation that works in the browser. For instance you could use the <code class="Code-In-Text--PACKT-">localStorage</code> API (<a href="http://nodejsdp.link/localstorage"><span class="url">nodejsdp.link/localstorage</span></a>) or the <code class="Code-In-Text--PACKT-">IndexedDB</code> API (<a href="http://nodejsdp.link/indexdb"><span class="url">nodejsdp.link/indexdb</span></a>).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Proxy</strong>: When<a id="_idIndexMarker924"/> code meant to run on the server runs on the browser, we often need functionality that is used on the server to be available on the browser as well. This is where the <em class="italic">remote</em> Proxy pattern is useful. Imagine if we wanted to access the filesystem of the server from the browser: we could think of creating an <code class="Code-In-Text--PACKT-">fs</code> object on the client that proxies every call to the <code class="Code-In-Text--PACKT-">fs</code> module living on the server, using Ajax or WebSockets as a way of exchanging commands and return values.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Dependency injection and service locator</strong>: Both dependency injection and service locator can <a id="_idIndexMarker925"/>be useful to<a id="_idIndexMarker926"/> replace the implementation of a module at the moment of its injection. When we introduced the concept of modules maps, in the <em class="italic">Packing</em> section, we also saw how the Service Locator pattern was intrinsically used by module bundlers to collate all the code from different modules into one file.</li>
    </ul>
    <p class="normal">As we can see, the arsenal of patterns at our disposal is quite powerful, but the most powerful weapon is still the ability of the developer to choose the best approach and adapt it to the specific problem at hand.</p>
    <p class="normal">Now that we understand the fundamentals of module bundlers and we have learned a number of useful patterns to write cross-platform code, we are ready to move into the second part of this chapter, where we will learn about React and write our first universal JavaScript application.</p>
    <h1 id="_idParaDest-280" class="title">A brief introduction to React</h1>
    <p class="normal">React is a <a id="_idIndexMarker927"/>popular JavaScript library created and maintained by Facebook. React is focused on providing a comprehensive set of functions and tools to build the view layer in web applications. React offers a view abstraction focused on the concept of a <strong class="keyword">component</strong>. A component<a id="_idIndexMarker928"/> could be a button, a form input, a simple container such as an HTML <code class="Code-In-Text--PACKT-">div</code>, or any other element in your user interface. The idea is that you should be able to construct the user interface of your application by just defining and composing highly reusable components with specific responsibilities.</p>
    <p class="normal">What makes React different from other view libraries for the web is that it is not bound to the DOM by design. In fact, it provides a high-level abstraction <a id="_idIndexMarker929"/>called the <strong class="keyword">virtual DOM</strong> (<a href="http://nodejsdp.link/virtual-dom"><span class="url">nodejsdp.link/virtual-dom</span></a>) that fits very well with the web but that can also be used in other contexts, for example, for building mobile apps, modeling 3D environments, or even defining the interaction between hardware components. In simple terms, the virtual DOM can be seen as an efficient way to re-render data organized in a tree-like structure.</p>
    <blockquote class="packt_quote"><p>"Learn it once, use it everywhere."</p>
    <p class="cite">—Facebook</p></blockquote>
    <p class="normal">This is the motto used by Facebook to introduce React. It intentionally mocks the famous Java motto <em class="italic">Write it once, run it everywhere</em> with the clear intention to underline a fundamental shift<a id="_idIndexMarker930"/> from the Java philosophy. The original design goal of Java was to allow developers to write applications once and run them on as many platforms as possible without changes. Conversely, the React philosophy acknowledges that every platform is inherently different and therefore encourages developers to write different applications that are optimized for the related target platform. React, as a library, shifts its focus on providing <em class="italic">convenient</em> design and architecture principles and tools that, once mastered, can be easily used to write platform-specific code.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">If you are curious to learn about the applications of React in contexts not strictly related to the field of web development, you can have a look at the following projects: <strong class="keyword">React Native</strong> for <a id="_idIndexMarker931"/>mobile apps (<a href="http://nodejsdp.link/react-native"><span class="url">nodejsdp.link/react-native</span></a>), <strong class="keyword">React PIXI</strong> for <a id="_idIndexMarker932"/>2D rendering with OpenGL (<a href="http://nodejsdp.link/react-pixi"><span class="url">nodejsdp.link/react-pixi</span></a>), <strong class="keyword">react-three-fiber</strong> to<a id="_idIndexMarker933"/> create<a id="_idIndexMarker934"/> 3D scenes (<a href="http://nodejsdp.link/react-three-fiber"><span class="url">nodejsdp.link/react-three-fiber</span></a>), and <strong class="keyword">React Hardware</strong> (<a href="http://nodejsdp.link/react-hardware"><span class="url">nodejsdp.link/react-hardware</span></a>).</p>
    </div>
    <p class="normal">The main reason why React is so interesting in the context of Universal JavaScript development is because it allows us to render React components both on the client and on the server using almost the same code. To put it another way, with React, we are able to render the HTML code that is required to display the page directly from Node.js. Then, when the page is loaded on the browser, React will<a id="_idIndexMarker935"/> perform a process called <strong class="keyword">hydration</strong> (<a href="http://nodejsdp.link/hydration"><span class="url">nodejsdp.link/hydration</span></a>), which will add all the frontend-only side effects like click handlers, animations, additional asynchronous data fetching, dynamic routing, and so on. Hydration converts a static markup into a fully interactive experience.</p>
    <p class="normal">This approach allows us to build <strong class="keyword">single-page applications</strong> (<strong class="keyword">SPAs</strong>), where the first render happens mostly on the server, but then, once<a id="_idIndexMarker936"/> the page is loaded on the browser and the user starts to click around, only the parts of the page that need to be changed are dynamically refreshed, without requiring a full page reload.</p>
    <p class="normal">This design offers two main advantages:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Better search engine optimization (SEO)</strong>: Since the page markup is pre-rendered by the server, various search engines can make sense of the content of the page by just looking at the HTML returned by the server. They won't need to simulate a browser environment and wait for the page to be fully loaded to see what a given page is about.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Better performance</strong>: Since we are pre-rendering the markup, this will be already available and visible on the browser, even while the browser is still downloading, parsing, and executing the JavaScript code included with the page. This approach can lead to a better user experience as the content is perceived to load faster and there are less browser "flashes" during rendering.</li>
    </ul>
    <div class="note">
      <p class="Information-Box--PACKT-">It is worth mentioning that the React virtual DOM is capable of optimizing the way changes are rendered. This means that the DOM is not rendered in full after every change, but instead React uses a smart in-memory diffing algorithm that is able to pre-calculate the minimum number of changes to apply to the DOM in order to update the view. This results in a very efficient mechanism for fast browser rendering.</p>
    </div>
    <p class="normal">Now that we know what React is, in the next section, we will write our first React component!</p>
    <h2 id="_idParaDest-281" class="title">Hello React</h2>
    <p class="normal">Without further ado, let's start to use <a id="_idIndexMarker937"/>React and jump to a concrete example. This will be a "Hello World" type of example but it will help us to illustrate the main ideas behind React, before we move onto more realistic examples.</p>
    <p class="normal">Let's start by creating a new webpack project in a new folder with:</p>
    <pre class="programlisting con"><code class="hljs-con">npm init -y
npm install --save-dev webpack webpack-cli
node_modules/.bin/webpack init
</code></pre>
    <p class="normal">Then, follow the guided instructions. Now, let's install React:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --save react react-dom
</code></pre>
    <p class="normal">Now, let's create a file, <code class="Code-In-Text--PACKT-">src/index.js</code>, with the following content:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">const</span> h = react.createElement                            <span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Hello</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{                    <span class="hljs-comment">// (2)</span>
  render () {                                            <span class="hljs-comment">// (3)</span>
    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, [                               <span class="hljs-comment">// (4)</span>
      <span class="hljs-string">'Hello '</span>,
      <span class="hljs-built_in">this</span>.props.name || <span class="hljs-string">'World'</span>                         <span class="hljs-comment">// (5)</span>
    ])
  }
}
ReactDOM.render(                                         <span class="hljs-comment">// (6)</span>
  h(Hello, { <span class="hljs-attr">name</span>: <span class="hljs-string">'React'</span> }),
  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]
)
</code></pre>
    <p class="normal">Let's review what's happening with this code:</p>
    <ol>
      <li class="numbered">The first thing that we do is to create a handy alias for the <code class="Code-In-Text--PACKT-">react.createElement</code> function. We will be using this function a couple of times in this example to create React elements. These could be plain DOM nodes (regular HTML tags) or instances of React components.</li>
      <li class="numbered">Now, we define our <code class="Code-In-Text--PACKT-">Hello</code> component, which has to extend the <code class="Code-In-Text--PACKT-">react.Component</code> class.</li>
      <li class="numbered">Every React component has to implement a <code class="Code-In-Text--PACKT-">render()</code> method. This method defines how the component will be displayed on the screen when it is rendered on the <a id="_idIndexMarker938"/>DOM and it has to return a React element.</li>
      <li class="numbered">We are using the <code class="Code-In-Text--PACKT-">react.createElement</code> function to create an <code class="Code-In-Text--PACKT-">h1</code> DOM element. This method expects three or more arguments. The first argument is the tag name (as a string) or a React component class. The second argument is an object used to pass attributes (or <strong class="keyword">props</strong>) to the component (or <code class="Code-In-Text--PACKT-">null</code> if we don't need to specify any attribute). Finally, the third argument is an array (or you can pass multiple arguments as well) of children elements. Elements can also be text (text nodes), as in our current example.</li>
      <li class="numbered">Here, we are using <code class="Code-In-Text--PACKT-">this.props</code> to access the attributes that are passed to this component at runtime. In this specific case, we are looking for the <code class="Code-In-Text--PACKT-">name</code> attribute. If this is passed, we use it to construct a text node; otherwise, we default to the string <code class="Code-In-Text--PACKT-">"World"</code>.</li>
      <li class="numbered">In this last block of code, we use <code class="Code-In-Text--PACKT-">ReactDOM.render()</code> to initialize our application. This function is responsible for attaching a React application to the existing page. An application is nothing more than an instance of a React component. Here, we are instantiating our <code class="Code-In-Text--PACKT-">Hello</code> component and passing the string <code class="Code-In-Text--PACKT-">"React"</code> for the <code class="Code-In-Text--PACKT-">name</code> attribute. Finally, as the last argument, we have to specify which DOM node in the page will be the parent element of our application. In this case, we are using the <code class="Code-In-Text--PACKT-">body</code> element of the <a id="_idIndexMarker939"/>page, but you can target any existing DOM element in the page.</li>
    </ol>
    <p class="normal">Now, you can see a preview of your application by running:</p>
    <pre class="programlisting con"><code class="hljs-con">npm start
</code></pre>
    <p class="normal">You should now see "Hello React" in your browser window. Congratulations, you have built your first React application!</p>
    <h2 id="_idParaDest-282" class="title">Alternatives to react.createElement</h2>
    <p class="normal">Repeated usage of <code class="Code-In-Text--PACKT-">react.createElement()</code> might compromise the readability of our React components. In fact, nesting <a id="_idIndexMarker940"/>many invocations of <code class="Code-In-Text--PACKT-">react.createElement()</code>, even with our <code class="Code-In-Text--PACKT-">h()</code> alias, will make it hard to understand the HTML structure we want our components to render.</p>
    <p class="normal">For this reason, it is not very common to use <code class="Code-In-Text--PACKT-">react.createElement()</code> directly. To address this problem, the React team <a id="_idIndexMarker941"/>offers and encourages an alternative syntax called <strong class="keyword">JSX</strong> (<a href="http://nodejsdp.link/jsx"><span class="url">nodejsdp.link/jsx</span></a>).</p>
    <p class="normal">JSX is a superset of JavaScript that allows you to embed HTML-like code into JavaScript code. JSX makes the creation of React elements similar to writing HTML code. With JSX, React components are generally more readable and easier to write. It is easier to see what we mean here by looking at a concrete example, so let's rewrite our "Hello React" application using JSX:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Hello</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> <strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h1</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Hello {this.props.name || 'World'}</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h1</strong><strong class="hljs-tag-slc">&gt;</strong>
  }
}
ReactDOM.render(
  <strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">Hello</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">name</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"React"</strong><strong class="hljs-tag-slc">/&gt;</strong>,
  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]
)
</code></pre>
    <p class="normal">Much more readable, isn't it?</p>
    <p class="normal">Unfortunately, since JSX is not a standard JavaScript feature, adopting JSX would require us to "compile" JSX code into standard equivalent JavaScript code. In the context of Universal JavaScript applications, we would have to do this both on the client-side code and the server-side code, so, for the sake of simplicity, we are not going to use JSX throughout the rest of this chapter.</p>
    <p class="normal">There are some relatively new<a id="_idIndexMarker942"/> JSX alternatives that rely on standard JavaScript tagged template literals (you can read more about JavaScript tagged template literals at <a href="http://nodejsdp.link/template-literals"><span class="url">nodejsdp.link/template-literals</span></a>). Using template literals seems to be a good compromise <a id="_idIndexMarker943"/>between code that is still quite easy to read and write and not having to perform an intermediate compilation process. Two of the most promising libraries providing this<a id="_idIndexMarker944"/> functionality are <code class="Code-In-Text--PACKT-">htm</code> (<a href="http://nodejsdp.link/htm"><span class="url">nodejsdp.link/htm</span></a>) and <code class="Code-In-Text--PACKT-">esx</code> (<a href="http://nodejsdp.link/esx"><span class="url">nodejsdp.link/esx</span></a>).</p>
    <p class="normal">In the rest of this chapter, we will be using <code class="Code-In-Text--PACKT-">htm</code>, so let's rewrite once more our "Hello React" example, this time using <code class="Code-In-Text--PACKT-">htm</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> htm </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'htm'</strong>
<strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> html = htm.bind(react.createElement)</strong>          <span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Hello</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {                                       <span class="hljs-comment">// (2)</span>
    <span class="hljs-keyword">return</span> <strong class="hljs-slc">html`</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h1</strong><strong class="hljs-tag-slc">&gt;</strong>
      <strong class="hljs-slc">Hello </strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-subst-slc">.props.name || </strong><strong class="hljs-string-slc">'World'</strong><strong class="hljs-subst-slc">}</strong>
    <strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h1</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">`</strong>
  }
}
ReactDOM.render(
  <strong class="hljs-slc">html`</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-subst-slc">${Hello}</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">name</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"React"</strong><strong class="hljs-tag-slc">/&gt;</strong><strong class="hljs-slc">`,</strong>                   <span class="hljs-comment">// (3)</span>
  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]
)
</code></pre>
    <p class="normal">This code looks quite readable, but let's quickly clarify how we are using <code class="Code-In-Text--PACKT-">htm</code> here:</p>
    <ol>
      <li class="numbered">The first thing that we have to do is create the template tag function <code class="Code-In-Text--PACKT-">html</code>. This function allows us to use template literals to generate React elements. At runtime, this template tag function will be calling <code class="Code-In-Text--PACKT-">react.createElement()</code> for us when needed.</li>
      <li class="numbered">Here, we use a tagged <a id="_idIndexMarker945"/>template literal with the <code class="Code-In-Text--PACKT-">html</code> tag function to create an <code class="Code-In-Text--PACKT-">h1</code> tag. Note that, as this is a standard tagged template literal, we can use the regular placeholder syntax (<code class="Code-In-Text--PACKT-">${expression}</code>) to insert dynamic expressions into the string. Remember that template literals and tagged template literals use backticks (<code class="Code-In-Text--PACKT-">`</code>) instead of single quotes (<code class="Code-In-Text--PACKT-">'</code>) to delimit the template string.</li>
      <li class="numbered">Similarly, we can use the placeholder syntax to create instances of React components (<code class="Code-In-Text--PACKT-">&lt;${ComponentClass}&gt;</code>). Note that, if a component instance contains children elements, we can use the special <code class="Code-In-Text--PACKT-">&lt;/&gt;</code> tag to indicate the end of the component (for example, <code class="Code-In-Text--PACKT-">&lt;${Component}&gt;&lt;child/&gt;&lt;/&gt;</code>). Finally, we can pass props to the component as normal HTML attributes.</li>
    </ol>
    <p class="normal">At this point, we should be able to understand the basic structure of a simple "Hello World" React component. In the next section, we will show you how to manage states in a React component, an important concept for most real-world applications.</p>
    <h2 id="_idParaDest-283" class="title">Stateful components</h2>
    <p class="normal">In the previous example, we<a id="_idIndexMarker946"/> saw how to build a <em class="italic">stateless</em> React component. By stateless, we mean that the component only receives input from the outside (in our example, it was receiving a <code class="Code-In-Text--PACKT-">name</code> property) and it doesn't need to calculate or manage any internal information to be able to render itself to the DOM.</p>
    <p class="normal">While it's great to have stateless components, sometimes, you have to manage some kind of state. React allows us to do that, so let's learn how with an example.</p>
    <p class="normal">Let's build a React application that displays a list of projects that have been recently updated on GitHub.</p>
    <p class="normal">We can encapsulate all the logic for asynchronously fetching the data from GitHub and displaying it on a dedicated component: the <code class="Code-In-Text--PACKT-">RecentGithubProjects</code> component. This component is configurable through the <code class="Code-In-Text--PACKT-">query</code> prop, which allows us to filter the projects on GitHub. The <code class="Code-In-Text--PACKT-">query</code> prop will receive a keyword such as "javascript" or "react", and this value will be used to construct the API call to GitHub.</p>
    <p class="normal">Let's finally have a look at the code <a id="_idIndexMarker947"/>of the <code class="Code-In-Text--PACKT-">RecentGithubProjects</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/RecentGithubProjects.js</span>
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createRequestUri</span><span class="hljs-function"> (</span><span class="hljs-params">query</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`https://api.github.com/search/repositories?q=</span><span class="hljs-subst">${</span>
<span class="hljs-subst">    </span><span class="hljs-built_in">encodeURIComponent</span>(query)
<span class="hljs-subst">  }</span><span class="hljs-string">&amp;sort=updated`</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RecentGithubProjects</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (props) {                                    <span class="hljs-comment">// (1)</span>
    <span class="hljs-built_in">super</span>(props)                                           <span class="hljs-comment">// (2)</span>
    <span class="hljs-built_in">this</span>.state = {                                         <span class="hljs-comment">// (3)</span>
      loading: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">projects</span>: []
    }
  }
  <span class="hljs-keyword">async</span> loadData () {                                      <span class="hljs-comment">// (4)</span>
    <span class="hljs-built_in">this</span>.setState({ <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">projects</span>: [] })
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(
      createRequestUri(<span class="hljs-built_in">this</span>.props.query),
      { <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span> }
    )
    <span class="hljs-keyword">const</span> responseBody = <span class="hljs-keyword">await</span> response.json()
    <span class="hljs-built_in">this</span>.setState({
      <span class="hljs-attr">projects</span>: responseBody.items,
      <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>
    })
  }
  componentDidMount () {                                   <span class="hljs-comment">// (5)</span>
    <span class="hljs-built_in">this</span>.loadData()
  }
  componentDidUpdate (prevProps) {                         <span class="hljs-comment">// (6)</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.query !== prevProps.query) {
      <span class="hljs-built_in">this</span>.loadData()
    }
  }
  render () {                                              <span class="hljs-comment">// (7)</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.loading) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'Loading ...'</span>
    }
                                                           <span class="hljs-comment">// (8)</span>
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">state</span>.<span class="hljs-subst">projects</span>.map(project =&gt; html`
        <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>project.<span class="hljs-subst">id}</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>project.<span class="hljs-subst">html_url}</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span>project.<span class="hljs-subst">full_name}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>:
          <span class="hljs-subst">${</span><span class="hljs-string">' '</span><span class="hljs-subst">}${</span>project.<span class="hljs-subst">description}</span>
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
      `)<span class="hljs-subst">}</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">There are some new React concepts<a id="_idIndexMarker948"/> in this component, so let's discuss the main details here:</p>
    <ol>
      <li class="numbered">In this new component, we are overriding the default constructor. A constructor accepts the props passed to the component as an argument.</li>
      <li class="numbered">The first thing we have to do is call the original constructor and propagate the props so that the component can be initialized correctly by React.</li>
      <li class="numbered">Now, we can define the initial component state. Our final state is going to be a list of GitHub projects, but those won't be available immediately as we will need to load them dynamically. Therefore, we define the initial state as a boolean flag, indicating that we are loading the data and the list of projects as an empty array.</li>
      <li class="numbered">The function <code class="Code-In-Text--PACKT-">loadData()</code> is the function that is responsible for making the API request, fetching the necessary data, and updating the internal state using <code class="Code-In-Text--PACKT-">this.setState()</code>. Note that <code class="Code-In-Text--PACKT-">this.setState()</code> is called twice: before we issue the HTTP request (to activate the loading state) and when the request is completed (to unset the loading flag and populate the list of projects). React will re-render the component automatically when the state changes.</li>
      <li class="numbered">Here, we are introducing another new concept: the <code class="Code-In-Text--PACKT-">componentDidMount</code> <em class="italic">lifecycle</em> function. This function is automatically invoked by React once the component has been successfully instantiated and attached (or <em class="italic">mounted</em>) to the DOM. This is the perfect place to load our data for the first time.</li>
      <li class="numbered">The function <code class="Code-In-Text--PACKT-">componentDidUpdate</code> is another React lifecycle function and it is automatically invoked every time the component is updated (for instance, if new props have been passed to the component). Here, we check if the <code class="Code-In-Text--PACKT-">query</code> prop has changed since the last update. If that's the case, then we need to reload the list of projects.</li>
      <li class="numbered">Finally, let's see what happens <a id="_idIndexMarker949"/>in our <code class="Code-In-Text--PACKT-">render()</code> function. The main thing to note is that here we have to handle the two different states of the component: the loading state and the state where we have the list of projects available for display. Since React will invoke the <code class="Code-In-Text--PACKT-">render()</code> function every time the state or the props change, just having an <code class="Code-In-Text--PACKT-">if</code> statement here will be enough. This technique<a id="_idIndexMarker950"/> is often called <strong class="keyword">conditional rendering</strong>.</li>
      <li class="numbered">In this final step, we are rendering a list of elements using <code class="Code-In-Text--PACKT-">Array.map()</code> to create a list element for every project fetched using the GitHub API. Note that every list element receives a value for the <code class="Code-In-Text--PACKT-">key</code> prop. The <code class="Code-In-Text--PACKT-">key</code> prop is a special prop that is recommended whenever you are rendering an array of elements. Every element should provide a unique <code class="Code-In-Text--PACKT-">key</code>. This prop helps the virtual DOM optimize every rendering pass (If you are curious to understand in detail what React does in this situation you can have a look at <a href="http://nodejsdp.link/react-reconciliation"><span class="url">nodejsdp.link/react-reconciliation</span></a>).</li>
    </ol>
    <div class="packt_tip">
      <p class="Tip--PACKT-">You might have noticed that we are not handling potential errors while fetching the data. There are several ways we can do this in React. The most elegant solution is probably implementing an <code class="Code-In-Text--PACKT-">ErrorBoundary</code> component (<a href="http://nodejsdp.link/error-boundary"><span class="url">nodejsdp.link/error-boundary</span></a>), but <a id="_idIndexMarker951"/>we will leave that as an exercise for you.</p>
    </div>
    <p class="normal">Let's now write the main application component. Here, we want to display a navigation menu where the user can select different queries ("JavaScript", "Node.js", and "React") to filter for different types of <a id="_idIndexMarker952"/>GitHub projects:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/App.js</span>
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { RecentGithubProjects } <span class="hljs-keyword">from</span> <span class="hljs-string">'./RecentGithubProjects.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">App</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (props) {
    <span class="hljs-built_in">super</span>(props)
    <span class="hljs-built_in">this</span>.state = {
      <span class="hljs-attr">query</span>: <span class="hljs-string">'javascript'</span>,
      <span class="hljs-attr">label</span>: <span class="hljs-string">'JavaScript'</span>
    }
    <span class="hljs-built_in">this</span>.setQuery = <span class="hljs-built_in">this</span>.setQuery.bind(<span class="hljs-built_in">this</span>)
  }
  setQuery (e) {
    e.preventDefault()
    <span class="hljs-keyword">const</span> label = e.currentTarget.text
    <span class="hljs-built_in">this</span>.setState({ label, <span class="hljs-attr">query</span>: label.toLowerCase() })
  }
  render () {
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">nav</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"#"</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">setQuery}</span><span class="hljs-tag">&gt;</span>JavaScript<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-subst">${</span><span class="hljs-string">' '</span><span class="hljs-subst">}</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"#"</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">setQuery}</span><span class="hljs-tag">&gt;</span>Node.js<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-subst">${</span><span class="hljs-string">' '</span><span class="hljs-subst">}</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"#"</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">setQuery}</span><span class="hljs-tag">&gt;</span>React<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">nav</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Recently updated <span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">state</span>.<span class="hljs-subst">label}</span> projects<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${RecentGithubProjects}</span><span class="hljs-tag"> </span><span class="hljs-attr">query</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">state.query}</span><span class="hljs-tag">/&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">This component is using its internal state to track the currently selected query. Initially, the "javascript" query is set and passed down to the <code class="Code-In-Text--PACKT-">RecentGithubProjects</code> component. Then, every time a keyword in the navigation menu is clicked, we update the state with the new selected keyword. When this happens, the <code class="Code-In-Text--PACKT-">render()</code> method will be automatically invoked and it will pass the new value for the <code class="Code-In-Text--PACKT-">query</code> prop to <code class="Code-In-Text--PACKT-">RecentGithubProjects</code>. In turn, <code class="Code-In-Text--PACKT-">RecentGithubProjects</code> will be marked as <em class="italic">updated</em>, and it will internally reload and eventually update the list of projects for the new query.</p>
    <p class="normal">One interesting detail to underline<a id="_idIndexMarker953"/> is that, in the constructor, we are explicitly binding the <code class="Code-In-Text--PACKT-">setQuery()</code> function to the current component instance. The reason why we do this is because this function is used directly as an event handler for the click event. In this case, the reference to <code class="Code-In-Text--PACKT-">this</code> would be <code class="Code-In-Text--PACKT-">undefined</code> without the bind and it would not be possible to call <code class="Code-In-Text--PACKT-">this.setState()</code> from the handler.</p>
    <p class="normal">At this point, we only need to attach the <code class="Code-In-Text--PACKT-">App</code> component to the DOM to run our application. Let's do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { App } <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
ReactDOM.render(
  html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${App}</span><span class="hljs-tag">/&gt;</span>`,
  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'body'</span>)[<span class="hljs-number">0</span>]
)
</code></pre>
    <p class="normal">Finally, let's just run the application with <code class="Code-In-Text--PACKT-">npm start</code> and test it on the browser.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that since we used async/await in our application, the default configuration generated by webpack might not work straight away. If you have any issues, compare your configuration file with the one in the code examples provided with this book (<a href="http://nodejsdp.link/wpconf"><span class="url">nodejsdp.link/wpconf</span></a>).</p>
    </div>
    <p class="normal">Try to refresh the page and click on the various keywords on the navigation menu. After a few seconds, you should see the list of projects being refreshed.</p>
    <p class="normal">At this point, it should be quite<a id="_idIndexMarker954"/> clear to you how React works, how to compose components together, and how to take advantage of state and props. Hopefully, this simple exercise will also help you to find new, interesting, open source JavaScript projects that you might want to contribute to!</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We've covered just enough ground for us to be able to build our first Universal React application. But if you want to be proficient with React, we recommend that you read the official React documentation (<a href="http://nodejsdp.link/react-docs"><span class="url">nodejsdp.link/react-docs</span></a>) for a more exhaustive overview of the library.</p>
    </div>
    <p class="normal">We are finally ready to take what we learned about webpack and React to create a simple, yet complete, universal JavaScript application.</p>
    <h1 id="_idParaDest-284" class="title">Creating a Universal JavaScript app</h1>
    <p class="normal">Now<a id="_idIndexMarker955"/> that we've covered the basics, let's start to build a more complete Universal JavaScript application. We are going to build a simple "book library" application where we can list different authors and see their biography and some of their masterpieces. Although this is going to be a very simple application, it will allow us to cover more advanced topics such as <strong class="keyword">universal routing</strong>, <strong class="keyword">universal rendering</strong>, and <strong class="keyword">universal data fetching</strong>. The idea is that you can later use this application as a scaffold for a real project and build on top of it your next universal JavaScript application.</p>
    <p class="normal">In this experiment, we are going to use the following technologies:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">React</strong> (<a href="http://nodejsdp.link/react"><span class="url">nodejsdp.link/react</span></a>), which we <a id="_idIndexMarker956"/>just introduced</li>
      <li class="Bullet--PACKT-"><strong class="keyword">React Router</strong> (<a href="http://nodejsdp.link/react-router"><span class="url">nodejsdp.link/react-router</span></a>), a companion <a id="_idIndexMarker957"/>routing layer for React</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Fastify</strong> (<a href="http://nodejsdp.link/fastify"><span class="url">nodejsdp.link/fastify</span></a>), a fast and ergonomic framework to build web servers in <a id="_idIndexMarker958"/>Node.js</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Webpack</strong> as the module bundler</li>
    </ul>
    <p class="normal">For practical reasons, we selected a very specific set of technologies for this exercise, but we will try to focus as much as possible on the design principles and patterns rather than the technologies themselves. As you learn these patterns, you should be able to use the acquired knowledge with <a id="_idIndexMarker959"/>any other combination of technologies and achieve similar results.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In order to keep things simple, we will be using webpack only to process the frontend code and we will leave the backend code unchanged, leveraging the native Node.js support for ESM.</p>
      <p class="Information-Box--PACKT-">At the time of writing, there are some subtle discrepancies between how webpack interprets the semantics of ESM imports as opposed to how Node.js does it, especially when importing modules written using the CommonJS syntax. For this reason, we recommend running the examples in the rest of this chapter using <code class="Code-In-Text--PACKT-">esm</code> (<a href="http://nodejsdp.link/esm"><span class="url">nodejsdp.link/esm</span></a>), a Node.js library that will preprocess ESM imports in a way that minimizes those differences. Once you have installed the <code class="Code-In-Text--PACKT-">esm</code> module in your project, you can run a script with <code class="Code-In-Text--PACKT-">esm</code> as follows:</p>
      <pre class="programlisting con"><code class="hljs-con">node –r esm script.js
</code></pre>
    </div>
    <h2 id="_idParaDest-285" class="title">Frontend-only app</h2>
    <p class="normal">In this section, we are <a id="_idIndexMarker960"/>going to focus on building our app on the frontend only, using webpack as a development web server. In the next sections, we will expand and update this basic app to convert it to a full Universal JavaScript application.</p>
    <p class="normal">This time, we will be using a custom webpack configuration, so let's start by creating a new folder and copying the <code class="Code-In-Text--PACKT-">package.json</code> and <code class="Code-In-Text--PACKT-">webpack.config.cjs</code> files from the code repository provided with this book (<a href="http://nodejsdp.link/frontend-only-app"><span class="url">nodejsdp.link/frontend-only-app</span></a>), then install all the necessary dependencies with:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install
</code></pre>
    <p class="normal">The data we will be using is stored in a JavaScript file (as a simple substitute for a database), so make sure you copy the file <code class="Code-In-Text--PACKT-">data/authors.js</code> into your project as well. This file contains some sample data in the following format:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> authors = [
  {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'author\'s unique id'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'author\'s name'</span>,
    <span class="hljs-attr">bio</span>: <span class="hljs-string">'author\'s biography'</span>,
    <span class="hljs-attr">books</span>: [ <span class="hljs-comment">// author's books</span>
      {
        <span class="hljs-attr">id</span>: <span class="hljs-string">'book unique id'</span>,
        <span class="hljs-attr">title</span>: <span class="hljs-string">'book title'</span>,
        <span class="hljs-attr">year</span>: <span class="hljs-number">1914</span> <span class="hljs-comment">// book publishing year</span>
      },
      <span class="hljs-comment">// ... more books</span>
    ]
  },
  <span class="hljs-comment">// ... more authors</span>
]
</code></pre>
    <p class="normal">Of course, feel free to change the data in this file if you want to add your favorite authors and books!</p>
    <p class="normal">Now that we have all the configuration in place, let's quickly discuss what we want our application to look like.</p>
    <figure class="mediaobject"><img src="../Images/B15729_10_03.png" alt="../../../Downloads/Untitled%20Diagram%20(15).png"/></figure>
    <p class="packt_figref">Figure 10.3: Application mockup</p>
    <p class="normal"><em class="italic">Figure 10.3</em> shows that our<a id="_idIndexMarker961"/> application will have two different types of page: an index page, where we list all the authors available in our data store, and then a page to visualize the details of a given author, where we will see their biography and some of their books.</p>
    <p class="normal">These two types of page will only have a header in common. This will allow us to go back to the index page at any time.</p>
    <p class="normal">We will be exposing the index page at the root path of our server (<code class="Code-In-Text--PACKT-">/</code>), while we will be using the path <code class="Code-In-Text--PACKT-">/author/:authorId</code> for the author's page.</p>
    <p class="normal">Finally, we will also have a <code class="Code-In-Text--PACKT-">404</code> page.</p>
    <p class="normal">In terms of file structure, we will organize our project as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">src
├── data
│   └── <strong class="hljs-slc">authors.js</strong>              – data file
└── frontend
    ├── <strong class="hljs-slc">App.js</strong>                  – application component
    ├── components
    │   ├── <strong class="hljs-slc">Header.js</strong>           – header component
    │   └── pages
    │       ├── <strong class="hljs-slc">Author.js</strong>       – author page
    │       ├── <strong class="hljs-slc">AuthorsIndex.js</strong> – index page
    │       └── <strong class="hljs-slc">FourOhFour.js</strong>   – 404 page
    └── <strong class="hljs-slc">index.js</strong>                – project entry point
</code></pre>
    <p class="normal">Let's start by writing the <code class="Code-In-Text--PACKT-">index.js</code> module, which will serve as the entry point for loading our frontend application and attaching it to the DOM:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> reactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { BrowserRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { App } <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
reactDOM.render(
  html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${BrowserRouter}</span><span class="hljs-tag">&gt;&lt;</span><span class="hljs-subst">${App}</span><span class="hljs-tag">/&gt;&lt;/&gt;</span>`,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)
</code></pre>
    <p class="normal">This code is quite simple as <a id="_idIndexMarker962"/>we are mainly importing the <code class="Code-In-Text--PACKT-">App</code> component and attaching it to the DOM in an element with the ID equal to <code class="Code-In-Text--PACKT-">root</code>. The only detail that stands out is that we are wrapping the application into a <code class="Code-In-Text--PACKT-">BrowserRouter</code> component. This component comes from the <code class="Code-In-Text--PACKT-">react-router-dom</code> library and it provides our app with client-side routing capabilities. Some of the components we will be writing next will showcase how to fully take advantage of these routing capabilities and how to connect different pages together using links. Later on, we will revisit this routing configuration to make it available on the server side as well.</p>
    <p class="normal">Right now, let's focus on the source code for <code class="Code-In-Text--PACKT-">App.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Switch, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { AuthorsIndex } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/AuthorsIndex.js'</span>
<span class="hljs-keyword">import</span> { Author } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/Author.js'</span>
<span class="hljs-keyword">import</span> { FourOhFour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/FourOhFour.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">App</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> html`
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Switch}</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Route}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">path</span><span class="hljs-tag">=</span><span class="hljs-string">"/"</span>
<span class="hljs-tag">          </span><span class="hljs-attr">exact</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-literal">true</span><span class="hljs-subst">}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">component</span><span class="hljs-tag">=</span><span class="hljs-subst">${AuthorsIndex}</span>
<span class="hljs-tag">        /&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Route}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">path</span><span class="hljs-tag">=</span><span class="hljs-string">"/author/:authorId"</span>
<span class="hljs-tag">          </span><span class="hljs-attr">component</span><span class="hljs-tag">=</span><span class="hljs-subst">${Author}</span>
<span class="hljs-tag">        /&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Route}</span>
<span class="hljs-tag">          </span><span class="hljs-attr">path</span><span class="hljs-tag">=</span><span class="hljs-string">"*"</span>
<span class="hljs-tag">          </span><span class="hljs-attr">component</span><span class="hljs-tag">=</span><span class="hljs-subst">${FourOhFour}</span>
<span class="hljs-tag">        /&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span>
    `
  }
}
</code></pre>
    <p class="normal">As you can tell from this code, the <code class="Code-In-Text--PACKT-">App</code> component is responsible for loading all the page components and configuring the routing for them.</p>
    <p class="normal">Here, we are using the <code class="Code-In-Text--PACKT-">Switch</code> component<a id="_idIndexMarker963"/> from <code class="Code-In-Text--PACKT-">react-router-dom</code>. This component allows us to define <code class="Code-In-Text--PACKT-">Route</code> components. Every <code class="Code-In-Text--PACKT-">Route</code> component needs to have a <code class="Code-In-Text--PACKT-">path</code> and a <code class="Code-In-Text--PACKT-">component</code> prop associated with it. At render time, <code class="Code-In-Text--PACKT-">Switch</code> will check the current URL against the paths defined by the routes, and it will render the component associated to the first <code class="Code-In-Text--PACKT-">Route</code> component that matches.</p>
    <p class="normal">As in a JavaScript <code class="Code-In-Text--PACKT-">switch</code> statement, where the order of <code class="Code-In-Text--PACKT-">case</code> statements is important, here, the order of the <code class="Code-In-Text--PACKT-">Route</code> components is important too. Our last route is a <em class="italic">catch-all route</em>, which will always match if none of the previous routes matches..</p>
    <p class="normal">Note also that we are setting the prop <code class="Code-In-Text--PACKT-">exact</code> for the first <code class="Code-In-Text--PACKT-">Route</code>. This is needed because <code class="Code-In-Text--PACKT-">react-router-dom</code> will match based <a id="_idIndexMarker964"/>on prefixes, so a plain <code class="Code-In-Text--PACKT-">/</code> will match any URL. By specifying <code class="Code-In-Text--PACKT-">exact: true</code>, we are telling the router to only match this path if it is exactly <code class="Code-In-Text--PACKT-">/</code> (and not if it just starts with <code class="Code-In-Text--PACKT-">/</code>).</p>
    <p class="normal">Let's now have a quick look at our <code class="Code-In-Text--PACKT-">Header</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Header</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">header</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Link}</span><span class="hljs-tag"> </span><span class="hljs-attr">to</span><span class="hljs-tag">=</span><span class="hljs-string">"/"</span><span class="hljs-tag">&gt;</span>My library<span class="hljs-tag">&lt;/&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">header</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">This is a very simple component that just renders an <code class="Code-In-Text--PACKT-">h1</code> title containing "My library." The only detail worth discussing here is that the title is wrapped by a <code class="Code-In-Text--PACKT-">Link</code> component from the <code class="Code-In-Text--PACKT-">react-router-dom</code> library. This component is responsible for rendering a clickable link that can interact with the application router to switch to a new route dynamically, without refreshing the entire page.</p>
    <p class="normal">Now, we have to write, one by one, our page components. Let's start with the <code class="Code-In-Text--PACKT-">AuthorsIndex</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">import</span> { authors } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../data/authors.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AuthorsIndex</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Header}</span><span class="hljs-tag">/&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span>authors.map((author) =&gt;
        html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">id}</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Link}</span><span class="hljs-tag"> </span><span class="hljs-attr">to</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-subst">${</span><span class="hljs-string">`/author/</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">id}</span><span class="hljs-string">`</span><span class="hljs-subst">}</span><span class="hljs-string">"</span><span class="hljs-tag">&gt;</span>
              <span class="hljs-subst">${</span>author.<span class="hljs-subst">name}</span>
            <span class="hljs-tag">&lt;/&gt;</span>
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`)<span class="hljs-subst">}</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">Yet another very simple component. Here, we are rendering some markup dynamically based on the list of authors <a id="_idIndexMarker965"/>available in our data file. Note that we are using, once again, the <code class="Code-In-Text--PACKT-">Link</code> component from <code class="Code-In-Text--PACKT-">react-router-dom</code> to create dynamic links to the author page.</p>
    <p class="normal">Now, let's have a look at the <code class="Code-In-Text--PACKT-">Author</code> component code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { FourOhFour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./FourOhFour.js'</span>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">import</span> { authors } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../data/authors.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Author</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">const</span> author = authors.find(
      <span class="hljs-params">author</span><span class="hljs-function"> =&gt;</span> author.id === <span class="hljs-built_in">this</span>.props.match.params.authorId
    )
    <span class="hljs-keyword">if</span> (!author) {
      <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${FourOhFour}</span><span class="hljs-tag"> </span><span class="hljs-attr">error</span><span class="hljs-tag">=</span><span class="hljs-string">"Author not found"</span><span class="hljs-tag">/&gt;</span>`
    }
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Header}</span><span class="hljs-tag">/&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">name}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">bio}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>Books<span class="hljs-tag">&lt;/</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-subst">${</span>author.<span class="hljs-subst">books</span>.map((book) =&gt;
          html`<span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>book.<span class="hljs-subst">id}</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span>book.<span class="hljs-subst">title}</span> (<span class="hljs-subst">${</span>book.<span class="hljs-subst">year}</span>)<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>`
        )<span class="hljs-subst">}</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">This component has a little bit of logic in it. In the <code class="Code-In-Text--PACKT-">render()</code> method, we filter the <code class="Code-In-Text--PACKT-">authors</code> dataset to find the current author. Notice that we are using <code class="Code-In-Text--PACKT-">props.match.params.authorId</code> to get the current author ID. The <code class="Code-In-Text--PACKT-">match</code> prop will be passed to the component by the router at render time and the nested <code class="Code-In-Text--PACKT-">params</code> object will be populated if the current path has dynamic parameters.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">It is common practice to memoize (<a href="http://nodejsdp.link/memoization"><span class="url">nodejsdp.link/memoization</span></a>) the result of any complex calculation performed in the <code class="Code-In-Text--PACKT-">render()</code> method. This prevents the complex calculation from running again in case its inputs haven't changed since the last render. In our example, a possible target for this type of optimization is the call to <code class="Code-In-Text--PACKT-">authors.find()</code>. We leave this to you as an exercise. If you want to know more about this technique take a look at <a href="http://nodejsdp.link/react-memoization"><span class="url">nodejsdp.link/react-memoization</span></a>.</p>
    </div>
    <p class="normal">There's a chance that we are receiving an<a id="_idIndexMarker966"/> ID that doesn't match any author in our dataset, so in this case, <code class="Code-In-Text--PACKT-">author</code> will be <code class="Code-In-Text--PACKT-">undefined</code>. This is clearly a <code class="Code-In-Text--PACKT-">404</code>, so instead of rendering the author data, we delegate the render logic to the <code class="Code-In-Text--PACKT-">FourOhFour</code> component, which is responsible for rendering the <code class="Code-In-Text--PACKT-">404</code> error page.</p>
    <p class="normal">Finally, let's see the source code for the <code class="Code-In-Text--PACKT-">FourOhFour</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FourOhFour</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Header}</span><span class="hljs-tag">/&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>404<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">props</span>.<span class="hljs-subst">error</span> || <span class="hljs-string">'Page not found'</span><span class="hljs-subst">}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Link}</span><span class="hljs-tag"> </span><span class="hljs-attr">to</span><span class="hljs-tag">=</span><span class="hljs-string">"/"</span><span class="hljs-tag">&gt;</span>Go back to the home page<span class="hljs-tag">&lt;/&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">This component is responsible for rendering the <code class="Code-In-Text--PACKT-">404</code> page. Note that we made the error message configurable through the <code class="Code-In-Text--PACKT-">error</code> prop and also that we are using a <code class="Code-In-Text--PACKT-">Link</code> from the <code class="Code-In-Text--PACKT-">react-router-dom</code> library to allow the user to travel back to the home page when landing on this error page.</p>
    <p class="normal">This was quite a lot of code, but we are finally ready to run our frontend-only React application: just type <code class="Code-In-Text--PACKT-">npm start</code> in your console and you should see the application running in your browser. Pretty barebones, but if we did everything correctly, it should work as expected and allow us to see our favorite authors and their masterpieces.</p>
    <p class="normal">It is worth using the app with the browser <a id="_idIndexMarker967"/>developer tools open so that we can verify that our dynamic routing is working correctly, that is, once the first page is loaded, transitions to other pages happen without any page refresh.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">For a better understanding of what happens when you interact with a React application, you can install and use the React Developer Tools browser extension on Chrome (<a href="http://nodejsdp.link/react-dev-tools-chrome"><span class="url">nodejsdp.link/react-dev-tools-chrome</span></a>) or Firefox (<a href="http://nodejsdp.link/react-dev-tools-firefox"><span class="url">nodejsdp.link/react-dev-tools-firefox</span></a>).</p>
    </div>
    <h2 id="_idParaDest-286" class="title">Server-side rendering</h2>
    <p class="normal">Our application works <a id="_idIndexMarker968"/>and this is great news. However, the app is running only on the client side, which means that if we try to <code class="Code-In-Text--PACKT-">curl</code> one of the pages, we will see something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My library&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;div id="root"&gt;&lt;/div&gt;
  &lt;script type="text/javascript" src="/main.js"&gt;&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <p class="normal">No content whatsoever! There's only an empty container (the root <code class="Code-In-Text--PACKT-">div</code>), which is where our application is mounted at runtime.</p>
    <p class="normal">In this section, we will modify our application to be able to render the content also from the server.</p>
    <p class="normal">Let's<a id="_idIndexMarker969"/> start by adding <code class="Code-In-Text--PACKT-">fastify</code> and <code class="Code-In-Text--PACKT-">esm</code> to our project:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --save fastify fastify-static esm
</code></pre>
    <p class="normal">Now, we can create our server application in <code class="Code-In-Text--PACKT-">src/server.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { resolve, dirname } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> reactServer <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/server.js'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> fastify <span class="hljs-keyword">from</span> <span class="hljs-string">'fastify'</span>
<span class="hljs-keyword">import</span> fastifyStatic <span class="hljs-keyword">from</span> <span class="hljs-string">'fastify-static'</span>
<span class="hljs-keyword">import</span> { StaticRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { App } <span class="hljs-keyword">from</span> <span class="hljs-string">'./frontend/App.js'</span>
<span class="hljs-keyword">const</span> __dirname = dirname(fileURLToPath(<span class="hljs-keyword">import</span>.meta.url))
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">const</span> template = <span class="hljs-function">(</span><span class="hljs-params">{ content }</span><span class="hljs-function">) =&gt;</span> <span class="hljs-string">`&lt;!DOCTYPE html&gt;</span>
<span class="hljs-string">&lt;html&gt;</span>
<span class="hljs-string">  &lt;head&gt;</span>
<span class="hljs-string">    &lt;meta charset="UTF-8"&gt;</span>
<span class="hljs-string">    &lt;title&gt;My library&lt;/title&gt;</span>
<span class="hljs-string">  &lt;/head&gt;</span>
<span class="hljs-string">  &lt;body&gt;</span>
<span class="hljs-string">    &lt;div id="root"&gt;</span><span class="hljs-subst">${content}</span><span class="hljs-string">&lt;/div&gt;</span>
<span class="hljs-string">    &lt;script type="text/javascript" src="/public/main.js"&gt;&lt;/script&gt;</span>
<span class="hljs-string">  &lt;/body&gt;</span>
<span class="hljs-string">&lt;/html&gt;`</span>
<span class="hljs-keyword">const</span> server = fastify({ <span class="hljs-attr">logger</span>: <span class="hljs-literal">true</span> })                   <span class="hljs-comment">// (2)</span>
server.register(fastifyStatic, {                           <span class="hljs-comment">// (3)</span>
  root: resolve(__dirname, <span class="hljs-string">'..'</span>, <span class="hljs-string">'public'</span>),
  <span class="hljs-attr">prefix</span>: <span class="hljs-string">'/public/'</span>
})
server.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> (req, reply) =&gt; {                    <span class="hljs-comment">// (4)</span>
  <span class="hljs-keyword">const</span> location = req.raw.originalUrl
                                                           <span class="hljs-comment">// (5)</span>
  <span class="hljs-keyword">const</span> serverApp = html`
    <span class="hljs-tag">&lt;</span><span class="hljs-subst">${StaticRouter}</span><span class="hljs-tag"> </span><span class="hljs-attr">location</span><span class="hljs-tag">=</span><span class="hljs-subst">${location}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${App}</span><span class="hljs-tag">/&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  `
  <span class="hljs-keyword">const</span> content = reactServer.renderToString(serverApp)    <span class="hljs-comment">// (6)</span>
  <span class="hljs-keyword">const</span> responseHtml = template({ content })
  reply.code(<span class="hljs-number">200</span>).type(<span class="hljs-string">'text/html'</span>).send(responseHtml)
})
<span class="hljs-keyword">const</span> port = <span class="hljs-built_in">Number</span>.parseInt(process.env.PORT) || <span class="hljs-number">3000</span>     <span class="hljs-comment">// (7)</span>
<span class="hljs-keyword">const</span> address = process.env.ADDRESS || <span class="hljs-string">'127.0.0.1'</span>
server.listen(port, address, <span class="hljs-keyword">function</span><span class="hljs-function"> (</span><span class="hljs-params">err</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err)
    process.exit(<span class="hljs-number">1</span>)
  }
})
</code></pre>
    <p class="normal">There's a lot of code here, so let's<a id="_idIndexMarker970"/> discuss step by step the main concepts introduced here:</p>
    <ol>
      <li class="numbered">Since we are not going to use the webpack dev server, we need to return the full HTML code of the page from our server. Here, we are defining the HTML template for all our pages using a function and a template literal. We will be passing the result of our server-rendered React application as <code class="Code-In-Text--PACKT-">content</code> to this template to get the final HTML to return to the client.</li>
      <li class="numbered">Here, we create a Fastify server instance and enable logging.</li>
      <li class="numbered">As you might have noticed from our template code, our web application will load the script <code class="Code-In-Text--PACKT-">/public/main.js</code>. This file is the frontend bundle that is generated by webpack. Here, we are letting the Fastify server instance serve all static assets from the <code class="Code-In-Text--PACKT-">public</code> folder using the <code class="Code-In-Text--PACKT-">fastify-static</code> plugin.</li>
      <li class="numbered">In this line, we define a catch-all route for every <code class="Code-In-Text--PACKT-">GET</code> request to the server. The reason why we are doing a catch-all route is because the actual routing logic is already contained in the React application. When we render the React application, it will display the correct page component based on the current URL.</li>
      <li class="numbered">On the server side, we have to use an instance of <code class="Code-In-Text--PACKT-">StaticRouter</code> from <code class="Code-In-Text--PACKT-">react-router-dom</code> and wrap our application component with it. <code class="Code-In-Text--PACKT-">StaticRouter</code> is a version of React Router that can be used for server-side rendering. This router, rather than taking the current URL from the browser window, allows us to pass the current URL directly from the server through the <code class="Code-In-Text--PACKT-">location</code> prop.</li>
      <li class="numbered">Here, we can finally generate the HTML code for our <code class="Code-In-Text--PACKT-">serverApp</code> component by using React's <code class="Code-In-Text--PACKT-">renderToString()</code> function. The generated HTML is the same as the one generated by<a id="_idIndexMarker971"/> the client-side application on a given URL. In the next few lines, we wrap this code with our page layout using the <code class="Code-In-Text--PACKT-">template()</code> function and finally, we send the result to the client.</li>
      <li class="numbered">In the last few lines of code, we tell our Fastify <code class="Code-In-Text--PACKT-">server</code> instance to listen on a given address and port defaulting to <code class="Code-In-Text--PACKT-">localhost:3000</code>.</li>
    </ol>
    <p class="normal">Now, we can run <code class="Code-In-Text--PACKT-">npm run build</code> to create the frontend bundle and finally, we can run our server, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">node -r esm src/server.js
</code></pre>
    <p class="normal">Let's open our browser on <code class="Code-In-Text--PACKT-">http://localhost:3000/</code> and see if our app is still working as expected. All good, right? Great! Now, let's try to <code class="Code-In-Text--PACKT-">curl</code> our home page to see if the server-generated code looks different:</p>
    <pre class="programlisting con"><code class="hljs-con">curl http://localhost:3000/
</code></pre>
    <p class="normal">This time, this is what we should see:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My library&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;div&gt;&lt;header&gt;&lt;h1&gt;&lt;a href="/"&gt;My library&lt;/a&gt;&lt;/h1&gt;&lt;/header&gt;&lt;div&gt;&lt;h2&gt;Authors&lt;/h2&gt;&lt;div&gt;&lt;div&gt;&lt;a href="/author/joyce"&gt;&lt;p&gt;James Joyce&lt;/p&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="/author/h-g-wells"&gt;&lt;p&gt;Herbert George Wells&lt;/p&gt;&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a href="/author/orwell"&gt;&lt;p&gt;George Orwell&lt;/p&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="/public/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <p class="normal">Great! This time, our root container is not empty: we are rendering the list of authors directly from the server. You should also try some author pages and see that it works correctly for those as well. Mission <a id="_idIndexMarker972"/>complete! Well, almost... what happens if we try to render a page that does not exist? Let's have a look:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -i http://localhost:3000/blah
</code></pre>
    <p class="normal">This will print:</p>
    <pre class="programlisting con"><code class="hljs-con">HTTP/1.1 200 OK
content-type: text/html
content-length: 367
Date: Sun, 05 Apr 2020 18:38:47 GMT
Connection: keep-alive
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My library&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;div&gt;&lt;header&gt;&lt;h1&gt;&lt;a href="/"&gt;My library&lt;/a&gt;&lt;/h1&gt;&lt;/header&gt;&lt;div&gt;&lt;h2&gt;404&lt;/h2&gt;&lt;h3&gt;Page not found&lt;/h3&gt;&lt;a href="/"&gt;Go back to the home page&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="/public/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <p class="normal">At first glance, this might seem correct because we are rendering our <code class="Code-In-Text--PACKT-">404</code> page, but we are actually returning a <code class="Code-In-Text--PACKT-">200</code> status code… not good!</p>
    <p class="normal">We can actually fix this with just a little extra effort, so let's do it.</p>
    <p class="normal">React <code class="Code-In-Text--PACKT-">StaticRouter</code> allows us to pass a generic <code class="Code-In-Text--PACKT-">context</code> prop that can be used to exchange information between the React application and the server. We can leverage this utility to allow our 404 page to inject some information into this shared context so that on the server side, we are aware of<a id="_idIndexMarker973"/> whether we should return a <code class="Code-In-Text--PACKT-">200</code> or a <code class="Code-In-Text--PACKT-">404</code> status code.</p>
    <p class="normal">Let's update the catch-all route on the server side first:</p>
    <pre class="programlisting code"><code class="hljs-code">server.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> (req, reply) =&gt; {
  <span class="hljs-keyword">const</span> location = req.raw.originalUrl
  <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> staticContext = {}</strong>
  <span class="hljs-keyword">const</span> serverApp = html`
    <span class="hljs-tag">&lt;</span><span class="hljs-subst">${StaticRouter}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">location</span><span class="hljs-tag">=</span><span class="hljs-subst">${location}</span>
<span class="hljs-tag">      </span><strong class="hljs-attr-slc">context</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-subst-slc">${staticContext}</strong>
<span class="hljs-tag">    &gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${App}</span><span class="hljs-tag">/&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  `
  <span class="hljs-keyword">const</span> content = reactServer.renderToString(serverApp)
  <span class="hljs-keyword">const</span> responseHtml = template({ content })
  <strong class="hljs-keyword-slc">let</strong><strong class="hljs-slc"> code = </strong><strong class="hljs-number-slc">200</strong>
  <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (staticContext.statusCode) {</strong>
    <strong class="hljs-slc">code = staticContext.statusCode</strong>
  <strong class="hljs-slc">}</strong>
  reply.code(<strong class="hljs-slc">code</strong>).type(<span class="hljs-string">'text/html'</span>).send(responseHtml)
})
</code></pre>
    <p class="normal">The changes from the previous version are highlighted in bold. As you can see, we create an empty object called <code class="Code-In-Text--PACKT-">staticContext</code> and pass it to the router instance in the <code class="Code-In-Text--PACKT-">context</code> prop. Later on, after the server-side rendering is completed, we check if <code class="Code-In-Text--PACKT-">staticContext.statusCode</code> was populated during the rendering process. If it was, it will now contain the status code that we have to return to the client, together with the rendered HTML code.</p>
    <p class="normal">Let's now change the <code class="Code-In-Text--PACKT-">FourOhFour</code> component to actually populate this value. To do this, we just need to update the <code class="Code-In-Text--PACKT-">render()</code> function with the following code before we return the elements to render:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.staticContext) {
  <span class="hljs-built_in">this</span>.props.staticContext.statusCode = <span class="hljs-number">404</span>
}
</code></pre>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">context</code> prop passed to <code class="Code-In-Text--PACKT-">StaticRouter</code> is passed only to direct children of <code class="Code-In-Text--PACKT-">Route</code> components using the prop <code class="Code-In-Text--PACKT-">staticContext</code>. For this reason, if we rebuild the frontend bundle and <a id="_idIndexMarker974"/>relaunch our server, this time, we will see a correct <code class="Code-In-Text--PACKT-">404</code> status for <code class="Code-In-Text--PACKT-">http://localhost:3000/blah</code>, but it won't work for URLs that match the author page such as <code class="Code-In-Text--PACKT-">http://localhost:3000/author/blah</code>. </p>
    <p class="normal">In order to make this work, we also need to propagate <code class="Code-In-Text--PACKT-">staticContext</code> from the <code class="Code-In-Text--PACKT-">Author</code> component into the <code class="Code-In-Text--PACKT-">FourOhFour</code> component. To do this, in the <code class="Code-In-Text--PACKT-">Author</code> component's <code class="Code-In-Text--PACKT-">render()</code> method, we have to apply the following change:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (!author) {
  <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${FourOhFour}</span>
<span class="hljs-tag">    </span><strong class="hljs-attr-slc">staticContext</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">props</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">staticContext}</strong>
<span class="hljs-tag">    </span><span class="hljs-attr">error</span><span class="hljs-tag">=</span><span class="hljs-string">"Author not found"</span>
<span class="hljs-tag">  /&gt;</span>`
}
<span class="hljs-comment">// ...</span>
</code></pre>
    <p class="normal">Now, the <code class="Code-In-Text--PACKT-">404</code> status code will be returned correctly from the server, even on author pages for non-existent authors.</p>
    <p class="normal">Great—we now have a fully functional React application that uses server-side rendering! But don't celebrate just yet, we still have some work to do...</p>
    <h2 id="_idParaDest-287" class="title">Asynchronous data retrieval</h2>
    <p class="normal">Now, imagine for a <a id="_idIndexMarker975"/>second that we are asked to build the website for the Library of Trinity College in Dublin, one of the most famous libraries in the world. It has about 300 years of history and about 7 million books. Ok, now let's imagine we have to allow the users to browse this massive collection of books. Yes, all 7 million of them... a simple data file is not going to be a great idea here!</p>
    <p class="normal">A better approach would be to have a dedicated API to retrieve the data about the books and use it to dynamically fetch only the minimum amount of data needed to render a given page. More data will be fetched as the user navigates through the various pages of the website.</p>
    <p class="normal">This approach is valid for most web applications, so let's try to apply the same principle to our demo application. We will be using an API with two endpoints:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">/api/authors</code>, to get the list of authors</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">/api/author/:authorId</code>, to get the information for a given author</li>
    </ul>
    <p class="normal">For the sake of this demo application, we will keep things very simple. We only want to demonstrate how our application is going to change as soon as we introduce asynchronous data fetching, so we are not going to bother with using a real database to back our API or with introducing more advanced features like pagination, filtering, or search.</p>
    <p class="normal">Since building such an API<a id="_idIndexMarker976"/> server leveraging our existing data file is a rather trivial exercise (one that doesn't add much value in the context of this chapter), we are going to skip the walkthrough of the API implementation. You can get the source code of the API server from the code repository of this book (<a href="http://nodejsdp.link/authors-api-server"><span class="url">nodejsdp.link/authors-api-server</span></a>).</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">This simple API server runs independently from our backend server, so it uses<a id="_idIndexMarker977"/> another port (or potentially even on another domain). In order to allow the browser to make asynchronous HTTP requests to a different port or domain, we need our API server to support <strong class="keyword">cross-origin resource sharing</strong> or <strong class="keyword">CORS</strong> (<a href="http://nodejsdp.link/cors"><span class="url">nodejsdp.link/cors</span></a>), a mechanism that allows <a id="_idIndexMarker978"/>secure cross-origin requests. Thankfully, enabling CORS with Fastify is as easy as installing the <code class="Code-In-Text--PACKT-">fastify-cors</code> (<a href="http://nodejsdp.link/fastify-cors"><span class="url">nodejsdp.link/fastify-cors</span></a>) plugin.</p>
    </div>
    <p class="normal">We are also going to need an HTTP client that works seamlessly on both the browser and Node.js. A <a id="_idIndexMarker979"/>good option is <code class="Code-In-Text--PACKT-">superagent</code> (<a href="http://nodejsdp.link/superagent"><span class="url">nodejsdp.link/superagent</span></a>).</p>
    <p class="normal">Let's install the new dependencies then:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install --save fastify-cors superagent
</code></pre>
    <p class="normal">Now we are ready to run our API server:</p>
    <pre class="programlisting con"><code class="hljs-con">node -r esm src/api.js
</code></pre>
    <p class="normal">And let's try some requests with <code class="Code-In-Text--PACKT-">curl</code>, for instance:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -i http://localhost:3001/api/authors
curl -i http://localhost:3001/api/author/joyce
curl -i http://localhost:3001/api/author/invalid
</code></pre>
    <p class="normal">If everything worked as expected, we<a id="_idIndexMarker980"/> are now ready to update our React components to use these new API endpoints rather than reading directly from the <code class="Code-In-Text--PACKT-">authors</code> dataset. Let's start by updating the <code class="Code-In-Text--PACKT-">AuthorsIndex</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> superagent </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'superagent'</strong>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AuthorsIndex</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  <strong class="hljs-keyword-slc">constructor</strong><strong class="hljs-slc"> (props) {</strong>
    <strong class="hljs-built_in-slc">super</strong><strong class="hljs-slc">(props)</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.state = {</strong>
      <strong class="hljs-attr-slc">authors</strong><strong class="hljs-slc">: [],</strong>
      <strong class="hljs-attr-slc">loading</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">true</strong>
    <strong class="hljs-slc">}</strong>
  <strong class="hljs-slc">}</strong>
  <strong class="hljs-keyword-slc">async</strong><strong class="hljs-slc"> componentDidMount () {</strong>
    <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> { body } = </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> superagent.get(</strong><strong class="hljs-string-slc">'http://localhost:3001/api/authors'</strong><strong class="hljs-slc">)</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.setState({ </strong><strong class="hljs-attr-slc">loading</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">false</strong><strong class="hljs-slc">, </strong><strong class="hljs-attr-slc">authors</strong><strong class="hljs-slc">: body })</strong>
  <strong class="hljs-slc">}</strong>
  render () {
    <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (</strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.state.loading) {</strong>
      <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> html`</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-subst-slc">${Header}</strong><strong class="hljs-tag-slc">/&gt;&lt;</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Loading ...</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">`</strong>
    <strong class="hljs-slc">}</strong>
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Header}</span><span class="hljs-tag">/&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">state</strong><strong class="hljs-slc">.</strong><span class="hljs-subst">authors</span>.map((author) =&gt;
        html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">id}</span><span class="hljs-tag">&gt;</span>
          <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Link}</span><span class="hljs-tag"> </span><span class="hljs-attr">to</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-subst">${</span><span class="hljs-string">`/author/</span><span class="hljs-subst">${</span>author.<span class="hljs-subst">id}</span><span class="hljs-string">`</span><span class="hljs-subst">}</span><span class="hljs-string">"</span><span class="hljs-tag">&gt;</span>
              <span class="hljs-subst">${</span>author.<span class="hljs-subst">name}</span>
            <span class="hljs-tag">&lt;/&gt;</span>
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`)<span class="hljs-subst">}</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">The main changes from the previous version are highlighted in bold. Essentially, we converted our React component into a stateful component. At construction time, we initialized the state to an empty array of authors and we set the <code class="Code-In-Text--PACKT-">loading</code> flag to <code class="Code-In-Text--PACKT-">true</code>. Then, we used the <code class="Code-In-Text--PACKT-">componentDidMount</code> lifecycle method to load the authors data using the new API endpoint. Finally, we <a id="_idIndexMarker981"/>updated the <code class="Code-In-Text--PACKT-">render()</code> method to display a loading message while the data was being loaded asynchronously.</p>
    <p class="normal">Now, we have to update our <code class="Code-In-Text--PACKT-">Author</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> superagent </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'superagent'</strong>
<span class="hljs-keyword">import</span> { FourOhFour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./FourOhFour.js'</span>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Author</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  <strong class="hljs-keyword-slc">constructor</strong><strong class="hljs-slc"> (props) {</strong>
    <strong class="hljs-built_in-slc">super</strong><strong class="hljs-slc">(props)</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.state = {</strong>
      <strong class="hljs-attr-slc">author</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc">,</strong>
      <strong class="hljs-attr-slc">loading</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">true</strong>
    <strong class="hljs-slc">}</strong>
  <strong class="hljs-slc">}</strong>
  <strong class="hljs-keyword-slc">async</strong><strong class="hljs-slc"> loadData () {</strong>
    <strong class="hljs-keyword-slc">let</strong><strong class="hljs-slc"> author = </strong><strong class="hljs-literal-slc">null</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.setState({ </strong><strong class="hljs-attr-slc">loading</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">false</strong><strong class="hljs-slc">, author })</strong>
    <strong class="hljs-keyword-slc">try</strong><strong class="hljs-slc"> {</strong>
      <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> { body } = </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> superagent.get(</strong>
        <strong class="hljs-string-slc">`http://localhost:3001/api/author/</strong><strong class="hljs-subst-slc">${</strong>
<span class="hljs-subst">          </span><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">props</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">match</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">params</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">authorId</strong>
<span class="hljs-subst">        </span><strong class="hljs-subst-slc">}</strong><strong class="hljs-string-slc">`</strong><strong class="hljs-slc">)</strong>
      <strong class="hljs-slc">author = body</strong>
    <strong class="hljs-slc">} </strong><strong class="hljs-keyword-slc">catch</strong><strong class="hljs-slc"> (e) {}</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.setState({ </strong><strong class="hljs-attr-slc">loading</strong><strong class="hljs-slc">: </strong><strong class="hljs-literal-slc">false</strong><strong class="hljs-slc">, author })</strong>
  <strong class="hljs-slc">}</strong>
  <strong class="hljs-slc">componentDidMount () {</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.loadData()</strong>
  <strong class="hljs-slc">}</strong>
  <strong class="hljs-slc">componentDidUpdate (prevProps) {</strong>
    <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (prevProps.match.params.authorId !==</strong>
      <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.props.match.params.authorId) {</strong>
      <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.loadData()</strong>
    <strong class="hljs-slc">}</strong>
  <strong class="hljs-slc">}</strong>
  render () {
    <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (</strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.state.loading) {</strong>
      <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> html`</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-subst-slc">${Header}</strong><strong class="hljs-tag-slc">/&gt;&lt;</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Loading ...</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">div</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">`</strong>
    <strong class="hljs-slc">}</strong>
    <span class="hljs-keyword">if</span> (!<strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.state.</strong>author) {
      <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${FourOhFour}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">staticContext</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">props</span>.<span class="hljs-subst">staticContext}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">error</span><span class="hljs-tag">=</span><span class="hljs-string">"Author not found"</span>
<span class="hljs-tag">      /&gt;</span>`
    }
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${Header}</span><span class="hljs-tag">/&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">state</strong><strong class="hljs-slc">.</strong><span class="hljs-subst">author</span>.<span class="hljs-subst">name}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span><span class="hljs-subst">${</span><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">state</strong><strong class="hljs-slc">.</strong><span class="hljs-subst">author</span>.<span class="hljs-subst">bio}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>Books<span class="hljs-tag">&lt;/</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-subst">${</span><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">state</strong><strong class="hljs-slc">.</strong><span class="hljs-subst">author</span>.<span class="hljs-subst">books</span>.map((book) =&gt;
          html`<span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-subst">${</span>book.<span class="hljs-subst">id}</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-subst">${</span>book.<span class="hljs-subst">title}</span> (<span class="hljs-subst">${</span>book.<span class="hljs-subst">year}</span>)
          <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>`
        )<span class="hljs-subst">}</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>`
  }
}
</code></pre>
    <p class="normal">The changes here are quite similar to the ones we applied to the previous component. In this component, we also generalized the data loading operation into the <code class="Code-In-Text--PACKT-">loadData()</code> method. We did this because this component implements not just the <code class="Code-In-Text--PACKT-">componentDidMount()</code> but also the <code class="Code-In-Text--PACKT-">componentDidUpdate()</code> lifecycle method. This is necessary because if we end up passing<a id="_idIndexMarker982"/> new props to the same component instance, we want the component to update correctly. This will happen, for instance, if we have a link in the author page that points to another author page, something that could happen if we implement a "related authors" feature in our application.</p>
    <p class="normal">At this point, we are ready to try this new version of the code. Let's regenerate the frontend bundle with <code class="Code-In-Text--PACKT-">npm run build</code> and start both our backend server and our API server, then point our browser to <code class="Code-In-Text--PACKT-">http://localhost:3000/</code>.</p>
    <p class="normal">If you navigate around the various pages, everything should work as expected. You might also notice that page content gets loaded interactively as you navigate through the pages.</p>
    <p class="normal">But what happens to our server-side rendering? If we try to use <code class="Code-In-Text--PACKT-">curl</code> on our home page, we should see the following HTML markup being returned:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;My library&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;div&gt;&lt;header&gt;&lt;h1&gt;&lt;a href="/"&gt;My library&lt;/a&gt;&lt;/h1&gt;&lt;/header&gt;<strong class="hljs-con-slc">&lt;div&gt;Loading ...&lt;/div&gt;</strong>&lt;/div&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="/public/main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
    <p class="normal">Did you notice that there's no content anymore, but just a quite useless "Loading …" indicator? This is not good. Also, this is not the only problem here. If you try to use <code class="Code-In-Text--PACKT-">curl</code> on an invalid author page, you will notice that you will get the same HTML markup with the loading indicator and no content and that the returned status code is <code class="Code-In-Text--PACKT-">200</code> rather than <code class="Code-In-Text--PACKT-">404</code>!</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We don't see any real content on the server-side rendered markup because the <code class="Code-In-Text--PACKT-">componentDidMount</code> lifecycle method is executed only on the browser while it's ignored by React during server-side rendering.</p>
    </div>
    <p class="normal">Furthermore, server-side rendering is a<a id="_idIndexMarker983"/> synchronous operation, so even if we move our loading code somewhere else, we still won't be able to perform any asynchronous data loading while rendering on the server.</p>
    <p class="normal">In the next section of this chapter, we will explore a pattern that can help us to achieve full universal rendering and data loading.</p>
    <h2 id="_idParaDest-288" class="title">Universal data retrieval</h2>
    <p class="normal">Server-side rendering is a <a id="_idIndexMarker984"/>synchronous operation and this makes it tricky to preload all the necessary data effectively. Being able to avoid the problems we underlined at the end of the previous section is not as straightforward as you might expect.</p>
    <p class="normal">The root of the problem is that we are keeping our routing logic within the React application, so, on the server, we cannot know which page we are actually going to render before we call <code class="Code-In-Text--PACKT-">renderToString()</code>. This is why the server cannot establish whether we need to preload some data for a particular page.</p>
    <p class="normal">Universal data retrieval is still quite a nebulous area in React, and different frameworks or libraries that facilitate React server-side rendering have come up with different solutions to this problem.</p>
    <p class="normal">As of today, the two patterns that we believe are worth discussing are <strong class="keyword">two-pass rendering</strong> and <strong class="keyword">async pages</strong>. These two techniques have different ways of figuring out which data needs to be preloaded. In both cases, once the data is fully loaded on the server, the generated HTML page will provide an inline <code class="Code-In-Text--PACKT-">script</code> block to inject all the data into the global scope (the <code class="Code-In-Text--PACKT-">window</code> object) so that when the application runs on the browser, the same data already loaded on the server won't have to be reloaded from the client.</p>
    <h3 id="_idParaDest-289" class="title">Two-pass rendering</h3>
    <p class="normal">The idea of two-pass rendering<a id="_idIndexMarker985"/> is to use the React router static context as a vector to exchange information between React and the server. <em class="italic">Figure 10.4</em> shows us how this works:</p>
    <p class="normal"><img src="../Images/B15729_10_04.png" alt="../../../Downloads/Untitled%20Diagram%20(15).png"/></p>
    <p class="packt_figref">Figure 10.4: Two-pass rendering schematic</p>
    <p class="normal">The steps of two-pass rendering are as follows:</p>
    <ol>
      <li class="numbered">The server calls <code class="Code-In-Text--PACKT-">renderToString()</code>, passing the URL received from the client and an empty static context object to the React application.</li>
      <li class="numbered">The React application will <a id="_idIndexMarker986"/>perform the routing process and select the components that need to be rendered for the given URL. Every component that requires to load some data asynchronously will need to implement some extra logic to allow such data to be preloaded on the server as well. This can be done by attaching a promise representing the result of the data loading operation to the router static context. This way, at the end of the rendering process, the server will receive an incomplete markup (representing the current loading state) and the static context will contain a number of promises representing data loading operations.</li>
      <li class="numbered">At this point, the server can look at the static context and wait for all the promises to settle to make sure that all the data has been preloaded completely. During this process, the server builds a new static context that contains the results returned by the promises. This new static context is used for a second round of rendering. This is why this technique is called two-pass rendering.</li>
      <li class="numbered">Now, the ball is again on the React side of the field. The routing process should pick the same components used during the first rendering pass, since the URL has not changed. This time, the components that need data preloading should see that such data is already available in the static context and they can render the view straight away. This step produces a complete static markup that the server can now use.</li>
      <li class="numbered">At this point, the server has the complete markup and it uses it to render the final HTML page. The server can also include all the preloaded data in a <code class="Code-In-Text--PACKT-">script</code> tag so that, on the browser, the data will be already available so there won't be any need to load it again while visiting the first page of the application.</li>
    </ol>
    <p class="normal">This technique is very powerful and has some interesting advantages. For instance, it allows you to organize your React components tree in a very flexible way. You can have multiple components requesting asynchronous data, and they can be placed at any level of the components tree.</p>
    <p class="normal">In more advanced use cases, you can also have data being loaded over multiple rendering passes. For instance, during the second pass, a new component in the tree might be rendered and this component might also need to load data asynchronously so it can just add new promises to the static context. To support this particular case, the server will have to continue the rendering loop until there are no more promises left in the static context. This particular variation of the<a id="_idIndexMarker987"/> two-pass rendering technique is referred to as <strong class="keyword">multi-pass rendering</strong>.</p>
    <p class="normal">The biggest disadvantage of<a id="_idIndexMarker988"/> this technique is that every call to <code class="Code-In-Text--PACKT-">renderToString()</code> is not cheap and in real-life applications, this technique might force the server to go through multiple rendering passes, making the whole process very slow. </p>
    <p class="normal">This might lead to severe performance degradation on the entire application, which can dramatically affect the user experience.</p>
    <p class="normal">A simpler but potentially more performant alternative will be discussed in the next section.</p>
    <h3 id="_idParaDest-290" class="title">Async pages</h3>
    <p class="normal">The technique we are <a id="_idIndexMarker989"/>going to describe here, which we are going to call "async pages," is based on a more constrained structure of the React application.</p>
    <p class="normal">The idea is to structure the top layers of the application components tree in a very specific way. Let's have a look at a possible structure first, then it will be easier to discuss how this specific approach can help us with asynchronous data loading.</p>
    <figure class="mediaobject"><img src="../Images/B15729_10_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 10.5: Async pages components tree structure</p>
    <p class="normal">In <em class="italic">Figure 10.5</em>, we have represented the structure that allows us to apply the async pages technique. Let's discuss in detail the scope of every layer in the components tree:</p>
    <ol>
      <li class="numbered">The root of the application is always a <code class="Code-In-Text--PACKT-">Router</code> component (<code class="Code-In-Text--PACKT-">StaticRouter</code> on the server and <code class="Code-In-Text--PACKT-">BrowserRouter</code> on the client).</li>
      <li class="numbered">The application component is the only child of the <code class="Code-In-Text--PACKT-">Router</code> component.</li>
      <li class="numbered">The only child of the application <a id="_idIndexMarker990"/>component is a <code class="Code-In-Text--PACKT-">Switch</code> component from the <code class="Code-In-Text--PACKT-">react-router-dom</code> package.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">Switch</code> component has one or more <code class="Code-In-Text--PACKT-">Route</code> components as children. These are used to define all the possible routes and which component should be rendered for every route.</li>
      <li class="numbered">This is the most interesting layer as we actually introduce the concept of a "page component." The idea is that a page component is responsible for the look and feel of an entire page. A page component can have an arbitrary subtree of components used to render the current view; for instance, a header, a body, and a footer. We can have two types of page components: regular page components that behave as any other React components and <code class="Code-In-Text--PACKT-">AsyncPage</code> components. Async pages are special <em class="italic">stateful</em> components that need to preload data for the page to be rendered both on the server- and the client side. They implement a special static method called <code class="Code-In-Text--PACKT-">preloadAsyncData()</code> that contains the logic necessary to preload the data for the given page.</li>
    </ol>
    <p class="normal">You can see that layers 1 to 4 are responsible for the routing logic, while level 5 is responsible for data loading and for actually rendering the current page. There are no other nested layers for additional routing and data loading.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Technically, there could be additional layers for routing and data loading after level 5, but those won't be universally available as they will be resolved only on the client side after the page has been rendered.</p>
    </div>
    <p class="normal">Now that we've discussed this more rigid structure, let's see how it can be useful to avoid multiple rendering passes and achieve universal data retrieval.</p>
    <p class="normal">Here's the idea: if we have our routes defined in a dedicated file as an array of paths and components, we can easily reuse this file on the server side and determine, before the React rendering phase, which page component we will actually end up rendering.</p>
    <p class="normal">Then, we can see if this page component <a id="_idIndexMarker991"/>is an <code class="Code-In-Text--PACKT-">AsyncPage</code>. If it is, it means we have to preload some data on the server side before the rendering. We can do this by calling the <code class="Code-In-Text--PACKT-">preloadAsyncData()</code> method from the given component.</p>
    <p class="normal">Once the data has been preloaded, this can be added in the static context and we can render the entire application. During the rendering phase, the <code class="Code-In-Text--PACKT-">AsyncPage</code> component will see that its data is already preloaded and available in the static context and it will be able to render straight away, skipping the loading state.</p>
    <p class="normal">Once the rendering is finished, the server can add the same preloaded data in a <code class="Code-In-Text--PACKT-">script</code> tag so that, on the browser side, the user won't have to wait for the data to be loaded again.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The Next.js framework (<a href="http://nodejsdp.link/nextjs"><span class="url">nodejsdp.link/nextjs</span></a>) is a popular framework for Universal JavaScript <a id="_idIndexMarker992"/>applications and adopts a similar technique to the one described here, so it is a good example of this pattern in the wild.</p>
    </div>
    <h3 id="_idParaDest-291" class="title">Implementing async pages</h3>
    <p class="normal">Now that we know<a id="_idIndexMarker993"/> how to solve our data fetching problems, let's implement the async pages technique in our application.</p>
    <p class="normal">Our components tree is already structured in a way that it's compliant to what's expected by this technique. Our pages are the <code class="Code-In-Text--PACKT-">AuthorsIndex</code> component, the <code class="Code-In-Text--PACKT-">Author</code> component, and the <code class="Code-In-Text--PACKT-">FourOhFour</code> component. The first two require universal data loading, so we will have to convert them into async pages.</p>
    <p class="normal">Let's start to update our application by extrapolating the route definitions into a dedicated file, <code class="Code-In-Text--PACKT-">src/frontend/routes.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { AuthorsIndex } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/AuthorsIndex.js'</span>
<span class="hljs-keyword">import</span> { Author } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/Author.js'</span>
<span class="hljs-keyword">import</span> { FourOhFour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/pages/FourOhFour.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
    <span class="hljs-attr">exact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">component</span>: AuthorsIndex
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/author/:authorId'</span>,
    <span class="hljs-attr">component</span>: Author
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'*'</span>,
    <span class="hljs-attr">component</span>: FourOhFour
  }
]
</code></pre>
    <p class="normal">We want this configuration file to be the source of truth for the router configuration across the various parts of the application, so let's refactor the frontend <code class="Code-In-Text--PACKT-">App</code> component to use this file as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// src/frontend/App.js</span>
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Switch, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> { routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'./routes.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">App</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  render () {
    <span class="hljs-keyword">return</span> html`<span class="hljs-tag">&lt;</span><span class="hljs-subst">${Switch}</span><span class="hljs-tag">&gt;</span>
      <strong class="hljs-subst-slc">${routes</strong><strong class="hljs-slc">.map(routeConfig =&gt;</strong>
        <strong class="hljs-slc">html`</strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-subst-slc">${Route}</strong>
<span class="hljs-tag">          </span><strong class="hljs-attr-slc">key</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-slc">routeConfig.</strong><strong class="hljs-subst-slc">path}</strong>
<span class="hljs-tag">          </span><strong class="hljs-attr-slc">...</strong><strong class="hljs-subst-slc">${routeConfig}</strong>
<span class="hljs-tag">        </span><strong class="hljs-tag-slc">/&gt;</strong><strong class="hljs-slc">`</strong>
      <strong class="hljs-slc">)</strong><strong class="hljs-subst-slc">}</strong>
    <span class="hljs-tag">&lt;/&gt;</span>`
  }
}
</code></pre>
    <p class="normal">As you can see, the only change here is that, rather than defining the various <code class="Code-In-Text--PACKT-">Route</code> components inline, we build them dynamically starting from the <code class="Code-In-Text--PACKT-">routes</code> configuration array. Any change in the <code class="Code-In-Text--PACKT-">routes.js</code> file will be automatically reflected in the application as well.</p>
    <p class="normal">At this point, we can update the server-side logic in <code class="Code-In-Text--PACKT-">src/server.js</code>.</p>
    <p class="normal">The first thing that we want to do is import a utility function from the <code class="Code-In-Text--PACKT-">react-router-dom</code> package that allows us to see if a given URL matches a given React router path definition. We also need to import the <code class="Code-In-Text--PACKT-">routes</code> array from the new <code class="Code-In-Text--PACKT-">routes.js</code> module.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">import</span> { StaticRouter<strong class="hljs-slc">, matchPath</strong> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { routes } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'./frontend/routes.js'</strong>
<span class="hljs-comment">// ...</span>
</code></pre>
    <p class="normal">Now, let's update our server-side HTML template generation function to be able to embed preloaded data in our page:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> template = <span class="hljs-function">(</span><span class="hljs-params">{ content</span><strong class="hljs-params-slc">, serverData</strong><span class="hljs-params"> }</span><span class="hljs-function">) =&gt;</span> <span class="hljs-string">`&lt;!DOCTYPE html&gt;</span>
<span class="hljs-string">&lt;html&gt;</span>
<span class="hljs-string">  &lt;head&gt;</span>
<span class="hljs-string">    &lt;meta charset="UTF-8"&gt;</span>
<span class="hljs-string">    &lt;title&gt;My library&lt;/title&gt;</span>
<span class="hljs-string">  &lt;/head&gt;</span>
<span class="hljs-string">  &lt;body&gt;</span>
<span class="hljs-string">    &lt;div id="root"&gt;</span><span class="hljs-subst">${content}</span><span class="hljs-string">&lt;/div&gt;</span>
<span class="hljs-string">    </span><strong class="hljs-subst-slc">${serverData ? </strong><strong class="hljs-string-slc">`&lt;script type="text/javascript"&gt;</strong>
<strong class="hljs-string-slc">window.__STATIC_CONTEXT__=</strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-built_in-slc">JSON</strong><strong class="hljs-slc">.stringify(</strong><strong class="hljs-subst-slc">serverData</strong><strong class="hljs-slc">)</strong><strong class="hljs-subst-slc">}</strong>
<span class="hljs-string">    </span><strong class="hljs-string-slc">&lt;/script&gt;`</strong><strong class="hljs-subst-slc"> : </strong><strong class="hljs-string-slc">''</strong><strong class="hljs-subst-slc">}</strong>
<span class="hljs-string">    &lt;script type="text/javascript" src="/public/main.js"&gt;&lt;/script&gt;</span>
<span class="hljs-string">  &lt;/body&gt;</span>
<span class="hljs-string">&lt;/html&gt;`</span>
<span class="hljs-comment">// ...</span>
</code></pre>
    <p class="normal">As you can see, our template now accepts a new argument called <code class="Code-In-Text--PACKT-">serverData</code>. If this argument is passed to the <code class="Code-In-Text--PACKT-">template</code> function, it will render a <code class="Code-In-Text--PACKT-">script</code> tag that will inject this data into a global variable called <code class="Code-In-Text--PACKT-">window.__STATIC_CONTEXT__</code>.</p>
    <p class="normal">Now, let's get into the meaty bit; let's<a id="_idIndexMarker994"/> rewrite the server-side rendering logic:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// ...</span>
server.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> (req, reply) =&gt; {
  <span class="hljs-keyword">const</span> location = req.raw.originalUrl
  <span class="hljs-keyword">let</span> component                                            <span class="hljs-comment">// (1)</span>
  <span class="hljs-keyword">let</span> match
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> route <span class="hljs-keyword">of</span> routes) {
    component = route.component
    match = matchPath(location, route)
    <span class="hljs-keyword">if</span> (match) {
      <span class="hljs-keyword">break</span>
    }
  }
  <span class="hljs-keyword">let</span> staticData                                           <span class="hljs-comment">// (2)</span>
  <span class="hljs-keyword">let</span> staticError
  <span class="hljs-keyword">let</span> hasStaticContext = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> component.preloadAsyncData === <span class="hljs-string">'function'</span>) {
    hasStaticContext = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> component.preloadAsyncData({ match })
      staticData = data
    } <span class="hljs-keyword">catch</span> (err) {
      staticError = err
    }
  }
  <span class="hljs-keyword">const</span> staticContext = {
    [location]: {
      <span class="hljs-attr">data</span>: staticData,
      <span class="hljs-attr">err</span>: staticError
    }
  }
                                                           <span class="hljs-comment">// (3)</span>
  <span class="hljs-keyword">const</span> serverApp = html`
    <span class="hljs-tag">&lt;</span><span class="hljs-subst">${StaticRouter}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">location</span><span class="hljs-tag">=</span><span class="hljs-subst">${location}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">context</span><span class="hljs-tag">=</span><span class="hljs-subst">${staticContext}</span>
<span class="hljs-tag">    &gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-subst">${App}</span><span class="hljs-tag">/&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  `
  <span class="hljs-keyword">const</span> content = reactServer.renderToString(serverApp)
  <span class="hljs-keyword">const</span> serverData = hasStaticContext ? staticContext : <span class="hljs-literal">null</span>
  <span class="hljs-keyword">const</span> responseHtml = template({ content, serverData })
  <span class="hljs-keyword">const</span> code = staticContext.statusCode
    ? staticContext.statusCode
    : <span class="hljs-number">200</span>
  reply.code(code).type(<span class="hljs-string">'text/html'</span>).send(responseHtml)
<span class="hljs-comment">// ...</span>
</code></pre>
    <p class="normal">There are quite some changes here. Let's <a id="_idIndexMarker995"/>discuss the main blocks one by one:</p>
    <ol>
      <li class="numbered">The first change aims to detect which page will be rendered for the current URL. We loop through the defined <code class="Code-In-Text--PACKT-">routes</code> and we use the <code class="Code-In-Text--PACKT-">matchPath</code> utility to verify if <code class="Code-In-Text--PACKT-">location</code> matches the current <code class="Code-In-Text--PACKT-">route</code> definition. If it does, we stop the loop and record which component will be rendered in the <code class="Code-In-Text--PACKT-">component</code> variable. We can be sure a component will be matched here because our last route (the <code class="Code-In-Text--PACKT-">404</code> page) will always match. The <code class="Code-In-Text--PACKT-">match</code> variable will contain information about the match. For instance, if the route contains some parameters, <code class="Code-In-Text--PACKT-">match</code> will contain the path fragment that matched every parameter. For instance, for the URL <code class="Code-In-Text--PACKT-">/author/joyce</code>, <code class="Code-In-Text--PACKT-">match</code> will have the property <code class="Code-In-Text--PACKT-">params</code> equal to <code class="Code-In-Text--PACKT-">{ authorId: 'joyce' }</code>. This is the same prop that a page component will receive from the router when rendered.</li>
      <li class="numbered">In the second block of changes, we check if the selected component is an <code class="Code-In-Text--PACKT-">AsyncPage</code>. We do that by checking if the component has a static method called <code class="Code-In-Text--PACKT-">preloadAsyncData</code>. If that's the case, we invoke that function by passing an object that contains the <code class="Code-In-Text--PACKT-">match</code> object as an argument (this way, we propagate any parameter that might be needed to fetch the data, such as <code class="Code-In-Text--PACKT-">authorId</code>). This function should return a promise. If the promise resolves, we have successfully preloaded the data for this component. If it rejects, we make sure to record the error. Finally, we create the <code class="Code-In-Text--PACKT-">staticContext</code> object. This object maps the preloaded data (or the rejection error) to the current location. The reason why we keep the location as a key is to be sure that if, for any reason, the browser renders another page from the one we preloaded (because of a programmatic error or because of a user action, like hitting the back button on the browser before the page is fully loaded), we won't end up using preloaded data that is not relevant to the current page on the browser.</li>
      <li class="numbered">In the last block of changes, we invoke the <code class="Code-In-Text--PACKT-">renderToString()</code> function to get the rendered HTML of the application. Note that since we are passing a static context containing the preloaded <a id="_idIndexMarker996"/>data, we expect that the application will be able to completely render the page without returning a loading state view. This does not happen magically, of course. We will need to add some logic to our React component to check if the necessary data is already available in the static context. Once we have the generated HTML, we use our <code class="Code-In-Text--PACKT-">template()</code> function to generate the complete page markup and we return it to the browser. We also make sure to respect the status code. For instance, if we ended up rendering the <code class="Code-In-Text--PACKT-">FourOhFour</code> component, we will have the <code class="Code-In-Text--PACKT-">statusCode</code> property in the static context changed, so if that's the case, we use that value for the final status code; otherwise, we default to <code class="Code-In-Text--PACKT-">200</code>.</li>
    </ol>
    <p class="normal">That's it for our server-side rendering.</p>
    <p class="normal">Now, it's time to create the async page abstraction in our React application. Since we are going to have two distinct async pages, a good way to reuse some code is to create a base class and to use the Template pattern that we already discussed in <em class="chapterRef">Chapter 9</em>, <em class="italic">Behavioral Design Patterns</em>. Let's define this class in <code class="Code-In-Text--PACKT-">src/frontend/components/pages/AsyncPage.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AsyncPage</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><span class="hljs-title">react</span><span class="hljs-class">.</span><span class="hljs-title">Component</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> preloadAsyncData (props) {                   <span class="hljs-comment">// (1)</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Must be implemented by sub class'</span>)
  }
  render () {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Must be implemented by sub class'</span>)
  }
  <span class="hljs-keyword">constructor</span> (props) {                                     <span class="hljs-comment">// (2)</span>
    <span class="hljs-built_in">super</span>(props)
    <span class="hljs-keyword">const</span> location = props.match.url
    <span class="hljs-built_in">this</span>.hasData = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> staticData
    <span class="hljs-keyword">let</span> staticError
    <span class="hljs-keyword">const</span> staticContext = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span>
      ? <span class="hljs-built_in">window</span>.__STATIC_CONTEXT__ <span class="hljs-comment">// client-side</span>
      : <span class="hljs-built_in">this</span>.props.staticContext  <span class="hljs-comment">// server-side</span>
    <span class="hljs-keyword">if</span> (staticContext &amp;&amp; staticContext[location]) {
      <span class="hljs-keyword">const</span> { data, err } = staticContext[location]
      staticData = data
      staticError = err
      <span class="hljs-built_in">this</span>.hasStaticData = <span class="hljs-literal">true</span>
      <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp;
        <span class="hljs-keyword">delete</span> staticContext[location]
    }
    <span class="hljs-built_in">this</span>.state = {
      ...staticData,
      staticError,
      <span class="hljs-attr">loading</span>: !<span class="hljs-built_in">this</span>.hasStaticData
    }
  }
  <span class="hljs-keyword">async</span> componentDidMount () {                              <span class="hljs-comment">// (3)</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hasStaticData) {
      <span class="hljs-keyword">let</span> staticData
      <span class="hljs-keyword">let</span> staticError
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.constructor.preloadAsyncData(
          <span class="hljs-built_in">this</span>.props
        )
        staticData = data
      } <span class="hljs-keyword">catch</span> (err) {
        staticError = err
      }
      <span class="hljs-built_in">this</span>.setState({
        ...staticData,
        <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span>,
        staticError
      })
    }
  }
}
</code></pre>
    <p class="normal">This class provides helper code for building a stateful component that can handle three possible scenarios:</p>
    <ul>
      <li class="Bullet--PACKT-">We are rendering on the server and <a id="_idIndexMarker997"/>we already have the data preloaded (no need to load the data).</li>
      <li class="Bullet--PACKT-">We are rendering on the client and the data is already available in the page through the <code class="Code-In-Text--PACKT-">__STATIC_CONTEXT__</code> variable (no need to load the data).</li>
      <li class="Bullet-End--PACKT-">We are rendering on the client and the data is not available (for instance, if this page was not rendered by the server, but a page the user navigated to after the first load). In this case, the data has to be dynamically loaded from the client when the component is mounted.</li>
    </ul>
    <p class="normal">Let's review the main points of this implementation together:</p>
    <ol>
      <li class="numbered">This component class should not be instantiated directly but only extended when implementing async pages. When this class is extended, the async page component will need to implement the methods <code class="Code-In-Text--PACKT-">static async preloadAsyncData(props)</code> and <code class="Code-In-Text--PACKT-">render()</code>.</li>
      <li class="numbered">In the constructor, we have to initialize the component state. There are two possible outcomes here: the data is already available (so we can set it in the state) or the data is not available (so we need to set the state to "loading" and let the component load the data once it's mounted on the page). If we are on the browser and we load the data from the static context, we also make sure to delete this data from the context. This will allow the user to see fresh data if they happen to go back to this page during the navigation.</li>
      <li class="numbered">The method <code class="Code-In-Text--PACKT-">componentDidMount()</code> is executed by React only on the browser. Here, we handle the case where the data was not preloaded and we have to dynamically load it at runtime.</li>
    </ol>
    <p class="normal">Now that we have this useful <a id="_idIndexMarker998"/>abstraction in place, we can rewrite our <code class="Code-In-Text--PACKT-">AuthorsIndex</code> and <code class="Code-In-Text--PACKT-">Author</code> components and convert them into async pages. Let's start with <code class="Code-In-Text--PACKT-">AuthorsIndex</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>
<span class="hljs-keyword">import</span> superagent <span class="hljs-keyword">from</span> <span class="hljs-string">'superagent'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { AsyncPage } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'./AsyncPage.js'</strong>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AuthorsIndex</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><strong class="hljs-title-slc">AsyncPage</strong><span class="hljs-class"> </span>{
  <strong class="hljs-keyword-slc">static</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">async</strong><strong class="hljs-slc"> preloadAsyncData (props) {</strong>
    <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> { body } = </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> superagent.get(</strong>
      <strong class="hljs-string-slc">'http://localhost:3001/api/authors'</strong>
    <strong class="hljs-slc">)</strong>
    <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> { </strong><strong class="hljs-attr-slc">authors</strong><strong class="hljs-slc">: body }</strong>
  <strong class="hljs-slc">}</strong>
  render () {
    <span class="hljs-comment">// unchanged...</span>
  }
}
</code></pre>
    <p class="normal">As you can see here, our <code class="Code-In-Text--PACKT-">AuthorsIndex</code> component now extends <code class="Code-In-Text--PACKT-">AsyncPage</code>. Since the <code class="Code-In-Text--PACKT-">AsyncPage</code> template will take care of all the state management in its constructor, we don't need a constructor here anymore; we just need to specify the business logic to load the data in the <code class="Code-In-Text--PACKT-">preloadAsyncData()</code> method. </p>
    <p class="normal">If you compare this implementation with the previous one, you might notice that the logic of this method is almost the same as what we had previously in <code class="Code-In-Text--PACKT-">componentDidMount()</code>. The method <code class="Code-In-Text--PACKT-">componentDidMount()</code> has been removed from here because the one we inherit from <code class="Code-In-Text--PACKT-">AsyncPage</code> will suffice. The only difference between the previous version of <code class="Code-In-Text--PACKT-">componentDidMount()</code> and <code class="Code-In-Text--PACKT-">preloadAsyncData()</code> is that in <code class="Code-In-Text--PACKT-">preloadAsyncData()</code>, we don't set the internal state directly; we just need to return the data. The underlying code in <code class="Code-In-Text--PACKT-">AsyncPage</code> will update the state as needed for us.</p>
    <p class="normal">Let's now rewrite <a id="_idIndexMarker999"/>the <code class="Code-In-Text--PACKT-">Author</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> htm <span class="hljs-keyword">from</span> <span class="hljs-string">'htm'</span>
<span class="hljs-keyword">import</span> superagent <span class="hljs-keyword">from</span> <span class="hljs-string">'superagent'</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { AsyncPage } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'./AsyncPage.js'</strong>
<span class="hljs-keyword">import</span> { FourOhFour } <span class="hljs-keyword">from</span> <span class="hljs-string">'./FourOhFour.js'</span>
<span class="hljs-keyword">import</span> { Header } <span class="hljs-keyword">from</span> <span class="hljs-string">'../Header.js'</span>
<span class="hljs-keyword">const</span> html = htm.bind(react.createElement)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Author</span><span class="hljs-class"> </span><span class="hljs-keyword">extends</span><span class="hljs-class"> </span><strong class="hljs-title-slc">AsyncPage</strong><span class="hljs-class"> </span>{
  <strong class="hljs-keyword-slc">static</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">async</strong><strong class="hljs-slc"> preloadAsyncData (props) {</strong>
    <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> { body } = </strong><strong class="hljs-keyword-slc">await</strong><strong class="hljs-slc"> superagent.get(</strong>
      <strong class="hljs-string-slc">`http://localhost:3001/api/author/</strong><strong class="hljs-subst-slc">${</strong>
         <strong class="hljs-slc">props.</strong><strong class="hljs-subst-slc">match</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">params</strong><strong class="hljs-slc">.</strong><strong class="hljs-subst-slc">authorId</strong>
<span class="hljs-subst">      </span><strong class="hljs-subst-slc">}</strong><strong class="hljs-string-slc">`</strong>
    <strong class="hljs-slc">)</strong>
    <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> { </strong><strong class="hljs-attr-slc">author</strong><strong class="hljs-slc">: body }</strong>
  <strong class="hljs-slc">}</strong>
  render () {
    <span class="hljs-comment">// unchanged...</span>
  }
}
</code></pre>
    <p class="normal">The changes here are perfectly in line with the changes we made for the <code class="Code-In-Text--PACKT-">AuthorsIndex</code> component. We are only moving the data loading logic into <code class="Code-In-Text--PACKT-">preloadAsyncData()</code> and letting the underlying abstraction manage the state transition for us.</p>
    <p class="normal">Now, we can apply just a last small optimization in our <code class="Code-In-Text--PACKT-">src/frontend/index.js</code> file. We can swap the <code class="Code-In-Text--PACKT-">reactDOM.render()</code> function call with <code class="Code-In-Text--PACKT-">reactDOM.hydrate()</code>. Since we will produce exactly the same markup from both the server side and the client side, this will make React a bit faster to initialize during the first browser load.</p>
    <p class="normal">We are finally ready to try all these changes. Make sure to rebuild the frontend bundle and relaunch the server. Have a look at the application and the code that is generated by the server; it should contain all the preloaded data for every page. Also, <code class="Code-In-Text--PACKT-">404</code> errors should be reported correctly for every <code class="Code-In-Text--PACKT-">404</code> page, including the ones for missing authors.</p>
    <p class="normal">Great! We finally managed to build an application that efficiently shares code, logic, and data between the client and the server: a true Universal JavaScript application!</p>
    <h1 id="_idParaDest-292" class="title">Summary</h1>
    <p class="normal">In this chapter, we explored the innovative and fast-moving world of Universal JavaScript. Universal JavaScript opens up a lot of new opportunities in the field of web development and it can help you build single-page applications that load fast, are accessible, and are optimized for search engines.</p>
    <p class="normal">In this chapter, we focused on introducing all the basics of this subject. We started from exploring module bundlers, why we need them, and how they work. We learned how to use webpack, and then we introduced React and discussed some of its functionality. We learned how to build component-oriented user interfaces and then started to build an application from scratch to explore universal rendering, universal routing, and universal data retrieval.</p>
    <p class="normal">Even though we discussed a lot of topics, we barely scratched the surface of this wide topic, but you should have gained all the necessary knowledge to keep exploring this world on your own if you are interested in knowing more. Given that this field is still evolving quite rapidly, tools and libraries will probably change a lot in the next few years, but all the basic concepts should stay there, so don't be afraid to keep exploring and experimenting. Becoming an expert on this topic is now just a matter of using the acquired knowledge to build a first real-world app with real, business-driven use cases.</p>
    <p class="normal">It's also worth underlining that the knowledge acquired here might be useful for projects that cross the boundaries of web development, like mobile app development. If you are interested in this topic, React Native might be a good starting point.</p>
    <p class="normal">In the next chapter, we are going to take a problem-solution approach to explore some more advanced topics. Are you ready?</p>
    <h1 id="_idParaDest-293" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">10.1 A matter of style</strong>: Our little library application looks very barebone. It could look a lot better with some style and images. Why don't you try to improve the look of the app? If you get stuck or need some inspiration, you can check our version of this exercise on GitHub (<a href="http://nodejsdp.link/univ"><span class="url">nodejsdp.link/univ</span></a>).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">10.2 Proper data management</strong>: As we said, keeping a lot of data in a file is not a great idea. Why don't you try to move all the data into a real database backend of your choice? At this point, you might also want to take this application to the next level and write some script to import data from a big collection of books like the Open Library archive (<a href="http://nodejsdp.link/open-libary-api"><span class="url">nodejsdp.link/open-libary-api</span></a>).</li>
      <li class="Bullet--PACKT-"><strong class="keyword">10.3 Pagination and search</strong>: Now that you have a more significant database, it's probably time to add some important features like search and pagination.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">10.4 A Universal… Blog!</strong>: Build a new universal JavaScript app from scratch that implements a blog. Then, try the same exercise using a framework like Next.js (<a href="http://nodejsdp.link/nextjs"><span class="url">nodejsdp.link/nextjs</span></a>) or Gatsby (<a href="http://nodejsdp.link/gatsby"><span class="url">nodejsdp.link/gatsby</span></a>).</li>
    </ul>
  </div>
</body></html>