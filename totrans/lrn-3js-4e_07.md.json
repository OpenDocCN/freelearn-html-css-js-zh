["```js\nconst material = new THREE.SpriteMaterial({ size: 0.1,\n  color: 0xff0000 })\nconst sprite = new THREE.Sprite(material)\nsprite.position.copy(new THREE.Vector3(1,1,1))\n```", "```js\nconst createPoints = () => {\n  const points = []\n  for (let x = -15; x < 15; x++) {\n    for (let y = -10; y < 10; y++) {\n      let point = new THREE.Vector3(x / 4, y / 4, 0)\n      points.push(point)\n    }\n  }\n  const colors = new Float32Array(points.length * 3)\n  points.forEach((e, i) => {\n    const c = new THREE.Color(Math.random() * 0xffffff)\n    colors[i * 3] = c.r\n    colors[i * 3 + 1] = c.g\n    colors[i * 3 + 2] = c.b\n  })\n  const geom = new THREE.BufferGeometry().setFromPoints(points)\n  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))\n  return geom\n}\nconst material = new THREE.PointsMaterial({ size: 0.1,\n  vertexColors: true, color: 0xffffff })\nconst points = new THREE.Points(createPoint(), material)\n```", "```js\nconst createGhostTexture = () => {\n  const canvas = document.createElement('canvas')\n  canvas.width = 32\n  canvas.height = 32\n  const ctx = canvas.getContext('2d')\n  // the body\n  ctx.translate(-81, -84)\n  ctx.fillStyle = 'orange'\n  ctx.beginPath()\n  ctx.moveTo(83, 116)\n  ctx.lineTo(83, 102)\n  ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)\n  // some code removed for clarity\n  ctx.fill()\n  // the eyes\n  ctx.fillStyle = 'white'\n  ctx.beginPath()\n  ctx.moveTo(91, 96)\n  ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)\n  ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)\n  // some code removed for clarity\n  ctx.fill()\n  // the pupils\n  ctx.fillStyle = 'blue'\n  ctx.beginPath()\n  ctx.arc(101, 102, 2, 0, Math.PI * 2, true)\n  ctx.fill()\n  ctx.beginPath()\n  ctx.arc(89, 102, 2, 0, Math.PI * 2, true)\n  ctx.fill()\n  const texture = new THREE.Texture(canvas)\n  texture.needsUpdate = true\n  return texture\n}\n```", "```js\nconst createPoints = () => {\n  const points = []\n  const range = 15\n  for (let i = 0; i < 15000; i++) {\n    let particle = new THREE.Vector3(\n      Math.random() * range - range / 2,\n      Math.random() * range - range / 2,\n      Math.random() * range - range / 2\n    )\n    points.push(particle)\n  }\n  const colors = new Float32Array(points.length * 3)\n  points.forEach((e, i) => {\n    const c = new THREE.Color(Math.random() * 0xffffff)\n    colors[i * 3] = c.r\n    colors[i * 3 + 1] = c.g\n    colors[i * 3 + 2] = c.b\n  })\n  const geom = new THREE.BufferGeometry().setFromPoints(points)\n  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))\n  return geom\n}\nconst material = new THREE.PointsMaterial({ size: 0.1,\n  vertexColors: true, color: 0xffffff, map:\n    createGhostTexture() })\nconst points = new THREE.Points(createPoint(), material)\n```", "```js\nconst texture = new THREE.TextureLoader().load(\"../../assets/textures/particles/raindrop-3t.png\");\n```", "```js\nconst material = new THREE.PointsMaterial({\n    size: 0.1,\n    vertexColors: false,\n    color: 0xffffff,\n    map: texture,\n    transparent: true,\n    opacity: 0.8,\n    alphaTest: 0.01\n  }),\n```", "```js\nconst count = 25000\nconst range = 20\nconst createPoints = () => {\n  const points = []\n  for (let i = 0; i < count; i++) {\n    let particle = new THREE.Vector3(\n      Math.random() * range - range / 2,\n      Math.random() * range - range / 2,\n      Math.random() * range - range / 1.5\n    )\n    points.push(particle)\n  }\n  const velocityArray = new Float32Array(count * 2)\n  for (let i = 0; i < count * 2; i += 2) {\n    velocityArray[i] = ((Math.random() - 0.5) / 5) * 0.1\n    velocityArray[i + 1] = (Math.random() / 5) * 0.1 + 0.01\n  }\n  const geom = new THREE.BufferGeometry().setFromPoints(points)\n  geom.setAttribute('velocity', new THREE.BufferAttribute(velocityArray, 2))\n  return geom\n}\nconst points = new THREE.Points(geom, material);\n```", "```js\nconst positionArray = points.geometry.attributes.position.array\nconst velocityArray = points.geometry.attributes.velocity.array\nfor (let i = 0; i < points.geometry.attributes.position.count; i++) {\n  const velocityX = velocityArray[i * 2]\n  const velocityY = velocityArray[i * 2 + 1]\n  positionArray[i * 3] += velocityX\n  positionArray[i * 3 + 1] -= velocityY\n  if (positionArray[i * 3] <= -(range / 2) || positionArray[i * 3] >= range / 2)\n    positionArray[i * 3] = positionArray[i * 3] * -1\n  if (positionArray[i * 3 + 1] <= -(range / 2) || positionArray[i * 3 + 1] >= range / 2)\n    positionArray[i * 3 + 1] = positionArray[i * 3 + 1] * -1\n}\npoints.geometry.attributes.position.needsUpdate = true\n```", "```js\nconst texture1 = new THREE.TextureLoader().load\n  ('/assets/textures/particles/snowflake4_t.png')\nconst texture2 = new THREE.TextureLoader().load\n  ('/assets/textures/particles/snowflake2_t.png')\nconst texture3 = new  THREE.TextureLoader().load\n  ('/assets/textures/particles/snowflake3_t.png')\nconst baseProps = {\n  size: 0.1,\n  color: 0xffffff,\n  transparent: true,\n  opacity: 0.5,\n  blending: THREE.AdditiveBlending,\n  depthTest: false,\n  alphaTest: 0.01\n}\nconst material1 = new THREE.PointsMaterial({\n  ...baseProps,\n  map: texture1\n})\nconst material2 = new THREE.PointsMaterial({\n  ...baseProps,\n  map: texture2\n})\nconst material3 = new THREE.PointsMaterial({\n  ...baseProps,\n  map: texture3\n})\nconst points1 = new THREE.Points(createPoints(), material1)\nconst points2 = new THREE.Points(createPoints(), material2)\nconst points3 = new THREE.Points(createPoints(), material3)\n```", "```js\nconst sceneOrtho = new THREE.Scene()\nsceneOrtho.backgroundColor = new THREE.Color(0x000000)\nconst cameraOrtho = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, -10, 10)\n```", "```js\nconst getTexture = () => {\n  const texture = new THREE.TextureLoader().load\n   ('/assets/textures/particles/sprite-sheet.png')\n  return texture\n}\nconst createSprite = (size, transparent, opacity, spriteNumber) => {\n  const spriteMaterial = new THREE.SpriteMaterial({\n    opacity: opacity,\n    color: 0xffffff,\n    transparent: transparent,\n    map: getTexture()\n  })\n  // we have 1 row, with five sprites\n  spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)\n  spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)\n  // make sure the object is always rendered at the front\n  spriteMaterial.depthTest = false\n  const sprite = new THREE.Sprite(spriteMaterial)\n  sprite.scale.set(size, size, size)\n  sprite.position.set(100, 50, -10)\n  sprite.velocityX = 5\n  sprite.name = 'Sprite'\n  sceneOrtho.add(sprite)\n}\n```", "```js\n  renderer.render(scene, camera)\n  renderer.autoClear = false\n  renderer.render(sceneOrtho, cameraOrtho)\n```", "```js\nconst texture = new THREE.TextureLoader().load('/assets/textures/particles/glow.png')\nconst geometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 30, 2, 3)\nconst material = new THREE.PointsMaterial({\n    size: 0.2,\n    vertexColors: false,\n    color: 0xffffff,\n    map: texture,\n    depthWrite: false,\n    opacity: 0.1,\n    transparent: true,\n    blending: THREE.AdditiveBlending\n  })\nconst points = new THREE.Points(geometry, material)\n```"]