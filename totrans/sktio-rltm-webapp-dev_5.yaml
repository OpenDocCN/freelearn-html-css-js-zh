- en: Chapter 5. The Socket.IO Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.io provides a very simple API that is easy to use but exposes a lot of
    functionality. Moreover, this functionality works uniformly across browsers and
    the various transport mechanisms provided by socket.io. To achieve this, a socket.io
    client and server do a lot of work in the background. In this chapter, we will
    examine and try to understand the communication in socket.io as well as some socket.io
    internals.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need another protocol?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first question to people familiar with WebSocket is, why do we need another
    protocol when we already have WebSocket? The answer is twofold; socket.io works
    in a uniform manner across browsers (dating back to Internet Explorer 6), and
    socket.io provides a much richer API
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket specification is still under development and is not supported
    on many of the browsers that are in use. In fact, any version of Internet Explorer
    prior to IE10 doesn't have support for WebSocket. There are still many people
    out there using old browsers that don't support WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem for WebSocket is firewalls and proxies. Most of the firewalls
    block any communication (apart from standard HTTP 1.0/1.1), and may not allow
    a WebSocket connection to be established. The same applies to most proxy servers.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we decide to use just the WebSocket protocol, we have to understand that
    there will be many people who may not be able to use our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to this, when we build our application using socket.io, the people
    who can use WebSocket will continue using it, but those who can''t will fall back
    on the next best available transport mechanism and then the next and so on, until
    they find one that works in the browser, even through the firewalls and proxies,
    all the way down to iframes (which is rarely used). The default order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FlashSocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR long polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR multipart streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSONP polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iframe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s also worth noting that using JSONP polling, socket.io provides support
    for cross-domain communication without the need for any special configuration
    on the server or any special code on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us take a look at the differences in the API. For this, we will see
    only the JavaScript client-side API, as any server will have its own implementation
    and API depending on the programming language used.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us begin by taking a quick look at a code snippet showing the skeleton
    of a WebSocket cliet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first step, as can be seen in the previous code snippet, is to create a
    new instance of WebSocket; in this, we have to pass the URI for the WebSocket
    server. This URI, like any other, has a part that specifies the protocol, which
    in this case can be either `ws` (unsecured) or `wss` (secured); the server address
    (the server's IP address or valid domain name); and finally, the port.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we also need to check if WebSocket is supported on the browser that
    the user has, but I have skipped that part to focus on the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the creation of the WebSocket object, we can attach event handlers
    to it. There are three events exposed by WebSocket, with their corresponding event
    handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open`: The `onopen` event handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The `onmessage` event handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`: The `onclose` event handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As is evident by their names, these handlers will be called on the opening of
    a socket connection, when there is a new message on the socket, and on closing
    the socket connection, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For every event, the client receives the event data. In case the event is a
    message, it contains that message along with other data. The WebSocket client
    doesn't try to interpret the message or its type, that is to say, it treats all
    messages as plain text and it is left to the application to interpret and understand
    it. Also, there is no mention of the namespacing of messages or the multiplexing
    of socket connections.
  prefs: []
  type: TYPE_NORMAL
- en: If you see the `onopen` handler, you will notice the `send` method, which is
    used by the client to send messages. Again, it can send only plain text, so you
    have to take care of serialization and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `close` method, which, as the name suggests, can be used
    to close the socket connection from the client.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see the same code using sockt.io:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code snippet looks similar to the one with WebSockets and, not surprisingly,
    does the same work as the previous code. However, there are some minor changes:
    instead of using `onopen`, `onmessage`, and `onclose`, we use socket.io''s `on`
    method to attach the handlers. The advantage is that when we use socket.io''s
    custom events functionality, the API to handle the event remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already seen, you can emit a new event using the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then receive it using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this case, we are passing a JSON object for the data; socket.io
    will take care of serializing and deserializing it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, socket.io provides support for namespacing of messages, multiplexing
    of connections, disconnection detection, reconnection, and an API to broadcast
    messages to all clients.
  prefs: []
  type: TYPE_NORMAL
- en: Considering everything covered in this section, it is not difficult to conclude
    that socket.io will need its own protocol and mechanism to work.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The socket.io socket emulates a network socket over different transport mechanisms.
    Just as any other socket, it has various stages in its lifecycle, depending on
    the status of the connection. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: connecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: connected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: disconnecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: disconnected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The socket is established when the client sends a connection request to the
    server and a handshake is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: Once the handshake is complete, a connection is opened using the transport negotiated
    during the handshake, and the state of the socket is set to *connected*.
  prefs: []
  type: TYPE_NORMAL
- en: To check the liveliness of the socket depending on the server configuration,
    the server may require heartbeat messages to be sent from the client to the server
    in regular intervals. In the absence of such a message, or the failure of the
    underlying transport, the socket will be disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the client will initiate a reconnect. If the connection is restored
    within the connection termination time or the timeout agreed at the time of the
    handshake, the buffered messages are sent across. In case the connection is not
    restored, the client will start a new connection request, beginning with a new
    handshake.
  prefs: []
  type: TYPE_NORMAL
- en: Also, optionally, to ensure message delivery over the socket, we can make it
    compulsory for the socket to acknowledge the message delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The socket is terminated when the `close` method is called on either the client
    or the server.
  prefs: []
  type: TYPE_NORMAL
- en: The Socket.IO connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The socket.io connection begins with the handshake. This makes the handshake
    a special part of the protocol. Apart from the handshake, all the other events
    and messages in the protocol are transferred over the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.io is intended for use with web applications, and therefore it is assumed
    that these applications will always be able to use HTTP. It is because of this
    reasoning that the socket.io handshake takes place over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initiate the connection and hence perform the handshake, the client performs
    a `POST` request on the handshake URI (built from the URI passed to the `connect`
    method). Let us take the same socket.io connection URI and try to understand its
    various parts. Let us say that the URI is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://myhost.com:8080/socket.io/1/](http://myhost.com:8080/socket.io/1/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let us break down and understand this URI.
  prefs: []
  type: TYPE_NORMAL
- en: '`http` is the protocol being used. We can set it to use `https`, using `https`
    in the client''s `connect` `ct` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '`myhost.com` again comes from the `connect` method and is the name or IP address
    of the host you want to connect to. The default i `localhost`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`8080` is the port over which your server is listening. This is also passed
    to the `connect` method when we are invoking it. The default is `80`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.io` is the namespace that handles all the connect requests.'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` is the socket.io protocol version number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server can respond to this in one of thee three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK` – This will be the server''s response when the handshake is successful.
    In addition to the status, the body of the response should be a colon-separated
    list of the session ID given to this connection, the heartbeat timeout, the connection
    closing timeout, and the list of supported transports separated by commas. A sample
    response body looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`401 Unauthorized` – This will be the response from the server in case the
    authorization handler fails to authorize the client. As we saw in the previous
    chapter, this is the handler we attach to the `authorize` event on the server,
    and it uses the connection and cookie information to authorize the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`503 Service Unavailable` – When the server has any other reason, including
    errors, to deny service to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the handshake is successful, based on the transports provided by the server
    and the one supported by the client the socket.io client will start communicating
    with the server on a particular URI. This URI has the form `[scheme]://[host]/[namespace]/[version]/[transportId]/[sessionId]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`[scheme]` is the protocol the client will be using to communicate. In the
    case of WebSockets, this is either `ws` or `wss`, while in the case of XHR, it
    is either `http` or `https`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[host]` is the server name or IP Address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[namespace]` is the socket.io namespace we want to send the message to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[version]` is the version of the socket.io protocol that we are using, currently
    `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[transportId]` is the the name of the transport mechanism chosen for the communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[sessionId]` is the session ID given to the client by the server during the
    handshake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of bidirectional transport, such as WebSocket, the connection opened
    at this URI will be used to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: For unidirectional transports such as XHR long polling, the client will perform
    a `GET` request on this URI, which the server will keep on hold till it has some
    data to send, while the client will perform a `POST` request on this URI whenever
    it has to send a message or an event to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the transport's connection is established, all the communication between
    the client and server happens using messaging over the socket. The messages need
    to be encoded in the format specified by socket.io.
  prefs: []
  type: TYPE_NORMAL
- en: 'This format enables socket.io to determine the type of the message and the
    data sent in the message, and some metadata useful for operation. The message
    format is `[type] : [id (''+'')] : [endpoint] (: [data])`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`type` is a single digit integer, specifying what type of message it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` is the message ID, which is an incremental integer; it is used for ACKs.
    It is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` sign, if present, tells socket.io not to handle the ACKs, as the application
    intends to handle it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoint` is the socket endpoint that the message is intended to be delivered
    to. This is optional and is used when multiplexing the socket for namespacing.
    If omitted, the message will be sent to the default socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` is the associated data to be delivered to the socket. In the case of
    messages, it is treated as plain text, while in the case of events, it will be
    parsed as JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming section, we will see what the types of messages are.
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect (0)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the type is zero (`0`), the message is a disconnect signal. This will
    tell socket.io to close the connection and the mentioned socket. If the endpoint
    is not specified, the message will be sent to the default socket, which will cause
    the whole socket to be closed and all the endpoints on that socket will be terminated.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `0` – The result is that the socket is closed and all the connections/endpoints
    are terminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message: `0::/endpoint` – The socket connection to `/endpoint` will be closed
    and no messages can be sent to or from that endpoint. Other endpoints will continue
    to operate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect (1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This message is only used for multiplexing, and is sent from the client to
    the server to open a new connection. Thus, this message must always have an endpoint.
    The first (default) socket connection is established by the handshake explained
    earlier. The endpoint may be followed by query parameters in a URL query format.
    If the connection is successful, the server will echo the same message, else the
    server can send an error message. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `1::/endpoint` – Requests the server to open a multiplexed socket
    to the endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message: `0::/endpoint?param=one` – Requests the server to open a multiplexed
    socket to the endpoint, passing a parameter called `param` with the value `one`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heartbeat (2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the heartbeat message. It must be sent from the client to the server
    within the timeout negotiated during the handshake. The server will reply with
    a heartbeat message too. In this case, we don''t have an endpoint and nor is any
    other information required. This is because it serves the whole socket. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `2` – Sends a heartbeat message to the other end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message (3)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the message sent over the socket. In the API, this message will be
    sent when you are using `socket.send`, and will result in a message event on the
    receiving end. This message will carry data, treating it as plan text. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `3:1::Some message` – This will send a message to the other end, where
    the message event handler will be triggered with the `Some message` message in
    the event data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message: `3:1:/endpoint:Some message` – Again, the message will be sent to
    other end of the socket, but on the multiplexed endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON message (4)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is similar to sending the message, but in this case the message has to
    be serialized using JSON, and it will be parsed at the other end before being
    sent to the handler. In version 0.6, this was done using the same API as `send()`
    for message, just passing a JSON message instead of a string message. But since
    this introduces a performance penalty over sending plain text from version 0.7
    onwards, we have to use the `json` flag to send a JSON message; for example, `socket.json.send`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `4:1::{"some":"content"}` – Sends the JSON message to the other end
    of the socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event (5)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Event message is a special kind of JSON message that is used to send events
    over the socket. In events, the data payload is of the form `{"name":"eventName",
    "args":{"some":"content"}}`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `name` is the name of the event and `args` are the parameters to be sent
    to the handler. The `socket.emit` call is used to send events in the applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following event names are reserved and cannot be used in applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reconnect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `5:1::{"name": "myEvent", "args":{"some": "data"}` – The result is
    that the event will be sent to the other end and the appropriate event handler
    will be invoked, passing the args to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACK (6)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The acknowledgment (ACK) message will be sent when the message is received,
    with ACK request enabled; or, it can be sent out by the application. The data
    section in the ACK message can be the message ID for the message that is being
    acknowledged. If the message ID is followed by `+` and additional data, it is
    treated as an event packet. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `6:::1` – Sends an acknowledgment for the receipt of a message with
    ID `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message: `6:::1+["A", "B"]` – This will send an acknowledgment for the message
    along with the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error (7)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is sent by the server in case there''s an error, such as failure during
    the processing of a `connect` request to an endpoint. The data section of this
    message will contain the error message and, optionally, advice, separated by the
    `+` sign. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message: `7:::Unauthorized` – The result is that the error will be sent to
    the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NOOP (8)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This message implies no operation, and is used to close a poll after the polling
    times out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the communication mechanism for the socket.io server
    and client. Understanding the working and the message formats, helps us in debugging
    the issues we face during the development of socket.io applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn to deploy and scale socket.io applications
    in production. Also, we will get a few tips on how to minimize our troubles on
    the production server.
  prefs: []
  type: TYPE_NORMAL
