- en: Chapter 4. Understanding and Creating Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides a detailed approach and guidance for creating a framework
    for test automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating frameworks in QTP requires knowledge of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VBScript basics, control structures, loops, and built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts and approaches for designing various frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming constructs that help to create the utilities for the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with VBScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowledge of Visual Basic script is essential to create frameworks. The knowledge
    of creating simple statements, controls structure, loops, and built-in functions
    in VBScript allows us to enhance the test scripts and make them more robust; it
    also allows us to interact with external resources. This section describes the
    VBScript features that are useful throughout the designing of the frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Using VBScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QTP uses VBScript as a scripting language. VBScript allows scripts to deal with
    resources that are not a part of the QTP itself, for example, filesystem and external
    data sources (Excel, databases, and so on). VBScript allows us to define the function
    procedures; it provides a lot of built-in functions that help to create the reusable
    functions. VBScript supports the regular expression that assists in verification
    and validation. Since it's a lightweight language, the framework designer is benefited.
  prefs: []
  type: TYPE_NORMAL
- en: VBScript datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variant is the only datatype in VBScript. A variant can contain different kinds
    of information depending on its declaration and use. It can contain numeric, constant,
    date, string, and Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the subtypes of a variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Subtype | Description | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty` | Variant is uninitialized | 0 for the numeric variables"" or Zero-length
    for the string variables |'
  prefs: []
  type: TYPE_TB
- en: '| `Null` | Variant initially contains no valid data | Does not contain data
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean` |   | True or False |'
  prefs: []
  type: TYPE_TB
- en: '| `Byte` | Small integer | 0-255 |'
  prefs: []
  type: TYPE_TB
- en: '| `Integer` | Integer | From -32,768 to 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| `Currency` | Currency | From -922,337,203,685,477.5808 to 922,337,203,685,477.5807
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Long` | Long integer | From -2,147,483,648 to 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| `Single` | Single-precision floating-point number | From -3.402823E38 to
    -1.401298E-45 for negative values, and from 1.401298E-45 to 3.402823E38 for positive
    values |'
  prefs: []
  type: TYPE_TB
- en: '| `Double` | Double-precision floating-point number | 1.79769313486232E308
    to 4.94065645841247E-324 for negative values, and 4.94065645841247E-324 to 1.79769313486232E308
    for positive values |'
  prefs: []
  type: TYPE_TB
- en: '| `Date (Time)` | A number that represents a date | Dates from January 1, 100
    to December 31, 9999 |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | Represents the characters | Contains characters of variable length
    string, approximately 2 billion in length |'
  prefs: []
  type: TYPE_TB
- en: '| `Object` | Contains an object |   |'
  prefs: []
  type: TYPE_TB
- en: '| `Error` | Contains an Error object |   |'
  prefs: []
  type: TYPE_TB
- en: Operators in VBScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Operators are useful in creating the expressions; these expressions are created
    by arithmetic, comparison, and logical operators. In VBScript, we can divide operators
    into four major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Mathematical | Symbol | Comparison | Symbol | Logical | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Exponential | `^` | Equality | `=` | Logical negation | `Not` |'
  prefs: []
  type: TYPE_TB
- en: '| Urinary negation | `-` | Inequality | `<>` | Logical conjunction | `And`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | `*` | Less than | `<` | Logical disjunction | `OR` |'
  prefs: []
  type: TYPE_TB
- en: '| Division | `/` | Greater than | `>` | Logical exclusion | `XOR` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer division | `\` | Less than equal to | `<=` | Logical equivalence
    | `EQV` |'
  prefs: []
  type: TYPE_TB
- en: '| Modulus | `MOD` | Greater than equal to | `>=` | Logical implication | `IMP`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | `+` | Object equivalence** | `Is` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | `-` |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| Concatenation | `&` |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integer division divides two numbers and returns an integer result, for example,
    5/2 will result in 2 not 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: The modulus or remainder operator divides operand 1 by operand 2 (rounding the
    floating-point number to an integer) and returns a remainder, for example, 5 MOD
    2 will result in 1.
  prefs: []
  type: TYPE_NORMAL
- en: Object equivalence compares two object reference variables. If object1 and object2
    both refer to the same object, the result is `True`; if they don't, the result
    is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding examples of expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An expression is a combination of explicit values, constants, variables, operators,
    and functions that are interpreted according to particular rules of precedence
    and association for a particular programming/scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures and loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A control structure, conditionally, executes a group of statements, depending
    on the value of an expression. There are four constructs that control the flow
    of the execution, which are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| If (condition)statement1End If | If condition Then statements [Else else
    statements ]End If | If condition Then[statements][ElseIf condition Then[elseif
    statements]][Else[else statements]]End If | Select Case expression[Case expression
    list[statements]][Case Else[else statements]]End Select |'
  prefs: []
  type: TYPE_TB
- en: 'An example of the `If` and `else` control statement is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the `Select` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding lines of code executes a series of statements as long
    as the given condition is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Using loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A loop executes a sequence of statements that are specified once but may be
    carried out several times in succession. VBScript allows four looping constructs
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| While … Wend | Do… Loop | For… Next | For each… Next |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| While condition[statements]Wend | Do [{While &#124; Until} condition][statements][Exit
    Do][statements]LoopDo[statements][Exit Do][statements]Loop [{While &#124; Until}
    condition] | For counter = start To end [Step step][statements][Exit For][statements]Next
    | For each element in collection[statements][Exit For][statements]Next [element]
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following is an example of the usage of `While … Wend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One of the drawbacks of the `While…Wend` loop is that it does not have the `exit`
    statement to terminate from the loop but other looping constructs allow us to
    exit from the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The Do Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Do...Loop` runs statements for an indefinite number of times. The statements
    are repeated either while a condition is true or until it becomes true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the usage of `Do Loops`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are two variants of `Do Loop`; we can use the `while` or `until` conditions
    with `Do` or `Loop`. When we use the `while` or `until` condition with `Do`, the
    execution starts with validating the condition first and then enters into the
    loop; refer to example 1\. In the latter case, example 3, the first loop is executed
    once and the condition is checked later.
  prefs: []
  type: TYPE_NORMAL
- en: The `For Next` loop iterates statements over a predefined number of times. Refer
    to the following code.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToProperties` method returns a collection of the properties of the test
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding set of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Do Loop](img/1027EN_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `For each … Next` loop iterates statements for each element in an array
    or collection.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dim dicObj` creates a dictionary variable, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Introducing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A framework is defined as a broad overview, guideline, or skeleton of the interlinked
    components, which supports a particular approach to a specific objective, and
    serves as a guide that can be enhanced as required by adding or deleting components.
    A framework is a working or conceptual model that supports or provides guidelines
    for creating or expanding the test scripts to achieve the test automation, ensuring
    lower maintenance and easy expandability.
  prefs: []
  type: TYPE_NORMAL
- en: A test automation framework is a layered structure and provides the mechanism
    to interrelate and interact with each other to achieve the common goals. Frameworks
    also include actual programs and interfaces or offer utility tools for using the
    frameworks. A framework facilitates a standard way for modifying, adding, and
    deleting the scripts and functions. It's a comprehensive structure that provides
    scalability and reliability with less efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Automation goals can be achieved by selecting the right framework that is suitable
    for test automation. The cost of test automation includes both development and
    maintenance efforts. Selecting the suitable framework and techniques helps in
    maintaining the lower cost and high impact solution.
  prefs: []
  type: TYPE_NORMAL
- en: The automation framework and types of framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, various structures and techniques are used to design the framework.
    Broadly based on these techniques and structures, we can classify the framework
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear**: In this the script is created in a linear fashion, usually generated
    by recording and replaying without or with only slight modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven**: Parameterizes the test and fetches data from a persistent
    data source. The data source could be internal or external to the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular**: A modular framework is designed to achieve modularity at test
    as well as script levels. The modular framework can be of the following combinations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test script modular framework
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Test library modular framework
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyword-driven**: Keyword-driven framework is designed for reducing the maintenance
    cost by separating test cases from their execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid**: In this, two or more of the previous patterns are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record and replay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recording is the process of capturing an object and its properties, creating
    the test objects, and storing them in the Object Repository with hierarchy. Assign
    a logical name to the test object and create the scripts by capturing the operation
    performed on the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Record and replay](img/1027EN_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the AUT, recorded script, and OR. The AUT contains
    the test objects. OR stores the test objects in an hierarchy and with their identification
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recorded scripts take us through the following three test steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Login** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `ashish` in the Agent Name textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A test step contains test objects with hierarchy, operation, and data value
    (if applicable) for the test object. While recording the user action on AUT, OR
    creation and scripts generation almost happen simultaneously. This approach is
    also called the **QTP linear framework** approach. In the linear framework approach,
    scripts are recorded in a step-by-step fashion without focusing on reusability.
    Consider an example where you have a test case to log in to an application, search
    for some data and then log out. In the linear framework, the code would look like
    something shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for creating the QTP linear framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **Flight** date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Fly From** (source).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Fly To** (destination).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **FLIGHT** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Insert Order** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **Flight Reservation** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest way to create scripts and use and implement them if the
    AUT is small, but do not expect frequent changes in AUT. The normal record and
    playback falls under this framework.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of linear a framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantages of linear framework are stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No expertize or experience of programming or designing is required. Basic knowledge
    of QTP is required for creating scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic test object creation and storage in the Object Repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the fastest way to create test automation scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the simplest framework, and it is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps to learn the objects and create the scripts manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can add checkpoints easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of linear framework are stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Does not allow reusability since scripts are created in a linear fashion and
    do not have functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is bound with the scripts; hence, the test is noniterative, and this approach
    is inefficient for executing the test for multiple sets of data. Change the data
    manually for each run or create multiple copies of scripts; unfortunately, both
    of these techniques are inefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintenance cost is very high, and it is tedious, and error-prone since
    it is required to make changes in all the affected areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to add comments on our own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the data-driven framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data-driven framework is the collection of test scripts that run with related
    multiple datasets. This framework provides reusable scripts for different sets
    of data and it improves the test coverage. Input and result (test criteria) data
    values can be stored in one or more central data sources or databases; the actual
    format and organization can be implementation specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the data-driven framework implementation we should know three
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iteration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable is a storage location and an associated with an identifier, which
    contains some known or unknown quantity or information, a value.
  prefs: []
  type: TYPE_NORMAL
- en: A parameter is a variable that is provided as an input to the scripts. Parameterization
    in QTP can be achieved by the `datatable` object. The `datatable` object represents
    the QuickTest design-time data table and its associated sheets and parameters.
    The `datatable` object has various methods and properties to access data from
    the runtime data table object.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration is a process where a parameterized script executes the test for a
    predefined number of times from a data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major steps in creating a data-driven framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the parameters that hold data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add code to get data from the data source and assign a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the settings or add code to execute the test for all the rows or subset
    of rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two major ways to access data in QTP:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `datatable` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating data-driven scripts using the `datatable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the script by recording or manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define parameters in an external Excel sheet as shown in the following screenshot.
    Make sure that the first row contains the parameter name. Enter data in the subsequent
    rows as shown in the following screenshot:![Introduction to the data-driven framework](img/1027EN_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To fetch the data from the external excel sheet, use the `import` method of
    `datatable`:'
  prefs: []
  type: TYPE_NORMAL
- en: Define parameters using the `datatable` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the data, rename the column name by double-clicking on the column name.
    Rename the column and add data to the subsequent rows as shown in the following
    screenshot:![Introduction to the data-driven framework](img/1027EN_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the data-driver tool or `datatable` object parameterization. Add the test
    data to `datatable`, add the column name to the header, and double-click on **Add**
    or change the column name to parameter in the data table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the test scripts iterative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two ways to make scripts iterative. First, under **Test Settings**
    select **Run one iteration only**, **Run on all rows**, and then **Run from row**
    `n` **to row** `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to the data-driven framework](img/1027EN_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Second, you can also programmatically create the scripts for running the test
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run for one iteration, `startnum` and `endnum` should be 1, `startnum=endnum=1`
  prefs: []
  type: TYPE_NORMAL
- en: To run test for all rows, `startnum = 1` and `endnum = datatable. datatable.GetRowCount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s club all the concepts together to parameterize the test. Creating the
    test data in `datatable`. `datatable` takes two arguments: parameter name and
    sheet type. `datatable` has two types of sheets: local sheet (local to action)
    and global sheet. To access the data from the global sheet, use `dtGlobalSheet`,
    and to access the data from the local sheet, use `dtLocalSheet`. Refer to the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to import and iterate the test using `datatable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Excel application with VBScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The FileSystemObject object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VBScript allows you to process drives, folders, and files using the `FileSystemObject`
    (FSO) object model, which is explained in the following section that describes
    how you can use `FileSystemObject` to manipulate files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways for file manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and appending files, removing data from the files, and reading from
    the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying, moving, and deleting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the steps for reading and writing data from text files:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write data to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the text file again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an example of reading and writing to the text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of using a text file for data-driven testing is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods used for performing the read and write operation on the test files
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Write` | Write to an opened text file |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteLine` | Write to an open text file and add a newline character to it
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteBlankLines` | Write blank line(s) to an opened text file |'
  prefs: []
  type: TYPE_TB
- en: '| `Read` | Read characters from the text file, which are specified as an argument
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadLine` | Read the entire line, excluding the newline character |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadAll` | Read the entire data from a text file |'
  prefs: []
  type: TYPE_TB
- en: 'The following example demonstrates the file manipulation operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of using the ADODB to get data from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to the modular framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modularity allows decomposing the components and/or functionality and recombines
    them. This approach is a design technique that emphasizes on separating the functionality
    of an AUT into independent, interconnected modules such that each module contains
    everything necessary to execute only one aspect of the desired functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving the modularity requires modularity at two different layers; one layer
    is test and the other layer is script. To create a modular framework, we need
    to decompose the test layer into manageable pieces based on their objectives.
    For example, common test libraries are separate from function libraries. At test
    level, we decompose the key libraries and resources into a structure to achieve
    the automation goals using appropriate design.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four distinct parts of the modular framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Script-level modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-level modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take the example of the Flight application; the entire functionality
    can be divided into small independent functions as shown in the following figure.
    This requires to achieve script-level modularity as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to the modular framework](img/1027EN_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can omit a few functions as part of the automation that are least used and
    do not contribute towards ROI, such as graph, edit, and help in the Flight application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from decomposing the entire functionality into small, independent functions,
    we need to ensure that other components should also be decomposed. After decomposing,
    the entire test component look likes the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to the modular framework](img/1027EN_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding list contains the most frequently used components, but implementation
    of the framework may require having a few more or less components based on the
    automation goals and requirements. Following is the description of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function library**: This is a collection of scripts that perform a particular
    task. Usually one task that allows to perform on the set of statements on AUT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test data**: This is stored in `datatable`, or an external data source provides
    the input for the tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log files**: They capture the log message that is used to see the outcome
    of the test scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master scripts**: These drive the flow of the test and allow coordination
    with the other components to ensure that the test runs successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handlers**: These allow to exit the test gracefully when an error occurs,
    and reveal information about the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OR**: This is a part of the test that contains the test object; usually the
    OR is a shared OR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: This is a component used to provide test-level environment
    variables or values that allow configuration of the tests that have to be run
    on various environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the test is decomposed, resources are required to be arranged in a structured
    way, which means there is a centralized repository for these resources. Managing
    the test requires the folder structure or test management tool (for example, Quality
    Center) to store the test resources. We need to ensure that the test component
    stays as defined by the guidelines and structure. Structure allows organizing
    the resources for achieving portability and consistency. The framework's folder
    structure is as shown in the following screenshot. The structure may vary from
    project to project but it's important for achieving consistency.
  prefs: []
  type: TYPE_NORMAL
- en: '![Structure](img/1027EN_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Structure has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Facilitates specialization**: Structure designs the components to perform
    the specific tasks and provide abstraction from complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control over resources**: Resource structure simplifies control over resources
    because they are at centralized locations and governed by policies for accessing,
    creating, and updating the resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier communication**: Resource structures clearly state the flow of information
    in a controlled way among team members. The modifications are done at a centralized
    location and utilized by all the other team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better performance**: Each component is specialized to perform its task and
    is tested thoroughly to improve the performance and reliability of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Always use the relative path; do not hardcode the resource location in scripts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Design is the most important aspect of frameworks. The design of a framework
    is driven by its key automation goals. The following is a comprehensive but not
    complete list of goals, where a few more goals can be added if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: It allows decomposing of resources and scripts; this make
    it easier to maintain and debug, and to fix the issues faster and reliably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability**: It is a well-designed and smaller function that improves the
    readability of the script and makes it easy to understand as well as enhances
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Comments and script/function headers are important to improve the readability
    and understandability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Extensibility**: When small functions are created and resources are structured,
    extending the existing functionality becomes easy. This allows us to add and enhance
    functionality, debug, and test with ease faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Functions that allow reusability to function make the framework
    robust and reliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start designing the framework, we should think of functions that can
    be used across scripts in the test to increase the reusability. Test these common
    functions thoroughly, and make sure that they have the necessary error handling
    capabilities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concise scripts**: Make sure that scripts are short and do a single task
    at a time; these scripts should be a part of the appropriate libraries or modules.
    Ensure that the scripts are tightly cohesive and loosely coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High cohesion and coupling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coupling refers to that part of the code which can be reused and can be separated
    from the code but is part of it directly. Whereas cohesion is a measure of how
    closely related are all the responsibilities, data, and methods of a class/code
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, I would like to achieve a minimum of three specific things with
    the design and architecture of a framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep things that have to change together in the code, as close together as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow unrelated things in the code to change independently (also known as orthogonality).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orthogonality is a concept that allows combining the small components to get
    effective results. This eases the read/write programs. A more orthogonal design
    allows for fewer exceptions, symmetry, and consistency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Minimize duplication in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The goals behind achieving loose coupling between modules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the code easier to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make our codes easier to consume by other developers by hiding the complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolate potential changes to a small area of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse code in completely new contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreasing coupling and increasing cohesion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We generally consider high cohesion to be a good thing for designing framework
    libraries like a key design considerations, but why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code. We need a connection string to connect to the database,
    and the connection string and database manipulation code is tightly coupled. Alright,
    what is the issue here? Now if we want to change the DSN, we need to change the
    code for each DSN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite this code to make it less coupled and highly cohesive. I have
    divided the code into two parts. The first part is a function that returns the
    DSN, and the second part uses that DSN and manipulates the database. Now if the
    user wants to access another database, the DSN will be different and the user
    just needs to change the parameter. The previous code is coupled and the following
    code is cohesive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is one more design consideration in the context of the QTP, that is, whether
    we should use actions or functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From my personal experience, we should use functions. Actions have many advantages
    and should be preferred in implementing any framework. Functions allow us to achieve
    the goals without functional decomposition. To create the framework, the generic
    library is required; for example, Logger, Error handler, and configuration utilities
    are required to achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The usability can be enhanced by dividing the entire flow into small manageable
    pieces using actions or functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key steps for designing the modular framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Automation Test Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the test-level components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the script-level functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test It
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Analyzing the application defines the automation goals into the defined functions
    and operations of the intended application. The key considerations for the analysis
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the key functionalities of the application and how are they related
    to each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are key flows?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is the least used functionality? Will it contribute to ROI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the goals that we want to achieve through automation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a design describes the desired features and operations in detail, including
    layouts, modules, rules, verification, and interaction among modules along with
    the process diagrams, pseudo code, and other documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to achieving modularity is by decomposing the functionality and recombining
    the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decomposition**: The interaction of the user with the application is broken
    down into libraries, such as Functional library (login, createorder, and so on),
    Common library, OR, Test data, and environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recombination**: The basic elements of interaction are recombined to follow
    a formal test plan using several levels of aggregation. The steps are aggregated
    to make sequences of the basic steps, and the sequences of basic steps are combined
    to make a scenario. The scenarios are aggregated to make a test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After decomposition and recombination, the overall modular framework design
    will look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a design](img/1027EN_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up an environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up the test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the structure, which is the same as creating the infrastructure for the
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create resources, including installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the folder structures or resources in the Test Management tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure version control (good practice).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Object Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create the OR by adding objects (Add objects to local repository or record the
    test step that automatically creates the test objects).
  prefs: []
  type: TYPE_NORMAL
- en: Creating test-level components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to create test-level components:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the test data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create common functions/libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a functional library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create test flows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add common components by loading the libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating script-level functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to create script-level components:'
  prefs: []
  type: TYPE_NORMAL
- en: Create steps manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the required programming logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the common functions (verification points).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `err` handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating design elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bring all the pieces together into a testing environment, and ensure that the
    test automation is working end-to-end.
  prefs: []
  type: TYPE_NORMAL
- en: Test the framework design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we can perform the test to checks for errors, bugs, and interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Report the bugs, fix them, and retest.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of modular frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional decomposition allows us to divide and conquer the complexities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularity eases designing, implementing, and debugging of the frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides standard interfaces for communicating with each other and allows the
    plugging in and removal of the new modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges for modular frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key challenges for creating modular frameworks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Require more technical know-how and effort to create generic modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For very specific modules, the cost of making interfaces is high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For assemblers (integrators), it can be difficult to assess the quality and
    interaction of different modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be difficult to assemble (integrate) the modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design creativity of a module designer can be limited because he needs to
    conform to the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less variation in products because of overuse of the same modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total system performance may be suboptimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword-driven framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Keyword-driven** testing is also called table-driven testing or action-based
    testing. It is a software testing methodology.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-driven testing uses a spreadsheet to specify test cases in a specific
    format, usually in a table format. The functions are designed for each keyword.
    This keyword is stored in the column on a row of the table. For example, in the
    keyword-driven approach, each action has its corresponding function stored in
    the functional library. Driver scripts drive the entire flow, fetch the action,
    and call the corresponding function.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword-driven testing approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keyword-driven approach is when the interaction of a user with an application
    is abstracted in the form of actions, and data is maintained in the external source.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interaction of the user with the application is broken down to the basic
    elements (login, select flight …). In the keyword-driven approach, a keyword represents
    the business scenario that performs many actions on AUT or small actions repeatedly.
    The basic elements of interaction are referred to as steps.
  prefs: []
  type: TYPE_NORMAL
- en: Recombination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic elements of interaction are recombined to follow a formal test plan
    using several levels of aggregation. The steps are aggregated to make sequence(s)
    of the basic steps, and sequences of the basic steps are combined to make sequence
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the following screenshot that shows mapping of the actions from its
    library function using driver script. The interaction of a user with an application
    is abstracted in the form of actions and data maintained in the external source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separate the test cases from the scripts. The test cases are kept out of the
    scripts. These are fetched by the driver script and the `keyword` function is
    called as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recombination](img/1027EN_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the keyword is found, the corresponding keyword library function is called
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recombination](img/1027EN_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Development of the keyword-driven framework requires achieving the modularity
    first; apart from that, we need the keyword function library, test cases, and
    driver script. The keyword-driven framework is a modular framework plus test cases
    stored in an external source and driver scripts with a specific functional library,
    also called the keyword library.
  prefs: []
  type: TYPE_NORMAL
- en: Function decomposition is an important activity for designing the keyword-driven
    framework, and the decomposition guide to identify the keywords. Keywords are
    the reusable functions that perform one of the key action(s) on AUT, do a specific
    task, and complete it on their own terms. Another important aspect of the keyword-driven
    framework is test cases are separated from the test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword-driven or test-plan driven method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach leverages the advantages of functional decomposition and separates
    the execution from the scripts. The test cases are defined in the spreadsheet
    containing the keywords. Each keyword has its corresponding function library that
    performs the action on the AUT.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, the entire process is keyword driven, including the functionality.
    The keywords control the processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyword-driven testing** (**KDT**) was created to simplify the creation of
    automated test cases and make them as much as manual test cases. KDT creates QTP-automated
    test scripts `On the Fly` based on information entered into a spreadsheet.'
  prefs: []
  type: TYPE_NORMAL
- en: Test case representation will be in rows and columns. In the test scenario spreadsheet,
    each test case will perform an action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In automated testing, the lowest level of granularity is the test case step.
    The step level is where each action or verification occurs.
  prefs: []
  type: TYPE_NORMAL
- en: As per KDT, we need to prepare data spreadsheets for each locale because the
    functionality may differ based upon the different locales. Some locales have a
    specific coverage for commercial groups, individual businesses, and so on. It
    is difficult to handle these in the test script. Test suite is prepared to specify
    which locale/locales need to be executed, and the script is made generic. The
    script is driven based on the Excel sheet, which will take Excel data from the
    locale and generate the `On the Fly` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key steps for designing the keyword-driven framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Automation Test Repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the test-level components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the scripts-level functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have already seen the key steps in creating the modular framework. The approach
    remains the same for the keyword-driven framework as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out about the automation repository in the keyword-driven approach.
    Overall, it contains data related to documents, test suite, and created test cases
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases are also referred to as test scenarios or test groups, which contain
    the spreadsheet that specifies the test steps for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common libraries contain the QTP library files and (`.vbs`, `.qfl`) files that
    control the entire KDT control flow, for example, driver scripts and library files
    (`.qfl`, `.vbs`). Common libraries can be viewed as:'
  prefs: []
  type: TYPE_NORMAL
- en: Utility functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment libraries** contain `.xml` and `.qfl` files that are used to
    set the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error libraries** contain files that are used to catch the errors during
    execution and perform the necessary actions (`.qfl` or `.vbs` file).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Framework documents** contain all the data that is created for the framework,
    for example, enhancements to the initial framework or help files created for the
    framework.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object Repository** contains the `.tsr` object files created using QTP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how various layers and components work together
    to achieve the overall design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The keyword-driven or test-plan driven method](img/1027EN_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generic flow in keyword-driven approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key steps and their sequence of execution in the keyword-driven approach
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the keyword as mentioned in the spreadsheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a list of the parameters from the step that follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the utility functions; the utility scripts will do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call utility scripts with the input parameter-list received from the utility
    script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the driver script to perform specific tasks (for example, log in, select
    flight, and so on), calling user-defined functions if required.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Report any errors to a test report for the test case.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exception handler scripts.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the driver script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the steps from 1 to 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages of the keyword-driven approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key advantages offered by the keyword-driven approach are as explained in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Cost effectiveness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword-driven automation framework reduces cost and time of the test design,
    automation, and execution. Keywords are highly reusable functions that represent
    the business scenarios or actions performed on the GUI. Each of these well-designed
    and tested functions provide good return on investment over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Separating test cases allows executing test cases without modifying the scripts.
    When the flow of the application changes, just change the test cases and not the
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keywords, utilities, and functions are built to achieve reusability. The entire
    framework is divided into layers that are integrated with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword-driven approach provides abstraction from the complexities and technical
    challenges; it is easy to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robustness of the keyword-driven framework allows adapting the changes in
    GUI and test flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows focusing on the development of test cases without or with minimal changes
    to the scripts, functions, and utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword-driven approach allows executing and creating automated test cases
    for non-technical testers, business analysts, and SMEs (Subject Matter Expert)
    to write automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases are separated from the scripts, and it is easy to prepare the test
    cases using the used keywords without knowledge of how they have been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Key challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowledge of designing is required.
  prefs: []
  type: TYPE_NORMAL
- en: New team members have to put in efforts to understand the framework and its
    design. Good documentation and knowledge sharing is required to overcome this
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: The hybrid framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **hybrid framework** allows combining the two frameworks to leverage their
    strengths and remove their weaknesses. Most frameworks, which are developed, fall
    into this category that uses the function decomposition like modular frameworks
    and the data-driven approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key steps in designing the hybrid framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the folder structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating and storing automation resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Organizing and managing resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating the frameworks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dry run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages of the hybrid framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hybrid framework allows leverages, and pulls the strengths of the other frameworks
    and eliminates their shortcomings, which suits the automation. Practically, most
    of the test automation solutions fall in this category.
  prefs: []
  type: TYPE_NORMAL
- en: Key challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though it mitigates the weaknesses of the other approaches, it loses its generosity
    and is very specific to the test automation solution AUT, which reduces the reusability
    of its components across the multiple AUTs.
  prefs: []
  type: TYPE_NORMAL
- en: Business Process Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Business Process Testing** (**BPT**) approach allows dividing the business
    processes into smaller reusable components that can used many times in the same
    or different test scripts; for example, the business process of buying a product
    is split into components such as log in, select product, add to cart, place order,
    and log out, which can be re-used in the same business process or different processes.
    The key advantage is it facilitates SMEs, Bas, and automation engineers to work
    and collaborate effectively. Some people call it a framework, but this is an approach
    rather than a framework. BPT is similar to the modular approach of creating test
    automation solutions using QTP and Quality Center.'
  prefs: []
  type: TYPE_NORMAL
- en: Application-independent framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application-independent framework is a specific keyword-driven testing
    or table-driven testing. It identifies the keywords that are independent of the
    AUT, which can perform specific actions on the components of the AUT directly.
    The key difference between the keyword-driven framework and application-independent
    keyword-driven framework lies in the library. In the application-independent keyword-driven
    framework, the functional library is more generic or works directly on the generic
    components for AUT. The following is the data table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Window | WinObject | Action | Arguments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Calculator | button | Click | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Calculator | button | Click | + |'
  prefs: []
  type: TYPE_TB
- en: '| Calculator | button | Click | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Calculator | button | Click | = |'
  prefs: []
  type: TYPE_TB
- en: '| Calculator | Text | VerResult | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'The functionality of the AUT is specified in the data table. The preceding
    table allows calculating some operations on the calculator window, which is 1
    + 3 = and verify the result. The instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the button (**1**) in the calculator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the button (**+**) in the calculator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the button (**3**) in the calculator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the button (**=**) in the calculator window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the result from text in the calculator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The action column lists the actions done with the mouse, keyboard, or specific
    functions. The data table should be mapped to generate the test step; for example,
    mouse click on the button, and the button is identified by the argument (`1`).
    The control name is given in the `WinObject` column, and the `Window` column contains
    the name of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In QTP, the Object Repository stores the test objects and provides the logical
    name |to it. We can use this logical name as a parameter to create the script;
    for example, we can store the object hierarchy in Excel with data. That is, utilizing
    the code to create the application-independent frameworks. The following diagram
    is an example of how we can achieve the application-independent implementation
    using excel and convert it into scripts. All the objects'' names are provided
    in the column; in runtime, it fetches the object information and creates the scripts
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application-independent framework](img/1027EN_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can observe that the script creates the objects
    at runtime rather than the hardcoded scripts. This gives the application independence
    from the other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the application-independent framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application-independent keyword-driven framework inherits all the advantages
    of the keyword-driven framework, apart from the one that allows us to work on
    different applications without much changes.
  prefs: []
  type: TYPE_NORMAL
- en: Key challenges of the application-independent framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the application-independent framework requires more expertise to deal
    with the complexities in creating generic libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The application-independent keyword-driven approach is usually designed for
    specific technologies and not for multiple technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic framework that is provided by QTP is the replay mechanism and
    easy steps to create the test steps. These steps are put into reusable functions
    and become the functional library in the modular and keyword-driven frameworks.
    Parameterizing the step and allowing it to iterate becomes the data-driven approach.
    Refer to the following diagram that shows the steps we performed in developing
    the one framework that became the base for developing the next one, for example,
    record and replay become the base for data-driven frameworks. One framework becomes
    the base or partial base to the next framework. Refer to the following diagram
    demonstrating how they are related:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key challenges of the application-independent framework](img/1027EN_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the various concepts and approaches to build a framework
    and its components, and a structure that allows us to keep the resources uniformly
    accessible. This helps to achieve the automation goals and lower the maintenance
    cost of the test automation suite.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss various ways to debug scripts,
    custom logging deployment, and maintaining the framework.
  prefs: []
  type: TYPE_NORMAL
