<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Animations and Moving the Camera</h1></div></div></div><p>In the previous chapters, we have seen some simple animations, but nothing too complex. In <a class="link" href="ch01.html" title="Chapter 1. Creating Your First 3D Scene with Three.js">Chapter 1</a>, <em>Creating Your First 3D Scene with Three.js</em>, we introduced the basic rendering loop, and in the chapter following that, we used that to rotate some simple objects and show a couple of other basic animation concepts. In this chapter, we're going to look in more detail at how animation is supported by Three.js. We will look in detail at the following four subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic animation</li><li class="listitem" style="list-style-type: disc">Moving the camera</li><li class="listitem" style="list-style-type: disc">Morphing and skinning</li><li class="listitem" style="list-style-type: disc">Loading external animations</li></ul></div><p>We start with the basic concepts behind animations.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Basic animations</h1></div></div></div><p>Before we look at the examples, let's do a quick recap of what<a id="id861" class="indexterm"/> was shown in <a class="link" href="ch01.html" title="Chapter 1. Creating Your First 3D Scene with Three.js">Chapter 1</a>, <em>Creating Your First 3D Scene with Three.js</em>, on the render loop. To support animations, we need to tell Three.js to render the scene every so often. For this, we use the standard HTML5 <code class="literal">requestAnimationFrame</code> functionality, as follows:</p><div><pre class="programlisting">render();

function render() {

  // render the scene
  renderer.render(scene, camera);
  // schedule the next rendering using requestAnimationFrame
  requestAnimationFrame(render);
}</pre></div><p>With this code, we<a id="id862" class="indexterm"/> only need to call the <code class="literal">render()</code> function once when were done initializing the scene. In the <code class="literal">render()</code> function itself, we use <code class="literal">requestAnimationFrame</code> to schedule the next rendering. This way, the browser will make sure the <code class="literal">render()</code> function is called at the correct interval (usually around 60 times a second). Before <code class="literal">requestAnimationFrame</code> was added to browsers, <code class="literal">setInterval(function, interval)</code> or <code class="literal">setTimeout(function, interval)</code> were used. These would call the specified function once every set interval. The problem with this approach is that it doesn't take into account what else is going on. Even if your animation isn't shown or is in a hidden tab, it is still called and is still using resources. Another issue is that these functions update the screen whenever they are called, not when it is the best time for the browser, which means higher CPU usage. With <code class="literal">requestAnimationFrame</code>, we don't tell the browser when it needs to update the screen; we ask the browser to run the supplied function when it's most opportune. Usually, this results in a frame rate of about 60 fps. With <code class="literal">requestAnimationFrame</code>, your animations will run more smoothly and will be more CPU- and GPU-friendly, and you don't have to worry about timing issues yourself.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec57"/>Simple animations</h2></div></div></div><p>With this<a id="id863" class="indexterm"/> approach, we can very easily animate objects by <a id="id864" class="indexterm"/>changing their rotation, scale, position, material, vertices, faces, and anything else you can imagine. In the next render loop, Three.js will render the changed properties. A very simple example, based on the one we already saw in <a class="link" href="ch01.html" title="Chapter 1. Creating Your First 3D Scene with Three.js">Chapter 1</a>, <em>Creating Your First 3D Scene with Three.js</em>, is available in <code class="literal">01-basic-animation.html</code>. The following screenshot shows this example:</p><div><img src="img/2215OS_09_01.jpg" alt="Simple animations"/></div><p>The <a id="id865" class="indexterm"/>render loop<a id="id866" class="indexterm"/> for this is very simple. Just change the properties of the involved meshes, and Three.js handles the rest. Here's how we do this:</p><div><pre class="programlisting">function render() {
  cube.rotation.x += controls.rotationSpeed;
  cube.rotation.y += controls.rotationSpeed;
  cube.rotation.z += controls.rotationSpeed;

  step += controls.bouncingSpeed;
  sphere.position.x = 20 + ( 10 * (Math.cos(step)));
  sphere.position.y = 2 + ( 10 * Math.abs(Math.sin(step)));

  scalingStep += controls.scalingSpeed;
  var scaleX = Math.abs(Math.sin(scalingStep / 4));
  var scaleY = Math.abs(Math.cos(scalingStep / 5));
  var scaleZ = Math.abs(Math.sin(scalingStep / 7));
  cylinder.scale.set(scaleX, scaleY, scaleZ);

  renderer.render(scene, camera);
  requestAnimationFrame(render);
}</pre></div><p>Nothing spectacular here, but it nicely shows the concept behind the basic animations we discuss in this book. In the next section, we'll take a quick sidestep. Besides animations, an important aspect, which you'll quickly run into when working with Three.js in more complex scenes, is the ability to select objects on screen using the mouse.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec58"/>Selecting objects</h2></div></div></div><p>Even<a id="id867" class="indexterm"/> though not directly related to animations, since we'll be looking into cameras and animations in this chapter, it is a nice addition to the <a id="id868" class="indexterm"/>subjects explained in this chapter. What we'll show here is how you can select an object from the scene using the mouse. We'll first look at the code required for this before we look at the example:</p><div><pre class="programlisting">var projector = new THREE.Projector();

function onDocumentMouseDown(event) {
  var vector = new THREE.Vector3(event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
  vector = vector.unproject(camera);

  var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

  var intersects = raycaster.intersectObjects([sphere, cylinder, cube]);

  if (intersects.length &gt; 0) {
    intersects[ 0 ].object.material.transparent = true;
    intersects[ 0 ].object.material.opacity = 0.1;
  }
}</pre></div><p>In this code, we use <code class="literal">THREE.Projector</code> together with <code class="literal">THREE.Raycaster</code> to determine whether we've clicked on a specific object. What happens when we click on the screen is the following:</p><div><ol class="orderedlist arabic"><li class="listitem">First, <code class="literal">THREE.Vector3</code> is created based on the position where we've clicked on the screen.</li><li class="listitem">Next, with the <code class="literal">vector.unproject</code> function, we convert the clicked position on screen to coordinates in our Three.js scene. In other words, we unproject from screen coordinates to world coordinates.</li><li class="listitem">Next, we create <code class="literal">THREE.Raycaster</code>. With <code class="literal">THREE.Raycaster</code>, we can cast rays into our scene. In this case, we emit a ray from the position of the camera (<code class="literal">camera.position</code>) to the position we clicked on in the scene.</li><li class="listitem">Finally, we use the <code class="literal">raycaster.intersectObjects</code> function to determine whether any of the supplied objects are hit by this ray.</li></ol></div><p>The result from this final step contains information on any object that is hit by this ray. The following information is provided:</p><div><pre class="programlisting">distance: 49.9047088522448
face: THREE.Face3
faceIndex: 4
object: THREE.Mesh
point: THREE.Vector3</pre></div><p>The mesh<a id="id869" class="indexterm"/> that<a id="id870" class="indexterm"/> was clicked on is the object, and <code class="literal">face</code> and <code class="literal">faceIndex</code> point to the face of the mesh that was selected. The <code class="literal">distance</code> value is measured from the camera to the clicked object, and <code class="literal">point</code> is the exact position on the mesh where it was clicked. You can test this out in the <code class="literal">02-selecting-objects.html</code> example. Any object you click on will become transparent and the details of the selection will be printed to the console. </p><p>If you want to see the path of the ray that is cast, you can enable the <code class="literal">showRay</code> property from the menu. The following screenshot shows the ray that was used to select the blue sphere:</p><div><img src="img/2215OS_09_02.jpg" alt="Selecting objects"/></div><p>Now that we've finished this small intermission, let's get back to our animations. Until now, we've changed the properties in our render loop to animate an object. In the next section, we'll look at a small library that makes defining animations a lot easier.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec59"/>Animating with Tween.js</h2></div></div></div><p>Tween.js <a id="id871" class="indexterm"/>is a <a id="id872" class="indexterm"/>small JavaScript library that you can download<a id="id873" class="indexterm"/> from <a class="ulink" href="https://github.com/sole/tween.js/">https://github.com/sole/tween.js/</a> and that you can use to easily define the transition of a property between two values. All the intermediate points between the start and end values are calculated for you. This process is called <strong>tweening</strong>. </p><p>For<a id="id874" class="indexterm"/> instance, you<a id="id875" class="indexterm"/> can use this library to change the <em>x</em> position of a mesh from 10 to 3 in 10 seconds, as follows:</p><div><pre class="programlisting">var tween = new TWEEN.Tween({x: 10}).to({x: 3}, 10000).easing(TWEEN.Easing.Elastic.InOut).onUpdate( function () {
  // update the mesh
})</pre></div><p>In this example, we've<a id="id876" class="indexterm"/> created <code class="literal">TWEEN.Tween</code>. This tween will make sure that the <em>x</em> property is changed from 10 to 3 over a period of 10,000 milliseconds. Tween.js also allows you to define how this property is changed over time. This can be done using linear, quadratic, or any of the other possibilities (see <a class="ulink" href="http://sole.github.io/tween.js/examples/03_graphs.html">http://sole.github.io/tween.js/examples/03_graphs.html</a> for a complete overview). The way the value is changed over time is called <a id="id877" class="indexterm"/>
<strong>easing</strong>. With Tween.js, you configure this using the <code class="literal">easing()</code> function.</p><p>Using this library from Three.js is very simple. If you open up the <code class="literal">03-animation-tween.html</code> example, you can see the Tween.js library in action. The following screenshot shows a still image of the example:</p><div><img src="img/2215OS_09_03.jpg" alt="Animating with Tween.js"/></div><p>In this <a id="id878" class="indexterm"/>example, we've<a id="id879" class="indexterm"/> taken a particle cloud from <a class="link" href="ch07.html" title="Chapter 7. Particles, Sprites, and the Point Cloud">Chapter 7</a>, <em>Particles, Sprites, and the Point Cloud</em>, and animated all the particles down to the ground. The position of these particles is based on a tween created with the Tween.js library, as follows:</p><div><pre class="programlisting">// first create the tweens
var posSrc = {pos: 1}
var tween = new TWEEN.Tween(posSrc).to({pos: 0}, 5000);
tween.easing(TWEEN.Easing.Sinusoidal.InOut);

var tweenBack = new TWEEN.Tween(posSrc).to({pos: 1}, 5000);
tweenBack.easing(TWEEN.Easing.Sinusoidal.InOut);

tween.chain(tweenBack);
tweenBack.chain(tween);


var onUpdate = function () {
  var count = 0;
  var pos = this.pos;

  loadedGeometry.vertices.forEach(function (e) {
    var newY = ((e.y + 3.22544) * pos) - 3.22544;
    particleCloud.geometry.vertices[count++].set(e.x, newY, e.z);
  });

  particleCloud.sortParticles = true;
};

tween.onUpdate(onUpdate);
tweenBack.onUpdate(onUpdate);</pre></div><p>With this<a id="id880" class="indexterm"/> piece of code, we create two tweens: <code class="literal">tween</code> and <code class="literal">tweenBack</code>. The first one defines how the position property transitions from 1 to 0, and the second one does the opposite. With the <code class="literal">chain()</code> function, we chain these two tweens to each other, so these tweens will start looping when started. The final thing we define here is the <code class="literal">onUpdate</code> method. In this method, we walk through all the vertices of the particle system and change their position according to the position provided by the tween (<code class="literal">this.pos</code>).</p><p>We start the tween when the model is loaded, so at the end of the following function, we call the <code class="literal">tween.start()</code> function:</p><div><pre class="programlisting">var loader = new THREE.PLYLoader();
loader.load( "../assets/models/test.ply", function (geometry) {
  ...
  tween.start()
  ...
});</pre></div><p>When the<a id="id881" class="indexterm"/> tween is started, we need to tell the Tween.js library when we want it to update all the tweens it knows about. We do this by calling the <code class="literal">TWEEN.update()</code> function:</p><div><pre class="programlisting">function render() {
  TWEEN.update();
  webGLRenderer.render(scene, camera);
  requestAnimationFrame(render);
}</pre></div><p>With these steps in place, the tween library will take care of positioning the various points of the point cloud. As you can see, using this library is much easier than having to manage the transitions yourself.</p><p>Besides <a id="id882" class="indexterm"/>animating <a id="id883" class="indexterm"/>and changing objects, we can also animate a scene by moving the camera around. In the previous chapters, we already did this a couple of times by manually updating the position of the camera. Three.js also provides a number of additional ways of updating the camera.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Working with the camera</h1></div></div></div><p>Three.js has a number of camera controls<a id="id884" class="indexterm"/> you can use to control the camera throughout a scene. These controls are located in the Three.js distribution and can be found in the <code class="literal">examples/js/controls</code> directory. In this section, we'll look in more detail at the following controls:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FirstPersonControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id885" class="indexterm"/> are controls that behave like those in first-person shooters. Move around with the keyboard and look around with the mouse.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FlyControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id886" class="indexterm"/> are flight simulator-like controls. Move and steer with the keyboard and the mouse.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">RollControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id887" class="indexterm"/> a simpler version of <code class="literal">FlyControls</code>. Allows you to move around and roll around the <em>z</em> axis.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TrackBallControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id888" class="indexterm"/>are the most used controls, allowing you to use the mouse (or the trackball) to easily move, pan, and zoom around the scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OrbitControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id889" class="indexterm"/>simulates a satellite in orbit around a specific scene. This allows you to move around with the mouse and keyboard.</p>
</td></tr></tbody></table></div><p>These controls are the most useful controls available. Besides these, Three.js also provides a number of additional controls you can use (but which aren't explained in this book). Using these controls, however, is done in the same manner as the ones explained in the previous table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DeviceOrientationControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id890" class="indexterm"/>controls the movement of the camera based on the orientation of the device. It internally uses the HTML device orientation API (<a class="ulink" href="http://www.w3.org/TR/orientation-event/">http://www.w3.org/TR/orientation-event/</a>). </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EditorControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id891" class="indexterm"/> are controls that are specifically created for online 3D editors. This is used by the Three.js online editor, which you can<a id="id892" class="indexterm"/> find at <a class="ulink" href="http://threejs.org/editor/">http://threejs.org/editor/</a>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OculusControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id893" class="indexterm"/>are controls that allow you to use an Oculus Rift device to look around in your scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OrthographicTrackballControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id894" class="indexterm"/> the same control as <code class="literal">TrackBallControls</code> but specifically created to be used with <code class="literal">THREE.OrthographicCamera</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PointerLockControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id895" class="indexterm"/> simple control that locks the mouse using the DOM element on which the scene is rendered. This provides basic functionality for a simple 3D game.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TransformControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id896" class="indexterm"/> an internal control used by the Three.js editor.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">VRControls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id897" class="indexterm"/> a control that uses the <code class="literal">PositionSensorVRDevice</code> API to control the scene. More information on this standard can be found at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices">https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices</a>.</p>
</td></tr></tbody></table></div><p>Besides using these camera controls, you can of course also move the camera yourself by setting <code class="literal">position</code> and change where it is pointed to using the <code class="literal">lookAt()</code> function.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>If you've worked with an older version of Three.js, you might be missing a specific camera control named <code class="literal">THREE.PathControls</code>. With this control, it was possible to define a path (for example using <code class="literal">THREE.Spline</code>) and move the camera along that path. In the last version of Three.js, this control was removed because of code complexity. The people behind Three.js are currently working on a replacement, but one isn't available yet.</p></div></div><p>The first of the controls we'll look at is <code class="literal">TrackballControls</code>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec60"/>TrackballControls</h2></div></div></div><p>Before <a id="id898" class="indexterm"/>you can use <code class="literal">TrackballControls</code>, you first <a id="id899" class="indexterm"/>need to include the correct JavaScript file into your page:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/TrackballControls.js"&gt;&lt;/script&gt;</pre></div><p>With this included, we can create the controls and attach them to the camera, as follows:</p><div><pre class="programlisting">var trackballControls = new THREE.TrackballControls(camera);
trackballControls.rotateSpeed = 1.0;
trackballControls.zoomSpeed = 1.0;
trackballControls.panSpeed = 1.0;</pre></div><p>Updating the position of the camera is something we do in the render loop, as follows:</p><div><pre class="programlisting">var clock = new THREE.Clock();
function render() {
  var delta = clock.getDelta();
  trackballControls.update(delta);
  requestAnimationFrame(render);
  webGLRenderer.render(scene, camera);
}</pre></div><p>In the preceding code snippet, we see a new Three.js object, <code class="literal">THREE.Clock</code>. The <code class="literal">THREE.Clock</code> object can be used to exactly calculate the elapsed time that a specific invocation or rendering loop takes to complete. You can do this by calling the <code class="literal">clock.getDelta()</code> function. This function will return the elapsed time between this call and the previous call to <code class="literal">getDelta()</code>. To update the position of the camera, we call the <code class="literal">trackballControls.update()</code> function. In this function, we need to provide the time that has passed since the last time this update function was called. For this, we use the <code class="literal">getDelta()</code> function from the <code class="literal">THREE.Clock</code> object. You might wonder why we don't just pass in the frame rate (1/60 seconds) to the <code class="literal">update</code> function. The reason is that with <code class="literal">requestAnimationFrame</code>, we can expect 60 fps, but this isn't guaranteed. Depending on all kinds of external factors, the frame rate might change. To make sure the camera turns and rotates smoothly, we need to pass in the exact elapsed time.</p><p>A working example for this can be found in <code class="literal">04-trackball-controls-camera.html</code>. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_04.jpg" alt="TrackballControls"/></div><p>You <a id="id900" class="indexterm"/>can <a id="id901" class="indexterm"/>control the camera in the following manner:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Control</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Left mouse button and move</p>
</td><td style="text-align: left" valign="top">
<p>Rotate and roll the camera around the scene</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Scroll wheel</p>
</td><td style="text-align: left" valign="top">
<p>Zoom in and zoom out</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Middle mouse button and move</p>
</td><td style="text-align: left" valign="top">
<p>Zoom in and zoom out</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right mouse button and move</p>
</td><td style="text-align: left" valign="top">
<p>Pan around the scene</p>
</td></tr></tbody></table></div><p>There are a couple of properties that you can use to fine-tune how the camera acts. For instance, you can set how fast the camera rotates with the <code class="literal">rotateSpeed</code> property and disable zooming by setting the <code class="literal">noZoom</code> property to <code class="literal">true</code>. In this chapter, we won't go into detail on what each property does as they are pretty much self-explanatory. For a complete overview of what is possible, look at the source of the <code class="literal">TrackballControls.js</code> file where these properties are listed.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec61"/>FlyControls</h2></div></div></div><p>The<a id="id902" class="indexterm"/> next control we'll look at is <code class="literal">FlyControls</code>. With <code class="literal">FlyControls</code>, you<a id="id903" class="indexterm"/> can fly around a scene using controls also found in flight simulators. An example can be found in <code class="literal">05-fly-controls-camera.html</code>. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_05.jpg" alt="FlyControls"/></div><p>Enabling <code class="literal">FlyControls</code> works in the<a id="id904" class="indexterm"/> same manner as <code class="literal">TrackballControls.</code> First, load the correct JavaScript file:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/FlyControls.js"&gt;&lt;/script&gt;</pre></div><p>Next, we configure the controls and attach it to the camera, as follows:</p><div><pre class="programlisting">var flyControls = new THREE.FlyControls(camera);
flyControls.movementSpeed = 25;
flyControls.domElement = document.querySelector('#WebGL-output');
flyControls.rollSpeed = Math.PI / 24;
flyControls.autoForward = true;
flyControls.dragToLook = false;</pre></div><p>Once<a id="id905" class="indexterm"/> again, we won't look into all the specific properties. Look at the source of the <code class="literal">FlyControls.js</code> file for that. Let's just pick out the properties you need to configure to get this control working. The property that needs to be set correctly is the <code class="literal">domElement</code> property. This property should point to the element in which we render the scene. For the examples in this book, we use the following element for our output:</p><div><pre class="programlisting">&lt;div id="WebGL-output"&gt;&lt;/div&gt;</pre></div><p>We set the property like this:</p><div><pre class="programlisting">flyControls.domElement = document.querySelector('#WebGL-output');</pre></div><p>If we don't set this property correctly, moving the mouse around will result in strange behavior.</p><p>You can <a id="id906" class="indexterm"/>control the camera with <code class="literal">THREE.FlyControls</code> in the following manner:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Control</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Left and middle mouse button</p>
</td><td style="text-align: left" valign="top">
<p>Start moving forward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right mouse button</p>
</td><td style="text-align: left" valign="top">
<p>Move backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mouse movement</p>
</td><td style="text-align: left" valign="top">
<p>Look around</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>W</p>
</td><td style="text-align: left" valign="top">
<p>Start moving forward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>S</p>
</td><td style="text-align: left" valign="top">
<p>Move backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A</p>
</td><td style="text-align: left" valign="top">
<p>Move left</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>D</p>
</td><td style="text-align: left" valign="top">
<p>Move right</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>Move up</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>F</p>
</td><td style="text-align: left" valign="top">
<p>Move down</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Left, right, up, and down arrows</p>
</td><td style="text-align: left" valign="top">
<p>Look left, right, up, and down</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>Roll left</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>E</p>
</td><td style="text-align: left" valign="top">
<p>Roll right</p>
</td></tr></tbody></table></div><p>The next control we'll look at is <code class="literal">THREE.RollControls</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec62"/>RollControls</h2></div></div></div><p>
<code class="literal">RollControls</code><a id="id907" class="indexterm"/> behaves <a id="id908" class="indexterm"/>much the same as <code class="literal">FlyControls</code>, so we won't go into detail here. <code class="literal">RollControls</code> can be created like this:</p><div><pre class="programlisting">var rollControls = new THREE.RollControls(camera);
rollControls.movementSpeed = 25;
rollControls.lookSpeed = 3;</pre></div><p>If you want to play around <a id="id909" class="indexterm"/>with this control, look at the <code class="literal">06-roll-controls-camera.html</code> example. Note that if you only see a black screen, move the mouse to the bottom of your browser, and the cityscape will pan into view. This <a id="id910" class="indexterm"/>camera can be moved around with the following controls:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Control</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Left mouse button</p>
</td><td style="text-align: left" valign="top">
<p>Move forward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right mouse button</p>
</td><td style="text-align: left" valign="top">
<p>Move backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Left, right, up, and down arrows</p>
</td><td style="text-align: left" valign="top">
<p>Move left, right, forward, and backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>W</p>
</td><td style="text-align: left" valign="top">
<p>Move forward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A</p>
</td><td style="text-align: left" valign="top">
<p>Move left</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>S</p>
</td><td style="text-align: left" valign="top">
<p>Move backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>D</p>
</td><td style="text-align: left" valign="top">
<p>Move right</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Q</p>
</td><td style="text-align: left" valign="top">
<p>Roll left</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>E</p>
</td><td style="text-align: left" valign="top">
<p>Roll right</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>Move up</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>F</p>
</td><td style="text-align: left" valign="top">
<p>Move down</p>
</td></tr></tbody></table></div><p>The last of the basic controls we'll look at is <code class="literal">FirstPersonControls</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec63"/>FirstPersonControls</h2></div></div></div><p>As<a id="id911" class="indexterm"/> the <a id="id912" class="indexterm"/>name implies, <code class="literal">FirstPersonControls</code> allows you to control the camera just like in a first-person shooter. The mouse is used to look around and the keyboard is used to walk around. You can find an example in <code class="literal">07-first-person-camera.html</code>. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_06.jpg" alt="FirstPersonControls"/></div><p>Creating<a id="id913" class="indexterm"/> these controls follows the same principles<a id="id914" class="indexterm"/> as the ones followed for other controls we've seen until now. The example we've just shown uses the following configuration:</p><div><pre class="programlisting">var camControls = new THREE.FirstPersonControls(camera);
camControls.lookSpeed = 0.4;
camControls.movementSpeed = 20;
camControls.noFly = true;
camControls.lookVertical = true;
camControls.constrainVertical = true;
camControls.verticalMin = 1.0;
camControls.verticalMax = 2.0;
camControls.lon = -150;
camControls.lat = 120;</pre></div><p>The only properties that you should carefully look at when using this control for yourself are the last two: the <code class="literal">lon</code> and <code class="literal">lat</code> properties. These two properties define where the camera is pointed at when the scene is rendered for the first time.</p><p>The controls<a id="id915" class="indexterm"/> for this control are pretty straightforward:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Control</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Mouse movement</p>
</td><td style="text-align: left" valign="top">
<p>Look around</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Left, right, up, and down arrows</p>
</td><td style="text-align: left" valign="top">
<p>Move left, right, forward, and backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>W</p>
</td><td style="text-align: left" valign="top">
<p>Move forward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A</p>
</td><td style="text-align: left" valign="top">
<p>Move left</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>S</p>
</td><td style="text-align: left" valign="top">
<p>Move backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>D</p>
</td><td style="text-align: left" valign="top">
<p>Move right</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>Move up</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>F</p>
</td><td style="text-align: left" valign="top">
<p>Move down</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Q</p>
</td><td style="text-align: left" valign="top">
<p>Stop all movement</p>
</td></tr></tbody></table></div><p>For the next control, we'll <a id="id916" class="indexterm"/>move on from this first-person perspective to the perspective from space.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec64"/>OrbitControl</h2></div></div></div><p>The<a id="id917" class="indexterm"/> <code class="literal">OrbitControl</code><a id="id918" class="indexterm"/> control is a great way to rotate and pan around an object in the center of the scene. With <code class="literal">08-controls-orbit.html</code>, we've included an example that shows how this control works. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_07.jpg" alt="OrbitControl"/></div><p>Using <code class="literal">OrbitControl</code> is just<a id="id919" class="indexterm"/> as simple as using the other controls. Include the correct JavaScript file, set up the control with the camera, and use <code class="literal">THREE.Clock</code> again to update the control:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/OrbitControls.js"&gt;&lt;/script&gt;
...
var orbitControls = new THREE.OrbitControls(camera);
orbitControls.autoRotate = true;
var clock = new THREE.Clock();
...
var delta = clock.getDelta();
orbitControls.update(delta);</pre></div><p>The<a id="id920" class="indexterm"/> controls for <code class="literal">THREE.OrbitControls</code> are focused on using the mouse, as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Control</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Left mouse click + move</p>
</td><td style="text-align: left" valign="top">
<p>Rotate the camera around the center of the scene</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Scroll wheel or middle mouse click + move</p>
</td><td style="text-align: left" valign="top">
<p>Zoom in and zoom out</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right mouse click + move</p>
</td><td style="text-align: left" valign="top">
<p>Pan around the scene</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Left, right, up, and down arrows</p>
</td><td style="text-align: left" valign="top">
<p>Pan around the scene</p>
</td></tr></tbody></table></div><p>That's it for<a id="id921" class="indexterm"/> the camera and moving it around. In this part, we've seen a lot of controls that allow you to create interesting camera actions. In the next section, we'll look at a more advanced way of animation: morphing and skinning.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Morphing and skeletal animation</h1></div></div></div><p>When you create animations in external programs (for instance, Blender), you usually have two main options to define animations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Morph targets</strong>: With <a id="id922" class="indexterm"/>morph targets, you define a deformed version, that is, a key position, of the mesh. For this deformed target, all vertex positions are stored. All you need to do to animate the shape is move all the vertices from one position to another key position and repeat that process. The following screenshot shows various morph targets used to show facial expressions (the following image has been provided by the Blender foundation):<div><img src="img/2215OS_09_09.jpg" alt="Morphing and skeletal animation"/></div></li><li class="listitem" style="list-style-type: disc"><strong>Skeletal animation</strong>: An <a id="id923" class="indexterm"/>alternative is using skeletal animation. With skeletal animation, you define the skeleton, that is, the bones, of the mesh and attach vertices to the specific bones. Now, when you move a bone, any connected bone is also moved appropriately, and the attached vertices are moved and deformed based on the position, movement, and scaling of the bone. The following screenshot, once again provided by the Blender foundation, shows an example of how bones can be used to move and deform an object:<div><img src="img/2215OS_09_10.jpg" alt="Morphing and skeletal animation"/></div></li></ul></div><p>Three.js supports both <a id="id924" class="indexterm"/>modes, but generally you'll probably get better results with morph targets. The main problem with skeletal animation is getting a good export from a 3D program like Blender that can be animated in Three.js. It's much easier to get a good working model with morph targets than it is with bones and skins.</p><p>In this section, we'll look at both options and additionally look at a couple of external formats supported by Three.js in which animations can be defined.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Animation with morph targets</h2></div></div></div><p>Morph targets<a id="id925" class="indexterm"/> are the most straightforward way of defining an animation. You define all the vertices for each important position (also called key frames) and tell Three.js to move the vertices from one position to the other. The disadvantage of this approach, though, is that for large meshes and large animations, the model files will become very large. The reason is that for each key position, all the vertex positions are repeated.</p><p>We'll show you how to work with morph targets<a id="id926" class="indexterm"/> using two examples. In the first example, we'll let Three.js handle the transition between the various key frames (or morph targets as we'll call them from now on), and in the second one, we'll do this manually.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec29"/>Animation with MorphAnimMesh</h3></div></div></div><p>For our<a id="id927" class="indexterm"/> first morphing example, we'll <a id="id928" class="indexterm"/>use a model that is also available from the Three.js distribution—the horse. The easiest way to understand how a morph-targets-based animation works is by opening up the <code class="literal">10-morph-targets.html</code> example. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_11.jpg" alt="Animation with MorphAnimMesh"/></div><p>In this<a id="id929" class="indexterm"/> example, the horse on the right-hand side is animated and running, and the horse on the left-hand side is standing still. This second horse (the left-hand side one) is rendered from the basic model, that is, the original set of vertices. With the menu in the top-right corner, you can browse through all the morph targets that are available and see the different positions the left-hand side horse can take.</p><p>Three.js <a id="id930" class="indexterm"/>provides a way to move from one position to the next, but this would mean we have to manually keep track of the current position we're in and the target we want to morph into, and once we've reached the target position, repeat this for the other positions. Luckily, Three.js also provides a specific mesh, that is, <code class="literal">THREE.MorphAnimMesh</code>, that takes care of the details for us. Before we continue, here's a quick note on another animation-related mesh provided by Three.js called <code class="literal">THREE.MorphBlendMesh</code>. If you look through the objects provided by Three.js, you might notice this object. With this specific mesh, you can do pretty much the same things you can do with <code class="literal">THREE.MorphAnimMesh</code>, and when you look at the source code, you can even see that much of it is duplicated between these two objects. <code class="literal">THREE.MorphBlendMesh</code>, however, seems to be deprecated and isn't used in any of the official Three.js examples. Everything you could do with <code class="literal">THREE.MorhpBlendMesh</code> can be done with <code class="literal">THREE.MorphAnimMesh</code>, so use <code class="literal">THREE.MorphAnimMesh</code> for this kind of functionality. The following piece of code shows you how to load the model and create <code class="literal">THREE.MorphAnimMesh</code> from it:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('../assets/models/horse.js', function(geometry, mat) {

  var mat = new THREE.MeshLambertMaterial({ morphTargets: true, vertexColors: THREE.FaceColors});

  morphColorsToFaceColors(geometry);
  geometry.computeMorphNormals();
  meshAnim = new THREE.MorphAnimMesh(geometry, mat );
  scene.add(meshAnim);

},'../assets/models' );


function morphColorsToFaceColors(geometry) {

  if (geometry.morphColors &amp;&amp; geometry.morphColors.length) {

    var colorMap = geometry.morphColors[ 0 ];
    for (var i = 0; i &lt; colorMap.colors.length; i++) {
      geometry.faces[ i ].color = colorMap.colors[ i ];
      geometry.faces[ i ].color.offsetHSL(0, 0.3, 0);
    }
  }
}</pre></div><p>This is the <a id="id931" class="indexterm"/>same approach we saw when <a id="id932" class="indexterm"/>loading other models. This time, however, the external model also contains the morph targets. Instead of creating a normal <code class="literal">THREE.Mesh</code> object, we create <code class="literal">THREE.MorphAnimMesh</code>. There are a couple of things you need to take into account when loading animations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make sure the material you use has <code class="literal">THREE.morphTargets</code> set to <code class="literal">true</code>. If it's not set, your mesh won't animate.</li><li class="listitem" style="list-style-type: disc">Before creating <code class="literal">THREE.MorphAnimMesh</code>, make sure to call <code class="literal">computeMorphNormals</code> on the geometry so that all the normal vectors for the morph targets are calculated. This is required for correct lighting and shadow effects.</li><li class="listitem" style="list-style-type: disc">It's also possible to define colors for faces of a specific morph target. These are available from the <code class="literal">morphColors</code> property. You can use this to morph not just the shape of a geometry, but also the colors of the individual faces. With the <code class="literal">morphColorsToFaceColors</code> helper method, we just fix the colors of the faces to the first set of colors in the <code class="literal">morphColors</code> array.</li><li class="listitem" style="list-style-type: disc">The default setting is to play the complete animation in one go. If there are multiple animations defined for the same geometry, you can use the <code class="literal">parseAnimations()</code> function together with <code class="literal">playAnimation(name,fps)</code> to play one of the defined animations. We'll use this approach in the last section of this chapter, where we load animations from an MD2 model.</li></ul></div><p>All that is left<a id="id933" class="indexterm"/> to do is update the animation in the<a id="id934" class="indexterm"/> render loop. For this, we once again use <code class="literal">THREE.Clock</code> to calculate the delta and use it to update the animation, as follows:</p><div><pre class="programlisting">function render() {

  var delta = clock.getDelta();
  webGLRenderer.clear();
  if (meshAnim) {
    meshAnim.updateAnimation(delta *1000);
    meshAnim.rotation.y += 0.01;
  }

  // render using requestAnimationFrame
  requestAnimationFrame(render);
  webGLRenderer.render(scene, camera);
}</pre></div><p>This approach is the easiest and allows you to quickly set up an animation from a model that has morph targets defined. An alternative approach is to set up the animation manually as we show in the next section.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec30"/>Creating an animation by setting the morphTargetInfluence property</h3></div></div></div><p>We'll create <a id="id935" class="indexterm"/>a very simple example where we morph a cube from one shape to another. This time, we'll manually control which target we will morph to. You can find the example in <code class="literal">11-morph-targets-manually.html</code>. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_12.jpg" alt="Creating an animation by setting the morphTargetInfluence property"/></div><p>In this example, we've<a id="id936" class="indexterm"/> manually created two morph targets for a simple cube, as follows:</p><div><pre class="programlisting">// create a cube
var cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
var cubeMaterial = new THREE.MeshLambertMaterial({morphTargets: true, color: 0xff0000});

// define morphtargets, we'll use the vertices from these geometries
var cubeTarget1 = new THREE.CubeGeometry(2, 10, 2);
var cubeTarget2 = new THREE.CubeGeometry(8, 2, 8);

// define morphtargets and compute the morphnormal
cubeGeometry.morphTargets[0] = {name: 'mt1', vertices: cubeTarget2.vertices};
cubeGeometry.morphTargets[1] = {name: 'mt2', vertices: cubeTarget1.vertices};
cubeGeometry.computeMorphNormals();

var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);</pre></div><p>As you open up this example, you'll see a simple cube. With the sliders in the top-right corner, you can set <code class="literal">morphTargetInfluences</code>. In other words, you can determine how much the initial cube should morph into the cube specified as <code class="literal">mt1</code> and how much it should morph into <code class="literal">mt2</code>. When you create your morph targets by hand, you need to take into account the fact that the morph target has the same number of vertices as the source geometry. You can set the influence using the <code class="literal">morphTargetInfluences</code> property of the mesh:</p><div><pre class="programlisting">var controls = new function () {
  // set to 0.01 to make sure dat.gui shows correct output
  this.influence1 = 0.01;
  this.influence2 = 0.01;

  this.update = function () {
    cube.morphTargetInfluences[0] = controls.influence1;
    cube.morphTargetInfluences[1] = controls.influence2;
  };
}</pre></div><p>Note that the <a id="id937" class="indexterm"/>initial geometry can be influenced by multiple morph targets at the same time. These two examples show the most important concepts behind morph target animations. In the next section, we'll have a quick look at animation using bones and skinning.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Animation using bones and skinning</h2></div></div></div><p>Morph <a id="id938" class="indexterm"/>animations are very straightforward. Three.js knows all the target vertex positions and only needs to transition each vertex from one <a id="id939" class="indexterm"/>position to the next. For bones and skinning, it becomes a bit more complex. When you use bones for animation, you move the bone, and Three.js has to determine how to translate the attached skin (a set of vertices) accordingly. For this example, we use a model that was exported from Blender to the Three.js format (<code class="literal">hand-1.js</code> in the <code class="literal">models</code> folder). This is a model of a hand, complete with a set of bones. By moving the bones around, we can animate the complete model. Let's first look at how we loaded the model:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('../assets/models/hand-1.js', function (geometry, mat) {
  var mat = new THREE.MeshLambertMaterial({color: 0xF0C8C9, skinning: true});
  mesh = new THREE.SkinnedMesh(geometry, mat);

  // rotate the complete hand
  mesh.rotation.x = 0.5 * Math.PI;
  mesh.rotation.z = 0.7 * Math.PI;

  // add the mesh
  scene.add(mesh);

  // and start the animation
  tween.start();

}, '../assets/models');</pre></div><p>Loading a <a id="id940" class="indexterm"/>model for bone animation isn't that different <a id="id941" class="indexterm"/>from any of the other models. We just specify the model file, which contains the definition of vertices, faces, and also bones, and based on that geometry, we create a mesh. Three.js also provides a specific mesh for skinned geometries like this called <code class="literal">THREE.SkinnedMesh</code>. The one thing you need to specify to make sure the model is updated is set the <code class="literal">skinning</code> property of the material you use to <code class="literal">true</code>. If you don't set this to <code class="literal">true</code>, you won't see any bone movement. The last thing we do here is that we set the <code class="literal">useQuaternion</code> property of all the bones to <code class="literal">false</code>. In this example, we'll use a <code class="literal">tween</code> object to handle the animation. This <code class="literal">tween</code> instance is defined like this:</p><div><pre class="programlisting">var tween = new TWEEN.Tween({pos: -1}).to({pos: 0}, 3000).easing(TWEEN.Easing.Cubic.InOut).yoyo(true).repeat(Infinity).onUpdate(onUpdate);</pre></div><p>With this tween, we transition the <code class="literal">pos</code> variable from <code class="literal">-1</code> to <code class="literal">0</code>. We've also set the <code class="literal">yoyo</code> property to <code class="literal">true</code>, which causes our animation to run in reverse the next time it is run. To make sure our animation keeps running, we set <code class="literal">repeat</code> to <code class="literal">Infinity</code>. You can also see that we specify an <code class="literal">onUpdate</code> method. This method is used to position the individual bones, and we'll look at this next.</p><p>Before we move the bones, let's look at the <code class="literal">12-bones-manually.html</code> example. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_13.jpg" alt="Animation using bones and skinning"/></div><p>When<a id="id942" class="indexterm"/> you <a id="id943" class="indexterm"/>open this example, you see the hand making a grab-like motion. We did this by setting the <em>z</em> rotation of the finger bones in the <code class="literal">onUpdate</code> method that is called from our tween animation, as follows:</p><div><pre class="programlisting">var onUpdate = function () {
  var pos = this.pos;

  // rotate the fingers
  mesh.skeleton.bones[5].rotation.set(0, 0, pos);
  mesh.skeleton.bones[6].rotation.set(0, 0, pos);
  mesh.skeleton.bones[10].rotation.set(0, 0, pos);
  mesh.skeleton.bones[11].rotation.set(0, 0, pos);
  mesh.skeleton.bones[15].rotation.set(0, 0, pos);
  mesh.skeleton.bones[16].rotation.set(0, 0, pos);
  mesh.skeleton.bones[20].rotation.set(0, 0, pos);
  mesh.skeleton.bones[21].rotation.set(0, 0, pos);

  // rotate the wrist
  mesh.skeleton.bones[1].rotation.set(pos, 0, 0);
};</pre></div><p>Whenever this update method is called, the relevant bones are set to the <code class="literal">pos</code> position. To determine which bone you need to move, it is a good idea to print out the <code class="literal">mesh.skeleton</code> property to the console. This will list all the bones and their names.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Three.js provides a simple helper you can use to show the bones of the models. Add the following to the code:</p><div><pre class="programlisting">helper = new THREE.SkeletonHelper( mesh );
helper.material.linewidth = 2;
helper.visible = false;
scene.add( helper );</pre></div><p>The bones are highlighted. You can see an example of this by enabling the <code class="literal">showHelper</code> property shown in the <code class="literal">12-bones-manually.html</code> example.</p></div></div><p>As you <a id="id944" class="indexterm"/>can <a id="id945" class="indexterm"/>see, working with bones takes a bit more effort but is much more flexible than the fixed morph targets. In this example, we've only moved the rotation of the bones; you can also move the position or change the scale. In the next section, we look at loading animations from external models. In that section, we'll revisit this example, but now, we'll run a predefined animation from the model instead of manually moving the bones around.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Creating animations using external models</h1></div></div></div><p>In <a class="link" href="ch08.html" title="Chapter 8. Creating and Loading Advanced Meshes and Geometries">Chapter 8</a>, <em>Creating and Loading Advanced Meshes and Geometries</em>, we looked at a number of 3D formats that <a id="id946" class="indexterm"/>are supported by Three.js. A couple of those formats also support animations. In this chapter, we'll look at the following examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Blender with the JSON exporter</strong>: We'll start with an animation created in Blender and exported to the Three.js JSON format.</li><li class="listitem" style="list-style-type: disc"><strong>Collada model</strong>: The Collada format has support for animations. For this example, we'll load an animation from a Collada file and render it with Three.js.</li><li class="listitem" style="list-style-type: disc"><strong>MD2 model</strong>: The MD2 model is a simple format used in the older Quake engines. Even though the format is a bit dated, it is still a very good format for storing character animations.</li></ul></div><p>We'll start with the Blender model.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec67"/>Creating a bones animation using Blender</h2></div></div></div><p>To get started <a id="id947" class="indexterm"/>with animations from Blender, you can load the example we've included in the models folder. You can find the <code class="literal">hand.blend</code> file there, which you can load into Blender. The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_14.jpg" alt="Creating a bones animation using Blender"/></div><p>There isn't room in this book to go into much detail on how to create animations in Blender, but there are a couple of things you need to keep in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every vertex from your model must at least be assigned to a vertex group.</li><li class="listitem" style="list-style-type: disc">The name of the vertex groups you use in Blender must correspond to the name of the bone that controls it. That way, Three.js can determine which vertices it needs to modify when moving the bones.</li><li class="listitem" style="list-style-type: disc">Only the first "action" is exported. So make sure the animation you want to export is the first one.</li><li class="listitem" style="list-style-type: disc">When creating key frames, it is a good idea to select all the bones even if they don't change.</li><li class="listitem" style="list-style-type: disc">When exporting the model, make sure the model is in its rest pose. If this is not the case, you'll see a very deformed animation.</li></ul></div><p>For more<a id="id948" class="indexterm"/> information on creating and exporting animations from Blender and the reasons for the aforementioned pointers, you can look at the following great resource: <a class="ulink" href="http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/">http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/</a>.</p><p>When you've created the animation in Blender, you can export the file using the Three.js exporter we used in the previous chapter. When exporting the file using the Three.js exporter, you have to make sure that the following properties are checked:</p><div><img src="img/2215OS_09_15.jpg" alt="Creating a bones animation using Blender"/></div><p>This will export <a id="id949" class="indexterm"/>the animation you've specified in Blender as a skeletal animation instead of a morph animation. With a skeletal animation, the movements of the bones are exported, which we can replay in Three.js.</p><p>Loading the model in Three.js is the same as we did for our previous example; however, now that the model is loaded, we will also create an animation, as follows:</p><div><pre class="programlisting">var loader = new THREE.JSONLoader();
loader.load('../assets/models/hand-2.js', function (model, mat) {

  var mat = new THREE.MeshLambertMaterial({color: 0xF0C8C9, skinning: true});
  mesh = new THREE.SkinnedMesh(model, mat);

  var animation = new THREE.Animation(mesh, model.animation);

  mesh.rotation.x = 0.5 * Math.PI;
  mesh.rotation.z = 0.7 * Math.PI;
  scene.add(mesh);

  // start the animation
  animation.play();

}, '../assets/models');</pre></div><p>To run this<a id="id950" class="indexterm"/> animation, all we have to do is create a <code class="literal">THREE.Animation</code> instance and call the <code class="literal">play</code> method on this animation. Before we see the animation, we still need to take one additional step. In our render loop, we call the <code class="literal">THREE.AnimationHandler.update(clock.getDelta())</code> function to update the animation, and Three.js will use the bones to set the model in the correct position. The result of this example (<code class="literal">13-animation-from-blender.html</code>) is a simple waving hand. </p><p>The following screenshot shows a still image of this example:</p><div><img src="img/2215OS_09_16.jpg" alt="Creating a bones animation using Blender"/></div><p>Besides Three.js' own format, we can use a couple of other formats to define animations. The first one we'll look at is loading a Collada model.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Loading an animation from a Collada model</h2></div></div></div><p>Loading a <a id="id951" class="indexterm"/>model from a Collada file works in the same manner as for the other formats. First, you have to include the correct loader JavaScript file:</p><div><pre class="programlisting">&lt;script type="text/javascript" src="img/ColladaLoader.js"&gt;&lt;/script&gt;</pre></div><p>Next, we create a loader and use it to load the model file:</p><div><pre class="programlisting">var loader = new THREE.ColladaLoader();
loader.load('../assets/models/monster.dae', function (collada) {

  var child = collada.skins[0];
  scene.add(child);

  var animation = new THREE.Animation(child, child.geometry.animation);
  animation.play();

  // position the mesh
  child.scale.set(0.15, 0.15, 0.15);
  child.rotation.x = -0.5 * Math.PI;
  child.position.x = -100;
  child.position.y = -60;
});</pre></div><p>A Collada file can contain much more than just a single mode; it can store complete scenes, including cameras, lights, animations, and more. A good way to work with a Collada model is to print out the result from the <code class="literal">loader.load</code> function to the console and determine which components you want to use. In this case, there was a single <code class="literal">THREE.SkinnedMesh</code> in the scene (<code class="literal">child</code>). To render and animate this model, all we have to do is set up the animation just like we did for the Blender-based model; even the render loop stays the same. Here's how we render and animate the model:</p><div><pre class="programlisting">function render() {
  ...
  meshAnim.updateAnimation( delta *1000 );
  ...
}</pre></div><p>And the result for this specific Collada file looks like this:</p><div><img src="img/2215OS_09_17.jpg" alt="Loading an animation from a Collada model"/></div><p>Another example<a id="id952" class="indexterm"/> of an external model, one that uses morph targets, is the MD2 file format.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Animation loaded from a Quake model</h2></div></div></div><p>The MD2 format<a id="id953" class="indexterm"/> was created to model characters from Quake, a great game from 1996. Even though the newer engines use a different format, you can still find a lot of interesting models in the <a id="id954" class="indexterm"/>MD2 format. To use files in this format, we first have to convert them to the Three.js JavaScript format. You can do this online using the following site:</p><p>
<a class="ulink" href="http://oos.moxiecode.com/js_webgl/md2_converter/">http://oos.moxiecode.com/js_webgl/md2_converter/</a>
</p><p>After conversion, you'll get a JavaScript file in the Three.js format that you can load and render using <code class="literal">MorphAnimMesh</code>. Since we've already seen how to do this in the previous sections, we'll skip the code where the model is loaded. One interesting thing though is happening in the code. Instead of playing the complete animation, we provide the name of the animation that needs to be played:</p><div><pre class="programlisting">mesh.playAnimation('crattack', 10);</pre></div><p>The<a id="id955" class="indexterm"/> reason is that an MD2 file usually contains a number of different character animations. Luckily, though, Three.js provides functionality to determine the available animations and play them using the <code class="literal">playAnimation</code> function. The first thing we need to do is tell Three.js to parse the animations:</p><div><pre class="programlisting">mesh.parseAnimations();</pre></div><p>This results in a list of names for the animations that can be played using the <code class="literal">playAnimation</code> function. In our example, you can select the name of the animation from the menu in the top-right corner. The available animations are determined like this:</p><div><pre class="programlisting">mesh.parseAnimations();

var animLabels = [];
for (var key in mesh.geometry.animations) {
  if (key === 'length' || !mesh.geometry.animations.hasOwnProperty(key)) continue;
  animLabels.push(key);
}

gui.add(controls,'animations',animLabels).onChange(function(e) {
  mesh.playAnimation(controls.animations,controls.fps);
});</pre></div><p>Whenever an animation from the menu is selected, the <code class="literal">mesh.playAnimation</code> function is called with the specified animation name. The example that demonstrates this can be found in <code class="literal">15-animation-from-md2.html</code>. The following screenshot shows us a still image of this example:</p><div><img src="img/2215OS_09_18.jpg" alt="Animation loaded from a Quake model"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we looked at different ways that you can animate your scene. We started with some basic animation tricks, moved on to camera movement and control, and ended with animation models using morph targets and skeleton/bones animations. When you have the render loop in place, adding animations is very easy. Just change a property of the mesh, and in the next rendering step, Three.js will render the updated mesh.</p><p>In previous chapters, we looked at the various materials you can use to skin your objects. For instance, we saw how you can change the color, shininess, and opacity of these materials. What we haven't discussed in detail yet, however, is how you can use external images (also called textures) together with these materials. With textures, you can easily create objects that look like they are made of wood, metal, stone, and much more. In the next chapter, we'll explore all the different aspects of textures and how they are used in Three.js.</p></div></body></html>