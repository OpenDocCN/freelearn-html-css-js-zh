<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Dependencies</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned how to work with classes and interfaces. We also learned about the SOLID principles and other object-oriented programming best practices. In this chapter, we will learn how to work with dependencies. The first part of the chapter will focus on the usage of modules. The second part of the chapter will focus on the management of dependencies in object-oriented programming.</p>
<p>We are going to cover the following topics:</p>
<ul>
<li>Third-party dependencies</li>
<li>Internal modules</li>
<li>External modules</li>
<li>Asynchronous module definition (AMD)</li>
<li>CommonJS modules</li>
<li>ES6 modules</li>
<li>Browserify and universal module definition (UMD)</li>
<li>Circular dependencies</li>
<li>Dependency injection</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Third-party dependencies</h1>
                </header>
            
            <article>
                
<p>Third-party dependencies are usually open source libraries created by third-party organizations or independent software engineers. Third-party dependencies are external modules and can be imported using their name instead of a relative or absolute path.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Package management tools</h1>
                </header>
            
            <article>
                
<p>Package management tools are used for dependency management so that we no longer have to download and manage our application's dependencies manually.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The rise and fall of package management tools</h1>
                </header>
            
            <article>
                
<p>The TypeScript ecosystem has experienced the rise and fall of many package managers over the past few years. This generated some confusion in the early days of TypeScript but, fortunately, today we have a much more stable ecosystem.</p>
<p>Some notable package managers in the TypeScript history include tsd, typings, npm, bower, yarn, and turbo. Some package managers, such as tsd, typings, and bower, are not recommended anymore, and others, such as yarn or turbo, are relatively new and not as widely adopted as npm. The recommended package manager at the time of writing is npm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">npm</h1>
                </header>
            
            <article>
                
<p>The <strong>Node Package Manager</strong> (<strong>npm</strong>) was originally developed as the default Node.js package management tool, but today it is used by many other tools.</p>
<p>npm uses a configuration file, named <kbd>package.json</kbd>, to store references to all the dependencies installed in our project. Originally, npm was usually only used to install backend dependencies, but today it is used to install any dependencies. This includes the following:</p>
<ul>
<li>Backend dependencies</li>
<li>Frontend dependencies</li>
<li>Development tools</li>
<li>TypeScript type definitions</li>
</ul>
<p>Before we install any packages, we should add a <kbd>package.json</kbd> file to our project. We can do this by executing the following command:</p>
<pre><strong>npm init</strong></pre>
<div class="packt_infobox">Please note that we must install Node.js to be able to use the <kbd>npm</kbd> command.</div>
<p>The <kbd>npm init</kbd> command will ask for some basic information about our project, including its name, version, description, entry point, test command, Git repository, keywords, author, and license.</p>
<div class="packt_infobox">Refer to the official npm documentation at <a href="https://docs.npmjs.com/files/package.json"><span class="URLPACKT">https://docs.npmjs.com/files/package.json</span></a> if you are unsure about the purpose of some of the <kbd>package.json</kbd> fields mentioned earlier.</div>
<p>The <kbd>npm</kbd> command will then show us a preview of the <kbd>package.json</kbd> file that is about to be generated, and ask for our final confirmation.</p>
<p>If you would like to skip the questions and generate the file using the default settings, you can use the <kbd>npm init</kbd> command together with the <kbd>--yes</kbd> flag:</p>
<pre><strong>npm init --yes</strong>  </pre>
<p>After creating the project's <kbd>package.json</kbd> file, we will use the <kbd>npm install</kbd> command to install our first dependency.</p>
<p>The <kbd>npm install</kbd> command takes as arguments the name of one or multiple dependencies separated by a single space, and the scope of the installation.</p>
<p>The scope can be the following:</p>
<ul>
<li>Global dependency</li>
<li>Dependency at development time (for example, testing frameworks, compilers, and so on)</li>
<li>Dependency at runtime (for example, a web framework, database ORMs, and so on)</li>
</ul>
<p>We will use the <kbd>tslint</kbd> npm package to check the style of our TypeScript code, so let's install it as a development dependency (using the <kbd>--save-dev</kbd> argument):</p>
<pre><strong>npm install tslint --save-dev</strong> </pre>
<p>To install a global dependency, we will use the <kbd>-g</kbd> argument:</p>
<pre><strong>npm install webpack-dev-server -g </strong>  </pre>
<div class="packt_infobox">We might need administrative privileges to install packages with global scope in our development environment.<br/>
<span>Also note that npm will not add any entries to our</span> <kbd>package.json</kbd> <span>when installing packages with a global scope, but is important that we manually add the right dependencies to the</span> <kbd>devDependencies</kbd> <span>section in</span> <kbd>package.json</kbd> <span>to guarantee that the continuous integration build server will resolve all our project's dependencies correctly. </span></div>
<p>To install a runtime dependency, use the <kbd>--save</kbd> argument:</p>
<pre><strong>npm install react --save</strong>  </pre>
<div class="packt_infobox">Please note that <kbd>react</kbd> is a module that can be used to create user interfaces.</div>
<p>Once we have installed some dependencies in the <kbd>package.json</kbd> file, the contents should look like the following:</p>
<pre>{ 
  "name": "repository-name", 
  "version": "1.0.0", 
  "description": "example", 
  "main": "index.html", 
  "scripts": { 
    "test": "echo "Error: no test specified" &amp;&amp; exit 1" 
  }, 
  "repository": { 
    "type": "git", 
    "url": "https://github.com/username/repository-name.git" 
  }, 
  "keywords": [ 
    "typescript", 
    "demo", 
    "example" 
  ], 
  "author": "Name Surname", 
  "contributors": [], 
  "license": "MIT", 
  "bugs": { 
    "url": "https://github.com/username/repository-name/issues" 
  }, 
  "homepage": "https://github.com/username/repository-name", 
  "engines": {}, 
  "dependencies": { 
    "react": "16.2.0" 
  }, 
  "devDependencies": { 
    "tslint": "5.9.1" 
  } 
} </pre>
<div class="packt_infobox">Some fields in the <kbd>package.json</kbd> file must be configured manually. To learn more about the available <kbd>package.json</kbd> configuration fields, visit <a href="https://docs.npmjs.com/files/package.json">https://docs.npmjs.com/files/package.json</a>.<br/>
<span>The versions of the npm packages used throughout this book may have been updated since its publication. Refer to the package documentation at</span> <a href="https://npmjs.com">https://npmjs.com</a> <span>to find out potential incompatibilities and learn about new features.<br/></span> <span>If you are using one of the modern versions of npm, installing a module will also generate a file named <kbd>package-lock.json</kbd>. This file describes the exact dependency tree that was generated, such that subsequent installations can generate identical trees, regardless of intermediate dependency updates.</span><span><br/></span></div>
<p>All the npm packages will be saved in the <kbd>node_modules</kbd> directory. It is recommended to avoid saving the <kbd>node_modules</kbd> directory into source control (for example, a Git repository).</p>
<p>The next time we set up our development environment, we will need to download all our dependencies again, but to do so, we will only need to execute the <kbd>npm install</kbd> command without any additional parameters:</p>
<pre><strong>npm install</strong>  </pre>
<p>The package manager (npm) will then search for the <kbd>package.json</kbd> file and install all the dependencies listed in it.</p>
<div class="packt_infobox">We can use the npm search engine at <a href="https://www.npmjs.com">https://www.npmjs.com</a> to find potential modules that could be useful for our application.</div>
<p>We can check whether the dependencies of our project are outdated using the <kbd>npm outdated</kbd> command.</p>
<p>We have learned how to use npm to manage the dependencies of a project. However, npm is more than a package manager, because it also allows us to create commands to perform some custom automation tasks, for example, to release a version of our application or run some automated tests. We will learn more about this feature later in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml" target="_blank">Chapter 9</a>, <em>Automating Your Development Workflow</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type definitions</h1>
                </header>
            
            <article>
                
<p>The TypeScript support for existing JavaScript libraries is achieved thanks to the declaration of the public interface, or API, of the library. The declaration of the public interface of a third-party module is known as <strong>type definition</strong>.</p>
<p>When we install an npm module, we can face a few different scenarios.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modules with native support for TypeScript</h1>
                </header>
            
            <article>
                
<p>Some third-party dependencies feature built-in support for TypeScript. For example, an example of a module with native support for TypeScript is the InversifyJS module. In this case, installing the npm module is enough, because the module includes the required type definitions:</p>
<pre><strong>npm install inversify --save</strong> </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modules with external support for TypeScript</h1>
                </header>
            
            <article>
                
<p>Some third-party dependencies do not feature built-in support for TypeScript, but type definitions are available in a separate npm module. An example of a module with external support for TypeScript is the <kbd>react</kbd> module. In this case, installing the npm module is not enough, because it doesn't include the required type definitions. We can solve this by installing the npm module which contains the missing type definitions:</p>
<pre><strong>npm install react --save 
npm install @types/react --save-dev</strong> </pre>
<p>The TypeScript team has developed an automated process that publishes all the available open source type definitions under one unique organization on the npm public registry. The organization is named <kbd>@types</kbd>, and the type definitions use the name of the module that they are defining.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modules with no support for TypeScript</h1>
                </header>
            
            <article>
                
<p>Some third-party dependencies don't feature built-in support for TypeScript, and type definitions are not available in a separate npm. In this case, installing the npm module is not enough, because it doesn't include the required type definitions. We can solve this by creating our type definitions.</p>
<p>Unfortunately, the process of creating our type definitions is not something that can be systematically described and requires a bit of experience, but we are going to try to explain the main complexities around it.</p>
<p>Let's pretend that we need to write custom type definition for the <kbd>react-side-effect</kbd> npm module, which is not the case because the type definitions are available already, but we will use it as an example.</p>
<p>The first thing that we need to do is to install the package that is missing the type definitions:</p>
<pre><strong>npm install react-side-effect --save</strong> </pre>
<p>Then we need to open the <kbd>package.json</kbd> contained inside the <kbd>react-side-effect</kbd> module. Each npm module contains a <kbd>package.json</kbd> file, so it should be located at the following path:</p>
<pre><strong>/node_modules/react-side-effect/package.json</strong> </pre>
<p>If we examine the <kbd>package.json</kbd> file, we should be able to find the <kbd>main</kbd> field. The <kbd>main </kbd>field describes the entry point of the npm module. The <kbd>main</kbd> field in the <kbd>package.json</kbd> of the <kbd>react-side-effect</kbd> npm module looks as follows:</p>
<pre><strong>"main": "lib/index.js"</strong> </pre>
<p>We need to open that file and find which elements are exported by the module and how they are exported. This is the complicated part: we need to navigate through the source code and identify the exported elements and the kind of exports. The <kbd>lib/index.js</kbd> file only exports a function named <kbd>withSideEffect</kbd>:</p>
<pre><strong>module.exports = function withSideEffect // ...</strong> </pre>
<p>At this point, we can create a file named <kbd>external.d.ts</kbd> and add the following type definitions:</p>
<pre>declare module "react-side-effect" { 
    declare const withSideEffect: any; 
    export = withSideEffect; 
} </pre>
<div class="packt_infobox">Please note that we have used the following:<br/>
<kbd>export = withSideEffect;</kbd><br/>
<span><br/>
We have used this kind of module export because that is the kind of export that we can</span> <a href="https://github.com/gaearon/react-side-effect/blob/eb25efece753108b083f9c2c1be8e650712810d0/src/index.js#L5">see</a> <span>in the library's source code.</span><span><br/>
Sometimes we will see a module export like the following:</span><span><br/></span><kbd>export default withSideEffect;</kbd> <span><br/></span><span><br/>
Or one like the following:</span><span><br/></span><kbd>export { withSideEffect };</kbd> <span><br/>
<br/></span> <span>We need to ensure that our type definition file uses the same kind of export that is used in the library. We will learn more about the different kinds of exports later in this chapter.</span><span><br/></span></div>
<p class="mce-root">The preceding code snippet declares a module named react-side-effect. The module exports an entity named <kbd>withSideEffect</kbd> with type <kbd>any</kbd>. The preceding type definitions should be enough to be able to import the module:</p>
<pre class="mce-root">import * as withSideEffect from "react-side-effect"; </pre>
<p>But if we do so, we will get an error:</p>
<pre><strong>Module '"react-side-effect"' resolves to a non-module entity and cannot be imported using this construct.</strong> </pre>
<p>Unfortunately, the only way to fix this is by adding an extra namespace, as described at <a href="https://github.com/Microsoft/TypeScript/issues/5073">https://github.com/Microsoft/TypeScript/issues/5073</a>:</p>
<pre>declare module "react-side-effect" { 
    declare const withSideEffect: any; 
    namespace withSideEffect {}; 
    export = withSideEffect; 
} </pre>
<p>At this point, we can import the module without errors, but the type of <kbd>withSideEffect</kbd> is <kbd>any</kbd>. We can solve this by examining the source code and spending some time trying to figure out the signature of the function. If we do so, we will end up with something like the following:</p>
<pre>declare module "react-side-effect" { 
 
    import React = __React; 
 
    function withSideEffect( 
        reducePropsToState: (propsList: any[]) =&gt; any, 
        handleStateChangeOnClient: (state: any) =&gt; any, 
        mapStateOnServer?: (state: any) =&gt; any 
    ): ClassDecorator; 
 
    class ElementClass extends React.Component&lt;any, any&gt; {} 
 
    interface ClassDecorator { 
        &lt;T extends (typeof ElementClass)&gt;(component:T): T; 
    } 
 
    namespace withSideEffect {}; 
 
    export = withSideEffect; 
} </pre>
<div class="packt_infobox">Please note that it is highly recommended to share your type definitions with the TypeScript community at <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The ECMAScript specification type definitions (lib.d.ts)</h1>
                </header>
            
            <article>
                
<p>The TypeScript compiler automatically includes type definitions for the ECMAScript version that we are targeting. For example, if we target ES5, we will not be able to access the Promise API, because it is part of the ES6 specification:</p>
<pre>const p = Promise.resolve(1); // Error </pre>
<p>However, TypeScript allows us to import the type definitions for a proposal instead of an entire ECMAScript specification. For example, we can target ES5 and use the Promise API by adding the following to our <kbd>tsconfig.json</kbd> file:</p>
<pre>"lib": ["es5", "dom", "es2015.promise"] </pre>
<p>The preceding setting is indicating to the TypeScript compiler that we want it to import the type definitions for the entire ECMAScript 5 specification, the <strong>document object model</strong> (<strong>DOM</strong>) and the Promise API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External TypeScript helpers (tslib)</h1>
                </header>
            
            <article>
                
<p>As we already know, TypeScript allows us to use features of the upcoming ECMAScript specifications. TypeScript uses a series of helper functions to implement some of these features at runtime. The following are some of the helper functions generated by TypeScript:</p>
<ul>
<li><kbd>__extends</kbd> for inheritance</li>
<li><kbd>__assign</kbd> for object spread properties</li>
<li><kbd>__rest</kbd> for object rest properties</li>
<li><kbd>__decorate</kbd>, <kbd>__param</kbd>, and <kbd>__metadata</kbd> for decorators</li>
<li><kbd>__awaiter</kbd> and <kbd>__generator</kbd> for <kbd>async</kbd>/<kbd>await</kbd></li>
</ul>
<p>If one of these helpers is required, TypeScript will generate it at compilation time. However, this can be a problem, because the helper is generated in all of the files that require it, which can lead to a lot of duplicated code.</p>
<p>We can use the following compilation settings to solve this problem:</p>
<ul>
<li>The <kbd>noEmitHelpers</kbd> flag will prevent TypeScript from emitting the helper functions</li>
<li>The <kbd>importHelpers</kbd> flag will emit the code necessary to import the helpers from the <kbd>tslib</kbd> npm module instead of emitting the helper functions</li>
</ul>
<p>The <kbd>tslib</kbd> module contains the declaration of all the required TypeScript helpers. We can install the <kbd>tslib</kbd> module using npm, as follows:</p>
<pre><strong>npm install tslib --save </strong></pre>
<p>This way, the helper functions are only declared once (by the <kbd>tslib</kbd> module).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Internal modules (module and namespace)</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>module</kbd> and <kbd>namespace</kbd> keywords to define internal modules. TypeScript originally allowed us to use the <kbd>module</kbd> keyword to declare internal modules, but it was later deprecated in favor of the <kbd>namespace</kbd> keyword.</p>
<div class="packt_infobox">Internal modules (<kbd>namespaces</kbd>) can be used to encapsulate certain elements of an application and to provide our code with a better organization. However, <strong>we should try to avoid them and favor external modules over namespaces</strong>. External modules should be our preferred option because they are required by some tools that allow us to optimize certain aspects of our application. External modules will be covered in detail later in this chapter.</div>
<p>We can use namespaces to group interfaces, classes, and objects that are somehow related. For example, we could wrap all our application models inside an internal module named <kbd>Models</kbd>:</p>
<pre>namespace Models { 
  export class UserModel { 
    // ... 
  } 
} </pre>
<p>All entities contained by a <kbd>namespace</kbd> are private by default. We can use the <kbd>export</kbd> keyword to declare what parts of our <kbd>namespace</kbd> we wish to make public.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Nested internal modules</h1>
                </header>
            
            <article>
                
<p>We can nest one <kbd>namespace</kbd> inside another as follows:</p>
<pre>namespace App { 
    export namespace Models { 
        export class UserModel { 
            // ... 
        } 
        export class TalkModel { 
            // ... 
        } 
    } 
} </pre>
<p>In the preceding example, we have declared a namespace named <kbd>App</kbd>, and inside it, we have declared a public namespace named <kbd>Models</kbd>, which contains two public classes: <kbd>UserModel</kbd> and <kbd>TalkModel</kbd>.</p>
<p>We can then access the namespace entities by indicating the full namespace name:</p>
<pre>const user = new App.Models.UserModel(); 
const talk = new App.Models.TalkModel(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-file internal modules</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to declare internal modules across multiple files. If an internal module becomes too big, it can be divided into multiple files to increase its maintainability. If we take the preceding example, we could add more contents to the internal module named <kbd>App</kbd> by referencing it in a new file.</p>
<p>Let's create a new file, named <kbd>validation.ts</kbd>, and add the following code to it:</p>
<pre>namespace App { 
    export namespace Validation { 
        export class UserValidator { 
            // ... 
        } 
 
        export class TalkValidator { 
            // ... 
        } 
    } 
} </pre>
<p>We can then access the namespace entities declared in both files by indicating the full namespace name:</p>
<pre>const userModel = new App.Models.UserModel(); 
const talkModel = new App.Models.TalkModel(); 
const userValidator = new App.Validation.UserValidator(); 
const talkValidator = new App.Validation.TalkValidator(); </pre>
<p>Even though the namespaces <kbd>Models</kbd> and <kbd>Validation</kbd> are declared in two different files, we can access them through the <kbd>App</kbd> namespace.</p>
<p>Namespace names can contain periods. For example, instead of nesting the internal modules (validation and models) inside the <kbd>app</kbd> module, we could have used periods in the <kbd>validation</kbd> and <kbd>models</kbd> internal module names:</p>
<pre>namespace App.Validation { 
  // ... 
} 
namespace App.Models { 
  // ... 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Internal module aliases</h1>
                </header>
            
            <article>
                
<p>The <kbd>import</kbd> keyword can be used within an internal module to provide an alias for another module, as follows:</p>
<pre>import TalkValidator = app.validation.TalkValidator; 
const talkValidator2 = new TalkValidator(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compiling internal modules</h1>
                </header>
            
            <article>
                
<p>Once we have finished declaring our internal modules, we can decide whether we want to compile each one into JavaScript or whether we prefer to concatenate all the files into one single file.</p>
<p>We can use the <kbd>--out</kbd> flag to compile all the input files into a single JavaScript output file:</p>
<pre><strong>tsc --out output.js input.ts</strong> </pre>
<p>The compiler will automatically order the output file based on the reference tags present in the files. We can then import our files or file using an HTML <kbd>&lt;script&gt;</kbd> tag.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External modules</h1>
                </header>
            
            <article>
                
<p>TypeScript also has the concept of an external module. JavaScript versions before ECMAScript 6 (ES6) don't include native support for external modules. Developers were forced to develop custom module loaders, and the open source community tried to come up with improved solutions over the years. As a result, today, there are several types of module loaders, and each one of them supports at least one module definition syntax.</p>
<div class="packt_infobox">In general, we can assume that when someone talks about a module, without explicitly specifying whether they are talking about an internal or external module, they are referring to an external module.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Module loaders and module definition syntaxes</h1>
                </header>
            
            <article>
                
<p>The main difference between using modules (instead of namespaces or internal modules) is that after declaring all our modules, we will not import them using an HTML <kbd>&lt;script&gt;</kbd> tag. Using the <kbd>&lt;script&gt;</kbd> tag is not recommended, because web browsers "halt" (or "freeze") simultaneous downloads and rendering of the page when they encounter and load the contents of a <kbd>&lt;script&gt;</kbd> tag.</p>
<div class="packt_infobox">We will discover more about network performance in <a href="2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Application Performance</em>.</div>
<p>External modules avoid loading the modules of our application using the <kbd>&lt;script&gt;</kbd> and use a module loader instead. A <strong>module loader</strong> is a tool that allows us to have better control over the module loading process. This allows us to perform tasks such as loading files asynchronously or combining multiple modules into a single highly optimized file.</p>
<p>Several module definition syntaxes have been proposed over the years by different open source projects due to the lack of native support for external modules in JavaScript:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Module definition syntax</strong></p>
</td>
<td>
<p><strong>Notes</strong></p>
</td>
</tr>
<tr>
<td>
<p>AMD</p>
</td>
<td>
<p>Introduced by the RequireJS module loader</p>
</td>
</tr>
<tr>
<td>
<p>CommonJS</p>
</td>
<td>
<p>Introduced by Node.js</p>
</td>
</tr>
<tr>
<td>
<p>UMD</p>
</td>
<td>
<p>Supports both AMD and UMD</p>
</td>
</tr>
<tr>
<td>
<p>SystemJS</p>
</td>
<td>
<p>Introduced by Angular 2, supports multiple syntaxes</p>
</td>
</tr>
<tr>
<td>
<p>ES6 modules</p>
</td>
<td>
<p>Introduced by the ECMAScript 6 specification</p>
</td>
</tr>
</tbody>
</table>
<p>We can also encounter a wide variety of module loaders:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Module loader</strong></p>
</td>
<td>
<p><strong>Module definition syntax</strong></p>
</td>
<td>
<p><strong>Notes</strong></p>
</td>
</tr>
<tr>
<td>
<p>RequireJS</p>
</td>
<td>
<p>AMD</p>
</td>
<td>
<p>RequireJS was the very first mainstream module loader for JavaScript applications</p>
</td>
</tr>
<tr>
<td>
<p>Browserify</p>
</td>
<td>
<p>CommonJS</p>
</td>
<td>
<p>CommonJS modules were introduced by the original Node.js module system, but today Node.js supports ES6 modules natively</p>
</td>
</tr>
<tr>
<td>
<p>SystemJS</p>
</td>
<td>
<p>Supports multiple module definition syntaxes</p>
</td>
<td>
<p>Supports multiple module definition syntaxes</p>
</td>
</tr>
<tr>
<td>
<p>Native</p>
</td>
<td>
<p>ES6</p>
</td>
<td>
<p>Modern JavaScript engines can support ES6 modules natively</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">External modules at design time and runtime</h1>
                </header>
            
            <article>
                
<p>TypeScript adds a layer of choice, because it allows us to choose which module definition syntax we want to use at design time and which one we want to use at runtime. In a landscape with so many options, it is very easy to feel overwhelmed and confused.</p>
<p>Fortunately, only two module definition syntaxes are available at design time in TypeScript, and one of them is considered deprecated:</p>
<ul>
<li>The legacy external module syntax (deprecated)</li>
<li>The ES6 module syntax (recommended)</li>
</ul>
<div class="packt_infobox">It is also possible to use other module definition syntaxes at runtime, such as the AMD or the UMD syntaxes, but the TypeScript compiler will not try to compile them into the selected module definition output.</div>
<p>TypeScript allows us to choose which kind of module definition syntax will be used at runtime:</p>
<ul>
<li>ES6</li>
<li>CommonJS</li>
<li>AMD</li>
<li>SystemJS</li>
<li>UMD</li>
</ul>
<p>We can indicate our preference by using the <kbd>--module</kbd> flag when compiling, as follows:</p>
<pre>    <strong>tsc --module commonjs main.ts // use CommonJS </strong>
    <strong>tsc --module amd main.ts      // use AMD </strong>
    <strong>tsc --module umd main.ts      // use UMD</strong>
    <strong>tsc --module system main.ts   // use SytemJS</strong>
  </pre>
<p>It is important to understand that the kind of module definition syntax used at design time and the one used at runtime can be different.</p>
<p>Since the release of TypeScript 1.5, it has been recommended to use the ECMAScript 6 module definition syntax, because it is based on the ECMAScript specification, which is considered a standard. Additionally, if we are planning to run our TypeScript application in a modern JavaScript engine, we will be able to use the ECMAScript 6 module definition syntax at both design time and runtime.</p>
<p>We will now look at each of the available module definition syntaxes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ES6 modules (runtime and design time)</h1>
                </header>
            
            <article>
                
<p>TypeScript 1.5 introduced support for the ES6 module syntax. The following code snippet defines an external module using the ES6 module syntax:</p>
<pre>class UserModel { 
  // ... 
} 
export { UserModel }; </pre>
<p>We don't need to use the <kbd>namespace</kbd> keyword to declare an ES6 module, but we must use the <kbd>export</kbd> keyword. We can use the <kbd>export</kbd> keyword at the bottom of the module or when an entity is declared:</p>
<pre>export class TalkModel { 
  // ... 
} </pre>
<p>We can also export an entity using an alias:</p>
<pre>class UserModel { 
  // ... 
} 
export { UserModel as User }; // UserModel exported as User </pre>
<p>An export declaration exports all meanings of a name:</p>
<pre>interface UserModel { 
  // ... 
} 
 
class UserModel { 
  // ... 
} 
export { UserModel }; // Exports both interface and function </pre>
<p>To import a module from another module, we must use the <kbd>import</kbd> keyword as follows:</p>
<pre>import { UserModel } from "./models"; </pre>
<p>The <kbd>import</kbd> keyword creates a variable for each imported component. In the preceding code snippet, a new variable named <kbd>UserModel</kbd> is declared, and its value contains a reference to the <kbd>UserModel</kbd> class, which is declared and exported by the imported module (the <kbd>model.ts</kbd> file).</p>
<p>We can use the <kbd>export</kbd> keyword to export multiple entities, as follows:</p>
<pre>class UserValidator { 
  // ... 
} 
 
class TalkValidator { 
  // ... 
} 
 
export { UserValidator, TalkValidator }; </pre>
<p>Furthermore, we can use the <kbd>import</kbd> keyword to import multiple entities from a single module, as follows:</p>
<pre>import { UserValidator, TalkValidator } from "./validation.ts" </pre>
<p>Finally, we can also use the <kbd>default</kbd> keyword to declare the default entity to be imported when no explicit entities are imported:</p>
<pre>export default UserValidator; </pre>
<p>We can then import the default export as follows:</p>
<pre>import UserValidator from "./validation.ts" </pre>
<div class="packt_infobox">ES6 modules work natively on modern JavaScript engines, but if you are targeting a JavaScript engine that doesn't support ES6 modules, you will need to use a tool such as webpack to enable backward compatibility with previous JavaScript engines.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Legacy external modules (design time only)</h1>
                </header>
            
            <article>
                
<p>Before TypeScript 1.5, external modules were declared using a specific design-time syntax. However, once compiled into JavaScript, modules were transformed into AMD, CommonJS, UMD, or SystemJS modules.</p>
<p>We should <strong>try to avoid using the legacy external module syntax and use the new ES6 syntax instead</strong>. However, we will take a quick look at the external module syntax, because it is still possible to face it sometimes in old applications and documentation.</p>
<p>To export a module using the legacy external module syntax, we need to use the <kbd>export</kbd> keyword. We can apply the <kbd>export</kbd> keyword directly to a class or interface as follows:</p>
<pre>export class User { 
 // ... 
} </pre>
<p>We can also use the <kbd>export</kbd> keyword on its own by assigning to it the value that we desire to export:</p>
<pre>class User { 
 // ... 
} 
export = User;  </pre>
<p>External modules can be compiled into any of the available module definition syntaxes (AMD, CommonJS, SystemJS, or UMD).</p>
<p>The legacy external module syntax <kbd>import</kbd> statements look as follows:</p>
<pre>import User = require("./user_class"); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">AMD modules (runtime only)</h1>
                </header>
            
            <article>
                
<p>If we compile the external module that we defined in the ES6 modules section into an AMD module (using the flag <kbd>--compile amd</kbd>), we will generate the following AMD module:</p>
<pre>define(["require", "exports"], function (require, exports) { 
    var UserModel = (function () { 
        function UserModel() { 
        } 
        return UserModel; 
    })(); 
    return UserModel; 
}); </pre>
<p>The <kbd>define</kbd> function takes an array as its first argument. This array contains a list of the names of the module dependencies. The second argument is a callback that will be invoked once all the module dependencies have been loaded. The callback takes each of the module dependencies as its parameters and contains all the logic from our TypeScript component. Notice how the return type of the callback matches the components that we declared as public by using the <kbd>export</kbd> keyword.</p>
<p>TypeScript will throw a compilation error because the <kbd>define</kbd> function is not declared. We can solve this problem by installing the RequireJS type definitions:</p>
<pre><strong>npm install --save @types/requirejs</strong> </pre>
<p>The AMD module can then be loaded using the RequireJS module loader as follows:</p>
<pre>require(["./models"], function(models) { 
    const user = new models.UserModel(); 
});</pre>
<p>As we can observe, AMD modules use two different functions to define modules (<kbd>define</kbd>) and consume modules (<kbd>require</kbd>). Usually, the application entry point uses the require function to load all the required dependencies.</p>
<div class="packt_infobox">We will not discuss AMD and RequireJS further in this book, but if you want to learn more about it, you can do so by visiting <a href="http://requirejs.org/docs/start.html">http://requirejs.org/docs/start.html</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CommonJS modules (runtime only)</h1>
                </header>
            
            <article>
                
<p>If we compile the external module that we defined in the ES6 modules section into an CommonJS module (using the flag <kbd>--compile commonjs</kbd>), we will obtain the following CommonJS module:</p>
<pre>var UserModel = (function () { 
    function UserModel() { 
      //... 
    } 
    return UserModel; 
})(); 
module.exports = UserModel; </pre>
<p>As we can see in the preceding code snippet, the CommonJS module definition syntax is almost identical to that of the legacy external module syntax. The main difference is the usage of the <kbd>module</kbd> object and its <kbd>exports</kbd> property instead of the <kbd>exports</kbd> keyword.</p>
<p>The preceding CommonJS module can be loaded natively by a Node.js application using the <kbd>import</kbd> keyword and the <kbd>require</kbd> function:</p>
<pre>import UserModel = require('./UserModel'); 
const user = new UserModel(); </pre>
<p>However, if we attempt to use the <kbd>require</kbd> function in a web browser, an exception will be thrown because the <kbd>require</kbd> function is undefined. We can easily solve this problem by using Browserify. Browserify is a module loader that allows us to use CommonJS modules in a web browser.</p>
<p class="mce-root packt_infobox"><span>If you need more information about Browserify, visit the official documentation at</span> <span><a href="https://github.com/substack/node-browserify#usage"><span class="URLPACKT">https://github.com/substack/node-browserify#usage</span></a></span><span>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">UMD modules (runtime only)</h1>
                </header>
            
            <article>
                
<p>If we want to release a JavaScript library or framework, we will need to compile our TypeScript application into both CommonJS and AMD modules, as well as compile in a way that it can be used by developers who don't want to use a module loader.</p>
<p>The web development community has developed the following code snippet to help us to achieve UMD support:</p>
<pre>(function (root, factory) { 
  if (typeof exports === 'object') { 
    // CommonJS 
    module.exports = factory(require('b')); 
  } else if (typeof define === 'function' &amp;&amp; define.amd) { 
    // AMD 
    define(['b'], function (b) { 
      return (root.returnExportsGlobal = factory(b)); 
    }); 
  } else { 
    // Global Variables 
    root.returnExportsGlobal = factory(root.b); 
  } 
}(this, function (b) { 
  // Your actual module 
  return {}; 
})); </pre>
<p>The preceding code snippet is great, but we want to avoid manually adding it to every single module in our application. Fortunately, there are a few options available to achieve UMD support with ease.</p>
<p>The first option is to use the flag <kbd>--compile umd</kbd> to generate one UMD module for each module in our application. The second option is to create one single UMD module that will contain all the modules in the application using a module loader such as Browserify.</p>
<div class="packt_infobox">Refer to the official Browserify project website at <a href="http://browserify.org/">http://browserify.org/</a> to learn more about Browserify. Refer to the <kbd>Browserify-standalone</kbd> option to learn more about the generation of one unique optimized file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SystemJS modules (runtime only)</h1>
                </header>
            
            <article>
                
<p>While UMD gives you a way to output a single module that works in both AMD and CommonJS, SystemJS will allow you to use ES6 modules closer to their native semantics without requiring an ES6-compatible browser engine.</p>
<p>SystemJS was introduced by Angular 2.0, which is a popular web application development framework.</p>
<div class="packt_infobox">Refer to the official SystemJS project website at <a href="https://github.com/systemjs/systemjs">https://github.com/systemjs/systemjs</a> to learn more about SystemJS.<br/>
<br/>
There is a free list of common module mistakes available online at <a href="http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules">http://www.typescriptlang.org/Handbook#modules-pitfalls-of-modules</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modules summary</h1>
                </header>
            
            <article>
                
<p>We can summarize all the preceding details using the following comparison table:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Module syntax</strong></p>
</td>
<td>
<p><strong>Design-time support</strong></p>
</td>
<td>
<p><strong>Module loader runtime support</strong></p>
</td>
<td>
<p><strong>Native runtime support</strong></p>
</td>
<td>
<p><strong>Optimization tool support</strong></p>
</td>
<td>
<p><strong>Recommended</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Legacy internal modules</strong></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes (via closures)</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>Namespaces</strong></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes (via closures)</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>ES6</strong></p>
</td>
<td>
<p><strong>Yes</strong></p>
</td>
<td>
<p><strong>Yes</strong></p>
</td>
<td>
<p><strong>Yes</strong></p>
</td>
<td>
<p><strong>Yes</strong></p>
</td>
<td>
<p><strong>Yes</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Legacy external modules</strong></p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>AMD</strong></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>CommonJS</strong></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>UMD</strong></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
<tr>
<td>
<p><strong>SystemJS</strong></p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
<td>
<p>Yes</p>
</td>
<td>
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p>As we can see, <strong>the recommended solution going forward is the usage of ES6 modules</strong>. If you are targeting a JavaScript engine that doesn't support ES6 modules, you will need to use a tool such as webpack to enable backward compatibility with previous JavaScript engines.</p>
<div class="packt_infobox">We will learn more about Webpack in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing dependencies in OOP</h1>
                </header>
            
            <article>
                
<p>We have learned how to work with application dependencies and third-party dependencies. We will now learn about the dependency inversion and extend what we learned in the previous chapter about the dependency inversion principle.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency injection versus dependency inversion</h1>
                </header>
            
            <article>
                
<p>Many articles use the terms <em>dependency injection</em> and <em>dependency inversion</em> as if their meanings were identical, but they are two very different concepts.</p>
<p>The following example declares a class named <kbd>Ninja</kbd> and a class named <kbd>Katana</kbd>. The <kbd>Ninja</kbd> class has a dependency on the class <kbd>Katana</kbd>:</p>
<pre>class Katana { 
    public tryHit(fromDistance: number) { 
        return fromDistance &lt;= 2; 
    } 
} 
 
class Ninja { 
    public constructor( 
        private _katana: Katana 
    ) {} 
    public fight(fromDistance: number) { 
        return this._katana.tryHit(fromDistance); 
    } 
} </pre>
<p>After declaring the preceding classes, we can inject an instance of <kbd>Katana</kbd> into the <kbd>Ninja</kbd> class:</p>
<pre>const ninja = new Ninja(new Katana()); 
ninja.fight(2); // true 
ninja.fight(5); // false </pre>
<p>The preceding code snippet implements the dependency injection design pattern because we are injecting a dependency (<kbd>Katana</kbd>) into the <kbd>Ninja</kbd> class. However, we are not implementing the dependency inversion principle because the <kbd>Ninja</kbd> class has a direct dependency on the <kbd>Katana</kbd> class.</p>
<p>The relationship between the <kbd>Ninja</kbd> class and the <kbd>Katana</kbd> class can be represented using the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><strong><em>Ninja → Katana</em></strong></p>
<p>The following code snippet declares an interface named <kbd>Weapon</kbd>, which is then implemented by the <kbd>Katana</kbd> class. This time, the <kbd>Ninja</kbd> class has a dependency on the <kbd>Weapon</kbd> interface instead of the <kbd>Katana</kbd> class:</p>
<pre>interface Weapon { 
    try Hit(fromDistance: number): boolean; 
} 
 
class Katana implements Weapon { 
    public tryHit(fromDistance: number) { 
        return fromDistance &lt;= 2; 
    } 
} 
 
class Ninja { 
    public constructor( 
        private _weapon: Weapon 
    ) {} 
    public fight(fromDistance: number) { 
        return this._weapon.tryHit(fromDistance); 
    } 
} </pre>
<p>After declaring the preceding classes, we can inject an instance of <kbd>Katana</kbd> into the <kbd>Ninja</kbd> class:</p>
<pre>const ninja = new Ninja(new Katana()); 
ninja.fight(2); // true 
ninja.fight(5); // false </pre>
<p>The preceding code snippet implements the dependency injection design pattern because we are injecting a dependency (<kbd>Katana</kbd>) into the <kbd>Ninja</kbd> class. It also implements the dependency inversion principle because the <kbd>Ninja</kbd> class does not have a direct dependency on the <kbd>Katana</kbd> class.</p>
<p>This time, the relationship between the classes can be represented using the following:</p>
<p class="CDPAlignCenter CDPAlign"><strong><em>Ninja → Weapon ← Katana</em></strong></p>
<p>As we can see, the arrow that represents the relationship between the <kbd>Ninja</kbd> and the <kbd>Katana</kbd> classes has been inverted. This explains the name of the dependency inversion principle.</p>
<p>The dependency inversion principle is important because it makes our code easier to maintain by reducing the level of coupling between the entities in our application. For example, if we rename the <kbd>Katana</kbd> class, we will not need to change the <kbd>Ninja</kbd> class. This means that the <kbd>Katana</kbd> and the <kbd>Ninja</kbd> classes are fully independent of each other.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inversion of control containers</h1>
                </header>
            
            <article>
                
<p>An <strong>inversion of control</strong> (<strong>IoC</strong>) container is a kind of tool that acts as a <em>smart factory</em>. An IoC container can be used to create instances of a class. If the class has some dependencies, the IoC container will be able to use dependency injection to cover the need for them. We say that the factory is <em>smart</em> because it can create dependencies based on matching conditions in the execution context and it can also control the life cycle of the instances that it creates.</p>
<p>When we use an IoC container, we are <em>losing control</em> of the creation of class instances, and the injection of dependencies and the IoC container will take control of these aspects of our application. This fact should explain the meaning of the term <em>inversion of control</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">InversifyJS basics</h1>
                </header>
            
            <article>
                
<p>InversifyJS is an IoC container for TypeScript applications. InversifyJS can be used to implement the dependency inversion principle.</p>
<p>To use InversifyJS, we need to install it using npm as follows:</p>
<pre><strong>npm install inversify reflect-metadata --save</strong> </pre>
<p>We can then import some of the entities declared by <kbd>inversify</kbd> and <kbd>reflect-metadata</kbd> as follows:</p>
<pre>import { Container, inject, injectable } from "inversify"; 
import "reflect-metadata"; </pre>
<p>The following code snippet adds an annotation to the <kbd>Ninja</kbd> class using the <kbd>inject</kbd> decorator:</p>
<pre>interface Weapon { 
    tryHit(fromDistance: number): boolean; 
} 
 
@injectable() 
class Katana implements Weapon { 
    public tryHit(fromDistance: number) { 
        return fromDistance &lt;= 2; 
    } 
} 
 
@injectable() 
class Ninja { 
    public constructor( 
        @inject("Weapon") private _weapon: Weapon 
    ) {} 
    public fight(fromDistance: number) { 
        return this._weapon.tryHit(fromDistance); 
    } 
} </pre>
<p>To create an instance of <kbd>Ninja</kbd> using InversifyJS, we need to create an instance of the <kbd>Container</kbd> class and declare what is known as <strong>type binding</strong>. A type binding is a link between a type and an implementation of that type. The following code snippet declares two type bindings. The first type binding links the type <kbd>Weapon</kbd> with the implementation <kbd>Katana</kbd>. The second type binding links the type <kbd>Ninja</kbd> to itself:</p>
<pre>const container = new Container(); 
container.bind&lt;Weapon&gt;("Weapon").to(Katana); 
container.bind&lt;Ninja&gt;("Ninja").to(Ninja);</pre>
<p>We can then create instances of the <kbd>Ninja</kbd> class using the container. The container uses the annotation to identify that the <kbd>Ninja</kbd> class has a dependency on the <kbd>Weapon</kbd> type. The container then creates an instance of the <kbd>Katana</kbd> class and is injected into the <kbd>Ninja</kbd> class because it knows that the <kbd>Katana</kbd> class is a valid implementation of the <kbd>Weapon</kbd> interface:</p>
<pre>const ninja = container.get&lt;Ninja&gt;("Ninja"); 
ninja.fight(2); // true 
ninja.fight(5); // false </pre>
<p>InversifyJS also allows us to control the life cycle of the dependencies. For example, we can configure the <kbd>Katana</kbd> type binding to make all instances a single shared instance (singleton):</p>
<pre>container.bind&lt;Weapon&gt;("Weapon").to(Katana).inSingletonScope(); </pre>
<p>We can also configure complex runtime constraints, which will determine how dependencies are resolved. For example, we could have two implementations of <kbd>Weapon</kbd> that are injected in different circumstances:</p>
<pre>container.bind&lt;Weapon&gt;("Weapon").to(Katana) 
         .whenInjectedInto(Samurai); 
 
container.bind&lt;Weapon&gt;("Weapon").to(Shuriken) 
         .whenInjectedInto(Ninja); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Circular dependencies</h1>
                </header>
            
            <article>
                
<p>A circular dependency is an issue that we can encounter when working with multiple components and dependencies. Sometimes it is possible to reach a point in which one component (A) has a dependency on a second component (B), which depends on the first component (A). In the following diagram, each node is a component, and we can observe that the nodes <strong>circular1.ts</strong> and <strong>circular2.ts</strong> (in red) have a circular dependency. The nodes without dependencies are displayed in green, and those with dependencies but no issues are displayed in blue:</p>
<p class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-127 image-border" src="Images/2abf1609-4a3d-41de-8296-5c408b103420.png" style="width:30.00em;height:15.75em;" width="690" height="362"/></p>
<p>The circular dependencies don't necessarily need to involve just two components. We can encounter scenarios in which a component depends on another component, which depends on other components, and some of the components in the dependency tree end up pointing to one of their parent components in the tree. InversifyJS will throw a runtime exception if a circular dependency is detected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned the basics about managing third-party dependencies. We also learned the differences between internal and external modules, and each of the main kinds of modules in each of these categories.</p>
<p>We also learned how to work with dependencies in object-oriented programming. Finally, we learned how to implement dependency injection and how to work with IoC containers.</p>
<p>In the next chapter, we will learn about the TypeScript/JavaScript runtime.</p>


            </article>

            
        </section>
    </div>



  </body></html>