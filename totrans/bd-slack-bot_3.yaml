- en: Chapter 3. Adding Complexity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。增加复杂性
- en: 'With the first bot done, it''s time to learn how to extend our bot with the
    use of other **application program interfaces** (**APIs**). This means teaching
    our bot how to listen for keywords, respond to commands, and deal with errors
    (human or otherwise). In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个机器人完成之后，是时候学习如何使用其他 **应用程序程序接口**（**API**）来扩展我们的机器人了。这意味着教我们的机器人如何监听关键词、响应命令以及处理错误（无论是人为的还是其他原因）。在本章中，我们将涵盖以下内容：
- en: Responding to keywords
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应关键词
- en: Bot commands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人命令
- en: External API integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部 API 集成
- en: Error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Responding to keywords
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应关键词
- en: In the previous chapter, we used regular expressions to test the contents of
    the message against some predefined keywords. Once the keywords were confirmed,
    we could perform actions and return the results. This worked well; however, it
    can lead to a large `if else` block for more feature-rich bots. Instead, we will
    now look at refactoring the end result of the previous chapter into a more modular
    design. In this section, we will accomplish this by using ES6's new `class` syntax
    and Node's `export` method.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用正则表达式来测试消息内容与预定义关键词的匹配。一旦关键词被确认，我们就可以执行操作并返回结果。这工作得很好；然而，对于功能更丰富的机器人，它可能会导致一个很大的
    `if else` 块。相反，我们现在将查看将上一章的最终结果重构为一个更模块化的设计。在本节中，我们将通过使用 ES6 的新 `class` 语法和 Node
    的 `export` 方法来实现这一点。
- en: Using classes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类
- en: 'Start by creating a new JavaScript file and name it `bot.js`. Paste the following
    into `bot.js` and save the file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的 JavaScript 文件，并将其命名为 `bot.js`。将以下内容粘贴到 `bot.js` 中并保存文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at the code in depth, starting with the `class` structure. The
    **Mozilla** **Developer Network** (**MDN**) defines JavaScript classes as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入查看代码，从 `class` 结构开始。**Mozilla 开发者网络**（**MDN**）将 JavaScript 类定义为：
- en: '*JavaScript classes are introduced in ECMAScript 6 and are syntactical sugar
    over JavaScript''s existing prototype-based inheritance. The class syntax is not
    introducing a new object-oriented inheritance model to JavaScript. JavaScript
    classes provide a much simpler and clearer syntax to create objects and deal with
    inheritance.*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*JavaScript 类是在 ECMAScript 6 中引入的，并且是 JavaScript 现有基于原型的继承的语法糖。类语法并没有向 JavaScript
    引入一个新的面向对象的继承模型。JavaScript 类提供了一个更简单、更清晰的语法来创建对象和处理继承。*'
- en: Simply put, JavaScript classes are an *alternative* to the prototype-based class
    pattern, and in fact function the exact same way under the hood. The benefit to
    using classes is when you wish to extend or inherit from a particular class, or
    provide a clearer overview of what your class does.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，JavaScript 类是原型类模式的替代方案，实际上在底层以完全相同的方式工作。使用类的优点在于当你希望扩展或继承特定类，或者提供一个更清晰的概述说明你的类做什么时。
- en: 'In the code example, we use a class in order to easily extend it later if we
    wish to add more functionality. Unique to classes is the `constructor` method,
    which is a special method for creating and initializing an object created with
    a class. When a class is called with the new keyword, this constructor function
    is what gets executed first:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们使用类以便于稍后扩展，如果我们想添加更多功能。类独有的特性是 `constructor` 方法，这是一个用于创建和初始化由类创建的对象的特殊方法。当一个类用
    `new` 关键字调用时，这个构造函数函数首先被执行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking at our constructor, we see the familiar use of the Slack RTM client:
    the client is initialized and the `RTM_CONNECTION_OPENED` event is used to log
    the team and username upon connecting. We attach the `slack` variable to the `this`
    object as a property, making it accessible throughout our class. Similarly, we
    assign the bot''s name to a variable, for easy access when required.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的构造函数，我们看到熟悉的 Slack RTM 客户端的使用：客户端被初始化，并使用 `RTM_CONNECTION_OPENED` 事件在连接时记录团队和用户名。我们将
    `slack` 变量附加到 `this` 对象作为属性，使其在整个类中可访问。同样，我们将机器人的名称分配给一个变量，以便在需要时轻松访问。
- en: 'Finally, we export the bot class via the Node modules system:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过 Node 模块系统导出机器人类：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This instructs Node to return our class when this file is imported using the
    `require` method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Node 在使用 `require` 方法导入此文件时返回我们的类。
- en: 'Create a new file in the same folder as `bot.js` and name it `index.js`. Paste
    the following inside it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bot.js` 同一文件夹中创建一个新文件，并将其命名为 `index.js`。将以下内容粘贴到其中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After saving the file, run the following from the terminal to start the bot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，从终端运行以下命令以启动机器人：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can use the Slack token created in the previous chapter, or generate a new
    one for this bot.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上一章创建的 Slack 令牌，或者为这个机器人生成一个新的令牌。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's generally a good idea to not hardcode sensitive information such as tokens
    or API keys (such as the Slack token) in your code. Instead, use Node's `process.env`
    object to pass variables from the command line to your code. Especially, take
    care of storing API keys in a public source control repository such as GitHub.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，不要在代码中硬编码敏感信息，如令牌或 API 密钥（如 Slack 令牌）。相反，使用 Node 的 `process.env` 对象从命令行传递变量到你的代码。特别是，要小心将
    API 密钥存储在公共源代码控制库中，如 GitHub。
- en: Once you've confirmed that your bot connects successfully to your Slack team,
    let's work on making the `Bot` class more modular.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认你的机器人成功连接到你的 Slack 团队，让我们努力使 `Bot` 类更加模块化。
- en: Reactive bots
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式机器人
- en: 'All the functionality described in our bot examples so far have one thing in
    common: the bots react to stimuli provided by human users. A message containing
    a keyword is sent and the bot responds with an action. These types of bot can
    be called reactive bots; they respond to an input with an output. The majority
    of bots can be classified as reactive bots, as most bots require some input in
    order to complete an action. An active bot is the opposite of this; rather than
    responding to input, the active bot produces output without needing any human
    stimuli. We will cover active bots in [Chapter 6](ch06.html "Chapter 6. Webhooks
    and Slash Commands"), *Webhooks and Slack Commands*. For now, let''s look at how
    we can optimize our reactive bots.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止在机器人示例中描述的所有功能都有一个共同点：机器人对人类用户提供的刺激做出反应。发送包含关键词的消息，机器人以动作做出响应。这类机器人可以称为反应式机器人；它们对输入做出输出。大多数机器人都可以归类为反应式机器人，因为大多数机器人需要一些输入才能完成动作。主动机器人与这相反；主动机器人不是对输入做出反应，而是在不需要任何人类刺激的情况下产生输出。我们将在第
    6 章（[Chapter 6](ch06.html "Chapter 6. Webhooks and Slash Commands")）中介绍主动机器人，*Webhooks
    和 Slack 命令*。现在，让我们看看我们如何优化我们的反应式机器人。
- en: 'We already defined the essential mechanism of reactive bots: responding to
    stimuli. As this is a core concept of the reactive bot, it makes sense to have
    a mechanism in place to easily invoke the desired behavior.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了反应式机器人的基本机制：对刺激做出反应。由于这是反应式机器人的核心概念，因此有一个机制来轻松调用所需的行为是有意义的。
- en: 'To do this, let''s add some functionality to our `Bot` class in the form of
    a `respondsTo` function. In previous examples, we used the `if` statements to
    determine when a bot should respond to a message:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们给我们的 `Bot` 类添加一些功能，形式是一个 `respondsTo` 函数。在之前的例子中，我们使用了 `if` 语句来确定机器人何时应该对一条消息做出响应：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is nothing wrong with this approach. If we wish to code a bot that has
    multiple keywords, our `Bot` class can get very complex and cluttered very quickly.
    Instead, let''s abstract out this behavior to our `respondsTo` function. The function
    should take at least two arguments: the keywords we wish to listen for and a callback
    function that executes when the keywords are identified in a message.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法没有问题。如果我们希望编写一个具有多个关键词的机器人，我们的 `Bot` 类可能会变得非常复杂，并且很快就会变得杂乱无章。相反，让我们将这种行为抽象到我们的
    `respondsTo` 函数中。该函数应至少接受两个参数：我们希望监听的关键词和一个当关键词在消息中识别时执行的回调函数。
- en: 'In `bot.js`, add the following to the constructor:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bot.js` 中，向构造函数添加以下内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This snippet uses the new ES6 `Map` object, which is a simple key/value store,
    much like dictionaries in other languages. `Map` differs from `Object` in that
    `Map` does not have default keys (as `Object` has a prototype), which means that
    you can iterate over a `Map` without having to explicitly check if the `Map` contains
    a value or if its prototype does. For example, with `Maps`, you no longer have
    to use `Object.hasOwnProperty` when iterating.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段使用了新的 ES6 `Map` 对象，它是一个简单的键/值存储，类似于其他语言中的字典。`Map` 与 `Object` 的不同之处在于 `Map`
    没有默认键（因为 `Object` 有原型），这意味着你可以遍历 `Map` 而不必显式检查 `Map` 是否包含值或其原型。例如，使用 `Maps`，你不再需要在遍历时使用
    `Object.hasOwnProperty`。
- en: 'As we will see later, the `keywords Map` object uses regular expressions as
    a key and a callback function as the value. Insert the following code underneath
    the constructor function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，`keywords Map` 对象使用正则表达式作为键，回调函数作为值。在构造函数下面插入以下代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function takes three parameters: `keywords`, `callback`, and `start`.
    `keywords` is the word or phrase we wish to act on in the form of a regular expression.
    `callback` is a function that will be called if the keywords match the message,
    and `start` is an optional Boolean indicating whether we wish to search only at
    the beginning of the message string or not.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：`keywords`、`callback`和`start`。`keywords`是我们希望以正则表达式形式采取行动的单词或短语。`callback`是一个函数，如果关键词与消息匹配，则会调用它，而`start`是一个可选的布尔值，表示我们是否希望仅在消息字符串的开头搜索。
- en: 'Look back at our newly updated constructor and pay special attention to the
    following lines within our `message` event listener:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们新更新的构造函数，并特别注意我们`message`事件监听器中的以下行：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we loop through the keywords `Map` object, which has regular expressions
    as its keys. We test each regular expression against the received message and
    call our callback function with the message, the channel, and the user that sent
    the message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历关键词`Map`对象，其键是正则表达式。我们将每个正则表达式与接收到的消息进行测试，并使用消息、频道和发送消息的用户调用我们的回调函数。
- en: 'Finally, let''s add a `sendMessage` functionality to our bot class. This will
    act as a wrapper for Slack''s `sendMessage`. We don''t have to expose the entire
    Slack object anymore. Add the following function underneath our constructor:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给我们的机器人类添加一个`sendMessage`功能。这将作为Slack的`sendMessage`的包装器。我们不再需要暴露整个Slack对象。在我们的构造函数下面添加以下函数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Despite having `channel` as an argument name, our `send` function will also
    work for a DM (a private channel between two people), additionally providing a
    callback via the Slack API's `sendMessage` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的`send`函数的参数名为`channel`，但它也可以用于DM（两个人之间的私密频道），此外，它还通过Slack API的`sendMessage`函数提供了一个回调。
- en: 'Now that we have a function that can subscribe to messages and their contents,
    open up `index.js` and let''s add a simple "Hello World" implementation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以订阅消息及其内容的函数，打开`index.js`，让我们添加一个简单的“Hello World”实现：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the file, restart your node process, and test out your bot. Here''s what
    it should look like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，重新启动你的node进程，并测试你的机器人。它应该看起来像这样：
- en: '![Reactive bots](img/B05384_03_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![反应式机器人](img/B05384_03_01.jpg)'
- en: Testing our refactor
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的重构
- en: The bot responds when our message has the string "hello", but only when it appears
    at the beginning of the message due to the `true` value we passed in after our
    callback.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的消息包含字符串"hello"时，机器人会做出响应，但只有在它出现在消息开头，由于我们在回调后传递的`true`值，才会如此。
- en: We have now refactored our bot's code to abstract the Slack event system away
    and make our code cleaner in the process. Let's do something a little more impressive
    with our new system and implement a simple game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经重构了机器人的代码，将Slack事件系统抽象出来，并在过程中使我们的代码更简洁。让我们用我们的新系统做一些更令人印象深刻的事情，并实现一个简单的游戏。
- en: Bot commands
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人命令
- en: So far, our bots have responded to keywords in messages to say hello or tell
    us how long they've been running. These keywords are useful for simple tasks,
    but for more complex actions, we need to give the bot some parameters to work
    with. A keyword followed by parameters or arguments can be referred to as a bot
    command. Similar to the command line, we can issue as many arguments as we want
    to get the most out of our bot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的机器人已经对消息中的关键词做出了响应，说“你好”或告诉我们它们已经运行了多久。这些关键词对于简单任务很有用，但对于更复杂的操作，我们需要给机器人一些参数来处理。一个跟在参数或参数后面的关键词可以称为机器人命令。类似于命令行，我们可以发出尽可能多的参数来充分利用我们的机器人。
- en: 'Let''s test this by giving our bot a new function: a game of chance where the
    issuer of the `roll` command plays a game of who can roll the highest number.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过给我们的机器人一个新的函数来测试这个：一个机会游戏，`roll`命令的发布者玩一个掷骰子比谁掷出的数字高的游戏。
- en: 'Add the following code to `index.js`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`index.js`中：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The command is very simple: a user sends the keyword `roll` followed by the
    name of the user they wish to challenge. This is shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令非常简单：用户发送关键词`roll`，后面跟着他们想要挑战的用户名。这在上面的屏幕截图中显示：
- en: '![Bot commands](img/B05384_03_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![机器人命令](img/B05384_03_02.jpg)'
- en: A straightforward implementation of the bot's roll command
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人滚动命令的直接实现
- en: It works well, but what happens if we omit any arguments to our `roll` command?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作得很好，但如果我们省略了`roll`命令的任何参数会发生什么？
- en: '![Bot commands](img/B05384_03_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![机器人命令](img/B05384_03_03.jpg)'
- en: '`undefined` wins the game, which isn''t expected behavior'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`赢得了游戏，这不是预期的行为'
- en: 'No arguments are provided; therefore, the value at index 0 of our `args` array
    is `undefined`. Clearly, our bot lacks some basic functionality: invalid argument
    error handling.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供参数；因此，我们的`args`数组中索引0的值是`undefined`。显然，我们的bot缺少一些基本功能：无效参数错误处理。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With bot commands, user input must always be sanitized and checked for errors,
    lest the bot perform some unwanted actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用bot命令时，用户输入必须始终被清理并检查错误，否则bot可能会执行一些不希望的操作。
- en: Sanitizing inputs
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理输入
- en: 'Add this block underneath our `getArgs` method call to stop empty rolls from
    happening:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`getArgs`方法调用下添加此块以防止发生空投掷：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s the result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '![Sanitizing inputs](img/B05384_03_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![清理输入](img/B05384_03_04.jpg)'
- en: Awesomebot providing some necessary sanitizing
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Awesomebot提供了一些必要的清理
- en: That's one use case down, but what if someone tries to challenge someone who's
    not in the channel? At the moment, the bot will roll against whatever you put
    as the first argument, be it a member of the channel or a complete fabrication.
    This is an example of where we want to further sanitize and restrict the user
    input to useful data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用例已经完成，但如果有人试图挑战不在通道中的人怎么办？目前，bot将针对你作为第一个参数放入的任何内容进行投掷，无论是通道成员还是完全的虚构。这是我们想要进一步清理和限制用户输入以使其有用的一个例子。
- en: To fix this, let's make sure that only members of the channel from where the
    `roll` command originated can be targeted.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们确保只有来自`roll`命令发起的通道的成员可以被针对。
- en: 'First, let''s add the following method to our `Bot` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的`Bot`类添加以下方法：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function simply checks to see whether the `members` property of `channel`
    exists, and returns a list of active non-bot users by name. In `index.js`, replace
    your `roll` command block with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能简单地检查`channel`的`members`属性是否存在，并返回按名称排序的活跃非bot用户列表。在`index.js`中，将你的`roll`命令块替换为以下代码：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our biggest changes here are that the bot will now check to make sure the command
    given is a valid one. It will ensure that by checking the following (listed in
    order):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里最大的变化是，bot现在将检查以确保给出的命令是有效的。它将通过检查以下内容（按顺序列出）来确保：
- en: There are members available in the channel.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通道中有可用的成员。
- en: An argument was provided after the command.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令后提供了参数。
- en: Whether the argument was valid, by making sure the name provided is in the members
    list of the channel or that the name is not that of a bot.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论参数是否有效，通过确保提供的名称在通道的成员列表中，或者该名称不是bot的名称。
- en: 'The important lesson to take away from this exercise is to minimize interruptions
    by ensuring that all use cases are handled correctly. Sufficient testing is required
    to be certain that you handled all use cases. For instance, in our `roll` command
    example, we missed an important case: users can use the `roll` command against
    themselves:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个练习中要吸取的重要教训是通过确保所有用例都得到正确处理来最小化中断。需要进行充分的测试以确保你处理了所有用例。例如，在我们的`roll`命令示例中，我们错过了一个重要的用例：用户可以使用`roll`命令针对自己：
- en: '![Sanitizing inputs](img/B05384_03_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![清理输入](img/B05384_03_05.jpg)'
- en: Rolling against yourself probably isn't the most useful of functions
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与自己投掷可能不是最有用的功能
- en: 'To fix this issue, we need to make a simple addition to our command. Add the
    following code in our previous sanitizing checks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要对我们的命令进行简单的添加。在之前的清理检查中添加以下代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When developing bots, every precaution should be taken to ensure that bot inputs
    are sanitized and that error responses give information about the error. This
    is especially true when working with external APIs, where incorrect input could
    lead to wildly inaccurate results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发bot时，应采取一切预防措施以确保bot输入被清理，并且错误响应提供有关错误的信息。这在与外部API一起工作时尤其如此，错误的输入可能导致极其不准确的结果。
- en: External API integration
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部API集成
- en: Eternal APIs are third-party services hosted outside of our bot structure. These
    come in many varying types and are used to solve many different problems, but
    their use in tandem with bots follows the same data flow structure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 永恒API是托管在我们bot结构之外的第三方服务。它们有多种类型，用于解决许多不同的问题，但与bot一起使用时遵循相同的数据流结构。
- en: '![External API integration](img/B05384_03_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![外部API集成](img/B05384_03_06.jpg)'
- en: The API call data flow structure between Slack, bot, and API service
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Slack、bot和API服务之间的API调用数据流结构
- en: We will build an example bot with API integration using a common and free-to-use
    API, namely that of the Wikimedia foundation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个常见且免费使用的API构建一个具有API集成的示例机器人，即维基媒体基金会的API。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be warned that while many APIs are free, there are many that charge when a certain
    amount of requests are made. Always check whether there is a fee before incorporating
    them into your bots.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多API是免费的，但也有很多API在达到一定数量的请求时会收费。在将它们集成到你的机器人中之前，请务必检查是否有费用。
- en: The Wikimedia foundation API is an example of a **representational state transfer**
    (**REST**) service, which communicates using standard **Hypertext Transfer Protocol**
    (**HTTP**) protocols such as GET or POST. Many RESTful services require you to
    transmit a token along with your request, ensuring security and for monetizing
    the service by tracking the amount of requests made. The Wikimedia API is a free
    RESTful service, meaning that we do not require a token to make use of it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 维基媒体基金会API是一个**表示状态转移**（**REST**）服务的例子，它使用标准的**超文本传输协议**（**HTTP**）协议，如GET或POST进行通信。许多RESTful服务要求你在请求中传输一个令牌，以确保安全，并通过跟踪请求量来通过货币化服务。维基媒体API是一个免费的RESTful服务，这意味着我们不需要令牌就可以使用它。
- en: Our new bot, `wikibot`, will allow the user to search for a Wikipedia page and
    return the page's summary if found, or an error message if it does not exist.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新机器人 `wikibot` 将允许用户搜索维基百科页面，如果找到页面则返回页面摘要，如果没有找到则返回错误信息。
- en: To start, you should follow the steps in [Chapter 2](ch02.html "Chapter 2. Your
    First Bot"), *Your First Bot*, to create a new Slack bot integration via the Slack
    web service and start a new project. This new project will reuse the `Bot` class
    created in this chapter, whereas our new `index.js` entry point will be a new,
    empty file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你应该遵循[第2章](ch02.html "第2章。你的第一个机器人")中“你的第一个机器人”的步骤，通过Slack网络服务创建一个新的Slack机器人集成并开始一个新的项目。这个新项目将重用本章中创建的`Bot`类，而我们的新`index.js`入口点将是一个新的空文件。
- en: 'We will start with the annotated and explained `index.js` code. At the conclusion
    of the chapter the full code will be made available for easier accessibility.
    Here''s the code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从注释和解释的`index.js`代码开始。在章节结束时，将提供完整的代码，以便更容易访问。以下是代码：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we import our own `Bot` class alongside a new library called `superagent`,
    which is used for making asynchronous JavaScript and XML (AJAX) calls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入我们自己的`Bot`类以及一个名为`superagent`的新库，该库用于进行异步JavaScript和XML（AJAX）调用。
- en: 'Before running this code, be sure to install `superagent` using NPM:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此代码之前，请确保使用NPM安装`superagent`：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`superagent` is installed with the `–save` flag, as the program cannot function
    without it.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `–save` 标志安装了 `superagent`，因为没有它程序无法运行。
- en: 'Let''s get back to our code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的代码：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These constants are the RESTful API **Uniform Resource Link** (**URL**) and
    the base Wikipedia page URL, respectively. You can test out the former by copying
    the URL, pasting it into the address field in a browser, and appending a topic
    at the end. You can check this for the following URL: [https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro=&explaintext=&titles=duck](https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro=&explaintext=&titles=duck).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量分别是RESTful API的**统一资源链接**（**URL**）和基本维基百科页面URL。你可以通过复制URL，将其粘贴到浏览器的地址字段中，并在末尾添加一个主题来测试前者。你可以检查以下URL：[https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro=&explaintext=&titles=duck](https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro=&explaintext=&titles=duck)。
- en: You should then see data returned in the **JavaScript object notation** (**JSON**)
    format, giving you an overview of the topic requested and the pages returned.
    The data and type of data returned is determined by the parameters in the query
    string of the URL. In the preceding URL, we query for the `extracts` property
    of a page, specifically the intro (`exintro`) and explanation (`explaintext`)
    for the page with the title `duck` in the JSON format.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以**JavaScript对象表示法**（**JSON**）格式返回的数据，这为你提供了请求的主题和返回的页面的概述。返回的数据和数据类型由URL查询字符串中的参数确定。在先前的URL中，我们查询了页面的`extracts`属性，特别是标题为`duck`的页面的简介（`exintro`）和解释（`explaintext`），以JSON格式返回。
- en: 'The latter constant is used later to return the URL for the Wikipedia page
    requested:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 后者常量用于稍后返回请求的维基百科页面的URL：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As before, we initiate a new instance of `Bot` with our options and Slack token.
    You can reuse the first token created in [Chapter 2](ch02.html "Chapter 2. Your
    First Bot"), *Your First Bot*. However, it is recommended to generate a new one
    instead. The code is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用我们的选项和Slack令牌启动一个新的`Bot`实例。你可以重用[第2章](ch02.html "第2章。你的第一个机器人")中创建的第一个令牌，*你的第一个机器人*。然而，建议生成一个新的令牌。代码如下：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function is a wrapper for the request to the Wikimedia API, in which we
    format the request by replacing the spaces in the search term with Unicode and
    make the GET request via the `superagent` library. The code is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是对访问维基媒体API的请求的包装，我们通过替换搜索词中的空格为Unicode格式来格式化请求，并通过`superagent`库进行GET请求。代码如下：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As this is an asynchronous request, we provide a callback function to be called
    when the `GET` request has returned the data we need. Before returning we make
    sure to parse the data into a JavaScript object form for easy access. The code
    is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个异步请求，我们提供了一个回调函数，当`GET`请求返回所需数据时将被调用。在返回之前，我们确保将数据解析成JavaScript对象形式以便于访问。代码如下：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![External API integration](img/B05384_03_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![外部API集成](img/B05384_03_07.jpg)'
- en: Wikibot explaining how it can be used
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Wikibot解释如何使用它
- en: 'The first command we implement is a simple `help` command; its only function
    is to explain how to use the bot''s Wikipedia functionality:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的第一条命令是一个简单的`help`命令；它的唯一功能是解释如何使用机器人的维基百科功能：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set up our new bot command with the keyword `wiki` and make sure to return
    if the command sender is a bot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键词`wiki`设置我们的新机器人命令，并确保如果命令发送者是机器人则返回：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will extract the search query of the command. For instance if the command
    is `wiki` `fizz buzz`, the output of `args` will be a string containing "fizz
    buzz":'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取命令的搜索查询。例如，如果命令是`wiki` `fizz buzz`，则`args`的输出将是一个包含"fizz buzz"的字符串：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we call our `getWikiSummary` function, with the arguments issued with
    the bot command and provide the anonymous function callback. If an error has occurred,
    immediately send an error message and log the error in the console. The command
    is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用我们的`getWikiSummary`函数，使用机器人命令提供的参数，并提供匿名函数回调。如果发生错误，立即发送错误消息并在控制台记录错误。命令如下：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The data object returned by the RESTful API call consists of a nested object
    named `query`, which in turn has a nested object called `pages`. Inside the `pages`
    object, there are more objects that use Wikipedia''s internal page ID as a key,
    which is a series of numbers in a string format. Let''s take a look at an example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过RESTful API调用返回的数据对象包含一个名为`query`的嵌套对象，它又包含一个名为`pages`的嵌套对象。在`pages`对象内部，有更多使用维基百科内部页面ID作为键的对象，这些键是一系列以字符串格式表示的数字。让我们看一个例子：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Object.keys` is a useful trick to retrieve data from an object without knowing
    the property''s name. We use it here as we don''t know the key ID for the page
    that we want, but we know we want the first value. `Object.keys` will return an
    array of key names for the `result.query.pages` object. We then select the value
    at index 0, as we''re only interested in the first result. The code is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys`是一个有用的技巧，可以在不知道属性名称的情况下从对象中检索数据。我们在这里使用它，因为我们不知道我们想要的页面的键ID，但我们知道我们想要第一个值。`Object.keys`将返回`result.query.pages`对象的键名称数组。然后我们选择索引0处的值，因为我们只对第一个结果感兴趣。代码如下：'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A Wikipedia page ID of -1 indicates that the article doesn''t exist at all.
    Instead of trying to parse data that doesn''t exist, we inform the user of the
    problem and return. The code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科页面ID为-1表示该文章根本不存在。我们不会尝试解析不存在的数据，而是通知用户问题并返回。代码如下：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the summary text contains the phrase `may refer to`, then we can conclude
    that the search term provided could lead to multiple Wikipedia entries. Since
    we can''t guess at what the user intended, we simply ask them to be more specific
    and return. The code is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果摘要文本包含短语`可能指`，那么我们可以得出结论，提供的搜索词可能导致多个维基百科条目。由于我们无法猜测用户的意图，我们简单地要求他们提供更具体的信息并返回。代码如下：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Unfortunately, it is possible that an API request returns a summary that is
    empty. This is an issue on the Wikimedia API''s end where a term returns a page,
    but the summary text is missing. In this case, we inform the user of the problem
    in the `else` conditional block of this `if` statement. The code is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有可能 API 请求返回一个空的摘要。这是 Wikimedia API 端的问题，其中某个术语返回一个页面，但摘要文本缺失。在这种情况下，我们在
    `if` 语句的 `else` 条件块中通知用户问题。代码如下：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The summary might stretch over several paragraphs, so for ease of use we convert
    the text block into an array of paragraphs by using the new line ASCII operator
    `\n` as our split criteria. The code is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要可能跨越几个段落，为了便于使用，我们使用新的换行 ASCII 操作符 `\n` 作为分割标准，将文本块转换为段落数组。代码如下：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Like regular users, bots can use Slack''s formatting options when sending messages.
    In this instance, we prepend the `>` operator in front of our paragraph to indicate
    a quotation block. The code is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通用户一样，机器人在发送消息时可以使用 Slack 的格式化选项。在这个例子中，我们在段落前加上 `>` 操作符，以指示引用块。代码如下：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As before, we pass the `true` Boolean to our `respondsTo` method of the `Bot`
    class to indicate that we want our keyword `wiki` to only trigger a response if
    it is placed at the beginning of a message.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将 `true` 布尔值传递给 `Bot` 类的 `respondsTo` 方法，以指示我们希望我们的关键字 `wiki` 仅在消息开头时触发响应。
- en: 'Once you''ve entered all the code into `index.js`, run the program using Node
    and test it in your Slack client:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将所有代码输入到 `index.js` 中，使用 Node 运行程序，并在你的 Slack 客户端中测试它：
- en: '![External API integration](img/B05384_03_08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![外部 API 集成](img/B05384_03_08.jpg)'
- en: Wikibot is up and running
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Wikibot 正在运行
- en: 'This is a basic example of how to incorporate external API calls into your
    bot. Before we move on to the next section, we should consider the ramifications
    of complex API requests. If an API request takes a sizeable amount of time (for
    example, a service needs to perform complex calculations), it would be useful
    for the user to see an indication that the bot is working on the command. To accomplish
    this, we can show a **typing indicator** while the bot waits for a response. Typing
    indicators are shown when a human starts to type a message before hitting send.
    Add the following method to the `Bot` class in `bot.js`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何将外部 API 调用集成到你的机器人中的基本示例。在我们进入下一节之前，我们应该考虑复杂 API 请求的后果。如果一个 API 请求需要花费相当长的时间（例如，一个服务需要执行复杂的计算），那么对于用户来说，看到机器人正在处理命令的指示将是有用的。为了实现这一点，我们可以在机器人等待响应时显示一个**输入指示器**。当一个人在发送消息之前开始输入时，会显示输入指示器。将以下方法添加到
    `bot.js` 中的 `Bot` 类：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To test our indicator, add the following to `index.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的指示器，将以下内容添加到 `index.js`：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, send the message `test` in your Slack channel and watch the indicator
    appear:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 Slack 频道中发送消息 `test` 并观察指示器出现：
- en: '![External API integration](img/B05384_03_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![外部 API 集成](img/B05384_03_09.jpg)'
- en: Wikibot is busy typing
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Wikibot 正在输入
- en: '1000 milliseconds later, we get the following result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 1000 毫秒后，我们得到以下结果：
- en: '![External API integration](img/B05384_03_10.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![外部 API 集成](img/B05384_03_10.jpg)'
- en: Bot is done with the action and the typing indicator has been removed
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人完成了操作，输入指示器已移除
- en: After the typing indicator is dispatched, it will automatically disappear once
    a message has been sent to the channel by the bot.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送指示器后，一旦机器人向频道发送了一条消息，指示器将自动消失。
- en: 'To use the typing indicator in our example bot, insert the following line above
    the `getWikiSummary` method call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例机器人中使用输入指示器，在 `getWikiSummary` 方法调用上方插入以下行：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Keep in mind that since the Wikimedia API call resolves very quickly, it's unlikely
    that you'll see the typing indicator for longer than a few milliseconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于 Wikimedia API 调用非常快，你不太可能看到输入指示器超过几毫秒。
- en: Error handling
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Continuing on from the last topic, a good way of making your bot appear more
    natural is for it to provide clear instructions on how to use it. Providing the
    wrong input for a command should *never* cause the bot to crash.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个主题继续，让你的机器人看起来更自然的一个好方法是让它提供如何使用它的明确说明。对于命令的输入错误，机器人**决不应该**崩溃。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bots should never crash due to user input. Either an error message should be
    sent or the request should silently fail.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人决不应该因为用户输入而崩溃。要么发送错误消息，要么请求静默失败。
- en: 'You can eliminate 99 percent of all bugs in your bot commands by doing valid
    type and content checking against the user''s input. Observe the following checklist
    when programming a new command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对用户的输入进行有效的类型和内容检查，你可以消除你机器人命令中 99% 的所有错误。在编写新命令时，请观察以下清单：
- en: If arguments are required, are any of the arguments undefined?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要参数，是否有任何参数未定义？
- en: Are the arguments of the type the bot is expecting? For example, are strings
    provided when a number is expected?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的类型是否符合机器人期望的类型？例如，当期望数字时是否提供了字符串？
- en: If targeting a member of the channel, does that member exist?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标是频道成员，该成员是否存在？
- en: Was the command sent in a DM? If so should the command still be executed?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令是否在 DM 中发送？如果是，那么命令是否应该被执行？
- en: Does the command pass a "sanity" check? For example, does the data or action
    requested make sense?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令是否通过了一个“合理性”检查？例如，请求的数据或操作是否有意义？
- en: 'As an example of the preceding checklist, let''s review the checks we made
    with the `roll` command earlier in this chapter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面清单的一个例子，让我们回顾一下本章前面用 `roll` 命令所做的检查：
- en: Are there non-bot members in the channel to interact with?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有非机器人成员在频道中可以与之交互？
- en: Was an argument supplied?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否提供了论点？
- en: Was the supplied argument valid?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的参数是否有效？
- en: Is the specified opponent in the channel the command was issued?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出命令的指定对手是否在频道中？
- en: Each point is a hurdle that the command's input had to overcome in order to
    return the desired result. If any of these questions is answered in the negative,
    then an error message is sent and the command process terminated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每一点都是一个障碍，命令的输入必须克服这些障碍才能返回所需的结果。如果这些问题的任何一个回答是否定的，那么将发送错误消息并终止命令过程。
- en: These checks might appear lengthy and superfluous, but they are absolutely necessary
    to provide a natural experience with the bot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查可能看起来很冗长且多余，但它们绝对有必要为机器人提供自然的体验。
- en: As a final note, be aware that despite your best efforts, users have an uncanny
    ability to cause crashes, intentionally or otherwise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，请注意，尽管你尽了最大努力，但用户仍然有一种不可思议的能力，无论是故意还是无意地导致崩溃。
- en: The more complex your bot becomes, the more likely it is that loopholes and
    edge cases will appear. Testing your bot thoroughly will get you most of the way,
    but always make sure that you are catching and logging errors on the programmatic
    side. A good debug log will save you many hours of frustration trying to find
    a difficult-to-squash bug.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人越复杂，出现漏洞和边缘情况的可能性就越大。彻底测试你的机器人将让你走得更远，但始终确保你在程序方面捕捉并记录错误。一个好的调试日志将节省你许多试图找到难以解决的错误所花费的时间。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to abstract away the core Slack API methods into
    a reusable module by using ES6's new class structures. The difference between
    a reactive and active bot was outlined as well as the distinction between keywords
    and bot commands. By applying the basic knowledge of external APIs outlined in
    this chapter, you should be able to create a bot that interfaces with any third-party
    application that provides RESTful APIs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过使用 ES6 的新类结构将核心 Slack API 方法抽象成可重用的模块。我们概述了反应性机器人与主动机器人的区别，以及关键词与机器人命令的区别。通过应用本章概述的外部
    API 的基本知识，你应该能够创建一个可以与任何提供 RESTful API 的第三方应用程序交互的机器人。
- en: In the next chapter, we will learn about the Redis data storage service and
    how to write a bot that interfaces with a persistent data source.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于 Redis 数据存储服务以及如何编写与持久数据源交互的机器人。
