- en: Connecting Your Alexa Skills to External APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will expand upon the basics we learned from the previous
    chapter, to improve the functionality and user experience of Alexa. We'll increase
    the functionality by learning to use external APIs to interact with services provided
    by other people. Then, we'll increase the user experience by giving our chatbot
    some memory of the existing conversation and also using a **speech synthesis markup
    language** (**SSML**) to control the way that Alexa talks to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To enable us to learn this, we're going to build a weather skill for Alexa.
    You will be able to ask for the current or five-day forecast for 200,000 cities
    across the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and interacting with an external API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing session memory using session attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SSML to control the way that Alexa talks with the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating a Lambda function for our skill, and we
    will deploy it using the local development setup that we discussed in [Chapter
    2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with AWS and
    Amazon CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using the **Open Weather Map API** to get weather data based on the
    user requests. We will go through the process of creating an account and getting
    an API key.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Postman to test the requests that we are going to make to the Open
    Weather Map API. It is a cross-platform app that can be installed at [getpostman.com](https://www.getpostman.com/).
  prefs: []
  type: TYPE_NORMAL
- en: All of the code required for this chapter can be found at [http://bit.ly/chatbot-ch4](http://bit.ly/chatbot-ch4).
  prefs: []
  type: TYPE_NORMAL
- en: External APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) is an interface that you
    can send requests to, and it will give you a response. These are used to let other
    people control parts of your software, whether that is getting information from
    the API database, changing a user's settings, or getting the API to send a text.
  prefs: []
  type: TYPE_NORMAL
- en: They are a very powerful tool for developers, giving you access to more data
    and services than you could ever gather or build on your own.
  prefs: []
  type: TYPE_NORMAL
- en: External APIs don't have to be built by someone else. If you have a system that
    you want to access from the chatbot, you can add API access, or you might already
    have an API built for it. Using an API to separate sections of your code or company
    can be a good way to allow and improve modularization.
  prefs: []
  type: TYPE_NORMAL
- en: Open Weather Map API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Open Weather Map API is a very powerful API that lets you get the current
    weather as well as the weather forecast for 200,000 cities around the world. The
    best part is that there is a free tier that allows you to make 60 requests a minute
    about current weather and five-day forecasts. This allows us to develop an Alexa
    Skill that uses real-world data without subscribing to a monthly fee.
  prefs: []
  type: TYPE_NORMAL
- en: To access this API, we need to create an account to get an API key. Go to [OpenWeatherMap.org](https://home.openweathermap.org)
    and go to Sign Up in the upper-right corner of the page. Enter your details, read
    the terms and conditions, and sign up. You'll then be prompted to give the reason
    that you are using the API. There's no *Alexa* option, so you can choose Mobile
    apps development, as that is the closest to our real usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''re logged in, you can access your API key. This is used on any
    request you make to the API so that it can check that you have the right permissions
    for making the request. Navigate to API keys, and find the Default key for your
    account. We''ll be using that key throughout this project to make sure that you
    can find it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d8aea21-53b3-47ae-be0c-29d82ddbaf9d.png)'
  prefs: []
  type: TYPE_IMG
- en: OpenWeatherMap API key
  prefs: []
  type: TYPE_NORMAL
- en: With our API key, we can now look at the requests we can make. On the API page,
    there is a list of different APIs, but the ones that we have access to are Current
    weather data and 5 day / 3-hour forecast. Underneath each of these sections is
    a button to go to the API doc, and we're going to look at the API docs for Current
    weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to request the data on the Current weather data API: Call
    current weather data for one location, Call current weather data for several cities,
    and Bulk downloading. We''re only going to be getting data for one location at
    a time.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the Call current weather data for one location section, there are also
    a few different ways to select the area. You can provide the city name, city ID,
    geographic coordinates, or the ZIP code. The user is going to be telling us a
    city name, so it makes the most sense to use that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to get the current weather data for a city by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we call either of these endpoints, we will get a response in a predefined
    format. It is good to know how the data will be returned so we can deal with it
    properly inside our skill. The Weather parameters in API respond section of the
    web page gives us examples of responses, as well as a list of the features, with
    a short description of each. This is an example of the response that can come
    back from a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating our weather skill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating the weather skill is going to follow the same steps as the previous
    skills that we have created. This is a great process to follow whenever you are
    creating any new Alexa skill. To recap the process, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a conversational flow from perfect conversations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the skill on Alexa Skills Kit, including all intents, slots, and utterances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the Lambda to handle the requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the skill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the skill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversation flow design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the conversations that the users will have with this skill are quite
    simple. There are only really two things that the user can ask about: the location
    and the data for the forecast. Here is an example of a perfect conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02458ac1-95bd-4e64-9bed-a0b0c17cd516.png)'
  prefs: []
  type: TYPE_IMG
- en: Weather conversation
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about this conversation is that both the questions are
    similar. What is the weather in {location} {date}?
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can handle them both with a single intent. That intent needs
    to check whether they have given a location and a date and then use those two
    things to call the API. The flow diagram for this intent will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23161391-e49a-459b-ba12-5883e114a3cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Weather flow diagram
  prefs: []
  type: TYPE_NORMAL
- en: The difference between this flow and the flows that we've worked with before
    is that the user can go through one intent multiple times in one conversation,
    usually with different slot values. We could build separate intents for `current
    weather`, `weather change Date`, and `weather change location`, but they would
    all do similar things.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the skill on Alexa Skills Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to get started using the Alexa Skills Kit developer console. Click the
    Create Skill button, name your skill, and select Custom as the skill type.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we do whenever we create a new skill adds an invocation
    phrase.
  prefs: []
  type: TYPE_NORMAL
- en: Doing it as soon as you create the skill means that you don't forget to fill
    it in later. You can change the phrase at any point before you publish your skill.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create our `getWeather` intent. Add a new custom intent called
    `getWeather` and then we can start filling the intent out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users are going to trigger this intent with lots of different utterances. We''re
    also going to learn how to populate slots from the user utterance. Start by adding
    our two slots to the intent, `location` and `date`. The slot type for location
    can be AMAZON.US_CITY, and data can be AMAZON.DATE. You can select `GB_CITY`,
    `AT_CITY`, `DE_CITY`, or `EUROPE_CITY` if you want a better city recognition for
    your area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a23cab3-658d-41b0-8641-f950cd9bf8a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Intent slots
  prefs: []
  type: TYPE_NORMAL
- en: With the slots created, we can create our utterances. These utterances will
    be different than our normal utterances, as we need to fill the slots at the same
    time. This can be demonstrated with an utterance such as `what is the weather
    like in London`. The slot that we are trying to fill is a `location` with the
    value of `London`. To capture this slot, we can use a curly brace method where
    the intent becomes `what is the weather like in {location}`. This means that whatever
    value is typed instead of `{location}` will be captured and stored in the location
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done for other similar utterances. `What about tomorrow` becomes
    `what about {date}` and an utterance of `what is the weather like tomorrow in
    New York` becomes `what is the weather like {date} in {location}`. This capture
    of slots from the initial utterance is very powerful, as it means that we don''t
    have to ask the user for the value of each slot. Asking a series of questions
    like that results in a very unnatural conversation. Here are a few examples of
    sample utterances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fcc1505-d45c-44fb-adf4-9c19d671c8a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Get weather utterances
  prefs: []
  type: TYPE_NORMAL
- en: With the intent slots and utterances completed, we can get the skill ID from
    the Endpoint section before moving on to creating the Lambda to handle the requests.
  prefs: []
  type: TYPE_NORMAL
- en: Building Lambda to handle the requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create our Lambda, we can create a new folder within our `Lambdas` folder
    and call it `weatherGods`. Inside that folder, we can create an `index.js` file
    in which we will create our handler. To start, copy the text from the `boilerplate
    Lambda` folder in this chapter's code repository. We also need to run `npm init`
    so that we can install `npm` packages later on.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting on the main code, we need to modify our `LaunchRequestHandler`.
    This can be done by changing the `speechText` variable. For this skill, we can
    enter a response message of `"You may ask the weather gods about the weather in
    your city or for a weather forecast"`. This prompts the user to say a phrase that
    will trigger the `getWeather` intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start on the logic to get the user the weather information that
    they want. We need to create another handler that will deal with the `getWeather`
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can get the weather, we need to check that we have values for the
    location and the date. If we don''t have values for either of these, we need to
    get them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will probably notice that the missing location and date are handled differently.
    If the location is missing, then we ask the user for the location. If we are missing
    the date, we set the date to `Date.now()`. This is a design choice because it
    feels more natural to say `"What's the weather like in LA?"` than `"What's the
    weather like in LA now?"`. It is often the smaller details such as this that make
    talking with a good chatbot so much better.
  prefs: []
  type: TYPE_NORMAL
- en: We know that we have a location and a date so can proceed with the rest of the
    logic. With the location and the date, we can make the request to the Open Weather
    Maps API.
  prefs: []
  type: TYPE_NORMAL
- en: Making an API request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a request to an API consists of using a `GET`, `PUT`, `POST`, or `DELETE`
    method on a URL with some optional data. A well-designed API will be designed
    to have most of the information about the request in the URL. This means that
    we will be changing the URL based on the user choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Open Weather Maps API, the URLs that we need to send our requests to
    are structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For current weather: [https://api.openweathermap.org/data/2.5/weather?q={$city},us](https://api.openweathermap.org/data/2.5/weather?q=%7B%24city%7D,us)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a five-day forecast: [https://api.openweathermap.org/data/2.5/forecast?q=${city},us](https://api.openweathermap.org/data/2.5/forecast?q=%24%7Bcity%7D,us)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, the API needs us to define a country code. In this example, we
    should use *US*, as we selected US_CITY as our slot type. If you chose a different
    slot type, make sure to enter the `ISO 3166` code for your country.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a request to these URLs, we need to use a request library. There is
    an `HTTP` standard library built into a node that can make requests, but there
    are some other libraries that make our life much simpler. The one we will be using
    is called `axios`. There are two main reasons to use `axios` over the standard
    `HTTP` library:'
  prefs: []
  type: TYPE_NORMAL
- en: It is more user-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is *promise-based*, so you control the flow of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make a request using `axios`, we first need to install it and require it
    in. Navigate to your `weatherGods` Lambda folder and run `npm install --save axios`
    and add `const axios = require('axios');` to the top of the `index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a request can now be as simple as adding this line of code wherever
    we want to make the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For our requests, we will also need to pass in our API key. For the Open Weather
    Maps API, we need to add a query string of `appid=${process.env.API_KEY}` at the
    end of our URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store our API key in environment variables so that it never gets committed
    to source control (GIT), where it could be accessed by someone else. They can
    be accessed and changed in your Lambda console. To store an environment variable,
    scroll down in your Lambda console to *Environment variables* and enter the key
    and value you want to store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff9c3ffe-1b75-42fc-aa84-ae9d4a18722f.png)'
  prefs: []
  type: TYPE_IMG
- en: Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: 'While we make the request, we have no access to the result. There are a few
    different ways to get the result from a Promise, but we''re going to use `async`
    and `await` to keep our code as clean and readable as possible. To get `async`
    and `await` working, we need to modify our handler function slightly. Where we
    have declared the input values, we need to declare that this function is an `async`
    function. We also need to check that our Lambda is running node 8.10 so it supports
    `async` functions. If you are using the build script that we created in [Chapter
    2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with AWS and
    Amazon CLI*, then all of our functions are automatically set up using node 8.10,
    but you can always check by looking at the runtime on your Lambda Console. We
    make our handle method asynchronous by adding `async` before the method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the results from a promise using `async` and `await`, we need to put
    an `await` before the promise. This means that the rest of the code won''t start
    running until the promise has returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've had a quick introduction to `axios` and `async`/`await`, we can
    start writing the requests that we are going to make. Because we have different
    URLs for *current weather* and *weather forecast*, we need to check whether the
    date selected is the current date or whether they are looking for a forecast.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing dates is a surprisingly complicated task, so we are going to use an
    `npm` package to make it much easier. This package is called `moment`, and it
    is a package that is made to work with dates. Install it to our Lambda using `npm
    install --save moment` and then require it into Lambda by adding `const moment
    = require('moment'); moment().format();` to the top of our `index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `handler`, we can add the following check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add in the request that we are going to make to `openWeatherMaps`.
    The response that we get from `axios` is all of the information about the request.
    Because we only care about the data that is returned, we can destructure the response
    and rename the data. Destructuring allows us to select a key from an object and
    name it as something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this destructuring to rename the current weather data and forecast
    data differently, to avoid future confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the responses from these requests, we need to extract the information that
    we want to send to the user. For this, we need to know the data that we're going
    to receive and the data we want at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'One great way to check the exact data you will receive is to make test requests
    to the API. A great tool for making API requests is [Postman](https://www.getpostman.com/),
    as it allows you to make `GET`, `PUT`, `POST`, and `DELETE` requests and see the
    results. To test our API request, we can open Postman and put `https://api.openweathermap.org/data/2.5/weather?q={$location},us,&APPID=${API_KEY}`
    into the request bar. Before making the request, just change `${location}` to
    be a test city and `${API_KEY}` to be the API key that we generated on the Open
    Weather Map website. It should look something like this: `https://api.openweathermap.org/data/2.5/weather?q=manchester,us,&APPID=12345678`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this request, we will get a result similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From this data, the information that we are likely to want to tell the user
    will come from the weather and the main sections, with the rest of the data being
    less relevant for us. To remove this information, we can use destructuring again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to do the same for the forecast requests. The data is different, so
    we will need to do a bit more processing to extract the data we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have forecast data for every three hours for the next five days. This
    is too much data to try to tell a user, even if they are only asking for a single
    day. To cut the data down, we can reduce the forecast to one at 9:00 and one at
    18:00\. We can use a filter on the `usefulForecast` array so that the `dt_txt`
    has to end at `09:00:00` or `18:00:00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get the two forecasts for the day that the user requested. We can
    use `moment` again to compare the results and the date selected by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We should now have an array that contains two forecasts with the weather, temperature,
    and humidity for 9:00 and 18:00 on the day the user asked about.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the data for the current weather and forecasts, we can start to create
    the user response. We''ll start with a current weather request. We can use template
    strings to make the formatting easy. You can modify the phrasing or the structure
    all that you want, as long as you use the correct variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You have probably noticed that we used two variables that we haven't defined
    yet. Let's look into that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `weatherString` needs to be made from the array of weather types that are
    currently happening. To deal with these, we can create a new function that takes
    the `weather` array and returns a string that is more human-/Alexa-readable. This
    function should be placed outside of the handlers object as a new function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If there is only one weather type, this function returns the description. When
    there is more than one weather type, insert a comma between the types, apart from
    the last one, where it uses `and` to add it on. This would create strings such
    as *broken clouds, light rain and mist*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to convert the temperature into a scale that more people understand.
    The temperature we''re given is in Kelvin, so we need to convert it to Celsius
    or Fahrenheit. I have provided the functions for both, but we only need to use
    one in our Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Back inside our `getWeather` handler, we can now add the calls to these functions
    to our `isToday` if block. You can comment out the temperature function you don''t
    want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have everything that we need to create the `speechText` variable
    that will be passed to the user, we need to follow a similar set of steps for
    the forecast data. We can start with the phrase that we want to build, which is
    a bit longer and more complex than the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To populate these variables, we need to use the format `formatWeatherString()`
    and `tempC()` functions on both elements in the `dayForecast` array. You can switch
    `tempC()` for `tempC()` if you want to use Fahrenheit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will put the morning forecasts into the first index of the arrays as we
    required in our `speechText` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the string responses for current weather and forecasts, we
    need to tell the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once we save this function, we are ready to deploy this Lambda. With our build
    script, this is done by navigating into the main Lambda folder and running `./build.sh
    weatherGods`.
  prefs: []
  type: TYPE_NORMAL
- en: Final setup and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Lambda created and uploaded, we can finish the last steps of the setup
    and then test out our skill. There are two things that we need to do before the
    skill starts working:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Alexa Skills Kit as a trigger to the Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the Lambda ARN to the skill endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've done this all twice before, so this will be a brief guide. Open the Lambda
    Console and navigate into the `weatherGods` Lambda. In the Designer section, add
    the Alexa Skills Kit as a trigger and then add the Skill ID to the configuration
    window, and save the Lambda. Copy the ARN of the Lambda and navigate into the
    Alexa Skills Kit Developer Console, where we can go into the `WeatherGods` skill
    and add the Lambda ARN to the skill endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the setup of the skill is done, we get to test it. In the Alexa Skill
    Kit console, make sure you are in the `WeatherGods` skill and that all of the
    items on the Skill builder checklist are complete. If you have any missing, then
    go back and complete that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5609c0f-1a0e-4122-87b2-4036c1253dff.png)'
  prefs: []
  type: TYPE_IMG
- en: Skill-building checklist
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go into the Test tab and try out this skill. We can start this skill
    and then ask for a forecast, and we should be told the forecast for a given city:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1223ec81-c4c3-4e51-8bdb-31d1d9a510cf.png)'
  prefs: []
  type: TYPE_IMG
- en: City forecast
  prefs: []
  type: TYPE_NORMAL
- en: This is a great place to try out different ways of asking the same thing and
    expanding the utterances for the intents.
  prefs: []
  type: TYPE_NORMAL
- en: Improving user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While our first version of this skill works well, it can be improved in a few
    key sections.
  prefs: []
  type: TYPE_NORMAL
- en: Error-handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error-handling our API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we first set up this function, we didn't include any error-handling for
    our API calls. There is a chance that something happens with the API or with our
    call that causes it to fail. This could be a huge list of things such as broken
    internet connection, incorrect request, unknown location, expired API key, or
    the API going down.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with this, we need to modify the way that our skill makes that request
    to the Open Weather Maps API. One of the limitations of using pure `async` and
    `await` is that we can''t tell whether the request has passed or failed. There
    are two ways to deal with this:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `try…catch` blocks to catch any errors that occur. The way that
    we would do this would be to wrap everything inside the `isToday` block in a `try`
    block and then have a `catch` that tells the user that we couldn't deal with the
    request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can pass the request to a function that returns an array of `[error, result]`.
    If no error occurs, then it will be `null` so we can do logic based on that fact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these methods are suitable, but they are best used in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `try…catch` method is used to catch errors across the code. We can
    take advantage of this by wrapping most of our logic in a single `try…catch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Keeping error messages light-hearted is often a good idea, as the user is less
    likely to be annoyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method is often used when you want to catch when a specific promise
    errors. We need to create a new function that takes a promise and returns the
    error and result status. This function is usually called `to`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If this function gets a promise that resolves, it returns the error as `null`
    and the result. But if there is an error, it returns an error and a `null` result.
    The error always goes in the first position because of a standard design called
    **error-first programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is good for catching errors at a very specific location, whether
    it is to handle it differently or just to log out more information at that point.
    We can use this on the current weather request to give a slightly different response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The last tool that we can use to handle errors is providing an error handler
    to the whole Alexa skill. We can create another handler that is called whenever
    there is an uncaught error in our code. This could be us returning an incorrect
    response, having an undefined variable, or an uncaught promise rejection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want this to be called every time an error occurs, our `canHandle`
    function always returns true. Our handler then gets passed the `handlerInput`
    but also gets passed an `error` variable. We can `console.log` out the response
    from the error and then send the user an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To apply this handler to our skill, we can add `.addErrorHandlers(ErrorHandler)`
    after `.addRequestHandlers` in our `Alexa.SkillBuilders`.
  prefs: []
  type: TYPE_NORMAL
- en: With these measures in place, our skill will work much better if there is ever
    an error in our code or when making a request to the Open Weather Map API. You
    should always have some sort of error-handling process around API calls, as you
    never know when they might go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Session memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that doesn't currently work is asking follow-up questions. From the
    initial perfect conversation, we had to follow up questions such as *What about
    tomorrow**?* and *What about in Miami?* that use knowledge about previous requests
    to populate either the date or the location. Having a skill that can remember
    certain bits of information between interactions means that it can interact in
    a much more human way. There are very few interactions that we make that never
    depend on previous information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain that information between interactions, we have the concept of **session
    attributes**. These are key value pairs that are attached to the session, not
    just the individual interaction. Once Alexa thinks she''s completed a task, she
    closes the session. In Alexa, session attributes are also really easy to set and
    retrieve. Getting session attributes is as simple as calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we have access to the values that we have previously stored
    in session attributes. To store values in session attributes, we can pass an object
    into `.setSessionAttributes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last thing that we need to do is to tell Alexa that the session hasn't finished
    yet. We do this by adding `.withShouldEndSession(false)` just before `.getResponse()`
    in our response builder when we want to keep the session attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user doesn''t respond within a set time, the session still gets closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can use this powerful tool to store the date and location of successful requests
    and then use them to fill location or date slots that aren't filled by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is to get the session attributes from storage.
    We can then use these values to populate the `date` and `location` variables.
    If we don''t get a value from the slots, we try the session attributes; otherwise,
    we set them to `null`. We then set out the local `sessionAttributes` variable
    to equal our `date` and `location`. This means that new values that come from
    slots override the existing session attribute values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have changed the local session attributes, but we haven''t set them on the
    session yet. We leave this until just before we respond to the user. We choose
    not to save it straight away, as if the user provided an invalid slot, that would
    get stored. If we store it just before sending the message, then we know that
    the API calls have succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we need to add `handlerInput.attributesManager.setSessionAttributes(sessionAttributes);`
    just before returning the forecast message.
  prefs: []
  type: TYPE_NORMAL
- en: This example makes good use of session attributes, but it can be used for so
    much more. It can be used to store information for certain intents, previous conversation
    topics, or information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that session attributes only last as long as the conversation
    session with the user. If you want to maintain attributes from one session to
    another, you can use persistent attributes, but this involves configuring your
    skill with a **Persistence Adapter**. More details are available at the end of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SSML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are sending a response to a user, you may not want Alexa to say it
    in her normal way. Alexa is already pretty smart and handles punctuation, increasing
    the tone at the end of a question and pausing after a period, but what if you
    want to have greater control?
  prefs: []
  type: TYPE_NORMAL
- en: SSML is a standard markup for speech synthesis, and Alexa supports a subset
    of SSML, allowing the use of 13 different tags. These tags allow you to specify
    the way that the text is spoken. This means you can add `<break time="2s">` into
    your speech to add a two-second pause, emphasise a section of the speech using
    `<emphasis level="moderate">text to emphasise</emphasis>`, or `<prosody rate="slow"
    pitch="-2st">`to change the tone and speed, `</prosody>`, of the speech.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways to change the way that Alexa talks, and they can all
    be found in the Alexa SSML reference page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis)).
  prefs: []
  type: TYPE_NORMAL
- en: The speech that we are saying to the user is already handled very well because
    of Alexa's handling of punctuation and questions. This means there isn't much
    of our existing messages we could improve with SSML. To give us something that
    always needs extra speech control, we're going to add a new intent—`tellAJoke`.
    If you've ever heard someone ruin a good joke, then you know that jokes need proper
    tone, speed, and timing.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add the `tellAJoke` intent in the Alexa Skills Kit console and then
    add a few utterances, but this time we don't need any slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve saved and built the model, we can move back to our code to handle
    this new intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e25de44c-efb2-41e4-834f-18a11a3ff2ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the tell-a-joke intent
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler for this intent is very simple. All that it needs to do is to get
    a random joke from the array of jokes and tell that to the user. We use `Math.floor(Math.random()
    * 3);` to get a random integer that is less than 3\. If you want to add more jokes,
    just change `3` to the number of jokes you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The more interesting part is creating the jokes. We need to start by creating
    a variable called `jokes` that is an array. Inside this array, we can put a few
    weather-related jokes. I''ve added the first three, but feel free to add your
    own (and remove my less-funny ones):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we published the skill now, those jokes would be even worse than they''re
    meant to be. The first thing that we will aim to fix will be the timing. Adding
    break tags before the punchline makes the jokes far better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact timings may not be perfect, but they''re already delivered much better
    than before. Another key to telling a joke well is the emphasis you place on certain
    words. Adding emphasis to sections of speech in Alexa is done by wrapping those
    words in `emphasis` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `emphasis` tags to our jokes, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When the `emphasis` tags are used but a level is not provided, a level of *moderate*
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other SSML tags that can be used to alter the way that Alexa
    says the response, and they can be found on the Alexa SSML page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've added all of these changes to our Lambda, we can build it and
    test it out.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite hard to test what happens when API errors occur, but we can test
    for session attributes and SSML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Session attributes can be tested by asking to follow up questions, where we
    expect that some data has been stored from the last question. We can ask for a
    forecast in one location, and then ask for a new location. The date should have
    been saved in session attributes, so we should get a forecast for the new location
    instead of the current weather. We can then ask about today''s weather, and the
    new location should have been saved, so we shouldn''t get prompted for the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90a19ab8-6d25-42d3-8fbf-2d99c267926c.png)'
  prefs: []
  type: TYPE_IMG
- en: Session attributes testing
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also test SSML by asking for a joke. The joke you get back should have
    the break that we added and possibly some emphasis. When you test this yourself,
    you will be able to hear these clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9762c3e-2641-4663-89ec-e75e11008e61.png)'
  prefs: []
  type: TYPE_IMG
- en: Jokes
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered how to use external APIs to increase the information
    that is available to the chatbot, allowing you to make much more powerful skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then looked at how to make the experience more enjoyable for the user. The
    three ways we did this were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We used error-handling to reduce the frustration when a user's request doesn't
    work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used session memory to remember details about the conversation so that we
    can use them later. This stopped us from repeating and prompting the user every
    time they didn't provide all of the information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used SSML to modify the way that Alexa says our responses, to make the sentence
    feel more human. We also used SSML to make jokes funnier, but it can be used to
    emphasize points or change the tone of the speech.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Axios differ from the standard HTTP request library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two common ways of handling `async` and `await` errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we store *color* on the session attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of data can be stored on the session attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use SSML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to learn about *persistentAttributes*,then you can read about them
    in the ASK SDK documents ([https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html](https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html)).
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of the supported SMML tags in Alexa, go to the Alexa SSML reference
    page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html)).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to hear how different SSML tags change the way that text is spoken,
    check out the Google SSML reference page ([https://developers.google.com/actions/reference/ssml](https://developers.google.com/actions/reference/ssml)).
    It has working examples of lots of SSMLs, but you can't edit them.
  prefs: []
  type: TYPE_NORMAL
