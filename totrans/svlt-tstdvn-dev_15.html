<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-169"><a id="_idTextAnchor168"/>15</h1>
<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Test-Driving Svelte Stores</h1>
<p><strong class="bold">Stores</strong> are a useful mechanism for sharing state that exists outside of the normal Svelte component hierarchy. You can think of stores as global variables but with a protective mechanism – the <strong class="source-inline">subscribe</strong> mechanism – that helps ensure that all components maintain a consistent view of each variable’s <span class="No-Break">current value.</span></p>
<p>When it comes to writing tests for components that involve stores, you’ve got to write tests for two halves: the first half for the <em class="italic">observation</em> of the store value and the second half for the <em class="italic">setting</em> of the <span class="No-Break">store value.</span></p>
<p>Because stores are an internal design decision, there’s no need to write a Playwright test specifically for the introduction <span class="No-Break">of stores.</span></p>
<p>This chapter covers the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Designing a store <span class="No-Break">for birthdays</span></li>
<li>Writing tests for reading <span class="No-Break">store values</span></li>
<li>Writing tests for updating <span class="No-Break">store values</span></li>
</ul>
<p>By the end of the chapter, you’ll have a good understanding of writing unit tests for Svelte <span class="No-Break">store objects.</span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Designing a store for birthdays</h1>
<p>The code for <a id="_idIndexMarker491"/>this chapter includes a single store in the <strong class="source-inline">src/stores/birthdays.js</strong> file with the <span class="No-Break">following content:</span></p>
<pre class="source-code">
import { writable } from 'svelte/store';
export const birthdays = writable([]);</pre>
<p>The idea of the <strong class="source-inline">birthdays</strong> store is to store whatever birthdays have been returned from the SvelteKit page load. It’s kept up to date by the page <span class="No-Break">route component.</span></p>
<p>There’s also a new <strong class="source-inline">NextBirthday</strong> component that reads the store and displays a message at <a id="_idIndexMarker492"/>the top of the page alerting the user to the next <span class="No-Break">upcoming birthday.</span></p>
<p class="callout-heading">Stores aren’t necessary for this change</p>
<p class="callout">This feature could have been written simply by passing <strong class="source-inline">birthdays</strong> as a prop to <strong class="source-inline">NextBirthday</strong>. It’s certainly worth avoiding stores if you can simply use component props. This chapter’s code is intended to be educative only; in reality I would not use a store for this <span class="No-Break">use case.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 15.1 – The Birthdays application with the new alert" height="750" src="image/Figure_15.1_B19611.jpg" width="1126"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Birthdays application with the new alert</p>
<p>The code for the <strong class="source-inline">NextBirthday</strong> component is not trivial, so you may be interested in checking it out online. In particular, the unit tests make use of the <strong class="source-inline">vi.useFakeTimers</strong> and <strong class="source-inline">vi.setSystemTime</strong> functions to ensure that the test checks aren’t affected by the passing of <span class="No-Break">real time.</span></p>
<p>That’s all the design necessary. Let’s look at <span class="No-Break">the tests.</span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Writing tests for reading store values</h1>
<p>There are at least two tests needed when reading the store value: first, for the initial value when <a id="_idIndexMarker493"/>the component loads, and second, when an update <span class="No-Break">comes in.</span></p>
<p>Here’s an example of the first, which you’ll find in <strong class="source-inline">src/routes/birthdays/NextBirthday.test.js</strong>. Notice how we import the <strong class="source-inline">birthdays</strong> store with the name, <strong class="source-inline">birthdaysStore</strong>, which makes it very clear in the test that the object imported is the store. The <em class="italic">Arrange</em> phase of the test then calls <strong class="source-inline">birthdayStore.set</strong> to prime the store with its initial value before the component <span class="No-Break">is mounted:</span></p>
<pre class="source-code">
import {
  birthdays as birthdaysStore
} from '../../stores/birthdays.js';
...
describe('NextBirthday', () =&gt; {
  it('displays a single birthday', () =&gt; {
    birthdaysStore.set([
      createBirthday('Hercules', '2023-09-01')
    ]);
    render(NextBirthday);
    expect(document.body).toHaveTextContent(
      'Hercules has the next birthday, on 2056-09-01'
    );
  });
});</pre>
<p>You may be <a id="_idIndexMarker494"/>curious why the year <strong class="source-inline">2056</strong> is mentioned in the expectation. That’s because we used <strong class="source-inline">vi.setSystemTime</strong> to set the current date to a <span class="No-Break">fixed date:</span></p>
<pre class="source-code">
const julyOfYear = (year) =&gt; {
  const date = new Date();
  date.setFullYear(year, 6, 1);
  return date;
};
describe('NextBirthday', () =&gt; {
  beforeEach(() =&gt; {
    vi.useFakeTimers();
    vi.setSystemTime(julyOfYear(2056));
  });
  afterEach(() =&gt; {
    vi.useRealTimers();
  });
  ...
});</pre>
<p>The second test has the same initial setting, but now the <strong class="source-inline">render</strong> call moves into the <em class="italic">Arrange</em> phase, and the <em class="italic">Act</em> phase is now a second call to <strong class="source-inline">birthdayStore.set</strong>. Notice also that this call needs to be marked with <strong class="source-inline">await</strong> so that the component has the opportunity <span class="No-Break">to re-render:</span></p>
<pre class="source-code">
it('updates the displayed data when the store is updated', async () =&gt; {
  birthdaysStore.set([
    createBirthday('Hercules', '2023-09-01')
  ]);
  render(NextBirthday);
  await birthdaysStore.set([
    createBirthday('Hercules', '2023-09-01'),
    createBirthday('Ares', '2023-08-01')
  ]);
  expect(document.body).toHaveTextContent(
    'Ares has the next birthday, on 2056-08-01'
  );
});</pre>
<p>This test will <a id="_idIndexMarker495"/>only pass if the component is set to observe the store. You can see this <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/NextBirthday.svelte</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$: nextBirthday = findNextBirthday($birthdays);</pre>
<p>The test would fail if the argument to the function was <strong class="source-inline">birthdays</strong> and <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">$birthdays</strong></span><span class="No-Break">.</span></p>
<p>Next, let’s look at the tests for setting <span class="No-Break">the value.</span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Writing tests for updating store values</h1>
<p>The page <a id="_idIndexMarker496"/>route component is responsible for ensuring the birthdays that are passed into it are saved in <span class="No-Break">the store.</span></p>
<p>Here’s the first test from the <strong class="source-inline">src/routes/birthdays/page.test.js</strong> file, which uses <strong class="source-inline">birthdaysStore.subscribe</strong> to set a <strong class="source-inline">storedBirthdays</strong> value within the test. After rendering the component, it expects the <strong class="source-inline">storedBirthdays</strong> value to contain <span class="No-Break">the birthdays:</span></p>
<pre class="source-code">
it('saves the loaded birthdays into the birthdays store', () =&gt; {
  let storedBirthdays;
  birthdaysStore.subscribe(
    (value) =&gt; (storedBirthdays = value)
  );
  render(Page, { data: { birthdays } });
  expect(storedBirthdays).toEqual(birthdays);
});</pre>
<p>A second <a id="_idIndexMarker497"/>test is then needed to ensure the store value is updated whenever the component prop changes. This test makes use of the <strong class="source-inline">$set</strong> function on the returned component to update the props on <span class="No-Break">the component:</span></p>
<pre class="source-code">
it('updates the birthdays store when the component props change', async () =&gt; {
  let storedBirthdays;
  birthdaysStore.subscribe(
    (value) =&gt; (storedBirthdays = value)
  );
  const { component } = render(Page, {
    data: { birthdays }
  });
  await component.$set({ data: { birthdays: [] } });
  expect(storedBirthdays).toEqual([]);
});</pre>
<p>And that’s all there is <span class="No-Break">to it.</span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Summary</h1>
<p>This short chapter covered some important concepts for testing Svelte stores: first, how to test the two halves of observing and setting Svelte store values, and second, how you can rename the store import so that it’s more readable within your tests. In our case, that meant renaming <strong class="source-inline">birthdays</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">birthdaysStore</strong></span><span class="No-Break">.</span></p>
<p>You’ve also seen how to call the store’s <strong class="source-inline">set</strong> and <strong class="source-inline">subscribe</strong> methods within your tests, and how to use Svelte’s <strong class="source-inline">$set</strong> function on the component instance to update props to a previously <span class="No-Break">rendered component.</span></p>
<p>Taken together, these techniques highlight how advanced Svelte features are still testable at the unit level if that’s desired. Of course, you might get just as much value from writing Playwright tests that can happily ignore the internal mechanics of <span class="No-Break">Svelte stores.</span></p>
<p>The next chapter covers a more complicated topic: <span class="No-Break"><strong class="bold">service workers</strong></span><span class="No-Break">.</span></p>
</div>
</div></body></html>