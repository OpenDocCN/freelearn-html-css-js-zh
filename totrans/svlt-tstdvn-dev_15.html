<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-169"><a id="_idTextAnchor168"/>15</h1>
<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Test-Driving Svelte Stores</h1>
<p><code>subscribe</code> mechanism – that helps ensure that all components maintain a consistent view of each variable’s current value.</p>
<p>When it comes to writing tests for components that involve stores, you’ve got to write tests for two halves: the first half for the <em class="italic">observation</em> of the store value and the second half for the <em class="italic">setting</em> of the store value.</p>
<p>Because stores are an internal design decision, there’s no need to write a Playwright test specifically for the introduction of stores.</p>
<p>This chapter covers the following key topics:</p>
<ul>
<li>Designing a store for birthdays</li>
<li>Writing tests for reading store values</li>
<li>Writing tests for updating store values</li>
</ul>
<p>By the end of the chapter, you’ll have a good understanding of writing unit tests for Svelte store objects.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter15/Complete</a>.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Designing a store for birthdays</h1>
<p>The code for <a id="_idIndexMarker491"/>this chapter includes a single store in the <code>src/stores/birthdays.js</code> file with the following content:</p>
<pre class="source-code">
import { writable } from 'svelte/store';
export const birthdays = writable([]);</pre>
<p>The idea of the <code>birthdays</code> store is to store whatever birthdays have been returned from the SvelteKit page load. It’s kept up to date by the page route component.</p>
<p>There’s also a new <code>NextBirthday</code> component that reads the store and displays a message at <a id="_idIndexMarker492"/>the top of the page alerting the user to the next upcoming birthday.</p>
<p class="callout-heading">Stores aren’t necessary for this change</p>
<p class="callout">This feature could have been written simply by passing <code>birthdays</code> as a prop to <code>NextBirthday</code>. It’s certainly worth avoiding stores if you can simply use component props. This chapter’s code is intended to be educative only; in reality I would not use a store for this use case.</p>
<div><div><img alt="Figure 15.1 – The Birthdays application with the new alert" height="750" src="img/Figure_15.1_B19611.jpg" width="1126"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Birthdays application with the new alert</p>
<p>The code for the <code>NextBirthday</code> component is not trivial, so you may be interested in checking it out online. In particular, the unit tests make use of the <code>vi.useFakeTimers</code> and <code>vi.setSystemTime</code> functions to ensure that the test checks aren’t affected by the passing of real time.</p>
<p>That’s all the design necessary. Let’s look at the tests.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Writing tests for reading store values</h1>
<p>There are at least two tests needed when reading the store value: first, for the initial value when <a id="_idIndexMarker493"/>the component loads, and second, when an update comes in.</p>
<p>Here’s an example of the first, which you’ll find in <code>src/routes/birthdays/NextBirthday.test.js</code>. Notice how we import the <code>birthdays</code> store with the name, <code>birthdaysStore</code>, which makes it very clear in the test that the object imported is the store. The <em class="italic">Arrange</em> phase of the test then calls <code>birthdayStore.set</code> to prime the store with its initial value before the component is mounted:</p>
<pre class="source-code">
import {
  birthdays as birthdaysStore
} from '../../stores/birthdays.js';
...
describe('NextBirthday', () =&gt; {
  it('displays a single birthday', () =&gt; {
    birthdaysStore.set([
      createBirthday('Hercules', '2023-09-01')
    ]);
    render(NextBirthday);
    expect(document.body).toHaveTextContent(
      'Hercules has the next birthday, on 2056-09-01'
    );
  });
});</pre>
<p>You may be <a id="_idIndexMarker494"/>curious why the year <code>2056</code> is mentioned in the expectation. That’s because we used <code>vi.setSystemTime</code> to set the current date to a fixed date:</p>
<pre class="source-code">
const julyOfYear = (year) =&gt; {
  const date = new Date();
  date.setFullYear(year, 6, 1);
  return date;
};
describe('NextBirthday', () =&gt; {
  beforeEach(() =&gt; {
    vi.useFakeTimers();
    vi.setSystemTime(julyOfYear(2056));
  });
  afterEach(() =&gt; {
    vi.useRealTimers();
  });
  ...
});</pre>
<p>The second test has the same initial setting, but now the <code>render</code> call moves into the <em class="italic">Arrange</em> phase, and the <em class="italic">Act</em> phase is now a second call to <code>birthdayStore.set</code>. Notice also that this call needs to be marked with <code>await</code> so that the component has the opportunity to re-render:</p>
<pre class="source-code">
it('updates the displayed data when the store is updated', async () =&gt; {
  birthdaysStore.set([
    createBirthday('Hercules', '2023-09-01')
  ]);
  render(NextBirthday);
  await birthdaysStore.set([
    createBirthday('Hercules', '2023-09-01'),
    createBirthday('Ares', '2023-08-01')
  ]);
  expect(document.body).toHaveTextContent(
    'Ares has the next birthday, on 2056-08-01'
  );
});</pre>
<p>This test will <a id="_idIndexMarker495"/>only pass if the component is set to observe the store. You can see this in <code>src/routes/birthdays/NextBirthday.svelte</code>:</p>
<pre class="source-code">
$: nextBirthday = findNextBirthday($birthdays);</pre>
<p>The test would fail if the argument to the function was <code>birthdays</code> and not <code>$birthdays</code>.</p>
<p>Next, let’s look at the tests for setting the value.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Writing tests for updating store values</h1>
<p>The page <a id="_idIndexMarker496"/>route component is responsible for ensuring the birthdays that are passed into it are saved in the store.</p>
<p>Here’s the first test from the <code>src/routes/birthdays/page.test.js</code> file, which uses <code>birthdaysStore.subscribe</code> to set a <code>storedBirthdays</code> value within the test. After rendering the component, it expects the <code>storedBirthdays</code> value to contain the birthdays:</p>
<pre class="source-code">
it('saves the loaded birthdays into the birthdays store', () =&gt; {
  let storedBirthdays;
  birthdaysStore.subscribe(
    (value) =&gt; (storedBirthdays = value)
  );
  render(Page, { data: { birthdays } });
  expect(storedBirthdays).toEqual(birthdays);
});</pre>
<p>A second <a id="_idIndexMarker497"/>test is then needed to ensure the store value is updated whenever the component prop changes. This test makes use of the <code>$set</code> function on the returned component to update the props on the component:</p>
<pre class="source-code">
it('updates the birthdays store when the component props change', async () =&gt; {
  let storedBirthdays;
  birthdaysStore.subscribe(
    (value) =&gt; (storedBirthdays = value)
  );
  const { component } = render(Page, {
    data: { birthdays }
  });
  await component.$set({ data: { birthdays: [] } });
  expect(storedBirthdays).toEqual([]);
});</pre>
<p>And that’s all there is to it.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Summary</h1>
<p>This short chapter covered some important concepts for testing Svelte stores: first, how to test the two halves of observing and setting Svelte store values, and second, how you can rename the store import so that it’s more readable within your tests. In our case, that meant renaming <code>birthdays</code> as <code>birthdaysStore</code>.</p>
<p>You’ve also seen how to call the store’s <code>set</code> and <code>subscribe</code> methods within your tests, and how to use Svelte’s <code>$set</code> function on the component instance to update props to a previously rendered component.</p>
<p>Taken together, these techniques highlight how advanced Svelte features are still testable at the unit level if that’s desired. Of course, you might get just as much value from writing Playwright tests that can happily ignore the internal mechanics of Svelte stores.</p>
<p>The next chapter covers a more complicated topic: <strong class="bold">service workers</strong>.</p>
</div>
</div></body></html>