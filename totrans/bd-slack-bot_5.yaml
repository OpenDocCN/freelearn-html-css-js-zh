- en: Chapter 5. Understanding and Responding to Natural Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：理解和回应自然语言
- en: We've built bots that can play games, store data, and provide useful information.
    The next step isn't information gathering, it's processing. This chapter will
    introduce **natural language processing** (**NLP**) and show how we can use it
    to enhance our bots even further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了能够玩游戏、存储数据和提供有用信息的机器人。下一步不是信息收集，而是处理。本章将介绍**自然语言处理**（**NLP**），并展示我们如何利用它进一步增强我们的机器人。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: A brief introduction to natural language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言的简要介绍
- en: A Node implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点实现
- en: Natural language processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言处理
- en: Natural language generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然语言生成
- en: Displaying data in a natural way
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以自然的方式展示数据
- en: A brief introduction to natural language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然语言的简要介绍
- en: You should always strive to make your bot as helpful as possible. In all the
    bots we've made so far, we've awaited clear instructions via a key word from the
    user and then followed said instructions as far as the bot is capable. What if
    we could infer instructions from users without them actually providing a key word?
    Enter **natural language processing** (**NLP**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终努力使你的机器人尽可能有用。在我们迄今为止制作的机器人中，我们都是通过用户的关键词来等待明确的指令，然后按照机器人能够做到的范围内执行这些指令。如果我们能够从用户那里推断出指令，而他们实际上并没有提供关键词怎么办？这就引入了**自然语言处理**（**NLP**）。
- en: NLP can be described as a field of computer science that strives to understand
    communication and interactions between computers and human (natural) languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理可以描述为计算机科学的一个领域，它致力于理解计算机与人类（自然）语言之间的沟通和互动。
- en: In layman's terms, NLP is the process of a computer interpreting conversational
    language and responding by executing a command or replying to the user in an equally
    conversational tone.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗易懂的话来说，自然语言处理是计算机解释对话语言并通过执行命令或以同样对话的语气回复用户的过程。
- en: Examples of NLP projects are digital assistants such as the iPhone's Siri. Users
    can ask questions or give commands and receive answers or confirmation in natural
    language, seemingly from a human.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）的例子包括iPhone的Siri这样的数字助手。用户可以提出问题或下达命令，并以自然语言接收答案或确认，似乎来自人类。
- en: One of the more famous projects using NLP is IBM's Watson system. In 2011, Watson
    famously competed against human opponents in the TV show Jeopardy! and won first
    place.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自然语言处理（NLP）的更著名的项目之一是IBM的Watson系统。2011年，Watson在电视节目《危险边缘》中与人类对手竞争，并赢得了第一名。
- en: The NLP field is a large and complicated one, with many years of research performed
    by prestigious academic institutions and by large technology companies. Watson
    alone took 5 years, $3 million, and a small army of academics and engineers to
    build. In this chapter, the main concepts will briefly be described and a practical
    example given.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理领域是一个庞大而复杂的领域，许多知名学术机构和大型科技公司进行了多年的研究。仅Watson就花费了5年时间，300万美元，以及一支由学者和工程师组成的小型军队来构建。在本章中，我们将简要介绍主要概念，并给出一个实际例子。
- en: 'First, let''s take a step back and see how NLP might benefit our bots. If we
    built a bot that retrieves the weather report, we could imagine the command to
    look something like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们退一步，看看自然语言处理如何使我们的机器人受益。如果我们构建了一个可以检索天气预报的机器人，我们可以想象命令看起来可能像这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This would return tomorrow's weather report for the city of Amsterdam. What
    if the bot could retrieve the weather report without requiring a command to be
    issued? For instance, if a Slack user were to send the message "Will it rain tomorrow?",
    then the bot would respond with tomorrow's weather report. This is NLP at work;
    it is the breakdown of natural language into instructions that can be interpreted
    by the program as a command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回阿姆斯特丹市的天气预报。如果机器人能够在不发出命令的情况下检索天气预报怎么办？例如，如果Slack用户发送消息“明天会下雨吗？”，那么机器人就会回复明天的天气预报。这就是自然语言处理（NLP）在发挥作用；它是将自然语言分解成程序可以解释为命令的指令的过程。
- en: To help us in our understanding of NLP, we will be using a helper library that
    abstracts the more complicated algorithms away. A good NLP framework is the Python
    language-based **natural language** **toolkit** (**NLTK**) available at [http://www.nltk.org/](http://www.nltk.org/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解自然语言处理（NLP），我们将使用一个辅助库，该库将更复杂的算法抽象化。一个好的NLP框架是基于Python语言的**自然语言****工具包**（**NLTK**），可在[http://www.nltk.org/](http://www.nltk.org/)找到。
- en: Luckily for us, a project to port the major functions of NLTK to Node has been
    functioning for some time and has reached a high enough level of maturity for
    us to use it seamlessly with our existing JavaScript projects. Known as Natural
    ([https://github.com/NaturalNode/natural](https://github.com/NaturalNode/natural)),
    this library will be our key point of entry to the world of NLP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一个将 NLTK 的主要功能移植到 Node 的项目已经存在了一段时间，并且已经达到了足够成熟的水平，我们可以无缝地将其与现有的 JavaScript
    项目一起使用。这个库被称为 Natural ([https://github.com/NaturalNode/natural](https://github.com/NaturalNode/natural))，它将成为我们进入
    NLP 世界的关键入口点。
- en: Let's start by introducing some of the more common NLP algorithms. Afterwards,
    we'll use our newfound knowledge by building a simple weather bot, as outlined
    earlier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍一些更常见的 NLP 算法。之后，我们将利用我们新获得的知识，通过构建一个简单的天气机器人来实现，正如之前概述的那样。
- en: Fundamentals of NLP
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NLP 基础
- en: 'NLP, at its core, works by splitting a chunk of text (also referred to as a
    corpus) into individual segments or tokens and then analyzing them. These tokens
    might simply be individual words but might also be word contractions. Let''s look
    at how a computer might interpret the phrase: *I have watered the plants*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言处理（NLP）的核心是通过将一段文本（也称为语料库）分割成单个片段或标记，然后对这些标记进行分析。这些标记可能是单个单词，也可能是单词缩写。让我们看看计算机如何解释这个短语：*我给植物浇水了*。
- en: 'If we were to split this corpus into tokens, it would probably look something
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个语料库分割成标记，它可能看起来像这样：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The word `the` in our corpus is unnecessary as it does not help to understand
    the phrase''s intent— the same for the word `have`. We should therefore remove
    the surplus words:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语料库中，单词 `the` 是不必要的，因为它并不能帮助我们理解短语的意图——同样，单词 `have` 也是如此。因此，我们应该删除这些多余的单词：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Already, this is starting to look more usable. We have a personal pronoun in
    the form of an actor (`I`), an action or verb (`watered`), and a recipient or
    noun (`plants`). From this, we can deduce exactly which action is enacted to what
    and by whom. Furthermore, by conjugating the verb `watered`, we can establish
    that this action occurred in the past. Consider how the context and meaning of
    the phrase changes when we make minor changes: *We are watering the plant*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 已经，这开始看起来更有用。我们有一个以演员形式出现的第一人称代词（`I`），一个动作或动词（`watered`），以及一个接受者或名词（`plants`）。从这些信息中，我们可以推断出确切的动作是由谁对什么进行的。此外，通过动词
    `watered` 的变化形式，我们可以确定这个动作发生在过去。考虑一下当我们对短语进行微小改变时，短语的内容和意义是如何变化的：*我们在给植物浇水*。
- en: 'By using the same process as previously, we get the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与之前相同的过程，我们得到以下结果：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The meaning of the phrase has dramatically changed: there are multiple actors
    involved, the action is in the present and the recipient is singular. The challenge
    of NLP is the ability to analyze such nuances, arrive at a conclusion with a high
    enough confidence level, and then perform actions based on that conclusion.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 短语的意义发生了戏剧性的变化：涉及多个演员，动作是现在时态，接受者是单数。NLP 的挑战在于分析这样的细微差别，以足够高的置信度得出结论，然后根据这个结论采取行动。
- en: A computer, much like a person, learns this nuance by practice and by picking
    up patterns. A common NLP term is to train your system to recognize context in
    a corpus. By providing a large amount of predefined phrases to our system, we
    can analyze said phrases and look for similar ones in other corpus'. We will talk
    more about how to use this training or classifying technique later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像人一样，计算机通过实践和识别模式来学习这种细微差别。一个常见的 NLP 术语是训练你的系统在语料库中识别上下文。通过向我们的系统提供大量预定义的短语，我们可以分析这些短语，并在其他语料库中寻找类似的短语。我们将在稍后更多地讨论如何使用这种训练或分类技术。
- en: Let's now look at how we can actually perform the actions explained in the beginning
    of this section, starting with the splitting of a corpus into a series of tokens,
    also known as **tokenizing**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何实际执行本节开头所解释的动作，首先是将语料库分割成一系列标记，也称为**分词**。
- en: Tokenizers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分词器
- en: 'Start by creating a new project with `npm init`. Name your bot "weatherbot"
    (or something similar), and install the Slack and Natural APIs with the following
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 `npm init` 创建一个新的项目。将你的机器人命名为 "weatherbot"（或类似名称），并使用以下命令安装 Slack 和 Natural
    API：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Copy our `Bot` class from the previous chapters and enter the following in
    `index.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章中的 `Bot` 类复制到 `index.js` 文件中，并输入以下内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start up your Node process and type a test phrase into Slack:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的 Node 进程，并在 Slack 中输入一个测试短语：
- en: '![Tokenizers](img/B05384_05_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![分词器](img/B05384_05_01.jpg)'
- en: The returned tokenized message
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的分词消息
- en: Through the use of tokenization, the bot has split the given phrase into short
    fragments or **tokens**, ignoring punctuation and special characters. Note that
    we are using the native `JSON` object's `stringify` method to convert the JavaScript
    array into a string before sending it to the channel.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用分词，机器人将给定的短语拆分为短片段或**标记**，忽略标点符号和特殊字符。请注意，我们正在使用本地`JSON`对象的`stringify`方法在将其发送到频道之前将
    JavaScript 数组转换为字符串。
- en: 'This particular tokenized algorithm will handle contractions (for example,
    `hasn''t`) by removing the punctuation and splitting the word. Depending on our
    use case, we might want to use a different algorithm. Luckily, `natural` provides
    three different algorithms. Each algorithm returns slightly different results
    for a corpus. To learn more about these algorithms, visit the `natural` GitHub
    page: [https://github.com/NaturalNode/natural#tokenizers](https://github.com/NaturalNode/natural#tokenizers).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的分词算法将通过删除标点符号并拆分单词来处理缩写词（例如，“hasn't”）。根据我们的用例，我们可能想要使用不同的算法。幸运的是，`natural`提供了三种不同的算法。每种算法对语料库返回的结果略有不同。要了解更多关于这些算法的信息，请访问`natural`的
    GitHub 页面：[https://github.com/NaturalNode/natural#tokenizers](https://github.com/NaturalNode/natural#tokenizers)。
- en: 'A majority of these algorithms use punctuation (spaces, apostrophes, and so
    on) to tokenize phrases, whereas the Treebank algorithm analyses contractions
    (for example, `wanna` and `gimme`) to split them into regular words (`want to`
    and `give me` in the case of `wanna` and `gimme`). Let''s use Treebank for the
    next example, and replace the line where the tokenizer is initialized with the
    following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些算法使用标点符号（空格、撇号等）来分词短语，而 Treebank 算法分析缩写词（例如，“wanna”和“gimme”），将它们拆分为常规单词（在“wanna”和“gimme”的情况下，“want
    to”和“give me”）。让我们在下一个示例中使用 Treebank，并将初始化分词器的行替换为以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, return to Slack and try another test message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 Slack 并尝试发送另一条测试消息：
- en: '![Tokenizers](img/B05384_05_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![分词器](img/B05384_05_02.jpg)'
- en: The Treebank algorithm handles contractions differently
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Treebank 算法处理缩写词的方式不同
- en: 'Notice two important things here: the `haven''t` contraction was split into
    two parts, the root verb (`have`) and the contracted add-on (`not`). Furthermore,
    the word `cannot` was split into two separate words, making the command easier
    to deal with. This also makes certain slang words like `lemme` and `gotta` easier
    to process. By splitting the contracted word into two, we can more easily infer
    whether the phrase is positive or negative. `Can` by itself means positive; however,
    if it is followed by `not` it changes the context of the phrase to be negative.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里两个重要的事情：缩写词“haven't”被拆分为两部分，即词根动词（“have”）和缩写附加部分（“not”）。此外，“cannot”这个词也被拆分为两个单独的词，这使得命令更容易处理。这也使得某些俚语词如“lemme”和“gotta”更容易处理。通过将缩写词拆分为两部分，我们可以更容易地推断出短语是积极的还是消极的。“Can”本身意味着积极；然而，如果它后面跟着“not”，它就会改变短语语境，使其变为消极。
- en: Stemmers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词干提取器
- en: 'Sometimes, it is useful to find the root or `stem` of a word. In the English
    language, irregular verb conjugations are not uncommon. By deducing the root of
    a verb, we can dramatically decrease the amount of calculations needed to find
    the action of the phrase. Take the verb `searching` for example; for the purpose
    of bots, it would be much easier to process the verb in its root form `search`.
    Here, a stemmer can help us determine said root. Replace the contents of `index.js`
    with the following to demonstrate stemmers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，找到词的词根或“词干”是有用的。在英语中，不规则动词的屈折形式并不罕见。通过推断动词的词根，我们可以显著减少查找短语动作所需的计算量。以动词“searching”为例；对于机器人来说，以其词根形式“search”处理这个动词会容易得多。在这里，词干提取器可以帮助我们确定这个词根。将`index.js`的内容替换为以下内容以演示词干提取器：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s see what stemming a word returns:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看对一个词进行词干提取会返回什么：
- en: '![Stemmers](img/B05384_05_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![词干提取器](img/B05384_05_03.jpg)'
- en: The conjugated versions of a verb are often different from its root
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 动词的屈折形式通常与其词根不同
- en: As expected, `searching` is stemmed into `search` but (more interestingly) the
    token `shining` is stemmed into `shine`. This shows that the process of stemming
    is more than simply removing `-ing` from the tail end of a token. Now, we can
    analyze our tokenized and stemmed corpus and pick out certain verbs or actions.
    For instance, after stemming, the phrases *I went swimming* and *I swam*, both
    contain the verb `swim`, which means we only have to search for one term (`swim`)
    rather than two (`swimming` and `swam`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`searching` 提取为 `search`，但（更有趣的是）标记 `shining` 提取为 `shine`。这表明词干提取的过程不仅仅是简单地从标记的末尾移除
    `-ing`。现在，我们可以分析我们的分词和词干提取语料库，并挑选出某些动词或动作。例如，在提取词干后，短语 *I went swimming* 和 *I
    swam* 都包含动词 `swim`，这意味着我们只需要搜索一个术语（`swim`），而不是两个（`swimming` 和 `swam`）。
- en: Stemming also works for removing plurals from words. For instance, `searches`
    stems into `search` and `rains` into `rain`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 词干提取也可以用于从单词中去除复数。例如，`searches` 提取为 `search`，而 `rains` 提取为 `rain`。
- en: 'Let''s combine the concepts of tokenizing and stemming into one program to
    see its effects. Once again, replace `index.js` with the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将分词和词干提取的概念结合到一个程序中，看看其效果。再次，将 `index.js` 替换为以下内容：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we call `tokenizeAndStem` on `message.text`. This might seem odd,
    until you realize that we have attached the `tokenizeAndStem` method to the `String`
    object's prototype in earlier code, highlighted in the preceding code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `message.text` 上调用了 `tokenizeAndStem`。这看起来可能有些奇怪，直到你意识到我们在之前的代码中已经将 `tokenizeAndStem`
    方法附加到了 `String` 对象的原型上，这在前面的代码中已经突出显示。
- en: 'Switch over to the Slack client and you should see:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 Slack 客户端，你应该会看到：
- en: '![Stemmers](img/B05384_05_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![词干提取器](img/B05384_05_04.jpg)'
- en: Tokenizing and stemming to produce useful results
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 分词和词干提取以产生有用的结果
- en: The tokenizer and stemming combination has automatically left out very common
    words such as `it` and `in`, leaving us with a sentence distilled into the most
    important tokens of the original input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 分词和词干提取的组合自动排除了非常常见的词，例如 `it` 和 `in`，从而将句子提炼成原始输入中最重要的标记。
- en: Using just the tokenized and stemmed result, we can infer that the user wishes
    to know about the weather in Amsterdam. Furthermore, we can choose to exclude
    the word `is` from our results. This leaves us with `rain amsterdam`, which is
    enough information for us to make a weather API call.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用分词和词干提取的结果，我们可以推断用户希望了解阿姆斯特丹的天气。此外，我们可以选择排除单词 `is`。这使我们只剩下 `rain amsterdam`，这对于我们进行天气
    API 调用来说是足够的信息。
- en: String distance
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串距离
- en: A string distance measuring algorithm is a calculation of how similar two strings
    are to one another. The strings `smell` and `bell` can be defined as similar,
    as they share three characters. The strings `bell` and `fell` are even closer,
    as they share three characters and are only one character apart from one another.
    When calculating string distance, the string `fell` will receive a higher ranking
    than `smell` when the distance is measured between them and `bell`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串距离测量算法是计算两个字符串之间相似度的计算。字符串 `smell` 和 `bell` 可以定义为相似的，因为它们共享三个字符。字符串 `bell`
    和 `fell` 更接近，因为它们共享三个字符，并且彼此之间只有一个字符的差异。在计算字符串距离时，当测量 `fell` 和 `bell` 之间的距离时，字符串
    `fell` 将比 `smell` 获得更高的排名。
- en: 'The NPM package `natural` provides three different algorithms for string distance
    calculation: Jaro-Winkler, the Dice coefficient, and the Levenshtein distance.
    Their main differences can be described as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: NPM 包 `natural` 提供了三种不同的字符串距离计算算法：Jaro-Winkler、Dice 系数和 Levenshtein 距离。它们的主要区别可以描述如下：
- en: '**Dice coefficient**: This calculates the difference between strings and represents
    the difference as a value between zero and one. Zero being completely different
    and one meaning identical.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dice 系数**：这计算字符串之间的差异，并将差异表示为零到一之间的值。零表示完全不同，一表示完全相同。'
- en: '**Jaro-Winkler**: This is similar to the Dice Coefficient, but gives greater
    weighting to similarities at the beginning of the string.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jaro-Winkler**：这与 Dice 系数类似，但给字符串开头的相似性赋予更大的权重。'
- en: '**Levenshtein distance**: This calculates the amount of edits or steps required
    to transform one string into another. Zero steps means the strings are identical.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Levenshtein 距离**：这计算将一个字符串转换为另一个字符串所需的编辑或步骤数量。零步意味着字符串是相同的。'
- en: 'Let''s use the Levenshtein distance algorithm to demonstrate its use:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Levenshtein 距离算法来演示其用法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A popular use for string distances is to perform a fuzzy search, where the
    search returns values that are a low string distance from the requested query.
    String distance calculation can be particularly useful for bots when processing
    a command with a typo in it. For instance, if a user meant to request the weather
    report for Amsterdam by sending the command `weather amsterdam`, but instead typed
    `weater amsterdam`. By calculating the Levenshtein distance between the strings,
    we can make an educated guess as to the user''s intent. Check out the following
    snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串距离的一个流行用途是执行模糊搜索，搜索结果返回与请求查询具有低字符串距离的值。字符串距离计算在处理包含错别字的命令时对机器人特别有用。例如，如果用户本想通过发送命令
    `weather amsterdam` 请求阿姆斯特丹的天气预报，但错误地输入了 `weater amsterdam`。通过计算字符串之间的 Levenshtein
    距离，我们可以对用户的意图做出合理的猜测。查看以下代码片段：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s the result in Slack:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Slack 上的结果：
- en: '![String distance](img/B05384_05_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![字符串距离](img/B05384_05_05.jpg)'
- en: Calculating string distance can make your bot a lot more user friendly
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算字符串距离可以使你的机器人更加用户友好
- en: We set our tolerance to be quite low in this case, allowing for two mistakes
    or `steps` to indicate a hit. In production code, it would make sense to reduce
    the tolerance to only one step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将容差设置得相当低，允许有两个错误或 `步骤` 来指示命中。在生产代码中，将容差减少到只有一个步骤是有意义的。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when choosing which string similarity algorithm to use, as each might
    determine distance differently. For instance, when using the Jaro-Winkler and
    Dice Coefficient algorithms, a score of 1 indicates that the two strings are identical.
    With the Levenshtein difference, it is the opposite, where 0 means identical and
    the higher the number the larger the string distance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择使用哪种字符串相似度算法时要小心，因为每种算法可能都会以不同的方式确定距离。例如，当使用 Jaro-Winkler 和 Dice 系数算法时，得分为
    1 表示两个字符串完全相同。使用 Levenshtein 差异时则相反，其中 0 表示相同，数字越高表示字符串距离越大。
- en: Inflection
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变位
- en: 'An inflector can be used to convert a noun back and forth from its singular
    and plural forms. This is useful when generating natural language, as the plural
    versions of nouns might not be obvious:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 变位器可以用来在单数和复数形式之间转换名词。这在生成自然语言时很有用，因为名词的复数形式可能并不明显：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code will output `viri` and `octopus`, respectively.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将分别输出 `viri` 和 `octopus`。
- en: 'Inflectors may also be used to transform numbers into their ordinal forms;
    for example, 1 becomes 1st, 2 becomes 2nd, and so on:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 变位器还可以用来将数字转换为它们的序数形式；例如，1 变为 1st，2 变为 2nd，依此类推：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This outputs `25th`, `42nd`, and `111th`, respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将分别输出 `25th`、`42nd` 和 `111th`。
- en: 'Here''s an example of the inflector used in a simple bot command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单机器人命令中使用的变位器的示例：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now when asked what day it is, our bot can respond a little more naturally:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当被问及今天是星期几时，我们的机器人可以回答得更加自然一些：
- en: '![Inflection](img/B05384_05_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![变位](img/B05384_05_06.jpg)'
- en: Inflection can make your bot more personable
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 变位可以让你的人工智能更加亲切
- en: 'This leads us to our next topic: how to display data in an easy-to-understand
    way.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们的下一个主题：如何以易于理解的方式显示数据。
- en: Displaying data in a natural way
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以自然的方式显示数据
- en: 'Let''s build our bot''s weather functionality. To do this, we will be using
    a third-party API called **Open Weather Map**. The API is free to use for up to
    60 calls per minute, with further pricing options available. To obtain the API
    key, you will need to sign up here: [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建机器人的天气功能。为此，我们将使用一个名为 **Open Weather Map** 的第三方 API。该 API 每分钟免费使用最多 60
    次调用，并提供其他定价选项。要获取 API 密钥，您需要在此处注册：[https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that you can pass variables such as API keys into Node from the command
    line. To run the weather bot, you could use the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以从命令行传递变量，例如 API 密钥到 Node。要运行天气机器人，你可以使用以下命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you signed up and obtained your API key, copy and paste the following
    code into `index.js`, replacing `process.env.WEATHER_API_KEY` with your newly
    acquired Open Weather Map key:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您注册并获取了您的 API 密钥，将以下代码复制并粘贴到 `index.js` 中，用您新获得的 Open Weather Map 密钥替换 `process.env.WEATHER_API_KEY`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using familiar code, our bot performs the following tasks:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用熟悉的代码，我们的机器人执行以下任务：
- en: Initializes the stemmer from the natural package and attaches it to the string
    prototype
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从自然包初始化词干提取器并将其附加到字符串原型
- en: Awaits the `weather` command and uses the `getWeather` function to retrieve
    the Open Weather Map weather data via an **Asynchronous JavaScript and XML** (**AJAX**)
    call
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待`weather`命令并使用`getWeather`函数通过**异步JavaScript和XML**（**AJAX**）调用检索Open Weather
    Map的天气数据
- en: Sends a formatted weather message to the channel
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向频道发送格式化的天气信息
- en: 'Here''s the bot in action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是机器人在行动：
- en: '![Displaying data in a natural way](img/B05384_05_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![以自然的方式显示数据](img/B05384_05_07.jpg)'
- en: A simple weatherbot
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的天气机器人
- en: 'After receiving the command and the place name, the bot sends an AJAX request
    to Open Weather Map with the place name as the argument. In return, we get a JSON
    response that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到命令和地点名称后，机器人使用地点名称作为参数向Open Weather Map发送AJAX请求。作为回报，我们得到一个看起来像这样的JSON响应：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note how among the plethora of information we get back there is the full, capitalized
    name of the place and useful information such as minimum and maximum temperature.
    For our bot's initial purpose, we will use the temperature object (`main`), the
    `name` property, and the `description` inside the `weather` object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在返回的大量信息中，有地点的全称和有用的信息，如最低和最高温度。对于我们机器人的初始目的，我们将使用温度对象（`main`）、`name`属性和`weather`对象内的`description`。
- en: Now that we have a simple bot which responds to the command `weather`, let's
    see if we can use NLP to get more specific answers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的机器人，它会对`weather`命令做出响应，让我们看看我们是否可以使用NLP来获得更具体的答案。
- en: Notice how the Open Weather Map AJAX call was abstracted out into the `getWeather`
    function. This means we can use the same function for both command calls and NLP
    calls.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到Open Weather Map的AJAX调用被抽象成`getWeather`函数。这意味着我们可以为命令调用和NLP调用使用相同的函数。
- en: Before we continue, we should discuss the right use case for NLP techniques.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该讨论NLP技术的正确用例。
- en: When to use NLP?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用NLP？
- en: 'It might be tempting to have weatherbot listen to and process all messages
    sent in the channel. This immediately poses some problems:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使天气机器人监听并处理频道中发送的所有消息。这立即提出了一些问题：
- en: How do we know if the message sent is a query on the weather or is completely
    unrelated?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何知道发送的消息是关于天气的查询，还是完全不相关的？
- en: Which geographic location is the query about?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询的是哪个地理位置？
- en: Is the message a question or a statement? For example, the difference between
    *Is it cold in Amsterdam* and *It is cold in Amsterdam*.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是问题还是陈述？例如，*阿姆斯特丹冷吗*和*阿姆斯特丹很冷*之间的区别。
- en: 'Although an NLP-powered solution to the preceding questions could probably
    be found, we have to face facts: it''s likely that our bot will get at least one
    of the above points wrong when listening to generic messages. This will lead the
    bot to either provide bad information or provide unwanted information, thus becoming
    annoying. If there''s one thing we need to avoid at all costs, it''s a bot that
    sends too many wrong messages too often.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能找到解决前面问题的NLP解决方案，但我们必须面对现实：当监听通用消息时，我们的机器人可能会至少犯上述错误中的一个。这会导致机器人提供错误信息或提供不必要的信息，从而变得令人烦恼。我们无论如何都要避免的是，机器人频繁地发送太多错误信息。
- en: 'Here''s an example of a bot using NLP and completely missing the point of the
    message sent:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个机器人使用NLP并完全忽略发送信息要点的例子：
- en: '![When to use NLP?](img/B05384_05_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![何时使用NLP?](img/B05384_05_08.jpg)'
- en: A clearly misunderstood message
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显被误解的信息
- en: If a bot were to often mistake your unrelated messages for actual commands,
    you can imagine users disabling your bot very quickly after enabling it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人经常将你的不相关消息误认为是实际命令，你可以想象用户在启用它后很快就会禁用它。
- en: The best possible solution would be to create a bot that has human-level natural
    language processing. If that sentence doesn't concern you, then consider that
    human-level natural language processing is considered an AI-complete problem.
    Essentially, it is equivalent to attempting to solve the problem of making computers
    as intelligent as humans.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案可能是创建一个具有人类水平自然语言处理能力的机器人。如果这句话没有引起你的注意，那么考虑一下，人类水平的自然语言处理被认为是人工智能的完整问题。本质上，它等同于尝试解决使计算机像人类一样智能的问题。
- en: 'Instead, we should focus on how to make our bot perform as best as possible
    with the resources at hand. We can start by introducing a new rule: use NLP as
    an enhancement for your bot, not as a main feature.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该专注于如何让我们的机器人利用现有资源尽可能好地表现。我们可以从引入一条新规则开始：将NLP作为机器人增强功能，而不是主要功能。
- en: 'An example of this is to only use NLP techniques when the bot is directly addressed
    in a mention. A mention in a Slack channel is when a user sends a message directly
    to another user in a public channel. This is done by prefacing the user''s name
    with the `@` symbol. Bots can also be mentioned, which means we should be able
    to process the weather command in two ways:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是在机器人被直接提及时才使用NLP技术。在Slack频道中提及是在公共频道中用户直接向另一个用户发送消息时发生的。这是通过在用户名前加上`@`符号来完成的。机器人也可以被提及，这意味着我们应该能够以两种方式处理天气命令：
- en: 'The user prefaces their request with the command `weather`: `weather is it
    raining in Amsterdam`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在请求前加上命令`weather`：`weather is it raining in Amsterdam`
- en: The user uses a mention `@weatherbot is it raining in Amsterdam`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用提及`@weatherbot is it raining in Amsterdam`
- en: Mentions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提及
- en: 'To implement the second point, we need to revisit our `Bot` class and add mention
    functionality. In the `Bot` class'' constructor, replace the `RTM_CONNECTION_OPENED`
    event listener block with the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第二点，我们需要重新访问我们的`Bot`类并添加提及功能。在`Bot`类的构造函数中，用以下内容替换`RTM_CONNECTION_OPENED`事件监听器块：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only change here is the addition of the bot''s `id` to the `this` object.
    This will help us later. Now, replace the `respondTo` function with this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的改变是将机器人的`id`添加到`this`对象中。这将有助于我们以后的操作。现在，用以下内容替换`respondTo`函数：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've improved the `respondTo` function by first checking whether `this.id`
    exists. If not, it means that we've not yet successfully connected to Slack. Therefore,
    we wait till Slack has connected (remember how we set `this.id` in the constructor
    after connecting) and then proceed. This is the second time we listen for the
    `RTM_CONNECTION_OPENED` event. Luckily, the first time it happens in the `Bot`
    class' constructor, which means this listener will always trigger second as it
    was added later. This ensures that `this.id` is defined once the event triggers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先检查`this.id`是否存在来改进了`respondTo`函数。如果没有，这意味着我们尚未成功连接到Slack。因此，我们等待Slack连接（记得我们在构造函数中连接后设置了`this.id`），然后继续。这是第二次监听`RTM_CONNECTION_OPENED`事件。幸运的是，第一次发生在`Bot`类的构造函数中，这意味着这个监听器总是作为第二个触发，因为它是在之后添加的。这确保了在事件触发时`this.id`已被定义。
- en: 'The function now takes either a string (the keywords we''re looking for) or
    an object as its first parameter. In the case of an object, we check to see whether
    the mention property is truthy; if so, we create a regular expression that purposefully
    looks for the mention syntax. When a message is received, a mention takes the
    following structure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在接受一个字符串（我们正在寻找的关键词）或一个对象作为其第一个参数。在对象的情况下，我们检查提及属性是否为真；如果是，我们创建一个故意查找提及语法的正则表达式。当收到消息时，提及具有以下结构：
- en: '`<@[USER_ID]>: [REST OF MESSAGE]`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`<@[USER_ID]>: [REST OF MESSAGE]`'
- en: 'Switch back to `index.js` and let''s try out our new code by replacing the
    previous `respondTo` block of `weather`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回`index.js`，让我们通过替换之前的`weather`的`respondTo`块来尝试我们的新代码：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now when we mention our bot and pass a city name, we get the following result:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们提及我们的机器人并传递一个城市名，我们得到以下结果：
- en: '![Mentions](img/B05384_05_09.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![提及](img/B05384_05_09.jpg)'
- en: Mentions can be used to identify specific behavior
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 提及可以用来识别特定的行为
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mentions are a great way to ensure that the message sent is meant to be a command
    for your bot. When implementing a natural language solution, it is highly recommended
    you use mentions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提及是确保发送的消息意图是命令你的机器人的有效方式。在实施自然语言解决方案时，强烈建议你使用提及。
- en: Now with mentions in place, let's look at how we're going to answer weather-related
    questions in an NLP way. We briefly talked about classification and the training
    of NLP systems earlier. Let's revisit that topic and see how we can use it for
    our weather bot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了提及，让我们看看我们将如何以自然语言处理（NLP）的方式回答与天气相关的问题。我们之前简要地讨论了分类和NLP系统的训练。让我们回顾一下这个话题，看看我们如何为我们的天气机器人使用它。
- en: Classifiers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类器
- en: 'Classification is the process of training your bot to recognize a phrase or
    pattern of words and to associate them with an identifier. To do this, we use
    a classification system built into `natural`. Let''s start with a small example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分类是将你的机器人训练成识别短语或单词模式并将其与标识符关联的过程。为此，我们使用`natural`内置的分类系统。让我们从一个简单的例子开始：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first log prints:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个日志输出：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second log prints:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个日志输出：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The classifier stems the string to be classified first, and then calculates
    which of the trained phrases it is the most similar to by assigning a weighting
    to each possibility.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 分类器首先提取要分类的字符串，然后通过为每个可能性分配权重来计算它与训练短语中最相似的是哪一个。
- en: 'You can view the weightings by using the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码查看权重：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To get accurate and reliable results, you must train your bot with potentially
    hundreds of phrases. Luckily, you can also import training data JSON files into
    the classifier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得准确可靠的结果，你必须用可能成百上千的短语来训练你的机器人。幸运的是，你还可以将训练数据JSON文件导入分类器。
- en: 'Save your classifier training data by creating a `classifier.json` file in
    your directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在你的目录中创建一个`classifier.json`文件来保存你的分类器训练数据：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Retrieve the same file with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码检索相同的文件：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let's try and use classifiers to power our weatherbot.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用分类器来为我们的weatherbot提供动力。
- en: Using trained classifiers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用训练好的分类器
- en: An example `classifier.json` file that contains training data for weather is
    included with this book. For the rest of this chapter, we will assume that the
    file is present and that we are loading it in via the preceding method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含一个包含天气训练数据的`classifier.json`文件示例。在本章的其余部分，我们将假设该文件存在，并且我们通过前面的方法加载它。
- en: 'Replace your `respondTo` method call with the following snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的`respondTo`方法调用替换为以下代码片段：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the Node process and ask weatherbot a series of natural language questions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Node进程并向weatherbot提出一系列自然语言问题：
- en: '![Using trained classifiers](img/B05384_05_10.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用训练好的分类器](img/B05384_05_10.jpg)'
- en: Weatherbot can now understand conversational language
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Weatherbot现在可以理解会话语言
- en: 'Let''s look at the code and see what''s going on:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码，看看发生了什么：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we check to see whether the keyword `set` is used immediately after the
    `@weatherbot` mention. If yes, this sets the following arguments to be the default
    city of the user. We use a simple settings object here, but this could be improved
    by using a data store such as Redis, explained in [Chapter 4](ch04.html "Chapter 4. Using
    Data"), *Using Data*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查关键字`set`是否紧跟在`@weatherbot`提及之后。如果是，则将这些参数设置为用户的默认城市。这里我们使用了一个简单的设置对象，但可以通过使用如Redis这样的数据存储来改进，如第4章[使用数据](ch04.html
    "第4章。使用数据")中所述。
- en: 'You can see an example of the `set` behavior in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下屏幕截图中看到`set`行为的示例：
- en: '![Using trained classifiers](img/B05384_05_11.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![使用训练好的分类器](img/B05384_05_11.jpg)'
- en: Setting a city saves users from having to type in their place name for each
    query
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设置城市可以节省用户在每次查询时输入地点名称的时间
- en: 'Next, we attempt to find the place we want to get weather information for:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试找到我们想要获取天气信息的地方：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We expect all weather queries with a place name to follow the pattern `[condition]
    in [place name]`. This means we can make a reasonable assumption that all tokens
    after the word `in` are the place name to use in our AJAX call.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望所有包含地点名称的天气查询都遵循`[条件] in [地点名称]`的模式。这意味着我们可以合理地假设所有在单词`in`之后的标记都是我们在AJAX调用中要使用的地点名称。
- en: If the word `in` does not appear and there is no set place name, then we send
    back an error message with a best guess example of how to use weatherbot.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现单词`in`并且没有设置地点名称，那么我们将发送一个包含最佳猜测示例的错误消息，说明如何使用weatherbot。
- en: This is, of course, not the most ideal way to detect a place name—determining
    which part of the phrase is a place name is notoriously difficult, especially
    when the name in question comprises multiple words like `New York` or `Dar es
    Salaam`. One possible solution would be to train our bot with a series of city
    name classifiers (essentially one training phrase per city). Other solutions include
    the Query GeoParser [http://www2009.eprints.org/239/](http://www2009.eprints.org/239/)
    and the Stanford Named Entity Recognizer [http://nlp.stanford.edu/software/CRF-NER.shtml](http://nlp.stanford.edu/software/CRF-NER.shtml).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是检测地点名称的最佳方法——确定短语中哪一部分是地点名称是非常困难的，尤其是当涉及到的名称由多个单词组成，如`New York`或`Dar es
    Salaam`时。一个可能的解决方案是使用一系列城市名称分类器（本质上每个城市一个训练短语）来训练我们的机器人。其他解决方案包括Query GeoParser
    [http://www2009.eprints.org/239/](http://www2009.eprints.org/239/)和斯坦福命名实体识别器[http://nlp.stanford.edu/software/CRF-NER.shtml](http://nlp.stanford.edu/software/CRF-NER.shtml)。
- en: 'Next we use the classifier to identify which key words the message should be
    associated with:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用分类器来识别消息应关联哪些关键词：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Some of the classifier''s phrases are added with an array as the second argument,
    for example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分类器的短语作为第二个参数添加了一个数组，例如：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This means that the returned value from the `classifier.classify` method is
    a comma-separated string value. We transform it into a JavaScript array by using
    the `Array.split` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`classifier.classify`方法返回的值是一个以逗号分隔的字符串值。我们通过使用`Array.split`方法将其转换成JavaScript数组。
- en: 'Finally, we set the typing indicator, which is good practice when making an
    asynchronous call:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置打字指示器，这在进行异步调用时是一个好的实践：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The value at index 0 of the option object is the state of the question, in this
    case whether the message is related to the temperature, condition, or generic
    weather.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选项对象的索引0处的值是问题的状态，在这种情况下是消息是否与温度、状况或通用天气相关。
- en: 'Our options are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下选项：
- en: '**Temperature**: Send the temperature (in Celsius) to the channel'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**温度**: 将温度（摄氏度）发送到频道'
- en: '**Conditions**: Send the weather conditions (for example, raining and windy)
    to the channel'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状况**: 将天气状况（例如，下雨和刮风）发送到频道'
- en: '**Weather**: Send both the conditions and temperature to the channel'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**天气**: 将状况和温度都发送到频道'
- en: It is important to understand the underlying concepts of classification and
    training to build a smarter bot. It is, however, possible to abstract the problem
    of obtaining training data by using the third-party service wit.ai ([https://wit.ai/](https://wit.ai/)).
    wit.ai is a free service, created by Facebook, which allows you to train phrases
    (referred to as **entities** by wit.ai) and to retrieve analysis on a given phrase
    easily and quickly via an AJAX request.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理解分类和训练的底层概念对于构建更智能的机器人很重要。然而，通过使用第三方服务wit.ai ([https://wit.ai/](https://wit.ai/))可以抽象出获取训练数据的问题。wit.ai是由Facebook创建的免费服务，允许你训练短语（由wit.ai称为**实体**），并通过AJAX请求轻松快速地检索给定短语的分析。
- en: Alternatively, you could use services such as api.ai ([https://api.ai/](https://api.ai/))
    or Microsoft's LUIS ([https://www.luis.ai/](https://www.luis.ai/)). Bear in mind,
    however, that although these services are free and easy to use, it is not guaranteed
    that they will be free or even around in the future. Unless you are attempting
    to build something that requires extremely accurate NLP services, it is almost
    always better to create your own implementation with open source NLP libraries.
    This has the added benefit of controlling and owning your own data, something
    which is not guaranteed when using a third-party service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用类似api.ai ([https://api.ai/](https://api.ai/))或微软的LUIS ([https://www.luis.ai/](https://www.luis.ai/))的服务。然而，请记住，尽管这些服务免费且易于使用，但并不能保证它们将来仍然是免费的，甚至可能存在。除非你试图构建需要极其精确NLP服务的项目，否则几乎总是更好的选择是使用开源NLP库创建自己的实现。这还有一个额外的优点，即可以控制和拥有自己的数据，这是在使用第三方服务时无法保证的。
- en: Now that we know how to process language, we should take a look at how to transform
    our data into human understandable natural language.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理语言，我们应该看看如何将我们的数据转换成人类可理解的自然语言。
- en: Natural language generation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然语言生成
- en: Natural language can be defined as a conversational tone in a bot's response.
    The purpose here is not to hide the fact that the bot is not human, but to make
    the information easier to digest.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 自然语言可以定义为机器人的回答中的对话语气。这里的目的是不是隐藏机器人不是人类的事实，而是使信息更容易消化。
- en: The `flavorText` variable from the previous snippet is an attempt to make the
    bot's responses sound more natural; in addition, it is a useful technique to cheat
    our way out of performing more complex processing to reach a conversational tone
    in our response.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码片段中的`flavorText`变量是尝试让机器人的回答听起来更自然；此外，它是一种有用的技巧，可以避免执行更复杂的处理，以便在回答中达到对话的语气。
- en: 'Take the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '![Natural language generation](img/B05384_05_14.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![自然语言生成](img/B05384_05_14.jpg)'
- en: Weatherbot's politician-like response
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 天气机器人的政治家式回答
- en: Notice how the first weather query is asking whether it's cold or not. Weatherbot
    gets around giving a yes or no answer by making a generic statement on the temperature
    to every question.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一个天气查询是询问是否寒冷。天气机器人通过针对每个问题做出关于温度的通用陈述来避免给出是或否的回答。
- en: This might seem like a cheat, but it is important to remember a very important
    aspect of NLP. *The more complex the generated language, the more likely it is
    to go wrong.* Generic answers are better than outright wrong answers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一种欺骗，但重要的是要记住NLP的一个非常重要的方面。*生成的语言越复杂，出错的可能性就越大。通用的回答比完全错误的回答要好。*
- en: This particular problem could be solved by adding more keywords to our classifiers
    and adding more phrases. Currently, our `classifier.json` file contains 50 phrases
    related to the weather; adding more phrases could get us a clearer idea of what
    is being asked of weatherbot.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的问题可以通过向我们的分类器添加更多关键词和短语来解决。目前，我们的`classifier.json`文件包含与天气相关的50个短语；添加更多短语可以帮助我们更清楚地了解对weatherbot的提问。
- en: This leads us to a very important point in the pursuit of natural language generation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了我们在追求自然语言生成过程中一个非常重要的观点。
- en: When should we use natural language generation?
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时应该使用自然语言生成？
- en: 'Sparingly, is the answer. Consider Slackbot, Slack''s own in-house bot used
    for setting up new users, amongst other things. Here''s the first thing Slackbot
    says to a new user:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是偶尔。以Slackbot为例，这是Slack自己内部使用的机器人，用于设置新用户，以及其他一些事情。以下是Slackbot对新用户说的第一句话：
- en: '![When should we use natural language generation?](img/B05384_05_15.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![何时应该使用自然语言生成？](img/B05384_05_15.jpg)'
- en: The humble bot
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 谦逊的机器人
- en: Immediately, the bot's restrictions are outlined and no attempts to hide the
    fact that it is not human are made. Natural language generation is at its best
    when used to transform data-intensive constructs such as JSON objects into easy
    to comprehend phrases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，机器人的限制被概述出来，并且没有试图隐藏它不是人类的事实。当用于将数据密集型结构，如JSON对象，转换为易于理解的短语时，自然语言生成效果最佳。
- en: The Turing Test is a famous test developed in 1950 by Alan Turing to assess
    a machine's ability to make itself indistinguishable from a human in a text-only
    sense. Like Slackbot, you should not strive to make your bot Turing Test complete.
    Instead, focus on how your bot can be the most useful and use natural language
    generation to make your bot as easy to use as possible.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵测试是由Alan Turing于1950年开发的一个著名测试，用于评估机器在纯文本交流中使自己与人类不可区分的能力。像Slackbot一样，你不应该努力使你的机器人通过图灵测试。相反，专注于你的机器人如何变得最有用，并使用自然语言生成使你的机器人尽可能易于使用。
- en: The uncanny valley
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诡异谷
- en: The uncanny valley is a term used to describe systems that act and sound like
    humans, but are somehow slightly off. This slight discrepancy actually leads to
    the bot feeling a lot more unnatural, and this is the exact opposite of what we
    are trying to accomplish with natural language generation. Instead, we should
    avoid trying to make the bot perfect in its natural language responses; the chances
    of finding ourselves in the uncanny valley get higher the more human-like we try
    to make a bot sound.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 诡异谷是一个用来描述那些行为和声音都像人类，但 somehow 稍微有些不对劲的系统的术语。这种轻微的差异实际上会导致机器人感觉更加不自然，这与我们通过自然语言生成所试图达成的目标正好相反。相反，我们应避免试图使机器人在自然语言响应中完美无缺；我们试图使机器人听起来越像人类，我们陷入诡异谷的可能性就越高。
- en: 'Instead, we should focus on making our bots useful and easy to use, over making
    its responses natural. A good principle to follow is to build your bot to *be
    as smart as a puppy*, a concept championed by Matt Jones ([http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/](http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/)):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该专注于使我们的机器人有用且易于使用，而不是使其响应自然。一个很好的原则是构建一个像小狗一样聪明的机器人，这是由Matt Jones([http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/](http://berglondon.com/blog/2010/09/04/b-a-s-a-a-p/))所倡导的：
- en: '*"Making smart things that don''t try to be too smart and fail, and indeed,
    by design, make endearing failures in their attempts to learn and improve. Like
    puppies."*'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"制作出聪明但不过度聪明且失败的东西，并且确实，通过设计，在学习和改进的过程中展现出可爱的失败。就像小狗一样。"*'
- en: Let's expand our weatherbot to make the generated response sound a little more
    natural (but not too natural).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的weatherbot，使其生成的响应听起来更加自然（但不要太自然）。
- en: 'First, edit the `getWeather` function to include `data` as a final argument
    in its callback call:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编辑`getWeather`函数，使其回调调用中包含`data`作为最后一个参数：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then add the `data` variable to the callback we assign in the mention `respondsTo`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`data`变量添加到我们在`respondsTo`中指定的回调函数中：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `switch` statement within the `getWeather` call, replace the `weather`
    case with this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getWeather`调用中的`switch`语句中，将`weather`情况替换为以下内容：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Asking for the weather in a city will now instruct our bot to send this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 询问一个城市的天气现在将指示我们的机器人发送以下内容：
- en: '![The uncanny valley](img/B05384_05_16.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![奇异的谷](img/B05384_05_16.jpg)'
- en: Weatherbot can now be a bit more specific with its reporting
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 天气机器人现在可以对其报告更加具体
- en: Here, we've simply taken the JSON returned from the AJAX call and formatted
    the data into something a bit more legible by humans. Rainfall is included, but
    only if there actually was any in the last 3 hours (if not, the `rain` property
    is omitted from the returned data). Cloud cover is represented by a percentage,
    which is perfect for us as we can assign predetermined statements (`patchy`, `almost
    completely clear` and `clear skies`) depending on that percentage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地从AJAX调用返回的JSON中提取数据，并将其格式化为对人类来说更易读的形式。包括降雨量，但仅当在过去的3小时内确实有降雨时（如果没有，则从返回的数据中省略`rain`属性）。云量以百分比表示，这对我们来说很完美，因为我们可以根据那个百分比分配预定的陈述（如`patchy`、`almost
    completely clear`和`clear skies`）。
- en: When generating natural language, think of how your data can be presented. Percentages
    are an excellent way of assigning a verbal value. For example, anything between
    80 and 100 percent can use adverbs like `extremely` or `very`, whereas we can
    use `barely` and `very little` for 0 to 20 percent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成自然语言时，考虑如何呈现你的数据。百分比是分配口头价值的一个极好方式。例如，80到100%之间的任何事物都可以使用副词如`extremely`或`very`，而对于0到20%的情况，我们可以使用`barely`和`very
    little`。
- en: For some data sets, a paragraph might be easier to digest rather than a list
    or pure data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些数据集，一段文字可能比列表或纯数据更容易消化。
- en: The result is a bot that, in a conversational tone, can give a weatherman-like
    weather report on the area in question.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个机器人，在对话语调中，可以对相关地区的天气进行天气预报员般的报告。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what NLP is and how it can be leveraged to make
    a bot seem far more complex than it really is. By using these techniques, natural
    language can be read, processed, and responded to in equally natural tones. We
    also covered the limitations of NLP and understood how to differentiate between
    good and bad uses of NLP.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了自然语言处理（NLP）是什么以及如何利用它使机器人看起来比实际复杂得多。通过使用这些技术，自然语言可以被读取、处理并以同样自然的语调进行响应。我们还涵盖了NLP的限制，并了解了如何区分NLP的良好和不良使用。
- en: In the next chapter, we will explore the creation of web-based bots, which can
    interact with Slack using webhooks and slash commands.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨基于Web的机器人的创建，这些机器人可以使用webhooks和slash命令与Slack进行交互。
