- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is one of the most relevant practices these days; it has become much
    more popular in the last couple of decades than in the past. Today, we build complex
    software with many dependencies and requirements that evolve over time. I strongly
    believe that testing is key when you are learning a new language or tool because
    it will provide you with a security net that will allow you to take more risks
    and move faster without breaking the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the importance of testing and how to choose
    the right type of testing for your application. You will write your first test,
    and then we will learn about creating test suites by grouping related tests, demonstrating
    both Node.js core testing and the Jest library.
  prefs: []
  type: TYPE_NORMAL
- en: Writing good tests is not easy, but by the end of this chapter, you will have
    a clear idea of what principles to follow every time and how you can use a testing
    coverage tool to extend and refactor your tests over time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will introduce **Test-Driven Development** (**TDD**) by solving
    some edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is testing important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test approach and philosophy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should I test my code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering code coverage tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/aK572sFboEM](https://youtu.be/aK572sFboEM)
  prefs: []
  type: TYPE_NORMAL
- en: Why is testing important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapters, modern applications are complex, have many
    moving parts, and will have dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we can say that testing is important because it helps us to ensure
    that our code is working as expected and that we are not introducing bugs when
    we are adding new features or fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a complex culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is much more than just writing some code to validate your application.
    It’s a culture that has many ideas, principles, practices, and tools... Have you
    heard of TDD? BDD? Unit tests? Integration tests? End-to-end tests? Mocks? Stubs?
    Spies? There are many concepts to learn and understand, and we will explore some
    of them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing has to be a team activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing will help you to onboard new developers to your team easily. You can
    join other teams to help them build new features or fix bugs even if you don’t
    know the code base in depth.
  prefs: []
  type: TYPE_NORMAL
- en: I love to see tests as documentation for the application, or even better, as
    the agreement to the world of how your application should behave in certain scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: But testing is a team effort. It’s not just the developer’s responsibility to
    write tests, the same way that it’s not just the developer’s responsibility to
    write secure code. The whole team should be involved in the process, and the team
    should have a culture of testing and stick to it over time.
  prefs: []
  type: TYPE_NORMAL
- en: Automating your tests is essential. Without automation, we would need to test
    our applications manually. It means that we will do a lot of repetitive tasks
    that are prone to errors, and we will need to spend a lot of time ensuring that
    our application is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: With tests, we can automate the process and ensure that our application is working
    as expected. We can run the tests on our local machine, or on a remote machine
    before a pull request is merged or we deploy the software. We can run the tests
    in different environments, and we can run them in parallel to speed up the process.
  prefs: []
  type: TYPE_NORMAL
- en: Take advantage now
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am used to doing tests in my day-to-day work, and I can say that they’re a
    great tool that has helped me to build better software. But overall, they have
    helped me to learn new things and improve my skills.
  prefs: []
  type: TYPE_NORMAL
- en: When you must use a new language or tool, you can use tests to learn how it
    works and explore the features. You can use tests to learn how this new thing
    works and do your own experiments while learning.
  prefs: []
  type: TYPE_NORMAL
- en: But if you are not used to doing tests, it can be a little bit hard to learn
    Node.js and testing at the same time. So, I recommend you learn Node.js first
    and then take a more in-depth look at testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will build a web application and use tests to ensure
    that our application is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You will face many challenges while adopting the testing culture. As with any
    cultural change, it’s not easy to start doing tests. It’s a challenge that you
    will need to overcome, and you will need to invest time to learn how to do it.
    But I can say that it’s worth it.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with a team, you will need to convince your team to start doing
    tests and consolidate the culture over time. It’s not easy, but it’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: You can always start doing tests in your own code and show the benefits to your
    team. You can start with a pet project or a proof-of-concept test and convince
    the whole team.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you will need to invest time to learn how to do it, and even when
    you know how to do it, you will need to invest time to write the tests. That time
    will always be bigger in comparison with the time that you will need to just write
    the code. But you will save time in the long term when you need to fix bugs or
    add new features and in preventing bugs in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on the motivations behind the adoption of testing, it
    is time to learn, in the next section, about the different types of tests that
    are available for our applications and how other industries have built solid products
    using different testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing approach and philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that we don’t realize when we are starting to learn about
    testing is that there are many different kinds of tests, and each one has a different
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is wildly used in the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the real world, testing is used in many industries. For example, if we want
    to test the quality of a car being manufactured in a factory, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test the engine in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the car in a controlled environment to ensure that it’s working as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the car in a real environment to ensure that it’s working as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the individual components of the car to ensure certain quality standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the car against a wall or other objects to ensure that it’s safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The automobile industry has one of the most interesting testing frameworks in
    terms of engineering in the world. Most cars that are manufactured today, for
    the vast majority of end users, were previously tested in many ways, including
    crash simulations to evaluate the potential damages. In the following figure,
    you can see how one of these tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Image by Wikimedia https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg](img/B21678_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Image by Wikimedia [https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg](https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Software products are no different. Just to give you an idea, we can test the
    web application components in isolation, or we can test the whole application
    from the perspective of the end user. There’s also the option to just test the
    performance of our application by making a lot of requests with different structures
    to our application and detecting any bottlenecks and inefficiencies. We can even
    test the security of our application by doing penetration tests and trying to
    hack our application.
  prefs: []
  type: TYPE_NORMAL
- en: The test pyramid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we can say that there are many different types of tests and each one has
    a different purpose. Let’s have a look at the test pyramid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Image by Martin Fowler in “The practical test pyramid” https://martinfowler.com/articles/practical-test-pyramid.html](img/B21678_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Image by Martin Fowler in “The practical test pyramid” [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the base of the pyramid is unit tests, which are more isolated
    and faster to run. At the top of the pyramid, we have UI tests, which are more
    expensive (as they require more integration) and are slower to run.
  prefs: []
  type: TYPE_NORMAL
- en: Using the car example, we can say that unit tests are like testing the engine
    in isolation, and UI tests are like testing the car in a real environment.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily understand that testing the engine in isolation is faster and
    cheaper than testing the car in a real environment because we don’t need to build
    the whole car to test the engine, prepare paperwork, coordinate with the insurance
    companies, or bring on more staff such as drivers and mechanics. Also, testing
    the car in a real environment can lead to impacts by external factors such as
    the weather, traffic, and road conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, we can just build the engine and test it in isolation inside
    the factory with the tools and necessary people. We can do it faster and cheaper,
    but this test won’t be able to detect some issues that we can have when we are
    testing the car in a real environment.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the same way, we can say that unit tests are faster and cheaper to run
    than UI tests, but UI tests will be able to detect some issues that we can’t detect
    with unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on unit tests, but we will have a look at other
    types of tests as well in the following chapters when we will build the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear on the different types of tests, it is time to be pragmatic
    and explore how to build our first test case using different libraries together
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How should I test my code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the history of JavaScript, most developers didn’t have the culture of
    testing their code while JavaScript was limited to the browser and used almost
    exclusively to build relatively simple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the evolution of the language and the community, we now have a
    lot of tools and frameworks to help us build tests.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks and libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a clear idea of how to test your code, you can easily migrate
    from one tool to another until you find the one that fits your needs best.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the promising Node.js test core library and
    the most popular test framework for web development, Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We are living in a transitional period where the Node.js core library is evolving
    to provide a better experience to developers. So, probably in the future, it will
    be the default tool to use. But for now, if you are new to testing, I recommend
    you use Jest because there are more tutorials and blog posts and the API is more
    stable.
  prefs: []
  type: TYPE_NORMAL
- en: Our first test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at a simple test, and then we’ll explore the different parts
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are testing the sum function. First, we import the `describe`
    and `it` functions from the `node:test` module. Then, we import the `assert` function
    from the `node:assert` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe` function is used to group tests. In this case, we are grouping
    all the tests related to the `utils` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `it` function is used to define a test. In this case, we are defining a
    test that should sum two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are using the `assert` function to check that the result of the
    `sum` function is the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can say that a test is composed of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Where we define the data that we need to run the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: Where we run the code that we want to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Where we check that the result of the code is the expected one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing principles and goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some principles that we should follow when we are building tests.
    For me, these principles can be summarized into three goals, which are fast, trustable,
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests should be fast to run and write. We will run this test many times,
    so if the test is slow to run, we will lose a lot of time waiting for it to finish.
    But the worst part is that we will be tempted to run the test less frequently
    or write fewer tests.
  prefs: []
  type: TYPE_NORMAL
- en: Then, testing will be a frustrating experience for you and your team. In small
    projects, you will have a few dozen tests, but in big projects, you can have thousands
    of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you have a test that on average takes one second to run, you will lose one
    second every time you run the test. If you have 1,000 tests, you will lose 1,000
    seconds, which is more than 16 minutes! In most cases, you will have the option
    to use concurrency and run the tests in parallel, so the total time will be much
    lower. But it requires an extra step to set up ([https://nodejs.org/api/test.html#runoptions](https://nodejs.org/api/test.html#runoptions)).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to dedicate time and resources to refactor and improve your tests
    in big projects to keep them fast.
  prefs: []
  type: TYPE_NORMAL
- en: Trustable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests should be trustable. If you have flaky tests (that is, tests that
    fail randomly), your team will be very frustrated and will lose confidence in
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid this situation, we should follow these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolated**: We need to isolate the tests from external factors such as the
    network, filesystem, database, and time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable and deterministic**: We need to be able to run the tests many
    times and get the same results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-contained and independent**: We need to be able to run any tests in
    isolation and get the same results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tests are code as well, so we need to maintain them in the same way as we maintain
    our production code. We should follow these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readable and explicit**: Tests should be easy to read and understand. They
    have to be flexible in order to evolve with the code that we are testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focused**: A single test should test a single thing. If we have a test that
    is testing more than one thing, we won’t be able to know exactly what is failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Small and simple**: It is better to have many small and simple tests than
    a few big and complex tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You wrote your first test and now the mechanics should be clearer.
    In the next section, we will learn how we can build a full test suite to cover
    multiple cases and how to automate some steps.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build our first test suite. We will build a test suite
    for the `utils` module that we created and published in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `node:test` and `node:assert` modules to build our test suite,
    and then we will build the same tests using the J`est` framework, so we can compare
    both approaches and see the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Utils module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new folder and then initialize a new Node.js project
    with `npm init`. Then we will create a `utils.js` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is very simple. The `sum` function will sum two numbers and the `multiply`
    function will multiply two numbers. Then the tests should be very simple as well.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we need to test that the `sum` function is summing two numbers and
    the `multiply` function is multiplying two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Test core library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, Node.js has introduced a new core library to help us to build tests.
    This library is called `assert` and it’s a core library, so we don’t need to install
    it. We can just import it and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the npm scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the following NPM scripts to our `package.json` file and add `type:"module"`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have chosen `type: "module"` to enable the ESM syntax by default,
    so we can use the import keyword in the files directly. You can find more information
    about how to import modules in [*Chapter 6*](B21678_06.xhtml#_idTextAnchor171)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the test suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a new folder, `node_test`, and include a new file, `utils.test.js`,
    inside it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that we are using `../` to refer to parent directories
    from the current file. That way, we can import files from anywhere on the computer.
    It is also possible to use the absolute path to a specific resource. You can find
    more details about the differences at [https://www.redhat.com/sysadmin/linux-path-absolute-relative](https://www.redhat.com/sysadmin/linux-path-absolute-relative).
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Terminal output](img/B21678_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the terminal uses distinct colors to show us the results of the
    tests. In this case, we have two tests and both are passing. As you can see, the
    output is very simple and is using the texts that we defined in the `describe`
    and `it` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Jest library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jest is a JavaScript testing framework that is very popular in the JavaScript
    community. It’s very easy to use and has a lot of features that will help us to
    build and maintain our test suite, especially if you are doing frontend development
    using modern frameworks as libraries, such as Angular, React, or Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to install `Jest` in our project as a development dependency.
    We can do it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Jest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we had the test previously set up for the Node.js core library, we will need
    to use a custom configuration for Jest. In a real project, we will use only one
    testing framework, and in that case, we can configure Jest using `npx` `jest@29
    --init`.
  prefs: []
  type: TYPE_NORMAL
- en: The `npx` command will execute the `Jest` command that we have installed in
    our project. The `--init` flag will create a configuration file for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new file, `jest.config.js`, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`modulePathIgnorePatterns` will ignore the `node_test` folder, so we can ignore
    the tests that we have created with the Node.js core library. `<rootDir>` is a
    reference to the folder where `jest.confg.js` is in this case, so it is easier
    to reference other resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As Jest does not support ESM modules yet, we will use Babel ([https://babeljs.io/](https://babeljs.io/))
    to transpile the code. We will create a new file, `.babelrc`, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will install the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding the npm scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the following npm scripts to our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding the test suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a new folder, `jest_test`, and include a new file, `utils.test.js`,
    inside it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is very similar to the code that we created for the
    Node.js core library. The only difference is in how we manage the assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note also that we are not importing the `describe` and `it` functions. This
    is because Jest provides these functions for us and we don’t need to import them.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can run the tests with the following command: `npm` `run jest-test`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Terminal output](img/B21678_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output is very similar to the output that we saw with the
    Node.js core library. The only difference is that the output is using different
    colors, and the text is slightly different. But the most important thing is that
    we have the same information.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are quite confident about our tests, but when the source code is growing
    every day, you need an additional tool that helps you know what code has been
    covered by tests or not. So, in the next section, we will learn in detail how
    we can use the test coverage to generate reports that will help us to improve
    the tests in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering code coverage tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are building a test suite, we need to make sure that we are covering
    all the code that is critical in scenarios that make sense for our purpose. This
    is called **code coverage** and it’s a very important metric to measure the quality
    of our test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Some people say that we need to have 100% code coverage, but this is not always
    true or practical. In my opinion, code coverage is a metric that helps us to detect
    the code that is not covered by our tests or code that has been over-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, it is a metric that can help us to skim the code and detect potential
    tests that we need to add or remove.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, code coverage was a feature that was provided by third-party libraries
    such as Istanbul ([https://istanbul.js.org/](https://istanbul.js.org/)). But now,
    Node.js and Jest provide this feature out of the box, so we don’t need to install
    any third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: Jest library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the following npm script to our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Node.js has an experimental feature that we can use to generate code coverage.
    We need to use the `--experimental-test-coverage` flag to enable this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add a new function, `substract`, to our `utils.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s run the code coverage for both Node.js and Jest to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Node.js will generate a `coverage` folder with the results. We
    can open the `index.html` file in our browser to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Terminal output](img/B21678_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have 66.67% code coverage for the functions, as we don’t
    have any coverage for the `subtract` function.
  prefs: []
  type: TYPE_NORMAL
- en: Jest report
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the code coverage with Jest is very similar to running the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Terminal output](img/B21678_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have the same code coverage as with Node.js. This is because
    both tools are used in the same way to calculate the code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage UI report
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In both cases, we have generated a `coverage` folder with the results. We can
    open the `index.html` file located in `coverage/lcov-report` in our browser to
    see the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 Web browser report](img/B21678_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 Web browser report
  prefs: []
  type: TYPE_NORMAL
- en: We can explore in detail what is and is not covered in `utils.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Web browser report](img/B21678_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Web browser report
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `subtract` function is not covered by our tests. So, here
    we have the opportunity to improve our tests.
  prefs: []
  type: TYPE_NORMAL
- en: The code coverage report is a great way to understand your tests, especially
    when you are working with a large code base. So, I encourage you to use it as
    much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will change the approach. We are going to learn about
    the additional value that we receive when we define the tests before we write
    the code. While that might sound complicated, it will help you a lot to clarify
    what you need to build next and how to do it in a way where you can test it. You
    will be amazed at how much time you can save when you follow this approach. It
    is called test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: TDD in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some edge cases that we are not covering in our `utils` module. For
    example, what happens if we pass a string to the `sum` function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is not the expected behavior when we use the `sum` function, so we need
    to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some tests to cover these edge cases in our `jest-tests/utils.test.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the `toThrow` matcher to test that the function
    is throwing an error. Now, let’s run the test coverage with `npm` `run jest-test`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Terminal output](img/B21678_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new test is failing because our code didn’t meet our requirements, so let’s
    make some changes in `utils.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s run the tests again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Terminal output](img/B21678_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: Our tests are passing again, so we can say that our code is working as expected.
    This interactive process of writing the tests first and then writing the code
    to make the tests pass is called test-driven development, or TDD.
  prefs: []
  type: TYPE_NORMAL
- en: While TDD is a vast topic, we can take this simple example as an exploratory
    introduction to the benefits of TDD without following it strictly. For example,
    we can test edge cases and then use them to improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: I personally find TDD a great approach in Node.js, as it helps me a lot with
    dividing complex tasks into smaller pieces that have their own well-defined and
    tested functionality. While this may seem obvious to more senior developers, due
    to the nature of JavaScript, it is very easy to build overengineering solutions.
    Testing will help us a lot in this matter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, testing can be a great ally when you are working in isolation, for example,
    when you need to build an HTTP API for a web application, but the frontend team
    is not planning to start until the API is ready. So, testing is a great way to
    validate the implementation with the frontend team. Also, tests are a great way
    to onboard new members to a team, as they can easily follow what is expected to
    happen in the application just by running and reading the tests.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced cases, it is also a great way to debug applications and recreate
    bugs reported by clients or team members. Overall, I think that the return on
    investment is very high, especially in dynamic languages such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the testing principles and how we can combine
    different types of tests to build a robust test suite. We also explored how the
    test pyramid can help us to build a test suite that is easy to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we discussed the differences between unit tests and integration
    tests and how we can use them to test our code. We also explored strategies to
    evangelize testing in our teams.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored how to add unit tests to our code using Node.js core
    modules and Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to use code coverage as an interactive tool to help
    us refine our tests and keep our code base robust. Then, we did a little exercise
    using TDD to fix a bug in our library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how the HTTP protocol works in detail and
    how we can build RESTful APIs with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Practical Test Pyramid by Martin* *Fowler*: [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test-Driven Development // Fun TDD Introduction with* *JavaScript*: [https://www.youtube.com/watch?v=Jv2uxzhPFl4](https://www.youtube.com/watch?v=Jv2uxzhPFl4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Delightful JavaScript Testing with* *Jest*: [https://www.youtube.com/watch?v=cAKYQpTC7MA](https://www.youtube.com/watch?v=cAKYQpTC7MA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Migrating from Jest to Node.js Native Test Runner by Erick* *Wendel*: [https://www.youtube.com/watch?v=2YfIB4gia60](https://www.youtube.com/watch?v=2YfIB4gia60)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TDD, Where Did It All Go Wrong (Ian* *Cooper)*: [https://www.youtube.com/watch?v=EZ05e7EMOLM](https://www.youtube.com/watch?v=EZ05e7EMOLM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unit testing in JavaScript Part 1 - Why unit* *testing?*: [https://www.youtube.com/watch?v=Eu35xM76kKY&list=PL0zVEGEvSaeF_zoW9o66wa_UCNE3a7BEr](https://www.youtube.com/watch?v=Eu35xM76kKY&list=PL0zVEGEvSaeF_zoW9o66wa_UCNE3a7BEr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Web Application Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 3*, you will learn how web applications are built by using modern patterns
    and techniques that are adopted by most companies. You will also learn how to
    build solid RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21678_09.xhtml#_idTextAnchor244), *Handling HTTP and REST API*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21678_10.xhtml#_idTextAnchor267)*, Building Web Applications
    with Express*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
