- en: Introduction to Client-Side Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端脚本简介
- en: In this chapter, we will start taking a look at client-side basics. This will
    give you an idea of where and how to write your client-side scripts and how to
    test them. We'll also take a look at a few examples for getting started in this
    area.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探讨客户端基础知识。这将帮助您了解在哪里以及如何编写您的客户端脚本，以及如何测试它们。我们还将查看一些在这个领域入门的示例。
- en: 'In this chapter, we will be looking at these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Client scripts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端脚本
- en: UI policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI策略
- en: How and when to write client-side scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以及何时编写客户端脚本
- en: Testing a client-side script
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试客户端脚本
- en: Basic client-side script examples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本客户端脚本示例
- en: Client scripts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端脚本
- en: Client scripts are generally the client-side scripts most used by developers.
    By default, a client script will run on all views of a form, but it can be set
    up to only run for a certain view by unchecking the global checkbox and entering
    a specific view into the view field that appears. Client scripts can also be inherited
    to tables that extend from a different table. For example, a client script on
    the task table can be inherited to tables that extend it, like the incident, change,
    and problem tables. To allow tables to inherit a client script, the inherit checkbox
    must be set.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚本通常是开发者最常使用的客户端脚本。默认情况下，客户端脚本将在表的所有视图中运行，但可以通过取消选中全局复选框并将特定视图输入到出现的视图字段中来设置为仅针对某个视图运行。客户端脚本还可以继承到从不同表扩展的表中。例如，任务表上的客户端脚本可以继承到扩展它的表中，如事件、变更和问题表。要允许表继承客户端脚本，必须设置继承复选框。
- en: The script in a client script can be run at different times, depending on when
    the developer chooses. This choice is made by selecting a type for the client
    script.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚本中的脚本可以在开发者选择的不同时间运行。这种选择是通过为客户端脚本选择一个类型来实现的。
- en: 'There are four types of client script, and these are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚本有四种类型，它们是：
- en: '`onLoad`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoad`'
- en: '`onChange`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChange`'
- en: '`onSubmit`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubmit`'
- en: '`onCellEdit`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCellEdit`'
- en: Let's take a look at each type and when you may want to use each to achieve
    your scripting goals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每种类型，以及您何时可能想要使用每种类型来实现您的脚本目标。
- en: onLoad
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onLoad`'
- en: The `onLoad` client script type runs script when a form is loaded. This can
    be helpful to manipulate data on a form before a user starts using it. Sometimes,
    when a form loads slowly, it is possible to see `onLoad` client scripts doing
    their job.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`onLoad`客户端脚本类型在表加载时运行脚本。这有助于在用户开始使用表之前操纵表中的数据。有时，当表加载缓慢时，可以看到`onLoad`客户端脚本正在执行其任务。'
- en: 'When selecting the `onLoad` type, the script field will be populated with the
    `onLoad` function ServiceNow provides for you, as long as the script field hasn''t
    already been edited. The script looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择`onLoad`类型时，只要脚本字段尚未被编辑，脚本字段将填充ServiceNow为您提供的`onLoad`函数。脚本如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the `onLoad` function to put your script into. Any script running `onLoad`
    will take time to run and slow down loading time, so it is always worth trying
    to keep `onLoad` client scripts to a minimum, and short, if necessary. I have
    been involved in projects simply to reduce the amount of `onLoad` client scripts
    on forms to reduce load times.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将您的脚本放入的`onLoad`函数。任何运行`onLoad`的脚本都会花费时间运行并减慢加载时间，因此始终值得尝试将`onLoad`客户端脚本保持在最小，如果需要，则尽可能简短。我曾参与过仅为了减少表上`onLoad`客户端脚本的数量以减少加载时间的项目。
- en: Try to have only one `onLoad` client script for each table, rather than multiple.
    This makes it easy to maintain, as all `onLoad` code is in one place, and you
    can be completely confident of the order the `onLoad` code will run in.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量让每个表只有一个`onLoad`客户端脚本，而不是多个。这样便于维护，因为所有`onLoad`代码都在一个地方，您可以完全确信`onLoad`代码将按什么顺序运行。
- en: 'In the following figure, *Figure 3.1*, we can see what this type of client
    script will look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，*图3.1*，我们可以看到这种类型客户端脚本的外观：
- en: '![](img/00b13751-09d5-4a3d-97e3-e3e59f390140.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00b13751-09d5-4a3d-97e3-e3e59f390140.png)'
- en: 'Figure 3.1: Sample onLoad client script'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：示例onLoad客户端脚本
- en: In the preceding figure, we can see an `onLoad` client script ready to be written
    for the incident table. As the comment states in the code, replace the comment
    in the code with the functionality of your script, and then begin writing underneath
    the comment inside the `onLoad` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个为事件表编写的`onLoad`客户端脚本。正如代码中的注释所述，将代码中的注释替换为脚本的功能，然后在`onLoad`函数内的注释下方开始编写。
- en: onChange
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onChange`'
- en: The `onChange` client script runs when a selected field is changed on the form.
    It is important to note that an `onChange` script will also run when the form
    is loaded. This type of script is often used to auto-populate other fields on
    a form, based on data in the field the `onChange` script is running on. For example,
    if a user is selected on a form, other user data on the form, like company and
    job title, could be populated using an `onChange` script.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChange` 客户端脚本在表单上更改选定的字段时运行。重要的是要注意，当表单加载时，`onChange` 脚本也会运行。这种类型的脚本通常用于根据
    `onChange` 脚本运行的字段中的数据自动填充表单上的其他字段。例如，如果用户在表单上被选中，表单上的其他用户数据，如公司和职位，可以使用 `onChange`
    脚本来填充。'
- en: 'In the same way that ServiceNow provides a script function in `onLoad` scripts,
    an `onChange` function is also provided. This is slightly more complicated, so
    let''s take a look:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ServiceNow 在 `onLoad` 脚本中提供脚本函数的方式相同，`onChange` 函数也被提供。这稍微复杂一些，让我们看看：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `onChange` function gives us five parameters that we can use inside the
    function in our script. Here is what each of these parameters gives us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChange` 函数为我们提供了五个参数，我们可以在脚本函数内部使用这些参数。以下是每个参数提供的内容：'
- en: '`control`: The dynamic HTML of the field that has changed'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control`：已更改字段的动态 HTML'
- en: '`oldValue`: The value in the changed field when the form was loaded'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oldValue`：表单加载时更改字段的值'
- en: '`newValue`: The new value that has been entered into the changed field'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newValue`：已输入到更改字段的新的值'
- en: '`isLoading`: Is true if the form is loading; otherwise, false'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：如果表单正在加载，则为真；否则为假'
- en: '`isTemplate`: Is true if the change has occurred as part of a template load;
    otherwise, false'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTemplate`：如果更改是作为模板加载的一部分发生的，则为真；否则为假'
- en: You can also see that a little scripting has already been done by ServiceNow.
    This `if` statement checks if the form is loading or if the new value of the changed
    field is empty. If either of these cases is true, the script returns from the
    function, essentially canceling the script. In most cases, this is quite helpful,
    but it is good to understand this `if` statement, as sometimes you will want to
    amend it if you want code to run during loading or on the field changing to an
    empty value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到 ServiceNow 已经进行了一些脚本编写。这个 `if` 语句检查表单是否正在加载，或者更改字段的新的值是否为空。如果这两个条件中的任何一个为真，脚本将从函数中返回，实际上取消了脚本。在大多数情况下，这非常有帮助，但了解这个
    `if` 语句是好的，因为有时你可能想要修改它，以便在加载期间或字段变为空值时运行代码。
- en: For example, if you have cleared a user field where additional user data has
    been added to the form, you will also want to clear the additional user data.
    In this instance, you will want to remove the condition where the code returns
    from the function if the `newValue` parameter is blank.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你已经清除了包含附加用户数据的用户字段，你也会想要清除附加的用户数据。在这种情况下，你将想要移除代码返回函数的条件，如果 `newValue`
    参数为空。
- en: When selecting the `onChange` type, the option to pick a field for the script
    to run against will be visible to the developer. The fields available in this
    field are dependent on the value in the table field.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 `onChange` 类型时，开发者将可以看到为脚本运行选择字段的选项。此字段中可用的字段取决于表字段中的值。
- en: 'We can see an `onChange` type client script in *Figure 3.2*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 3.2* 中看到一个 `onChange` 类型客户端脚本：
- en: '![](img/b86eb6b9-402a-46d0-b03a-8c7d9b14f846.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b86eb6b9-402a-46d0-b03a-8c7d9b14f846.png)'
- en: 'Figure 3.2: Sample onChange client script'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：示例 `onChange` 客户端脚本
- en: In the preceding figure, we can see an `onChange` client script for the problem
    table. Pay particular attention to the Field name field, which defaults to Active,
    as that is the field that needs to change for this script to run. It can be easy
    to forget to change this field and wonder why your script is not executing when
    you are expecting it to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到问题表的 `onChange` 客户端脚本。特别注意字段名称字段，它默认为 Active，因为这是需要更改以使脚本运行的字段。很容易忘记更改这个字段，当你期望脚本执行时，却不知道为什么它没有执行。
- en: onSubmit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onSubmit`'
- en: The `onSubmit` client script type runs when a form is saved. This type of script
    is not that widely used, as we can often use server-side script to perform actions
    for us once a record is saved, but it can be helpful, as it provides a final chance
    to execute client-side script before server-side script is run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit` 客户端脚本类型在表单保存时运行。这种类型的脚本并不广泛使用，因为我们通常可以使用服务器端脚本来在记录保存后执行操作，但它很有帮助，因为它提供了在运行服务器端脚本之前执行客户端脚本的最后机会。'
- en: 'The script ServiceNow provides for `onSubmit` is quite similar to `onLoad`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow 为 `onSubmit` 提供的脚本与 `onLoad` 非常相似：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `onSubmit` script type can be used to check field values before a save takes
    place and abort the save if invalid values exist in fields.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSubmit` 脚本类型可用于在保存之前检查字段值，并在字段中存在无效值时终止保存。'
- en: When considering writing an `onSubmit` script, it is worth thinking about whether
    that script could run on the server side instead. This is because the client script
    runs in front of the user, and further processing must wait until the script finishes,
    whereas on the server side, the code is executed away from the user and can be
    executed alongside other scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑编写 `onSubmit` 脚本时，值得思考的是该脚本是否可以在服务器端运行。这是因为客户端脚本在用户面前运行，进一步的加工必须等待脚本完成，而服务器端，代码在用户之外执行，并且可以与其他脚本并行执行。
- en: If you want to abort the form being submitted, return false from the `onSubmit`
    function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想终止正在提交的表单，请从 `onSubmit` 函数返回 `false`。
- en: 'We can see an `onSubmit` example in *Figure 3.3*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图 3.3* 中看到一个 `onSubmit` 示例：
- en: '![](img/ffc38ca1-9fe5-4abc-a1ff-f2e5527c3c3d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffc38ca1-9fe5-4abc-a1ff-f2e5527c3c3d.png)'
- en: 'Figure 3.3: Sample onSubmit client script'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：样本 onSubmit 客户端脚本
- en: For our `onSubmit` client script example, we can see that this client script
    is ready for the script to be added for the change table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `onSubmit` 客户端脚本示例，我们可以看到这个客户端脚本已准备好添加到更改表。
- en: onCellEdit
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: onCellEdit
- en: The `onCellEdit` type of client script runs when a cell is edited on the list
    view of a table. This is the only client script type that does not run on the
    form view of a table. This type of client script is helpful to ensure that the
    rules you want to stick to are also enforced on list views of a table.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表的列表视图中编辑单元格时，将运行 `onCellEdit` 类型的客户端脚本。这是唯一不运行在表表单视图中的客户端脚本类型。这种类型的客户端脚本有助于确保您想要坚持的规则也适用于表的列表视图。
- en: 'The script that ServiceNow provides for `onCellEdit` scripts looks a little
    different from the other client script types:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow 为 `onCellEdit` 脚本提供的脚本看起来与其他客户端脚本类型略有不同：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is worth noting that these scripts could be for multiple records, as you
    can edit more than one using a list. As you can see, there are quite a few different
    parameters in this slightly different type of script. We''ll have a look at what
    each one of those parameters gives us:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些脚本可能是针对多个记录的，因为您可以使用列表编辑多个记录。如您所见，这种略有不同的脚本类型中有相当多的不同参数。我们将查看每个参数提供了什么：
- en: '`sysIDs`: All of the `sys_id` unique IDs of the records being edited in an
    array.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysIDs`: 正在被编辑的记录的所有 `sys_id` 唯一 ID 的数组。'
- en: '`table`: The current table of the records being edited.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`: 正在被编辑的记录的当前表。'
- en: '`oldValues`: The old values of all the cells being edited.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oldValues`: 正在被编辑的所有单元格的旧值。'
- en: '`newValue`: The new value to be put into all the cells being edited.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newValue`: 将放入所有正在编辑的单元格的新值。'
- en: '`callback`: A callback that allows the execution of further `onCellEdit` scripts
    or commits the change made if no further scripts exist. A `true` or `false` parameter
    can be passed, which will either allow further scripts and commit changes, or
    stop execution of further scripts and not commit the change, respectively.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`: 一个回调，允许执行进一步的 `onCellEdit` 脚本或在没有其他脚本存在的情况下提交所做的更改。可以传递一个 `true`
    或 `false` 参数，分别允许进一步执行脚本和提交更改，或者停止进一步脚本的执行并不提交更改。'
- en: These scripts tend to not be used that frequently, as server-side scripts like
    business rules can often be used to perform the functionality needed. Editing
    records in the list can also be a powerful tool for updating multiple records
    at once, so this is sometimes locked down to only certain users to prevent less
    knowledgeable users from causing issues.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本通常不太常用，因为像业务规则这样的服务器端脚本通常可以用来执行所需的功能。在列表中编辑记录也可以是更新多个记录的强大工具，因此有时会将其锁定为仅对某些用户开放，以防止知识不足的用户造成问题。
- en: 'An `onCellEdit` client script example can be viewed in *Figure 3.4*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `onCellEdit` 客户端脚本示例可以在 *图 3.4* 中查看：
- en: '![](img/d0ea13db-6ec0-4f6d-9ea7-fc6e160ecc5c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0ea13db-6ec0-4f6d-9ea7-fc6e160ecc5c.png)'
- en: 'Figure 3.4: Sample onCellEdit client script'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：样本 onCellEdit 客户端脚本
- en: The client script in the preceding figure is an `onCellEdit` for the requested
    item table.  Again, for this type of script, ensure the Field name field is set
    to the value you require, as the script will only run on a change to this field
    in the list view.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中的客户端脚本是为请求的项目表中的`onCellEdit`。同样，对于此类脚本，请确保字段名称字段设置为所需的值，因为脚本仅在列表视图中更改此字段时运行。
- en: UI policies
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI策略
- en: UI policies are a more configurable version of client scripts. An administrator
    sets a condition and then uses actions or scripts to amend fields. Using configuration,
    a developer can change whether a field is mandatory, visible, and read-only. If
    these are the changes you are considering making to a field, a UI policy is usually
    the best option. UI policies are easier to understand and maintain for other administrators
    than client scripts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: UI策略是客户端脚本的更可配置版本。管理员设置一个条件，然后使用操作或脚本修改字段。通过配置，开发者可以更改字段是否为必填、可见和只读。如果您正在考虑对字段进行这些更改，UI策略通常是最佳选择。UI策略比客户端脚本更容易理解和维护，对其他管理员来说也是如此。
- en: UI policies can also be scripted based on the condition set, as in, you can
    run code if the condition matches and you can run code if the condition does not
    match. Setting the condition in a UI policy is much like setting a condition elsewhere
    in ServiceNow, as it uses the standard condition builder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: UI策略也可以根据设置的条件进行脚本化，例如，如果条件匹配，可以运行代码；如果不匹配，也可以运行代码。在UI策略中设置条件与在ServiceNow的其他地方设置条件非常相似，因为它使用标准的条件构建器。
- en: 'UI policies run against a table, but because you can use the condition builder,
    a number of fields can be used as part of the condition built. UI policies come
    with some tick boxes that dictate when the UI policy should be applied. In the
    following, we''ll take a look at the different choices and how they change when
    a policy is applied:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: UI策略针对表运行，但由于可以使用条件构建器，因此可以多个字段作为条件构建的一部分使用。UI策略附带一些复选框，用于指定UI策略何时应用。在以下内容中，我们将查看不同的选项以及它们在应用策略时的变化：
- en: '`Global`: Set by default, this means the UI policy will run on all views by
    default, although by unticking the global tick box, you can select a specific
    view.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Global`：默认设置，这意味着UI策略将默认在所有视图中运行，尽管通过取消勾选全局复选框，您可以选择特定的视图。'
- en: '`On load`: Set by default, too, this tick box, when checked, runs the policy
    when the form is loaded, as well as when fields are changed.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`On load`：默认设置，此复选框选中时，在表单加载时以及字段更改时运行策略。'
- en: '`Reverse if false`: If the condition is not true, then reverse the effects
    of the UI policy. This is set by default.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reverse if false`：如果条件不成立，则反转UI策略的效果。这是默认设置。'
- en: '`Inherit`: Unset by default, this allows tables that extend the selected table
    to inherit the policy. For example, a policy on the task table would be inherited
    by the incident table if this was set.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inherit`：默认未设置，这允许扩展所选表的表继承策略。例如，如果设置了此选项，任务表上的策略将被事件表继承。'
- en: A UI policy has UI policy actions associated to it that will take effect when
    the condition matches, or in reverse if the reverse if false checkbox is set.
    These actions allow for fields to be made mandatory, visible, read-only, or a
    combination of these effects. UI policy actions are considered as configurations,
    and considered best practice when taking these actions on fields.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: UI策略与其关联的UI策略操作相关联，当条件匹配时生效，或者在“反转如果为假”复选框设置的情况下反向生效。这些操作允许字段变为必填、可见、只读或这些效果的组合。UI策略操作被视为配置，并在字段上采取这些操作时被视为最佳实践。
- en: If you want to achieve more with a UI policy, there are options to script on
    matching or not matching the given condition. This is rarely used, as client scripts
    tend to fit this requirement better, but let's look at how it works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过UI策略实现更多功能，有选项可以在匹配或不匹配给定条件时进行脚本化。这很少使用，因为客户端脚本通常更适合此要求，但让我们看看它是如何工作的。
- en: Firstly, to script in a UI policy, you must set the Run scripts checkbox. This
    makes two fields appear: Execute if true and Execute if false. These are fairly
    self explanatory in that they will run if the condition defined in the UI policy
    matches true or false.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要在UI策略中脚本化，您必须设置“运行脚本”复选框。这将出现两个字段：如果为真则执行和如果为假则执行。这些名称相当直观，即如果UI策略中定义的条件匹配为真或假，则将运行。
- en: 'ServiceNow gives us the function to put our code into, which looks as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow为我们提供了将代码放入其中的功能，如下所示：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is the same in both the Execute if true or Execute if false script
    fields.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在“执行如果为真”或“执行如果为假”脚本字段中是相同的。
- en: UI policies are very useful for making fields mandatory, visible, and read-only.
    The ability to configure rather than customize is certainly considered best practice
    if thinking of scripting in UI policies, though it is often best to use a client
    script. This is because you only have to maintain one script with a client script,
    rather than the two on a UI policy. It is also easier to code for all eventualities in
    client scripts, rather than just matching or not matching a set condition, as
    in UI policies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UI策略对于使字段成为必填、可见和只读非常有用。如果考虑在UI策略中脚本化，那么配置而不是定制当然被认为是最佳实践，尽管通常最好使用客户端脚本。这是因为你只需要维护一个客户端脚本，而不是UI策略上的两个脚本。在客户端脚本中，编写所有可能情况下的代码也更容易，而不是像UI策略中那样仅仅匹配或不匹配一组条件。
- en: 'We can see a UI policy in *Figure 3.5* showing the script form section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.5中，我们可以看到一个显示脚本表单部分的UI策略：
- en: '![](img/4a84cb9f-139b-4169-b123-7bc876b2a5db.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a84cb9f-139b-4169-b123-7bc876b2a5db.png)'
- en: 'Figure 3.5: Sample UI policy showing script fields'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：示例UI策略显示脚本字段
- en: In the preceding figure, we can see a UI policy currently set to run on the
    incident table. It is important, if we use the two script fields we can see, that
    we cover the scenarios of the condition of the UI policy being true and false
    with these two scripts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个当前设置为在事件表中运行的UI策略。如果我们使用可以看到的两个脚本字段，那么重要的是我们要用这两个脚本覆盖UI策略条件为真和假的场景。
- en: How and when to write client-side scripts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何以及何时编写客户端脚本
- en: Client-side scripts should be written when a developer wants to change the screen
    in front of the user. This could be a change to a field value, visibility, or
    another change. Every time client-side scripts are run, it requires resources
    from the instance, and so keeping client-side scripting to a minimum is important.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者想要更改用户面前的屏幕时，应该编写客户端脚本。这可能是对字段值、可见性或其他更改的更改。每次运行客户端脚本时，都需要从实例中获取资源，因此将客户端脚本保持在最低限度很重要。
- en: If you can make a change on the server side rather than the client side, then
    is it considered best practice to do so. This will then keep loading times shorter
    and improve the user experience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以在服务器端而不是客户端进行更改，那么这样做被认为是最佳实践。这将缩短加载时间并提高用户体验。
- en: Let's have a look at some common uses for client-side scripting and how best
    to achieve these tasks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户端脚本的一些常见用途以及如何最好地完成这些任务。
- en: Making fields mandatory, visible, or read-only
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使字段成为必填、可见或只读
- en: For making fields mandatory, visible, or read-only, it is best to use a UI policy.
    This method uses configuration rather than customization, and is easier to maintain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使字段成为必填、可见或只读，最好使用UI策略。这种方法使用配置而不是定制，并且更容易维护。
- en: Scripting does not need to be done in this case, as you can use UI policy actions
    to achieve your goal. ServiceNow makes these actions easy to set up with the condition
    builder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不需要进行脚本编写，因为你可以使用UI策略操作来实现你的目标。ServiceNow通过条件构建器使这些操作设置变得简单易行。
- en: Populating fields based on the value of another field
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据另一个字段的值填充字段
- en: Another popular use for client-side scripting is populating a field based on
    the value of another. A common use of this is when selecting a user in a field
    and then wanting, for example, to automatically populate the company, telephone
    number, and job title.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚本的另一个流行用途是基于另一个字段的值填充字段。这种用法的一个常见例子是在字段中选择用户后，例如，自动填充公司、电话号码和职位名称。
- en: For this example, you will want to use an `onChange` client script. By setting
    the `onChange` field to be the user field, you can then get the rest of the user
    data using a client script. The best practice for this is to use a `GlideAjax`
    call, which we will explore in advanced client scripting later in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你将想要使用一个`onChange`客户端脚本。通过将`onChange`字段设置为用户字段，你可以使用客户端脚本获取其余的用户数据。对于这一点，最佳实践是使用`GlideAjax`调用，我们将在下一章的进阶客户端脚本中探讨。
- en: Showing/hiding form sections
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示/隐藏表单部分
- en: Sometimes you will want to show only certain form sections to different types
    of users. This can be based on a number of variables, but often it will be based
    on the roles a user has or the groups they belong to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能只想向不同类型的用户显示特定的表单部分。这可以基于许多变量，但通常它将基于用户拥有的角色或他们所属的组。
- en: For this requirement, an `onLoad` client script can be used. This will ensure
    that before the form is available to the user, the required form sections can
    be hidden.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个需求，可以使用 `onLoad` 客户端脚本。这将确保在表单对用户可用之前，所需的表单部分可以被隐藏。
- en: Review
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: We have looked at some of the more common uses of client scripting, but this
    is by no means an exhaustive list. When considering writing scripts on the client
    side, it is often worth thinking about how necessary they are and if they can
    be better placed in server-side script. Remember that client-side scripts increase
    load times, so try to keep them to a minimum.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了客户端脚本的一些常见用途，但这绝对不是详尽的列表。在考虑在客户端编写脚本时，通常值得思考它们是否必要，以及它们是否可以更好地放在服务器端脚本中。记住，客户端脚本会增加加载时间，因此尽量将它们保持在最低限度。
- en: Testing client-side scripts
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端脚本
- en: Testing scripts in ServiceNow can be done in a few ways. Fortunately, client-side
    scripts can be some of the easiest to test, because the script is running in front
    of the user, and therefore, logging and feedback on scripts can be shown directly
    to the user, too.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在ServiceNow中测试脚本可以通过几种方式完成。幸运的是，客户端脚本可能是最容易测试的，因为脚本是在用户面前运行的，因此可以直接向用户展示脚本的日志和反馈。
- en: Alert
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出提示
- en: One of the simplest ways to debug client script is to use the alert functionality.
    `alert` simply pops up a message window displaying information you choose to include.
    This can be useful for showing the values of fields or variables at certain times,
    or simply to confirm that certain functions were entered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调试客户端脚本最简单的方法之一是使用 `alert` 功能。`alert` 简单地弹出一个消息窗口，显示你选择包含的信息。这可以用于显示在特定时间字段或变量的值，或者简单地确认某些函数已被输入。
- en: 'Let''s see how `alert` works in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中 `alert` 的作用：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding script will simply show a pop-up message to the user saying `Debug
    Message`. It is a simple line of code to write and provides instant feedback.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本将简单地向用户显示一个弹出消息，内容为“调试信息”。这是一行简单的代码，可以提供即时反馈。
- en: 'Let''s have a look at how we can use `alert` to help us test our code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `alert` 来帮助我们测试代码：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we are using three messages to test that the script
    is working how we would like it to. The first will simply alert us to the script
    starting by showing the user Start of script. This can be helpful to check that
    JavaScript is running correctly on a browser or that other client scripts are
    not causing an error that stops this script from running.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用三条消息来测试脚本是否按预期工作。第一条消息会简单地通过显示“脚本开始”来提醒用户脚本已经开始。这有助于检查JavaScript是否在浏览器上正确运行，或者是否有其他客户端脚本正在引发错误，阻止此脚本运行。
- en: The second message gives us the value of the short description as the form is
    loading. We are storing the value of the short description in the `shortDescBefore`
    variable and using it in our alert. We can combine strings of text and variables
    together in an alert by using the plus sign between them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条消息给出了表单加载时的简短描述值。我们将简短描述的值存储在 `shortDescBefore` 变量中，并在我们的 `alert` 中使用它。我们可以通过在它们之间使用加号将文本字符串和变量组合在一起，在
    `alert` 中。
- en: The third message shows the value of the short description field after we have
    used the `g_form setValue` method to amend it. The third message will read The
    short description afterwards is Alerting Issue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条消息显示了在用 `g_form setValue` 方法修改后，简短描述字段的值。第三条消息将读作“之后的简短描述是弹出问题”。
- en: Using `alert` allows us to test and also debug script that has been written
    quickly and effectively. The problem with using `alert` is that you must ensure
    all alerts are removed or commented out if being used for tests or debugging.
    This is due to them being very obvious to users if they are not removed, and some
    do find them rather irritating to have to keep clicking away.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `alert` 允许我们测试和调试快速且有效地编写的脚本。使用 `alert` 的问题在于，你必须确保在用于测试或调试时移除或注释掉所有 `alert`，因为这些消息如果不移除，对用户来说非常明显，有些人甚至觉得它们很烦人，需要不断点击。
- en: I tend to like testing in this way for initial development because of how easy
    it is to use. However, alert does not provide an ongoing testing method, so it
    can be better to put in a cleaner logging method for maintenance of your code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于喜欢以这种方式进行初始开发测试，因为它使用起来非常方便。然而，`alert` 并不提供持续的测试方法，因此对于代码的维护来说，使用更干净的日志方法可能更好。
- en: Jslog
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jslog
- en: Another way of testing and debugging client-side scripts is using `jslog`. When
    using `jslog`, you can write lines in scripts to send logs to the JavaScript log.
    The JavaScript log can be opened in the developer system settings so that messages
    can be viewed. This method will only show logs to users who have the JavaScript
    log open, so it can be a less intrusive method of testing scripts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试和调试客户端脚本的方法是使用`jslog`。当使用`jslog`时，您可以在脚本中写入行以将日志发送到JavaScript日志。JavaScript日志可以在开发系统设置中打开，以便查看消息。这种方法只会向已打开JavaScript日志的用户显示日志，因此它可以是一种不太侵入性的测试脚本的方法。
- en: 'The contents of a `jslog` message can be the same as a message using `alert`.
    Let''s have a look at how we write this in script:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`jslog`消息的内容可以与使用`alert`的消息相同。让我们看看我们如何在脚本中编写它：'
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the message `Testing Message` will appear in the JavaScript
    log. Jslog can contain strings or variables, but it will not display in the ServiceNow
    logs. It only appears in the JavaScript log, so you must ensure you have it open
    if using this testing method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，消息“Testing Message”将出现在JavaScript日志中。Jslog可以包含字符串或变量，但它不会显示在ServiceNow日志中。它只出现在JavaScript日志中，因此如果您使用此测试方法，请确保您已打开它。
- en: As the JavaScript log will not be open for regular users, it is possible to
    leave these logs in for future maintenance of scripts. If you choose to do this,
    make sure that the logs you leave in are well documented and minimal. It is difficult
    for a new developer to maintain an instance they are new to, where the JavaScript
    log is constantly being updated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript日志对于普通用户来说通常不会打开，因此可以将这些日志保留以供脚本未来的维护。如果您选择这样做，请确保您留下的日志有良好的文档记录并且尽可能少。对于新手开发者来说，维护一个他们不熟悉的实例，其中JavaScript日志不断更新，是非常困难的。
- en: Browser
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: The browser method is not a ServiceNow-specific way of debugging client-side
    scripts, but can be a useful one. Because these scripts are running on the client,
    web browsers often have ways of displaying running JavaScript code that you can
    check.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器方法不是ServiceNow特有的客户端脚本调试方式，但它可能非常有用。因为这些脚本在客户端运行，所以网络浏览器通常有显示正在运行的JavaScript代码的方式，您可以进行检查。
- en: These methods vary based on the browser you use to view ServiceNow, but most
    modern browsers will have some way of checking what JavaScript is running which
    can be used to test your client-side scripts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法根据您查看ServiceNow所使用的浏览器而有所不同，但大多数现代浏览器都将有一些检查正在运行的JavaScript的方法，这可以用来测试您的客户端脚本。
- en: I personally tend to like using Google Chrome for browser-based testing, but
    other browsers can be just as good.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人倾向于使用Google Chrome进行基于浏览器的测试，但其他浏览器也可以同样出色。
- en: Script examples
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: Having introduced the basic elements of client-side scripting and how and where
    to use it, we can take a look at some examples of scripts to further our understanding.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了客户端脚本的基本元素以及如何和在哪里使用它之后，我们可以看看一些脚本的例子来进一步加深理解。
- en: We'll start by looking at some client script examples.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看一些客户端脚本示例开始。
- en: 'In this first example, we''ll use an `onLoad` client script to show and hide
    form sections based on the logged-in users'' roles. We''ll only show the related
    records form section on the incident form if the logged-in user has the `itil_admin`
    role:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将使用一个`onLoad`客户端脚本根据登录用户的角色显示和隐藏表单部分。如果登录用户具有`itil_admin`角色，我们只会在事件表单上显示相关的记录表单部分：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the example, we are using `g_user`'s `hasRole` method to determine
    whether the logged-in user has the required role. If they don't, then we use the
    `g_form` `setSectionDisplay` method to hide the form section. Putting this client
    script as an `onLoad` type allows us to ensure that this form section is immediately
    hidden from the user.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在示例中看到的，我们正在使用`g_user`的`hasRole`方法来确定登录用户是否具有所需的角色。如果没有，我们则使用`g_form`的`setSectionDisplay`方法来隐藏表单部分。将此客户端脚本作为`onLoad`类型放置，可以确保此表单部分立即从用户那里隐藏。
- en: I have often used this type of script before to hide sensitive data that appears
    on a form section. This can range from financial details to personal information
    held by HR.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用这种类型的脚本来隐藏出现在表单部分上的敏感数据。这可以是从财务细节到由HR持有的个人信息。
- en: 'We can see how this script would look in *Figure 3.6*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图3.6*中看到这个脚本的外观：
- en: '![](img/c8e14742-3215-4865-b112-76d2a4f33c26.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8e14742-3215-4865-b112-76d2a4f33c26.png)'
- en: 'Figure 3.6: OnLoad client script to hide form sections'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：用于隐藏表单部分的OnLoad客户端脚本
- en: Now let's have a look at an `onChange` client script example. Sometimes, we
    may want to increase the speed at which incidents for certain categories are looked
    into. Let's suppose that for this example, we want to set the urgency to high
    for all network incidents, medium for database ones, and low for all other users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个`onChange`客户端脚本的示例。有时，我们可能希望提高对某些类别事件的处理速度。假设在这个示例中，我们希望将所有网络事件的紧急程度设置为高，数据库事件的紧急程度设置为中等，其他用户的紧急程度设置为低。
- en: 'We need to make sure we set the `Field name` field value to `Category` for
    our `onChange` script. Let''s look at the code we need:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保为我们的`onChange`脚本设置`字段名称`字段的值为`Category`。让我们看看我们需要查看的代码：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we have used a `switch case` statement to perform different
    actions, based on the new value of the field. This JavaScript technique is more
    efficient than using multiple `if` statements. We have also used the `newValue`
    parameter that ServiceNow gives us to quickly decide on which value we should
    set the urgency to.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`switch case`语句根据字段的新值执行不同的操作。这种JavaScript技术比使用多个`if`语句更有效。我们还使用了ServiceNow提供的`newValue`参数，以便快速决定将紧急程度设置为何值。
- en: When setting the value of the urgency in this example, the user is still able
    to amend the urgency field if they feel the urgency is not fitting for this particular
    incident. It is possible to lock down fields though which have been populated
    by scripts by making them read-only or setting security rules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中设置紧急程度的值时，如果用户认为紧急程度不适合这个特定事件，他们仍然可以修改紧急程度字段。通过将字段设置为只读或设置安全规则，可以锁定由脚本填充的字段。
- en: 'Let''s take a look at how this client script looks in *Figure 3.7*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个客户端脚本在*图3.7*中的样子：
- en: '![](img/65a27981-0d38-4371-b87e-c6dbef6d6e7a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65a27981-0d38-4371-b87e-c6dbef6d6e7a.png)'
- en: 'Figure 3.7: OnChange client script setting urgency based on category'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：基于类别的OnChange客户端脚本设置紧急程度
- en: Next, we'll have a look at an example using an `onSubmit` type client script.
    These are less used than some of the other types of client script, but it is good
    to see how to create one if necessary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个使用`onSubmit`类型客户端脚本的示例。这些脚本不如其他类型的客户端脚本常用，但如果需要，了解如何创建一个是有好处的。
- en: 'In this example, we''ll look at making sure a user has filled in the description
    if they have the `itil` role. Sometimes you may want to ensure that users with
    more technical experience fill in further information on a form:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将检查具有`itil`角色的用户是否填写了描述。有时你可能希望确保具有更多技术经验的用户在表单中填写更多信息：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we use the `g_form.addErrorMessage` method to show
    a message at the top of the form if a user with the `itil` role tries to save
    the form with no description. This message will let the user know why they are
    not able to save the form. The code that stops the record from being saved is
    returning false from the `onSubmit` function. If at any point in the `onSubmit`
    script the function returns false, then the record will not be saved.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`g_form.addErrorMessage`方法在表单顶部显示消息，如果具有`itil`角色的用户尝试保存没有描述的表单。这条消息将让用户知道为什么他们无法保存表单。阻止记录保存的代码是从`onSubmit`函数返回false。如果在`onSubmit`脚本的任何点上函数返回false，则记录将不会保存。
- en: Being able to stop a form from being saved is an important aspect of the `onSubmit`
    type of client script, and arguably, its main use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 能够阻止表单保存是`onSubmit`类型客户端脚本的一个重要方面，可以说是其主要用途。
- en: 'The example we have scripted can be seen in *Figure 3.8*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的示例可以在*图3.8*中看到：
- en: '![](img/6c2d7897-382e-42b6-aea2-e442bbe6c698.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c2d7897-382e-42b6-aea2-e442bbe6c698.png)'
- en: 'Figure 3.8: OnSubmit client script enforcing description update for itil users'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：OnSubmit客户端脚本强制itil用户更新描述
- en: Now let's see an example using the `onCellEdit` type of client script. Often,
    these types of script are used to validate the input that a user enters into a
    cell on the list view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个使用`onCellEdit`类型客户端脚本的示例。通常，这类脚本用于验证用户在列表视图中单元格中输入的内容。
- en: 'For this example, we will ensure that a user does not enter a high impact into
    a cell to force them to open up the form view to do this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将确保用户不会在单元格中输入高影响值，以迫使他们打开表单视图来完成此操作：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example uses the `newValue` parameter to check the value the impact has
    been set to. If it has `high` or `1` as the value of the field, which we need
    to use in scripts rather than labels, then the user is alerted through a message.
    By setting the `saveAndClose` variable to `false`, we can also stop the field
    from being updated. This is because the callback is using this variable, and therefore
    also sets the `callback` to `false`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用`newValue`参数来检查影响被设置到的值。如果它将字段值设置为`high`或`1`，这是我们需要在脚本中而不是标签中使用的，那么用户将通过消息被提醒。通过将`saveAndClose`变量设置为`false`，我们还可以阻止字段被更新。这是因为回调正在使用这个变量，因此也将`callback`设置为`false`。
- en: Often, business rules can be used to fulfill a similar task to the `onCellEdit`
    scripts, but it is useful to see how they can be created.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，业务规则可以用来完成与`onCellEdit`脚本类似的任务，但了解它们是如何创建的很有用。
- en: 'We can also see how this script looks in ServiceNow in *Figure 3.9*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在*图3.9*中看到这个脚本在ServiceNow中的样子：
- en: '![](img/73411a06-408f-4b56-8b79-cdd72a8e423d.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73411a06-408f-4b56-8b79-cdd72a8e423d.png)'
- en: 'Figure 3.9: OnCellEdit client script stopping impact being set to high on list
    views'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：OnCellEdit客户端脚本将列表视图上的影响设置为高
- en: These examples give us a good understanding of the different types of client
    script, and some uses for each. Now we'll take a look at UI policies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例让我们对不同的客户端脚本类型及其用途有了很好的理解。现在我们将探讨UI策略。
- en: As a UI policy is configured, we mainly only need to use script if we want to
    run scripts for the Execute if true and Execute if false fields we described earlier
    in the chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置UI策略时，我们主要只需要使用脚本，如果我们想要运行我们在本章前面描述的“如果为真”和“如果为假”字段中的脚本。
- en: 'For this example, we will change the short description when the UI policy condition
    matches and clear the value again if the condition does not match. Firstly, let''s
    see the Execute if true script:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将当UI策略条件匹配时更改简短描述，如果条件不匹配则再次清除值。首先，让我们看看“如果为真”脚本：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As the condition handles when we want the script to run, we simply need to perform
    the actions we want to take in the Execute if true script. This script will change
    the value in the short description field.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件处理了脚本何时运行，我们只需在“如果为真”脚本中执行我们想要采取的操作。这个脚本将更改简短描述字段中的值。
- en: 'Now let''s see the Execute if false script:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看“如果为假”脚本：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This second script will clear the Short description field if the condition does
    not match. In this example, the short description field would only ever contain
    no value or the `Matched condition` text. When writing scripts in UI policies,
    think carefully about all of the outcomes of your script. Writing scripts in these
    two separate scripts can be more difficult, which is why scripting is usually
    done in client scripts rather than UI policies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本将在条件不匹配时清除简短描述字段。在这个例子中，简短描述字段将只包含无值或`Matched condition`文本。在UI策略中编写脚本时，要仔细考虑脚本的所有可能结果。在这两个独立的脚本中编写脚本可能更困难，这就是为什么脚本通常在客户端脚本中而不是在UI策略中编写。
- en: 'We can see the UI policy containing the scripts we created in *Figure 3.10*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图3.10*中看到包含我们创建的脚本的UI策略：
- en: '![](img/5c37b779-c2b1-435c-9e14-4def99bdd88a.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c37b779-c2b1-435c-9e14-4def99bdd88a.png)'
- en: 'Figure 3.10: UI policy setting or clearing the short description'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：UI策略设置或清除简短描述
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: During this chapter, we looked at basic uses of client-side scripting in client
    scripts and UI policies. We explored the four different types of client script
    and saw how each script type works. We also discovered how and when to write client-side
    scripts and how to test and debug them. Finally, we looked at some practical examples
    of client-side scripts and where uses of the different types of client script
    can be utilized.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了客户端脚本在客户端脚本和UI策略中的基本用法。我们研究了四种不同类型的客户端脚本，并了解了每种脚本类型的工作方式。我们还发现了何时以及如何编写客户端脚本，以及如何测试和调试它们。最后，我们查看了一些客户端脚本的实用示例以及不同类型客户端脚本的使用场景。
- en: In the next chapter, we continue with client-side scripting, looking at the
    more advanced techniques and areas where client-side scripts can be used. We take
    a look at script actions, AJAX calls for calling server-side scripts, and using
    UI actions to run client-side scripts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨客户端脚本，关注更高级的技术和客户端脚本可以使用的领域。我们将研究脚本操作、用于调用服务器端脚本的AJAX调用，以及使用UI操作运行客户端脚本。
