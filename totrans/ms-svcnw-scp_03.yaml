- en: Introduction to Client-Side Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start taking a look at client-side basics. This will
    give you an idea of where and how to write your client-side scripts and how to
    test them. We'll also take a look at a few examples for getting started in this
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Client scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to write client-side scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a client-side script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic client-side script examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client scripts are generally the client-side scripts most used by developers.
    By default, a client script will run on all views of a form, but it can be set
    up to only run for a certain view by unchecking the global checkbox and entering
    a specific view into the view field that appears. Client scripts can also be inherited
    to tables that extend from a different table. For example, a client script on
    the task table can be inherited to tables that extend it, like the incident, change,
    and problem tables. To allow tables to inherit a client script, the inherit checkbox
    must be set.
  prefs: []
  type: TYPE_NORMAL
- en: The script in a client script can be run at different times, depending on when
    the developer chooses. This choice is made by selecting a type for the client
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of client script, and these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onLoad`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChange`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubmit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCellEdit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each type and when you may want to use each to achieve
    your scripting goals.
  prefs: []
  type: TYPE_NORMAL
- en: onLoad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onLoad` client script type runs script when a form is loaded. This can
    be helpful to manipulate data on a form before a user starts using it. Sometimes,
    when a form loads slowly, it is possible to see `onLoad` client scripts doing
    their job.
  prefs: []
  type: TYPE_NORMAL
- en: 'When selecting the `onLoad` type, the script field will be populated with the
    `onLoad` function ServiceNow provides for you, as long as the script field hasn''t
    already been edited. The script looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the `onLoad` function to put your script into. Any script running `onLoad`
    will take time to run and slow down loading time, so it is always worth trying
    to keep `onLoad` client scripts to a minimum, and short, if necessary. I have
    been involved in projects simply to reduce the amount of `onLoad` client scripts
    on forms to reduce load times.
  prefs: []
  type: TYPE_NORMAL
- en: Try to have only one `onLoad` client script for each table, rather than multiple.
    This makes it easy to maintain, as all `onLoad` code is in one place, and you
    can be completely confident of the order the `onLoad` code will run in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, *Figure 3.1*, we can see what this type of client
    script will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00b13751-09d5-4a3d-97e3-e3e59f390140.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Sample onLoad client script'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see an `onLoad` client script ready to be written
    for the incident table. As the comment states in the code, replace the comment
    in the code with the functionality of your script, and then begin writing underneath
    the comment inside the `onLoad` function.
  prefs: []
  type: TYPE_NORMAL
- en: onChange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onChange` client script runs when a selected field is changed on the form.
    It is important to note that an `onChange` script will also run when the form
    is loaded. This type of script is often used to auto-populate other fields on
    a form, based on data in the field the `onChange` script is running on. For example,
    if a user is selected on a form, other user data on the form, like company and
    job title, could be populated using an `onChange` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that ServiceNow provides a script function in `onLoad` scripts,
    an `onChange` function is also provided. This is slightly more complicated, so
    let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onChange` function gives us five parameters that we can use inside the
    function in our script. Here is what each of these parameters gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`control`: The dynamic HTML of the field that has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oldValue`: The value in the changed field when the form was loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newValue`: The new value that has been entered into the changed field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLoading`: Is true if the form is loading; otherwise, false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTemplate`: Is true if the change has occurred as part of a template load;
    otherwise, false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also see that a little scripting has already been done by ServiceNow.
    This `if` statement checks if the form is loading or if the new value of the changed
    field is empty. If either of these cases is true, the script returns from the
    function, essentially canceling the script. In most cases, this is quite helpful,
    but it is good to understand this `if` statement, as sometimes you will want to
    amend it if you want code to run during loading or on the field changing to an
    empty value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have cleared a user field where additional user data has
    been added to the form, you will also want to clear the additional user data.
    In this instance, you will want to remove the condition where the code returns
    from the function if the `newValue` parameter is blank.
  prefs: []
  type: TYPE_NORMAL
- en: When selecting the `onChange` type, the option to pick a field for the script
    to run against will be visible to the developer. The fields available in this
    field are dependent on the value in the table field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an `onChange` type client script in *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b86eb6b9-402a-46d0-b03a-8c7d9b14f846.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Sample onChange client script'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see an `onChange` client script for the problem
    table. Pay particular attention to the Field name field, which defaults to Active,
    as that is the field that needs to change for this script to run. It can be easy
    to forget to change this field and wonder why your script is not executing when
    you are expecting it to.
  prefs: []
  type: TYPE_NORMAL
- en: onSubmit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onSubmit` client script type runs when a form is saved. This type of script
    is not that widely used, as we can often use server-side script to perform actions
    for us once a record is saved, but it can be helpful, as it provides a final chance
    to execute client-side script before server-side script is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script ServiceNow provides for `onSubmit` is quite similar to `onLoad`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `onSubmit` script type can be used to check field values before a save takes
    place and abort the save if invalid values exist in fields.
  prefs: []
  type: TYPE_NORMAL
- en: When considering writing an `onSubmit` script, it is worth thinking about whether
    that script could run on the server side instead. This is because the client script
    runs in front of the user, and further processing must wait until the script finishes,
    whereas on the server side, the code is executed away from the user and can be
    executed alongside other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to abort the form being submitted, return false from the `onSubmit`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an `onSubmit` example in *Figure 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffc38ca1-9fe5-4abc-a1ff-f2e5527c3c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Sample onSubmit client script'
  prefs: []
  type: TYPE_NORMAL
- en: For our `onSubmit` client script example, we can see that this client script
    is ready for the script to be added for the change table.
  prefs: []
  type: TYPE_NORMAL
- en: onCellEdit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `onCellEdit` type of client script runs when a cell is edited on the list
    view of a table. This is the only client script type that does not run on the
    form view of a table. This type of client script is helpful to ensure that the
    rules you want to stick to are also enforced on list views of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script that ServiceNow provides for `onCellEdit` scripts looks a little
    different from the other client script types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that these scripts could be for multiple records, as you
    can edit more than one using a list. As you can see, there are quite a few different
    parameters in this slightly different type of script. We''ll have a look at what
    each one of those parameters gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sysIDs`: All of the `sys_id` unique IDs of the records being edited in an
    array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table`: The current table of the records being edited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oldValues`: The old values of all the cells being edited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newValue`: The new value to be put into all the cells being edited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback`: A callback that allows the execution of further `onCellEdit` scripts
    or commits the change made if no further scripts exist. A `true` or `false` parameter
    can be passed, which will either allow further scripts and commit changes, or
    stop execution of further scripts and not commit the change, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These scripts tend to not be used that frequently, as server-side scripts like
    business rules can often be used to perform the functionality needed. Editing
    records in the list can also be a powerful tool for updating multiple records
    at once, so this is sometimes locked down to only certain users to prevent less
    knowledgeable users from causing issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `onCellEdit` client script example can be viewed in *Figure 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0ea13db-6ec0-4f6d-9ea7-fc6e160ecc5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Sample onCellEdit client script'
  prefs: []
  type: TYPE_NORMAL
- en: The client script in the preceding figure is an `onCellEdit` for the requested
    item table.  Again, for this type of script, ensure the Field name field is set
    to the value you require, as the script will only run on a change to this field
    in the list view.
  prefs: []
  type: TYPE_NORMAL
- en: UI policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI policies are a more configurable version of client scripts. An administrator
    sets a condition and then uses actions or scripts to amend fields. Using configuration,
    a developer can change whether a field is mandatory, visible, and read-only. If
    these are the changes you are considering making to a field, a UI policy is usually
    the best option. UI policies are easier to understand and maintain for other administrators
    than client scripts.
  prefs: []
  type: TYPE_NORMAL
- en: UI policies can also be scripted based on the condition set, as in, you can
    run code if the condition matches and you can run code if the condition does not
    match. Setting the condition in a UI policy is much like setting a condition elsewhere
    in ServiceNow, as it uses the standard condition builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'UI policies run against a table, but because you can use the condition builder,
    a number of fields can be used as part of the condition built. UI policies come
    with some tick boxes that dictate when the UI policy should be applied. In the
    following, we''ll take a look at the different choices and how they change when
    a policy is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Global`: Set by default, this means the UI policy will run on all views by
    default, although by unticking the global tick box, you can select a specific
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On load`: Set by default, too, this tick box, when checked, runs the policy
    when the form is loaded, as well as when fields are changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reverse if false`: If the condition is not true, then reverse the effects
    of the UI policy. This is set by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Inherit`: Unset by default, this allows tables that extend the selected table
    to inherit the policy. For example, a policy on the task table would be inherited
    by the incident table if this was set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UI policy has UI policy actions associated to it that will take effect when
    the condition matches, or in reverse if the reverse if false checkbox is set.
    These actions allow for fields to be made mandatory, visible, read-only, or a
    combination of these effects. UI policy actions are considered as configurations,
    and considered best practice when taking these actions on fields.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to achieve more with a UI policy, there are options to script on
    matching or not matching the given condition. This is rarely used, as client scripts
    tend to fit this requirement better, but let's look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, to script in a UI policy, you must set the Run scripts checkbox. This
    makes two fields appear: Execute if true and Execute if false. These are fairly
    self explanatory in that they will run if the condition defined in the UI policy
    matches true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'ServiceNow gives us the function to put our code into, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function is the same in both the Execute if true or Execute if false script
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: UI policies are very useful for making fields mandatory, visible, and read-only.
    The ability to configure rather than customize is certainly considered best practice
    if thinking of scripting in UI policies, though it is often best to use a client
    script. This is because you only have to maintain one script with a client script,
    rather than the two on a UI policy. It is also easier to code for all eventualities in
    client scripts, rather than just matching or not matching a set condition, as
    in UI policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a UI policy in *Figure 3.5* showing the script form section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a84cb9f-139b-4169-b123-7bc876b2a5db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Sample UI policy showing script fields'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see a UI policy currently set to run on the
    incident table. It is important, if we use the two script fields we can see, that
    we cover the scenarios of the condition of the UI policy being true and false
    with these two scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How and when to write client-side scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side scripts should be written when a developer wants to change the screen
    in front of the user. This could be a change to a field value, visibility, or
    another change. Every time client-side scripts are run, it requires resources
    from the instance, and so keeping client-side scripting to a minimum is important.
  prefs: []
  type: TYPE_NORMAL
- en: If you can make a change on the server side rather than the client side, then
    is it considered best practice to do so. This will then keep loading times shorter
    and improve the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at some common uses for client-side scripting and how best
    to achieve these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Making fields mandatory, visible, or read-only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For making fields mandatory, visible, or read-only, it is best to use a UI policy.
    This method uses configuration rather than customization, and is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting does not need to be done in this case, as you can use UI policy actions
    to achieve your goal. ServiceNow makes these actions easy to set up with the condition
    builder.
  prefs: []
  type: TYPE_NORMAL
- en: Populating fields based on the value of another field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular use for client-side scripting is populating a field based on
    the value of another. A common use of this is when selecting a user in a field
    and then wanting, for example, to automatically populate the company, telephone
    number, and job title.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you will want to use an `onChange` client script. By setting
    the `onChange` field to be the user field, you can then get the rest of the user
    data using a client script. The best practice for this is to use a `GlideAjax`
    call, which we will explore in advanced client scripting later in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Showing/hiding form sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you will want to show only certain form sections to different types
    of users. This can be based on a number of variables, but often it will be based
    on the roles a user has or the groups they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: For this requirement, an `onLoad` client script can be used. This will ensure
    that before the form is available to the user, the required form sections can
    be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at some of the more common uses of client scripting, but this
    is by no means an exhaustive list. When considering writing scripts on the client
    side, it is often worth thinking about how necessary they are and if they can
    be better placed in server-side script. Remember that client-side scripts increase
    load times, so try to keep them to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Testing client-side scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing scripts in ServiceNow can be done in a few ways. Fortunately, client-side
    scripts can be some of the easiest to test, because the script is running in front
    of the user, and therefore, logging and feedback on scripts can be shown directly
    to the user, too.
  prefs: []
  type: TYPE_NORMAL
- en: Alert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest ways to debug client script is to use the alert functionality.
    `alert` simply pops up a message window displaying information you choose to include.
    This can be useful for showing the values of fields or variables at certain times,
    or simply to confirm that certain functions were entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `alert` works in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script will simply show a pop-up message to the user saying `Debug
    Message`. It is a simple line of code to write and provides instant feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we can use `alert` to help us test our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are using three messages to test that the script
    is working how we would like it to. The first will simply alert us to the script
    starting by showing the user Start of script. This can be helpful to check that
    JavaScript is running correctly on a browser or that other client scripts are
    not causing an error that stops this script from running.
  prefs: []
  type: TYPE_NORMAL
- en: The second message gives us the value of the short description as the form is
    loading. We are storing the value of the short description in the `shortDescBefore`
    variable and using it in our alert. We can combine strings of text and variables
    together in an alert by using the plus sign between them.
  prefs: []
  type: TYPE_NORMAL
- en: The third message shows the value of the short description field after we have
    used the `g_form setValue` method to amend it. The third message will read The
    short description afterwards is Alerting Issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using `alert` allows us to test and also debug script that has been written
    quickly and effectively. The problem with using `alert` is that you must ensure
    all alerts are removed or commented out if being used for tests or debugging.
    This is due to them being very obvious to users if they are not removed, and some
    do find them rather irritating to have to keep clicking away.
  prefs: []
  type: TYPE_NORMAL
- en: I tend to like testing in this way for initial development because of how easy
    it is to use. However, alert does not provide an ongoing testing method, so it
    can be better to put in a cleaner logging method for maintenance of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Jslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of testing and debugging client-side scripts is using `jslog`. When
    using `jslog`, you can write lines in scripts to send logs to the JavaScript log.
    The JavaScript log can be opened in the developer system settings so that messages
    can be viewed. This method will only show logs to users who have the JavaScript
    log open, so it can be a less intrusive method of testing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of a `jslog` message can be the same as a message using `alert`.
    Let''s have a look at how we write this in script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the message `Testing Message` will appear in the JavaScript
    log. Jslog can contain strings or variables, but it will not display in the ServiceNow
    logs. It only appears in the JavaScript log, so you must ensure you have it open
    if using this testing method.
  prefs: []
  type: TYPE_NORMAL
- en: As the JavaScript log will not be open for regular users, it is possible to
    leave these logs in for future maintenance of scripts. If you choose to do this,
    make sure that the logs you leave in are well documented and minimal. It is difficult
    for a new developer to maintain an instance they are new to, where the JavaScript
    log is constantly being updated.
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The browser method is not a ServiceNow-specific way of debugging client-side
    scripts, but can be a useful one. Because these scripts are running on the client,
    web browsers often have ways of displaying running JavaScript code that you can
    check.
  prefs: []
  type: TYPE_NORMAL
- en: These methods vary based on the browser you use to view ServiceNow, but most
    modern browsers will have some way of checking what JavaScript is running which
    can be used to test your client-side scripts.
  prefs: []
  type: TYPE_NORMAL
- en: I personally tend to like using Google Chrome for browser-based testing, but
    other browsers can be just as good.
  prefs: []
  type: TYPE_NORMAL
- en: Script examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having introduced the basic elements of client-side scripting and how and where
    to use it, we can take a look at some examples of scripts to further our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by looking at some client script examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first example, we''ll use an `onLoad` client script to show and hide
    form sections based on the logged-in users'' roles. We''ll only show the related
    records form section on the incident form if the logged-in user has the `itil_admin`
    role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the example, we are using `g_user`'s `hasRole` method to determine
    whether the logged-in user has the required role. If they don't, then we use the
    `g_form` `setSectionDisplay` method to hide the form section. Putting this client
    script as an `onLoad` type allows us to ensure that this form section is immediately
    hidden from the user.
  prefs: []
  type: TYPE_NORMAL
- en: I have often used this type of script before to hide sensitive data that appears
    on a form section. This can range from financial details to personal information
    held by HR.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how this script would look in *Figure 3.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8e14742-3215-4865-b112-76d2a4f33c26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: OnLoad client script to hide form sections'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's have a look at an `onChange` client script example. Sometimes, we
    may want to increase the speed at which incidents for certain categories are looked
    into. Let's suppose that for this example, we want to set the urgency to high
    for all network incidents, medium for database ones, and low for all other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make sure we set the `Field name` field value to `Category` for
    our `onChange` script. Let''s look at the code we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have used a `switch case` statement to perform different
    actions, based on the new value of the field. This JavaScript technique is more
    efficient than using multiple `if` statements. We have also used the `newValue`
    parameter that ServiceNow gives us to quickly decide on which value we should
    set the urgency to.
  prefs: []
  type: TYPE_NORMAL
- en: When setting the value of the urgency in this example, the user is still able
    to amend the urgency field if they feel the urgency is not fitting for this particular
    incident. It is possible to lock down fields though which have been populated
    by scripts by making them read-only or setting security rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this client script looks in *Figure 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65a27981-0d38-4371-b87e-c6dbef6d6e7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: OnChange client script setting urgency based on category'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll have a look at an example using an `onSubmit` type client script.
    These are less used than some of the other types of client script, but it is good
    to see how to create one if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll look at making sure a user has filled in the description
    if they have the `itil` role. Sometimes you may want to ensure that users with
    more technical experience fill in further information on a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `g_form.addErrorMessage` method to show
    a message at the top of the form if a user with the `itil` role tries to save
    the form with no description. This message will let the user know why they are
    not able to save the form. The code that stops the record from being saved is
    returning false from the `onSubmit` function. If at any point in the `onSubmit`
    script the function returns false, then the record will not be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to stop a form from being saved is an important aspect of the `onSubmit`
    type of client script, and arguably, its main use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example we have scripted can be seen in *Figure 3.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c2d7897-382e-42b6-aea2-e442bbe6c698.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: OnSubmit client script enforcing description update for itil users'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see an example using the `onCellEdit` type of client script. Often,
    these types of script are used to validate the input that a user enters into a
    cell on the list view.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will ensure that a user does not enter a high impact into
    a cell to force them to open up the form view to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the `newValue` parameter to check the value the impact has
    been set to. If it has `high` or `1` as the value of the field, which we need
    to use in scripts rather than labels, then the user is alerted through a message.
    By setting the `saveAndClose` variable to `false`, we can also stop the field
    from being updated. This is because the callback is using this variable, and therefore
    also sets the `callback` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Often, business rules can be used to fulfill a similar task to the `onCellEdit`
    scripts, but it is useful to see how they can be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see how this script looks in ServiceNow in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73411a06-408f-4b56-8b79-cdd72a8e423d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: OnCellEdit client script stopping impact being set to high on list
    views'
  prefs: []
  type: TYPE_NORMAL
- en: These examples give us a good understanding of the different types of client
    script, and some uses for each. Now we'll take a look at UI policies.
  prefs: []
  type: TYPE_NORMAL
- en: As a UI policy is configured, we mainly only need to use script if we want to
    run scripts for the Execute if true and Execute if false fields we described earlier
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will change the short description when the UI policy condition
    matches and clear the value again if the condition does not match. Firstly, let''s
    see the Execute if true script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As the condition handles when we want the script to run, we simply need to perform
    the actions we want to take in the Execute if true script. This script will change
    the value in the short description field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the Execute if false script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This second script will clear the Short description field if the condition does
    not match. In this example, the short description field would only ever contain
    no value or the `Matched condition` text. When writing scripts in UI policies,
    think carefully about all of the outcomes of your script. Writing scripts in these
    two separate scripts can be more difficult, which is why scripting is usually
    done in client scripts rather than UI policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the UI policy containing the scripts we created in *Figure 3.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c37b779-c2b1-435c-9e14-4def99bdd88a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: UI policy setting or clearing the short description'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this chapter, we looked at basic uses of client-side scripting in client
    scripts and UI policies. We explored the four different types of client script
    and saw how each script type works. We also discovered how and when to write client-side
    scripts and how to test and debug them. Finally, we looked at some practical examples
    of client-side scripts and where uses of the different types of client script
    can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we continue with client-side scripting, looking at the
    more advanced techniques and areas where client-side scripts can be used. We take
    a look at script actions, AJAX calls for calling server-side scripts, and using
    UI actions to run client-side scripts.
  prefs: []
  type: TYPE_NORMAL
