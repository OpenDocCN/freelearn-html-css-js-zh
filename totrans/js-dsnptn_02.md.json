["```js\nclass BoardSquare {\n  constructor(color, row, file, startingPiece) {\n    this.color = color;\n    this.row = row;\n    this.file = file;\n  }\n}\n```", "```js\nclass BoardSquare {\n  // no change to the rest of the class\n  occupySquare(piece) {\n    this.piece = piece;\n  }\n  clearSquare() {\n    this.piece = null;\n  }\n}\n```", "```js\nconst whiteSquare = new BoardSquare('white');\nconst whiteSquareTwo = new BoardSquare('white');\n// ...\nconst whiteSquareLast = new BoardSquare('white');\n```", "```js\nconst blackSquare = new BoardSquare('black');\nconst blackSquareTwo = new BoardSquare('black');\n// ...\nconst blackSquareLast = new BoardSquare('black');\n```", "```js\nclass BoardSquarePrototype {\n  constructor(prototype) {\n    this.prototype = prototype;\n  }\n  clone() {\n    const boardSquare = new BoardSquare();\n    boardSquare.color = this.prototype.color;\n    boardSquare.row = this.prototype.row;\n    boardSquare.file = this.prototype.file;\n    return boardSquare;\n  }\n}\n```", "```js\n    const whiteSquare = new BoardSquare('white');\n    const whiteSquarePrototype = new BoardSquarePrototype\n      (whiteSquare);\n    ```", "```js\n    const whiteSquareTwo = whiteSquarePrototype.clone();\n    // ...\n    const whiteSquareLast = whiteSquarePrototype.clone();\n    console.assert(\n      whiteSquare.color === whiteSquareTwo.color &&\n        whiteSquareTwo.color === whiteSquareLast.color,\n      'Prototype.clone()-ed instances have the same color\n         as the prototype'\n    );\n    console.assert(\n      whiteSquare !== whiteSquareTwo &&\n        whiteSquare !== whiteSquareLast &&\n        whiteSquareTwo !== whiteSquareLast,\n      'each Prototype.clone() call outputs a different\n         instances'\n    );\n    ```", "```js\nconst boardSquare = new BoardSquare('white');\nconst boardSquarePrototype = new BoardSquarePrototype(boardSquare);\nconst boardSquareTwo = boardSquarePrototype.clone();\n// ...\nconst boardSquareLast = boardSquarePrototype.clone();\nconsole.assert(\n  boardSquareTwo.color === 'white' &&\n    boardSquare.color === boardSquareTwo.color &&\n    boardSquareTwo.color === boardSquareLast.color,\n  'Prototype.clone()-ed instances have the same color as\n     the prototype'\n);\nconsole.assert(\n  boardSquare !== boardSquareTwo &&\n    boardSquare !== boardSquareLast &&\n    boardSquareTwo !== boardSquareLast,\n  'each Prototype.clone() call outputs a different\n    instances'\n);\n```", "```js\nconst boardSquare = new BoardSquare('black');\n// rest of the code stays the same\nconsole.assert(\n  boardSquareTwo.color === 'black' &&\n    boardSquare.color === boardSquareTwo.color &&\n    boardSquareTwo.color === boardSquareLast.color,\n  'Prototype.clone()-ed instances have the same color as\n     the prototype'\n);\nconsole.assert(\n  boardSquare !== boardSquareTwo &&\n    boardSquare !== boardSquareLast &&\n    boardSquareTwo !== boardSquareLast,\n  'each Prototype.clone() call outputs a different\n     instances'\n);\n```", "```js\nclass BoardSquare {\n  constructor(color, row, file, startingPiece) {\n    this.color = color;\n    this.row = row;\n    this.file = file;\n    this.piece = startingPiece;\n  }\n  // same rest of the class\n}\nconst boardSquare = new BoardSquare('white', 1, 'A',\n  'king');\nconst boardSquarePrototype = new BoardSquarePrototype\n  (boardSquare);\nconst otherBoardSquare = boardSquarePrototype.clone();\nconsole.assert(\n  otherBoardSquare.piece === undefined,\n  'prototype.piece was not copied over'\n);\n```", "```js\nclass BoardSquarePrototype {\n  constructor(prototype) {\n    this.prototype = prototype;\n  }\n  clone() {\n    return Object.assign(new BoardSquare(), this.prototype);\n  }\n}\nconst boardSquare = new BoardSquare('white', 1, 'A',\n  'king');\nconst boardSquarePrototype = new BoardSquarePrototype\n  (boardSquare);\nconst otherBoardSquare = boardSquarePrototype.clone();\nconsole.assert(\n  otherBoardSquare.piece === 'king' &&\n    otherBoardSquare.piece === boardSquare.piece,\n  'prototype.piece was copied over'\n);\n```", "```js\nconst square = {\n  color: 'white',\n  occupySquare(piece) {\n    this.piece = piece;\n  },\n  clearSquare() {\n    this.piece = null;\n  },\n};\nconst otherSquare = Object.create(square);\n```", "```js\nconsole.assert(otherSquare.__proto__ === square, 'uses JS\n  prototype');\nconsole.assert(\n  otherSquare.occupySquare === square.occupySquare &&\n    otherSquare.clearSquare === square.clearSquare,\n  \"methods are not copied, they're 'inherited' using the\n     prototype\"\n);\ndelete otherSquare.color;\nconsole.assert(\n  otherSquare.color === 'white' && otherSquare.color ===\n    square.color,\n  'data fields are also inherited'\n);\n```", "```js\nclass Square {\n  constructor() {}\n  occupySquare(piece) {\n    this.piece = piece;\n  }\n  clearSquare() {\n    this.piece = null;\n  }\n}\nclass BlackSquare extends Square {\n  constructor() {\n    super();\n    this.color = 'black';\n  }\n}\nconsole.assert(\n  BlackSquare.prototype.__proto__ === Square.prototype,\n  'subclass prototype has prototype of superclass'\n);\n```", "```js\nclass Logger {\n  static logLevels = ['info', 'warn', 'error'];\n  constructor(logLevel = 'info', transport = console) {\n    if (Logger.#loggerInstance) {\n      throw new TypeError(\n        'Logger is not constructable, use getInstance()\n           instead'\n      );\n    }\n    this.logLevel = logLevel;\n    this.transport = transport;\n  }\n  isLevelEnabled(targetLevel) {\n    return (\n      Logger.logLevels.indexOf(targetLevel) >=\n      Logger.logLevels.indexOf(this.logLevel)\n    );\n  }\n  info(message) {\n    if (this.isLevelEnabled('info')) {\n      return this.transport.info(message);\n    }\n  }\n  warn(message) {\n    if (this.isLevelEnabled('warn')) {\n      this.transport.warn(message);\n    }\n  }\n  error(message) {\n    if (this.isLevelEnabled('error')) {\n      this.transport.error(message);\n    }\n  }\n}\n```", "```js\nclass Logger {\n  static loggerInstance = null;\n  // rest of the class\n  static getInstance() {\n    if (!Logger.loggerInstance) {\n      Logger.loggerInstance = new Logger('warn', console);\n    }\n    return Logger.loggerInstance;\n  }\n}\n```", "```js\nconst a = Logger.getInstance();\nconst b = Logger.getInstance();\nconsole.assert(a === b, 'Logger.getInstance() returns the\n  same reference');\n```", "```js\nclass Logger {\n  // rest of the class\n  constructor(logLevel = 'info', transport = console) {\n    if (Logger.loggerInstance) {\n      throw new TypeError(\n        'Logger is not constructable, use getInstance()\n          instead'\n      );\n    }\n    this.logLevel = logLevel;\n    this.transport = transport;\n  }\n  // rest of the class\n}\n```", "```js\nLogger.getInstance();\nnew Logger('info', console); // new TypeError('Logger is\n  not constructable, use getInstance() instead');\n```", "```js\nnew Logger('info', console); // Logger { logLevel: 'info',\n  transport: ... }\nnew Logger('info', console); // Logger { logLevel: 'info',\n  transport: ... }\nLogger.getInstance();\nnew Logger('info', console); // new TypeError('Logger is\n  not constructable, use getInstance() instead');\n```", "```js\nclass Logger {\n  // rest of the class unchanged\n  constructor(logLevel = 'info', transport = console) {\n    // rest of the constructor unchanged\n    Logger.loggerInstance = this;\n  }\n}\n```", "```js\nexport class Logger {\n  // no changes to the Logger class\n}\nexport default Logger.getInstance();\n```", "```js\nimport { Logger } from './logger.js';\nconst logger = Logger.getInstance();\nlogger.warn('testing testing 12'); // testing testing 12\n```", "```js\nimport logger from './logger.js';\nlogger.warn('testing testing 12'); // testing testing 12\n```", "```js\nconst logger = Logger.getInstance();\nLogger.loggerInstance = null;\nconst logger = new Logger('info', console); // should throw but creates a new instance\n```", "```js\nexport class Logger {\n  // other static fields are unchanged\n  static #loggerInstance = null;\n  #logLevel;\n  #transport;\n  constructor(logLevel = 'info', transport = console) {\n    if (Logger.#loggerInstance) {\n      throw new TypeError(\n        'Logger is not constructable, use getInstance()\n          instead'\n      );\n    }\n    this.#logLevel = logLevel;\n    this.#transport = transport;\n  }\n  #isLevelEnabled(targetLevel) {\n    // implementation unchanged\n  }\n  info(message) {\n    if (this.#isLevelEnabled('info')) {\n      return this.#transport.info(message);\n    }\n  }\n  warn(message) {\n    if (this.#isLevelEnabled('warn')) {\n      this.#transport.warn(message);\n    }\n  }\n  error(message) {\n    if (this.#isLevelEnabled('error')) {\n      this.#transport.error(message);\n    }\n  }\n  getInstance() {\n    if (!Logger.#loggerInstance) {\n      Logger.#loggerInstance = new Logger('warn', console);\n    }\n    return Logger.#loggerInstance;\n  }\n}\n```", "```js\n  Logger.#loggerInstance = null;\n        ^\nSyntaxError: Private field '#loggerInstance' must be\n  declared in an enclosing class\n```", "```js\nclass Logger {\n  // no changes to the logger class\n}\nexport default Object.freeze(new Logger('warn', console));\n```", "```js\nimport logger from './logger.js';\nlogger.transport = {}; // new TypeError('Cannot add\n  property transport, object is not extensible')\n```", "```js\nclass MySingleton {\n  constructor(value) {\n    this.value = value;\n  }\n}\nexport default new MySingleton('my-value');\n```", "```js\nimport('./my-singleton.js') result in the same object. They both return the same object because the output of the import for a given module is a singleton:\n```", "```js\nawait Promise.all([\n  import('./my-singleton.js'),\n  import('./my-singleton.js'),\n]).then(([import1, import2]) => {\n  console.assert(\n    import1.default.value === 'my-value' &&\n      import2.default.value === 'my-value',\n    'instance variable is equal'\n  );\n  console.assert(\n    import1.default === import2.default,\n    'multiple imports of a module yield the same default\n      object value, a single MySingleton instance'\n  );\n  console.assert(import1 === import2, 'import objects are a\n    single reference');\n});\n```", "```js\nclass Logger {\n  static logLevels = ['info', 'warn', 'error'];\n  #transport;\n  constructor(logLevel = 'info', transport = console) {\n    this.logLevel = logLevel;\n    this.#transport = transport;\n  }\n  isLevelEnabled(targetLevel) {\n    return (\n      Logger.logLevels.indexOf(targetLevel) >=\n      Logger.logLevels.indexOf(this.logLevel)\n    );\n  }\n  info(message) {\n    if (this.isLevelEnabled('info')) {\n      return this.#transport.info(message);\n    }\n  }\n  warn(message) {\n    if (this.isLevelEnabled('warn')) {\n      this.#transport.warn(message);\n    }\n  }\n  error(message) {\n    if (this.isLevelEnabled('error')) {\n      this.#transport.error(message);\n    }\n  }\n}\nexport default Object.freeze(new Logger('warn', console));\n```", "```js\nconst simpleFactoryFunction = () => ({}); // returns an object, therefore it's a factory.\n```", "```js\nclass Building {\n  generateBuilding() {\n    this.topFloor = this.makeTopFloor();\n  }\n  makeTopFloor() {\n    throw new Error('not implemented, left for subclasses\n      to implement');\n  }\n}\n```", "```js\nclass House extends Building {\n  makeTopFloor() {\n    return {\n      level: 1,\n    };\n  }\n}\n```", "```js\nconst house = new House();\nhouse.generateBuilding();\nconsole.assert(house.topFloor.level === 1, 'topFloor works\n  in House');\n```", "```js\nclass SkyScraper extends Building {\n  makeTopFloor() {\n    return {\n      level: 125,\n    };\n  }\n}\n```", "```js\nconst skyScraper = new SkyScraper();\nskyScraper.generateBuilding();\nconsole.assert(skyScraper.topFloor.level > 100, 'topFloor\n  works in SkyScraper');\n```", "```js\nfunction generateBuilding({ makeTopFloor }) {\n  return {\n    topFloor: makeTopFloor(),\n  };\n}\n```", "```js\nconst house = generateBuilding({\n  makeTopFloor() {\n    return {\n      level: 1,\n    };\n  },\n});\nconsole.assert(house.topFloor.level === 1, 'topFloor works\n  in house');\nconst skyScraper = generateBuilding({\n  makeTopFloor() {\n    return {\n      level: 125,\n    };\n  },\n});\nconsole.assert(skyScraper.topFloor.level > 100, 'topFloor works in skyScraper');\n```"]