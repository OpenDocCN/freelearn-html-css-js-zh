<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Constructing Common UI Widgets</h1></div></div></div><p>One of the biggest features that draws developers to Ext JS is the vast array of UI widgets available out of the box. The ease with which they can be integrated with each other and the attractive and consistent visuals each of them offers is also a big attraction. No other framework can compete on this front, and this is a huge reason Ext JS leads the field of large-scale web applications.</p><p>In this chapter, we will look at how UI widgets fit into the framework's structure, how they interact with each other, and how we can retrieve and reference them. We will then delve under the surface and investigate the lifecycle of a component and the stages it will go through during the lifetime of an application. Finally, we will add the first UI components to our BizDash application in the form of data grids, trees, data views, and forms.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Anatomy of a UI widget</h1></div></div></div><p>Every UI <a id="id285" class="indexterm"/>element in Ext JS extends from the base component class <code class="literal">Ext.Component</code>. This class is responsible for rendering UI elements to the HTML document. They are generally sized and positioned by layouts used by their parent components and participate in the automatic component lifecycle process.</p><p>You can imagine an instance of <code class="literal">Ext.Component</code> as a single section of the user interface in a similar way that you might think of a DOM element when building traditional web interfaces.</p><p>Each subclass of <code class="literal">Ext.Component</code> builds upon this simple fact and is responsible for generating more complex HTML structures or combining multiple Ext.Components to create a more complex interface.</p><p>
<code class="literal">Ext.Component</code> classes, however, can't contain other Ext.Components. To combine components, one must use the <code class="literal">Ext.container.Container</code> class, which itself extends from <code class="literal">Ext.Component</code>. This class allows multiple components to be rendered inside it and have their<a id="id286" class="indexterm"/> size and positioning managed by the framework's layout classes (see <a class="link" href="ch06.html" title="Chapter 6. Combining UI Widgets into the Perfect Layout">Chapter 6</a>, <em>Combining UI Widgets into the Perfect Layout</em>, for more details).</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec78"/>Components and HTML</h2></div></div></div><p>Creating <a id="id287" class="indexterm"/>and manipulating UIs using components requires<a id="id288" class="indexterm"/> a slightly different way of thinking than you may be used to when <a id="id289" class="indexterm"/>creating interactive websites with libraries such as jQuery.</p><p>The <code class="literal">Ext.Component</code> class provides a layer of abstraction from the underlying HTML and allows us <a id="id290" class="indexterm"/>to encapsulate additional logic to build and manipulate this HTML. This<a id="id291" class="indexterm"/> concept is different from the way other libraries allow you to manipulate UI elements and provides a hurdle for new developers to get over.</p><p>The <code class="literal">Ext.Component</code> class generates HTML for us, which we rarely need to interact with directly; instead, we manipulate the configuration and properties of the component. The following code and screenshot show the HTML generated by a simple <code class="literal">Ext.Component</code> instance:</p><div><pre class="programlisting">var simpleComponent = Ext.create('Ext.Component', {
  html    : 'Ext JS Essentials!',
  renderTo: Ext.getBody()
});</pre></div><div><img src="img/3717_07_01.jpg" alt="Components and HTML"/></div><p>As you can see, a simple <code class="literal">&lt;DIV&gt;</code> tag is created, which is given some CSS classes and an autogenerated ID, and has the HTML config displayed inside it.</p><p>This generated HTML is created and managed by the <code class="literal">Ext.dom.Element</code> class, which wraps a DOM element and its children, offering us numerous helper methods to interrogate and manipulate it. After it is rendered, each <code class="literal">Ext.Component</code> instance has the element instance stored in its <code class="literal">el</code> property. You can then use this property to manipulate the underlying HTML that represents the component.</p><p>As mentioned earlier, the <code class="literal">el</code> property won't be populated until the component has been rendered to the DOM. You should put logic dependent on altering the raw HTML of the component in an <code class="literal">afterrender</code> event listener or override the <code class="literal">afterRender</code> method.</p><p>The following example shows how you can manipulate the underlying HTML once the component has been rendered. It will set the background color of the element to red:</p><div><pre class="programlisting">Ext.create('Ext.Component', {
  html     : 'Ext JS Essentials!',
  renderTo : Ext.getBody(),
  listeners: {
    afterrender: function(comp) {
      comp.el.setStyle('background-color', 'red');
    }
  }
});</pre></div><p>It is important to understand that digging into and updating the HTML and CSS that Ext JS creates for you is a dangerous game to play and can result in unexpected results when the<a id="id292" class="indexterm"/> framework tries to update things itself. There is usually <a id="id293" class="indexterm"/>a <em>framework way</em> to achieve the manipulations you want to include, which we recommend you use first.</p><p>We always<a id="id294" class="indexterm"/> advise new developers to try not to fight the framework too <a id="id295" class="indexterm"/>much when starting out. Instead, we encourage them to follow its conventions and patterns, rather than having to wrestle it to do things in the way they may have previously done when developing traditional websites and web apps.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>The component lifecycle</h1></div></div></div><p>When <a id="id296" class="indexterm"/>a component is created, it follows a lifecycle process that is important to understand, so as to have an awareness of the order in which things happen. By understanding this sequence of events, you will have a much better idea of where your logic will fit and ensure you have control over your components at the right points.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec79"/>The creation lifecycle</h2></div></div></div><p>The following <a id="id297" class="indexterm"/>process is followed when a new<a id="id298" class="indexterm"/> component is instantiated and rendered to the document by adding it to an existing container. When a component is shown explicitly (for example, without adding to a parent, such as a floating component) some additional steps are included. These have been denoted with a * in the following process.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec40"/>constructor</h3></div></div></div><p>First, the<a id="id299" class="indexterm"/> class' constructor function is executed, which triggers all of the other steps in turn. By overriding this function, we can add any setup code required for the component.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec41"/>Config options processed</h3></div></div></div><p>The next<a id="id300" class="indexterm"/> thing to be handled is the config options that are present in the class (see <a class="link" href="ch02.html" title="Chapter 2. Mastering the Framework's Building Blocks">Chapter 2</a>, <em>Mastering the Framework's Building Blocks</em>, for details). This involves each option's <code class="literal">apply</code> and <code class="literal">update</code> methods being called, if they exist, meaning the values are available via the getter from now onwards.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec42"/>initComponent</h3></div></div></div><p>The <code class="literal">initComponent</code> method is now called and is generally used to apply configurations to the <a id="id301" class="indexterm"/>class and perform any initialization logic.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec43"/>render</h3></div></div></div><p>Once <a id="id302" class="indexterm"/>added to a container, or when the <code class="literal">show</code> method is called, the component is rendered to the document.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec44"/>boxready</h3></div></div></div><p>At this stage, the<a id="id303" class="indexterm"/> component is rendered and has been laid out by its parent's layout class, and is ready at its initial size. This event will only happen once on the component's first layout.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec45"/>activate (*)</h3></div></div></div><p>If the<a id="id304" class="indexterm"/> component is a floating item, then the activate event will fire, showing that the component is the active one on the screen. This will also fire when the component is brought back to focus, for example, in a <strong>Tab</strong> panel when a tab is selected.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec46"/>show (*)</h3></div></div></div><p>Similar <a id="id305" class="indexterm"/>to the previous step, the show event will fire when the component is finally visible on screen.</p><div><img src="img/3717_07_02.jpg" alt="show (*)"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec80"/>The destruction process</h2></div></div></div><p>When we<a id="id306" class="indexterm"/> are removing a component from the <a id="id307" class="indexterm"/>Viewport and want to destroy it, it will follow a destruction sequence that we can use to ensure things are cleaned up sufficiently, so as to avoid memory leaks and so on. The framework takes care of the majority of this cleanup for us, but it is important that we tidy up any additional things we instantiate.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec47"/>hide (*)</h3></div></div></div><p>When a<a id="id308" class="indexterm"/> component is manually hidden (using the hide method), this event will fire and any additional hide logic can be included here.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec48"/>deactivate (*)</h3></div></div></div><p>Similar to the activate step, this is fired when the component becomes inactive. As with the <a id="id309" class="indexterm"/>activate step, this will happen when floating and nested components are hidden and are no longer the items under focus.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec49"/>destroy</h3></div></div></div><p>This is the <a id="id310" class="indexterm"/>final step in the teardown process and is implemented when the component and its internal properties and objects are cleaned up. At this stage, it is best to remove event handlers, destroy subclasses, and ensure any other references are released.</p><div><img src="img/3717_07_03.jpg" alt="destroy"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Component Queries</h1></div></div></div><p>Ext JS<a id="id311" class="indexterm"/> boasts a powerful system to retrieve references to components called Component Queries. This is a CSS/XPath style query syntax that lets us target broad sets or specific components within our application. For example, within our controller, we may want to find a button with the text "Save" within a component of type MyForm.</p><p>In this section, we will demonstrate the Component Query syntax and how it can be used to select components. We will also go into details about how it can be used within <code class="literal">Ext.container.Container</code> classes to scope selections.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec81"/>xtypes</h2></div></div></div><p>Before <a id="id312" class="indexterm"/>we dive in, it is important to understand the concept of xtypes in Ext JS. An xtype is a shorthand name for an <code class="literal">Ext.Component</code> that allows us to <a id="id313" class="indexterm"/>identify its declarative component configuration objects. For example, we can create a new <code class="literal">Ext.Component</code> as a child of an <code class="literal">Ext.container.Container</code> using an xtype with the following code:</p><div><pre class="programlisting">Ext.create('Ext.Container', {
  items: [
    {
      xtype: 'component',
      html : 'My Component!'
    }
  ]
});</pre></div><p>Using xtypes allows you to lazily instantiate components when required, rather than having them all created upfront.</p><p>Common<a id="id314" class="indexterm"/> component xtypes include:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Classes</p>
</th><th style="text-align: left" valign="bottom">
<p>xtypes</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ext.tab.Panel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">tabpanel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ext.container.Container</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">container</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ext.grid.Panel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">gridpanel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Ext.Button</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">button</code>
</p>
</td></tr></tbody></table></div><p>xtypes form the basis of our Component Query syntax in the same way that element types (for example, <code class="literal">div</code>, <code class="literal">p</code>, <code class="literal">span</code>, and so on) do for CSS selectors. We will use these heavily in the following examples.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec82"/>Sample component structure</h2></div></div></div><p>We will <a id="id315" class="indexterm"/>use the following sample <a id="id316" class="indexterm"/>component structure—a panel with a child tab panel, form, and buttons—to perform our example queries on:</p><div><pre class="programlisting">var panel = Ext.create('Ext.panel.Panel', {
  height : 500,
  width : 500,
  renderTo: Ext.getBody(),
  layout: {
    type : 'vbox',
    align: 'stretch'
  },
  items : [
    {
      xtype : 'tabpanel',
      itemId: 'mainTabPanel',
      flex : 1,
      items : [
        {
          xtype : 'panel',
          title : 'Users',
          itemId: 'usersPanel',
          layout: {
            type : 'vbox',
            align: 'stretch'
            },
            tbar : [
              {
                xtype : 'button',
                text : 'Edit',
                itemId: 'editButton'
                }
              ],
              items : [
                {
                  xtype : 'form',
                  border : 0,
                  items : [
                    {
                      xtype : 'textfield',
                      fieldLabel: 'Name',
                      allowBlank: false
                    },
                    {
                      xtype : 'textfield',
                      fieldLabel: 'Email',
                      allowBlank: false
                    }
                  ],
                  buttons: [
                    {
                      xtype : 'button',
                      text : 'Save',
                      action: 'saveUser'
                    }
                  ]
                },
                {
                  xtype : 'grid',
                  flex : 1,
                  border : 0,
                  columns: [
                    {
                      header : 'Name',
                      dataIndex: 'Name',
                      flex : 1
                    },
                    {
                      header : 'Email',
                      dataIndex: 'Email'
                    }
                  ],
                  store : Ext.create('Ext.data.Store', {
                    fields: [
                      'Name',
                      'Email'
                    ],
                    data : [
                      {
                        Name : 'Joe Bloggs',
                        Email: 'joe@example.com'
                      },
                      {
                        Name : 'Jane Doe',
                        Email: 'jane@example.com'
                      }
                    ]
                  })
                }
              ]
            }
          ]
        },
        {
          xtype : 'component',
          itemId : 'footerComponent',
          html : 'Footer Information',
          extraOptions: {
            option1: 'test',
            option2: 'test'
          }, 
          height : 40
        }
      ]
    });</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec83"/>Queries with Ext.ComponentQuery</h2></div></div></div><p>The <code class="literal">Ext.ComponentQuery</code> class is used to perform Component Queries, with the <code class="literal">query</code> method <a id="id317" class="indexterm"/>primarily used. This method accepts two parameters: a query string and an optional <code class="literal">Ext.container.Container</code> instance to use as the root of the selection (that is, only components below this one in the hierarchy will be returned). The method will return an array of components or an empty array if none are found.</p><p>We will work through a number of scenarios and use Component Queries to find a specific set of components.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Finding components based on xtype</h3></div></div></div><p>As <a id="id318" class="indexterm"/>we have seen, we use xtypes like element types in CSS selectors. We can select all the <code class="literal">Ext.panel.Panel</code> instances using its xtype—<code class="literal">panel</code>:</p><div><pre class="programlisting">var panels = Ext.ComponentQuery.query('panel');</pre></div><p>We can also add the concept of hierarchy by including a second xtype separated by a space. The following code will select all <code class="literal">Ext.Button</code> instances that are descendants (at any level) of an <code class="literal">Ext.panel.Panel</code> class:</p><div><pre class="programlisting">var buttons = Ext.ComponentQuery.query('panel buttons');</pre></div><p>We could also use the <code class="literal">&gt;</code> character to limit it to buttons that are direct descendants of a <code class="literal">panel</code>.</p><div><pre class="programlisting">var directDescendantButtons = Ext.ComponentQuery.query('panel &gt; button');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec51"/>Finding components based on attributes</h3></div></div></div><p>It is <a id="id319" class="indexterm"/>simple to select a component based on the value of a property. We use the XPath syntax to specify the attribute and the value. The following code will select buttons with an action attribute of <code class="literal">saveUser</code>:</p><div><pre class="programlisting">var saveButtons = Ext.ComponentQuery.query('button[action="saveUser"]);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Finding components based on itemIds</h3></div></div></div><p>ItemIds are<a id="id320" class="indexterm"/> commonly used to retrieve components, and they are specially optimized for performance within the <code class="literal">ComponentQuery</code> class. They should be unique only within their parent container and not globally unique like the <code class="literal">id</code> config. To select a component based on itemId, we prefix the itemId <a id="id321" class="indexterm"/>with a <code class="literal">#</code> symbol:</p><div><pre class="programlisting">var usersPanel = Ext.ComponentQuery.query('#usersPanel');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Finding components based on member functions</h3></div></div></div><p>It is also<a id="id322" class="indexterm"/> possible to identify matching components based on the result of a function of that component. For example, we can select all text fields whose values are valid (that is, when a call to the <code class="literal">isValid</code> method returns <code class="literal">true</code>):</p><div><pre class="programlisting">var validFields = Ext.ComponentQuery.query('form &gt; textfield{isValid()}');</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec84"/>Scoped Component Queries</h2></div></div></div><p>All of <a id="id323" class="indexterm"/>our previous examples will search the entire component tree to find matches, but often we may want to keep our searches local to a specific container and its descendants. This can help reduce the complexity of the query and improve the performance, as fewer components have to be processed.</p><p>Ext.Containers have three handy methods to do this: <code class="literal">up</code>, <code class="literal">down</code>, and <code class="literal">query</code>. We will take each of these in turn and explain their features.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec54"/>up</h3></div></div></div><p>This<a id="id324" class="indexterm"/> method accepts a selector and will traverse up the hierarchy to find a single matching parent component. This can be useful to find the grid panel that a button belongs to, so an action can be taken on it:</p><div><pre class="programlisting">var grid = button.up('gridpanel');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec55"/>down</h3></div></div></div><p>This <a id="id325" class="indexterm"/>returns the first descendant component that matches the given selector:</p><div><pre class="programlisting">var firstButton = grid.down('button');</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec56"/>query</h3></div></div></div><p>The <code class="literal">query</code> method <a id="id326" class="indexterm"/>performs much like <code class="literal">Ext.ComponentQuery.query</code> but is automatically scoped to the current container. This means that it will search all descendant components of the current container and return all matching ones as an array.</p><div><pre class="programlisting">var allButtons = grid.query('button');</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Hierarchical data with trees</h1></div></div></div><p>Now that <a id="id327" class="indexterm"/>we know and understand components, their lifecycle, and how to retrieve references to them, we will move on to more specific UI widgets.</p><p>The tree panel component allows us to display hierarchical data in a way that reflects the data's structure and relationships.</p><p>In our application, we are going to use a tree panel to represent our navigation structure to allow users to see how the different areas of the app are linked and structured.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Binding to a data source</h2></div></div></div><p>Like all<a id="id328" class="indexterm"/> other data-bound components, tree panels must be bound to a data store—in this particular case it must be an <code class="literal">Ext.data.TreeStore</code> instance or subclass, as it takes advantage of the extra features added to this specialist store class.</p><p>We will make use of the <code class="literal">BizDash.store.Navigation</code> TreeStore we created in <a class="link" href="ch05.html" title="Chapter 5. Modeling Data Structures for Your UI">Chapter 5</a>, <em>Modeling Data Structures for Your UI</em>, to bind to our tree panel.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec86"/>Defining a tree panel</h2></div></div></div><p>The tree <a id="id329" class="indexterm"/>panel is defined in the <code class="literal">Ext.tree.Panel</code> class (which has an xtype of <code class="literal">treepanel</code>), which we will extend to create a custom class called <code class="literal">BizDash.view.navigation.NavigationTree</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.navigation.NavigationTree', {
  extend: 'Ext.tree.Panel',
  alias: 'widget.navigation-NavigationTree',
  store : 'Navigation',
  columns: [
    {
      xtype : 'treecolumn',
      text : 'Navigation',
      dataIndex: 'Label',
      flex : 1
    }
  ],
  rootVisible: false,
  useArrows : true
});</pre></div><p>We configure the tree to be bound to our TreeStore by using its storeId, in this case, Navigation.</p><p>A tree panel is a subclass of the <code class="literal">Ext.panel.Table</code> class (similar to the <code class="literal">Ext.grid.Panel</code> class), which means it must have a columns configuration present. This tells the component what values to display as part of the tree. In a simple, <em>traditional</em> tree, we might only have one column showing the item and its children; however, we can define multiple columns and display additional fields in each row. This would be useful if we were displaying, for example, files and folders and wanted to have additional columns to display the file type and file size of each item.</p><p>In our example, we are only going to have one column, displaying the Label field. We do this by using the <code class="literal">treecolumn</code> xtype, which is responsible for rendering the tree's navigation elements. Without defining <code class="literal">treecolumn</code>, the component won't display correctly.</p><p>The <code class="literal">treecolumn</code> xtype's configuration allows us to define which of the attached data model's fields <a id="id330" class="indexterm"/>to use (<code class="literal">dataIndex</code>), the column's header text (<code class="literal">text</code>), and the fact that the column should fill the horizontal space (flex: see the <em>Using the VBox layout</em> and <em>Using the HBox layout</em> sections in <a class="link" href="ch06.html" title="Chapter 6. Combining UI Widgets into the Perfect Layout">Chapter 6</a>, <em>Combining UI Widgets into the Perfect Layout</em>, for more details on this concept).</p><p>Additionally, we set the <code class="literal">rootVisible</code> to <code class="literal">false</code>, so the data's root is hidden, as it has no real meaning other than holding the rest of the data together. Finally, we set <code class="literal">useArrows</code> to <code class="literal">true</code>, so the items with children use an arrow instead of the +/- icon.</p><div><img src="img/3717_07_04.jpg" alt="Defining a tree panel"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Displaying tabular data</h1></div></div></div><p>The grid<a id="id331" class="indexterm"/> component is one of the biggest reasons Ext JS is selected by developers. Its performance, features, and flexibility make it a powerful feature. In this section, we will work through an example of creating a grid to display our product data.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec87"/>Product data</h2></div></div></div><p>Before <a id="id332" class="indexterm"/>we dive into creating a grid component, we must create a data store that will hold the product data that our grid will display. In <a class="link" href="ch05.html" title="Chapter 5. Modeling Data Structures for Your UI">Chapter 5</a>, <em>Modeling Data Structures for Your UI</em>, we defined the models that represent our product data, but we didn't create a products store to hold a collection of product model instances. To do this, we create a new file called <code class="literal">Products.js</code> in the <code class="literal">store</code> folder of our project with the following class definition:</p><div><pre class="programlisting">Ext.define('BizDash.store.Products', {
  extend: 'Ext.data.Store',
  model: 'BizDash.model.Product',
  autoLoad: true,
  proxy: {
    type : 'ajax',
    url : 'products.json',
    reader: {
      type : 'json',
      rootProperty: 'rows'
    }
  }
});</pre></div><p>This is <a id="id333" class="indexterm"/>a simple store definition with the only new configuration being the <code class="literal">autoLoad: true</code> setting, which will perform a load using the defined proxy as soon as the store is instantiated. In order to have this store automatically instantiated, we include it in the <code class="literal">stores</code> config of the <code class="literal">Application.js</code> file.</p><p>Our <code class="literal">products.json</code> file contains some simple product data, as seen here:</p><div><pre class="programlisting">{
  "success": true,
  "rows": [
    {
      "id"         : 1,
      "Name"       : "Product 1",
      "Description": "Product 1 Description",
      "Quantity"   : 1,
      "Price"      : 9.99
    },
    {
      "id"         : 2,
      "Name"       : "Product 2",
      "Description": "Product 2 Description",
      "Quantity"   : 5,
      "Price"      : 2.99
    },
    {
      "id"         : 3,
      "Name"       : "Product 3",
      "Description": "Product 3 Description",
      "Quantity"   : 1000,
      "Price"      : 5.49
    }
  ]
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec88"/>Product grid</h2></div></div></div><p>To<a id="id334" class="indexterm"/> create a grid, we use the <code class="literal">Ext.grid.Panel</code> component which extends from the <code class="literal">Ext.panel.Panel</code> class and so can be used in the same way as a simple panel (for example, it can have docked items, be given dimensions, and so on).</p><p>We will define our product grid in a file called <code class="literal">ProductGrid.js</code> inside a new folder called <code class="literal">product</code> under the project's view folder. We give it a basic configuration:</p><div><pre class="programlisting">Ext.define('BizDash.view.product.ProductGrid', {
  extend: 'Ext.grid.Panel',
  xtype: 'product-ProductGrid',
  store: 'Products',
  columns: [
    {
      text: 'Name',
      dataIndex: 'Name'
    },
    {
      text: 'Description',
      dataIndex: 'Description',
      flex: 1
    },
    {
      text: 'Quantity',
      dataIndex: 'Quantity'
    },
    {
      text: 'Price ',
      dataIndex: 'Price'
    }
  ]
});</pre></div><p>You will recognize the <code class="literal">Ext.define</code> structure as the same as we have used throughout the book with the class name and parent class defined. The <code class="literal">xtype</code> config lets us define a string that can be used when lazily instantiating the product grid.</p><p>The grid component has only two required configurations which we have included in the previous example: a store containing the data to be displayed and an array of columns which define what data is shown.</p><p>The store can be an actual store reference or a storeId that will be used to look up the store instance—in this case the products store we defined earlier.</p><p>Our columns definition contains an array of configuration objects that will be used to instantiate <code class="literal">Ext.grid.column.Column</code> classes (or subclasses thereof, for example, Date, Template, Number, and so on). The <code class="literal">text</code> property will define the column's header text and the <code class="literal">dataIndex</code> is the field to map to within the store's records. In our example, we have opted to display all the products' fields.</p><p>Finally, we <a id="id335" class="indexterm"/>can include the new <code class="literal">ProductGrid</code> in our application and see it in action. We must first require the new component in the <code class="literal">views</code> array of <code class="literal">Application.js</code>:</p><div><pre class="programlisting">...
  views: [
    'product.ProductGrid'
  ]
...</pre></div><p>We can then use the xtype in the Main view's items collection, placing it in the center region:</p><div><pre class="programlisting">...
{
  region: 'center',
  xtype : 'product-ProductGrid'
}
...</pre></div><p>Reloading our application should show a grid with three rows of data:</p><div><img src="img/3717_07_05.jpg" alt="Product grid"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Customizing column displays</h2></div></div></div><p>So far, <a id="id336" class="indexterm"/>our grid simply displays the data values<a id="id337" class="indexterm"/> as they are held in the model, which is fine for simple values but some data would benefit from more advanced formatting.</p><p>There are multiple ways of achieving the same effect when it comes to formatting column values. We will cover the two main options: column renderers and template columns.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec57"/>Column renderers</h3></div></div></div><p>We will<a id="id338" class="indexterm"/> start by adding a bit of color to our grid by customizing the styling of the <strong>Quantity</strong> column when it starts to get low. We will make the figures red when they drop to 3 or below, and orange when between 7 and 3.</p><p>A column <code class="literal">renderer</code> is a function that allows us to manipulate the data value (without affecting the underlying stored value) before it is displayed. We add the <code class="literal">renderer</code> property to the column definition and give it a function with the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>value</strong>: The value of the bound model field</li><li class="listitem" style="list-style-type: disc"><strong>metaData</strong>: Additional attributes of the cell being rendered, for example, <code class="literal">tdCls</code>, <code class="literal">tdAttr</code>, and <code class="literal">tdStyle</code></li><li class="listitem" style="list-style-type: disc"><strong>record</strong>: The record for the current row</li><li class="listitem" style="list-style-type: disc"><strong>rowIndex</strong>: The index of the current row</li><li class="listitem" style="list-style-type: disc"><strong>colIndex</strong>: The index of the current column</li><li class="listitem" style="list-style-type: disc"><strong>store</strong>: The store that is bound to the grid</li><li class="listitem" style="list-style-type: disc"><strong>view</strong>: The grid view</li></ul></div><p>The renderer<a id="id339" class="indexterm"/> function should return a string that will then be displayed in the cell. The following code shows our <code class="literal">renderer</code> function:</p><div><pre class="programlisting">{
  text : 'Quantity',
  dataIndex: 'Quantity',
  renderer : function(value, metaData, record, rowIndex, colIndex, store, view) {
    var colour = 'black';
    if(value &lt;= 3){
      colour = 'red';
    } else if(value &gt; 3 &amp;&amp; value &lt;= 7){
    colour = 'orange';
    }
    return '' + value + '';
  }
}</pre></div><div><img src="img/3717_07_06.jpg" alt="Column renderers"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Template columns</h2></div></div></div><p>As we<a id="id340" class="indexterm"/> mentioned earlier, there are various other column types<a id="id341" class="indexterm"/> that offer additional features. The template column allows us to define an <code class="literal">Ext.XTemplate</code> that is merged with the row's record. This is particularly useful if we want to include more complex HTML in the cell.</p><p>The next example shows how we can include the <code class="literal">StockValue</code> field besides the <code class="literal">Price</code>. We start by adding an <code class="literal">xtype: 'templatecolumn'</code> property to the column definition and then by defining a <code class="literal">tpl</code> string which will be converted into an <code class="literal">Ext.XTemplate</code> instance:</p><div><pre class="programlisting">{
  xtype: 'templatecolumn',
  width: 200,
  text: 'Price ',
  dataIndex: 'Price',
  tpl: '£{Price} (£{StockValue})'
}</pre></div><div><img src="img/3717_07_07.jpg" alt="Template columns"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>Grid widgets</h2></div></div></div><p>Rendering <a id="id342" class="indexterm"/>complex components in grids has long been a desire of Ext JS <a id="id343" class="indexterm"/>developers and has now been made much easier with the introduction of grid widgets. These are components that are rendered inside grid cells and bound to a model field. Examples of grid widgets are buttons, mini graphs, form fields, and so on.</p><p>We are going to add a simple button widget to our grid to allow each product's details to be viewed. We start by adding a new <code class="literal">widgetcolumn</code> to our grid's column array. The widget option defines the kind of widget displayed:</p><div><pre class="programlisting">{
  xtype : 'widgetcolumn',
  width : 100,
  text  : 'Action',
  widget: {
    xtype    : 'button',
    text     : 'Details'
  }
}</pre></div><p>This will render a button on each row that we can then hook up to a click event to open up a product details view (see the next section for further details on doing this).</p><div><img src="img/3717_07_08.jpg" alt="Grid widgets"/></div><p>We can hook into the widget's events using the <code class="literal">listeners</code> config as we would if we were using the component anywhere else in our application. The following snippet shows how to attach a simple <code class="literal">click</code> handler to the button:</p><div><pre class="programlisting">{
  xtype : 'widgetcolumn',
  width : 100,
  text : 'Action',
  widget: {
    xtype : 'button',
    text : 'Details',
    listeners: {
      click: function(btn){
        var rec = btn.getWidgetRecord();
        console.log('Widget Button clicked! - ', rec.get('Name'));
      }
    }
  }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Inputting data with forms</h1></div></div></div><p>A key<a id="id344" class="indexterm"/> aspect of web applications is forms. Being able to input data into our system is imperative, and as such, Ext JS has form components to suit all types of input that can be easily bound to our data models and related views.</p><p>In this section, we will expand on our product grid and allow users to edit products through a simple form.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Defining a form</h2></div></div></div><p>We <a id="id345" class="indexterm"/>define our product form as we would any other view—by creating a file (in this case named view/product/ProductForm.js) and calling <code class="literal">Ext.define</code> within it. We extend the <code class="literal">Ext.form.Panel</code> class and give it an xtype of product—<code class="literal">ProductForm</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.product.ProductForm', {
  extend: 'Ext.form.Panel',
  xtype: 'product-ProductForm'
});</pre></div><p>Within our form, we want to have input fields for the product's name, description, quantity, and price. There are numerous specific <code class="literal">form</code> field types we can use to suit most data types: <code class="literal">text</code>, <code class="literal">number</code>, <code class="literal">textarea</code>, <code class="literal">combobox</code>, <code class="literal">time</code>, <code class="literal">file</code>, <code class="literal">date</code>, <code class="literal">html</code>, and more. Check out the <code class="literal">Ext.form.field.*</code> namespace for all the possibilities.</p><p>We will make use of the <code class="literal">text</code>, <code class="literal">textarea</code>, and <code class="literal">number</code> fields for our form. We configure each using their xtypes and <code class="literal">fieldLabel</code>. Additionally, we will give our <code class="literal">textarea</code> an explicit height and tell our <code class="literal">Price</code> field that it can have a <code class="literal">decimalPrecision</code> of <code class="literal">2</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.product.ProductForm', {
  extend: 'Ext.form.Panel',
  xtype: 'product-ProductForm',
  items: [
    {
      xtype: 'textfield',
      fieldLabel: 'Name'
    },
    {
      xtype: 'textarea',
      fieldLabel: 'Description',
      height: 100
    },
    {
      xtype: 'numberfield',
      fieldLabel: 'Quantity'
    },
    {
      xtype: 'numberfield',
      fieldLabel: 'Price',
      decimalPrecision: 2
    }
  ]
});</pre></div><p>Now we have our input fields ready we will also add two buttons: <code class="literal">Save</code> and <code class="literal">Cancel</code>. We use the <code class="literal">bbar</code> config, which is a shortcut to adding a bottom docked toolbar, and define two buttons:</p><div><pre class="programlisting">...
  items: [ ... ],
  bbar : [
    {
      xtype: 'button',
      text: 'Save'
    },
    {
      xtype: 'button',
      text: 'Cancel'
    }
  ]
...</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Displaying our form</h2></div></div></div><p>We want to<a id="id346" class="indexterm"/> open our form when a user clicks the <strong>Details</strong> button beside a product in the grid and we want it to be pre-populated with that product's information.</p><p>We start by creating a ViewController called <code class="literal">product.ProductGridController</code>, which will be attached to the <code class="literal">ProductGrid</code> view:</p><div><pre class="programlisting">Ext.define('BizDash.view.product.ProductGridController', {
  extend: 'Ext.app.ViewController',
  alias: 'controller.ProductGrid'
});</pre></div><p>This class <a id="id347" class="indexterm"/>extends the <code class="literal">Ext.app.ViewController</code> class and we give it an alias of <code class="literal">ProductGrid</code>. We use this alias to tie it back to our <code class="literal">ProductGrid</code> view by adding <code class="literal">controller: 'ProductGrid'</code> to the <code class="literal">ProductGrid</code> class.</p><p>We will now use <code class="literal">ProductGridController</code> to listen for a click on the <strong>Details</strong> button and create and show our <code class="literal">ProductForm</code>.</p><p>The click handler we added to the <strong>Details</strong> button in the previous section must be replaced with the name of the ViewController method that we want to execute when that event happens. We will call this <code class="literal">onDetailsClick</code>:</p><div><pre class="programlisting">// ProductGrid.js
{
  xtype : 'widgetcolumn',
  width : 100,
  text  : 'Action',
  widget: {
    xtype    : 'button',
    text     : 'Details',
    listeners: {
      click: 'onDetailsClick'
    }
  }
}</pre></div><p>The <code class="literal">onDetailsClick</code> method of ViewController will instantiate a <code class="literal">ProductForm</code> instance, with some extra configuration to size and float it above the existing UI, and then show it:</p><div><pre class="programlisting">onDetailsClick: function(btn) {
  var rec = btn.getWidgetRecord(),
  productForm = Ext.create('BizDash.view.product.ProductForm', {
    floating: true,
    modal : true,
    closable: true,
    center : true,
    width : 500,
    height : 300
  });
  productForm.show();
}</pre></div><p>If we run our app, we will see the form display as a modal window above our grid.</p><div><img src="img/3717_07_09.jpg" alt="Displaying our form"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Populating our form</h2></div></div></div><p>At the<a id="id348" class="indexterm"/> moment, our product form is displayed but it isn't populated with the details of the product we clicked on. To do this, we must bind each of the form fields to the product model via a <code class="literal">ViewModel</code>.</p><p>We start by creating a <code class="literal">ProductFormModel</code> class with a very simple configuration. The class extends the <code class="literal">Ext.app.ViewModel</code> class and is given an alias of <code class="literal">ProductForm</code>.</p><p>We also define the <code class="literal">data</code> property, which holds the data to be bound, with a <code class="literal">rec</code> property which will be a reference to the product model instance we want to display:</p><div><pre class="programlisting">Ext.define('BizDash.view.product.ProductFormModel', {
  extend: 'Ext.app.ViewModel',
  alias: 'viewmodel.ProductForm',
  data: {
    rec: null
  }
});</pre></div><p>This class is then tied to our <code class="literal">ProductForm</code> class with its alias:</p><div><pre class="programlisting">// ProductForm.js
viewModel: {
  type: 'ProductForm'
}</pre></div><p>Now that these two are tied together, we can make use of the <code class="literal">bind</code> option of each form field to tell the framework to populate the field with a value from this <code class="literal">ViewModel</code>. We can also do this with the form's title property, so it displays the product name:</p><div><pre class="programlisting">...
  bind: {
    title: '{rec.Name}'
  },
  items: [
    {
      xtype     : 'textfield',
      fieldLabel: 'Name',
      bind      : '{rec.Name}'
    },
    {
      xtype     : 'textarea',
      fieldLabel: 'Description',
      height    : 100,
      bind      : '{rec.Description}'
    },
    {
      xtype     : 'numberfield',
      fieldLabel: 'Quantity',
      bind      : '{rec.Quantity}'
    },
    {
      xtype           : 'numberfield',
      fieldLabel      : 'Price',
      decimalPrecision: 2,
      bind            : '{rec.Price}'
    }
  ]
...</pre></div><p>The final<a id="id349" class="indexterm"/> piece of the puzzle is to give the <code class="literal">ViewModel</code> a reference to the correct product model instance. We do this in the <code class="literal">onDetailsClick</code> method of <code class="literal">ProductGridController</code>:</p><div><pre class="programlisting">// ProductGridController.js
...
productForm.getViewModel().setData({
  rec: rec
});
...</pre></div><p>Now, when we open the form, the fields will be prepopulated. You will also notice that when you edit the product name, for example, the grid and form title will automatically update in real time. Pretty clever.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Persisting updates</h2></div></div></div><p>At the <a id="id350" class="indexterm"/>moment, our <code class="literal">Save</code> and <code class="literal">Cancel</code> buttons don't do anything, so let's hook them up.</p><p>We start by defining what happens when the buttons are clicked. We use the same pattern as we did with the product grid's <code class="literal">Details</code> button and assign the click event a method name which correlates to a method in the ViewController:</p><div><pre class="programlisting">// ProductForm.js
bbar: [
  {
    xtype: 'button',
    text: 'Save',
    listeners: {
      click: 'onSave'
    }
  },
  {
    xtype: 'button',
    text: 'Cancel',
    listeners: {
      click: 'onCancel'
    }
  }
]</pre></div><p>Now, we must create a ViewController called <code class="literal">ProductFormController</code>. Just like we did with <code class="literal">ProductGrid</code>, we have to tell the view that the ViewController exists by adding <code class="literal">controller: 'ProductFormController'</code>. The ViewModel and ViewControllers must also be <em>required</em> by the view, so they are available:</p><div><pre class="programlisting">requires: [
  'BizDash.view.product.ProductFormController',
  'BizDash.view.product.ProductFormModel'
],</pre></div><p>Inside the ViewController's handlers, we use the <code class="literal">getView</code> method to retrieve a reference to the form, so we can act on it. The <code class="literal">onSave</code> method will retrieve a reference to the product record (via the ViewModel) and commit it (alternatively, if you have a proper backend setup, you would call the <code class="literal">save</code> method). The <code class="literal">onCancel</code> method calls the <code class="literal">reject</code> method on the product model, so any changes that have been made are reverted. Both methods will then close the form and destroy it.</p><div><pre class="programlisting">//ProductFormController.js
onSave: function(btn){
  var productModel = this.getView().getViewModel().getData().rec;
  productModel.commit();
  this.closeForm();
},
onCancel: function(btn){
  var productModel = this.getView().getViewModel().getData().rec;
  productModel.reject();
  this.closeForm();
},
closeForm: function(){
  var productForm = this.getView();
  productForm.close();
  productForm.destroy();
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Data-bound views</h1></div></div></div><p>So far, <a id="id351" class="indexterm"/>we have seen how to display data sets in trees and grids, but what if we want a bit more flexibility in how things are displayed?</p><p>Data views give us this freedom and allow us to define custom HTML to be displayed for each item in the dataset but while retaining the powerful automatic binding setup. We can then apply our own custom CSS to this HTML to style it as we want.</p><p>We will work through an example where we create a data view for the users in our system.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Defining our users' data view</h2></div></div></div><p>As <a id="id352" class="indexterm"/>always, we create a new view class—<code class="literal">BizDash.view.user.UsersView</code>—extending the base framework class <code class="literal">Ext.view.View</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.user.UsersView', {
  extend: 'Ext.view.View',
  alias: 'widget.user-UsersView'
});</pre></div><p>A data<a id="id353" class="indexterm"/> view requires three properties to function fully: a <code class="literal">store</code>, a <code class="literal">tpl</code>, and an <code class="literal">itemSelector</code>.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec58"/>Store</h3></div></div></div><p>In exactly <a id="id354" class="indexterm"/>the same way as the grid and tree we've looked at previously, this is the data source that the component will be bound to. Any changes made to this store or its records will automatically be reflected in the view.</p><p>In this instance, we will use the users store and will configure it using the <code class="literal">storeId</code>:</p><div><pre class="programlisting">Ext.define('BizDash.view.user.UsersView', {
  extend: 'Ext.view.View',
  alias: 'widget.user-UsersView',
  store: 'Users'
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec59"/>Template</h3></div></div></div><p>A data <a id="id355" class="indexterm"/>view is based on the concept of rendering a piece of HTML for each record in the bound data store. The <code class="literal">tpl</code> config defines <code class="literal">Ext.XTemplate</code> that will be merged with a record to produce that piece of HTML. Without this, nothing will be rendered to the screen.</p><p>We want to display each user's name, role, and photo. We define the data view with the following template string:</p><div><pre class="programlisting">    tpl: [
        '&lt;tpl for="."&gt;',
        '   &lt;div class="user-item"&gt;',
        '       &lt;img src="img/{Photo}" /&gt;',
        '       &lt;div class="name"&gt;{Name}&lt;/div&gt;',
        '       &lt;div class="role"&gt;{Role}&lt;/div&gt;',
        '   &lt;/div&gt;',
        '&lt;/tpl&gt;'
    ].join('')</pre></div><p>We start by <a id="id356" class="indexterm"/>using the <code class="literal">tpl</code> markup tag along with the <code class="literal">for</code> attribute. This tells the template to loop over the array it is given and merge the HTML within it with each record in turn. We mark data placeholders, whose names match the model's field names, using the <code class="literal">{{...}}</code> notation.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec60"/>Item selector</h3></div></div></div><p>Finally, for <a id="id357" class="indexterm"/>our view component to know how to identify a single record's HTML, we must give it a CSS selector that can identify a single node. This is used to allow events to be raised on individual items (for example, click, double-click, and so on).</p><p>We have given the wrapper div the <code class="literal">user-item</code> class, which we can use as the unique selector:</p><div><pre class="programlisting">...
  itemSelector: 'user-item'
...</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Styling the view</h2></div></div></div><p>If you <a id="id358" class="indexterm"/>show our data view, it will look a bit poor, so we need to include some styling to make it pretty.</p><p>We do this by creating a <code class="literal">.scss</code> file called <code class="literal">UsersView.scss</code> within the <code class="literal">sass/src</code> folder and mirroring the view folders structure, so the SASS is automatically picked up. In this case, we create it in <code class="literal">sass/src/view/user/UsersView.scss</code>:</p><div><pre class="programlisting">.user-item
{
  float: left;
  width: 120px;
  text-align: center;
  margin: 20px;
  img {
    width: 100%;
  }
  .name
  {
    font-size: 1.2em;
    font-weight: bold;
  }
  .role
  {
    font-size: 0.8em;
    color: #CCC;
  }
}</pre></div><p>Following a <code class="literal">sencha app build</code> command and a refresh, you should see a nicer-styled data view, as follows:</p><div><img src="img/3717_07_10.jpg" alt="Styling the view"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we have learnt how Ext JS' components fit together and the lifecycle that they follow when created and destroyed.</p><p>We then moved on to utilizing some of the most popular and useful components. We have explored the details of the following components within our BizDash application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Trees</li><li class="listitem" style="list-style-type: disc">Grids</li><li class="listitem" style="list-style-type: disc">Forms</li><li class="listitem" style="list-style-type: disc">Data views</li></ul></div><p>In addition to explaining the main features and configuration options of these components, we linked them together within a simple MVVM architecture, taking advantage of two-way data binding and event listening.</p><p>In the next chapter, we will introduce Ext JS themes and how they can be customized to make your application unique.</p></div></body></html>