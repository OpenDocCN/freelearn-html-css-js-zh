<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Testing Node.js Applications" id="aid-10DJ41"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Testing Node.js Applications</h1></div></div></div><p>So far, we have only been testing our code by exercising it manually. This isn't a very sustainable approach as our application becomes larger. Ideally, we should regularly exercise all the functionality of our application to check for regressions. This would quickly become prohibitively time-consuming if we continued to use only manual testing. It is much more effective to maintain a suite of automated tests. These also bring many other benefits, for example, acting as documentation of our code for other developers.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Writing automated unit tests for our application</li><li class="listitem">Introducing new libraries to help us write more descriptive tests</li><li class="listitem">Seeing how to create and use test doubles in JavaScript</li><li class="listitem">Exercising our application's web interface using HTTP client tests</li><li class="listitem">Adding full-stack integration tests using browser automation</li><li class="listitem">Establishing a structure for writing further tests as we expand our codebase</li></ul></div><div class="section" title="Writing a simple test in Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Writing a simple test in Node.js</h1></div></div></div><p>Node.js comes <a id="id185" class="indexterm"/>with a built-in module called <code class="literal">assert</code> that can be used for testing. We can use it to write a simple test for the games service that we wrote in <a class="link" title="Chapter 5. Creating Dynamic Websites" href="part0030.xhtml#aid-SJGS1">Chapter 5</a>
<span class="emphasis"><em>, Building Dynamic Websites</em></span>. We add the following code under <code class="literal">gameServiceTest.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

let assert = require('assert');
let service = require('./services/games.js')

// Given
service.create('firstUserId', 'testing');

// When
let games = service.availableTo('secondUserId');

// Then            
assert.equal(games.length, 1);            
let game = games[0];
assert.equal(game.setBy, 'firstUserId');
assert.equal(game.word, 'TESTING');</pre></div><p>Note that the <code class="literal">assert.equal</code> function takes the actual value as the first argument and the expected value as the second argument. This is the opposite way around to JUnit's built-in <code class="literal">Assert.Equals</code>, and the classic-style <code class="literal">Assert.AreEqual</code> in NUnit. It's important to get these parameters the right way around so that they appear correctly in error messages when an assertion fails.</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Given, When, Then</strong></span>
</p><p>The <span class="emphasis"><em>Given</em></span>, <span class="emphasis"><em>When</em></span>, and <span class="emphasis"><em>Then</em></span> comments in the preceding test are not specific to JavaScript or any of the test frameworks we'll be using, but are generally a good tool for structuring tests to keep them focused and readable.</p></div><p>We can <a id="id186" class="indexterm"/>now verify our code using the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; node gameServiceTest.js</strong></span>
<span class="strong"><strong>&gt; echo %errorlevel%</strong></span>
</pre></div><p>An exit code of <code class="literal">0</code> indicates that our test completed successfully without any errors. Although we haven't been following test-driven development (writing a failing test first before adding any new code), it's still important to see each test fail to confirm that it's testing something. Try altering the <code class="literal">availableTo</code> function in <code class="literal">services/games.js</code> to return an empty array, and run the test again.</p><p>Not only do we now get a non-zero exit code, but we also get an error containing our assertion failure. Our test output still isn't particular compelling, though. Also, the lack of structure in our test script will make it harder to navigate as we add more tests. We can address both of these issues by making use of one of the testing libraries available for JavaScript.</p></div></div>
<div class="section" title="Structuring the codebase for tests" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Structuring the codebase for tests</h1></div></div></div><p>As we write <a id="id187" class="indexterm"/>more tests for our application, we'll benefit from having more structure to our tests. It's common to have at least one test file per production module. It will also be useful to have a way of running all of our tests and seeing the overall result.</p><p>We're going to start adding tests under a <code class="literal">test</code> directory. From this point on in the book, we're also going to keep all of our application code under a <code class="literal">src</code> directory. This will make it easier to <a id="id188" class="indexterm"/>navigate our codebase and to keep production and test code separate.</p><p>If you're following along with the book at this point, you should move <code class="literal">app.js</code> and all the folders (apart from the <code class="literal">bin</code> folder) under a new <code class="literal">src</code> directory, and update the startup script as follows in <code class="literal">bin/www</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>var app = require('../src/app');</strong></span>
var debug = require('debug')('hangman:server');
var http = require('http');</pre></div></div>
<div class="section" title="Writing BDD-style tests with Mocha" id="aid-12AK81"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Writing BDD-style tests with Mocha</h1></div></div></div><p>From C# or Java, you may be most familiar with the xUnit-style of tests used by NUnit, JUnit, and so<a id="id189" class="indexterm"/> on. This style structures tests into classes, <a id="id190" class="indexterm"/>and turns method names into test names. This can be a bit restrictive, and isn't common in JavaScript testing. JavaScript test frameworks make use of the less structured, and more dynamic, nature of the language to allow more flexibility.</p><p>There are several different styles for writing tests in JavaScript. The most common is the so-called <span class="strong"><strong>behavior-driven development</strong></span> (<span class="strong"><strong>BDD</strong></span>) style in which we describe the behavior of our <a id="id191" class="indexterm"/>application in plain English. This is the default style of the most popular JavaScript testing frameworks. It is also common in frameworks for other programming platforms, most notably RSpec for Ruby.</p><p>We'll be using a popular test framework named Mocha. Let's first add this to our application:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install mocha --save-dev</strong></span>
</pre></div><p>Note that <code class="literal">--save-dev</code> adds Mocha to our <code class="literal">package.json</code> file as a <span class="strong"><strong>development dependency</strong></span>. This<a id="id192" class="indexterm"/> indicates that it's not needed in our production code, and <code class="literal">npm</code> doesn't need to install it in production environments. We'll also update this file to let <code class="literal">npm</code> run our tests using Mocha, by adding a test script as follows:</p><div class="informalexample"><pre class="programlisting">  "scripts": {
    "start": "node ./bin/www",
<span class="strong"><strong>    "test": "node node_modules/mocha/bin/mocha test/**/*.js"</strong></span>
  },</pre></div><p>This tells <code class="literal">npm</code> to execute scripts under the <code class="literal">/test/</code> directory as tests using Mocha when we run <code class="literal">npm test</code> from the command line.</p><div class="note" title="Note"><h3 class="title"><a id="note06"/>Note</h3><p>
<span class="strong"><strong>Mocha and Jasmine</strong></span>
</p><p>There are a large number of different testing frameworks available for JavaScript. The most <a id="id193" class="indexterm"/>well-established are Jasmine and Mocha. They have comparable features and both support the same syntax for writing tests. They are both well-documented, and switching between the two is easy.</p><p>Jasmine<a id="id194" class="indexterm"/> was originally aimed more at testing client-side JavaScript in the browser. Mocha was originally more focused on testing server-side Node.js code.</p><p>Nowadays, both frameworks are well-suited for either environment. Jasmine also has more <span class="emphasis"><em>batteries included</em></span>, which can make it quicker to get started with. Mocha delegates more features to other libraries, giving the user more choice about how they prefer to write tests.</p></div><p>Now we<a id="id195" class="indexterm"/> just need to add some tests! Mocha <a id="id196" class="indexterm"/>provides global functions named <code class="literal">describe</code> and <code class="literal">it</code> for structuring our tests. These functions each take two arguments: a string describing the behavior of our application and a callback defining the tests for that behavior. The following code snippet shows our previous test rewritten using Mocha. We add the following code under <code class="literal">test/services/games.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const assert = require('assert');
const service = require('../../src/services/games.js');

describe('Game service', () =&gt; {
    const firstUserId = 'user-id-1';
    const secondUserId = 'user-id-2';
        
    describe('list of available games', () =&gt; { 
        it('should include games set by other users', () =&gt; {
            // Given
            service.create(firstUserId, 'testing');
            
            // When
            const games = service.availableTo(secondUserId);
            
            // Then
            assert.equal(games.length, 1);
            const game = games[0];
            assert.equal(game.setBy, firstUserId);
            assert.equal(game.word, 'TESTING');
        });
    });
});</pre></div><p>Now try running the previous test using <code class="literal">npm test</code>. You should see output like the following (the exact appearance will depend on what console you are using):</p><div class="mediaobject"><img src="../Images/image00217.jpeg" alt="Writing BDD-style tests with Mocha"/></div><p style="clear:both; height: 1em;"> </p><p>Note how <a id="id197" class="indexterm"/>we get a much more descriptive output <a id="id198" class="indexterm"/>of our tests. Also note the use of nested describe callbacks in our test to build up a description of our application. The benefit of this becomes clearer as we add more tests. Try adding the following test after the first test:</p><div class="informalexample"><pre class="programlisting">    it('should not include games set by the same user', () =&gt; {
        // Given
        service.create(firstUserId, 'first');
        service.create(secondUserId, 'second');
        
        // When
        const games = service.availableTo(secondUserId);
        
        // Then
        assert.equal(games.length, 1);
        const game = games[0];
        assert.notEqual(game.setBy, secondUserId);
    });</pre></div><p>Run the tests again using <code class="literal">npm test</code>. This time, we get a test failure from Mocha:</p><div class="mediaobject"><img src="../Images/image00218.jpeg" alt="Writing BDD-style tests with Mocha"/></div><p style="clear:both; height: 1em;"> </p><div class="section" title="Resetting state between tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec34"/>Resetting state between tests</h2></div></div></div><p>Our second test<a id="id199" class="indexterm"/> fails because it retrieves two games from the service. But this is not because our production code is failing to filter games correctly. In fact, there are two games created by the first user. One of these has been carried over from the previous test.</p><p>It's important for tests to be independent and isolated from each other. To this end, we need to clean up any state between tests. In this case, we want to delete all the games we created. The games service doesn't give us a method for clearing all games. We can only remove individual games after retrieving them. There are a few options available to us here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We could keep track of all the games we create during each test and delete them all at the end. This might seem the most obvious solution, but it's a bit fragile. It would be easy to miss a single game that might cause confusing test failures later.</li><li class="listitem">We could rewrite the games service module to export a function for creating a new service, and instantiate a new service for each test. In general, it's a good idea to try and isolate tests by creating fresh objects under each test. However, this is only useful if the object doesn't store any external state. We may well want to change the implementation of the games service later, to store data externally in a persistent datastore.</li><li class="listitem">We could add a clear method to the games service to wipe out all its data. It's not wrong to create methods like this for the purposes of supporting tests. However, it's preferable to interact with the application via its existing API if possible.</li></ul></div><p>The games <a id="id200" class="indexterm"/>service does offer a way of retrieving all current games. We just need to pass in a user ID that doesn't match the setter of any game. We can then go through and delete all games. We want to do this before every test, which we can do using <a id="id201" class="indexterm"/>Mocha's <code class="literal">beforeEach</code> hook:</p><div class="informalexample"><pre class="programlisting">describe('Game service', () =&gt; {
    const firstUserId = 'user-id-1';
    const secondUserId = 'user-id-2';
    
<span class="strong"><strong>    beforeEach(() =&gt; {</strong></span>
<span class="strong"><strong>        let gamesCreated = service.availableTo("not-a-user");</strong></span>
<span class="strong"><strong>        gamesCreated.forEach(game =&gt; game.remove());</strong></span>
<span class="strong"><strong>    });</strong></span>
        
    describe('list of available games', () =&gt; {    </pre></div><p>If we re-run our tests, they now both pass correctly. There is also an <code class="literal">afterEach</code> hook in Mocha, which we could have used<a id="id202" class="indexterm"/> instead. This would have worked, but it's safer for tests to defend themselves by cleaning up first, rather than relying on other tests to clean up after themselves.</p></div></div>
<div class="section" title="Using Chai for assertions" id="aid-1394Q1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Using Chai for assertions</h1></div></div></div><p>Another way to<a id="id203" class="indexterm"/> make our tests more descriptive is how we write our<a id="id204" class="indexterm"/> assertions. Although the built-in Node.js assert module has been useful so far, it is a bit limited. It only contains a small number of simple methods for basic assertions.</p><p>You may have experience of Fluent Assertions or NUnit's Constraint model in .NET, or AssertJ in Java. Compared to these, the Node.js assert module might seem quite primitive.</p><p>There are<a id="id205" class="indexterm"/> several assertion frameworks available for JavaScript. We'll be using Chai (<a class="ulink" href="http://chaijs.com">http://chaijs.com</a>), which supports three different styles for writing assertions. The <code class="literal">assert</code> style follows the traditional xUnit assertions, as in JUnit, or the classic model of NUnit. The <code class="literal">should</code> and <code class="literal">expect</code> styles provide a natural language interface for building more descriptive assertions.</p><p>Any of these styles is a perfectly valid choice for writing test assertions. The important thing is to pick a style for your codebase and use it consistently. We will be using Chai's <code class="literal">expect</code> syntax throughout this book. This is one of the more common styles in JavaScript testing. The <a id="id206" class="indexterm"/>Jasmine test framework has built-in assertions that<a id="id207" class="indexterm"/> follow a similar style.</p><p>Let's first install Chai by running the following on the command line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install chai --save-dev</strong></span>
</pre></div><p>Then update our tests to use it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>const expect = require('chai').expect;</strong></span>
const service = require('../../src/services/games.js');

...

    it('should include games created by other users', () =&gt; {
        // Given
        service.create(firstUserId, 'testing');
        
        // When
        const games = service.availableTo(secondUserId);
        
        // Then
<span class="strong"><strong>        expect(games.length).to.equal(1);</strong></span>
        const game = games[0];
<span class="strong"><strong>        expect(game.setBy).to.equal(firstUserId);</strong></span>
<span class="strong"><strong>        expect(game.word).to.equal('TESTING');</strong></span>
    });
    
    it('should not include games created by the same user', () =&gt; {
        // Given
        service.create(firstUserId, 'first');
        service.create(secondUserId, 'second');
        
        // When
        const games = service.availableTo(secondUserId);
        
        // Then
<span class="strong"><strong>        expect(games.length).to.equal(1);</strong></span>
        let game = games[0];
<span class="strong"><strong>        expect(game.setBy).not.to.equal(secondUserId);</strong></span>
    });</pre></div><p>The change isn't particularly dramatic at this point as we're only making simple assertions. But <a id="id208" class="indexterm"/>the natural language interface will allow us to specify <a id="id209" class="indexterm"/>more detailed assertions in a descriptive way.</p></div>
<div class="section" title="Creating test doubles" id="aid-147LC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Creating test doubles</h1></div></div></div><p>There are <a id="id210" class="indexterm"/>more tests we could write for the games service, but let's look at a different module for now. How would we go about testing our <code class="literal">users</code> middleware? The following code is from <code class="literal">middleware/users.js</code>:</p><div class="informalexample"><pre class="programlisting">module.exports = function(req, res, next) {
    let userId = req.cookies.userId;
    if (!userId) {
        userId = uuid.v4();
        res.cookie('userId', userId);
    }
    req.user = {
        id: userId
    };
    next();
};</pre></div><p>In order to test this class, we will need to pass in arguments for the <code class="literal">req</code>, <code class="literal">res</code>, and <code class="literal">next</code> parameters with which our code interacts. We don't have a real request, response, or middleware pipeline available, so we need to create some stand-in values instead. Stand-in values such as this are generally called <span class="strong"><strong>test doubles</strong></span>. Our code reads an attribute from the request and calls the <a id="id211" class="indexterm"/>cookie method on the response. We can create test doubles for these as follows, in a new test script under <code class="literal">test/middleware/users.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const middleware = require('../../middleware/users.js');
const expect = require('chai').expect;

describe('Users middleware', () =&gt; {    
    const defaultUserId = 'user-id-1';
    let request, response;
    
    beforeEach(() =&gt; {
        request = { cookies: {} };
        response = { cookie: () =&gt; {} };
    });
    
    it('if the user already signed in, reads their ID from a cookie and exposes the user on the request', () =&gt; {
        // Given
        request.cookies.userId = defaultUserId;
        
        // When
        middleware(request, response, () =&gt; {});
        
        // Then
        expect(request.user).to.exist;
        expect(request.user.id).to.equal(defaultUserId);
    }); 
});</pre></div><p>Here, we simply<a id="id212" class="indexterm"/> create a plain JavaScript object to represent the request. This allows us to verify that the production code reads from, and writes to, the request properties correctly. We just pass in the minimum possible input for the response object and the <code class="literal">next</code> function to allow the code to execute. This is very easy to do in JavaScript, partly because it is not statically typed. Creating test doubles like this in C# or Java can be a lot more work as the compiler will insist on the test doubles matching the corresponding parameter types.</p><p>We also need to test that our middleware calls the next middleware in the chain, as this is important behavior. This is slightly more complex than just creating an object with simple properties. We can still create a suitable test double by defining a new function that records when it is called (this kind of test<a id="id213" class="indexterm"/> double is called a <span class="strong"><strong>spy</strong></span>):</p><div class="informalexample"><pre class="programlisting">    it('calls the next middleware in the chain', () =&gt; {
        // Given
        let calledNext = false;
        const next = () =&gt; calledNext = true;
        
        // When
        middleware(request, response, next);
        
        // Then
        expect(calledNext).to.be.true;
    });</pre></div><p>This works perfectly well, but will become more cumbersome if we want to test more complex calls, for example, if we want to check for multiple calls or make further assertions about the arguments passed in. We can simplify this by making use of a framework to create test doubles for us.</p><div class="section" title="Creating test doubles using Sinon.JS"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec35"/>Creating test doubles using Sinon.JS</h2></div></div></div><p>Sinon.JS is a<a id="id214" class="indexterm"/> framework for creating all kinds of test <a id="id215" class="indexterm"/>doubles. Let's first install it into our application by running the following on the command line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install sinon --save-dev</strong></span>
</pre></div><p>Now let's simplify our previous test and write a more complex test using test doubles created by Sinon.JS:</p><div class="informalexample"><pre class="programlisting">const expect = require('chai').expect;
<span class="strong"><strong>const sinon = require('sinon');</strong></span>

...

    it('calls the next middleware in the chain', () =&gt; {
          // Given
<span class="strong"><strong>        const next = sinon.spy();</strong></span>
        
        // When
        middleware(request, {}, next);
        
        // Then
        expect(next.called).to.be.true;
    });
    
<span class="strong"><strong>    it('if the user is not already signed in, ' +</strong></span>
<span class="strong"><strong>        'creates a new user id and stores it in a cookie', () =&gt; {</strong></span>
<span class="strong"><strong>        // Given</strong></span>
<span class="strong"><strong>        request.cookies.userId = undefined;</strong></span>
<span class="strong"><strong>        response = { cookie: sinon.spy() };</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>        // When</strong></span>
<span class="strong"><strong>        middleware(request, response, () =&gt; {});</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>        // Then</strong></span>
<span class="strong"><strong>        expect(request.user).to.exist;</strong></span>
<span class="strong"><strong>        const newUserId = request.user.id;</strong></span>
<span class="strong"><strong>        expect(newUserId).to.exist;</strong></span>
<span class="strong"><strong>        expect(response.cookie.calledWith(</strong></span>
<span class="strong"><strong>            'userId', newUserId)).to.be.true;</strong></span>
    });</pre></div><p>Sinon.JS spies keep track of the details of all calls made to them and provide a convenient API for checking these. This allows us to keep our test code simple and readable. There are many more properties than just the <code class="literal">called</code> and <code class="literal">calledWith</code> user here. Take <a id="id216" class="indexterm"/>a look at the Sinon.JS documentation <a id="id217" class="indexterm"/>at <a class="ulink" href="http://sinonjs.org/docs/#spies-api">http://sinonjs.org/docs/#spies-api</a> to see some of the other ways we can verify the calls <a id="id218" class="indexterm"/>made against a spy.</p><div class="note" title="Note"><h3 class="title"><a id="note07"/>Note</h3><p>
<span class="strong"><strong>Spies, stubs, and mocks</strong></span>
</p><p>If you read <a id="id219" class="indexterm"/>more of the Sinon.JS documentation, you'll see that it's very<a id="id220" class="indexterm"/> explicit about the difference between spies, stubs, and mocks. This<a id="id221" class="indexterm"/> is in contrast to most popular test double frameworks in Java and .NET, which tend to call all test doubles by the same name (typically mock or fake). In reality though, most instances of test doubles typically only act as a spy (used for verifying side-effects) or a stub (used for providing data, or throwing exceptions to test error-handling). A true mock verifies a specific sequence of calls and returns specific data to the code under test. Although some of the early mocking frameworks in Java and .NET only supported this type of test double (now sometimes called a <span class="emphasis"><em>strict mock</em></span>), it isn't common practice anymore. This is<a id="id222" class="indexterm"/> because it quite tightly couples test and production code and makes refactoring more difficult. It's especially rare to have more than one mock (as opposed to just a stub or spy) in a single test.</p></div></div></div>
<div class="section" title="Testing an Express application" id="aid-1565U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Testing an Express application</h1></div></div></div><p>While using <a id="id223" class="indexterm"/>Sinon.JS makes our tests neater, they still depend on the details of the Express middleware API and how we're using it. This might be appropriate for our middleware module as we want to ensure that it fulfills a particular contract (especially calling <code class="literal">next</code> and setting <code class="literal">request.user</code>). For most middleware, though, especially our routes, this approach would couple our tests too closely to our implementation.</p><p>It would be better to test the actual behavior of each route by making HTTP requests to it and examining the responses, rather than checking for specific low-level interactions with the request and response objects. This gives us more flexibility to change our implementation and refactor our code, without needing to change the tests. Thus, our tests can support this process (by catching regressions) rather than hindering it (by having to be updated to match our implementation).</p><p>On other platforms, testing a whole application can be quite a heavyweight process. It is possible to start up a server in process, for example, using Jetty in Java or Katana in .NET. Newer application frameworks, such as Spring Boot or NancyFx, also make this process easier. These are still likely to be relatively slow and resource-intensive tests, though.</p><p>In Node.js, starting<a id="id224" class="indexterm"/> up an application server is easy and very lightweight. We just use the same <code class="literal">http.createServer</code> call as we've seen before, and pass it an application. To test our route in isolation, we'll bootstrap a new application containing just this route. Let's see how we can use this to test the delete endpoint of our games route. We add the following code under <code class="literal">test/routes/games.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';

const http = require('http');
const express = require('express');
const bodyParser = require('body-parser');
const expect = require('chai').expect;
const gamesService = require('../../src/services/games.js');

const TEST_PORT = 5000, userId = 'test-user-id';

describe('/games', () =&gt; {
  let server;
  const makeRequest = (method, path, callback) =&gt; {
    http.request({
      method: method,
      port: TEST_PORT,
      path: path
    }, callback).end();
  };
  
  before(done =&gt; {
    const app = express();
    app.use(bodyParser.json());
    app.use((req, res, next) =&gt; {
      req.user = { id: userId }; next();
    });
    
    const games = require('../../src/routes/games.js');
    app.use('/games', games);
    
    server = http.createServer(app).listen(TEST_PORT, done);
  });
  
  afterEach(() =&gt; {
    const gamesCreated = gamesService.availableTo("non-user");
    gamesCreated.forEach(game =&gt; game.remove());
  });
  
  after(done =&gt; {
    server.close(done);
  });
  
  describe('/:id DELETE', () =&gt; {
    it('should allow users to delete their own games', done =&gt; {
      const game = gamesService.create(userId, 'test');
      
      makeRequest('DELETE', '/games/' + game.id, response =&gt; {
        expect(response.statusCode).to.equal(200);
        expect(gamesService.createdBy(userId)).to.be.empty;
        done();
      });
    });
  });
});</pre></div><p>This might seem <a id="id225" class="indexterm"/>like quite a lot of code, but remember that we're firing up an entire application here. Also, most of this code will be reused for multiple tests. Let's work through what it does.</p><p>The <code class="literal">before</code> callback creates our server, just as we saw in <a class="link" title="Chapter 2. Getting Started with Node.js" href="part0018.xhtml#aid-H5A41">Chapter 2</a>
<span class="emphasis"><em>, Getting Started with Node.js</em></span>, listening on a special port for use by our tests. It also sets up some stub middleware to simulate a current user on the request. The <code class="literal">afterEach</code> callback clears up any created games (as we saw before in the test of the games service). Note that since we're running in the same process, we can trivially interact with the same data layer that our application is using. Finally, the <code class="literal">after</code> function asks the server to stop listening for connections.</p><p>The test itself is very simple: we just create a game set by the current user (as in our service tests before) and then issue a request to delete it. This makes use of our own <code class="literal">makeRequest</code> function, which simply calls through to Node's <code class="literal">http.request</code>. We can then inspect the response object to check for the appropriate status code, and check the service for the desired effect.</p><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Writing asynchronous tests in Mocha</strong></span>
</p><p>Notice that <a id="id226" class="indexterm"/>our test and all of the callbacks to <a id="id227" class="indexterm"/>Mocha's hook functions discussed above (except for afterEach) take a <code class="literal">done</code> parameter. This is because all of these tests perform some asynchronous work. Mocha makes it very easy to write asynchronous tests or hooks: you just make your callback function take a single parameter (called <code class="literal">done</code> by convention), and call it when processing is complete. If it's not called within a timeout (which defaults to 2 seconds but can be changed), then Mocha fails the test.</p></div><p>Let's run our<a id="id228" class="indexterm"/> tests again using the <code class="literal">npm test</code> command. Notice that all of the tests still finish very quickly (tens of milliseconds on my machine), even though we're starting up our whole server-side application. You may also notice the output is a bit messy due to log output from the server.  We can easily suppress this by updating app.js as follows:</p><div class="informalexample"><pre class="programlisting">//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
<span class="strong"><strong>if (app.get('env') === 'development') {</strong></span>
<span class="strong"><strong>    app.use(logger('dev'));</strong></span>
<span class="strong"><strong>}</strong></span>
app.use(bodyParser.json());</pre></div><p>The <code class="literal">'env'</code> property of an Express application comes from the <code class="literal">NODE_ENV</code> environment variable (or defaults to development if this is not present). This is useful for differentiating between production and development environments. Since it defaults to <code class="literal">development</code>, we also need to set it to something else in order to suppress this logging in our tests. We can do this by updating our test script in <code class="literal">package.json</code> as follows:</p><div class="informalexample"><pre class="programlisting">  "scripts": {
    "start": "node ./bin/www",
<span class="strong"><strong>    "test": "set NODE_ENV=test &amp;&amp; node node_modules/mocha/bin/mocha test/**/*.js"</strong></span>
  },</pre></div><div class="section" title="Simplifying tests using SuperAgent"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Simplifying tests using SuperAgent</h2></div></div></div><p>While our<a id="id229" class="indexterm"/> tests are fast, and setting<a id="id230" class="indexterm"/> up the server is quite straightforward, we<a id="id231" class="indexterm"/> do have quite a lot of code for making requests to the server and handling responses. This would become more complex if we needed to make a wider variety of requests, or were interested in more than just the response status code or headers.</p><p>We can simplify our tests by using a library that provides a simpler API for communicating<a id="id232" class="indexterm"/> with the server. SuperAgent (<a class="ulink" href="https://visionmedia.github.io/superagent/">https://visionmedia.github.io/superagent/</a>) is a JavaScript library that provides a fluent, readable syntax for making HTTP requests. This can be used for Ajax requests in the browser, or for requests in a Node.js application as we're doing here.</p><p>We'll make use <a id="id233" class="indexterm"/>of SuperAgent through a lightweight wrapper called SuperTest (<a class="ulink" href="https://github.com/visionmedia/supertest">https://github.com/visionmedia/supertest</a>), which makes testing Node.js-based HTTP applications even more convenient.</p><p>First, we add SuperTest into our application using <code class="literal">npm</code>, by running the following on the command<a id="id234" class="indexterm"/> line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install supertest --save-dev</strong></span>
</pre></div><p>Now <a id="id235" class="indexterm"/>we can rewrite our tests as <a id="id236" class="indexterm"/>follows:</p><div class="informalexample"><pre class="programlisting">'use strict';

const express = require('express');
const bodyParser = require('body-parser');
<span class="strong"><strong>const request = require('supertest');</strong></span>
const expect = require('chai').expect;
const gamesService = require('../../src/services/games.js');

const userId = 'test-user-id';

describe('/games', () =&gt; {
<span class="strong"><strong>  let agent, app;</strong></span>
  
  before(() =&gt; {
    app = express();
    app.use(bodyParser.json());
    app.use((req, res, next) =&gt; {
      req.user = { id: userId }; next();
    });
    
    const games = require('../../src/routes/games.js');
    app.use('/games', games);
  });
  
<span class="strong"><strong>  beforeEach(() =&gt; {</strong></span>
<span class="strong"><strong>    agent = request.agent(app);</strong></span>
<span class="strong"><strong>  });</strong></span>
  
  describe('/:id DELETE', () =&gt; {
    it('should allow users to delete their own games', done =&gt; {
<span class="strong"><strong>      const game = gamesService.create(userId, 'test');</strong></span>
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>      agent</strong></span>
<span class="strong"><strong>        .delete('/games/' + game.id)</strong></span>
<span class="strong"><strong>        .expect(200)</strong></span>
<span class="strong"><strong>        .expect(() =&gt;</strong></span>
<span class="strong"><strong>           expect(gamesService.createdBy(userId)).to.be.empty)</strong></span>
<span class="strong"><strong>        .end(done);</strong></span>
    });
  });
});</pre></div><p>SuperTest and SuperAgent take care of starting up the server for our application, and provide a much simpler API for making requests. Note the use of a request <span class="strong"><strong>agent</strong></span>, which represents <a id="id237" class="indexterm"/>a single browser <a id="id238" class="indexterm"/>session.</p><p>SuperAgent provides<a id="id239" class="indexterm"/> a number of functions (<code class="literal">get</code>, <code class="literal">post</code>, <code class="literal">delete</code>, and so on) for making HTTP requests. These can be chained with calls to the <code class="literal">expect</code> function (not to be confused with Chai's <code class="literal">expect</code>) to verify properties of the response, such as the status code. We can also pass in a callback to make specific checks about the response, or verify side-effects (as we do in the previous example).</p><p>Note that it is important to always call the <code class="literal">end</code> function to make sure any expectation errors are thrown and fail the test. We can pass Mocha's <code class="literal">done</code> callback to end the test when the request is completed.</p><p>Now that we've simplified our test code, we can easily add more tests for our routes. For example, let's add some tests to cover the negative cases of our delete endpoint:</p><div class="informalexample"><pre class="programlisting">    it('should not allow users to delete games that they did not set', done =&gt; {
      const game = gamesService.create('another-user-id', 'test');
      agent
        .delete('/games/' + game.id)
        .expect(403)
        .expect(() =&gt; expect(gamesService.get(game.id).ok))
        .end(done);
    });

    it('should return a 404 for requests to delete a game that no longer exists', done =&gt; {
      const game = gamesService.create(userId, 'test');
      agent
        .delete(`/games/${game.id}`)
        .expect(200)
        .end(function(err) {
          if (err) {
            done(err);
          } else {
            agent
              .delete('/games/' + game.id)
              .expect(404, done);
          }
        });
    });</pre></div></div></div>
<div class="section" title="Full-stack testing with PhantomJS" id="aid-164MG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Full-stack testing with PhantomJS</h1></div></div></div><p>We have now written unit tests for logic at the core of our application and integration tests for our <a id="id240" class="indexterm"/>server-side routes. We don't yet have any<a id="id241" class="indexterm"/> automated tests that cover our views and client-side scripts as our manual testing throughout the previous chapters did.</p><p>We can write unit tests for client-side scripts using Mocha. However, all of our current client-side scripts interact with the server, so aren't good candidates for unit testing. Our manual tests are really full-stack tests of our whole application, including the interaction between the server and the client.</p><p>In order to achieve this in an automated test, we will need to use some form of browser automation. <span class="strong"><strong>PhantomJS</strong></span> is a headless browser with a JavaScript API that allows us to automate it<a id="id242" class="indexterm"/> directly. We can write a simple test for our game page using this.</p><p>First, we'll install PhantomJS within our project by running the following on the command line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; npm install phantomjs-prebuilt --save-dev</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="note08"/>Note</h3><p>PhantomJS is not a Node.js module. It is a standalone, headless web browser. The npm module is just a convenient way of installing it and making it a dependency of the project. PhantomJS cannot be invoked from Node.js, except to execute it as a separate child process.</p></div><p>Now we can implement a test as follows, under <code class="literal">integration-test/game.js</code>:</p><div class="informalexample"><pre class="programlisting">(function() {
    'use strict';

    var expect = require('chai').expect;
    var page = require('webpage').create();
    var rootUrl = 'http://localhost:3000';
    
    withGame('Example', function() {
        expect(getText('#word')).to.equal('_______');
         
        page.evaluate(function() {
            $(document).ajaxComplete(window.callPhantom);
        });
        
        page.sendEvent('keydown', page.event.key.E);
        page.onCallback = verify(function() {
            expect(getText('#word')).to.equal('E_____E');
            expect(getText('#missedLetters')).to.be.empty;
            
            page.sendEvent('keydown', page.event.key.T);
            page.onCallback = verify(function() {
                expect(getText('#word')).to.equal('E_____E');
                expect(getText('#missedLetters')).to.equal('T');
                
                console.log('Test completed successfully!');
                phantom.exit();
            });
        });
    });
    
    function withGame(word, callback) {
        ...
    }
    
    function getText(selector) {
        return page.evaluate(function(s) {
            return $(s).text();
        }, selector);
    }
    
    function verify(expectations) {
        return function() { 
            try {
                expectations();
            } catch(e) {
                console.log('Test failed!');
                handleError(e.message);
            }
        }
    }
    
    function handleError(message) {
        console.log(message);
        phantom.exit(1);
    }
    
    phantom.onError = page.onError = handleError;
}());</pre></div><p>Make sure the application is running (using <code class="literal">npm start</code>), then execute the test by running the following on the command line:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; node node_modules/phantomjs-prebuilt/bin/phantomjs integration-test/game.js</strong></span>
</pre></div><p>Let's take a look through the code to understand how it works. Note that we're running in the browser environment here rather than Node.js, so fall back to the ECMAScript 5 syntax (for example, <code class="literal">var</code> instead of <code class="literal">let</code>, and no arrow functions).</p><p>The omitted <code class="literal">withGame</code> method (which you can find in the book's companion code) uses PhantomJS to<a id="id243" class="indexterm"/> load the index view and submit a new game, then <a id="id244" class="indexterm"/>clears PhantomJS's cookies and opens the game as a new user, before invoking the callback passed to <code class="literal">withGame</code>.</p><p>In our test, we create a game to guess the word <span class="emphasis"><em>example</em></span>, then invoke JavaScript within the page to make assertions about its contents. The <code class="literal">getText</code> function uses PhantomJS's <code class="literal">page.evaluate</code> function to run some JavaScript within the context of the page, and return a value. Note that the callback function passed to <code class="literal">page.evaluate</code> does not have access to the wider execution context of our script. We can, however, specify additional arguments to the <code class="literal">page.evaluate</code> call, which is how we pass in the selector for jQuery.</p><p>We then use <code class="literal">page.evaluate</code> again to set up a callback each time an Ajax request completes. Here, we use <code class="literal">window.callPhantom</code>, which executes within the context of the page, and triggers <code class="literal">page.onCallback</code>, which executes within the context of our test.</p><p>Finally, we use <code class="literal">page.sendEvent</code> to trigger a keyboard event in the browser. Note that this is not the same as using pure JavaScript within the browser to trigger a DOM event, but is an instruction directly to PhantomJS to simulate the <code class="literal">keypress</code> event as if it had come from the user.</p><p>If we put all this together, we get the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We use <code class="literal">page.sendEvent</code> to simulate pressing a keyboard key</li><li class="listitem">This causes our production code to send off an Ajax request</li><li class="listitem">When this request completes, <code class="literal">window.callPhantom</code> is invoked in the context of the browser</li><li class="listitem">This causes PhantomJS to invoke our <code class="literal">page.onCallback</code> function</li><li class="listitem">We then use jQuery within <code class="literal">page.evaluate</code> (via <code class="literal">getText</code>) to retrieve values from the page</li></ul></div><p>The remaining contents of the file (<code class="literal">verify</code> and <code class="literal">handleError</code>) ensure that PhantomJS writes all errors to the console and sets an appropriate exit code in the case of a failure.</p></div>
<div class="section" title="Summary" id="aid-173721"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we have learned how to write unit tests in Node.js, used Mocha and Chai to write more descriptive tests, created test doubles using Sinon.JS, written application level tests using SuperAgent and SuperTest, and implemented a full-stack test in PhantomJS.</p><p>Although we have tests at each layer of our application now, we haven't yet covered all of our code. It would be useful to find any gaps where we should write more tests. We also have to invoke a few different commands to run all of our unit and integration tests. In the next chapter, we'll see how to automate these and other processes as part of a continuous integration build.</p></div></body></html>