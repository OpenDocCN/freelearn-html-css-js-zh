- en: Extending Types with New Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen that Reason provides tools and techniques
    that open possibilities for programming generically. One is parametric polymorphism
    using type variables. Another one is the functor, which can take one or several
    modules as parameters and return a module.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at ways of extending types themselves
    to add behavior to them. One such technique available in Reason is called **subtyping**.
    The idea is to have a hierarchical relation of types, with specific types being
    subtypes of more generic types. For example, a *cat* could be a subtype of *mammal*,
    which itself is a subtype of *vertebrate*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find a definition about the subtyping approach in the OCaml documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping governs when an object with one type A can be used in an expression
    that expects an object of another type B. When this is true, we say that A is
    a subtype of B. More concretely, subtyping restricts when the coercion operator
    `e :> t` can be applied. This coercion works only if the type of e is a subtype
    of t.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to subtyping, there are techniques similar to what we do with **Object-Oriented
    Programming (OOP)**-style inheritance, which can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation and use cases, you can leverage one or several of
    these techniques to improve your code's structure and make it easy to extend its
    features, while keeping your code type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping using polymorphic variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reuse with OOP-style inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtyping using polymorphic variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 5](d3723975-7a3c-4369-84fe-272b67870234.xhtml), *Putting
    Alternative Values in Types,* Reason has the concept of variant types, which can
    be leveraged in pattern matching and exhaustivity checking. Variant types have
    their more complex and powerful version called **polymorphic variants***.* They
    give us more flexibility than regular variants. Among other things, they are defined
    using a special syntax, such as ``type color = [`Red | `Orange | `Yellow | `Green
    | `Blue ];``, and their constructors exist independently.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how they can be used for extending type behavior using subtyping.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing constructors for different types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since constructors exist independently, we can use the same constructor more
    than once. So, we can define a type, `rgb`, that uses the `Red`, `Green`, and
    `Blue` constructors that came with the definition for the type, `color`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we start with both type definitions, followed by a couple of bindings
    to use those types (`onegreen` and `othergreen`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add code to show the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, if you try executing the JavaScript resulting from the compilation
    of this Reason code, you would get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the identifier printed is the same for both variables, which
    we could have had the intuition of, since we have used the same constructor (``
    `Green ``).
  prefs: []
  type: TYPE_NORMAL
- en: Let's make this visually interesting by adding functions that stringify the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a function that gives a string value for each color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a function that gives a string value for each *RGB color*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add the same code that is useful to log the values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what''s the result of this new experiment? The compilation of the complete
    version of the code (in the `src/Ch09/Ch09_Example1.re` file) gives a JS code
    file which, when executed using the `node` command, would give an output similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you would have guessed, using two different functions, we were able to differentiate
    the output based on the type of the input (and the constructor involved, for example,
    the polymorphic constructor, `Green`).
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise left for the reader, add `Js.log(stringOfRgb(onegreen));` to
    the ReasonML code and see what you get as output for that call.
  prefs: []
  type: TYPE_NORMAL
- en: An example of polymorphic variant type extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a more interesting trick of code reuse. It is possible to extend an
    existing polymorphic variant type to create a new one. Let's see this through
    another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to handle input for shoe categories, for both the general
    public and for women, and we started by defining the categories specific to women,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could define the polymorphic variants for all (women and men) by reusing
    that type definition and extending it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the result of these types with the code file, `src/Ch09/Ch09_Example2.re`.
    As usual, we add some console logging (with `Js.log()`) to make things interesting.
    The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the JS code that results from the compilation gives an output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting to see what could happen at compile time if you make a mistake
    when binding the constructor to the `janedoe_shoe` variable, for example, writing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it, and during re-compilation, you will immediately see an error similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, back to our normal code! Could we improve our code here to write less?
    Could we leverage the variants type, `onlyWomanShoe`, in the `infoAboutShoe()`
    function, to avoid the two lines in the `switch` block for `Slingbacks` and `HighHeels`,
    and try to make this really powerful?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a trick to do that, using a syntax sugar within the `switch` block
    of the function: `#onlyWomanShoe`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explain in detail later where this comes from, but basically we could
    write this almost-equivalent code (`src/Ch09/Ch09_Example2bis.re`), where we only
    change the body of the `infoAboutShoe` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the JS code produced by the compilation gives output such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More about extending polymorphic variant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we have a type definition for websites and we want to extend it to
    all web apps (including personal productivity tools, social networks, and even
    APIs). We could first define the main things that characterize a website, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether there is an access by login or not (for the main content), that is,
    private or public access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, we can first define two utility types, `domain` and `accessType`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a helper function to stringify the `accessType` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the variants type for websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a function that would return a short summary text containing the
    information for each website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, for testing purposes, we add a few bindings and show the results
    in the console using `Js.log()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that part working. But, we are not done yet. We also want to extend
    that code to apply to any webapp. So, we define a new type, for *web apps* (`webapp`,
    as you would guess) with the intent of being an extension of the *websites* one.
    The type definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After that, we add a new function (`appSummary()`) that will extend the previous
    one (`siteSummary()`). One technique we use here is the `as` keyword, allowing
    us (in the `switch` part of the function) to match a result to a constructor of
    the `website` variant type. For example, we can write `` `CorporateSite(`Domain(s))
    as ws ``.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can actually improve this a little bit; to avoid the compiler
    from complaining about the `s` and `a` variables not being used in the first three
    lines of the `switch` block, we can replace those variables by the `_`. The improved
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can finish by adding some testing code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But wait, there is more improvement possible!
  prefs: []
  type: TYPE_NORMAL
- en: Another technique is to reuse the first type via the `#website as ws` syntax
    and that allows us to completely replace the lines related to the `website` variant
    type constructors in the pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version of the function would then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And, after this update, to make things interesting, here is the final testing
    and value display code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that executing the JavaScript code produced by the compilation gives
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We just saw a nice type extension technique supported by Reason with polymorphic
    type variants.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse with OOP-style inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance, as we have in object oriented programing languages, is not commonly
    used in Reason. However, we can find a couple of examples of techniques that resemble
    OOP-style inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constantly referring to something in a module imposes a lot of writing on the
    developer. This is where `open` is handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without this feature, let''s say you have the `ColorExample` module (based
    on code we already used in the first example of this chapter), defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the function by using the `ColorExample.stringOfColor` reference
    and similarly for the values. So, some value display code would look like the
    following (as actually seen in the `src/Ch09/Ch09_Open_module.re` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But, with the `open` solution for opening the module within a scope, we can
    write more compact code, as follows (in the same `src/Ch09/Ch09_Open_module.re`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And things work as expected! The code file when executed gives the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What happens is that all of the contents of the module are magically accessible
    without the need to add the prefix that would normally be added (the `ColorExample.`
    part, in this case) when accessing the types, functions, and variables it contains.
    It brings the module's content into the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have done things in an alternative way: have the module in its own
    file for better separation of code. There are cases where you would want to do
    that if it better fits your way of organizing the code. So basically, let''s move
    the module''s code in the `src/Ch09/Ch09_OpenModulebisPart1.re` file, for example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another code file (`src/Ch09/Ch09_OpenModulebisPart2.re`, for example),
    we can open the module and access its functions and values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have seen how to leverage `open` for opening modules in Reason.
    And, in code that you can find written by other developers, you can find it used
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Including a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason also provides a way to reuse a module already defined, and extend it
    like in OOP: the `include` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding this feature, the documentation actually says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `include` in a module, statically transfers a module's content into a
    new one. Thus often fulfills the role of inheritance or mixing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a base module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we reuse it in the following module, using the `include` technique, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we can display information using a function from each module, in order
    to compare the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the JS code produced by compiling our code (in the `src/Ch09/Ch09_Include_module.re`
    file) gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Interesting. You could already have the intuition of what happens here, but
    the ReasonML documentation about `include` stipulates that this technique copies
    over the definition of a module *statically*, then also performs `open`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how you can leverage two types of techniques, subtyping using
    polymorphic variants and OOP-style inheritance with modules, to improve your code
    structure and make it easy to add behavior to types.
  prefs: []
  type: TYPE_NORMAL
- en: With polymorphic variant types, we can reuse constructors for different types
    because of their design. Furthermore, it is possible to extend a polymorphic variant
    type to create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: With modules, we can open an existing module to use functions and bindings defined
    in it, and we can include it in a new module to extend its behavior line in OOP-style
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter, we are going to go through a final example where
    we bring together the main techniques we have learned so far.
  prefs: []
  type: TYPE_NORMAL
