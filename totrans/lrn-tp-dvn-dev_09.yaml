- en: Extending Types with New Behavior
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新行为扩展类型
- en: In the previous chapter, we have seen that Reason provides tools and techniques
    that open possibilities for programming generically. One is parametric polymorphism
    using type variables. Another one is the functor, which can take one or several
    modules as parameters and return a module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 Reason 提供的工具和技术，这些工具和技术为通用编程开辟了可能性。一个是使用类型变量的参数多态性。另一个是函子，它可以接受一个或多个模块作为参数并返回一个模块。
- en: In this chapter, we are going to look at ways of extending types themselves
    to add behavior to them. One such technique available in Reason is called **subtyping**.
    The idea is to have a hierarchical relation of types, with specific types being
    subtypes of more generic types. For example, a *cat* could be a subtype of *mammal*,
    which itself is a subtype of *vertebrate*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨扩展类型本身以添加行为的方法。Reason 中可用的一种技术称为 **子类型化**。其思想是类型之间存在层次关系，具体类型是更通用类型的子类型。例如，一只
    *猫* 可以是 *哺乳动物* 的子类型，而 *哺乳动物* 本身又是 *脊椎动物* 的子类型。
- en: 'We can find a definition about the subtyping approach in the OCaml documentation:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 OCaml 文档中找到一个关于子类型化方法的定义：
- en: Subtyping governs when an object with one type A can be used in an expression
    that expects an object of another type B. When this is true, we say that A is
    a subtype of B. More concretely, subtyping restricts when the coercion operator
    `e :> t` can be applied. This coercion works only if the type of e is a subtype
    of t.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型化控制着一个类型 A 的对象能否被用于期望另一个类型 B 的对象的表达式中。当这是真的时，我们说 A 是 B 的子类型。更具体地说，子类型化限制了何时可以应用转换操作符
    `e :> t`。这种转换仅在 e 的类型是 t 的子类型时才有效。
- en: In addition to subtyping, there are techniques similar to what we do with **Object-Oriented
    Programming (OOP)**-style inheritance, which can be useful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了子类型化之外，还有一些类似于我们在面向对象编程（OOP）风格的继承中所做的技术，这些技术可能很有用。
- en: Depending on the situation and use cases, you can leverage one or several of
    these techniques to improve your code's structure and make it easy to extend its
    features, while keeping your code type-safe.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体情况和使用案例，你可以利用这些技术中的一个或多个来改进你的代码结构，使其易于扩展功能，同时保持代码的类型安全性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Subtyping using polymorphic variants
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多态变体进行子类型化
- en: Code reuse with OOP-style inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OOP 风格的继承进行代码复用
- en: Subtyping using polymorphic variants
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多态变体进行子类型化
- en: As we have seen in [Chapter 5](d3723975-7a3c-4369-84fe-272b67870234.xhtml), *Putting
    Alternative Values in Types,* Reason has the concept of variant types, which can
    be leveraged in pattern matching and exhaustivity checking. Variant types have
    their more complex and powerful version called **polymorphic variants***.* They
    give us more flexibility than regular variants. Among other things, they are defined
    using a special syntax, such as ``type color = [`Red | `Orange | `Yellow | `Green
    | `Blue ];``, and their constructors exist independently.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 5 章](d3723975-7a3c-4369-84fe-272b67870234.xhtml) 中所看到的，*在类型中放置替代值*，Reason
    有变体类型的概念，这可以在模式匹配和完备性检查中发挥作用。变体类型有它们更复杂和强大的版本，称为 **多态变体***。它们比常规变体提供了更多的灵活性。例如，它们使用特殊的语法定义，如
    `type color = [Red | Orange | Yellow | Green | Blue ];`，并且它们的构造函数是独立存在的。
- en: Let's see how they can be used for extending type behavior using subtyping.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们如何通过子类型化来扩展类型行为。
- en: Reusing constructors for different types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用不同类型的构造函数
- en: Since constructors exist independently, we can use the same constructor more
    than once. So, we can define a type, `rgb`, that uses the `Red`, `Green`, and
    `Blue` constructors that came with the definition for the type, `color`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数是独立存在的，我们可以多次使用同一个构造函数。因此，我们可以定义一个名为 `rgb` 的类型，它使用与 `color` 类型定义一起提供的
    `Red`、`Green` 和 `Blue` 构造函数。
- en: 'Here, we start with both type definitions, followed by a couple of bindings
    to use those types (`onegreen` and `othergreen`):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了类型，然后是几个绑定来使用这些类型（`onegreen` 和 `othergreen`）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s also add code to show the values:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一些代码来展示值：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, if you try executing the JavaScript resulting from the compilation
    of this Reason code, you would get output similar to this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你尝试执行编译此 Reason 代码生成的 JavaScript，你会得到类似以下输出的结果：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the identifier printed is the same for both variables, which
    we could have had the intuition of, since we have used the same constructor (``
    `Green ``).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，打印的标识符对两个变量都是相同的，这我们可能已经有所预感，因为我们使用了相同的构造函数（` `Green ``）。
- en: Let's make this visually interesting by adding functions that stringify the
    values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加将值转换为字符串的函数来使这个例子更直观。
- en: 'We add a function that gives a string value for each color, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个函数，为每个颜色提供一个字符串值，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We add a function that gives a string value for each *RGB color*, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个函数，为每个 *RGB 颜色* 提供一个字符串值，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we add the same code that is useful to log the values, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了相同的代码，用于记录值，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, what''s the result of this new experiment? The compilation of the complete
    version of the code (in the `src/Ch09/Ch09_Example1.re` file) gives a JS code
    file which, when executed using the `node` command, would give an output similar
    to this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个新实验的结果是什么？完整版本的代码（在 `src/Ch09/Ch09_Example1.re` 文件中）编译后生成一个 JS 代码文件，使用
    `node` 命令执行时，输出结果类似于以下内容：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you would have guessed, using two different functions, we were able to differentiate
    the output based on the type of the input (and the constructor involved, for example,
    the polymorphic constructor, `Green`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，使用两个不同的函数，我们能够根据输入类型（以及涉及的构造函数，例如多态构造函数 `Green`）来区分输出。
- en: As an exercise left for the reader, add `Js.log(stringOfRgb(onegreen));` to
    the ReasonML code and see what you get as output for that call.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为留给读者的练习，将 `Js.log(stringOfRgb(onegreen));` 添加到 ReasonML 代码中，并查看该调用输出的结果。
- en: An example of polymorphic variant type extension
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态变体类型扩展的示例
- en: There is a more interesting trick of code reuse. It is possible to extend an
    existing polymorphic variant type to create a new one. Let's see this through
    another example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码复用的一个更有趣的技巧是，可以将现有的多态变体类型扩展以创建一个新的类型。让我们通过另一个例子来看一下。
- en: 'Let''s say we want to handle input for shoe categories, for both the general
    public and for women, and we started by defining the categories specific to women,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网站类型定义，我们想将其扩展到所有网络应用（包括个人生产力工具、社交网络，甚至 API）。我们首先定义了特定于女性的类别，如下所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could define the polymorphic variants for all (women and men) by reusing
    that type definition and extending it, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重用该类型定义并扩展它来为所有（女性和男性）定义多态变体，如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the result of these types with the code file, `src/Ch09/Ch09_Example2.re`.
    As usual, we add some console logging (with `Js.log()`) to make things interesting.
    The complete code is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过代码文件 `src/Ch09/Ch09_Example2.re` 来查看这些类型的结果。像往常一样，我们添加一些控制台日志（使用 `Js.log()`）使事情更有趣。完整的代码如下：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Executing the JS code that results from the compilation gives an output similar
    to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行编译结果生成的 JS 代码会输出类似于以下内容：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is interesting to see what could happen at compile time if you make a mistake
    when binding the constructor to the `janedoe_shoe` variable, for example, writing
    the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在将构造函数绑定到 `janedoe_shoe` 变量时出错，例如，写下以下内容，编译时会发生什么很有趣：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try it, and during re-compilation, you will immediately see an error similar
    to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，在重新编译期间，你会立即看到类似于以下错误的错误：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, back to our normal code! Could we improve our code here to write less?
    Could we leverage the variants type, `onlyWomanShoe`, in the `infoAboutShoe()`
    function, to avoid the two lines in the `switch` block for `Slingbacks` and `HighHeels`,
    and try to make this really powerful?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的正常代码！我们能否在这里改进代码以减少代码量？我们能否在 `infoAboutShoe()` 函数中利用变体类型 `onlyWomanShoe`，以避免
    `switch` 块中的 `Slingbacks` 和 `HighHeels` 的两行代码，并尝试使其真正强大？
- en: 'There is a trick to do that, using a syntax sugar within the `switch` block
    of the function: `#onlyWomanShoe`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个技巧可以在函数的 `switch` 块中使用语法糖来实现这一点：`#onlyWomanShoe`。
- en: 'We will explain in detail later where this comes from, but basically we could
    write this almost-equivalent code (`src/Ch09/Ch09_Example2bis.re`), where we only
    change the body of the `infoAboutShoe` function, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后详细解释这一点，但基本上我们可以编写几乎等效的代码（`src/Ch09/Ch09_Example2bis.re`），我们只更改 `infoAboutShoe`
    函数的主体，如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Executing the JS code produced by the compilation gives output such as the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行编译生成的 JS 代码会输出如下内容：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More about extending polymorphic variant types
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于扩展多态变体类型的内容
- en: 'Suppose we have a type definition for websites and we want to extend it to
    all web apps (including personal productivity tools, social networks, and even
    APIs). We could first define the main things that characterize a website, such
    as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网站类型定义，我们想将其扩展到所有网络应用（包括个人生产力工具、社交网络，甚至 API）。我们首先定义了描述网站的主要特征，如下所示：
- en: The domain
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名
- en: Whether there is an access by login or not (for the main content), that is,
    private or public access
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否通过登录进行访问（对于主要内容），即私有或公共访问
- en: 'To get started, we can first define two utility types, `domain` and `accessType`,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们首先定义两个实用类型，`domain`和`accessType`，如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we add a helper function to stringify the `accessType` values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个辅助函数来将`accessType`值转换为字符串：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s define the variants type for websites:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义网站的变体类型：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then add a function that would return a short summary text containing the
    information for each website:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个函数，该函数将返回包含每个网站信息的简短摘要文本：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As usual, for testing purposes, we add a few bindings and show the results
    in the console using `Js.log()`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，为了测试目的，我们添加了一些绑定，并使用`Js.log()`在控制台显示结果：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see that part working. But, we are not done yet. We also want to extend
    that code to apply to any webapp. So, we define a new type, for *web apps* (`webapp`,
    as you would guess) with the intent of being an extension of the *websites* one.
    The type definition is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这部分正在工作。但是，我们还没有完成。我们还想将这段代码扩展到任何 webapp。因此，我们定义了一个新的类型，用于*web apps*（`webapp`，正如你所猜到的），目的是作为*websites*类型的扩展。类型定义如下：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After that, we add a new function (`appSummary()`) that will extend the previous
    one (`siteSummary()`). One technique we use here is the `as` keyword, allowing
    us (in the `switch` part of the function) to match a result to a constructor of
    the `website` variant type. For example, we can write `` `CorporateSite(`Domain(s))
    as ws ``.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加了一个新的函数（`appSummary()`），它将扩展之前的函数（`siteSummary()`）。我们在这里使用的一个技术是`as`关键字，它允许我们在函数的`switch`部分将结果与`website`变体类型的构造函数相匹配。例如，我们可以写``
    `CorporateSite(`Domain(s)) as ws ```。
- en: 'We can define the function as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义函数如下：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that we can actually improve this a little bit; to avoid the compiler
    from complaining about the `s` and `a` variables not being used in the first three
    lines of the `switch` block, we can replace those variables by the `_`. The improved
    function is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上可以稍微改进一下；为了避免编译器对`switch`块的前三条线中的`s`和`a`变量未使用而抱怨，我们可以用`_`替换这些变量。改进后的函数如下：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can finish by adding some testing code, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一些测试代码来完成，如下所示：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But wait, there is more improvement possible!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，还有更多的改进空间！
- en: Another technique is to reuse the first type via the `#website as ws` syntax
    and that allows us to completely replace the lines related to the `website` variant
    type constructors in the pattern matching.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是通过`#website as ws`语法重用第一个类型，这允许我们完全替换与`website`变体类型构造函数相关的模式匹配的行。
- en: 'The final version of the function would then be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最终版本如下：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And, after this update, to make things interesting, here is the final testing
    and value display code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个更新之后，为了使事情更有趣，以下是最终的测试和值显示代码：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see that executing the JavaScript code produced by the compilation gives
    the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，执行编译生成的 JavaScript 代码会产生以下输出：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We just saw a nice type extension technique supported by Reason with polymorphic
    type variants.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了 Reason 支持的一种很好的类型扩展技术，即多态类型变体。
- en: Code reuse with OOP-style inheritance
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象风格的继承进行代码复用
- en: Inheritance, as we have in object oriented programing languages, is not commonly
    used in Reason. However, we can find a couple of examples of techniques that resemble
    OOP-style inheritance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 继承，就像我们在面向对象编程语言中看到的那样，在 Reason 中并不常用。然而，我们可以找到一些类似于 OOP 风格继承的技术示例。
- en: Opening a module
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开一个模块
- en: Constantly referring to something in a module imposes a lot of writing on the
    developer. This is where `open` is handy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中不断引用某个东西会给开发者带来很多编写工作。这就是`open`派上用场的地方。
- en: 'Without this feature, let''s say you have the `ColorExample` module (based
    on code we already used in the first example of this chapter), defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个功能，假设你有一个`ColorExample`模块（基于我们在本章第一个示例中已经使用过的代码），定义如下：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can use the function by using the `ColorExample.stringOfColor` reference
    and similarly for the values. So, some value display code would look like the
    following (as actually seen in the `src/Ch09/Ch09_Open_module.re` file):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`ColorExample.stringOfColor`引用来使用该函数，对于值也是类似。所以，一些值显示代码可能如下所示（如实际在`src/Ch09/Ch09_Open_module.re`文件中看到的那样）：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But, with the `open` solution for opening the module within a scope, we can
    write more compact code, as follows (in the same `src/Ch09/Ch09_Open_module.re`
    file):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用在作用域内打开模块的 `open` 解决方案，我们可以编写更紧凑的代码，如下（在同一个 `src/Ch09/Ch09_Open_module.re`
    文件中）：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And things work as expected! The code file when executed gives the following
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事情按预期进行！执行代码文件时给出以下输出：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What happens is that all of the contents of the module are magically accessible
    without the need to add the prefix that would normally be added (the `ColorExample.`
    part, in this case) when accessing the types, functions, and variables it contains.
    It brings the module's content into the current scope.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，模块的所有内容都可以神奇地访问，无需添加通常在访问包含的类型、函数和变量时需要添加的前缀（在这种情况下是 `ColorExample.`
    部分）。它将模块的内容引入当前作用域。
- en: 'We could have done things in an alternative way: have the module in its own
    file for better separation of code. There are cases where you would want to do
    that if it better fits your way of organizing the code. So basically, let''s move
    the module''s code in the `src/Ch09/Ch09_OpenModulebisPart1.re` file, for example,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以另一种方式做事：将模块放在自己的文件中以更好地分离代码。在某些情况下，如果你认为这样做更适合你的代码组织方式，你可能想这样做。所以基本上，让我们将模块的代码移动到
    `src/Ch09/Ch09_OpenModulebisPart1.re` 文件中，例如，如下所示：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in another code file (`src/Ch09/Ch09_OpenModulebisPart2.re`, for example),
    we can open the module and access its functions and values, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个代码文件（例如 `src/Ch09/Ch09_OpenModulebisPart2.re`），我们可以打开模块并访问其函数和值，如下所示：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's it! We have seen how to leverage `open` for opening modules in Reason.
    And, in code that you can find written by other developers, you can find it used
    a lot.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经看到了如何在 Reason 中利用 `open` 打开模块。并且，在你可以找到的其他开发者的代码中，你可以发现它被大量使用。
- en: Including a module
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含一个模块
- en: 'Reason also provides a way to reuse a module already defined, and extend it
    like in OOP: the `include` keyword.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 还提供了一种重用已定义的模块并像在面向对象中一样扩展它的方法：`include` 关键字。
- en: 'Regarding this feature, the documentation actually says the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个特性，文档实际上是这样说的：
- en: Using `include` in a module, statically transfers a module's content into a
    new one. Thus often fulfills the role of inheritance or mixing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中使用 `include`，可以将模块的内容静态地转移到新的模块中。因此，通常可以满足继承或混合的角色。
- en: 'Let''s say we have a base module as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个基础模块如下：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we reuse it in the following module, using the `include` technique, as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在以下模块中使用它，使用 `include` 技术，如下所示：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And, we can display information using a function from each module, in order
    to compare the behavior:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用每个模块中的函数来显示信息，以便比较行为：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Executing the JS code produced by compiling our code (in the `src/Ch09/Ch09_Include_module.re`
    file) gives the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 执行编译我们的代码（在 `src/Ch09/Ch09_Include_module.re` 文件中）产生的 JS 代码给出以下输出：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Interesting. You could already have the intuition of what happens here, but
    the ReasonML documentation about `include` stipulates that this technique copies
    over the definition of a module *statically*, then also performs `open`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣。你可能已经对这里发生的事情有了直觉，但 ReasonML 关于 `include` 的文档规定，这种技术会静态地复制模块的定义，然后也执行 `open`。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now seen how you can leverage two types of techniques, subtyping using
    polymorphic variants and OOP-style inheritance with modules, to improve your code
    structure and make it easy to add behavior to types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何利用两种技术，使用多态变体进行子类型化和使用模块的面向对象继承风格，来改进代码结构并使其易于向类型添加行为。
- en: With polymorphic variant types, we can reuse constructors for different types
    because of their design. Furthermore, it is possible to extend a polymorphic variant
    type to create a new one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态变体类型，我们可以因为它们的设计而重用不同类型的构造函数。此外，还可以扩展多态变体类型以创建新的类型。
- en: With modules, we can open an existing module to use functions and bindings defined
    in it, and we can include it in a new module to extend its behavior line in OOP-style
    inheritance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块，我们可以打开一个现有的模块来使用其中定义的函数和绑定，并且我们可以将其包含在新的模块中以扩展其行为，类似于面向对象的继承风格。
- en: In the next and last chapter, we are going to go through a final example where
    we bring together the main techniques we have learned so far.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将通过一个最终示例来回顾我们迄今为止学到的所有主要技术。
