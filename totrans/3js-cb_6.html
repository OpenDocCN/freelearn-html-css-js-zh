<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Point Clouds and Postprocessing</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a point cloud based on a geometry</li><li class="listitem" style="list-style-type: disc">Creating a point cloud from scratch</li><li class="listitem" style="list-style-type: disc">Coloring individual points in a point cloud</li><li class="listitem" style="list-style-type: disc">Styling individual points</li><li class="listitem" style="list-style-type: disc">Moving individual points of a point cloud</li><li class="listitem" style="list-style-type: disc">Exploding a point cloud</li><li class="listitem" style="list-style-type: disc">Setting up the basic postprocessing pipeline</li><li class="listitem" style="list-style-type: disc">Creating custom postprocessing steps</li><li class="listitem" style="list-style-type: disc">Saving WebGL output to disk</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Introduction</h1></div></div></div><p>Three.js has support for many different types of geometries and objects. In this chapter, we'll show<a id="id466" class="indexterm"/> you a number of recipes that use the <code class="literal">THREE.PointCloud</code> object. With this object, you can create a point cloud where the individual vertices are rendered instead of the complete mesh. You have all kinds of different styling options available for the points, and you can even move the individual points around to create very interesting-looking (and realistic) animations and simulations.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Creating a point cloud based on a geometry</h1></div></div></div><p>An <a id="id467" class="indexterm"/>interesting feature of Three.js is that it also allows you to create point clouds. A point cloud isn't rendered as a solid geometry, but all the individual vertices are rendered as single points. In this recipe, we'll show you how to create such a point cloud based on an already existing geometry.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec261"/>Getting ready</h2></div></div></div><p>There are no additional steps required to start with this recipe. For the example we use in this recipe, however, we use an external model as the basis for our point cloud. We also use a camera control object, <code class="literal">THREE.OrbitControls</code>, to make navigation around the example easier. If you want to use the camera control object yourself, you need to add the following JavaScript libraries to the scene (besides the standard Three.js one):</p><div><pre class="programlisting">  &lt;script src="img/OrbitControls.js"&gt;&lt;/script&gt;
  &lt;script src="img/OBJLoader.js"&gt;&lt;/script&gt;</pre></div><p>The external model we use is also provided with the sources in this book and can be found in the <code class="literal">assets/models/cow</code> folder. To see what the result of this recipe can look like, we provided an example that shows you a point cloud that was created based on an existing geometry (<code class="literal">06.01-create-point-cloud-from-geometry.html</code>).You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_01.jpg" alt="Getting ready"/></div><p>As you can see in this screenshot, we've loaded a cow geometry and created a point cloud based on it. You can, of course, use any geometry you want, but especially complex models look really great when rendered as a point cloud.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec262"/>How to do it...</h2></div></div></div><p>Creating a point cloud isn't that different from creating a simple <code class="literal">THREE.Mesh</code> object. The following section explains the steps you should take:</p><div><ol class="orderedlist arabic"><li class="listitem">The <a id="id468" class="indexterm"/>first thing you need in this approach is <code class="literal">THREE.Geometry</code>. You can use either one of the standard geometries or load an external one. For this recipe, we'll load an external one (the cow we mentioned in the <em>Getting ready</em> section of this recipe):<div><pre class="programlisting">  var loader = new THREE.OBJLoader();
  loader.load(
    "../assets/models/cow/cow.obj",
    function(cow) {
      // get the main cow geometry from the 
      // loaded object hierarchy
      var cowGeometry = cow.children[1].geometry;
    }
  );</pre></div><p>In this code snippet, we load the external model, so we have geometry on which we can base the point cloud.</p></li><li class="listitem">Before we create the point cloud, we first have to tell Three.js what we want the point cloud to look like. For this, we create <code class="literal">THREE.PointCloudMaterial</code>:<div><pre class="programlisting">  var pcMat = new THREE.PointCloudMaterial();
  pcMat.map = THREE.ImageUtils.loadTexture("../assets/textures/ps_smoke.png");
  pcMat.color = new THREE.Color(0x5555ff);
  pcMat.transparent = true;
  pcMat.size = 0.2;
  pcMat.blending = THREE.AdditiveBlending;</pre></div><p>This material defines what each point will look like. Most of the properties are pretty self-explanatory. The interesting one here is the <code class="literal">blending</code> property. By<a id="id469" class="indexterm"/> setting the <code class="literal">blending</code> property to <code class="literal">THREE.AdditiveBlending</code>, you get the nice glow effect you can see in the screenshot at the beginning of this recipe.</p></li><li class="listitem">At this point, we have <code class="literal">THREE.Geometry</code> and <code class="literal">THREE.PointCloudMaterial</code>; with these two objects, we can create the point cloud:<div><pre class="programlisting">  pc = new THREE.PointCloud(geometry, pcMat);
  pc.sizeAttenuation = true;
  pc.sortPoints = true;</pre></div><p>As you can see, we pass in <code class="literal">THREE.Geometry</code> and <code class="literal">THREE.PointCloudMaterial</code> to create <code class="literal">THREE.PointCloud</code>. On the created point cloud, we set two additional properties to <code class="literal">true</code>. The <code class="literal">sizeAttenuation</code> property makes sure that the size of a point also depends on the distance from the camera. So, points farther away look smaller. The <code class="literal">sortPoints</code> property makes sure that when you use transparent points, as we do in this recipe, they are rendered correctly.</p></li><li class="listitem">The last step to perform is to add the created <code class="literal">THREE.PointCloud</code> object to the scene:<div><pre class="programlisting">  scene.add(pc);</pre></div></li></ol></div><p>Now, Three.js <a id="id470" class="indexterm"/>will render the point cloud just like it does any other 3D object.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec263"/>How it works...</h2></div></div></div><p>When you create <code class="literal">THREE.PointCloud</code>, Three.js creates a point for each vertex of the provided <code class="literal">THREE.Geometry</code> object. No other information in <code class="literal">THREE.Geometry</code> is used. Internally, for <code class="literal">THREE.WebGLRenderer</code>, it directly uses <code class="literal">GL_POINTS</code>, which is a WebGL primitive, to<a id="id471" class="indexterm"/> render the individual points (refer to <a class="ulink" href="https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml">https://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml</a> for more information). Then, using a custom fragment shader, it styles these points. The result is that when you use <code class="literal">THREE.WebGLRenderer</code>, you can easily render millions of points while maintaining great performance.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec264"/>There's more...</h2></div></div></div><p>Points are a great way to represent all kinds of different effects. For some interesting applications of points, you can look at the following examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One <a id="id472" class="indexterm"/>million points rendered on WebGL: <a class="ulink" href="http://soulwire.github.io/WebGL-GPU-Particles/">http://soulwire.github.io/WebGL-GPU-Particles/</a></li><li class="listitem" style="list-style-type: disc">Morphing from one geometry to another using a point cloud: <a class="ulink" href="http://oos.moxiecode.com/js_webgl/particles_morph/index.html">http://oos.moxiecode.com/js_webgl/particles_morph/index.html</a></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec265"/>See also</h2></div></div></div><p>In this chapter, we have a number of recipes that deal with points that are closely related to this one:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <em>Creating a point cloud from scratch</em> recipe, we create a point cloud from a custom-created geometry</li><li class="listitem" style="list-style-type: disc">In the <em>Styling individual points</em> recipe, we show you how you can style the individual points of a point cloud</li><li class="listitem" style="list-style-type: disc">In the <em>Moving individual points of a point cloud</em> and <em>Exploding a point cloud</em> recipes, we<a id="id473" class="indexterm"/> show you how you can move the points around</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Creating a point cloud from scratch</h1></div></div></div><p>When you <a id="id474" class="indexterm"/>want to create a point cloud, you can pass in an existing geometry and base the point cloud on it. In this recipe, we'll show you how you can create <code class="literal">THREE.Geometry</code> from scratch and create a point cloud from it.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec266"/>Getting ready</h2></div></div></div><p>For this recipe, we don't require any additional JavaScript libraries and we don't need to load external models, as we create our geometry from scratch. You can look at the geometry we created by opening <code class="literal">06.02-create-point-system-from-scratch.html</code> in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_02.jpg" alt="Getting ready"/></div><p>In the<a id="id475" class="indexterm"/> next section, we'll explain how to create this custom geometry and use it together with <code class="literal">THREE.PointCloud</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec267"/>How to do it...</h2></div></div></div><p>The steps are pretty much the same as shown in the <em>Creating a point cloud based on a geometry</em> recipe, except that first, we need to create our own custom geometry:</p><div><ol class="orderedlist arabic"><li class="listitem">Creating a custom geometry is fairly easy:<div><pre class="programlisting">  var x = 100;
  var y = 100;
  var geometry = new THREE.Geometry();
  for (var i = 0 ; i &lt; x ; i++) {
    for (var j = 0 ; j &lt; y ; j++) {
      var v = new THREE.Vector3();
      v.x = i / 10;
      v.y = Math.sin(i/100 * Math.PI*2) + Math.cos(j/100 * Math.PI) * 2;
      v.z = j / 10;
      geometry.vertices.push(v);
    }
  }</pre></div><p>As you can see from this code snippet, you first need to instantiate <code class="literal">THREE.Geometry</code> and then create <code class="literal">THREE.Vector3</code> instances and push them to the vertices property of geometry.</p></li><li class="listitem">Now that we've got a geometry, we just need <code class="literal">THREE.PointCloudMaterial</code>:<div><pre class="programlisting">  var pcMat = new THREE.PointCloudMaterial(geometry);
  pcMat.map = THREE.ImageUtils.loadTexture ("../assets/textures/ps_smoke.png");
  pcMat.color = new THREE.Color(0x55ff55);
  pcMat.transparent = true;
  pcMat.size = 0.2;
  pcMat.blending = THREE.AdditiveBlending;</pre></div></li><li class="listitem">Use this material together with the geometry to create <code class="literal">THREE.PointCloud</code> and add it to the scene:<div><pre class="programlisting">  pc = new THREE.PointCloud(geometry, pcMat);
  pc.sizeAttenuation = true;
  pc.sortPoints = true;
  scene.add(pc);</pre></div></li></ol></div><p>If you've already looked at the <em>Creating a point cloud based on a geometry</em> recipe, you'll notice that most of the steps are the same. The only difference between these two recipes is how you create the geometry.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec268"/>How it works...</h2></div></div></div><p>For an <a id="id476" class="indexterm"/>explanation on how this works, look at the <em>How it works…</em> section from the <em>Creating a point cloud based on a geometry</em> recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec269"/>There's more…</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <em>Geometries and Meshes</em>, we showed how you could render 3D formulas with Three.js. With the setup from this recipe, you can also create 3D formulas that are visualized as point clouds. For instance, the following screenshot shows you a 3D formula from <a class="link" href="ch02.html" title="Chapter 2. Geometries and Meshes">Chapter 2</a>, <em>Geometries and Meshes</em>, rendered as a point cloud:</p><div><img src="img/1182OS_06_03.jpg" alt="There's more…"/></div><p>As you can see, you can very easily create great-looking point clouds this way.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec270"/>See also</h2></div></div></div><p>There<a id="id477" class="indexterm"/> are a couple of recipes in this chapter that are related to this recipe:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <em>Creating a point cloud based on a geometry</em> recipe, we use an existing geometry to create a point cloud</li><li class="listitem" style="list-style-type: disc">In the <em>Styling individual points</em> recipe, we show you how you can style the individual points of a point cloud</li><li class="listitem" style="list-style-type: disc">In the <em>Moving individual points of a point cloud</em> and <em>Exploding a point cloud</em> recipes, we show you how you can move the points around</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Coloring the individual points in a point cloud</h1></div></div></div><p>When <a id="id478" class="indexterm"/>you create a point cloud, every point has <a id="id479" class="indexterm"/>the same color and style, as every point uses the same <code class="literal">THREE.PointCloudMaterial</code> object. There is, however, a way to add color to the individual points.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec271"/>Getting ready</h2></div></div></div><p>There is no need for any additional steps to run this recipe. We'll create a custom geometry, just like we did in the <em>Creating a point cloud from scratch</em> recipe, and this time, we color each individual point. The result of this recipe can be seen by opening <code class="literal">06.03-color-individual-points-in-point-system.html</code> in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_04.jpg" alt="Getting ready"/></div><p>As you can see, we've colored the individual points in various shades of red.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec272"/>How to do it...</h2></div></div></div><p>To accomplish individual colored points, we need to set one additional property when we create <code class="literal">THREE.Geometry</code>. The following steps show you how to do this:</p><div><ol class="orderedlist arabic"><li class="listitem">We start by creating the geometry. When we create the individual vertices, we can also inform Three.js about the color that we want to use for it:<div><pre class="programlisting">  var x = 100;
  var y = 100;
  var geometry = new THREE.Geometry();
  for (var i = 0 ; i &lt; x ; i++) {
    for (var j = 0 ; j &lt; y ; j++) {
      var v = new THREE.Vector3(i,0,j);
<strong>      var rnd = Math.random()/2 + 0.5;</strong>
<strong>      geometry.colors.push(</strong>
<strong>        new THREE.Color(rnd, rnd/4, 0));</strong>
      geometry.vertices.push(v);
    }
  }</pre></div><p>In this code snippet, we create a random color and push it to the <code class="literal">geometry.colors</code> array. At the end of these two loops, we will have 10000 vertices in the <code class="literal">vertices</code> array and 10000 colors in the <code class="literal">colors</code> array.</p></li><li class="listitem">Now, we<a id="id480" class="indexterm"/> can create <code class="literal">THREE.PointCloudMaterial</code> and use it together with the geometry to create <code class="literal">THREE.PointCloud</code>:<div><pre class="programlisting">  var pcMat = new THREE.PointCloudMaterial(geometry);
  pcMat.vertexColors = true;
  pcMat.map = THREE.ImageUtils.loadTexture("../assets/textures/ps_smoke.png");
  pcMat.transparent = true;
  pc = new THREE.PointCloud(geometry, pcMat);
  scene.add(pc);</pre></div><p>To <a id="id481" class="indexterm"/>use the colors we created in step 1, we need to set the <code class="literal">vertexColors</code> property of <code class="literal">THREE.PointCloudMaterial</code> to <code class="literal">true</code>. In this code snippet, we also load a texture and assign it to the <code class="literal">map</code> property. We use individual colors, so there is no need to set the <code class="literal">color</code> property on the material we need to set color on <code class="literal">THREE.Geometry</code>, which we show in the next step.</p></li><li class="listitem">If you've already looked at the example shown in the <em>Getting ready</em> section of this recipe, you'll notice that the colors of the points change. We can easily do this by just changing the color in the <code class="literal">colors</code> array of the geometry in the render loop:<div><pre class="programlisting">  for (var i = 0 ; i &lt; pc.geometry.colors.length ; i++) {
    var rnd = Math.random()/2 + 0.5;
    pc.geometry.colors[i] = new THREE.Color(rnd, rnd/4, 0);
  }
  pc.geometry.colorsNeedUpdate = true;</pre></div><p>When you change the colors, you need to set the <code class="literal">colorsNeedUpdate</code> property to <code class="literal">true</code> so that Three.js knows that the colors of the points need to be updated.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec273"/>How it works...</h2></div></div></div><p>Three.js uses WebGL to render individual points. For this, Three.js uses vertex shaders and fragment shaders (see the previous chapter for more recipes on this). To color the individual <a id="id482" class="indexterm"/>points, Three.js passes the information<a id="id483" class="indexterm"/> into the fragment shader used to determine the output color. The corresponding piece of shader code looks like this:</p><div><pre class="programlisting">  gl_FragColor = vec4( psColor, opacity );</pre></div><p>The <code class="literal">psColor</code> variable is the one that is passed from the colors array of <code class="literal">THREE.Geometry</code> to the shader used to color the points.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec274"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Coloring an individual point in Three.js is very simple and straightforward. However, if you want to change more properties of the points, such as the opacity or the size, you can't do that with standard Three.js. In the <em>Styling individual points</em> recipe, we'll show you how you can create a custom shader to also change these properties of the points within a point cloud.</li><li class="listitem" style="list-style-type: disc">If you're interested in adding animation to the points in the point cloud, you can look at the <em>Moving individual points of a point cloud</em> and <em>Exploding a point cloud</em> recipes.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Styling individual points</h1></div></div></div><p>With the<a id="id484" class="indexterm"/> standard Three.js functionality, you can't style the individual points of a point cloud. You can change their color, as we've shown in the <em>Coloring the individual points in a point cloud</em> recipe, but it isn't possible to change a point's size or opacity. In this recipe, we'll show you how to create a custom vertex and fragment shader, which allow you to change the color, opacity, and size of the individual points of a point cloud and that you can also easily extend to add more properties.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec275"/>Getting ready</h2></div></div></div><p>There are no external libraries used in this recipe. We'll just extend the basic Three.js functionality by creating our own custom shaders. To see the shaders in action, open the <code class="literal">06.04-style-individual-points-in-point-system-with-custom-shader.html</code> example in your browser. You will see something similar to the following recipe:</p><div><img src="img/1182OS_06_05.jpg" alt="Getting ready"/></div><p>As you<a id="id485" class="indexterm"/> can see in this screenshot, the size, color, and opacity of the individual points differ.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec276"/>How to do it…</h2></div></div></div><p>Let's look at the steps that you need to take to accomplish this:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's start simple and first create the geometry from which we'll create the point cloud:<div><pre class="programlisting">  var geometry = new THREE.Geometry();
<strong>  var pSize = [];</strong>
<strong>  var pOpacity = [];</strong>
<strong>  var width= 100;</strong>
<strong>  var height = 100;</strong>
  // create the geometry and set custom values
  for (var i = 0 ; i &lt; width ; i++) {
    for (var j = 0 ; height &lt; y ; j++) {
      var v = new THREE.Vector3();
      v.x = i / 10;
      v.y = (Math.sin(i/200 * Math.PI*2) + Math.cos(j/50 * Math.PI) + Math.sin((j+i)/40 * Math.PI))/2;
      v.z = j / 10;
      // add the vertex
      geometry.vertices.push(v);
      // add vertex specific color, size and opacity
<strong>      geometry.colors.push(new THREE.Color(v.y,0.5,0.7));</strong>
<strong>      pSize.push(Math.random());</strong>
<strong>      pOpacity.push(Math.random()/4+0.5);</strong>
    }
  }</pre></div><p>As you can see, we create <code class="literal">THREE.Geometry</code> from scratch and generate 10,000 vertices. As we want to change the color, size, and opacity of the individual vertices, we also generate values for these properties for each of the 10,000 vertices. The colors are stored in the <code class="literal">geometry.colors</code> array as this is the standard Three.js functionality. We store the size in the <code class="literal">pSize</code> array and the opacity in the <code class="literal">pOpacity</code> array.</p></li><li class="listitem">Now <a id="id486" class="indexterm"/>that we've got a geometry and a couple of arrays containing the expected size and opacity for the individual vertices, let's define the material for the point cloud:<div><pre class="programlisting">  var attributes = ...; // filled in in next steps
  var uniforms = ...;   // filled in in next steps
  var psMat2 = new THREE.ShaderMaterial({
    attributes: attributes,
    uniforms: uniforms,
    transparent : true,
    blending : THREE.AdditiveBlending,
    vertexShader: document getElementById('pointVertexShader').text,
    fragmentShader: document getElementById('pointFragmentShader').text
  });</pre></div><p>Instead of using the standard <code class="literal">THREE.PointCloudMaterial</code> object, we use <code class="literal">THREE.ShaderMaterial</code>. The <code class="literal">transparent</code> and <code class="literal">blending</code> are properties standard material properties and behave as you'd expect. We'll explain the other properties in the upcoming steps.</p></li><li class="listitem">In step 2, the material referenced the attributes variable. In this step, we'll configure this variable:<div><pre class="programlisting">  var attributes = {
    pSize:    { type: 'f', value: pSize },
    pOpacity: { type: 'f', value: pOpacity }
  };</pre></div><p>Our <code class="literal">attributes</code> object contains two properties. The first one points to the array that contains the sizes of the vertices and the second one points to the array that contains the opacity values. The <code class="literal">f</code> value for type means that it is an array of floats. As we reference this attribute from our shader material, we can access the individual values in our shaders.</p></li><li class="listitem">In<a id="id487" class="indexterm"/> step 2, we also defined some uniforms. The <code class="literal">uniforms</code> object are also passed into the shader but are the same for all vertices:<div><pre class="programlisting">  var basicShader = THREE.ShaderLib['point_basic'];
  var uniforms = THREE.UniformsUtils.merge([basicShader.uniforms]);
  uniforms['map'].value = THREE.ImageUtils.loadTexture("../assets/textures/ps_smoke.png");
  uniforms['size'].value = 100;
  uniforms['opacity'].value = 0.5;
  uniforms['psColor'].value = new THREE.Color(0xffffff);</pre></div><p>Here, we reuse the standard uniforms Three.js uses in its shaders and use it to further configure the shaders.</p></li><li class="listitem">Looking back at step 2, the only two properties we need to define are the actual shaders: <code class="literal">document.getElementById('pointVertexShader').text</code> and <code class="literal">document.getElementById('pointFragmentShader').text</code>. Let's start with the vertex shader:<div><pre class="programlisting">  &lt;script id="pointVertexShader" type="x-shader/x-vertex"&gt;
    precision highp float;
    precision highp int;
    attribute vec3 color;
    attribute float pSize;
    attribute float pOpacity;
    uniform float size;
    uniform float scale;
    varying vec3 vColor;
    varying float vOpacity;
    void main() {
      vColor = color;
      vOpacity = pOpacity;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      gl_PointSize = 2.0 * pSize * size * ( scale / length( mvPosition.xyz ) );
      gl_Position = projectionMatrix * mvPosition;
    }
  &lt;/script&gt;</pre></div><p>A vertex shader is used to determine the position and the size of a vertex. In this shader, we set the size of the vertex and the point and use the <code class="literal">pSize</code> attribute in the calculation. This way, we can control the size of the individual pixel. We also copy the value of <code class="literal">color</code> and <code class="literal">pOpacity</code> to a <code class="literal">varying</code> value so that we can access it from our fragment shader in the next step.</p></li><li class="listitem">So far, the <a id="id488" class="indexterm"/>size of the point could be configured directly from Three.js. Now, let's look at the fragment shader and do the same for the color and opacity:<div><pre class="programlisting">  &lt;script id="pointFragmentShader" type="x-shader/x-fragment"&gt;
    precision highp float;
    precision highp int;
    uniform vec3 psColor;
    uniform float opacity;
    varying vec3 vColor;
    varying float vOpacity;
    uniform sampler2D map;
    void main() {
      gl_FragColor = vec4( psColor, vOpacity );
      gl_FragColor = gl_FragColor * texture2D( map,vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );
      gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );
    }
  &lt;/script&gt;</pre></div><p>The fragment shader is only a small program. What we do here is the following:</p><div><ol class="orderedlist arabic"><li class="listitem">We first set the color of the fragment (the point) to the color defined on the material (<code class="literal">psColor</code>), and the opacity is set to the point-specific opacity (<code class="literal">vOpacity</code>).</li><li class="listitem">Next, we apply the provided texture (<code class="literal">map</code>).</li><li class="listitem">Finally, we multiply the color value(<code class="literal">gl_Fragcolor</code>) with the point specific color(<code class="literal">vcolor</code>).</li></ol></div></li><li class="listitem">At this point, we've configured the material and created the specific shaders. Now, we can just create the point cloud and add it to the scene:<div><pre class="programlisting">  ps = new THREE.PointCloud(geometry, psMat2);
  ps.sortPoints = true;
  scene.add(ps);</pre></div><p>With this last step, you're done.</p></li></ol></div><p>As<a id="id489" class="indexterm"/> you can see, as this isn't a standard Three.js functionality, we need to take some additional steps to accomplish our goals.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec277"/>How it works...</h2></div></div></div><p>In the previous section, we've already explained a bit how the styling of individual points works. The main thing to remember here is that under the hood, Three.js creates vertex and fragment shaders for rendering. If there is a functionality you want that can't be configured in the standard shaders, you can use <code class="literal">THREE.ShaderMaterial</code> to create your own custom implementations. You can still use Three.js to create your geometries and handle all the WebGL initialization stuff but use your own shader implementations.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec278"/>There's more…</h2></div></div></div><p>With this setup, you've got a basic skeleton to create your own custom shader based on point clouds. You can now easily add more functionalities, other configuration options, and more by just adding to this setup.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec279"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you just want to color an individual point, you can refer to the <em>Coloring the individual points in a point cloud</em> recipe, and if you're interested in adding animation to the points in the point cloud, you can refer to the <em>Moving individual points of a point cloud</em> and <em>Exploding a point cloud</em> recipes.</li><li class="listitem" style="list-style-type: disc">There <a id="id490" class="indexterm"/>are also a couple of other recipes that use vertex and fragment shaders. In this chapter, you can find the <em>Creating custom postprocessing steps</em> recipe, which uses a shader as a postprocessing effect. In <a class="link" href="ch05.html" title="Chapter 5. Lights and Custom Shaders">Chapter 5</a>, <em>Light and Custom Shaders</em>, we have the <em>Creating a custom vertex shader</em> recipe, which uses a custom vertex shader to alter the shape of a geometry, and the <em>Creating a custom fragment shader</em> recipe, which colors 3D objects using a custom fragment shader implementation.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Moving individual points of a point cloud</h1></div></div></div><p>When<a id="id491" class="indexterm"/> you create a point cloud from a geometry, the <a id="id492" class="indexterm"/>position of the points is based on the vertices from the provided geometry. The result is a point cloud where the individual points don't move. In this recipe, we show you how you can move the individual points of a point cloud.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec280"/>Getting ready</h2></div></div></div><p>For this recipe, we require a point cloud that contains some points. You can create your own one (as we explained in the <em>Creating a point cloud from scratch</em> and <em>Creating a point cloud from an existing geometry</em> recipes). We will use the point cloud we created in the <em>Styling individual points</em> recipe. As always, we've provided an example where you can see the final result of this recipe. Open <code class="literal">06.05-move-individual-points.html</code> in your browser, and you'll see the following screenshot:</p><div><img src="img/1182OS_06_06.jpg" alt="Getting ready"/></div><p>If you open this in your browser, you'll see all the points being moved around the screen. In the following section, we'll explain how you can do that.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec281"/>How to do it...</h2></div></div></div><p>To<a id="id493" class="indexterm"/> create moving points, we need to perform<a id="id494" class="indexterm"/> the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure you've got a point cloud with a geometry. Look at the <em>Creating a point cloud from scratch</em> and <em>Creating a point cloud based on a geometry</em> recipes to learn how to create such a point cloud. In this recipe, we assume the point cloud can be referenced through the <code class="literal">ps</code> variable.</li><li class="listitem">The next step is to update the position of the individual points of the point cloud. We do that by updating the <code class="literal">render</code> loop:<div><pre class="programlisting">  var step = 0;
  function render() {
    renderer.render(scene, camera);
    requestAnimationFrame(render);
    step=0.005;
    var count = 0;
    var geometry = ps.geometry;
    geometry.vertices.forEach(function(v){
      // calculate new value for the y value
      v.y =  ( Math.sin((v.x/20+step) * Math.PI*2) + Math.cos((v.z/5+step*2) * Math.PI) + Math.sin((v.x + v.y + step*2)/4 * Math.PI))/2;
      // and calculate new colors
      geometry.colors[count++]= new THREE.Color(v.y,0.5,0.7);
    });
    geometry.verticesNeedUpdate = true;
    geometry.colorsNeedUpdate = true;
  }</pre></div><p>In the <code class="literal">render</code> loop, we access geometry through the <code class="literal">ps</code> variable. Next, we change the <code class="literal">y</code> position (<code class="literal">v.y</code>) of each point based on the value of the step variable. By increasing the step value in each render loop, we create the animation you can see when you look at the example for this recipe. Finally, we need to tell Three.js that the positions of the vertices in the geometry have changed by setting <code class="literal">geometry.verticesNeedUpdate</code> to <code class="literal">true</code>.</p></li></ol></div><p>In this recipe, we also change the colors of each point, so to inform Three.js about these changes, we also set <code class="literal">geometry.colorsNeedUpdate</code> to <code class="literal">true</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec282"/>How it works...</h2></div></div></div><p>This recipe <a id="id495" class="indexterm"/>works in a very simple way. A point<a id="id496" class="indexterm"/> cloud is created based on the position of the vertices of <code class="literal">THREE.Geometry</code> by simply changing the position of the vertices around which we can move the points.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec283"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In this recipe, we changed the position of the vertices in a very simple way. We just changed the <em>y</em> value of the vertex. In the <em>Exploding a point cloud</em> recipe, we show you an approach where the position of a vertex is changed based on its normal vector.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Exploding a point cloud</h1></div></div></div><p>You can <a id="id497" class="indexterm"/>create many interesting effects with point clouds. You can, for instance, create water, smoke, and cloud effects. In this recipe, we show you another interesting effect you can create with points. We'll show you how you can explode a point cloud where each point's path is based on its normal vector.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec284"/>Getting ready</h2></div></div></div><p>For this recipe, there aren't any steps that need to be taken before we start looking at the recipe. We've provided an example where you can see the resulting explosion in action. Open the <code class="literal">06.06-explode-geometry.html</code> example in your browser and you'll see a screen that looks like the following screenshot:</p><div><img src="img/1182OS_06_07.jpg" alt="Getting ready"/></div><p>If you<a id="id498" class="indexterm"/> click on the <strong>implode</strong> button, the points will move to the middle of the screen; if you click on <strong>explode</strong>, they'll move outwards. With the <strong>speed</strong> property, you can set the speed at which the points will move.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec285"/>How to do it…</h2></div></div></div><p>To accomplish this effect, you only need to perform a couple of small steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we need to do is create the geometry. For the best effect, we use a geometry with lots of vertices:<div><pre class="programlisting">  cube = new THREE.CubeGeometry(4,6,4,20,20,20);
  cube.vertices.forEach(function(v) {
    v.velocity = Math.random();
  });
  createPointSystemFromGeometry(cube);</pre></div><p>As you can see, we don't just create the geometry; we also add a <code class="literal">velocity</code> parameter to each of the vertices, which we set to a random value. We do this to make sure not all the points explode at the same speed (which would have the same effect as just scaling the geometry).</p></li><li class="listitem">Now, we can create the point cloud:<div><pre class="programlisting">  var psMat = new THREE.PointCloudMaterial();
  psMat.map = THREE.ImageUtils.loadTexture("../assets/textures/ps_ball.png");
  psMat.blending = THREE.AdditiveBlending;
  psMat.transparent = true;
  psMat.opacity = 0.6;
  var ps = new THREE.PointCloud(cube, psMat);
  ps.sortPoints = true;
  scene.add(ps);</pre></div><p>This is just a standard point cloud based on the geometry we created in step 1.</p></li><li class="listitem">In the <a id="id499" class="indexterm"/>introduction to the recipe, we mentioned that we wanted to explode the points based on their normal vector. So, before we start rendering the scene and updating the position of the individual points, we first need to calculate the normal of each vector:<div><pre class="programlisting">  var avgVertexNormals = [];
  var avgVertexCount = [];
  for (var i = 0 ; i &lt; cube.vertices.length ; i++) {
    avgVertexNormals.push(new THREE.Vector3(0,0,0));
    avgVertexCount.push(0);
  }
  // first add all the normals
  cube.faces.forEach(function (f) {
    var vA = f.vertexNormals[0];
    var vB = f.vertexNormals[1];
    var vC = f.vertexNormals[2];
    // update the count
    avgVertexCount[f.a]+=1;
    avgVertexCount[f.b]+=1;
    avgVertexCount[f.c]+=1;
    // add the vector
    avgVertexNormals[f.a].add(vA);
    avgVertexNormals[f.b].add(vB);
    avgVertexNormals[f.c].add(vC);
  });
  // then calculate the average
  for (var i = 0 ; i &lt; avgVertexNormals.length ; i++) {
    avgVertexNormals[i].divideScalar(avgVertexCount[i]);
  }</pre></div><p>We won't explain this code snippet in detail, but what we do here is that we calculate the normal vector of each vertex based on the normal vectors of the faces the particular vector is part of. The final normal vector is stored in the <code class="literal">avgVertexNormals</code> array.</p></li><li class="listitem">Next, we<a id="id500" class="indexterm"/> look at a helper function that we'll call from the <code class="literal">render</code> loop in the next step. This function determines the new position of each vertex based on the velocity function we defined in step 1 and the normal vector we calculated in step 3:<div><pre class="programlisting">  function explode(outwards) {
    var dir = outwards === true ? 1 : -1;
    var count = 0;
    cube.vertices.forEach(function(v){
      v.x+=(avgVertexNormals[count].x * v.velocity * control.scale)*dir;
      v.y+=(avgVertexNormals[count].y * v.velocity * control.scale)*dir;
      v.z+=(avgVertexNormals[count].z * v.velocity * control.scale)*dir;
      count++;
    });
    cube.verticesNeedUpdate = true;
  }</pre></div><p>The <code class="literal">control.scale</code> variable<a id="id501" class="indexterm"/> is set through GUI and determines the speed at which our geometry expands, and the <code class="literal">dir</code> property is based on whether we want to move the points outwards or inwards. The <code class="literal">verticesNeedUpdate</code> property is required to inform Three.js about these changes.</p></li><li class="listitem">Now all that is left to do is call the explode function from the <code class="literal">render</code> loop:<div><pre class="programlisting">  function render() {
    renderer.render(scene, camera);
    explode(true); // or explode(false)
    requestAnimationFrame(render);
  }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec286"/>There's more</h2></div></div></div><p>In this <a id="id502" class="indexterm"/>example, we've used a standard geometry; you can, of course, also use an externally loaded model.</p><div><img src="img/1182OS_06_08.jpg" alt="There's more"/></div><p>This screenshot, for instance, shows you an exploding model of a cow.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec287"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Another recipe that deals with animation and moving individual points around can be found in the <em>Moving individual points of a point cloud</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec84"/>Setting up the basic postprocessing pipeline</h1></div></div></div><p>Besides<a id="id503" class="indexterm"/> rendering a scene in 3D, Three.js also allows you to add postprocessing effects to the final output. With postprocessing, you can take the final rendered 2D image and apply all different kinds of filters to it. You could, for instance, add specific blurring effects, sharpen specific colors, and much more. In this recipe, we'll show you how to set up a postprocessing pipeline in Three.js, which you can use to add effects to the final rendered scene.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec288"/>Getting ready</h2></div></div></div><p>To work with postprocessing in Three.js, you need to include a number of additional JavaScript files from the Three.js distribution. For this recipe, the following JavaScript files should be added to your HTML page:</p><div><pre class="programlisting">  &lt;script src="img/CopyShader.js"&gt;&lt;/script&gt;
  &lt;script src="img/EffectComposer.js"&gt;&lt;/script&gt;
  &lt;script src="img/RenderPass.js"&gt;&lt;/script&gt;
  &lt;script src="img/ShaderPass.js"&gt;&lt;/script&gt;
  &lt;script src="img/MaskPass.js"&gt;&lt;/script&gt;</pre></div><p>To demonstrate how postprocessing works, we'll apply the dot-screen effect to a Three.js scene. For this effect, we require one additional JavaScript file:</p><div><pre class="programlisting">  &lt;script src="img/DotScreenShader.js"&gt;&lt;/script&gt;</pre></div><p>We've also provided an example that shows you the final result of this recipe. You can view this by opening <code class="literal">06.07-setup-basic-post-processing-pipeline.html</code> in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_09.jpg" alt="Getting ready"/></div><p>In this<a id="id504" class="indexterm"/> screenshot, you can see that we've rendered a scene with a large number of cubes and applied an effect to render it as a series of dots.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec289"/>How to do it...</h2></div></div></div><p>Setting up a postprocessing pipeline only takes a couple of small steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To set up a postprocessing pipeline, we need something called a composer. We'll use this composer in the <code class="literal">render</code> loop to create the final output. The first thing we need for that is a new global variable:<div><pre class="programlisting">  var composer;</pre></div></li><li class="listitem">Next, we need to instantiate a composer as a new instance of <code class="literal">THREE.EffectComposer</code>:<div><pre class="programlisting">  composer = new THREE.EffectComposer( renderer );</pre></div><p>We pass in <code class="literal">THREE.WebGLRenderer</code>, which we would normally use to render the scene.</p></li><li class="listitem">Now, we need to define the steps that the composer will execute. These steps are executed sequentially and we can use them to apply multiple effects to the scene. The first step we always need to take is to render the scene. For this, we use <code class="literal">THREE.RenderPass</code>:<div><pre class="programlisting">  var renderPass = new THREE.RenderPass( scene, camera );
  composer.addPass( renderPass  );</pre></div><p>A render pass renders a scene object using the provided camera and renderer we configured in step 2.</p></li><li class="listitem">Now<a id="id505" class="indexterm"/> that we've rendered the scene, we can apply a postprocessing effect. For this recipe, we use <code class="literal">THREE.DotScreenShader</code>:<div><pre class="programlisting">  var effect = new THREE.ShaderPass( THREE.DotScreenShader);
  effect.uniforms[ 'scale' ].value = 4;
  effect.renderToScreen = true;
  composer.addPass( effect );</pre></div><p>In this code snippet, we create a postprocessing step (<code class="literal">THREE.ShaderPass</code>), add it to the composer (<code class="literal">composer.addPass(effect)</code>), and tell the effect composer to render the output of this step to screen by setting <code class="literal">renderToScreen</code> to <code class="literal">true</code>.</p></li><li class="listitem">The final step we need to take is to alter the render loop:<div><pre class="programlisting">  function render() {
    composer.render();
    requestAnimationFrame(render);
  }</pre></div><p>As you can see, we now use the <code class="literal">composer</code> object we created in step 2 to render the final output instead of <code class="literal">THREE.WebGLRenderer</code>.</p></li></ol></div><p>In this recipe, we've only used a single postprocessing step, but you can use as many steps as you want. You just have to remember that in the final step, you set the <code class="literal">renderToScreen</code> property to <code class="literal">true</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec290"/>How it works...</h2></div></div></div><p>In a couple of recipes, we've already explained that Three.js uses WebGL shaders to render the 3D scenes. <code class="literal">THREE.EffectComposer</code> uses the same approach. Each of the steps you add run a simple vertex and fragment shader on the output from the previous step. In the <em>Creating custom postprocessing steps</em> recipe, we'll dive into more detail and create a custom postprocessing step ourselves.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec291"/>There's more</h2></div></div></div><p>Three.js provides a large number of standard shaders and steps you can use in <code class="literal">THREE.EffectComposer</code>. For a complete overview of the possible shaders and standard steps, look<a id="id506" class="indexterm"/> at the following directories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing">https://github.com/mrdoob/three.js/tree/master/examples/js/postprocessing</a>: This directory contains all the standard postprocessing steps you can use with <code class="literal">THREE.EffectComposer</code>.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/shaders">https://github.com/mrdoob/three.js/tree/master/examples/js/shaders</a>: Three.js provides the <code class="literal">THREE.ShaderPass</code> postprocessing step, which <a id="id507" class="indexterm"/>allows you to directly use WebGL shaders. On this page, you can find a large number of shaders that can be used with the <code class="literal">THREE.ShaderPass</code> object.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec292"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Even though Three.js provides a large number of standard shaders and postprocessing steps, you can also easily create your own. In the <em>Creating custom postprocessing steps</em> recipe, we show you how to create a custom vertex and fragment shader that works with <code class="literal">THREE</code>.<code class="literal">EffectComposer</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec85"/>Creating custom postprocessing steps</h1></div></div></div><p>In the <em>Setting up the basic postprocessing pipeline</em> recipe, we showed you how you can use <code class="literal">THREE.EffectComposer</code> to add postprocessing effects to a rendered Three.js scene. In this<a id="id508" class="indexterm"/> recipe, we'll explain how you can create custom processing steps that you can use with <code class="literal">THREE.EffectComposer</code>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec293"/>Getting ready</h2></div></div></div><p>This recipe uses <code class="literal">THREE.EffectComposer</code>, so we need to load some additional JavaScript files with the correct objects. For this, you need to add the following at the top of your HTML page:</p><div><pre class="programlisting">  &lt;script src="img/CopyShader.js"&gt;&lt;/script&gt;
  &lt;script src="img/EffectComposer.js"&gt;&lt;/script&gt;
  &lt;script src="img/RenderPass.js"&gt;&lt;/script&gt;
  &lt;script src="img/ShaderPass.js"&gt;&lt;/script&gt;
  &lt;script src="img/MaskPass.js"&gt;&lt;/script&gt;</pre></div><p>In this recipe, we'll create a postprocessing effect that converts the output using a mosaic effect. You can look at the final result by opening <code class="literal">06.08-create-custom-post-processing-step.html</code> in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_10.jpg" alt="Getting ready"/></div><p>You <a id="id509" class="indexterm"/>might not recognize this, but what you're seeing is a large number of cubes that are rotating.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec294"/>How to do it…</h2></div></div></div><p>We create this effect by using a custom fragment shader. The following steps explain how to set this up:</p><div><ol class="orderedlist arabic"><li class="listitem">We first need to create <code class="literal">THREE.EffectComposer</code> and configure the steps:<div><pre class="programlisting">  var composer = new THREE.EffectComposer( renderer );
  var renderPass = new THREE.RenderPass( scene, camera );
  composer.addPass( renderPass  );</pre></div><p>So far, we have only added the render step (<code class="literal">THREE.RenderPass</code>), which renders the scene and allows us to add additional postprocessing effects.</p></li><li class="listitem">To use custom shaders, we'll need to use the <code class="literal">THREE.ShaderPass</code> object:<div><pre class="programlisting">  var customShader = {
    uniforms: {
      "tDiffuse": { type: "t", value: null},
      "scale":    { type: "f", value: 1.0 },
      "texSize":  { type: "v2", value: new THREE.Vector2( 50, 50 ) },
      "center":   { type: "v2", value: new THREE.Vector2( 0.5, 0.5 ) },
    },
    vertexShader: document.getElementById('hexagonVertexShader').text,
    fragmentShader: document.getElementById('hexagonFragmentShader').text
  };
  var effect = new THREE.ShaderPass( customShader );
  effect.renderToScreen = true;
  composer.addPass( effect );</pre></div><p>We pass in <code class="literal">customShader</code> as an argument to <code class="literal">THREE.ShaderPass</code>. This <code class="literal">customShader</code> object contains the configuration of our custom shader. The <code class="literal">uniforms</code> objects are the variables we pass into our custom shader, and <code class="literal">vertexShader</code> and <code class="literal">fragmentShader</code> point to our shader programs.</p></li><li class="listitem">Let's<a id="id510" class="indexterm"/> first look at <code class="literal">vertexShader</code> from step 2:<div><pre class="programlisting">  &lt;script id="hexagonVertexShader" type="x-shader/x-vertex"&gt;
    varying vec2 texCoord;
    void main() {
      texCoord = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  &lt;/script&gt;</pre></div><p>This is a simple vertex shader that doesn't change anything related to the output. The only thing to notice in this shader code is that we pass the coordinate that we're working on (<code class="literal">uv</code>, which is automatically passed in by Three.js) to the fragment shader as a <code class="literal">varying</code> value with the <code class="literal">texCoord</code> name.</p></li><li class="listitem">The final step is to look at the fragment shader from step 2:<div><pre class="programlisting">  &lt;script id="hexagonFragmentShader" type="x-shader/x-fragment"&gt;
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float scale;
    uniform vec2 texSize;
    varying vec2 texCoord;
    void main() {
      vec2 tex = (texCoord * texSize - center) / scale;
      tex.y /= 0.866025404;
      tex.x -= tex.y * 0.5;
      vec2 a;
      if (tex.x + tex.y - floor(tex.x) - floor(tex.y) &lt; 1.0)
      a = vec2(floor(tex.x), floor(tex.y));
      else a = vec2(ceil(tex.x), ceil(tex.y));
      vec2 b = vec2(ceil(tex.x), floor(tex.y));
      vec2 c = vec2(floor(tex.x), ceil(tex.y));
      vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);
      vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);
      vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);
      vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);
      float alen = length(TEX - A);
      float blen = length(TEX - B);
      float clen = length(TEX - C);
      vec2 choice;
      if (alen &lt; blen) {
        if (alen &lt; clen) choice = a;
        else choice = c;
      } else {
        if (blen &lt; clen) choice = b;
        else choice = c;
      }
      choice.x += choice.y * 0.5;
      choice.y *= 0.866025404;
      choice *= scale / texSize;
      gl_FragColor = texture2D(tDiffuse, choice 
        + center / texSize);
    }
  &lt;/script&gt;</pre></div><p>This<a id="id511" class="indexterm"/> is a rather large shader program and explaining the details is a bit out of scope for this recipe. In short, what happens is that this shader looks at the color of the surrounding pixels and based on that, it determines how to draw this pixel. The important item to notice here is <code class="literal">uniform sampler2D tDiffuse</code> at the top of the code. This is the output of the previous render step passed into the shader as a 2D texture. Using <code class="literal">tDiffuse</code> in the calculations, we can change the output that is rendered on screen. If we don't want to apply an effect, we would just use <code class="literal">vec4 color = texture2D(tDiffuse, texCoord)</code> to set the output color.</p></li><li class="listitem">The<a id="id512" class="indexterm"/> last step is to update the <code class="literal">render</code> loop to use composer instead of renderer:<div><pre class="programlisting">  function render() {
    composer.render();
    requestAnimationFrame(render);
  }</pre></div></li></ol></div><p>Writing shaders is difficult work; a setup like this, however, makes it a lot easier to create your own custom shaders. Just replace the fragment shader from step 4 with your own implementation and you can start experimenting.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec295"/>How it works...</h2></div></div></div><p>In this recipe, we've used <code class="literal">THREE.EffectComposer</code> together with <code class="literal">THREE.RenderPass</code> to render the scene. If we add more steps to <code class="literal">THREE.EffectComposer</code>, we can access the current rendering directly from our shader by accessing the <code class="literal">tDiffuse</code> texture. This way, we can easily add all kinds of effects by just writing a shader that uses the <code class="literal">tDiffuse</code> texture as its input.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec296"/>There's more…</h2></div></div></div><p>When you write shaders, you can pretty much create whatever you want. Getting started with shaders, however, can be rather difficult. A good example of some shaders that apply<a id="id513" class="indexterm"/> a specific effect can be found at <a class="ulink" href="https://github.com/evanw/glfx.js">https://github.com/evanw/glfx.js</a>. The shader we used in this recipe was also adopted from the <code class="literal">hexagonpixalte.js</code> shader that you can find in the <code class="literal">src/filters/fun/hexagonalpixelate.js</code> folder in the mentioned GitHub repository.</p><p>You can also look at the sources of the effects that are provided by Three.js. You can access them directly from GitHub at <a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/shaders">https://github.com/mrdoob/three.js/tree/master/examples/js/shaders</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec297"/>See also</h2></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Lights and Custom Shaders">Chapter 5</a>, <em>Lights and Custom Shaders</em>, we've also created two custom shaders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the <em>Creating a custom vertex shader</em> recipe, we explain the steps you need to take to set up a custom vertex shader</li><li class="listitem" style="list-style-type: disc">In the <em>Creating a custom fragment shader</em> recipe, we explain the steps you need to take to set up a custom fragment shader</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec86"/>Saving WebGL output to disk</h1></div></div></div><p>In this<a id="id514" class="indexterm"/> book we've created some very beautiful visualizations <a id="id515" class="indexterm"/>so far. The trouble with this, however, is that it's difficult to save the output of your rendering as an image. In this recipe, we'll show you how you can create a normal image from a WebGL-rendered scene, which can be saved to the disk.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec298"/>Getting ready</h2></div></div></div><p>There isn't much to do in order to get ready for this recipe. We'll be using standard HTML5 features, which you can apply not just to Three.js-based outputs, but to any HTML5 canvas element. We've prepared a very simple example page, where you test the result of this recipe. For this, open the <code class="literal">06.09-save-webgl-output.html</code> example in your browser. You will see something similar to the following screenshot:</p><div><img src="img/1182OS_06_11.jpg" alt="Getting ready"/></div><p>On this page, you'll see a single Three.js scene. If you hit the <em>p</em> key, the current state will be saved as a new image, which you can then download normally. Note that in the preceding <a id="id516" class="indexterm"/>screenshot, we've zoomed out of the page.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec299"/>How to do it...</h2></div></div></div><p>For this<a id="id517" class="indexterm"/> recipe, we only need to take a couple of simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we do is register an event listener for key presses:<div><pre class="programlisting">  window.addEventListener("keyup", copyCanvas);</pre></div><p>Whenever a key is pressed, the <code class="literal">copyCanvas</code> function will be called.</p></li><li class="listitem">Now let's look at the <code class="literal">copyCanvas</code> function:<div><pre class="programlisting">  function copyCanvas(e) {
    var imgData, imgNode;
    if (e.which !== 80) {
      return;
    } else {
      imgData = renderer.domElement.toDataURL();
    }
    // create a new image and add to the document
    imgNode = document.createElement("img");
    imgNode.src = imgData;
    document.body.appendChild(imgNode);
  }</pre></div><p>The first thing we do here is check which key was pressed. If the <em>p</em> key was pressed, we'll continue. Next, we take the image data from the canvas with the <code class="literal">toDataURL()</code> function. The final step we need to take is to create a new <code class="literal">img</code> element, assign the data (<code class="literal">imgData</code>), and add it to the document.</p></li><li class="listitem">This would work for non-WebGL canvas elements. However, if you work with WebGL, we need to take one additional step. We need to instantiate <code class="literal">THREE.WebGLRenderer</code> like this:<div><pre class="programlisting">  renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});</pre></div><p>If we don't do this, you'll only see a black screen in the output and not the actual WebGL output. Note, though, that this does have an adverse impact on performance.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec300"/>How it works...</h2></div></div></div><p>In HTML5, it is possible to describe a file or any other resource using a URL starting with data. So, instead of fetching resources in multiple HTTP requests, these resources could be included directly in the HTML document. The canvas element allows you to copy its contents as a URL that complies with this scheme. In this recipe, we use this data URL to create a new <code class="literal">img</code> element, which can be saved like a normal image.</p><p>If you <a id="id518" class="indexterm"/>want to dive into the details of the data URL scheme, you can look at the RFC (Request For Comments) that describes this scheme at <a class="ulink" href="http://tools.ietf.org/html/rfc2397">http://tools.ietf.org/html/rfc2397</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec301"/>There's more</h2></div></div></div><p>In the <a id="id519" class="indexterm"/>most recent version of Chrome and Firefox, you can <a id="id520" class="indexterm"/>also save the output of an HTML canvas element by right-clicking and selecting <strong>Save Image As</strong>. Besides using the standard browser functionality, it is also possible to directly start the download of the image. If you use the following piece of code instead of creating and adding a new image, the browser will automatically download the canvas as an image:</p><div><pre class="programlisting">  var link = document.createElement("a");
  link.download = 'capture.png';
  link.href = imgData;
  link.click();</pre></div><p>Finally, If you've got <a id="id521" class="indexterm"/>an animation that you want to save<a id="id522" class="indexterm"/> as a movie, you can do that as well.<a id="id523" class="indexterm"/> You can find instructions on how to do this at: <a class="ulink" href="http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets">http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets</a>
</p></div></div></body></html>