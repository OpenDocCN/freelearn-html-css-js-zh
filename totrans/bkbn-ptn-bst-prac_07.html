<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Organizing Backbone Applications &#x2013; Structure, Optimize, and Deploy"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Organizing Backbone Applications – Structure, Optimize, and Deploy</h1></div></div></div><p>In the previous chapters of this book, we looked at the individual components of Backbone.js and learned about several good practices that help create a better application. However, Backbone itself doesn't provide any application structure or guidance on how to organize the application source code. This makes it quite difficult for beginner-level programmers to understand how to create a folder structure, add proper namespaces, load script files in the appropriate order, and follow patterns to create a robust app architecture.</p><p>Almost every Backbone.js developer, at some point of time, faces this issue. You can find many articles (check the blog links on application architecture in <a class="link" href="apa.html" title="Appendix A. Books, Tutorials, and References">Appendix A</a>, <span class="emphasis"><em>Books, Tutorials, and References</em></span>) on the Web where developers have described how they tried to structure their Backbone code base. But that again makes the task difficult because you may need to choose a particular solution from a number of different opinions and understand whether that is the best solution or not. In this chapter, we will look at a step-by-step process on how to organize the structure for both small- and large-scale applications.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Application directory structure</strong></span>: Code organization is crucial in order to start developing a nontrivial JavaScript application. This section illustrates a boilerplate directory structure that may help you to conceptualize your application structure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asynchronous module definition</strong></span>: Rather than stacking a number of JavaScript files in your HTML file, <span class="strong"><strong>Asynchronous Module Definition</strong></span> (<span class="strong"><strong>AMD</strong></span>) helps in defining modules and loading its dependencies asynchronously in a subtle way.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Application architecture</strong></span>: This section provides a complete step-by-step guide on the patterns and best practices that you should follow in your application architecture to make it flexible and maintainable.</li></ul></div><div class="section" title="Understanding the application directory structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Understanding the application directory structure</h1></div></div></div><p>Code organization<a id="id245" class="indexterm"/> in a filesystem plays an important role<a id="id246" class="indexterm"/> in application development. It provides solutions to several problems such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing the separation of concern for views, models, collections, and routers</li><li class="listitem" style="list-style-type: disc">Defining a clear entry point to the application</li><li class="listitem" style="list-style-type: disc">Proper namespacing</li></ul></div><p>The directory structure that we are going to propose here is not something that will work universally for every application. As JavaScript doesn't provide an inherent code organization mechanism, there is no single pattern that is best for all the applications; it solely depends on the situation. You are free to use the following structure, and lots of developers use it for their projects without any issues:</p><div class="mediaobject"><img src="graphics/3576OS_07_02.jpg" alt="Understanding the application directory structure"/></div><p>We kept all of the <a id="id247" class="indexterm"/>static assets inside the <code class="literal">assets</code> folder. You can add more folders if you have other types of static resources. The templates are stored in a separate directory that matches the <code class="literal">views</code> folder structure. We will load these templates dynamically as needed and optimize them later to create a single file with all the templates (refer to <a class="link" href="apc.html" title="Appendix C. Organizing Templates with AMD and Require.js">Appendix C</a>, <span class="emphasis"><em>Organizing Templates with AMD and Require.js</em></span>, for more details). The <code class="literal">main.js</code> file is the entry point of the application. You will see its usage in the following section when we will discuss working with AMD. The <code class="literal">app.js</code> file holds the application class that acts as the topmost parent class of the application. All the utility files such as <code class="literal">utility.js</code> or <code class="literal">helper.js</code>, which mostly contain the helper methods, sit in the <code class="literal">util</code> folder. The <code class="literal">test</code> folder is the main directory in which all the test scripts are stored. The <code class="literal">config</code> and <code class="literal">mixin</code> folders are there to store the config and reusable mixin files respectively. This file structure is basic and can work as the boilerplate of your application.</p><p>There is another pattern that became popular for large and complex applications recently—the modular approach. In this case, we divide the complete application into multiple small modules; each module will add a specific functionality to the app. We will look into it later in this <a id="id248" class="indexterm"/>chapter, but we can discuss the file structure of this pattern here. A module consists of its own views, models, and collections. You can have one <code class="literal">templates</code> folder for each module and place that module's templates separately in that folder, or you can leave it as it is as a single <code class="literal">templates</code> folder for the complete project. We will go for the latter; the <code class="literal">app</code> folder will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/3576OS_07_03.jpg" alt="Understanding the application directory structure"/></div><p>As you can see, there is no separate <code class="literal">models</code>, <code class="literal">collections</code>, or <code class="literal">views</code> folder; instead, there is a <code class="literal">modules</code> directory that includes all the modules of the application. Each module contains a <code class="literal">main.js</code> file that works as the starting point of that module.</p><p>Now, how will you benefit by using such a modular pattern over the directory structure? Actually this is not just a change in the directory structure, but a completely new application architecture. We noticed that beginner-level developers, who are not very familiar with the module patterns, find it difficult to start with this structure—probably because it's a new concept. However, once you start using it, you will realize that it is quite easy to work with and flexible too. The advantages of using such structures are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The modules are generally independent of each other. So, you can re-use one module elsewhere with minimum changes.</li><li class="listitem" style="list-style-type: disc">The modules generally do not communicate with each other directly; they use a common medium to communicate. So, you can change or delete one module while the others stay untouched.</li><li class="listitem" style="list-style-type: disc">Your code base becomes modular and more flexible as each module encapsulates their functionality. For example, a <code class="literal">User</code> module performs all of the user-related functions; no other part of your application will handle any user-related job.</li></ul></div><p>The previous <a id="id249" class="indexterm"/>structure is not the only way to make the app modular. There are several other concepts and you can choose any of them as per your requirements. For example, I often use the AuraJS directory structure (the <code class="literal">TodoMVC</code> app from <a class="ulink" href="https://github.com/aurajs/todomvc">https://github.com/aurajs/todomvc</a>) while working with this framework. It is similar yet different and useful. So, if you are aware of multiple such directory structures and do not know which one to choose, go for the one that we mentioned previously. There is no harm in following a standard structure; it is better than going for an unstructured project directory.</p></div></div>
<div class="section" title="Working with Asynchronous Module Definition"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Working with Asynchronous Module Definition</h1></div></div></div><p>So far, we have<a id="id250" class="indexterm"/> learned to add all our script files in HTML files within <code class="literal">SCRIPT</code> tags. The browser loads these files synchronously and hence we always need to ensure that if one file has a dependency over another file, the latter should always be loaded prior to the former. Since all of the references to these dependencies are made via global variables, these dependencies must be loaded in the proper order, and a developer must take care of them before he adds a new script file to the application. Although this process works just fine, it may become difficult to manage large applications as too many dependencies will overlap. AMD provides a solution to this problem.</p><p>AMD is a mechanism <a id="id251" class="indexterm"/>used to define a module such that the module and its dependencies can be asynchronously loaded. So, multiple AMD modules can be loaded in parallel, and once the last dependent module is loaded, the main module will execute. In addition, AMD omits the use of global variables by encapsulating the module definition, and provides a way to load multiple modules into one file and obviates the need for explicit namespacing.</p><p>Presently, the most popular script loader that supports AMD is Require.js (<a class="ulink" href="http://requirejs.org">http://requirejs.org</a>). It <a id="id252" class="indexterm"/>provides an implementation of the module patterns and allows us to create a centrally-managed dependency mapping using its map configuration. Discussing Require.js in detail is beyond the scope of this chapter. So, if you want to get a complete overview of the concept, we recommend you visit their website first before proceeding to the following sections.</p><div class="section" title="Adding Require.js to your project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Adding Require.js to your project</h2></div></div></div><p>While <code class="literal">require.js</code> loads <a id="id253" class="indexterm"/>all the modules of your <a id="id254" class="indexterm"/>application, it is the only file that you need to include in your <code class="literal">index.html</code> file. Add the following script tag within the <code class="literal">HEAD</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;script data-main="app/main" src="libs/require.js"&gt;&lt;/script&gt;</pre></div><p>The <code class="literal">data-main</code> attribute<a id="id255" class="indexterm"/> specifies the JavaScript file that will act as the starting point of the application. In this case, it is our <code class="literal">main.js</code> file. Once the <code class="literal">require.js</code> file is loaded, it looks into the <code class="literal">data-main</code> attribute's entry point and loads that script. We are going to add the entire <code class="literal">require.js</code> configuration to this file along with all of the libraries and their dependencies. You do not need to add a <code class="literal">.js</code> extension to any file as RequireJS automatically appends that.</p></div><div class="section" title="Configuring dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Configuring dependencies</h2></div></div></div><p>We are <a id="id256" class="indexterm"/>going to add all the library files in the RequireJS config option, along with their paths and dependencies, to the <code class="literal">main.js</code> file:</p><div class="informalexample"><pre class="programlisting">// File: app/main.js

require.config({
  baseUrl: 'libs',
  paths: {
    jquery: 'jquery',
    underscore: 'underscore/underscore',
    backbone: 'backbone/backbone'
  },
  shim: {
    // We assume the backbone file here is a non-AMD file
    backbone: {
      exports: 'Backbone',
      deps: ['underscore', 'jquery']
    }
  }
});</pre></div><p>We call the <code class="literal">require.config()</code> method<a id="id257" class="indexterm"/> in the <code class="literal">data-main</code> entry file and pass a configuration object with a set of properties to it. There are quite a number of properties that can go as config options, but we will discuss only those that are the <a id="id258" class="indexterm"/>most important at this point. You can find a complete list in the <code class="literal">require.js</code> API (<a class="ulink" href="http://requirejs.org/docs/api.html">http://requirejs.org/docs/api.html</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">baseUrl</code>: This config <a id="id259" class="indexterm"/>defines the root path so you do not need to include it every time in your file paths.</li><li class="listitem" style="list-style-type: disc"><code class="literal">paths</code>: This <a id="id260" class="indexterm"/>config specifies the shortcut alias of each file and the paths to the files are given relative to <code class="literal">baseUrl</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">shim</code>: This <a id="id261" class="indexterm"/>config should be used only for the non-AMD files, that is, the scripts that do not already call the <code class="literal">define()</code> method. It will not work properly for AMD files.</li><li class="listitem" style="list-style-type: disc"><code class="literal">exports</code>: This <a id="id262" class="indexterm"/>config is the global variable name of that module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">deps</code>: This<a id="id263" class="indexterm"/> config is an array of dependencies that must be loaded first before the respective module loads.</li></ul></div><p>You need to <a id="id264" class="indexterm"/>look for the AMD-enabled version of the library files if you want to use them directly. Otherwise, you have to go via the <code class="literal">shim</code> option.</p></div><div class="section" title="Defining a module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Defining a module</h2></div></div></div><p>RequireJS provides<a id="id265" class="indexterm"/> two important methods—<code class="literal">define()</code> and <code class="literal">require()</code>, which facilitate module definition and dependency loading respectively. The <code class="literal">define()</code> method<a id="id266" class="indexterm"/> takes an optional module ID, an optional array that includes the dependencies that this module may require, and a function that gets executed in order to instantiate the module. The most basic module definition of a Backbone model will look like this:</p><div class="informalexample"><pre class="programlisting">// File: app/models/user.js 

define([
     'jquery',
     'underscore',
     'backbone'
   ],
   function ($, _, Backbone) {
     var User = Backbone.Model.extend({
       defaults: ['name', 'age']
     });
     return User;
   });</pre></div><p>Now, this model can be used in another file just as the other dependencies. The interesting thing is that RequireJS makes sure that a particular file is loaded only once, irrespective of how many times you include it in several files. Now, let's create a <code class="literal">Users</code> collection and use our <code class="literal">User</code> model there:</p><div class="informalexample"><pre class="programlisting">// File: app/collections/users.js

define(function (require) {
  var $ = require('jquery'),
    _ = require('underscore'),
    Backbone = require('backbone'),
    UserModel = require('app/models/user');

  var Users = Backbone.Collection.extend({
    model: UserModel
  });

  return Users;
});</pre></div><p>It is pretty simple, right? Also, <a id="id267" class="indexterm"/>notice that we loaded the dependencies in a pattern other than what we used for our model definition. This pattern is called the <code class="literal">Sugar</code> syntax and it utilizes the <code class="literal">require()</code> method to load the dependencies. You can use either of the syntaxes with your module definitions. When there are lots of dependencies, using the <code class="literal">Sugar</code> syntax makes it easier to organize the dependency variables rather than just putting them as arguments of a function.</p><p>So, with AMD, you can define all of your files in the same way. The script dependencies are loaded as we saw previously, and the text dependencies can be loaded using the <code class="literal">text</code> plugin (<a class="ulink" href="https://github.com/requirejs/text">https://github.com/requirejs/text</a>) of RequireJS. We already discussed this thoroughly in <a class="link" href="apc.html" title="Appendix C. Organizing Templates with AMD and Require.js">Appendix C</a>, <span class="emphasis"><em>Organizing Templates with AMD and Require.js</em></span>, when we loaded the external template files using this plugin. In the following section, we are going to see how we can initiate a complete application architecture using these concepts.</p></div></div>
<div class="section" title="Creating application architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Creating application architecture</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>The essential premise at the heart of Backbone has always been to try and discover the minimal set of data-structuring (Models and Collections) and user interface (Views and URLs) primitives that are useful when building web applications with JavaScript.</p><p>Jeremy Ashkenas, creator of Backbone.js, Underscore.js, and CoffeeScript</p></blockquote></div><p>As Jeremy mentioned, Backbone.js has no intention, at least in the near future, to raise its bar to provide <a id="id268" class="indexterm"/>application architecture. Backbone will continue to be a lightweight tool to produce the minimal features required for web development. So, should we blame Backbone.js for not including such functionality even though there is a huge demand for this in the developer community? Certainly not! Backbone.js only yields the set of components that are necessary to create the backbone of an application and gives us complete freedom to build the app architecture in whichever way we want.</p><div class="blockquote"><blockquote class="blockquote"><p>If working on a significantly large JavaScript application, remember to dedicate sufficient time to planning the underlying architecture that makes the most sense. It's often more complex than you may initially imagine.</p><p>Addy Osmani, author of Patterns For Large-Scale JavaScript Application Architecture</p></blockquote></div><p>So, as we start digging into more detail on creating an application architecture, we are not going to talk about trivial applications or something similar to a to-do-list app. Rather, we will <a id="id269" class="indexterm"/>investigate how to structure a medium- or large-level application. After discussions with a number of developers, we found that the main issue they face here is that there are several methodologies the online blog posts and tutorials offer to structure an application. While most of these tutorials talk about good practices, it becomes difficult to choose exactly one from them. Keeping that in mind, we will explore a number of steps that you should follow to make your app robust and maintainable in the long run.</p><div class="section" title="Managing a project directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Managing a project directory</h2></div></div></div><p>This is the first <a id="id270" class="indexterm"/>step towards creating a solid app architecture. We have already discussed this in detail in the previous sections. If you are comfortable using another directory layout, go ahead with it. The directory structure will not matter much if the rest of your application is organized properly.</p></div><div class="section" title="Organizing code with AMD"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Organizing code with AMD</h2></div></div></div><p>We will use <a id="id271" class="indexterm"/>RequireJS for our project. As discussed earlier, it comes with a bunch of facilities such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a lot of script tags in one HTML file and managing all of the dependencies on your own may work for a medium-level project, but will gradually fail for a large-level project. Such a project may have thousands of lines of code; managing a code base of that size requires small modules to be defined in each individual file. With RequireJS, you do not need to worry about how many files you have—you just know that if the standard is followed properly, it is bound to work.</li><li class="listitem" style="list-style-type: disc">The global namespace is never touched and you can freely give the best names to something that matches with it the most.</li><li class="listitem" style="list-style-type: disc">Debugging the RequireJS modules is a lot easier than other approaches because you know what the dependencies and path to each of them are in every module definition.</li><li class="listitem" style="list-style-type: disc">You can use <code class="literal">r.js</code>, an optimization tool for RequireJS that minifies all the JavaScript and CSS files, to create the production-ready build.</li></ul></div></div><div class="section" title="Setting up an application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Setting up an application</h2></div></div></div><p>For a <a id="id272" class="indexterm"/>Backbone app, there must be a centralized object that will hold together all the components of the application. In a simple application, <a id="id273" class="indexterm"/>most people generally just make the main router work as the central object. But that will surely not work for a large application and you need an <code class="literal">Application</code> object that should work as the parent component. This object should have a method (mostly <code class="literal">init()</code>) that will work as the entry point to your application and initialize the main router along with the Backbone history. In addition, either your <code class="literal">Application</code> class should extend <code class="literal">Backbone.Events</code> or it should include a property that points to an instance of the <code class="literal">Backbone.Events</code> class. The benefit of doing this is that the <code class="literal">app</code> or <code class="literal">Backbone.Events</code> instance can act as a central event aggregator, and you can trigger application-level events on it.</p><p>A very basic <code class="literal">Application</code> class will look like the following code snippet:</p><div class="informalexample"><pre class="programlisting">// File: application.js

define([
  'underscore',
  'backbone',
  'router'
], function (_, Backbone, Router) {
  // the event aggregator
  var PubSub = _.extend({}, Backbone.Events);

  var Application = function () {
    // Do useful stuff here
  }

  _.extend(Application.prototype, {
    pubsub: new PubSub(),
    init: function () {
      Backbone.history.start();
    }
  });

  return Application;
});</pre></div><p>
<code class="literal">Application</code> is a simple class with an <code class="literal">init()</code> method and a <code class="literal">PubSub</code> instance. The <code class="literal">init()</code> method acts as the starting point of the application and <code class="literal">PubSub</code> works as the application-level event manager. You can add more functionality to the <code class="literal">Application</code> class, such as starting and stopping modules and adding a region manager for view layout management. It is advisable to keep this class as short as you can.</p><div class="section" title="Using the module pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec11"/>Using the module pattern</h3></div></div></div><p>We often <a id="id274" class="indexterm"/>see that <a id="id275" class="indexterm"/> intermediate-level developers find it a bit confusing to initially use a module-based architecture. It can be a little difficult for them to make the transition from a simple MVC architecture to a modular MVC architecture. While the points we are discussing in this chapter are valid for both these architectures, we should always prefer to use a modular concept in nontrivial applications for better maintainability and organization.</p><p>In the directory structure section, <a id="id276" class="indexterm"/>we saw how the module consists of a <code class="literal">main.js</code> file, its views, models, and collections<a id="id277" class="indexterm"/> all together. The <code class="literal">main.js</code> file will define the module and have different methods to manage the other components of that module. It works as the starting point of the module. A simple <code class="literal">main.js</code> file will look like the following code:</p><div class="informalexample"><pre class="programlisting">// File: main.js

define([
  'app/modules/user/views/userlist',
  'app/modules/user/views/userdetails'
], function (UserList, UserDetails) {
  var myVar;

  return {
    initialize: function () {
      this.showUserList();
 },

    showUsersList: function () {
      var userList = new UserList();
      userList.show();
    },

    showUserDetails: function (userModel) {
      var userDetails = new UserDetails({
        model: userModel
      });
      userDetails.show();
    }
  };
});</pre></div><p>As you can see, the responsibility of this file is to initiate the module and manage the components of that module. We have to make sure that it handles only parent-level tasks; it shouldn't contain a method that one of its views should ideally have.</p><p>The concept is not very complex, but you need to set it up properly in order to use it for a large application. You can even go for an existing app and module setup and integrate it with your Backbone app. For instance, Marionette provides an application infrastructure for Backbone apps. You can use its inbuilt <code class="literal">Application</code> and <code class="literal">Module</code> classes to structure your application. It also provides a general-purpose <code class="literal">Controller</code> class—something that doesn't come with the Backbone library but can be used as a mediator to provide generic methods and work as a common medium among the modules.</p><p>You can also <a id="id278" class="indexterm"/>use AuraJS (<a class="ulink" href="https://github.com/aurajs/aura">https://github.com/aurajs/aura</a>), a framework-agonistic event-driven architecture developed by Addy Osmani (<a class="ulink" href="http://addyosmani.com">http://addyosmani.com</a>) and many others; it works quite well with Backbone.js. A thorough discussion on AuraJS is beyond<a id="id279" class="indexterm"/> the scope of this book, but you can grab a lot of useful information about it from its documentation and examples (<a class="ulink" href="https://github.com/aurajs/todomvc">https://github.com/aurajs/todomvc</a>). It is an excellent boilerplate tool that gives your app a kick-start and we highly recommend it, especially if you are not using the Marionette application infrastructure. The following are a few benefits of using AuraJS<a id="id280" class="indexterm"/>; they may help you choose this framework for your application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">AuraJS is framework-agnostic. Though it works great with Backbone.js, you can use it for your JavaScript module architecture even if you aren't using Backbone.js.</li><li class="listitem" style="list-style-type: disc">It utilizes the module pattern, application-level and module-level communication using the facade (sandbox) and mediator patterns.</li><li class="listitem" style="list-style-type: disc">It abstracts away the utility libraries that you use (such as templating and DOM manipulation) so you can swap alternatives anytime you want.</li></ul></div></div><div class="section" title="Managing objects and module communication"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec12"/>Managing objects and module communication</h3></div></div></div><p>One of<a id="id281" class="indexterm"/> the most important ways to keep the application code maintainable is to reduce the tight coupling between modules and objects. If you are following the module pattern, you should never let one module communicate with another directly. Loose coupling adds a level of restriction in your code, and a change in one module will never enforce a change in the rest of the application. Moreover, it lets you re-use the same modules elsewhere. But how can we communicate if there is no direct relationship? The two important patterns we use in this case are the observer and mediator patterns.</p><div class="section" title="Using the observer/PubSub pattern"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec08"/>Using the observer/PubSub pattern</h4></div></div></div><p>The <a id="id282" class="indexterm"/>PubSub pattern is nothing but the event dispatcher concept that we discussed in <a class="link" href="ch06.html" title="Chapter 6. Working with Events, Sync, and Storage">Chapter 6</a>, <span class="emphasis"><em>Working with Events, Sync, and Storage</em></span>. It works as a messaging channel between the object (publisher) that fires the event and another object (subscriber) that receives the notification.</p><div class="mediaobject"><img src="graphics/3576OS_07_01.jpg" alt="Using the observer/PubSub pattern"/></div><p>We mentioned earlier that we can have an application-level event aggregator as a property of the <code class="literal">Application</code> object. This event aggregator can work as the common channel via which the other modules can communicate, and that too without interacting directly.</p><p>Even at the <a id="id283" class="indexterm"/>module-level, you may need a common event dispatcher only for that module; the views, models, and collections of that module can use it to communicate with each other. However, publishing too many events via a dispatcher sometimes makes it difficult to manage them and you must be careful enough to understand which events you should publish via a generic dispatcher and which ones you should fire on a certain component only. Anyhow, this pattern is one of the best tools to design a decoupled system, and you should always have one ready for use in your module-based application.</p></div><div class="section" title="Using the mediator pattern"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec09"/>Using the mediator pattern</h4></div></div></div><p>Sometimes,<a id="id284" class="indexterm"/> you may find that too many relationships exist between the modules of your app, and you need a central point of control that will help manage all the communication. This centralized system is called the mediator; it works as a <span class="emphasis"><em>shared subject</em></span> between a set of modules and promotes loose coupling by not referring to the modules explicitly. All the modules will have a reference to this mediator.</p><p>The mediator pattern is somewhat similar to the observer pattern, but it doesn't work as a broadcasting system. It includes a set of methods that are accessible to all modules that share this mediator. A mediator can be a simple object with a number of required methods:</p><div class="informalexample"><pre class="programlisting">var Mediator = {
  method1: function(){},
  method2: function(){}
};</pre></div><p>Any module can access any method of this mediator.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>A mediator is best applied when two or more objects have an indirect working relationship, and business logic or workflow needs to dictate the interactions and coordination of these objects.</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Addy Osmani</em></span></span></td></tr></table></div><p>The concept <a id="id285" class="indexterm"/>of a mediator will get more clear once we look at a simple example. Assume that we have two modules: <code class="literal">User</code> and <code class="literal">Event</code>. The <code class="literal">User</code> module has a <code class="literal">getUserDetails()</code> method<a id="id286" class="indexterm"/> to retrieve a user's details based on the user ID. The <code class="literal">Event</code> module has a <code class="literal">loadEvents()</code> method<a id="id287" class="indexterm"/> whose job it is to load all the events near the user's current location. Now, getting the currently logged-in user's ID or current location is a functionality that isn't particularly module-specific, and it is better to keep it in a <code class="literal">Mediator</code> instance. Look at the following example:</p><div class="informalexample"><pre class="programlisting">// Mediator
define(['util'], function (Util) {
  var Mediator = {
    getLoggedinUser: function () {
      return Util.getCookie('userid');
    },

    getUserCurrentLocation: function () {
      // returns user's current location
    }
  };

  return Mediator;
});

// User module
define(['app/mediator'],
  function (Mediator) {
    var User = function () {};

    User.prototype.getUserDetails = function () {
      var userId = Mediator.getLoggedinUser();

      // Load user's details with the loggedin user id
    }

    return User;
  });

// Event module
define(['app/mediator'],
  function (Mediator) {
    var Event = function () {};

    Event.prototype.loadEvents = function () {
      var userLocation = Mediator.getUserCurrentLocation();

      // load events nearby user's location
    }

    Event.prototype.showEventDetails = function () {}

    return Event;
  });</pre></div><p>As you can see, <a id="id288" class="indexterm"/>we just pass the <code class="literal">Mediator</code> instance in both the module definitions and place the reusable and shared methods inside the mediator so that they can be accessed from any module. This is a basic example; we hope that it conveys the idea of using a mediator. In a complete application level, a mediator may take care of a lot of its functionality. Using a mediator without knowing its proper use is not a good idea—let's look at the pros and cons of using a mediator pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The pros are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The biggest advantage of using the mediator pattern is that it enforces the communication channel between modules to change from many-to-many to many-to-one. So, the modules will not communicate directly with each other but via the <code class="literal">mediator</code> object.</li><li class="listitem" style="list-style-type: disc">It omits the tight coupling between modules and thus reduces the architectural complexity in large applications.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The cons are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main drawback of this pattern is that it can introduce a single point of failure.</li><li class="listitem" style="list-style-type: disc">Communicating back and forth via a mediator may sometimes result in a performance hit.</li></ul></div></li></ul></div><p>Anyhow, both these patterns—observer and mediator, if you have noticed already, are one of the simplest to implement. If used properly, they can become the best resources for organizing and <a id="id289" class="indexterm"/>maintaining your application. It is not a big deal to use them; you can implement these concepts even in small- and medium-level applications. Whenever you feel the need for module or component communication, a mediator or PubSub pattern can become handy.</p></div></div></div><div class="section" title="Understanding view management"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Understanding view management</h2></div></div></div><p>Backbone <a id="id290" class="indexterm"/>views are very lightweight components, and you<a id="id291" class="indexterm"/> need to add some custom functions to handle event binding, proper layout, data integration, and life cycle management in almost every app. So, it is always preferable to have a base view that will handle this common functionality; all other views will extend from it. For this purpose, we recommend you choose MarionetteJS, which provides three extremely useful view classes: <code class="literal">ItemView</code>, <code class="literal">CollectionView</code>, and <code class="literal">CompositeView</code>. These classes, along with Marionette's base <code class="literal">View</code> class, facilitate the most important boilerplate functionality that one may need to use for his/her app views.</p><p>There are two more important aspects of view management: the layout manager and the template handler. We discussed both these topics in detail in <a class="link" href="ch02.html" title="Chapter 2. Working with Views">Chapter 2</a>, <span class="emphasis"><em>Working with Views</em></span>. In a large application, a single page consists of multiple views and a major task involves creating, switching, and destroying these views. While you can always handle this layout management yourself, an existing robust layout manager will help you to maintain these views and clean up the memory. You can choose either the <code class="literal">Backbone.LayoutManager</code> plugin or the <code class="literal">Marionette.RegionManager</code> extension for this job. Both of them provide similar functionality and are well-accepted in the developer community.</p><p>For templates, we advise you to observe the following important points for a large application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use Handlebars instead of Underscore's template engine, although there is no restriction in choosing other template engines. Just make sure that you do not evaluate JavaScript code in your template—this increases the complexity, as we discussed in <a class="link" href="ch02.html" title="Chapter 2. Working with Views">Chapter 2</a>, <span class="emphasis"><em>Working with Views</em></span>.</li><li class="listitem" style="list-style-type: disc">Keep your view templates in separate and individual files.</li><li class="listitem" style="list-style-type: disc">Always precompile your templates. A number of processes that we discussed in <a class="link" href="ch02.html" title="Chapter 2. Working with Views">Chapter 2</a>, <span class="emphasis"><em>Working with Views</em></span>, <a class="link" href="apb.html" title="Appendix B. Precompiling Templates on the Server Side">Appendix B</a>, <span class="emphasis"><em>Precompiling Templates on the Server Side</em></span>, and <a class="link" href="apc.html" title="Appendix C. Organizing Templates with AMD and Require.js">Appendix C</a>, <span class="emphasis"><em>Organizing Templates with AMD and Require.js</em></span>, describe how you should precompile your templates and load them.</li></ul></div></div><div class="section" title="Understanding other important features"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Understanding other important features</h2></div></div></div><p>There are <a id="id292" class="indexterm"/>few more things that you need to take care of while developing complex apps. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multiple routers</strong></span>: It's <a id="id293" class="indexterm"/>always preferable to have multiple routers compared to a gigantic router class. We discussed the concept of subrouters in <a class="link" href="ch05.html" title="Chapter 5. Routing Best Practices and Subrouting">Chapter 5</a>, <span class="emphasis"><em>Routing Best Practices and Subrouting</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Utility methods</strong></span>: Each <a id="id294" class="indexterm"/>application needs a set of utility methods that are generic and can be used by any component of the application. You should always have one or more than one <code class="literal">Utility</code> class depending on the requirements, and these classes should take care of all the common utility methods.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DOM handling</strong></span>: The<a id="id295" class="indexterm"/> more you interact with the DOM in your views, the more difficult will it be to maintain in the later stage. Always try to reduce direct DOM manipulation as much as you can.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Error handler</strong></span>: Keep <a id="id296" class="indexterm"/>a generic error/exception handler ready; it should work as a single point for the errors/warnings and display messages to the users.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Memory management</strong></span>: In <a id="id297" class="indexterm"/>single-page large applications, memory leak is a real point of concern. So, you must be very much careful about not initiating global variables, cleaning up references when they are not in use, and unbinding events when the related element or component is removed.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Summary</h1></div></div></div><p>This chapter dealt with one of the most important topics of Backbone.js-based application development. At the framework level, learning Backbone is quite easy and developers get a complete grasp over it in a very short period of time. Developing simple applications with a few pages never seems to be an issue. But when it comes to a large complex application, laying out the architecture becomes quite confusing, with what to include and what not to. In this chapter, we tried to discuss every point associated with the app's architecture and mentioned when and why you should use a particular pattern. Moreover, most of these patterns are applied to a number of large applications with success. So, you can adopt these concepts without any hesitation.</p><p>Until this chapter, we talked about almost everything related to Backbone.js application development. However, no project is complete without proper testing, and that is what we are going to learn in our next and final chapter, <a class="link" href="ch08.html" title="Chapter 8. Unit Test, Stub, Spy, and Mock Your App">Chapter 8</a>, <span class="emphasis"><em>Unit Test, Stub, Spy, and Mock Your App</em></span>.</p></div></body></html>