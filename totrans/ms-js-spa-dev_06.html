<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Data Binding, and Why You Should Embrace It"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Data Binding, and Why You Should Embrace It</h1></div></div></div><p>The View layer of a single page application goes far beyond statically displaying HTML and data through JavaScript templating engines or other means. A modern JavaScript application must handle real-time updates and be imbued with reactivity. Some of the protocols described in <a class="link" href="ch04.html" title="Chapter 4. REST is Best – Interacting with the Server Side of Your App">Chapter 4</a>, <span class="emphasis"><em>REST is Best - Interacting with the Server Side of Your App</em></span> such as WebSockets, MQPP, and DDP can be used to actively retrieve updates to data for an application, but the ability to bind those changes to the DOM and display them in the View must be handled on the frontend of the application. This is where data binding comes into play.</p><p>In this chapter, you will learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What data binding is?</li><li class="listitem" style="list-style-type: disc">The differences between one-way and two-way data binding</li><li class="listitem" style="list-style-type: disc">The AngularJS implementation of data binding</li><li class="listitem" style="list-style-type: disc">Other popular implementations of data binding</li><li class="listitem" style="list-style-type: disc">How to implement data binding with native JavaScript?</li><li class="listitem" style="list-style-type: disc">What some use cases of data binding are?</li></ul></div><div class="section" title="What is data binding?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>What is data binding?</h1></div></div></div><p>At a high level, data binding is a software design pattern specifying the ability to directly tie changes to your underlying application data, or Model, to the View by visually reflecting those changes automatically. This can be done by any number of means using JavaScript, and it is really dependent upon what version of JavaScript you are using and its abilities and limitations. In the case of a web application, those abilities and limitations are governed by the user's browser, of course, and this is why there are so many implementations of data binding in the JavaScript community.</p><p>If you have worked with any popular JavaScript frameworks, or at least have read about any of them, you have probably heard of data binding. You also have probably never attempted to implement it on your own, considering the number of libraries and frameworks out there that provide this capability. The advantage that some of these implementations give you is cross-browser compatibility by using multiple methods and feature detection in the browser for the delegation of those methods. Other frameworks, such as Ember.js and Knockout.js, use their own proprietary implementation of data binding that works across most browsers, but requires loading a potentially large library when all you want is the data binding feature.</p><p>Using a library or framework for complex data observation is often more desirable than writing custom JavaScript to do it yourself, which speaks to the popularity of frameworks such as AngularJS - often touted for its data binding features. Leveraging these features is one thing, but understanding how they work and what is going on under the hood of a framework is quite another. First, let's break down the concept of data binding a bit more.</p><div class="section" title="One-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>One-way data binding</h2></div></div></div><p>One-way, or unidirectional, data binding is when a change to an application's data model is updated and subsequently reflected in the View. The initial change to the data model can come from anywhere, be it the submission of a form from the current user, the edit of a post of a different user on another computer, or a change in current data pushed directly from the application's host server. When the change in that data is automatically merged with a dynamic template and updated in the View without intervention from the user, it is known as one-way data binding:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_06_01.jpg" alt="One-way data binding"/></div><p>
</p><p> One-way data binding is visualized in a View from the merging of a ViewModel with a Template.</p><p>Here, you can see a simple representation of the one-way data binding design pattern. The manner in which the update to the View ultimately takes place relies entirely on how the application's frontend JavaScript is written, and can be done in any number of ways, but the conceptual pattern itself remains unvarying.</p><p>Using a JavaScript templating engine, like the ones discussed in <span class="emphasis"><em><a class="link" href="ch05.html" title="Chapter 5. Its All About the View">Chapter 5</a></em></span>, <span class="emphasis"><em>Its All About the View</em></span> provides one-way data binding at the template level when expressions in the compiled templates are bound to dynamic data. Updating the view to reflect real-time changes to that data, however, must be handled with additional code that observes for model changes and triggers updates to the view accordingly.</p></div><div class="section" title="Two-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Two-way data binding</h2></div></div></div><p>Two-way, or bidirectional, data binding includes the one-way data binding pattern but additionally allows changes to the representation of data in the View by the user to be reflected in the underlying Model itself. With this pattern in place, the data displayed in the View is always a representation of the current state of the Model, even when the user makes changes to that data in the View without explicitly submitting it via forms or other means:</p><p>
</p><div class="mediaobject"><img src="graphics/B05228_06_02.jpg" alt="Two-way data binding"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>Two-way data binding is visualized in a View from changes to the ViewModel merged with a template, and changes by the user to the representations of the data in the View are merged back into the ViewModel.</p></div></div><p>This diagram shows the two-way data binding design pattern. In order for this pattern to work, there must be some type of observer in place that is continuously watching for changes to the data and syncing it in both directions. This naturally requires a more complex frontend architecture, and popular frameworks such as AngularJS can be leveraged to take the reins.</p></div></div></div>
<div class="section" title="Data binding with modern JavaScript frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Data binding with modern JavaScript frameworks</h1></div></div></div><p>Due to the complexity that comes with data binding design patterns, there are some standalone JavaScript libraries, such as Rivets.js and Knockout.js, that can provide it for you. Many full-fledged JavaScript frameworks also include their own implementations of data binding as a core feature.</p><div class="section" title="Data binding with AngularJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Data binding with AngularJS</h2></div></div></div><p>AngularJS, which is maintained by Google, is one of the most popular modern JavaScript frameworks. As discussed in <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever"><span class="emphasis"><em>Chapter 2</em></span></a>, <span class="emphasis"><em>Model-View-Whatever</em></span> it is a self-avowed MVW framework. In addition to its MVW architectural pattern implementation, it includes a powerful data binding design pattern, which is often its most touted feature.</p><div class="section" title="One-way data binding with AngularJS"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec74"/>One-way data binding with AngularJS</h3></div></div></div><p>One-way data binding with AngularJS is achieved when an expression in the View is populated by a value from the Model associated with the Controller for that View. Consider the following Controller and Model data:</p><pre class="programlisting">var myApp = angular.module('myApp', []); &#13;
myApp.controller('UserController', function UserController($scope) { &#13;
    $scope.user = { &#13;
        firstName: 'Peebo', &#13;
        lastName: 'Sanderson' &#13;
    }; &#13;
}); &#13;
</pre><p>The user Model that is defined on the scope for this Controller can be represented in the View with the following template markup:</p><pre class="programlisting">&lt;body ng-app="myApp"&gt; &#13;
    &lt;div ng-controller="UserController"&gt; &#13;
        &lt;p&gt; &#13;
            &lt;strong&gt;First Name:&lt;/strong&gt; {{user.firstName}}&lt;br&gt; &#13;
            &lt;strong&gt;Last Name:&lt;/strong&gt; {{user.lastName}} &#13;
        &lt;/p&gt; &#13;
    &lt;/div&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>Just like with many other JavaScript templating engines, the double curly brace syntax is used to represent expressions to be evaluated in an AngularJS template. Additionally, AngularJS allows for the use of the ng-bind attribute on empty HTML elements to be used in place of the double curly brace syntax for expressions:</p><pre class="programlisting">&lt;body ng-app="myApp"&gt; &#13;
    &lt;div ng-controller="UserController"&gt; &#13;
        &lt;p&gt; &#13;
            &lt;strong&gt;First Name:&lt;/strong&gt; &#13;
            &lt;span ng-bind="user.firstName"&gt;&lt;/span&gt;&lt;br&gt; &#13;
            &lt;strong&gt;Last Name:&lt;/strong&gt; &#13;
            &lt;span ng-bind="user.lastName"&gt;&lt;/span&gt; &#13;
        &lt;/p&gt; &#13;
    &lt;/div&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>This syntax is more verbose, but may be preferable to some. In either case, changes to the Model properties will be automatically updated in the View where those properties are bound by their respective template expressions. In this way, AngularJS provides the underlying DOM manipulation layer that wires Model changes to be updated in the View without any further code being necessary.</p></div><div class="section" title="Two-way data binding with AngularJS"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec75"/>Two-way data binding with AngularJS</h3></div></div></div><p>Two-way data binding with AngularJS is achieved when an editable value in the View, such as a text input, is assigned to a property on the Model for the current Controller scope. When the value for that property is changed by the user, the Model will be updated automatically, and that change will be propagated back to the View for any expression that is bound to that Model property.</p><p>Using the Controller and Model from the previous example, consider the following template markup:</p><pre class="programlisting">&lt;body ng-app="myApp"&gt; &#13;
    &lt;div ng-controller="UserController"&gt; &#13;
        &lt;p&gt; &#13;
            &lt;strong&gt;First Name:&lt;/strong&gt; {{user.firstName}}&lt;br&gt; &#13;
            &lt;strong&gt;Last Name:&lt;/strong&gt; {{user.lastName}} &#13;
        &lt;/p&gt; &#13;
        &lt;p&gt; &#13;
            &lt;label&gt; &#13;
                &lt;input type="text" ng-model="user.firstName"&gt; &#13;
            &lt;/label&gt;&lt;br&gt; &#13;
            &lt;label&gt; &#13;
                &lt;input type="text" ng-model="user.lastName"&gt; &#13;
            &lt;/label&gt; &#13;
        &lt;/p&gt; &#13;
    &lt;/div&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>The text inputs are given the ng-model attribute to assign a Model property as the value when the View is initially loaded. When the user changes the value for either of these inputs, the $scope.user Model will be updated, and the change will then be reflected in the paragraph block above the inputs where the same properties are bound to the DOM by their respective expressions. This round-trip from a change in the View to the Model and back to the View again is a simple example of two-way data binding.</p></div><div class="section" title="Dirty checking with AngularJS"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec76"/>Dirty checking with AngularJS</h3></div></div></div><p>AngularJS uses a method of polling for changes to find differences between the Model and the View, and this method is referred to as dirty checking. This checking is done on a defined interval, which is referred to as the digest cycle<span class="strong"><strong>.</strong></span> For each digest cycle, special methods called watches are registered with listeners by the scope to watch for changes to bound expressions that are passed to them:</p><pre class="programlisting">$scope.$watch(watchExpression, listener); &#13;
 &#13;
</pre><p>As explained in <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, <span class="emphasis"><em>Model-View-Whatever</em></span> the <span class="emphasis"><em>scope</em></span> is a JavaScript object that defines the Model context for variable expressions in the View. The watches compare bound Model expressions with their previous values and if any of them are found to be <span class="emphasis"><em>dirty</em></span>, or different, the listener callbacks are executed and the changes are then synced to the View.</p><p>AngularJS allows dirty checking to be performed at multiple levels of depth for an object, depending on your needs. There are three types of watch provided for this, with three respective depths. These levels provide for flexible data binding features, but with more depth comes more performance concerns.</p><div class="section" title="Dirty checking by reference"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec32"/>Dirty checking by reference</h4></div></div></div><p>The standard method of dirty checking in AngularJS watches for the entire value of a bound expression to change to a new value. This is referred to as dirty checking by reference. If the expression represents an object or an array, and only changes to its properties or members are made, the change will not be detected. This is the lowest depth of dirty checking, and thereby the most performant.</p><p>As an example, consider a user object with multiple properties is applied to the scope:</p><pre class="programlisting">$scope.user = { &#13;
    firstName: 'Peebo', &#13;
    lastName: 'Sanderson', &#13;
    age: 54 &#13;
}; &#13;
 &#13;
</pre><p>Now a watch expression can be bound by reference to one of the object's properties:</p><pre class="programlisting">$scope.$watch('user.firstName', listener); &#13;
$scope.user.firstName = 'Udis'; &#13;
</pre><p>Since user.firstName has changed, this will be picked up in the subsequent digest cycle and the listener function will be triggered. Now consider instead that we watch the user object itself:</p><pre class="programlisting">$scope.$watch('user', listener); &#13;
$scope.user.lastName = 'Petroyka'; &#13;
// The entire value of $scope.user has not changed &#13;
 &#13;
</pre><p>In this case, nothing is picked up by the watch after user.lastName is changed. This is because the watch is looking for the user object itself to change - not one of its individual properties:</p><pre class="programlisting">$scope.user = { &#13;
    firstName: 'Udis', &#13;
    lastName: 'Petroyka, &#13;
    age: 82 &#13;
}; &#13;
// The entire value of $scope.user has changed &#13;
 &#13;
</pre><p>If you were to instead replace the entire user object itself, the watch would find the value to be <span class="emphasis"><em>dirty</em></span> and would then invoke the listener during the next digest cycle.</p></div><div class="section" title="Dirty checking by collection contents"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec33"/>Dirty checking by collection contents</h4></div></div></div><p>If you need to watch for shallow changes to an object or an array, AngularJS provides another method for watching called <code class="literal">$watchCollection</code>. In this context, <span class="emphasis"><em>shallow</em></span> means that the watch will only respond to changes at the first level of the object or array <code class="literal">
<span class="strong"><strong>- deep </strong></span>
</code>property changes, or those of nested objects or arrays, will not be detected. AngularJS calls this dirty checking by collection contents:</p><pre class="programlisting">$scope.$watchCollection(obj, listener); &#13;
 &#13;
</pre><p>In this case, changing a property of the user object from the previous example would be picked up by the watch and trigger the <code class="literal">listener</code>:</p><pre class="programlisting">$scope.$watchCollection('user', listener); &#13;
$scope.user.firstName = 'Jarmond'; &#13;
// A property of the object has changed &#13;
 &#13;
</pre><p>Dirty checking by collection contents is not as performant as checking by reference because a copy of the watched object or array must be kept in memory.</p></div><div class="section" title="Dirty checking by value"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec34"/>Dirty checking by value</h4></div></div></div><p>AngularJS also allows you to watch for changes on any nested data within an object or array. This is referred to as dirty checking by value:</p><pre class="programlisting">$scope.$watch(watchExpression, listener, true); &#13;
 &#13;
</pre><p>You can implement this method of watching using the <code class="literal">$watch</code> method, just as you would with checking by reference, but with an added third parameter set to true. This parameter tells the watch whether you want to check for object equality or not, and it defaults to false. When the watch checks for equality by reference, it performs a simple <code class="literal">!==</code> conditional. When the third parameter of $watch is set to true, however, it uses the internal angular.equals method for a deep comparison.</p><p>The <code class="literal">angular.equals</code> method can be used to compare any two values, and it supports value types, regular expressions, objects, and arrays. If a property being compared is a function or its name begins with <code class="literal">$</code>, it will be ignored. The reason for ignoring functions is obvious, and as for the <code class="literal">$</code> prefix, it is likely done to avoid AngularJS internal functionality from being overwritten.</p><p>Dirty checking by value is the most comprehensive form of data binding in AngularJS, but it is also the least performant. This is because a full copy of any complex object or array being compared must be held in memory, as is the case with dirty checking by collection contents, but additionally, a deep traversal of the entire object or array must be performed on each digest cycle. To maintain memory efficiency in your application, care should be taken when using this type of data binding with AngularJS.</p></div><div class="section" title="When to use dirty checking for data binding"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec35"/>When to use dirty checking for data binding</h4></div></div></div><p>The dirty checking approach to data binding has its pros and cons. AngularJS assures us that memory is not a concern as long as you are not doing several thousand bindings in a single view. A downside is, however, that changes to the Model will not always show up in real time due to the latency of the digest cycle. If you are designing an application in which you would like to display true real-time, two-way data binding, then AngularJS may not be the solution for you.</p></div></div></div><div class="section" title="Data binding with Ember.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Data binding with Ember.js</h2></div></div></div><p>Ember.js is a popular open source JavaScript framework for building web applications. It is similar to AngularJS in its provided features, but it takes quite a different approach to data binding.</p><p>Ember.js runs an internal loop, similar to the digest cycle in AngularJS, called the <code class="literal"><span class="strong"><strong>run loop</strong></span></code>. It does not use dirty checking on bound Model data, but it maintains the run loop for other internal functionality, such as scheduling work queues to be performed in a particular order. The main reason behind scheduling operations within the run loop is to provide memory management and optimize the efficiency of the framework.</p><p>Ember.js uses property accessors to provide data binding, which means it uses direct object properties to get and set bound Model values. With this mechanism in place, it can forgo dirty checking to employ data binding.</p><div class="section" title="Computed properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec77"/>Computed properties</h3></div></div></div><p>Ember.js uses computed properties via object property accessors internally for setting and getting values. This means that properties are defined as functions that perform some type of manipulation to produce the final values that are returned. To do this, the native JavaScript object type is extended with the internal <code class="literal">Ember.Object.extend</code> method, and computed properties are returned using the <code class="literal">Ember.computed</code> method:</p><pre class="programlisting">var User = Ember.Object.extend({ &#13;
    firstName: null, &#13;
    lastName: null, &#13;
    fullName: Ember.computed('firstName', 'lastName', function() { &#13;
        return `${this.get('firstName')} ${this.get('lastName')}`; &#13;
    }) &#13;
}); &#13;
</pre><p>For this extended <code class="literal">User</code> object, the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties are static, but the <code class="literal">fullName</code> property is computed with the <code class="literal">'firstName'</code> and <code class="literal">'lastName'</code> strings passed to it as parameters. This tells the computed method that those properties of the extended object are to be used in computing the returned value for <code class="literal">fullName</code>.</p><p>Now, to access the value that is returned by <code class="literal">fullName</code>, a new User object must first be created with the static <code class="literal">firstName</code> and <code class="literal">lastName</code> properties defined:</p><pre class="programlisting">var currentUser = User.create({ &#13;
    firstName: 'Chappy', &#13;
    lastName: 'Scrumdinger' &#13;
}); &#13;
</pre><p>Once a <code class="literal">currentUser</code> object is created with a given <code class="literal">firstName</code> and <code class="literal">lastName</code> value, the <code class="literal">fullName</code> property can be computed and returned:</p><pre class="programlisting">currentUser.get('fullName'); // returns "Chappy Scrumdinger" &#13;
</pre><p>This convention of extending objects is a bit verbose, but it allows Ember.js to handle the computed properties internally and track bound objects while also normalizing JavaScript inconsistencies across various user agents, or browsers.</p></div><div class="section" title="One-way data binding with Ember.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec78"/>One-way data binding with Ember.js</h3></div></div></div><p>Ember.js uses computed properties in its data binding implementation, which means that direct property accessors can be used and no dirty checking is necessary. For one-way bindings, you can get the property for an object, but you cannot set it:</p><pre class="programlisting">var User = Ember.Object.create({ &#13;
    firstName: null, &#13;
    lastName: null, &#13;
    nickName: Ember.computed.oneWay('firstName') &#13;
}); &#13;
 &#13;
</pre><p>In this example, the <code class="literal">Ember.computed.oneWay</code> method is used to apply a one-way binding for the <code class="literal">nickName</code> property as an <span class="emphasis"><em>alias</em></span> of the <code class="literal">firstName</code> property:</p><pre class="programlisting">var currentUser = User.create({ &#13;
    firstName: 'Peebo', &#13;
    lastName: 'Sanderson' &#13;
}); &#13;
</pre><p>When a new User object is created, the <code class="literal">nickName</code> property for it can then be accessed:</p><pre class="programlisting">currentUser.get('nickName'); // returns "Peebo" &#13;
</pre><p>Since this is only a one-way binding, however, the <code class="literal">nickName</code> property cannot be used to set the aliased <code class="literal">firstName</code> property:</p><pre class="programlisting">currentUser.set('nickName', 'Chappy'); &#13;
currentUser.get('firstName'); // returns "Peebo" &#13;
</pre><p>Often, you may only need to return bound values in an application and not implicitly set them from the View. Wither Ember.js, the <code class="literal">Ember.computed.oneWay</code> method can be used for this purpose and will save you additional performance concerns.</p></div><div class="section" title="Two-way data binding with Ember.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec79"/>Two-way data binding with Ember.js</h3></div></div></div><p>Two-way data binding is also available with Ember.js via computed properties. This uses an alias paradigm as well; however, a computed two-way alias allows for both getting and setting an aliased property:</p><pre class="programlisting">var User = Ember.Object.extend({ &#13;
    firstName: null, &#13;
    lastName: null, &#13;
    nickName: Ember.computed.alias('firstName') &#13;
}); &#13;
</pre><p>In this instance, we are using the Ember.computed.alias method to employ two-way data binding for the aliased <code class="literal">firstName</code> property via the computed <code class="literal">nickName</code> property:</p><pre class="programlisting">var currentUser = User.create({ &#13;
    firstName: 'Udis', &#13;
    lastName: 'Petroyka' &#13;
}); &#13;
</pre><p>When a new User object is created now, the <code class="literal">nickName</code> property can be accessed to both set and get the aliased <code class="literal">firstName</code> property:</p><pre class="programlisting">currentUser.get('nickName'); // returns "Udis" &#13;
currentUser.set('nickName', 'Peebo'); &#13;
currentUser.get('firstName'); // returns "Peebo" &#13;
</pre><p>Now, with two-way data binding, View synchronization comes into play. One thing to note about Ember.js in this scenario is that, although it does not use dirty checking, it will not immediately update values bound to the Model after they are changed. Property accessors are indeed used to aggregate changes to bound data, but they are not synchronized until the next run loop, just as with AngularJS and its digest cycle. In this respect, you could surmise that data binding with AngularJS versus Ember.js is really no different, and neither framework provides any benefit over the other in this regard.</p><p>Keep in mind that the internal looping mechanisms implemented in these frameworks are designed around performance optimization. The difference in this case is that AngularJS uses its digest cycle to check for changes to bound values, in addition to its other internal operations, while Ember.js is always aware of changes to its bound values and only uses its run loop to synchronize them.</p><p>It is likely that each of these frameworks provides certain advantages over the other, depending upon what type of application you are building. When choosing a framework to build an application, it is always important to understand these internal mechanisms so that you can consider how they may affect performance in your particular use case.</p></div></div><div class="section" title="Data binding with Rivets.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Data binding with Rivets.js</h2></div></div></div><p>Sometimes it is desirable to build an SPA with smaller, more modular libraries that provide you with specific functionality, rather than using a full-fledged frontend framework such as AngularJS or Ember.js. This could be because you are building a simple application that does not necessitate the complexity of an MVW architectural pattern, or you may just not want to be constrained by the conventions of a framework.</p><p>Rivets.js is a lightweight library that is primarily designed around data binding, and although it does provide some additional features, it makes very few assumptions about your application architecture. In this respect, it is a good choice if you are only looking to add a data binding layer to a modularized application.</p><div class="section" title="One-way data binding with Rivets.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec80"/>One-way data binding with Rivets.js</h3></div></div></div><p>Rivets.js uses an internal construct called a<span class="emphasis"><em> binder</em></span> to define how the DOM should be updated in response to a change in a bound property's value. The library comes with a variety of built-in binders, but also allows you to define your own custom binders.</p><p>One-way binders in Rivets.js update the DOM when a property on a bound Model changes. As you would expect in a one-way scenario, updating the View will not update the Model.</p><p>Consider the following object:</p><pre class="programlisting">var dog = { &#13;
    name: 'Belladonna', &#13;
    favoriteThing: 'Snacks!' &#13;
}; &#13;
</pre><p>Using the binder syntax of Rivets.js, these properties can be bound to the View as follows:</p><pre class="programlisting">&lt;h1 rv-text="dog.name"&gt;&lt;/h1&gt; &#13;
&lt;p&gt; &#13;
    My favorite thing is:  &#13;
    &lt;span rv-text="dog.favoriteThing"&gt;&lt;/span&gt; &#13;
&lt;/p&gt; &#13;
</pre><p>Rivets.js uses the <code class="literal">rv-</code> custom attribute prefix on HTML elements to define behaviors for different types of binders. The <code class="literal">rv-</code>text attribute is a built-in binder that inserts a bound value directly into the DOM, just as any JavaScript templating engine might do. To that point, there is also an expression interpolation syntax that uses single curly braces:</p><pre class="programlisting">&lt;h1&gt;{ dog.name }&lt;/h1&gt; &#13;
&lt;p&gt;My favorite thing is: { dog.favoriteThing }&lt;/p&gt; &#13;
</pre><p>With either of these examples, the View would render the following HTML:</p><pre class="programlisting">&lt;h1&gt;Belladonna&lt;/h1&gt; &#13;
&lt;p&gt;My favorite thing is: Snacks!&lt;/p &#13;
</pre><p>Changing any properties on the bound Model would also update the View:</p><pre class="programlisting">dog.name = 'Zoe'; // binder in View is updated &#13;
dog.favoriteThing = 'Barking!'; // binder in View is updated &#13;
 &#13;
</pre><p>The rendered HTML in the View would then reflect these changes:</p><pre class="programlisting">&lt;h1&gt;Zoe&lt;/h1&gt; &#13;
&lt;p&gt;My favorite thing is: Barking!&lt;/p&gt; &#13;
 &#13;
</pre><div class="section" title="Defining your own one-way binder"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec36"/>Defining your own one-way binder</h4></div></div></div><p>If none of the many predefined binders in Rivets.js fits your needs, you can always define your own:</p><pre class="programlisting">rivets.binders.size = function(el, val) { &#13;
    el.style.fontSize = val; &#13;
}; &#13;
</pre><p>In this example, we have created a binder called size, which can be used to dynamically change the CSS font-size property for an element based on a Model value:</p><pre class="programlisting">var dog = { &#13;
    name: 'Belladonna', &#13;
    favoriteThing: 'Snacks!', &#13;
    size: '2rem' &#13;
}; &#13;
</pre><p>The custom binder can then be used in the View as follows:</p><pre class="programlisting">&lt;h1&gt;{ dog.name }&lt;/h1&gt; &#13;
&lt;p&gt; &#13;
    My favorite thing is: &#13;
    &lt;span rv-size="dog.size"&gt;{ dog.favoriteThing }&lt;/span&gt; &#13;
&lt;/p&gt; &#13;
</pre><p>This would render the View with the <code class="literal">dog.favoriteThing</code> value displayed at twice the font-size of the body text, as defined in the bound dog Model.</p></div></div><div class="section" title="Two-way data binding with Rivets.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec81"/>Two-way data binding with Rivets.js</h3></div></div></div><p>Two-way binders in Rivets.js behave just as one-way binders do when a Model is updated by synchronizing the bound values in the View, but they will also update the Model when bound values in the View are changed by the user. This behavior could be triggered by form input or some other type of event, such as clicking a button.</p><p>There are some predefined two-way binders included with Rivets.js. As you might expect, it provides for the most common use case <code class="literal">- a</code> text input:</p><pre class="programlisting">&lt;input type="text" rv-value="dog.name"&gt; &#13;
 &#13;
</pre><p>Using the <code class="literal">rv-value</code> attribute to bind a Model property to an input element will prepopulate the value for that input with the bound Model value, and it will also update the Model value when the user changes the value of the input.</p><div class="section" title="Defining your own two-way binder"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec37"/>Defining your own two-way binder</h4></div></div></div><p>To define a custom two-way binder in Rivets.js, a much more explicit approach must be taken, in contrast to one-way binders. This is because you must define how to bind and unbind to an element, as well as the data binding routine to run when the bound value changes:</p><pre class="programlisting">rivets.binders.validate = { &#13;
    bind: function(el) { &#13;
        adapter = this.config.adapters[this.key.interface]; &#13;
        model = this.model; &#13;
        keypath = this.keypath; &#13;
 &#13;
        this.callback = function() { &#13;
            value = adapter.read(model, keypath); &#13;
            adapter.publish(model, keypath, !value); &#13;
        } &#13;
 &#13;
        $(el).on('focus', this.callback); &#13;
    }, &#13;
 &#13;
    unbind: function(el) { &#13;
        $(el).off('blur', this.callback); &#13;
    }, &#13;
 &#13;
    routine: function(el, value) { &#13;
        $(el)[value ? 'removeClass' : 'addClass']('invalid'); &#13;
    } &#13;
}; &#13;
</pre><p>Using the special property definitions shown in this example, we are telling Rivets.js to bind to an input <code class="literal">onfocus</code> and to unbind from the input <code class="literal">onblur</code>. Additionally, we define a routine to run when the value changes in which a <code class="literal">className</code> of invalid is added to the input when the value is empty, and removed when it is populated.</p></div></div></div></div>
<div class="section" title="Implementing data binding with native JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Implementing data binding with native JavaScript</h1></div></div></div><p>Writing your own implementation of data binding can be done fairly easily using native JavaScript. If you don't feel the need to use a comprehensive framework or library for your application and simply want the benefit of the data binding design pattern baked in, using native JavaScript to implement it is a logical course to take. This will provide you with several benefits, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You will understand how the data binding actually works under the hood</li><li class="listitem" style="list-style-type: disc">You will have a less bloated frontend that doesn't include extraneous library code that you may not even use</li><li class="listitem" style="list-style-type: disc">You won't be pigeonholed into an architecture defined by a particular framework when all you want is the added benefit of data binding</li></ul></div><div class="section" title="Object getters and setters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Object getters and setters</h2></div></div></div><p>The <code class="literal">Object</code> type in JavaScript has native <code class="literal">get</code> and <code class="literal">set</code> properties that can be used as <code class="literal">getters</code> and <code class="literal">setters</code> for any property name on a particular object. A <code class="literal">getter</code> is a method that returns a dynamically computed value from an object, and a <code class="literal">setter</code> is a method that is used to pass a value to a given property on an object as if you were assigning it that value. When a setter is defined and passed a value, the property name for that setter cannot actually hold a value itself; however, it can be used to <span class="emphasis"><em>set</em></span> the value on a completely different variable.</p><p>The <code class="literal">get</code> and <code class="literal">set</code> properties default to <code class="literal">undefined</code>, just like any unassigned property on an object, so they can easily be defined as functions for any user-defined object without affecting JavaScript's native <code class="literal">Object</code> prototype. This can be a powerful tool when used in an appropriate manner within an intuitive design pattern such as data binding.</p><div class="section" title="The object initializer"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec82"/>The object initializer</h3></div></div></div><p>
<code class="literal">Getters</code> and <code class="literal">setters</code> can be defined for an object using an object initializer, which is most commonly performed by defining an object in literal notation. For example, suppose we want to create a <code class="literal">getter</code> and a <code class="literal">setter</code> for the <code class="literal">firstName</code> property on an object named user:</p><pre class="programlisting">var firstName = 'Udis'; &#13;
var user = { &#13;
    get firstName() { &#13;
        return firstName; &#13;
    }, &#13;
    set firstName(val) { &#13;
        firstName = val; &#13;
    } &#13;
}; &#13;
</pre><p>In this instance, we can use the <code class="literal">user.firstName</code> property to <code class="literal">get</code> and <code class="literal">set</code> the value for the <code class="literal">firstName</code> variable by simply using standard object literal syntax:</p><pre class="programlisting">console.log(user.firstName); // Returns "Udis" &#13;
user.firstName = 'Jarmond'; &#13;
console.log(user.firstName); // Returns "Jarmond" &#13;
console.log(firstName); // Returns "Jarmond" &#13;
</pre><p>In this example, setting <code class="literal">user.firstName = 'Jarmond'</code> does not actually change the value of the <code class="literal">user.firstName</code> property; rather, it calls the property's defined setter method and instead sets the value for the standalone <code class="literal">firstName</code> variable.</p></div><div class="section" title="The Object.defineProperty() method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec83"/>The Object.defineProperty() method</h3></div></div></div><p>It may often be the case that you would like to modify an existing object to provide data binding for that object in your application. To do this, the <code class="literal">Object.defineProperty()</code> method can be used to add the getter and setter for a particular property on a predefined object:</p><pre class="programlisting">var user = {}; &#13;
Object.defineProperty(user, 'firstName', { &#13;
    get: function() { &#13;
        return firstName; &#13;
    } &#13;
    set: function(val) { &#13;
        firstName = val; &#13;
    }, &#13;
    configurable: true, &#13;
    enumerable: true &#13;
}); &#13;
</pre><p>This method takes the object you want to define a property for as the first argument, the property name you are defining as the second argument, and a <code class="literal">descriptor</code> object as the third argument. The descriptor object allows you to define the <code class="literal">getter</code> and <code class="literal">setter</code> for the property using the <code class="literal">get</code> and <code class="literal">set</code> key names, and it additionally allows some other keys to further describe the property.</p><p>The <code class="literal">configurable</code> key, if <code class="literal">true</code>, allows the property's configuration to be changed and the property itself to be deleted. It defaults to <code class="literal">false</code>. The <code class="literal">enumerable</code> key, if <code class="literal">true</code>, allows the property to be visible when iterating over the parent object. It also defaults to <code class="literal">false</code>.</p><p>Using <code class="literal">Object.defineProperty()</code> is a more concise way to declare the <code class="literal">getter</code> and <code class="literal">setter</code> for an object's property because you can explicitly configure the behavior for that property, in addition to being able to add the property to a predefined object.</p></div><div class="section" title="Designing a getter and setter data binding pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec84"/>Designing a getter and setter data binding pattern</h3></div></div></div><p>Now we can take this example further by creating a two-way binding between a DOM element and the <code class="literal">user</code> object for which we have defined a <code class="literal">getter</code> and <code class="literal">setter</code>. Let's consider a text input element that is prepopulated with the <code class="literal">firstName</code> value initially when the page loads:</p><pre class="programlisting">&lt;input type="text" name="firstName" value="Jarmond"&gt; &#13;
</pre><p>Now we can define our <code class="literal">getter</code> and <code class="literal">setter</code> based on the value of this input so that there is a reactive binding between the Model and the View:</p><pre class="programlisting">var firstName = document.querySelector('input[name="firstName"]'); &#13;
var user = {}; &#13;
Object.defineProperty(user, 'firstName', { &#13;
    get: function() { &#13;
        return firstName.value; &#13;
    }, &#13;
    set: function(val) { &#13;
       firstName.value = val; &#13;
    }, &#13;
    configurable: true, &#13;
    enumerable: true &#13;
}); &#13;
</pre><p>If you create a page with the input element and run the code above, you can then use the developer console in your browser to set the value of <code class="literal">user.firstName</code> and see it automatically update in the DOM for the value of the input element:</p><pre class="programlisting">user.firstName = 'Chappy'; &#13;
</pre><p>Additionally, if you change the value in the text input and then check the value of the <code class="literal">user.firstName</code> property in the developer console, you will see that it reflects the changed value of the input. With this simple use of a <code class="literal">getter</code> and <code class="literal">setter</code>, you have architecturally implemented two-way data binding with native JavaScript.</p><div class="section" title="Synchronizing data in the View"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec38"/>Synchronizing data in the View</h4></div></div></div><p>To further extend this example so that representations of the Model in the View always remain synchronized and work much like the Rivets.js data binding pattern, we can simply add an oninput event callback to our input to update the DOM in the desired fashion:</p><pre class="programlisting">firstName.oninput = function() { &#13;
    user.firstName = user.firstName; &#13;
}; &#13;
</pre><p>Now, if we want other places in the DOM where this data is represented to be updated upon changing the value of this input, all we need to do is add the desired behavior to the setter for the property. Let's use a custom HTML attribute called <code class="literal">data-bind</code> to convey the property's representation in the DOM outside of the text input itself.</p><p>First, create a static file with the following HTML:</p><pre class="programlisting">&lt;p&gt; &#13;
    &lt;label&gt; &#13;
        First name:  &#13;
        &lt;input type="text" name="firstName" value="Udis"&gt; &#13;
    &lt;/label&gt; &#13;
&lt;/p&gt; &#13;
</pre><p>Then, below the HTML and just before the closing <code class="literal">&lt;/body&gt;</code> tag of your document, add the following JavaScript within <code class="literal">&lt;script&gt;</code> tags:</p><pre class="programlisting">var firstName = document.querySelector('input[name="firstName"]'); &#13;
var user = {}; &#13;
Object.defineProperty(user, 'firstName', { &#13;
    get: function() { &#13;
        return firstName.value; &#13;
    }, &#13;
    set: function(val) { &#13;
        var list = document.querySelectorAll( &#13;
            '[data-bind="firstName"]' &#13;
        ), i; &#13;
        for (i = 0; i &lt; list.length; i++) { &#13;
            list[i].innerHTML = val; &#13;
        } &#13;
        firstName.value = val; &#13;
    }, &#13;
    configurable: true, &#13;
    enumerable: true &#13;
}); &#13;
user.firstName = user.firstName; &#13;
firstName.oninput = function() { &#13;
    user.firstName = user.firstName; &#13;
}; &#13;
</pre><p>Now load the page in your browser and observe that the <code class="literal">&lt;strong data-bind="firstName"&gt;</code> element will be populated with the name <code class="literal">Udis</code> from the value of the input. This is achieved by calling the setter for the <code class="literal">user.firstName</code> property and assigning it to its corresponding <code class="literal">getter</code> as <code class="literal">user.firstName = user.firstName</code>. This may seem redundant, but what is actually occurring here is the code defined in the setter method is being executed with the given value from the text input, which is obtained from the <code class="literal">getter</code>. The setter looks for any element on the page with the <code class="literal">data-bind</code> property set to <code class="literal">firstName</code> and updates that element's content with the <code class="literal">firstName</code> value from the input, which is represented in the model as <code class="literal">user.firstName</code>.</p><p>Next, place your cursor in the text input and change the value. Notice that the name represented within the <code class="literal">&lt;strong&gt;</code> element changes as you type, and each representation is in sync with the model. Finally, use your developer console to update the value of the model:</p><pre class="programlisting">user.firstName = 'Peebo'; &#13;
</pre><p>Notice that the representations both in the text input and the <code class="literal">&lt;strong&gt;</code> element are automatically updated and in sync. You have successfully created a two-way data binding and View synchronization design pattern using a small amount of native JavaScript.</p></div><div class="section" title="Abstracting the design pattern to a reusable method"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec39"/>Abstracting the design pattern to a reusable method</h4></div></div></div><p>You can further abstract your data binding design pattern by creating a method that can be used to apply this behavior to a property for any predefined object:</p><pre class="programlisting">function dataBind(obj, prop) { &#13;
    var input = document.querySelector('[name="' + prop + '"]'); &#13;
    input.value = obj[prop] || input.value; &#13;
    Object.defineProperty(obj, prop, { &#13;
        get: function() { &#13;
            return input.value; &#13;
        }, &#13;
        set: function(val) { &#13;
            var list = document.querySelectorAll( &#13;
                '[data-bind="' + prop + '"]' &#13;
            ), i; &#13;
            for (i = 0; i &lt; list.length; i++) { &#13;
                list[i].innerHTML = val; &#13;
            } &#13;
            input.value = val; &#13;
        }, &#13;
        configurable: true, &#13;
        enumerable: true &#13;
    }); &#13;
    obj[prop] = obj[prop]; &#13;
    input.oninput = function() { &#13;
        obj[prop] = obj[prop]; &#13;
    }; &#13;
} &#13;
</pre><p>Here, we have created a method called <code class="literal">dataBind</code>, which takes an object and a property as its arguments. The property name is used as an identifier for elements in the DOM that are to be bound to the Model:</p><pre class="programlisting">// For the input &#13;
var input = document.querySelector('[name="' + prop + '"]'); &#13;
// For other elements &#13;
var list = document.querySelectorAll('[data-bind="' + prop + '"]'); &#13;
</pre><p>Next, simply define an object and call the <code class="literal">dataBind</code> method on it, additionally passing in the property name you want to bind to the DOM. This method also allows you to set the initial value for the property in the Model, and it will be reflected in the View upon binding if it is set. Otherwise, it will display the value set on the input itself, if any:</p><pre class="programlisting">var user = {}; &#13;
user.firstName = 'Peebo'; &#13;
dataBind(user, 'firstName'); &#13;
</pre><p>If you modify the code in the page you just created to use the abstracted <code class="literal">dataBind</code> method, you will see that it works exactly as before, but it can now be reused to bind multiple object properties with multiple corresponding elements in the DOM. This pattern can certainly be further abstracted and combined with a modeling pattern in which it could be used as a powerful data binding layer within a JavaScript SPA. The open source library inbound.js is a good example of this pattern taken to the next level. You can learn more about it at <a class="ulink" href="http://inboundjs.com">inboundjs.com</a>.</p></div></div></div><div class="section" title="Accounting for DOM mutations"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Accounting for DOM mutations</h2></div></div></div><p>One downfall of the previous example, when it comes to View synchronization, is that only user input will trigger the setting of the Model from the View. If you want comprehensive, two-way data binding in which any changes to bound values in the View sync to their respective Model properties, then you must be able to observe DOM mutations, or changes, by any means.</p><p>Let's take a look at the previous example again:</p><pre class="programlisting">var user = {}; &#13;
user.firstName = 'Peebo'; &#13;
dataBind(user, 'firstName'); &#13;
</pre><p>Now if you edit the value of the text input, the <code class="literal">firstName</code> property on the Model will update, and the <code class="literal">&lt;strong data-bind="firstName"&gt;</code> element's contents will be updated as well:</p><pre class="programlisting">&lt;input type="text" name="firstName" value="Jarmond"&gt; &#13;
 &#13;
console.log(user.firstName); // returns "Jarmond" &#13;
</pre><p>Now let's instead use the developer console and change the <code class="literal">&lt;strong data-bind="firstName"&gt;</code> element's <code class="literal">innerHTML</code>:</p><pre class="programlisting">document.querySelector('strong[data-bind="firstName"]') &#13;
    .innerHTML = 'Udis'; &#13;
</pre><p>After doing this, you will notice that the value of the input has not updated, and neither has the Model data:</p><pre class="programlisting">console.log(user.firstName); // returns "Jarmond" &#13;
</pre><p>The DOM mutation you created by using the console has now broken your two-way data binding and View synchronization. Fortunately, there is a native JavaScript constructor that can be used to avoid this pitfall.</p><div class="section" title="MutationObserver"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec85"/>MutationObserver</h3></div></div></div><p>The <code class="literal">MutationObserver</code> constructor provides the ability to observe changes to the DOM no matter where they are triggered from. In most cases, user input is likely sufficient for triggering Model updates, but if you are building an application that may have DOM mutations triggered from other sources, such as data being pushed via Websockets, you may want to sync those changes back to your Model.</p><p>MutationObserver works much like the native addEventListener by providing a special type of listener that triggers a callback upon DOM mutation. This event type is unique in that it is not often triggered by direct user interaction, unless the developer console is being used to manipulate the DOM. Instead, application code is typically what will be updating the DOM, and this event is triggered directly by those mutations.</p><p>A simple <code class="literal">MutationObserver</code> can be instantiated as follows:</p><pre class="programlisting">var observer = new MutationObserver(function(mutations) { &#13;
  mutations.forEach(function(mutation) { &#13;
    console.log(mutation); &#13;
  });     &#13;
});  &#13;
</pre><p>Next, a configuration must be defined to pass to the observe method of the new observer object:</p><pre class="programlisting">    var config = { &#13;
        attributes: true, &#13;
        childList: true, &#13;
        characterData: true &#13;
    }; &#13;
 &#13;
</pre><p>This object is called <code class="literal">MutationObserverInit</code>. It defines special properties that are used by the <code class="literal">MutationObserver</code> implementation to specify how closely an element is to be observed. At least one of <code class="literal">attributes</code>, <code class="literal">childList</code>, or <code class="literal">characterData</code> must be set to true, or an error will be thrown:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">attributes</code>: Tells the observer whether mutations to the element's attributes should be observed or not</li><li class="listitem" style="list-style-type: disc"><code class="literal">childList</code>: Tells the observer whether the addition and removal of the element's child nodes should be observed or not</li><li class="listitem" style="list-style-type: disc"><code class="literal">characterData</code>: Tells the observer whether mutations to the element's data should be observed or not</li></ul></div><p>There are also four additional, but optional, <code class="literal">MutationObserverInit</code> properties that can be defined:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">subtree</code>: If true, tells the observer to watch for mutations to the element's descendants, in addition to the element itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">attributeOldValue</code>: If true in conjunction with attributes set to true, tells the observer to save the element attributes' old values before mutation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">characterDataOldValue</code>: If true in conjunction with <code class="literal">characterData</code> set to true, tells the observer to save the element's old data values before mutation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">attributeFilter</code>: An array specifying attribute names that should not be observed in conjunction with attributes set to true.</li></ul></div><p>With the configuration defined, an observer can now be called on a DOM element:</p><pre class="programlisting">var elem = document.querySelector('[data-bind="firstName"]'); &#13;
observer.observe(elem, config); &#13;
</pre><p>With this code in place, any mutations to the element with the attribute <code class="literal">data-bind="firstName"</code> will trigger the callback defined in the observer object's instantiation of the <code class="literal">MutationObserver</code> constructor, and it will log the mutation object passed to the iterator.</p><div class="section" title="Extending dataBind with MutationObserver"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec40"/>Extending dataBind with MutationObserver</h4></div></div></div><p>Now let's further extend our <code class="literal">dataBind</code> method with the <code class="literal">MutationObserver</code> constructor by using it to trigger callbacks when elements with the data-bind attribute are mutated:</p><pre class="programlisting">function dataBind(obj, prop) { &#13;
    var input = document.querySelector('[name="' + prop + '"]'); &#13;
    var observer = new MutationObserver(function(mutations) { &#13;
        mutations.forEach(function(mutation) { &#13;
            var val = mutation.target.innerHTML; &#13;
            if (obj[prop] !== val) { &#13;
                console.log( &#13;
                    'Inequality detected: "' +  &#13;
                    obj[prop] + '" !== "' + val + '"' &#13;
                ); &#13;
                obj[prop] = mutation.target.innerHTML; &#13;
            } &#13;
        }); &#13;
    }); &#13;
    var config = { &#13;
        attributes: true, &#13;
        childList: true, &#13;
        characterData: true &#13;
    }; &#13;
    var list = document.querySelectorAll( &#13;
        '[data-bind="' + prop + '"]' &#13;
    ), i; &#13;
    for (i = 0; i &lt; list.length; i++) { &#13;
        observer.observe(list[i], config); &#13;
    } &#13;
    input.value = obj[prop] || input.value; &#13;
    Object.defineProperty(obj, prop, { &#13;
        get: function() { &#13;
            return input.value; &#13;
        }, &#13;
        set: function(val) { &#13;
            var list = document.querySelectorAll( &#13;
                '[data-bind="' + prop + '"]' &#13;
            ), i; &#13;
            for (i = 0; i &lt; list.length; i++) { &#13;
                list[i].innerHTML = val; &#13;
            } &#13;
            input.value = val; &#13;
        }, &#13;
        configurable: true, &#13;
        enumerable: true &#13;
    }); &#13;
    obj[prop] = obj[prop]; &#13;
    input.oninput = function() { &#13;
        obj[prop] = obj[prop]; &#13;
    }; &#13;
} &#13;
</pre><p>The <code class="literal">MutationObserver</code> constructor takes a callback function as its only parameter. This callback is passed a mutations object, which can be iterated over to define callbacks for each mutation:</p><pre class="programlisting">var observer = new MutationObserver(function(mutations) { &#13;
    mutations.forEach(function(mutation) { &#13;
        var val = mutation.target.innerHTML; &#13;
        if (obj[prop] !== val) { &#13;
            console.log( &#13;
                'Inequality detected: "' +  &#13;
                obj[prop] + '" !== "' + val + '"' &#13;
            ); &#13;
            obj[prop] = mutation.target.innerHTML; &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
</pre><p>Note that in the <code class="literal">MutationObserver</code> instantiation callback, we perform an inequality comparison of the bound Model property to the <code class="literal">mutation.target.innerHTML</code>, which is the content of the DOM element being observed, before we set the Model property. This is important because it provides that we only set the bound Model property when there is a DOM mutation triggered directly on this particular DOM node, and not as a result of a setter. If we did not perform this check, all setters would trigger the callback, which calls the setter again, and infinite recursion would ensue. This is, of course, not desirable.</p><p>Using the new version of the <code class="literal">dataBind</code> method, test the HTML page in a browser again and update the input value:</p><pre class="programlisting">&lt;input type="text" name="firstName" value="Chappy"&gt; &#13;
 &#13;
console.log(user.firstName); // returns "Chappy" &#13;
</pre><p>Next, use the developer console to change the bound Model property and you will see it update in the DOM for both the input and the <code class="literal">&lt;strong data-bind="firstName"&gt;</code> element, as originally expected:</p><pre class="programlisting">user.firstName = 'Peebo'; &#13;
</pre><p>Finally, use the developer console to change the innerHTML of the <code class="literal">&lt;strong data-bind="firstName"&gt;</code> element and trigger a mutation event:</p><pre class="programlisting">document.querySelector('strong[data-bind="firstName"]') &#13;
    .innerHTML = 'Udis'; &#13;
</pre><p>This time, you will see the value of the input element update as well. This is because the mutation event was triggered and detected by the observer object, which then fired the callback function. Within that callback function, the <code class="literal">obj[prop] !== val</code> comparison was made and found to be true, so the setter was called on the new value, subsequently updating the input value and the value returned from the <code class="literal">user.firstName</code> property:</p><pre class="programlisting">console.log(user.firstName); // returns "Udis" &#13;
</pre><p>You have now implemented two-way data binding and comprehensive view synchronization using native <code class="literal">getters</code> and setters and the <code class="literal">MutationObserver</code> constructor. Keep in mind that the examples given here are experimental and have not been used in a real-world application. Care should be taken when employing these techniques in your own application, and testing should be paramount.</p></div></div></div></div>
<div class="section" title="Why use data binding?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Why use data binding?</h1></div></div></div><p>Data binding provides a layer of abstraction that can eliminate the need for a lot of additional application wiring, custom event publishing and subscribing, and Model evaluation against the View. These things are usually handled with custom application code that is specific to the application itself, when a framework or some type of data binding is not being used. Without careful planning and the use of defined architectural patterns, this can lead to a lot of adjunct code, and subsequently a code base that is not extensible, does not scale well, and is difficult for new developers to take on and learn.</p><p>If you feel that data binding is a component you'd like to include in your application, then consider your options, some of which we have laid out here, and choose accordingly. You may see the need to build your application with a full-fledged JavaScript framework such as AngularJS, or you may only want the added abstraction layer of data binding in combination with your own custom architecture. Also, consider the performance implications of your choices, and whether you need two-way data binding, which is more memory-intensive, or only one-way data binding, which will help to keep your application more performant.</p><div class="section" title="Use cases for one-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Use cases for one-way data binding</h2></div></div></div><p>The most common form of data binding in modern single page applications is one-way data binding. At its most basic, one-way data binding need only consist of binding dynamic Model values to their respective expressions in a template at render time. If the model changes after a template has already been rendered, the synchronization of that data to the View is an added benefit of some frameworks such as AngularJS, Ember.js, and Rivets.js.</p><p>If you are building an application in which you want to display real-time, frequently changing data to a user, and that data does not need to be manipulated by the user, this is a good use case for one-way data binding with View synchronization. A more specific example of this is an application for tracking stock quotes and displaying the prices as they change in real time. The Model data in this case is meant entirely for viewing by the user, but no changes to the Model from the View are necessary since the stock quotes cannot be changed by the user. In a scenario like this, two-way data binding listeners would not be useful and would only generate additional and unnecessary overhead.</p></div><div class="section" title="Use cases for two-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Use cases for two-way data binding</h2></div></div></div><p>Two-way data binding is not as commonly used as one-way data binding in single page applications, but it does have its place. It is important to fully understand the needs of your application before you decide to attach two-way data binding behaviors to the DOM and use additional memory.</p><p>A live chat, or live messaging, application is one of the most common examples of two-way data binding. Whether the application provides one-to-one messaging or multiuser messaging, two-way data binding can be used to synchronize the View in both directions for each user. As a user is viewing the application, new messages from other users are added to the Model and displayed in the View. Likewise, the user viewing the application enters new messages in the View and they are added to the Model, downloaded to the server, and then displayed to the other users in their own Views.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>You have now learned what data binding is, the differences between one-way and two-way data binding, how data binding is implemented in some modern JavaScript frameworks and libraries, and what some use cases for data binding are in the real world. You have also learned about the architectural differences between one-way and two-way data binding implementations, and how to write your own data binding implementation using modern native JavaScript with getters and setters. Additionally, you have learned about the <code class="literal">MutationObserver</code> constructor and how it can be used to trigger behaviors in the DOM based on mutation events.</p><p>Next, we will take everything that we have learned so far about different architectural components, including MongoDB, Express, AngularJS, and Node.js, and learn how to begin putting them all together to leverage the full MEAN stack.</p></div></body></html>