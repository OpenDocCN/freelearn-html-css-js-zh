["```js\n> yarn add utility-types\n```", "```js\n    import * from as fs from \"fs\"import * as path from \"path\";\n    import { ASB } from \"./globalObjects.ts\";\n    import allure from \"@wdio/allure-reporter\";\n    ```", "```js\n    export const clickElement = async (driver: WebDriver, element: WebDriver.Element) => {p  try {p\n        await driver.click(element)p\n      } catch (error) {p\n        throw new WebDriverError(`Unable to click element: ${error.message}`)p\n      }p\n    }\n    ```", "```js\n    import { clickAdv } from './helpers/helpers'pWe can then use the clickAdv function in our test code like this:\n    await clickAdv(driver, element)\n    ```", "```js\n p\n/**\n * Console.log wrapper\n *    - Does not print if string is empty / null\n *    - Prints trace if not passed string or number\n * @param message\n */\nexport async function log(message: any): Promise<void> {\n  try {\n    if (typeof message === \"string\" || typeof message === \"number\") {\n      if (message) {\n        console.log(`---> ${message}`);\n      }\n    } else {\n      console.log(`--->   helpers.console() received: ${message}`);\n      console.trace();\n    }\n  } catch (error: any) {\n    console.log(`--->   helpers.console(): ${error.message}`);\n  }\n}\n```", "```js\nimport * as helpers from '../../helpers/helpers.ts';\n```", "```js\nhelpers.log (`Hello, World!`)\n> [0-0] ---> Hello, World!\n```", "```js\nhelpers.log (``)\n```", "```js\nhelpers.log (Promise)\n> [0-0] --->   helpers.console() received: function Promise() { [native code] }\n> [0-0] Trace\n> [0-0]     at Module.log (file:///D:/repos/Test-Automation-with-WebdriverIO/helpers/helpers.ts:14:15)\n> [0-0]     at UserContext.<anonymous> (file:///D:/repos/Test-Automation-with-WebdriverIO/test/specs/example.e2e.ts:10:17)\n```", "```js\nawait this.inputUsername.setValue(username);\nawait this.inputPassword.setValue(password);\nawait this.btnSubmit.click();\n```", "```js\n<button class=\"radius\" type=\"submit\" fdprocessedid=\"ra4xrd\">p\n    <i class=\"fa fa-2x fa-sign-in\"> Login</i>p\n</button>\n```", "```js\n<a class=\"radius\" type=\"submit\" fdprocessedid=\"ra4xrd\">p\n    <i class=\"fa fa-2x fa-sign-in\"> Login</i>p\n</a>p\n```", "```js\n[0-0] Error: Can't call click on element with selector \"button[type=\"submit\"]\" because element wasn't found\n```", "```js\n    try{\n        await this.btnSubmit.click();\n        helpers.log(` Clicked button`);\n    } catch (err)\n        helpers.log(`    Click failed because\\n${err)`);\n  }\n```", "```js\nbtnLogin.click() // Customized with overWriteCommand\n```", "```js\nbtnLogin.clickAdv()\n```", "```js\nclickAdv(btnLogin)\n```", "```js\nbrowser.overwriteCommand('click', async(origClick, element)= {\n    let success = true;\n    try{ p           element = await getValidElement(element, \"button\");\n       await element.click(); // Instrinsic click\n       console.log(' Clicked ${element.selector}');\n    } catch (err)\n        success = false;\n        console.log(`$   {element.selector}click failed\\n ${err)`);\n  }\n    return success;\n})\n```", "```js\nawait this.btnBogus.click();\n```", "```js\nawait this.btnSubmit.click();\n```", "```js\n[0-0] ---> Clicking button[type=\"submit\"] ...\n[0-0] --->   button clicked.\n```", "```js\nbrowser.addCommand(\"clickAdv\", async function (){\n…\n}, true);\n```", "```js\nawait this.btnSubmit.clickAdv();\n```", "```js\n[0-0] ---> Clicking button[type=\"submit\"]\n[0-0] --->   button clicked.;\n```", "```js\nawait this.btnAddToCart.clickAdv();\n```", "```js\nawait this.btnAddToCart.click();\n```", "```js\n    public get btnBogus () {\n        return $('button[type=\"bogus\"]');\n    }\n```", "```js\n        await this.btnBogus.clickAdv();\n```", "```js\nError: Can't call clickAdv on element with selector \"button[type=\"bogus\"]\" because element wasn't found\n```", "```js\nawait helpers.clickAdv(this.btnSubmit);\nawait helpers.clickAdv(this.btnBogus);\n```", "```js\n[0-0] ---> Clicking button[type=\"submit\"] ...\n[0-0] --->   button clicked.\n[0-0] --->   pageSync() completed in 25 ms\n[0-0] ---> Clicking button[type=\"bogus\"] ...\n[0-0] --->   button[type=\"submit\"] was not clicked.\n[0-0] Error: Can't call click on element with selector \"button[type=\"bogus\"]\" because element wasn't found\n```", "```js\n// Default timeout for all waitFor* commands.\nwaitforTimeout: 10_000,\n```", "```js\n/**\n * Wrapper for browser.pause\n * @param ms reports if wait is more than 1/2 second\n */\nexport async function pause(ms: number) {\n  if (ms > 500){\n  log(`  Waiting ${ms} ms...`); // Custom log\n  }\n  const start = Date.now();\n  let now = start;\n  while (now - start < ms) {\n    now = Date.now();\n  }\n}\n```", "```js\nexport async function highlightOn(\n  element: WebdriverIO.Element,\n  color: string = \"green\"\n): Promise<boolean> {\n  let elementSelector:any\n  let visible: boolean = true;\n  try {\n      elementSelector = await element.selector;\n      try {\n        await browser.execute(`arguments[0].style.border = '5px solid ${color}';`, element);\n        visible = await isElementVisible(element)\n      } catch (error: any) {\n        // Handle stale element\n        const newElement = await browser.$(elementSelector)\n        ASB.set(\"element\", newElement)\n        ASB.set(\"staleElement\", true)\n        await browser.execute(`arguments[0].style.border = '5px solid ${color}';`, newElement);\n        //log (`  highlightOn ${elementSelector} refresh success`)\n      }\n  } catch (error) {\n    // Element no longer exists\n    visible = false\n  }\n  return visible;\n}\n```", "```js\nexport async function highlightOff(element: WebdriverIO.Element): Promise<boolean> {\n  let visible: boolean = true;\n  try {\n      await browser.execute(`arguments[0].style.border = \"0px\";`, element);\n  } catch (error) {\n      // Element no longer exists\n      visible = false;\n  }\n  return visible;\n}\n```", "```js\nexport async function waitForSpinner(): Promise<boolean> {\n  let spinnerDetected: boolean = false;\n  // This spinner locator is unique to each project\n  const spinnerLocator: string = `//img[contains(@src,'loader')]`;\n  await pause(100); // Let browser begin building spinner on page\n  let spinner = await browser.$(spinnerLocator);\n  let found = await highlightOn(spinner);\n  let timeout = ASB.get(\"spinnerTimeoutInSeconds\")\n  const start = Date.now();\n  if (found) {\n    const startTime = performance.now();\n    spinnerDetected = true;\n    try {\n      while (found) {\n        found = await highlightOn(spinner);\n        if (!found) break;\n        await pause(100);\n        found = await highlightOff(spinner);\n        if (!found) break;\n        await pause(100);\n        if  (Date.now() - start > timeout * 1000) {\n          log (`ERROR: Spinner did not close after ${timeout}           seconds`)\n          break;\n        }\n      }\n    } catch (error) {\n      // Spinner no longer exists\n    }\n    log(`  Spinner Elapsed time: ${Math.floor(performance.now() -     startTime)} ms`);\n  }\n  return spinnerDetected;\n}\n```", "```js\n/**\n * pageSync - Dynamic wait for the page to stabilize.\n * Use after click\n * ms = default time wait between loops 125 = 1/8 sec\n *      Minimum 25 for speed / stability balance\n */\nlet LAST_URL: String = \"\";\nexport async function pageSync(\n  ms: number = 25,\n  waitOnSamePage: boolean = false\n): Promise<boolean> {\n  await waitForSpinner();\n```", "```js\nlet result = false;\n  let skipToEnd = false;\n  let thisUrl = await browser.getUrl();\n  if (waitOnSamePage === false) {\n    if (thisUrl === LAST_URL) {\n      //skip rest of function\n      result = true;\n      skipToEnd = true;\n    }\n  }\n```", "```js\n  if (skipToEnd === false) {\n    LAST_URL = thisUrl;\n    const waitforTimeout = browser.options.waitforTimeout;\n    let visibleSpans: String = `span:not([style*=\"visibility: hidden\"])`;\n    let elements: any = await $$(visibleSpans);\n    let exit: boolean = false;\n    let count: number = elements.length;\n    let lastCount: number = 0;\n    let retries: number = 3;\n    let retry: number = retries;\n    let timeout: number = 20; // 5 second timeout\n    const startTime: number = Date.now();\n    while (retry > 0) {\n      if ((lastCount != count) || (count < 20)) {\n        retry = retries; // Reset the count of attempts\n      }\n      // Exit after 3 stable element counts\n      if (retry == 0) {\n        break;\n      }\n      if (timeout-- === 0) {\n        log(\"Page never settled\");\n        exit = true;\n        break;\n      }\n      lastCount = count;\n```", "```js\n      // wait 1/4 sec before next count check\n      await pause(ms);\n      try {\n        elements = await $$(visibleSpans);\n      } catch (error: any) {\n        exit = true;\n        switch (error.name) {\n          case \"TimeoutError\":\n            log(`ERROR: Timed out while trying to find visible             spans.`);\n            break;\n          case \"NoSuchElementError\":\n            log(`ERROR: Could not find any visible spans.`);\n            break;\n          default:\n            if (error.message === `Couldn't find page handle`) {\n              log(`WARN: Browser closed. (Possibly missing await)`);\n            }\n        }\n        // Error thrown: Exit loop\n        break;\n      }\n      count = await elements.length;\n      retry--;\n    }\n```", "```js\n    // Metric: Report if the page took more than 3 seconds to build\n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    if (duration > waitforTimeout) {\n      log(`  WARN: pageSync() completed in ${duration / 1000}       sec  (${duration} ms) `);\n    }\n  }\n  return result;\n}\n```", "```js\nexport async function isElementInViewport(element: WebdriverIO.Element): Promise<boolean> {\n  let isInViewport = await element.isDisplayedInViewport();\n  return isInViewport;\n}\n```", "```js\nexport async function waitForElementToStopMoving(element: WebdriverIO.Element, timeout: number = 1500): Promise<boolean> {\n  let rect = await element.getRect();\n  pause (100);\n  let isMoving = (rect !== await element.getRect())\n  let startTime = Date.now();\n  // Keep checking the element's position until it stops moving or the timeout is reached\n  while (isMoving) {\n    // If the element's position hasn't changed, it is not moving\n    if (rect === await element.getRect()) {\n      // Element is static\n      isMoving = false;\n    }else{\n      // Element is moving...\n      pause (100)\n    }\n    // If the timeout has been reached, stop the loop\n    if (Date.now() - startTime > timeout) {\n      break;\n    }\n    // Wait for a short amount of time before checking the element's position again\n    await pause(100);\n  }\n  return !isMoving;\n}\n```", "```js\nexport async function clickAdv(\n  element: ChainablePromiseElement<WebdriverIO.Element>) {\n  let success: boolean = false;\n  const SELECTOR = await element.selector;\n  log(`Clicking ${SELECTOR}`);\n  try {\n    //await element.waitForDisplayed();\n    if (!await isElementInViewport(element)){\n      await element.scrollIntoView({ block: \"center\", inline: \"center\" });\n      await waitForElementToStopMoving(element)\n    }\n    await highlightOn(element);\n    await element.click({ block: \"center\" });\n    await pageSync();\n    success = true;\n  } catch (error: any) {\n    log(`  ERROR: ${SELECTOR} was not clicked.\\n           ${error.message}`);\n    expect(`to be clickable`).toEqual(SELECTOR);\n    // Throw the error to stop the test\n    await element.click({ block: \"center\" });\n  }\n  return success;\n}\n```", "```js\n[0-0] ---> Clicking button[type=\"bogus\"]\n[0-0] --->   ERROR: button[type=\"bogus\"] was not clicked. [0-0] Error: element (\"button[type=\"bogus\"]\") still not displayed after 30000ms\n```", "```js\nwaitforTimeout: 3000,\n```", "```js\npublic get btnBogus() {\n  return $('//button[type=\"bogus\"]');\n}\nawait helpers.clickAdv(this.btnBogus);\n```", "```js\n  public get lnkSubmit() {\n    return $('//a[text()=\"submit\"]');\n  }\n```", "```js\n    // Class switching\n    await helpers.clickAdv(this.lnkSubmit);\n```", "```js\n  element = await getValidElement(element);\n  const SELECTOR = await element.selector;\n  await log(`Clicking ${SELECTOR}`);\n```", "```js\nexport async function getValidElement(\n  element: WebdriverIO.Element\n): Promise<WebdriverIO.Element> {\n  let selector: any = await element.selector;\n  // Get a collection of matching elements\n  let found: boolean = true;\n  let newSelector: string = \"\"\n  let newElement: any = element;\n  let elements: WebdriverIO.Element[];\n  let elementType:string = \"\"\n  let elementText:string = \"\"\n  try {\n    elements = await $$(selector);\n    if (elements.length === 0) {\n      let index: number = selector.indexOf(\"[\");\n      elementType = selector.substring(0, index);\n```", "```js\n      switch (elementType) {\n        case \"//a\":\n          elementText = selector.match(/=\".*\"/)[0].slice(2, -1);\n          newSelector = `//button[contains(@type,'${elementText}')]`\n          break;\n        case \"//button\":\n          elementText = selector.match(/=\".*\"/)[0].slice(2, -1);\n          newSelector =`//a[contains(text(),'${elementText}'])`\n          break;\n```", "```js\n        default:\n          found = false;\n          newElement = element;\n          break;\n      }\n      newElement = await $(newSelector);\n      found = await isElementVisible (newElement)\n    }\n  } catch (error) {\n    found = false;\n  }\n  // Successful class switch\n  if (found) {\n    await log(\n      `  WARNING: Replaced ${selector}\\n with ${newSelector}`\n    );\n  } else {\n    await log(`  ERROR: Unable to find ${selector}`);\n  }\n  return newElement;\n}\n```", "```js\n   ASB.set(`alreadyFailed`, !found)\n   if (ASB.get(`alreadyFailed`) === true)) {\n      allure.addStep(`Click '${selector}'`, undefined, 'skipped');\n      ASB.set(`skipped`, ASB.get(`skipped`)++)\n      return;\n    }\n```"]