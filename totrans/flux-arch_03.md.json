["```js\n// Import the dispatcher, so that the store can\n// listen to dispatch events.\nimport dispatcher from '../dispatcher';\n\n// Our \"Home\" store.\nclass HomeStore {\n  constructor() {\n\n    // Sets a default state for the store. This is\n    // never a bad idea, in case other stores want to\n    // iterate over array values - this will break if\n    // they're undefined.\n    this.state = {\n      user: '',\n      events: [],\n      navigation: []\n    };\n\n    // When a \"HOME_LOAD\" event is dispatched, we\n    // can assign \"payload\" to \"state\".\n    dispatcher.register((e) => {\n      switch (e.type) {\n        case 'HOME_LOAD':\n          Object.assign(this.state, e.payload);\n          break;\n      }\n    });\n  }\n}\n\nexport default new HomeStore();\n```", "```js\n// Imports the \"dispatcher\", and the \"homeStore\".\nimport dispatcher from './dispatcher';\nimport homeStore from './stores/home';\n\n// Logs the default state of the store, before\n// any actions are triggered against it.\nconsole.log(`user: \"${homeStore.state.user}\"`);\n// → user: \"\"\n\nconsole.log('events:', homeStore.state.events);\n// → events: []\n\nconsole.log('navigation:', homeStore.state.navigation);\n// → navigation: []\n\n// Dispatches a \"HOME_LOAD\" event, when populates the\n// \"homeStore\" with data in the \"payload\" of the event.\ndispatcher.dispatch({\n  type: 'HOME_LOAD',\n  payload: {\n    user: 'Flux',\n    events: [\n      'Completed chapter 1',\n      'Completed chapter 2'\n    ],\n    navigation: [\n      'Home',\n      'Settings',\n      'Logout'\n    ]\n  }\n});\n\n// Logs the new state of \"homeStore\", after it's\n// been populated with data.\nconsole.log(`user: \"${homeStore.state.user}\"`);\n// → user: \"Flux\"\n\nconsole.log('events:', homeStore.state.events);\n// → events: [\"Completed chapter 1\", \"Completed chapter 2\"]\n\nconsole.log('navigation:', homeStore.state.navigation);\n// → navigation: [\"Home\", \"Settings\", \"Logout\"]\n```", "```js\n// We need the \"dispatcher\" to register our store,\n// and the \"EventEmitter\" class so that our store\n// can emit \"change\" events when the state of the\n// store changes.\nimport dispatcher from '../dispatcher';\nimport { EventEmitter } from 'events';\n\n// Our \"Home\" store which is an \"EventEmitter\"\nclass HomeStore extends EventEmitter {\n  constructor() {\n\n    // We always need to call this when extending a class.\n    super();\n\n    // Sets a default state for the store. This is\n    // never a bad idea, in case other stores want to\n    // iterate over array values - this will break if\n    // they're undefined.\n    this.state = {\n      user: '',\n      events: [],\n      navigation: []\n    };\n\n    // When a \"HOME_LOAD\" event is dispatched, we\n    // can assign \"payload\" to \"state\", then we can\n    // emit a \"change\" event.\n    dispatcher.register((e) => {\n      switch (e.type) {\n        case 'HOME_LOAD':\n          Object.assign(this.state, e.payload);\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new HomeStore();\n```", "```js\n// Imports the \"dispatcher\", and the \"homeStore\".\nimport dispatcher from './dispatcher';\nimport homeStore from './stores/home';\n\n// Logs the default state of the store, before\n// any actions are triggered against it.\nconsole.log(`user: \"${homeStore.state.user}\"`);\n// → user: \"\"\n\nconsole.log('events:', homeStore.state.events);\n// → events: []\n\nconsole.log('navigation:', homeStore.state.navigation);\n// → navigation: []\n\n// The \"change\" event is emitted whenever the state of The\n// store changes.\nhomeStore.on('change', (state) => {\n  console.log(`user: \"${state.user}\"`);\n  // → user: \"Flux\"\n\n  console.log('events:', state.events);\n  // → events: [\"Completed chapter 1\", \"Completed chapter 2\"]\n\n  console.log('navigation:', state.navigation);\n  // → navigation: [\"Home\", \"Settings\", \"Logout\"]\n});\n\n// Dispatches a \"HOME_LOAD\" event, when populates the\n// \"homeStore\" with data in the \"payload\" of the event.\ndispatcher.dispatch({\n  type: 'HOME_LOAD',\n  payload: {\n    user: 'Flux',\n    events: [\n      'Completed chapter 1',\n      'Completed chapter 2'\n    ],\n    navigation: [\n      'Home',\n      'Settings',\n      'Logout'\n    ]\n  }\n});\n```", "```js\nimport dispatcher from '../dispatcher';\nimport { EventEmitter } from 'events';\n\n// Our \"User\" store which is an \"EventEmitter\"\nclass UserStore extends EventEmitter {\n  constructor() {\n    super();\n    this.state = {\n      first: '',\n      last: ''\n    };\n\n    dispatcher.register((e) => {\n      switch (e.type) {\n        // When the \"USER_LOAD\" action is dispatched, we\n        // can assign the payload to this store's state.\n        case 'USER_LOAD':\n          Object.assign(this.state, e.payload);\n          this.emit('change', this.state);\n          break;\n\n        // When the \"USER_REMOVE\" action is dispatched,\n        // we need to check if this is the user that was\n        // removed. If so, then reset the state.\n        case 'USER_REMOVE':\n          if (this.state.id === e.payload) {\n            Object.assign(this.state, {\n              id: null,\n              first: '',\n              last: ''\n            });\n\n            this.emit('change', this.state);\n          }\n\n          break;\n      }\n    });\n  }\n}\n\nexport default new UserStore();\n```", "```js\nimport dispatcher from '../dispatcher';\nimport { EventEmitter } from 'events';\n\n// Our \"UserList\" store which is an \"EventEmitter\"\nclass UserListStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // There's no users in this list by default.\n    this.state = []\n\n    dispatcher.register((e) => {\n      switch (e.type) {\n\n        // The \"USER_ADD\" action adds the \"payload\" to\n        // the array state.\n        case 'USER_ADD':\n          this.state.push(e.payload);\n          this.emit('change', this.state);\n          break;\n\n        // The \"USER_REMOVE\" action has a user id as\n        // the \"payload\" - this is used to locate the\n        // user in the array and remove it.\n        case 'USER_REMOVE':\n          let user = this.state.find(\n            x => x.id === e.payload);\n\n          if (user) {\n            this.state.splice(this.state.indexOf(user), 1);\n            this.emit('change', this.state);\n          }\n\n          break;\n      }\n    });\n  }\n}\n\nexport default new UserListStore();\n```", "```js\nimport dispatcher from './dispatcher';\nimport userStore from './stores/user';\nimport userListStore from './stores/user-list';\n\n// Intended to simulate a back-end API that changes \n// state of something. In this case, it's creating\n// a new resource. The returned promise will resolve\n// with the new resource data.\nfunction createUser() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({\n        id: 1,\n        first: 'New',\n        last: 'User'\n      });\n    }, 500);\n  });\n}\n\n// Show the user when the \"userStore\" changes.\nuserStore.on('change', (state) => {\n  console.log('changed', `\"${state.first} ${state.last}\"`);\n});\n\n// Show how many users there are when the \"userListStore\"\n// changes.\nuserListStore.on('change', (state) => {\n  console.log('users', state.length);\n});\n\n// Creates the back-end resource, then dispatches actions\n// once the promise has resolved.\ncreateUser().then((user) => {\n\n  // The user has loaded, the \"payload\" is the resolved data.\n  dispatcher.dispatch({\n    type: 'USER_LOAD',\n    payload: user\n  });\n  // Adds a user to the \"userListStore\", using the resolved\n  // data.\n  dispatcher.dispatch({\n    type: 'USER_ADD',\n    payload: user\n  });\n\n  // We can also remove the user. This impacts both stores.\n  dispatcher.dispatch({\n    type: 'USER_REMOVE',\n    payload: 1\n  });\n});\n```", "```js\nimport dispatcher from '../dispatcher';\nimport { EventEmitter } from 'events';\n\n// Our \"Panel\" store which is an \"EventEmitter\"\nclass PanelStore extends EventEmitter {\n  constructor() {\n\n    // We always need to call this when extending a class.\n    super();\n\n    // The initial state of the store.\n    this.state = {\n      visible: true,\n      items: [\n        { name: 'First', selected: false },\n        { name: 'Second', selected: false }\n      ]\n    };\n\n    dispatcher.register((e) => {\n      switch (e.type) {\n\n        // Toggles the visibility of the panel, which is\n        // visible by default.\n        case 'PANEL_TOGGLE':\n          this.state.visible = !this.state.visible;\n          this.emit('change', this.state);\n          break;\n\n        // Selects an object from \"items\", but only\n        // if the panel is visible.\n        case 'ITEM_SELECT':\n          let item = this.state.items[e.payload];\n\n          if (this.state.visible && item) {\n            item.selected = true;\n            this.emit('change', this.state);\n          }\n\n          break;\n      }\n    });\n  }\n}\n\nexport default new PanelStore();\n```", "```js\nimport dispatcher from './dispatcher';\nimport panelStore from './stores/panel';\n\n// Logs the state of the \"panelStore\" when it changes.\npanelStore.on('change', (state) => {\n  console.log('visible', state.visible);\n  console.log('selected', state.items.filter(\n    x => x.selected));\n});\n\n// This will select the first item.\ndispatcher.dispatch({\n  type: 'ITEM_SELECT',\n  payload: 0\n});\n// → visible true\n// → selected [ { name: First, selected: true } ]\n\n// This disables the panel by toggling the \"visible\"\n// property value.\ndispatcher.dispatch({ type: 'PANEL_TOGGLE' });\n// → visible false\n// → selected [ { name: First, selected: true } ]\n\n// Nothing the second item isn't actually selected,\n// because the panel is disabled. No \"change\" event\n// is emitted here either, because the \"visible\"\n// property is false.\ndispatcher.dispatch({\n  type: 'ITEM_SELECT',\n  payload: 1\n});\n```", "```js\nimport dispatcher from '../dispatcher';\nimport { EventEmitter } from 'events';\n\nclass PlayerStore extends EventEmitter {\n  constructor() {\n    super();\n\n    // The property keys in the default state are\n    // used to determine the allowable properties\n    // used to set the state.\n    this.state = {\n      id: null,\n      name: ''\n    };\n\n    dispatcher.register((e) => {\n      switch (e.type) {\n        case 'PLAYER_LOAD':\n\n          // Make sure that we only take payload data\n          // that's already a state property.\n          for (let key in this.state) {\n            this.state[key] = e.payload[key];\n          }\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new PlayerStore();\n```", "```js\nimport dispatcher from './dispatcher';\nimport playerStore from './stores/player';\n\n// Logs the state of the player store when it changes.\nplayerStore.on('change', (state) => {\n  console.log('state', state);\n});\n\n// Dispatch a \"PLAYER_LOAD\" action with more payload\n// data than is actually used by the store.\ndispatcher.dispatch({\n  type: 'PLAYER_LOAD',\n  payload: {\n    id: 1,\n    name: 'Mario',\n    score: 527,\n    rank: 12\n  }\n});\n// → state {id: 1, name: \"Mario\"}\n```", "```js\noutput: {\n  …\n  library: 'views'\n}\n```", "```js\nimport settingsView from './views/settings';\nexport { settingsView as settings };\n```", "```js\nimport dispatcher from '../dispatcher';\nimport settingsStore from '../stores/settings';\n\n// This is a \"bare bones\" view because it's\n// not rendering anything to the DOM. We're just\n// using it to validate our Flux data-flows and\n// to think about potential actions dispatched\n// from this view.\nclass SettingsView {\n  constructor() {\n\n    // Logs the state of \"settingsStore\" when it\n    // changes.\n    settingsStore.on('change', (state) => {\n      console.log('settings', state);\n    });\n\n    // The initial state of the store is logged.\n    console.log('settings', settingsStore.state);\n  }\n\n  // This sets an email value by dispatching\n  // a \"SET_EMAIL\" action.\n  setEmail(email) {\n    dispatcher.dispatch({\n      type: 'SET_EMAIL',\n      payload: 'foo@bar.com'\n    });\n  }\n\n  // Do all the things!\n  doTheThings() {\n    dispatcher.dispatch({\n      type: 'DO_THE_THINGS',\n      payload: true\n    })\n  }\n}\n\n// We don't need more than one of these\n// views, so export a new instance.\nexport default new SettingsView();\n```", "```js\nviews.settings.setEmail()\n// → settings {email: \"foo@bar.com\", allTheThings: false}\n\nviews.settings.doTheThings()\n// → settings {email: \"foo@bar.com\", allTheThings: true}\n```"]