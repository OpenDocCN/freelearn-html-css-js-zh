<html><head></head><body>
<div id="_idContainer059">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.2.1">Building a Framework by Example</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter combines all the insight and architectural knowledge from </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Parts 1</span></em><span class="koboSpan" id="kobo.5.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.6.1">2</span></em><span class="koboSpan" id="kobo.7.1"> of the book and puts it into practice. </span><span class="koboSpan" id="kobo.7.2">Follow along as we develop a simple JavaScript testing framework based on the patterns and best techniques we have seen so far. </span><span class="koboSpan" id="kobo.7.3">The practical approach will enable us to learn by example, as it is a great educational approach for software topics of this kind. </span><span class="koboSpan" id="kobo.7.4">The framework we build here is a new project developed specifically for this chapter. </span><span class="koboSpan" id="kobo.7.5">We can treat this new sample framework project as a “Hello World” exercise for JavaScript framework development. </span><span class="koboSpan" id="kobo.7.6">Our aim through this exercise is to train our abilities and apply them later on in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">real-world projects.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This chapter will cover the following topics for building a framework </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">by example:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">First, we’ll structure our initial approach for a new framework project, including determining the goals, stakeholders, and branding for creating something from scratch. </span><span class="koboSpan" id="kobo.11.2">This will largely involve putting the learnings of project considerations from </span><a href="B19014_05.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 5</span></em></span></a> <span class="No-Break"><span class="koboSpan" id="kobo.13.1">into practice.</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Next, we’ll learn to outline a typical initial architecture design to get our implementation of a testing framework off the ground. </span><span class="koboSpan" id="kobo.14.2">This includes outlining how the components fit together and the unique features of the project and its interfaces. </span><span class="koboSpan" id="kobo.14.3">In addition, we’ll summarize the public interfaces that are expected by developers who will be utilizing </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">our project.</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Finally, we’ll walk through the implementation of our testing framework based on the created design, including core feature components, command-line implementation, browser testing integration, </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">and more.</span></span></li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">The implemented framework code is in the book repository at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.21.1">. </span><span class="koboSpan" id="kobo.21.2">The code for our sample framework is included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">chapter6</span></strong><span class="koboSpan" id="kobo.23.1"> directory. </span><span class="koboSpan" id="kobo.23.2">To follow the implementation explanation in this chapter, it is recommended to follow along with the framework files in the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">chapter directory.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">To run the code, make sure to have </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Node.js v20 or higher</span></em><span class="koboSpan" id="kobo.27.1"> installed (you can download it from </span><a href="http://nodejs.org"><span class="koboSpan" id="kobo.28.1">nodejs.org</span></a><span class="koboSpan" id="kobo.29.1">). </span><span class="koboSpan" id="kobo.29.2">To make it easier to manage different versions of Node.js, you can use a Node.js version manager tool such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">nvm</span></strong><span class="koboSpan" id="kobo.31.1"> (</span><a href="http://github.com/nvm-sh/nvm"><span class="koboSpan" id="kobo.32.1">github.com/nvm-sh/nvm</span></a><span class="koboSpan" id="kobo.33.1">). </span><span class="koboSpan" id="kobo.33.2">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">nvm</span></strong><span class="koboSpan" id="kobo.35.1"> will automatically install the appropriate version of Node.js from the framework project directory, as the project is configured and tested for a particular version. </span><span class="koboSpan" id="kobo.35.2">Make sure to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">npm install</span></strong><span class="koboSpan" id="kobo.37.1"> to fetch the project’s dependencies. </span><span class="koboSpan" id="kobo.37.2">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">npm test</span></strong><span class="koboSpan" id="kobo.39.1"> should output a set of passing tests. </span><span class="koboSpan" id="kobo.39.2">This means that your local configuration is all correctly set up. </span><span class="koboSpan" id="kobo.39.3">The interactive script will perform all these steps for you if you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">npm start</span></strong><span class="koboSpan" id="kobo.41.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">chapter6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">To test the frontend portion of this sample framework, please use the latest version of Chromium-based browsers or an updated version of Firefox. </span><span class="koboSpan" id="kobo.44.2">To debug the framework, refer to the </span><em class="italic"><span class="koboSpan" id="kobo.45.1">About debugging</span></em><span class="koboSpan" id="kobo.46.1"> section of </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">You can use the approach as documented in </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">that chapter.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.50.1">Determining goals and stakeholders and framework branding</span></h1>
<p><span class="koboSpan" id="kobo.51.1">The subject of our framework practical exercise is a new JavaScript code </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">testing framework.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.53.1">Goals</span></h2>
<p><span class="koboSpan" id="kobo.54.1">The goal we will</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.55.1"> try to achieve is to provide robust test tooling for projects of variable complexity. </span><span class="koboSpan" id="kobo.55.2">The primary objective of testing frameworks is to provide developers with a reliable, fast, and versatile platform for verifying their code’s functionality, performance, and stability. </span><span class="koboSpan" id="kobo.55.3">In addition, they aim to minimize the risk of potential errors and create a seamless development experience that ultimately results in a </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">high-quality product.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">To accomplish these project goals, our JavaScript framework will focus on executing tests quickly and accurately, supporting various reporter output formats, and fostering a developer-friendly environment. </span><span class="koboSpan" id="kobo.57.2">By prioritizing ease of use and integration with other JavaScript tools and application frameworks, we will aim to make the testing process as seamless and efficient as possible. </span><span class="koboSpan" id="kobo.57.3">The framework will also enable cross-platform testing across Node.js and real web browser environments, ensuring that code performs consistently and as expected in </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">various contexts.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">A side condition of this particular project is to create a sandbox-like environment for you, the reader, by providing an extensible and more straightforward project that you can learn from. </span><span class="koboSpan" id="kobo.59.2">You are </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.60.1">encouraged to run the code and play the role of a potential </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">framework contributor.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.62.1">Stakeholders</span></h2>
<p><span class="koboSpan" id="kobo.63.1">The stakeholders of a </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.64.1">new JavaScript code testing framework could include a variety of software engineers and web developers who have specific software testing needs. </span><span class="koboSpan" id="kobo.64.2">First and foremost, JavaScript developers can utilize this framework in their user-facing projects and include it in the development of other JavaScript software. </span><span class="koboSpan" id="kobo.64.3">This framework can be a full stack solution for testing code in multiple environments. </span><span class="koboSpan" id="kobo.64.4">In the developer community, we are trying to develop a framework that is suitable for frontend, backend, full stack developers, QA and DevOps engineers, and finally, other </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">framework/library authors.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Our stakeholders can benefit from the architectural features of this project. </span><span class="koboSpan" id="kobo.66.2">For example, if we are testing the code in a real browser environment, the developed framework could be a good selling point for frontend engineers. </span><span class="koboSpan" id="kobo.66.3">The choice of the JavaScript testing feature set that we enable by building this project might also create friction or incompatibility with some engineering workflows, such as running tests in older runtimes and browsers. </span><span class="koboSpan" id="kobo.66.4">Thus, mainly, we are targeting a subset of developers that can live on the bleeding edge of new features and easily keep their code base up to date with the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">latest environments.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">If we were developing a JavaScript code testing framework internally, our stakeholders would be the internal developers of a start-up or a bigger company. </span><span class="koboSpan" id="kobo.68.2">In this case, we could gather insights about which feature sets were most needed in the internal teams. </span><span class="koboSpan" id="kobo.68.3">In addition, particular features could be developed to target specific organizational needs. </span><span class="koboSpan" id="kobo.68.4">The iteration and stability of the project would depend on how it was used internally </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Both stakeholders and framework developers benefit from consistent project communication and identity. </span><span class="koboSpan" id="kobo.70.2">This is where our new framework can benefit a bit from adding some branding. </span><span class="koboSpan" id="kobo.70.3">More on that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">next section.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.72.1">Framework branding</span></h2>
<p><span class="koboSpan" id="kobo.73.1">Before diving into </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.74.1">architecture and coding, spending some time on the branding and identity of our project can be beneficial for the sake of the project structure. </span><span class="koboSpan" id="kobo.74.2">Creating an identity around the framework is a common pattern in internal and public projects, as it clearly defines the project’s logical boundaries and provides context around the project in general. </span><span class="koboSpan" id="kobo.74.3">Creating an identity could be as simple as picking a temporary name for your new project. </span><span class="koboSpan" id="kobo.74.4">It can also be a more involved creative process as we establish a project name. </span><span class="koboSpan" id="kobo.74.5">The name will be useful for creating a </span><em class="italic"><span class="koboSpan" id="kobo.75.1">namespace</span></em><span class="koboSpan" id="kobo.76.1"> for our project and utilized internally by the code base and by tests/dependent projects as they load this new project. </span><span class="koboSpan" id="kobo.76.2">The name can, of course, be changed later with some </span><em class="italic"><span class="koboSpan" id="kobo.77.1">find and replace</span></em><span class="koboSpan" id="kobo.78.1">, so the decision does not have to </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">be final.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">We will use a new framework name for our new project and repurpose it for subsequent project advancements in </span><em class="italic"><span class="koboSpan" id="kobo.81.1">Chapters 7</span></em><span class="koboSpan" id="kobo.82.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.83.1">8</span></em><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">We </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.85.1">define </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">Componium</span></strong><span class="koboSpan" id="kobo.87.1"> as the overarching brand for the frameworks we develop in this book. </span><span class="koboSpan" id="kobo.87.2">The name is a play on the word </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Component</span></em><span class="koboSpan" id="kobo.89.1">, combined with a </span><em class="italic"><span class="koboSpan" id="kobo.90.1">-nium</span></em><span class="koboSpan" id="kobo.91.1"> ending, which gives this name a technological and software sound. </span><span class="koboSpan" id="kobo.91.2">Besides, the name is not fully unique, as a musical instrument from 1821 shares the name with our framework: </span><a href="http://mim.be/en/collection-piece/componium"><span class="koboSpan" id="kobo.92.1">mim.be/en/collection-piece/componium</span></a><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">More</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.94.1"> importantly, it is not a problem for us because there are no conflicts for this name in the JavaScript ecosystem. </span><span class="koboSpan" id="kobo.94.2">Choosing a namespace has to come with some uniqueness, avoiding naming conflicts with existing </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">developer tools.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Continuing the creative process, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.97.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.98.1">.1</span></em><span class="koboSpan" id="kobo.99.1">, you can see our framework’s logo and color scheme, which can be used in documentation and presented in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">visual features:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 6.1: New framework name and logo" src="image/Figure_6.1_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 6.1: New framework name and logo</span></p>
<p><span class="koboSpan" id="kobo.103.1">The testing framework will be specifically known as </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Componium Test</span></em><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">The addition of identity assets is beneficial to make the project more identifiable and establish a stronger brand presence in the developer community, fostering trust </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">and recognition.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">On the more technical side of things, creating a namespace for your project, as we did here with </span><em class="italic"><span class="koboSpan" id="kobo.108.1">componium</span></em><span class="koboSpan" id="kobo.109.1">, can help on several occasions. </span><span class="koboSpan" id="kobo.109.2">Namespacing eliminates potential naming conflicts and collisions with other frameworks and helps us logically group the code base with its components for both internal and external developers. </span><span class="koboSpan" id="kobo.109.3">Depending on the type of framework project, creating a namespace can also make the code base approach more modular. </span><span class="koboSpan" id="kobo.109.4">We saw an example of this in </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.111.1">, where Vue.js had the approach to namespace many of its packages in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">vue-*</span></strong><span class="koboSpan" id="kobo.113.1"> namespace. </span><span class="koboSpan" id="kobo.113.2">In addition, namespacing can help facilitate framework customizations and extensions, such as other developers contributing plugins </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">and additions.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Now that we</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.116.1"> know more about creating an identity for our projects and with our branding exercise complete, we can move to the exciting part of architecting our </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">new framework.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.118.1">Architecting the new framework</span></h1>
<p><span class="koboSpan" id="kobo.119.1">Now, we’ll get to the </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.120.1">architectural part of our practical approach. </span><span class="koboSpan" id="kobo.120.2">So far, we know what we are building and who we are building it for. </span><span class="koboSpan" id="kobo.120.3">It is now time to determine the shape of our feature set and see how we can enable those features for our users. </span><span class="koboSpan" id="kobo.120.4">The most basic use case that we would like to cover is generating assertions for JavaScript code, as </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
// basic.js
export function helloReader() {
  return "Hello reader!";
}
// tests/basic.js
import ct, { assert } from "componium-test";
import { helloReader } from "../basic.js";
ct({
  basic: function () {
    assert.strictEqual(helloReader(), "Hello reader!",
      "output is correct");
  },
});</span></pre>
<p><span class="koboSpan" id="kobo.123.1">The preceding code example tests the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">helloReader()</span></strong><span class="koboSpan" id="kobo.125.1"> function and verifies that the correct string is returned. </span><span class="koboSpan" id="kobo.125.2">Starting from these basics, to take things further, we spend time on core functionality and identifying out-of-scope features first. </span><span class="koboSpan" id="kobo.125.3">Later, this can help drive technical decisions, as we brainstorm the set of extended features that can be suitable for our project. </span><span class="koboSpan" id="kobo.125.4">Our strategy consists of comparing the features offered by existing testing tools, developing unique characteristics, and contemplating which capabilities are out of the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">initial scope.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">To draw some feature comparisons, we can look at some frameworks from </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.128.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.129.1">. </span><em class="italic"><span class="koboSpan" id="kobo.130.1">Jest</span></em><span class="koboSpan" id="kobo.131.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Vitest</span></em><span class="koboSpan" id="kobo.133.1"> come to mind as they are frameworks comparable to what we are building in this chapter. </span><span class="koboSpan" id="kobo.133.2">In addition, other projects in the ecosystem are </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">jasmine</span></strong><span class="koboSpan" id="kobo.135.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">ava</span></strong><span class="koboSpan" id="kobo.137.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">tap</span></strong><span class="koboSpan" id="kobo.139.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">tape</span></strong><span class="koboSpan" id="kobo.141.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">mocha</span></strong><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">Most of these projects provide an advanced testing interface with a specific test life cycle and different ways to create assertions. </span><span class="koboSpan" id="kobo.143.3">All these existing open source projects also provide a common set of core functionalities, such as executability to run the framework in different projects, different output formatting options, the ability to stub or spy on interfaces, </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">In the following </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.146.1">subsections, we will examine some of the unique features that can be implemented as part of our initial approach to the </span><em class="italic"><span class="koboSpan" id="kobo.147.1">Componium </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Test</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1"> project.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.150.1">Selecting features</span></h2>
<p><span class="koboSpan" id="kobo.151.1">Brainstorming a list of </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.152.1">features for a testing framework can be both exhausting and exciting. </span><span class="koboSpan" id="kobo.152.2">There are just so many areas to cover in terms of testing tool development, with most of the feature set covering different areas of development. </span><span class="koboSpan" id="kobo.152.3">In the architecting example from the beginning of this section, we listed basic test use cases, and now we can expand on them. </span><span class="koboSpan" id="kobo.152.4">Here are some of the additional types of functionality that could help our project provide a better feature set to </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">its stakeholders:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">Capable test runner</span></strong><span class="koboSpan" id="kobo.155.1">: The framework exposes a test runner executable with the ability to execute a single or full suite of tests. </span><span class="koboSpan" id="kobo.155.2">It provides its users with a selective execution format to specify which tests to run, a feature that's useful during development and debugging situations. </span><span class="koboSpan" id="kobo.155.3">The test runner also allows the users to define test cases using a </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">particular syntax.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Cross-platform testing</span></strong><span class="koboSpan" id="kobo.158.1">: The framework enables testing in different JavaScript environments, such as providing some support for Node.js and web </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">API testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.160.1">Assertion types</span></strong><span class="koboSpan" id="kobo.161.1">: Users are able to use different types of assertion styles, which provides flexible options for structuring tests. </span><span class="koboSpan" id="kobo.161.2">These different assertion styles cater to different preferences and can impact the readability and maintainability of test code. </span><span class="koboSpan" id="kobo.161.3">Offering a variety of assertion types allows developers to pick the one that best suits their needs and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">coding style.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Test suite interface</span></strong><span class="koboSpan" id="kobo.164.1">: Provide a rich interface that includes setup functions and life cycle hooks. </span><span class="koboSpan" id="kobo.164.2">These features are necessary for organizing and managing tests effectively. </span><span class="koboSpan" id="kobo.164.3">A good test suite interface enables necessary actions before and after tests or test suites, enabling a more structured approach </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">to testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.166.1">Ability to stub code</span></strong><span class="koboSpan" id="kobo.167.1">: Enable capabilities for spying, stubbing, and mocking of existing code to allow implementation substitution. </span><span class="koboSpan" id="kobo.167.2">This is a crucial feature to determine all possible </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.168.1">ways the application code can be called. </span><span class="koboSpan" id="kobo.168.2">For instance, the Jest framework has the following capabilities built </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">in: </span></span><a href="http://jestjs.io/docs/jest-object#mock-functions"><span class="No-Break"><span class="koboSpan" id="kobo.170.1">jestjs.io/docs/jest-object#mock-functions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.171.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Code coverage</span></strong><span class="koboSpan" id="kobo.173.1">: Output a report of code coverage that shows a percentage of the code base that is covered by </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.175.1">Integration with build systems</span></strong><span class="koboSpan" id="kobo.176.1">: Expose the right interfaces and document how a particular framework can be </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.177.1">executed in </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">continuous integration</span></strong><span class="koboSpan" id="kobo.179.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.180.1">CI</span></strong><span class="koboSpan" id="kobo.181.1">) environments, mentioning any particular features that are available to the user as part of this execution mode. </span><span class="koboSpan" id="kobo.181.2">Investment into handling build pipeline features can also include integration with build tools (from </span><a href="B19014_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.182.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.183.1">) such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">webpack</span></strong><span class="koboSpan" id="kobo.185.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">rollup.js</span></strong><span class="koboSpan" id="kobo.187.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">and others.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.189.1">Test reporters</span></strong><span class="koboSpan" id="kobo.190.1">: Enable the framework to emit test results reporting in different formats. </span><span class="koboSpan" id="kobo.190.2">Some examples of the standard types shipped with frameworks include the following: a specification reporter that shows a hierarchical view of test suite results, a JSON or XML reporter to integrate with external tools, and a dot reporter that outputs </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">.</span></strong><span class="koboSpan" id="kobo.192.1"> for passing tests or </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">F</span></strong><span class="koboSpan" id="kobo.194.1"> for failures. </span><span class="koboSpan" id="kobo.194.2">Usually, these reporter types can be specified by the environment or flag while running the test </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">framework executable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.196.1">Plugin interface</span></strong><span class="koboSpan" id="kobo.197.1">: Expose a plugin interface to make it possible to extend the framework feature set. </span><span class="koboSpan" id="kobo.197.2">For a testing framework, this could be an option to provide additional reporters or swap out </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">built-in libraries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.199.1">Besides this list of features, our framework can also focus on improving the developer experience around JavaScript features such as handling ES module environments or asynchronous behavior in tests. </span><span class="koboSpan" id="kobo.199.2">It may also choose to cater to many niche JavaScript use cases, such as being able to work with particular libraries and test media and </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">graphics-related features.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We now have a generous list of conceivable features that will produce a reasonable foundation for our</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.202.1"> framework implementation. </span><span class="koboSpan" id="kobo.202.2">Part of the feature planning and development process also includes figuring out which functionality will be out of scope. </span><span class="koboSpan" id="kobo.202.3">This is what we will briefly cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">following section.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.204.1">Identifying out-of-scope features</span></h2>
<p><span class="koboSpan" id="kobo.205.1">Even though we have</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.206.1"> identified a rich feature set, it does </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.207.1">not cover all potential use cases of a testing framework. </span><span class="koboSpan" id="kobo.207.2">To further improve the ergonomics of the project, there are components that would need to be developed in the follow-up versions. </span><span class="koboSpan" id="kobo.207.3">In particular, this initial version aims to create a foundation for the framework that will allow us to quickly iterate and add new features. </span><span class="koboSpan" id="kobo.207.4">It is better to focus on creating a continuous and intuitive development environment rather than rushing a slew of features immediately. </span><span class="koboSpan" id="kobo.207.5">In a real-world use case, as a framework developer, it would be important to gather user feedback and address the most pressing needs of your stakeholders as you iterate on </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">Here are some features and components that could serve as potential additions to </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">follow-up releases:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.211.1">Test watcher</span></strong><span class="koboSpan" id="kobo.212.1">: Providing a test runner mode that is watching for file changes and rerunning the tests as underlying components change. </span><span class="koboSpan" id="kobo.212.2">This could be a welcoming feature for developers as it provides real-time feedback during the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">development process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Clock and date manipulation</span></strong><span class="koboSpan" id="kobo.215.1">: An additional improvement on top of existing mocking functionality, built-in clock and date mocking in JavaScript projects can make it much easier to freeze or manipulate dates. </span><span class="koboSpan" id="kobo.215.2">Providing this interface further </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">improves ergonomics.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.217.1">Snapshot testing</span></strong><span class="koboSpan" id="kobo.218.1">: Involves capturing and comparing the output of complex components. </span><span class="koboSpan" id="kobo.218.2">It can save time by simplifying assertion methods and separating the expected output source from the test </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">file structure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.220.1">Retries</span></strong><span class="koboSpan" id="kobo.221.1">: The ability to retry failed tests could improve the ergonomics in different testing environments. </span><span class="koboSpan" id="kobo.221.2">This feature requires a careful approach to make sure that only expected failures are retried and the test runner does not report passing results for </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">broken tests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.223.1">There are definitely more components that can be developed for such frameworks, but the feature collection </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.224.1">we have identified is enough </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.225.1">for us to construct the architectural design outline. </span><span class="koboSpan" id="kobo.225.2">The next part of the development process is to pick out the most consequential parts from the feature set and devise an architecture to make this functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">a reality.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.227.1">Designing the outline</span></h2>
<p><span class="koboSpan" id="kobo.228.1">We need to introduce</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.229.1"> an executable interface to enable the test</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.230.1"> runner features with cross-platform testing behavior. </span><span class="koboSpan" id="kobo.230.2">This interface, implemented as a command-line tool, must handle users’ running options within different environments. </span><span class="koboSpan" id="kobo.230.3">Finally, to fulfill our main goal of asserting code behavior, the execution modes must return the testing </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">assertions’ status.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">As the executable triggers the tests, the tests will emit their status and events. </span><span class="koboSpan" id="kobo.232.2">The runner needs to respect the life cycles of those tests and subscribe to the events related to the testing workflow. </span><span class="koboSpan" id="kobo.232.3">Potential events could include passing or failing state or bubbling up assertion errors if </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">those occur.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Creating a design diagram such as the one seen here makes it easier to see how the components that enable the feature set can interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">one another:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.236.1"><img alt="Figure 6.2: Initial design diagram" src="image/Figure_6.2_B19014.png.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.237.1">Figure 6.2: Initial design diagram</span></p>
<p><span class="koboSpan" id="kobo.238.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.239.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.240.1">.2</span></em><span class="koboSpan" id="kobo.241.1">, the flow of execution starts from the executable or the command line, defined on the left side of the diagram. </span><span class="koboSpan" id="kobo.241.2">In this case, the executable is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">ct</span></strong><span class="koboSpan" id="kobo.243.1"> command, which is short for </span><em class="italic"><span class="koboSpan" id="kobo.244.1">Componium Test</span></em><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">If the developer uses the command line as an entry point, then </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.246.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">CLI handler</span></strong><span class="koboSpan" id="kobo.248.1"> parses through the provided flags and options, determining if the tests will be running in the Node.js environment or the web browser environment. </span><span class="koboSpan" id="kobo.248.2">This will enable the cross-platform testing capabilities we evaluated during the feature </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">planning process.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">In the Node.js </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.251.1">context, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">NodeExecutor</span></strong><span class="koboSpan" id="kobo.253.1"> class can parse the provided test </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.254.1">files and run their assertions, logging the real-time status of the execution and outputting the final results of the tests. </span><span class="koboSpan" id="kobo.254.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">chapter6/componium-test/packages/node/executor.js</span></strong><span class="koboSpan" id="kobo.256.1"> file has the contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">NodeExecutor</span></strong><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">The code is programmed to spawn worker environments for each test suite and run assertions in the test cases. </span><span class="koboSpan" id="kobo.258.3">Later, a summary of passing and failing tests </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">is collected.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">In the browser context, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">BrowserExecutor</span></strong><span class="koboSpan" id="kobo.262.1"> class relies on an external web browser bridge, provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">puppeteer</span></strong><span class="koboSpan" id="kobo.264.1"> library. </span><span class="koboSpan" id="kobo.264.2">It creates a communication channel between the test runner and a real browser environment, queues the expected test suites, and uses a similar interface to capture test assertion and life cycle output. </span><span class="koboSpan" id="kobo.264.3">The browser environment also has distinct running methods, such as the </span><em class="italic"><span class="koboSpan" id="kobo.265.1">headless</span></em><span class="koboSpan" id="kobo.266.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.267.1">headful</span></em><span class="koboSpan" id="kobo.268.1"> modes, where the browser is either hidden or displayed to the user while the tests run. </span><span class="koboSpan" id="kobo.268.2">This feature requires integrating the library and the test runner executable. </span><span class="koboSpan" id="kobo.268.3">This executor can be found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">chapter6/componium-test/packages/browser/executor.js</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">This code works in a similar way to the Node.js method, but due to the fact that it runs in the web browser context, it has to send the results of the test suite back to the Node.js test runner running in the terminal process. </span><span class="koboSpan" id="kobo.270.3">The environmental difference makes the technical design of these two executors </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">vastly different.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">The diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.273.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.274.1">.2</span></em><span class="koboSpan" id="kobo.275.1"> also outlines potential support for running tests directly as a script file via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">node</span></strong><span class="koboSpan" id="kobo.277.1"> CLI. </span><span class="koboSpan" id="kobo.277.2">In this case, the tests bypass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">ct</span></strong><span class="koboSpan" id="kobo.279.1"> interface and directly output the results as the script runs. </span><span class="koboSpan" id="kobo.279.2">It is a handy feature that supports direct </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">testing workflows.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">The outline and diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.282.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.283.1">.2</span></em><span class="koboSpan" id="kobo.284.1"> do not capture the full details of the test runner workflow, but they are helpful for our development process. </span><span class="koboSpan" id="kobo.284.2">As you develop your own frameworks, you will find that creating such artifacts can help you be more efficient and precise in </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.285.1">architecting different kinds of software solutions. </span><span class="koboSpan" id="kobo.285.2">With the architecture </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.286.1">and features outlined, we can continue to the interface design part of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">the process.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.288.1">Designing the interfaces and API</span></h2>
<p><span class="koboSpan" id="kobo.289.1">Two main interfaces</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.290.1"> are used as the point of interaction with our framework: the main framework module and the test runner executable. </span><span class="koboSpan" id="kobo.290.2">Developers must be acquainted with these interfaces through API documentation, examples, and more. </span><span class="koboSpan" id="kobo.290.3">In addition, introducing breaking changes or modifications to these APIs’ functionality will affect projects already integrated into </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the framework.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">The first interface we are looking at is the imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">componium-test</span></strong><span class="koboSpan" id="kobo.294.1"> framework module. </span><span class="koboSpan" id="kobo.294.2">This module exports the main testing object that can accept the testing function </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.295.1">through </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.297.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">JSON</span></strong><span class="koboSpan" id="kobo.299.1">). </span><span class="koboSpan" id="kobo.299.2">The module also exports additional framework interfaces, such as the assertion and mocking libraries. </span><span class="koboSpan" id="kobo.299.3">Here’s an example of using </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">this module:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.301.1">Code snippet 1</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
import framework interfaces
import ct, { assert, fake, replace } from "componium-test";
import Calculator from "../fixtures/calculator.js";
  // fixture to test
let calc;
ct({
  describe: "Calculator Tests",
  beforeEach: () =&gt; {
    calc = new Calculator();
  },
  multiply: function () {
    assert.equal(calc.multiply(3, 2), 6, "3 * 2 is 6");
  },
  mockMultiply: function () {
    const myFake = fake.returns(42);
    replace(calc, "multiply", myFake);
    assert.strictEqual(calc.multiply(1, 1), 42,
      "fake interface is working");
  },
  afterEach: () =&gt; {
    console.log("called afterEach");
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.303.1">The preceding code </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.304.1">example of using the module in the test file can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">tests/calc-tests.js</span></strong><span class="koboSpan" id="kobo.306.1"> path of the framework. </span><span class="koboSpan" id="kobo.306.2">In this code, we see the inclusion of basic assertions for a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Calculator</span></strong><span class="koboSpan" id="kobo.308.1"> script; those are made possible by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">assert</span></strong><span class="koboSpan" id="kobo.310.1"> function. </span><span class="koboSpan" id="kobo.310.2">Based on the expected feature set, we have the test life cycle methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">beforeEach</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">Additionally, mocking functionality that replaces the return point of </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">multiply</span></strong><span class="koboSpan" id="kobo.314.1"> is enabled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">fake</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">replace</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1"> functions.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">The second interface is the command-line utility provided when the users install the framework. </span><span class="koboSpan" id="kobo.319.2">This is a test runner that enables interaction with a large number of </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">test suites:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
&gt; ct --help
ct [&lt;tests&gt;...]
Options:
     --version   Show version number                       [boolean]
 -b, --browser   Run the test in a web browser             [boolean]
     --keepAlive Keep the web browser alive to debug tests [boolean]
      --help     Show help                                 [boolean]</span></pre>
<p><span class="koboSpan" id="kobo.322.1">The executable supports a variety of options to enable the expected feature set. </span><span class="koboSpan" id="kobo.322.2">In addition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">--help</span></strong><span class="koboSpan" id="kobo.324.1"> flag can also display available commands and their shortcuts. </span><span class="koboSpan" id="kobo.324.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">ct</span></strong><span class="koboSpan" id="kobo.326.1"> executable accepts one or more test suites as arguments, visible through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">ct [&lt;tests&gt;...]</span></strong><span class="koboSpan" id="kobo.328.1"> notation. </span><span class="koboSpan" id="kobo.328.2">The presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">ct</span></strong><span class="koboSpan" id="kobo.330.1"> executable is expected by developers after installing the framework from JavaScript’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">npm</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.332.1">package registry.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">We now have knowledge</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.334.1"> of these two developer-level APIs—the test executable and the test interface. </span><span class="koboSpan" id="kobo.334.2">We can now proceed to the implementation of features that power the functionality behind those two </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">framework features.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.336.1">Implementing the new frameworks</span></h1>
<p><span class="koboSpan" id="kobo.337.1">The implementation </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.338.1">process guides us further on how frameworks in JavaScript can be created. </span><span class="koboSpan" id="kobo.338.2">In this implementation process, we’ll see the different entry points of a test runner combined with distinguishable features. </span><span class="koboSpan" id="kobo.338.3">This section roughly follows the diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.339.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.340.1">.2</span></em><span class="koboSpan" id="kobo.341.1">, where we outlined the framework design. </span><span class="koboSpan" id="kobo.341.2">Now that we know our features and have a rough idea of the project’s architecture, let’s broadly outline the steps of the internal implementation of this project, </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.343.1">Determine how the designed test suite configuration can be implemented within the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">Node.js environment.</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">Create internal packages to execute the test suites in </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">different environments.</span></span></li>
<li><span class="koboSpan" id="kobo.347.1">Implement the infrastructure for real web </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">browser-mode testing.</span></span></li>
<li><span class="koboSpan" id="kobo.349.1">Collect results from the test runner and output them to </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">the user.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.351.1">Following </span><em class="italic"><span class="koboSpan" id="kobo.352.1">steps 1</span></em><span class="koboSpan" id="kobo.353.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.354.1">4</span></em><span class="koboSpan" id="kobo.355.1">, we begin our implementation by examining how our tests are structured and executed. </span><span class="koboSpan" id="kobo.355.2">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Calculator Tests</span></strong><span class="koboSpan" id="kobo.357.1"> snippet, we can examine the JavaScript object structure, consisting of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">ct</span></strong><span class="koboSpan" id="kobo.359.1"> functional call and accepting a test suite object. </span><span class="koboSpan" id="kobo.359.2">Some special properties include describing the test suite name and running life cycle methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">before</span></strong><span class="koboSpan" id="kobo.361.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">after</span></strong><span class="koboSpan" id="kobo.363.1">. </span><span class="koboSpan" id="kobo.363.2">The execution life cycle of these methods can</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.364.1"> be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.366.1"><img alt="Figure 6.3: Test life cycle" src="image/Figure_6.3_B19014.png.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.367.1">Figure 6.3: Test life cycle</span></p>
<p><span class="koboSpan" id="kobo.368.1">To enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">ct</span></strong><span class="koboSpan" id="kobo.370.1"> function call, the test suites can access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">componium-test</span></strong><span class="koboSpan" id="kobo.372.1"> package and our framework’s public interfaces, such as the assertion library features. </span><span class="koboSpan" id="kobo.372.2">We can see an example of including the framework in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">calc-tests.js</span></strong><span class="koboSpan" id="kobo.374.1"> code block in </span><em class="italic"><span class="koboSpan" id="kobo.375.1">Code snippet 1</span></em><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">Besides importing the framework features, the test file imports the code we aim </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Importing our framework in the Node.js context will require properly exporting it as part of the package. </span><span class="koboSpan" id="kobo.378.2">To do that, we define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">exports</span></strong><span class="koboSpan" id="kobo.380.1"> property in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">package.json</span></strong><span class="koboSpan" id="kobo.382.1"> file. </span><span class="koboSpan" id="kobo.382.2">This allows projects to configure </span><em class="italic"><span class="koboSpan" id="kobo.383.1">Componium Test</span></em><span class="koboSpan" id="kobo.384.1"> as a dependency to import the module </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">by name:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.386.1">Code Snippet 2</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
"exports": {
  ".": "./packages/runner/tester.js",
  "./package.json": "./package.json"
},</span></pre>
<p><span class="koboSpan" id="kobo.388.1">The preceding configuration pinpoints our </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">tester.js</span></strong><span class="koboSpan" id="kobo.390.1"> file, which handles most of the test-running logic, referenced from our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">runner</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">Once the test object is loaded into the framework, it is directed to the appropriately named </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">packages/runner/tester.js</span></strong><span class="koboSpan" id="kobo.395.1"> file. </span><span class="koboSpan" id="kobo.395.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">tester.js</span></strong><span class="koboSpan" id="kobo.397.1"> file is where most of the testing happens, including the life cycle methods, executed at appropriate times, alongside the main test function. </span><span class="koboSpan" id="kobo.397.2">Provided that a test suite can have many tests, the tester proceeds to</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.398.1"> call through all the provided functions. </span><span class="koboSpan" id="kobo.398.2">To measure the speed of the tests, we can rely on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">performance</span></strong><span class="koboSpan" id="kobo.400.1"> APIs (</span><a href="http://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><span class="koboSpan" id="kobo.401.1">developer.mozilla.org/en-US/docs/Web/API/Performance/now</span></a><span class="koboSpan" id="kobo.402.1">). </span><span class="koboSpan" id="kobo.402.2">These APIs provide high-resolution timestamps to provide us with data on how long the tests take </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">to run.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.404.1">Testing functionality</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Enabling an excellent </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.406.1">testing experience through detailed test assertions, our project needs an assertion library that can be used within the newly written tests. </span><span class="koboSpan" id="kobo.406.2">The assertion interfaces should include equality comparison, value size comparison, object value evaluation, </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">and others.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">To focus on broad framework development, we will import an external test assertion library</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.409.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">Chai</span></strong><span class="koboSpan" id="kobo.411.1"> (</span><a href="http://chaijs.com"><span class="koboSpan" id="kobo.412.1">chaijs.com</span></a><span class="koboSpan" id="kobo.413.1">) to help us with this task. </span><span class="koboSpan" id="kobo.413.2">Using this external library can save us time and let us concentrate on developing the framework interfaces and focus on the bigger picture. </span><span class="koboSpan" id="kobo.413.3">To avoid locking the project into a particular assertion library, we will abstract away Chai into an internal module. </span><span class="koboSpan" id="kobo.413.4">In the initial implementation, we will expose the three interfaces, </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">should</span></strong><span class="koboSpan" id="kobo.415.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">expect</span></strong><span class="koboSpan" id="kobo.417.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">assert</span></strong><span class="koboSpan" id="kobo.419.1">. </span><span class="koboSpan" id="kobo.419.2">Subsequently, we can develop our own assertion infrastructure or replace Chai with a different library, which we can potentially develop </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">by ourselves.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">As the testing script executes our provided tests, our handy assertion library will throw an exception if any comparison functions are unsuccessful, </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
AssertionError: 3 * 2 is 6: expected 1.5 to equal 6
    at multiply (file:///Users/componium-test/tests/
      calc-tests.js:20:12)
    at ComponiumTest.test (file:///Users/
      componium-test/packages/runner/tester.js:92:15) {
  showDiff: true,
  actual: 1.5,
  expected: 6,
  operator: 'strictEqual'
}</span></pre>
<p><span class="koboSpan" id="kobo.424.1">The preceding output</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.425.1"> shown is a snippet of a failure in one of the tests, where the imported </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Calculator</span></strong><span class="koboSpan" id="kobo.427.1"> module does not correctly perform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">multiply</span></strong><span class="koboSpan" id="kobo.429.1"> operation. </span><span class="koboSpan" id="kobo.429.2">The framework needs to handle this type of code behavior. </span><span class="koboSpan" id="kobo.429.3">In the case of assertion or other errors, the test runner needs to signal back to the running process of at least one or more failed tests. </span><span class="koboSpan" id="kobo.429.4">If at least something flips the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">errorOccurred</span></strong><span class="koboSpan" id="kobo.431.1"> flag, then it will result in our testing node process exiting with a </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">failure status.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Besides the assertion library, we want to provide mocking and stubbing functionality in the developed framework. </span><span class="koboSpan" id="kobo.433.2">Using a similar pattern where we include the Chai.js library and expose it as a test API interface, we will</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.434.1"> include the </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">Sinon.js</span></strong><span class="koboSpan" id="kobo.436.1"> (</span><a href="http://sinonjs.org"><span class="koboSpan" id="kobo.437.1">sinonjs.org</span></a><span class="koboSpan" id="kobo.438.1">) library, which has a rich interface for creating test stubs, spies, and mocks. </span><span class="koboSpan" id="kobo.438.2">It is an excellent fit for our project because it supports many JavaScript environments and has been battle-tested in other projects for many years. </span><span class="koboSpan" id="kobo.438.3">The presence of this library will make it easier for developers to increase code coverage and write more </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">effective tests.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">In the code snippet (</span><em class="italic"><span class="koboSpan" id="kobo.441.1">Code snippet 1</span></em><span class="koboSpan" id="kobo.442.1">) of the example test file, we use Sinon.js’ functions to create a fake </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">mockMultiply</span></strong><span class="koboSpan" id="kobo.444.1"> return point. </span><span class="koboSpan" id="kobo.444.2">The Sinon.js methods are also abstracted away from direct usage. </span><span class="koboSpan" id="kobo.444.3">Instead, they are exposed as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">componium-test</span></strong><span class="koboSpan" id="kobo.446.1"> package. </span><span class="koboSpan" id="kobo.446.2">Users can access the library’s mocking, faking, and stubbing mechanisms configured in the framework’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">packages/mock/lib.js</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.448.1">mock package.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">The inclusion of</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.450.1"> powerful assertions and mocking libraries, exposed in a simple interface, allows our framework to gain rich functionality from the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">first version.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.452.1">Creating a command-line tool</span></h2>
<p><span class="koboSpan" id="kobo.453.1">In the previous </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.454.1">sections, we talked about making our </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">tester.js</span></strong><span class="koboSpan" id="kobo.456.1"> file the imported entry point to run tests. </span><span class="koboSpan" id="kobo.456.2">To match the expected feature set, the framework needs to support running multiple sets of tests from a given directory. </span><span class="koboSpan" id="kobo.456.3">This means supporting a number of suites of a given format in bulk. </span><span class="koboSpan" id="kobo.456.4">This means that the number of test suites will be structured in the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">following format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
import ct, { assert } from "componium-test";
ct({...});</span></pre>
<p><span class="koboSpan" id="kobo.459.1">To get this bulk execution feature, we need to create a command-line tool for our framework. </span><span class="koboSpan" id="kobo.459.2">To integrate with the Node.js command-line environment, we need to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">bin</span></strong><span class="koboSpan" id="kobo.461.1"> key in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">package.json</span></strong><span class="koboSpan" id="kobo.463.1"> file to export the command-line file, </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
"bin": {
  "ct": "bin/ct.js"
},</span></pre>
<p><span class="koboSpan" id="kobo.466.1">The binary shortcut that we export is just </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">ct</span></strong><span class="koboSpan" id="kobo.468.1"> to make it really easy to execute the framework commands from other projects. </span><span class="koboSpan" id="kobo.468.2">To develop the binary file, we can rely on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">yargs</span></strong><span class="koboSpan" id="kobo.470.1"> library (</span><a href="http://yargs.js.org"><span class="koboSpan" id="kobo.471.1">yargs.js.org</span></a><span class="koboSpan" id="kobo.472.1">) to handle user input, parsing the provided process arguments from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">process.argv</span></strong><span class="koboSpan" id="kobo.474.1"> variable. </span><span class="koboSpan" id="kobo.474.2">See the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">packages/bin/ct.js</span></strong><span class="koboSpan" id="kobo.476.1"> file for details on the executable structure. </span><span class="koboSpan" id="kobo.476.2">There are several features to remember with the structure of the executable, focusing on developing a good interface and enabling particular features of the framework, </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.478.1">Include the interpretation in the file’s first line with </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">#!/usr/bin/env node</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">This signals to the system shell to use the node executable for this file. </span><span class="koboSpan" id="kobo.480.3">This is known as the </span><em class="italic"><span class="koboSpan" id="kobo.481.1">Shebang</span></em><span class="koboSpan" id="kobo.482.1"> (</span><a href="http://wikipedia.org/wiki/Shebang_%28Unix%29"><span class="koboSpan" id="kobo.483.1">wikipedia.org/wiki/Shebang_%28Unix%29</span></a><span class="koboSpan" id="kobo.484.1">), where an interpreter executable is provided within </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the script.</span></span></li>
<li><span class="koboSpan" id="kobo.486.1">Keep the binary package logic focused on the code related to parsing command-line flags and ensuring a good CLI experience. </span><span class="koboSpan" id="kobo.486.2">This includes supporting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">--help</span></strong><span class="koboSpan" id="kobo.488.1"> flag, providing shortcuts to flags, and testing for edge cases of how an executable can be used. </span><span class="koboSpan" id="kobo.488.2">The flags or options of the CLI should follow the double-hyphenated (</span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">--</span></strong><span class="koboSpan" id="kobo.490.1">) structure or a single one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">-</span></strong><span class="koboSpan" id="kobo.492.1">) for </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">short options.</span></span></li>
<li><span class="koboSpan" id="kobo.494.1">The executable should follow the standard rules of CLIs. </span><span class="koboSpan" id="kobo.494.2">The CLI process should exit with an appropriate status code and indicate if the process failed. </span><span class="koboSpan" id="kobo.494.3">This is especially important in the case of the test runner that we are working with in </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">this chapter.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.496.1">Depending on the execution mode, Node.js, or the browser, the CLI file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">packages/runner/cli.js</span></strong><span class="koboSpan" id="kobo.498.1">) chooses the right executor class, providing this class with a list of target files. </span><span class="koboSpan" id="kobo.498.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">NodeExecutor</span></strong><span class="koboSpan" id="kobo.500.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">BrowserExecutor</span></strong><span class="koboSpan" id="kobo.502.1"> classes have the job of processing all the test files and evaluating if any of the tests in those files fail any assertions. </span><span class="koboSpan" id="kobo.502.2">In the Node.js testing environment, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">NodeExecutor</span></strong><span class="koboSpan" id="kobo.504.1"> class to run the tests. </span><span class="koboSpan" id="kobo.504.2">The</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.505.1"> class spawns new worker threads to execute test suites concurrently. </span><span class="koboSpan" id="kobo.505.2">The main purpose of this interface is to run tests for multiple target files and return an overall pass or </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">fail result.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.507.1">Browser testing workflow</span></h2>
<p><span class="koboSpan" id="kobo.508.1">Another feature we </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.509.1">are exploring in the developed framework is the ability to execute tests in a real web browser environment. </span><span class="koboSpan" id="kobo.509.2">To enable this, the CLI accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">–browser</span></strong><span class="koboSpan" id="kobo.511.1"> flag that switches the running mode of the test framework. </span><span class="koboSpan" id="kobo.511.2">The entry point to this interface for a developer may look something like this: </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">ct –browser test/some_test.js</span></strong><span class="koboSpan" id="kobo.513.1">. </span><span class="koboSpan" id="kobo.513.2">Depending on the approach to the framework executables, we can also introduce a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">ct-browser</span></strong><span class="koboSpan" id="kobo.515.1"> executable to directly execute the test in the browser context without worrying about extra parameters. </span><span class="koboSpan" id="kobo.515.2">To implement this functionality, the framework relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">puppeteer</span></strong><span class="koboSpan" id="kobo.517.1"> library to spawn a new browser instance and establish a communication channel </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">with it.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.519.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.520.1">.4</span></em><span class="koboSpan" id="kobo.521.1"> shows the debugging view of the browser test </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">runner workflow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.523.1"><img alt="Figure 6.4: Debugging view of the browser test runner workflow" src="image/Figure_6.4_B19014.png.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.524.1">Figure 6.4: Debugging view of the browser test runner workflow</span></p>
<p><span class="koboSpan" id="kobo.525.1">This operation mode is helpful to get access to the tests if they are failing in the browser. </span><span class="koboSpan" id="kobo.525.2">This environment allows developers to set breakpoints in their code and debug the tests. </span><span class="koboSpan" id="kobo.525.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">BrowserExecutor</span></strong><span class="koboSpan" id="kobo.527.1"> file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">packages/browser/executor.js</span></strong><span class="koboSpan" id="kobo.529.1"> takes care of launching a new instance of a real web browser. </span><span class="koboSpan" id="kobo.529.2">The communication channel it establishes can rely on messaging from the console or through more advanced </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">window.postMessage</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.531.1">function calls.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">We can use a simple Node.js server paired with a small templating library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">eta</span></strong><span class="koboSpan" id="kobo.534.1"> to create a browser</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.535.1"> page that executes the tests. </span><span class="koboSpan" id="kobo.535.2">We can create a valid HTML document with the templating library that includes the dependencies and test files. </span><span class="koboSpan" id="kobo.535.3">To properly load the framework files, the page relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">importmap</span></strong><span class="koboSpan" id="kobo.537.1"> (</span><a href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap"><span class="koboSpan" id="kobo.538.1">developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap</span></a><span class="koboSpan" id="kobo.539.1">) to map ES module names to URLs. </span><span class="koboSpan" id="kobo.539.2">The code is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
&lt;script type="importmap"&gt;
 {
   "imports": {
     "componium-test": "/runner/tester.js",
     "chai": "/chai.js",
     "sinon": "/sinon.js"
   }
 }
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.542.1">The initial implementation of the frontend test runner has a minimal interface, but it can be further developed to show a more interactive dashboard of tests. </span><span class="koboSpan" id="kobo.542.2">This can be a potential feature investment, adding additional frontend features if a test runner is used heavily in browser-related testing. </span><span class="koboSpan" id="kobo.542.3">The import map structure can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">chapter6/componium-test/packages/browser/views/layout.eta</span></strong><span class="koboSpan" id="kobo.544.1"> file. </span><span class="koboSpan" id="kobo.544.2">Besides the</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.545.1"> framework files, this file also consists of parsing a dynamic list of test suites that need to be included in the frontend. </span><span class="koboSpan" id="kobo.545.2">This makes it possible to include and run a number of test suites in the frontend </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">testing harness.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.547.1">Testing the framework</span></h2>
<p><span class="koboSpan" id="kobo.548.1">As we develop the testing </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.549.1">framework, we must ensure its reliability and correctness. </span><span class="koboSpan" id="kobo.549.2">However, using another external framework for testing might not be ideal, and we can’t use the framework itself to test its features as it is still under development. </span><span class="koboSpan" id="kobo.549.3">We use simple approaches to address this challenge, enabling unit, snapshot, and </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">end-to-end</span></strong><span class="koboSpan" id="kobo.551.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.552.1">E2E</span></strong><span class="koboSpan" id="kobo.553.1">) testing</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.554.1"> to ensure our project </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">works correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Unit testing of our project can primarily rely on the existing test runner implementation. </span><span class="koboSpan" id="kobo.556.2">However, we need to integrate snapshot testing, which includes comparing the test runner’s output with snapshotted versions of the desired output. </span><span class="koboSpan" id="kobo.556.3">As we refactor certain features, we should verify with the snapshot test to detect unintended changes. </span><span class="koboSpan" id="kobo.556.4">Including such tests gives us more confidence as we push new updates and improvements to the project. </span><span class="koboSpan" id="kobo.556.5">In particular, unit tests that require more attention are related to the exit status codes of the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">test runner.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Another important testing addition is the inclusion of E2E tests that cover the whole framework workflow. </span><span class="koboSpan" id="kobo.558.2">This includes installing packages, importing the testing package, and executing tests. </span><span class="koboSpan" id="kobo.558.3">These tests are made possible by creating a separate testing package that includes our framework as a dependency, </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.560.1">
"dependencies": {
 "componium-test": "file:.."
</span><span class="koboSpan" id="kobo.560.2">}</span></pre>
<p><span class="koboSpan" id="kobo.561.1">The sample testing project includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">componium-test</span></strong><span class="koboSpan" id="kobo.563.1"> as a dependency in its </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">package.json</span></strong><span class="koboSpan" id="kobo.565.1"> file and points to the parent directory to load the files. </span><span class="koboSpan" id="kobo.565.2">These E2E tests can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">e2e</span></strong><span class="koboSpan" id="kobo.567.1"> directory of the project. </span><span class="koboSpan" id="kobo.567.2">In </span><a href="B19014_09.xhtml#_idTextAnchor156"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.568.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.569.1">, we will explore additional ways to</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.570.1"> improve and validate </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">project quality.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.572.1">Framework packages</span></h2>
<p><span class="koboSpan" id="kobo.573.1">Shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.575.1">.5</span></em><span class="koboSpan" id="kobo.576.1"> are the initial</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.577.1"> packages of the project. </span><span class="koboSpan" id="kobo.577.2">They are situated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">packages</span></strong><span class="koboSpan" id="kobo.579.1"> directory, similar to how many other frameworks choose to organize </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">their projects:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.581.1"><img alt="Figure 6.5: The framework packages of the project" src="image/Figure_6.5_B19014.png.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.582.1">Figure 6.5: The framework packages of the project</span></p>
<p><span class="koboSpan" id="kobo.583.1">These packages are logically split by their responsibility. </span><span class="koboSpan" id="kobo.583.2">Here is a brief outline of what </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">they do:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">assert</span></strong><span class="koboSpan" id="kobo.586.1">: Contains the assertion </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">library-related configuration</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">bin</span></strong><span class="koboSpan" id="kobo.589.1">: Contains the executable, which is exported by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">package.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1"> file</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">browser</span></strong><span class="koboSpan" id="kobo.593.1">: Files related to test execution in the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">browser environment</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">views</span></strong><span class="koboSpan" id="kobo.596.1">: Template files that make it possible to load tests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">frontend context</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">mock</span></strong><span class="koboSpan" id="kobo.599.1">: Mocking </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">library-related features</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">node</span></strong><span class="koboSpan" id="kobo.602.1">: Files related to the Node.js </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">execution environment</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">runner</span></strong><span class="koboSpan" id="kobo.605.1">: Global test runner interfaces that are shared between the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">execution contexts</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">util</span></strong><span class="koboSpan" id="kobo.608.1">: Miscellaneous utility functions that are used across </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">the framework</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.610.1">Besides assembling together all the self-developed packages into a cohesive design, our project also relies on external libraries. </span><span class="koboSpan" id="kobo.610.2">Here is a list of some of the dependencies that are utilized in the framework to achieve the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">feature set:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">chai</span></strong><span class="koboSpan" id="kobo.613.1">: This library allows us to quickly set up a test assertion interface to make the testing experience much nicer. </span><span class="koboSpan" id="kobo.613.2">It provides our framework with assertion interfaces</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.614.1"> useful for </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.616.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">BDD</span></strong><span class="koboSpan" id="kobo.618.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.619.1">test-driven development</span></strong><span class="koboSpan" id="kobo.620.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.621.1">TDD</span></strong><span class="koboSpan" id="kobo.622.1">). </span><span class="koboSpan" id="kobo.622.2">It provides us with </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.623.1">multiple assertion styles, and these assertion functions work in Node.js and browser environments. </span><span class="koboSpan" id="kobo.623.2">This library has an extensive plugin list that can extend its functionality. </span><span class="koboSpan" id="kobo.623.3">The source for this project can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">github.com/chaijs/chai</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">sinon</span></strong><span class="koboSpan" id="kobo.628.1">: This library allows us to provide an interface for creating test spies, stubs, and mocks. </span><span class="koboSpan" id="kobo.628.2">Enabling this feature makes our framework more suitable for testing JavaScript applications, as it enables more comprehensive unit </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">testing coverage.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">debug</span></strong><span class="koboSpan" id="kobo.631.1">: A small</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.632.1"> utility that makes it easier to develop the framework by introducing filtered debug logging. </span><span class="koboSpan" id="kobo.632.2">By namespacing the debug level after each package of our framework, it makes it easier to understand the framework’s internals as it </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">executes tests.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">eta</span></strong><span class="koboSpan" id="kobo.635.1">: This is a lightweight templating engine that helps us construct the test runner in the browser. </span><span class="koboSpan" id="kobo.635.2">It produces an HTML document with the necessary framework files and </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">test suites.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">glob</span></strong><span class="koboSpan" id="kobo.638.1">: This module enables pattern matching for test directories. </span><span class="koboSpan" id="kobo.638.2">It allows us to run a command such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">ct tests</span></strong><span class="koboSpan" id="kobo.640.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">tests</span></strong><span class="koboSpan" id="kobo.642.1"> is a directory, resulting in finding all test files for a particular directory. </span><span class="koboSpan" id="kobo.642.2">Generally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">glob</span></strong><span class="koboSpan" id="kobo.644.1"> saves us much time writing filesystem-related code by providing an easy-to-use file pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">matching system.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">yargs</span></strong><span class="koboSpan" id="kobo.647.1">: This is used as the argument parser for the framework’s CLI. </span><span class="koboSpan" id="kobo.647.2">It makes it easier for us to create a better command-line experience for the </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">test runner.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">puppeteer</span></strong><span class="koboSpan" id="kobo.650.1">: This library is included to provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">BrowserExecutor</span></strong><span class="koboSpan" id="kobo.652.1"> class with a real web-browser testing interface. </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">puppeteer</span></strong><span class="koboSpan" id="kobo.654.1"> enables headless browser testing by controlling a Chromium or Firefox instance and running tests within </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">that environment.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.656.1">These are highlights of the dependencies that we’ll use in this project. </span><span class="koboSpan" id="kobo.656.2">For some of the framework logic, we have built out our own solutions, organized within packages. </span><span class="koboSpan" id="kobo.656.3">At the same time, we are relying on external libraries to address the complexities of specific technical challenges. </span><span class="koboSpan" id="kobo.656.4">The</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.657.1"> current structure allows us to introduce new packages or expand existing ones. </span><span class="koboSpan" id="kobo.657.2">The defined abstractions also allow us to swap out external dependencies in favor of </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">other solutions.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.659.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.660.1">This chapter provided us with a walkthrough on integrating the concepts and architectural principles from earlier sections of the book to build a basic JavaScript testing framework. </span><span class="koboSpan" id="kobo.660.2">The practical approach provides us with insights into building out testing framework internals. </span><span class="koboSpan" id="kobo.660.3">Even if we do not end up coding a new testing project, it still trains our software muscles to have general knowledge of architecting something from scratch. </span><span class="koboSpan" id="kobo.660.4">Our method uses a combination of libraries and packages to enable a hybrid of standard and </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">unique features.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">We covered three parts of the framework development workflow: setting up a new project, drafting an initial design, and working through the first version of the goal brainstorming, architectural design, and implementation. </span><span class="koboSpan" id="kobo.662.2">As we put these skills into practice, the goal is to make you as a developer more comfortable with architecting, developing, and producing successful projects for others. </span><span class="koboSpan" id="kobo.662.3">In the upcoming chapters, we will focus on framework publishing and maintenance. </span><span class="koboSpan" id="kobo.662.4">We will also continue these practical exercises as we walk through building </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">more projects.</span></span></p>
</div>
</body></html>