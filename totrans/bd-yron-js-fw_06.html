<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor089"/>6</h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Building a Framework by Example</h1>
<p>This chapter combines all the insight and architectural knowledge from <em class="italic">Parts 1</em> and <em class="italic">2</em> of the book and puts it into practice. Follow along as we develop a simple JavaScript testing framework based on the patterns and best techniques we have seen so far. The practical approach will enable us to learn by example, as it is a great educational approach for software topics of this kind. The framework we build here is a new project developed specifically for this chapter. We can treat this new sample framework project as a “Hello World” exercise for JavaScript framework development. Our aim through this exercise is to train our abilities and apply them later on in real-world projects.</p>
<p>This chapter will cover the following topics for building a framework by example:</p>
<ul>
<li>First, we’ll structure our initial approach for a new framework project, including determining the goals, stakeholders, and branding for creating something from scratch. This will largely involve putting the learnings of project considerations from <a href="B19014_05.xhtml#_idTextAnchor073"><em class="italic">Chapter 5</em></a> into practice.</li>
<li>Next, we’ll learn to outline a typical initial architecture design to get our implementation of a testing framework off the ground. This includes outlining how the components fit together and the unique features of the project and its interfaces. In addition, we’ll summarize the public interfaces that are expected by developers who will be utilizing our project.</li>
<li>Finally, we’ll walk through the implementation of our testing framework based on the created design, including core feature components, command-line implementation, browser testing integration, and more.</li>
</ul>
<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Technical requirements</h1>
<p>The implemented framework code is in the book repository at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. The code for our sample framework is included in the <code>chapter6</code> directory. To follow the implementation explanation in this chapter, it is recommended to follow along with the framework files in the chapter directory.</p>
<p>To run the code, make sure to have <em class="italic">Node.js v20 or higher</em> installed (you can download it from <a href="http://nodejs.org">nodejs.org</a>). To make it easier to manage different versions of Node.js, you can use a Node.js version manager tool such as <code>nvm</code> (<a href="http://github.com/nvm-sh/nvm">github.com/nvm-sh/nvm</a>). Running <code>nvm</code> will automatically install the appropriate version of Node.js from the framework project directory, as the project is configured and tested for a particular version. Make sure to run <code>npm install</code> to fetch the project’s dependencies. Running <code>npm test</code> should output a set of passing tests. This means that your local configuration is all correctly set up. The interactive script will perform all these steps for you if you run <code>npm start</code> from the <code>chapter6</code> directory.</p>
<p>To test the frontend portion of this sample framework, please use the latest version of Chromium-based browsers or an updated version of Firefox. To debug the framework, refer to the <em class="italic">About debugging</em> section of <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>. You can use the approach as documented in that chapter.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Determining goals and stakeholders and framework branding</h1>
<p>The subject of our framework practical exercise is a new JavaScript code testing framework.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Goals</h2>
<p>The goal we will<a id="_idIndexMarker430"/> try to achieve is to provide robust test tooling for projects of variable complexity. The primary objective of testing frameworks is to provide developers with a reliable, fast, and versatile platform for verifying their code’s functionality, performance, and stability. In addition, they aim to minimize the risk of potential errors and create a seamless development experience that ultimately results in a high-quality product.</p>
<p>To accomplish these project goals, our JavaScript framework will focus on executing tests quickly and accurately, supporting various reporter output formats, and fostering a developer-friendly environment. By prioritizing ease of use and integration with other JavaScript tools and application frameworks, we will aim to make the testing process as seamless and efficient as possible. The framework will also enable cross-platform testing across Node.js and real web browser environments, ensuring that code performs consistently and as expected in various contexts.</p>
<p>A side condition of this particular project is to create a sandbox-like environment for you, the reader, by providing an extensible and more straightforward project that you can learn from. You are <a id="_idIndexMarker431"/>encouraged to run the code and play the role of a potential framework contributor.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Stakeholders</h2>
<p>The stakeholders of a <a id="_idIndexMarker432"/>new JavaScript code testing framework could include a variety of software engineers and web developers who have specific software testing needs. First and foremost, JavaScript developers can utilize this framework in their user-facing projects and include it in the development of other JavaScript software. This framework can be a full stack solution for testing code in multiple environments. In the developer community, we are trying to develop a framework that is suitable for frontend, backend, full stack developers, QA and DevOps engineers, and finally, other framework/library authors.</p>
<p>Our stakeholders can benefit from the architectural features of this project. For example, if we are testing the code in a real browser environment, the developed framework could be a good selling point for frontend engineers. The choice of the JavaScript testing feature set that we enable by building this project might also create friction or incompatibility with some engineering workflows, such as running tests in older runtimes and browsers. Thus, mainly, we are targeting a subset of developers that can live on the bleeding edge of new features and easily keep their code base up to date with the latest environments.</p>
<p>If we were developing a JavaScript code testing framework internally, our stakeholders would be the internal developers of a start-up or a bigger company. In this case, we could gather insights about which feature sets were most needed in the internal teams. In addition, particular features could be developed to target specific organizational needs. The iteration and stability of the project would depend on how it was used internally as well.</p>
<p>Both stakeholders and framework developers benefit from consistent project communication and identity. This is where our new framework can benefit a bit from adding some branding. More on that in the next section.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Framework branding</h2>
<p>Before diving into <a id="_idIndexMarker433"/>architecture and coding, spending some time on the branding and identity of our project can be beneficial for the sake of the project structure. Creating an identity around the framework is a common pattern in internal and public projects, as it clearly defines the project’s logical boundaries and provides context around the project in general. Creating an identity could be as simple as picking a temporary name for your new project. It can also be a more involved creative process as we establish a project name. The name will be useful for creating a <em class="italic">namespace</em> for our project and utilized internally by the code base and by tests/dependent projects as they load this new project. The name can, of course, be changed later with some <em class="italic">find and replace</em>, so the decision does not have to be final.</p>
<p>We will use a new framework name for our new project and repurpose it for subsequent project advancements in <em class="italic">Chapters 7</em> and <em class="italic">8</em>. We <a id="_idIndexMarker434"/>define <strong class="bold">Componium</strong> as the overarching brand for the frameworks we develop in this book. The name is a play on the word <em class="italic">Component</em>, combined with a <em class="italic">-nium</em> ending, which gives this name a technological and software sound. Besides, the name is not fully unique, as a musical instrument from 1821 shares the name with our framework: <a href="http://mim.be/en/collection-piece/componium">mim.be/en/collection-piece/componium</a>. More<a id="_idIndexMarker435"/> importantly, it is not a problem for us because there are no conflicts for this name in the JavaScript ecosystem. Choosing a namespace has to come with some uniqueness, avoiding naming conflicts with existing developer tools.</p>
<p>Continuing the creative process, in <em class="italic">Figure 6</em><em class="italic">.1</em>, you can see our framework’s logo and color scheme, which can be used in documentation and presented in the project’s visual features:</p>
<div><div><img alt="Figure 6.1: New framework name and logo" src="img/Figure_6.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: New framework name and logo</p>
<p>The testing framework will be specifically known as <em class="italic">Componium Test</em>. The addition of identity assets is beneficial to make the project more identifiable and establish a stronger brand presence in the developer community, fostering trust and recognition.</p>
<p>On the more technical side of things, creating a namespace for your project, as we did here with <em class="italic">componium</em>, can help on several occasions. Namespacing eliminates potential naming conflicts and collisions with other frameworks and helps us logically group the code base with its components for both internal and external developers. Depending on the type of framework project, creating a namespace can also make the code base approach more modular. We saw an example of this in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, where Vue.js had the approach to namespace many of its packages in a <code>vue-*</code> namespace. In addition, namespacing can help facilitate framework customizations and extensions, such as other developers contributing plugins and additions.</p>
<p>Now that we<a id="_idIndexMarker436"/> know more about creating an identity for our projects and with our branding exercise complete, we can move to the exciting part of architecting our new framework.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Architecting the new framework</h1>
<p>Now, we’ll get to the <a id="_idIndexMarker437"/>architectural part of our practical approach. So far, we know what we are building and who we are building it for. It is now time to determine the shape of our feature set and see how we can enable those features for our users. The most basic use case that we would like to cover is generating assertions for JavaScript code, as presented here:</p>
<pre class="source-code">
// basic.js
export function helloReader() {
  return "Hello reader!";
}
// tests/basic.js
import ct, { assert } from "componium-test";
import { helloReader } from "../basic.js";
ct({
  basic: function () {
    assert.strictEqual(helloReader(), "Hello reader!",
      "output is correct");
  },
});</pre>
<p>The preceding code example tests the <code>helloReader()</code> function and verifies that the correct string is returned. Starting from these basics, to take things further, we spend time on core functionality and identifying out-of-scope features first. Later, this can help drive technical decisions, as we brainstorm the set of extended features that can be suitable for our project. Our strategy consists of comparing the features offered by existing testing tools, developing unique characteristics, and contemplating which capabilities are out of the initial scope.</p>
<p>To draw some feature comparisons, we can look at some frameworks from <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. <em class="italic">Jest</em> and <em class="italic">Vitest</em> come to mind as they are frameworks comparable to what we are building in this chapter. In addition, other projects in the ecosystem are <code>jasmine</code>, <code>ava</code>, <code>tap</code>, <code>tape</code>, and <code>mocha</code>. Most of these projects provide an advanced testing interface with a specific test life cycle and different ways to create assertions. All these existing open source projects also provide a common set of core functionalities, such as executability to run the framework in different projects, different output formatting options, the ability to stub or spy on interfaces, and more.</p>
<p>In the following <a id="_idIndexMarker438"/>subsections, we will examine some of the unique features that can be implemented as part of our initial approach to the <em class="italic">Componium </em><em class="italic">Test</em> project.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Selecting features</h2>
<p>Brainstorming a list of <a id="_idIndexMarker439"/>features for a testing framework can be both exhausting and exciting. There are just so many areas to cover in terms of testing tool development, with most of the feature set covering different areas of development. In the architecting example from the beginning of this section, we listed basic test use cases, and now we can expand on them. Here are some of the additional types of functionality that could help our project provide a better feature set to its stakeholders:</p>
<ul>
<li><strong class="bold">Capable test runner</strong>: The framework exposes a test runner executable with the ability to execute a single or full suite of tests. It provides its users with a selective execution format to specify which tests to run, a feature that's useful during development and debugging situations. The test runner also allows the users to define test cases using a particular syntax.</li>
<li><strong class="bold">Cross-platform testing</strong>: The framework enables testing in different JavaScript environments, such as providing some support for Node.js and web API testing.</li>
<li><strong class="bold">Assertion types</strong>: Users are able to use different types of assertion styles, which provides flexible options for structuring tests. These different assertion styles cater to different preferences and can impact the readability and maintainability of test code. Offering a variety of assertion types allows developers to pick the one that best suits their needs and coding style.</li>
<li><strong class="bold">Test suite interface</strong>: Provide a rich interface that includes setup functions and life cycle hooks. These features are necessary for organizing and managing tests effectively. A good test suite interface enables necessary actions before and after tests or test suites, enabling a more structured approach to testing.</li>
<li><strong class="bold">Ability to stub code</strong>: Enable capabilities for spying, stubbing, and mocking of existing code to allow implementation substitution. This is a crucial feature to determine all possible <a id="_idIndexMarker440"/>ways the application code can be called. For instance, the Jest framework has the following capabilities built in: <a href="http://jestjs.io/docs/jest-object#mock-functions">jestjs.io/docs/jest-object#mock-functions</a>.</li>
<li><strong class="bold">Code coverage</strong>: Output a report of code coverage that shows a percentage of the code base that is covered by the tests.</li>
<li><code>webpack</code>, <code>rollup.js</code>, and others.</li>
<li><code>.</code> for passing tests or <code>F</code> for failures. Usually, these reporter types can be specified by the environment or flag while running the test framework executable.</li>
<li><strong class="bold">Plugin interface</strong>: Expose a plugin interface to make it possible to extend the framework feature set. For a testing framework, this could be an option to provide additional reporters or swap out built-in libraries.</li>
</ul>
<p>Besides this list of features, our framework can also focus on improving the developer experience around JavaScript features such as handling ES module environments or asynchronous behavior in tests. It may also choose to cater to many niche JavaScript use cases, such as being able to work with particular libraries and test media and graphics-related features.</p>
<p>We now have a generous list of conceivable features that will produce a reasonable foundation for our<a id="_idIndexMarker442"/> framework implementation. Part of the feature planning and development process also includes figuring out which functionality will be out of scope. This is what we will briefly cover in the following section.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Identifying out-of-scope features</h2>
<p>Even though we have<a id="_idIndexMarker443"/> identified a rich feature set, it does <a id="_idIndexMarker444"/>not cover all potential use cases of a testing framework. To further improve the ergonomics of the project, there are components that would need to be developed in the follow-up versions. In particular, this initial version aims to create a foundation for the framework that will allow us to quickly iterate and add new features. It is better to focus on creating a continuous and intuitive development environment rather than rushing a slew of features immediately. In a real-world use case, as a framework developer, it would be important to gather user feedback and address the most pressing needs of your stakeholders as you iterate on your project.</p>
<p>Here are some features and components that could serve as potential additions to follow-up releases:</p>
<ul>
<li><strong class="bold">Test watcher</strong>: Providing a test runner mode that is watching for file changes and rerunning the tests as underlying components change. This could be a welcoming feature for developers as it provides real-time feedback during the development process.</li>
<li><strong class="bold">Clock and date manipulation</strong>: An additional improvement on top of existing mocking functionality, built-in clock and date mocking in JavaScript projects can make it much easier to freeze or manipulate dates. Providing this interface further improves ergonomics.</li>
<li><strong class="bold">Snapshot testing</strong>: Involves capturing and comparing the output of complex components. It can save time by simplifying assertion methods and separating the expected output source from the test file structure.</li>
<li><strong class="bold">Retries</strong>: The ability to retry failed tests could improve the ergonomics in different testing environments. This feature requires a careful approach to make sure that only expected failures are retried and the test runner does not report passing results for broken tests.</li>
</ul>
<p>There are definitely more components that can be developed for such frameworks, but the feature collection <a id="_idIndexMarker445"/>we have identified is enough <a id="_idIndexMarker446"/>for us to construct the architectural design outline. The next part of the development process is to pick out the most consequential parts from the feature set and devise an architecture to make this functionality a reality.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Designing the outline</h2>
<p>We need to introduce<a id="_idIndexMarker447"/> an executable interface to enable the test<a id="_idIndexMarker448"/> runner features with cross-platform testing behavior. This interface, implemented as a command-line tool, must handle users’ running options within different environments. Finally, to fulfill our main goal of asserting code behavior, the execution modes must return the testing assertions’ status.</p>
<p>As the executable triggers the tests, the tests will emit their status and events. The runner needs to respect the life cycles of those tests and subscribe to the events related to the testing workflow. Potential events could include passing or failing state or bubbling up assertion errors if those occur.</p>
<p>Creating a design diagram such as the one seen here makes it easier to see how the components that enable the feature set can interact with one another:</p>
<div><div><img alt="Figure 6.2: Initial design diagram" src="img/Figure_6.2_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Initial design diagram</p>
<p>In <em class="italic">Figure 6</em><em class="italic">.2</em>, the flow of execution starts from the executable or the command line, defined on the left side of the diagram. In this case, the executable is the <code>ct</code> command, which is short for <em class="italic">Componium Test</em>. If the developer uses the command line as an entry point, then <a id="_idIndexMarker449"/>the <strong class="bold">CLI handler</strong> parses through the provided flags and options, determining if the tests will be running in the Node.js environment or the web browser environment. This will enable the cross-platform testing capabilities we evaluated during the feature planning process.</p>
<p>In the Node.js <a id="_idIndexMarker450"/>context, the <code>NodeExecutor</code> class can parse the provided test <a id="_idIndexMarker451"/>files and run their assertions, logging the real-time status of the execution and outputting the final results of the tests. The <code>chapter6/componium-test/packages/node/executor.js</code> file has the contents of <code>NodeExecutor</code>. The code is programmed to spawn worker environments for each test suite and run assertions in the test cases. Later, a summary of passing and failing tests is collected.</p>
<p>In the browser context, the <code>BrowserExecutor</code> class relies on an external web browser bridge, provided by the <code>puppeteer</code> library. It creates a communication channel between the test runner and a real browser environment, queues the expected test suites, and uses a similar interface to capture test assertion and life cycle output. The browser environment also has distinct running methods, such as the <em class="italic">headless</em> and <em class="italic">headful</em> modes, where the browser is either hidden or displayed to the user while the tests run. This feature requires integrating the library and the test runner executable. This executor can be found in <code>chapter6/componium-test/packages/browser/executor.js</code>. This code works in a similar way to the Node.js method, but due to the fact that it runs in the web browser context, it has to send the results of the test suite back to the Node.js test runner running in the terminal process. The environmental difference makes the technical design of these two executors vastly different.</p>
<p>The diagram in <em class="italic">Figure 6</em><em class="italic">.2</em> also outlines potential support for running tests directly as a script file via the <code>node</code> CLI. In this case, the tests bypass the <code>ct</code> interface and directly output the results as the script runs. It is a handy feature that supports direct testing workflows.</p>
<p>The outline and diagram in <em class="italic">Figure 6</em><em class="italic">.2</em> do not capture the full details of the test runner workflow, but they are helpful for our development process. As you develop your own frameworks, you will find that creating such artifacts can help you be more efficient and precise in <a id="_idIndexMarker452"/>architecting different kinds of software solutions. With the architecture <a id="_idIndexMarker453"/>and features outlined, we can continue to the interface design part of the process.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Designing the interfaces and API</h2>
<p>Two main interfaces<a id="_idIndexMarker454"/> are used as the point of interaction with our framework: the main framework module and the test runner executable. Developers must be acquainted with these interfaces through API documentation, examples, and more. In addition, introducing breaking changes or modifications to these APIs’ functionality will affect projects already integrated into the framework.</p>
<p>The first interface we are looking at is the imported <code>componium-test</code> framework module. This module exports the main testing object that can accept the testing function <a id="_idIndexMarker455"/>through <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>). The module also exports additional framework interfaces, such as the assertion and mocking libraries. Here’s an example of using this module:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code snippet 1</p>
<pre class="source-code">
import framework interfaces
import ct, { assert, fake, replace } from "componium-test";
import Calculator from "../fixtures/calculator.js";
  // fixture to test
let calc;
ct({
  describe: "Calculator Tests",
  beforeEach: () =&gt; {
    calc = new Calculator();
  },
  multiply: function () {
    assert.equal(calc.multiply(3, 2), 6, "3 * 2 is 6");
  },
  mockMultiply: function () {
    const myFake = fake.returns(42);
    replace(calc, "multiply", myFake);
    assert.strictEqual(calc.multiply(1, 1), 42,
      "fake interface is working");
  },
  afterEach: () =&gt; {
    console.log("called afterEach");
  }
});</pre>
<p>The preceding code <a id="_idIndexMarker456"/>example of using the module in the test file can be found in the <code>tests/calc-tests.js</code> path of the framework. In this code, we see the inclusion of basic assertions for a sample <code>Calculator</code> script; those are made possible by importing the <code>assert</code> function. Based on the expected feature set, we have the test life cycle methods, such as <code>beforeEach</code>. Additionally, mocking functionality that replaces the return point of <code>multiply</code> is enabled by the <code>fake</code> and <code>replace</code> functions.</p>
<p>The second interface is the command-line utility provided when the users install the framework. This is a test runner that enables interaction with a large number of test suites:</p>
<pre class="source-code">
&gt; ct --help
ct [&lt;tests&gt;...]
Options:
     --version   Show version number                       [boolean]
 -b, --browser   Run the test in a web browser             [boolean]
     --keepAlive Keep the web browser alive to debug tests [boolean]
      --help     Show help                                 [boolean]</pre>
<p>The executable supports a variety of options to enable the expected feature set. In addition, the <code>--help</code> flag can also display available commands and their shortcuts. The <code>ct</code> executable accepts one or more test suites as arguments, visible through the <code>ct [&lt;tests&gt;...]</code> notation. The presence of the <code>ct</code> executable is expected by developers after installing the framework from JavaScript’s <code>npm</code> package registry.</p>
<p>We now have knowledge<a id="_idIndexMarker457"/> of these two developer-level APIs—the test executable and the test interface. We can now proceed to the implementation of features that power the functionality behind those two framework features.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Implementing the new frameworks</h1>
<p>The implementation <a id="_idIndexMarker458"/>process guides us further on how frameworks in JavaScript can be created. In this implementation process, we’ll see the different entry points of a test runner combined with distinguishable features. This section roughly follows the diagram in <em class="italic">Figure 6</em><em class="italic">.2</em>, where we outlined the framework design. Now that we know our features and have a rough idea of the project’s architecture, let’s broadly outline the steps of the internal implementation of this project, as follows:</p>
<ol>
<li>Determine how the designed test suite configuration can be implemented within the Node.js environment.</li>
<li>Create internal packages to execute the test suites in different environments.</li>
<li>Implement the infrastructure for real web browser-mode testing.</li>
<li>Collect results from the test runner and output them to the user.</li>
</ol>
<p>Following <em class="italic">steps 1</em> to <em class="italic">4</em>, we begin our implementation by examining how our tests are structured and executed. In the preceding <code>Calculator Tests</code> snippet, we can examine the JavaScript object structure, consisting of a <code>ct</code> functional call and accepting a test suite object. Some special properties include describing the test suite name and running life cycle methods such as <code>before</code> and <code>after</code>. The execution life cycle of these methods can<a id="_idIndexMarker459"/> be seen in the following diagram:</p>
<div><div><img alt="Figure 6.3: Test life cycle" src="img/Figure_6.3_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Test life cycle</p>
<p>To enable the <code>ct</code> function call, the test suites can access the <code>componium-test</code> package and our framework’s public interfaces, such as the assertion library features. We can see an example of including the framework in the <code>calc-tests.js</code> code block in <em class="italic">Code snippet 1</em>. Besides importing the framework features, the test file imports the code we aim to test.</p>
<p>Importing our framework in the Node.js context will require properly exporting it as part of the package. To do that, we define an <code>exports</code> property in our <code>package.json</code> file. This allows projects to configure <em class="italic">Componium Test</em> as a dependency to import the module by name:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Code Snippet 2</p>
<pre class="source-code">
"exports": {
  ".": "./packages/runner/tester.js",
  "./package.json": "./package.json"
},</pre>
<p>The preceding configuration pinpoints our <code>tester.js</code> file, which handles most of the test-running logic, referenced from our <code>runner</code> package.</p>
<p>Once the test object is loaded into the framework, it is directed to the appropriately named <code>packages/runner/tester.js</code> file. The <code>tester.js</code> file is where most of the testing happens, including the life cycle methods, executed at appropriate times, alongside the main test function. Provided that a test suite can have many tests, the tester proceeds to<a id="_idIndexMarker460"/> call through all the provided functions. To measure the speed of the tests, we can rely on the <code>performance</code> APIs (<a href="http://developer.mozilla.org/en-US/docs/Web/API/Performance/now">developer.mozilla.org/en-US/docs/Web/API/Performance/now</a>). These APIs provide high-resolution timestamps to provide us with data on how long the tests take to run.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Testing functionality</h2>
<p>Enabling an excellent <a id="_idIndexMarker461"/>testing experience through detailed test assertions, our project needs an assertion library that can be used within the newly written tests. The assertion interfaces should include equality comparison, value size comparison, object value evaluation, and others.</p>
<p>To focus on broad framework development, we will import an external test assertion library<a id="_idIndexMarker462"/> called <code>should</code>, <code>expect</code>, and <code>assert</code>. Subsequently, we can develop our own assertion infrastructure or replace Chai with a different library, which we can potentially develop by ourselves.</p>
<p>As the testing script executes our provided tests, our handy assertion library will throw an exception if any comparison functions are unsuccessful, as follows:</p>
<pre class="source-code">
AssertionError: 3 * 2 is 6: expected 1.5 to equal 6
    at multiply (file:///Users/componium-test/tests/
      calc-tests.js:20:12)
    at ComponiumTest.test (file:///Users/
      componium-test/packages/runner/tester.js:92:15) {
  showDiff: true,
  actual: 1.5,
  expected: 6,
  operator: 'strictEqual'
}</pre>
<p>The preceding output<a id="_idIndexMarker463"/> shown is a snippet of a failure in one of the tests, where the imported <code>Calculator</code> module does not correctly perform the <code>multiply</code> operation. The framework needs to handle this type of code behavior. In the case of assertion or other errors, the test runner needs to signal back to the running process of at least one or more failed tests. If at least something flips the <code>errorOccurred</code> flag, then it will result in our testing node process exiting with a failure status.</p>
<p>Besides the assertion library, we want to provide mocking and stubbing functionality in the developed framework. Using a similar pattern where we include the Chai.js library and expose it as a test API interface, we will<a id="_idIndexMarker464"/> include the <strong class="bold">Sinon.js</strong> (<a href="http://sinonjs.org">sinonjs.org</a>) library, which has a rich interface for creating test stubs, spies, and mocks. It is an excellent fit for our project because it supports many JavaScript environments and has been battle-tested in other projects for many years. The presence of this library will make it easier for developers to increase code coverage and write more effective tests.</p>
<p>In the code snippet (<em class="italic">Code snippet 1</em>) of the example test file, we use Sinon.js’ functions to create a fake <code>mockMultiply</code> return point. The Sinon.js methods are also abstracted away from direct usage. Instead, they are exposed as part of the <code>componium-test</code> package. Users can access the library’s mocking, faking, and stubbing mechanisms configured in the framework’s <code>packages/mock/lib.js</code> mock package.</p>
<p>The inclusion of<a id="_idIndexMarker465"/> powerful assertions and mocking libraries, exposed in a simple interface, allows our framework to gain rich functionality from the first version.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Creating a command-line tool</h2>
<p>In the previous <a id="_idIndexMarker466"/>sections, we talked about making our <code>tester.js</code> file the imported entry point to run tests. To match the expected feature set, the framework needs to support running multiple sets of tests from a given directory. This means supporting a number of suites of a given format in bulk. This means that the number of test suites will be structured in the following format:</p>
<pre class="source-code">
import ct, { assert } from "componium-test";
ct({...});</pre>
<p>To get this bulk execution feature, we need to create a command-line tool for our framework. To integrate with the Node.js command-line environment, we need to provide a <code>bin</code> key in the <code>package.json</code> file to export the command-line file, like so:</p>
<pre class="source-code">
"bin": {
  "ct": "bin/ct.js"
},</pre>
<p>The binary shortcut that we export is just <code>ct</code> to make it really easy to execute the framework commands from other projects. To develop the binary file, we can rely on the <code>yargs</code> library (<a href="http://yargs.js.org">yargs.js.org</a>) to handle user input, parsing the provided process arguments from the <code>process.argv</code> variable. See the <code>packages/bin/ct.js</code> file for details on the executable structure. There are several features to remember with the structure of the executable, focusing on developing a good interface and enabling particular features of the framework, as follows:</p>
<ul>
<li>Include the interpretation in the file’s first line with <code>#!/usr/bin/env node</code>. This signals to the system shell to use the node executable for this file. This is known as the <em class="italic">Shebang</em> (<a href="http://wikipedia.org/wiki/Shebang_%28Unix%29">wikipedia.org/wiki/Shebang_%28Unix%29</a>), where an interpreter executable is provided within the script.</li>
<li>Keep the binary package logic focused on the code related to parsing command-line flags and ensuring a good CLI experience. This includes supporting the <code>--help</code> flag, providing shortcuts to flags, and testing for edge cases of how an executable can be used. The flags or options of the CLI should follow the double-hyphenated (<code>--</code>) structure or a single one (<code>-</code>) for short options.</li>
<li>The executable should follow the standard rules of CLIs. The CLI process should exit with an appropriate status code and indicate if the process failed. This is especially important in the case of the test runner that we are working with in this chapter.</li>
</ul>
<p>Depending on the execution mode, Node.js, or the browser, the CLI file (<code>packages/runner/cli.js</code>) chooses the right executor class, providing this class with a list of target files. The <code>NodeExecutor</code> and <code>BrowserExecutor</code> classes have the job of processing all the test files and evaluating if any of the tests in those files fail any assertions. In the Node.js testing environment, we use the <code>NodeExecutor</code> class to run the tests. The<a id="_idIndexMarker467"/> class spawns new worker threads to execute test suites concurrently. The main purpose of this interface is to run tests for multiple target files and return an overall pass or fail result.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Browser testing workflow</h2>
<p>Another feature we <a id="_idIndexMarker468"/>are exploring in the developed framework is the ability to execute tests in a real web browser environment. To enable this, the CLI accepts a <code>–browser</code> flag that switches the running mode of the test framework. The entry point to this interface for a developer may look something like this: <code>ct –browser test/some_test.js</code>. Depending on the approach to the framework executables, we can also introduce a separate <code>ct-browser</code> executable to directly execute the test in the browser context without worrying about extra parameters. To implement this functionality, the framework relies on the <code>puppeteer</code> library to spawn a new browser instance and establish a communication channel with it.</p>
<p><em class="italic">Figure 6</em><em class="italic">.4</em> shows the debugging view of the browser test runner workflow:</p>
<div><div><img alt="Figure 6.4: Debugging view of the browser test runner workflow" src="img/Figure_6.4_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Debugging view of the browser test runner workflow</p>
<p>This operation mode is helpful to get access to the tests if they are failing in the browser. This environment allows developers to set breakpoints in their code and debug the tests. The <code>BrowserExecutor</code> file in <code>packages/browser/executor.js</code> takes care of launching a new instance of a real web browser. The communication channel it establishes can rely on messaging from the console or through more advanced <code>window.postMessage</code> function calls.</p>
<p>We can use a simple Node.js server paired with a small templating library called <code>eta</code> to create a browser<a id="_idIndexMarker469"/> page that executes the tests. We can create a valid HTML document with the templating library that includes the dependencies and test files. To properly load the framework files, the page relies on <code>importmap</code> (<a href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap">developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap</a>) to map ES module names to URLs. The code is illustrated in the following snippet:</p>
<pre class="source-code">
&lt;script type="importmap"&gt;
 {
   "imports": {
     "componium-test": "/runner/tester.js",
     "chai": "/chai.js",
     "sinon": "/sinon.js"
   }
 }
&lt;/script&gt;</pre>
<p>The initial implementation of the frontend test runner has a minimal interface, but it can be further developed to show a more interactive dashboard of tests. This can be a potential feature investment, adding additional frontend features if a test runner is used heavily in browser-related testing. The import map structure can be found in the <code>chapter6/componium-test/packages/browser/views/layout.eta</code> file. Besides the<a id="_idIndexMarker470"/> framework files, this file also consists of parsing a dynamic list of test suites that need to be included in the frontend. This makes it possible to include and run a number of test suites in the frontend testing harness.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Testing the framework</h2>
<p>As we develop the testing <a id="_idIndexMarker471"/>framework, we must ensure its reliability and correctness. However, using another external framework for testing might not be ideal, and we can’t use the framework itself to test its features as it is still under development. We use simple approaches to address this challenge, enabling unit, snapshot, and <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) testing<a id="_idIndexMarker472"/> to ensure our project works correctly.</p>
<p>Unit testing of our project can primarily rely on the existing test runner implementation. However, we need to integrate snapshot testing, which includes comparing the test runner’s output with snapshotted versions of the desired output. As we refactor certain features, we should verify with the snapshot test to detect unintended changes. Including such tests gives us more confidence as we push new updates and improvements to the project. In particular, unit tests that require more attention are related to the exit status codes of the test runner.</p>
<p>Another important testing addition is the inclusion of E2E tests that cover the whole framework workflow. This includes installing packages, importing the testing package, and executing tests. These tests are made possible by creating a separate testing package that includes our framework as a dependency, as follows:</p>
<pre class="source-code">
"dependencies": {
 "componium-test": "file:.."
}</pre>
<p>The sample testing project includes <code>componium-test</code> as a dependency in its <code>package.json</code> file and points to the parent directory to load the files. These E2E tests can be found in the <code>e2e</code> directory of the project. In <a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, we will explore additional ways to<a id="_idIndexMarker473"/> improve and validate project quality.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Framework packages</h2>
<p>Shown in <em class="italic">Figure 6</em><em class="italic">.5</em> are the initial<a id="_idIndexMarker474"/> packages of the project. They are situated in the <code>packages</code> directory, similar to how many other frameworks choose to organize their projects:</p>
<div><div><img alt="Figure 6.5: The framework packages of the project" src="img/Figure_6.5_B19014.png.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: The framework packages of the project</p>
<p>These packages are logically split by their responsibility. Here is a brief outline of what they do:</p>
<ul>
<li><code>assert</code>: Contains the assertion library-related configuration</li>
<li><code>bin</code>: Contains the executable, which is exported by the <code>package.json</code> file</li>
<li><code>browser</code>: Files related to test execution in the browser environment</li>
<li><code>views</code>: Template files that make it possible to load tests in the frontend context</li>
<li><code>mock</code>: Mocking library-related features</li>
<li><code>node</code>: Files related to the Node.js execution environment</li>
<li><code>runner</code>: Global test runner interfaces that are shared between the execution contexts</li>
<li><code>util</code>: Miscellaneous utility functions that are used across the framework</li>
</ul>
<p>Besides assembling together all the self-developed packages into a cohesive design, our project also relies on external libraries. Here is a list of some of the dependencies that are utilized in the framework to achieve the desired feature set:</p>
<ul>
<li><code>chai</code>: This library allows us to quickly set up a test assertion interface to make the testing experience much nicer. It provides our framework with assertion interfaces<a id="_idIndexMarker475"/> useful for <code>github.com/chaijs/chai</code>.</li>
<li><code>sinon</code>: This library allows us to provide an interface for creating test spies, stubs, and mocks. Enabling this feature makes our framework more suitable for testing JavaScript applications, as it enables more comprehensive unit testing coverage.</li>
<li><code>debug</code>: A small<a id="_idIndexMarker477"/> utility that makes it easier to develop the framework by introducing filtered debug logging. By namespacing the debug level after each package of our framework, it makes it easier to understand the framework’s internals as it executes tests.</li>
<li><code>eta</code>: This is a lightweight templating engine that helps us construct the test runner in the browser. It produces an HTML document with the necessary framework files and test suites.</li>
<li><code>glob</code>: This module enables pattern matching for test directories. It allows us to run a command such as <code>ct tests</code> where <code>tests</code> is a directory, resulting in finding all test files for a particular directory. Generally, <code>glob</code> saves us much time writing filesystem-related code by providing an easy-to-use file pattern matching system.</li>
<li><code>yargs</code>: This is used as the argument parser for the framework’s CLI. It makes it easier for us to create a better command-line experience for the test runner.</li>
<li><code>puppeteer</code>: This library is included to provide the <code>BrowserExecutor</code> class with a real web-browser testing interface. <code>puppeteer</code> enables headless browser testing by controlling a Chromium or Firefox instance and running tests within that environment.</li>
</ul>
<p>These are highlights of the dependencies that we’ll use in this project. For some of the framework logic, we have built out our own solutions, organized within packages. At the same time, we are relying on external libraries to address the complexities of specific technical challenges. The<a id="_idIndexMarker478"/> current structure allows us to introduce new packages or expand existing ones. The defined abstractions also allow us to swap out external dependencies in favor of other solutions.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Summary</h1>
<p>This chapter provided us with a walkthrough on integrating the concepts and architectural principles from earlier sections of the book to build a basic JavaScript testing framework. The practical approach provides us with insights into building out testing framework internals. Even if we do not end up coding a new testing project, it still trains our software muscles to have general knowledge of architecting something from scratch. Our method uses a combination of libraries and packages to enable a hybrid of standard and unique features.</p>
<p>We covered three parts of the framework development workflow: setting up a new project, drafting an initial design, and working through the first version of the goal brainstorming, architectural design, and implementation. As we put these skills into practice, the goal is to make you as a developer more comfortable with architecting, developing, and producing successful projects for others. In the upcoming chapters, we will focus on framework publishing and maintenance. We will also continue these practical exercises as we walk through building more projects.</p>
</div>
</body></html>