- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming Declaratively – A Better Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to now, we haven’t really been able to appreciate the possibilities of **functional
    programming** (**FP**) as it pertains to working in a higher-level, declarative
    fashion. In this chapter, we will correct this and start producing shorter, more
    concise, and easier-to-understand code, by using some **higher-order functions**
    (**HOFs**) —that is, functions that take functions as parameters, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce()` and `reduceRight()` to apply an operation to a whole array, reducing
    it to a single result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()` to transform one array into another by applying a function to each
    of its elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flat()` to make a single array out of an array of arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap()` to mix together mapping and flattening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach()` to simplify writing loops by abstracting the necessary looping
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll also be able to perform searches and selections with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()` to pick some elements from an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find()` and `findIndex()` to search for elements that satisfy a condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of predicates, `every()` and `some()`, to check an array for a Boolean
    test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these functions will let you work more declaratively, and you’ll see that
    your focus will shift to what you need to do and not so much to how it’s going
    to be done; the dirty details are hidden inside our functions. Instead of writing
    a series of possibly nested loops, we’ll focus on using functions as building
    blocks to specify our desired result.
  prefs: []
  type: TYPE_NORMAL
- en: We will use these functions to work with events in a declarative style, as we’ll
    see in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design
    Patterns*, when we use the **observer** pattern. We will also be able to work
    in a *fluent* fashion, in which the output of a function becomes the input of
    the next one, a style we will look at later.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first set of operations that we are going to consider works on an array
    and processes it in the base of a function to produce certain results. There are
    several possible results: a single value with the `reduce()` operation, a new
    array with `map()`, or just about any kind of result with `forEach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Caring about inefficiency
  prefs: []
  type: TYPE_NORMAL
- en: If you google around, you will find some articles declaring that these functions
    are inefficient because a loop done by hand can be faster. This, while possibly
    true, is practically irrelevant. Unless your code really suffers from speed problems
    and you can determine that the slowness derives from using these HOFs, trying
    to avoid them using longer code, with a higher probability of bugs, simply doesn’t
    make much sense.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by considering the preceding list of functions in order, beginning
    with the most general of all, which, as we’ll see, can even be used to emulate
    the rest of the transformations in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Reducing an array to a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer this question: how many times have you had to loop through an array,
    performing an operation (say, summing) to produce a single value (maybe the sum
    of all the array values) as a result? Probably many, many, many times. This kind
    of operation can usually be implemented functionally by applying `reduce()` and
    `reduceRight()`. Let’s start with the former!'
  prefs: []
  type: TYPE_NORMAL
- en: To fold or not to fold
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for some terminology! In usual FP parlance, we speak of `reduce()` is
    `reduceRight()` is correspondingly known as **foldr**. In category theory terms,
    both operations are **catamorphisms**: the reduction of all the values in a container
    down to a single result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner workings of the `reduce()` function are illustrated in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The workings of the reduce() operation](img/Figure_5.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The workings of the reduce() operation
  prefs: []
  type: TYPE_NORMAL
- en: See how `reduce()` traverses the array, applying a reducing function to each
    element and the accumulated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should you always try to use `reduce()` or `reduceRight()` instead of hand-coded
    loops? The following points might answer this question:'
  prefs: []
  type: TYPE_NORMAL
- en: All the aspects of loop control are automatically taken care of, so you don’t
    even have the possibility of an off-by-one mistake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization and handling of the result values are also done implicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you work really hard at being impure and modifying the original array,
    your code will be free of side-effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we can `reduce()` an array, let’s see some of its practical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summing an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common example of the application of `reduce()`, usually seen in all
    textbooks and on all web pages, is the summing of all of the elements of an array.
    So, to keep with tradition, let’s start with precisely this example!
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce an array, you must provide a **dyadic** function (a function with
    two parameters; **binary** would be another name for that) and an initial value.
    In our case, the function will sum up its two arguments. Initially, the function
    will be applied to the provided initial value and the first element of the array.
    For us, the initial value to provide is a zero, and the first result will be the
    first element itself. Then, the function will be applied again, this time, to
    the result of the previous operation and the second element of the array, and
    so the second result will be the sum of the first two elements of the array. Progressing
    in this fashion along the whole array, the final result will be the sum of all
    its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t actually need the sum definition—you could have just written `myArray.reduce((x,y)
    => x+y, 0)`—however, when written in this fashion, the meaning of the code is
    clearer: you want to reduce the array to a single value by `sum`-ming all its
    elements. (Would we be forgetting data types with this? No; TypeScript can deduce
    all the implied types on its own.)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing out the loop, initializing a variable to hold the result
    of the calculations, and going through the array doing the sums, you just declare
    which operation should be performed. This is what I meant when I said that programming
    with functions such as those we’ll see in this chapter allows you to work more
    declaratively, focusing on what rather than how.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also even use `reduce()` without providing the initial value: if you
    skip it, the first value of the array will be used, and the internal loop will
    start with the second element of the array; however, be careful if the array is
    empty and you skipped providing an initial value, as you’ll get a runtime error!
    See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the reducing function to see how it progresses through its calculations
    by just including a little bit of impurity!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the first sum was done by adding the initial value (`0`) and
    the first element of the array, how that result was used in the second addition,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What’s in a name?
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the reason for the *foldl* name seen previously (at least, its ending,
    *l*) should now be clear: the reducing operation proceeds from left to right,
    from the first element to the last. You may wonder, however, how it would have
    been named if it had been defined by a right-to-left language (such as Arabic,
    Hebrew, Farsi, or Urdu) speaker!'
  prefs: []
  type: TYPE_NORMAL
- en: This example is common and well known; let’s do something more complicated.
    As we’ll find out, `reduce()` will be quite useful for many different objectives!
  prefs: []
  type: TYPE_NORMAL
- en: Calculating an average
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s do a bit more work. How do you calculate the average of a list of numbers?
    If you were explaining this to someone, your answer would surely be something
    such as *sum all the elements in the list and divide that by the number of elements*.
    In programming terms, this is not a procedural description (you don’t explain
    how to sum elements or traverse the array) but rather a declarative one since
    you say what to do, not how.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform that description of the calculation into an almost self-explanatory
    function (In the *Averaging arrays* section of the next chapter, we’ll extend
    arrays to include an averaging method, based on this code.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `average()` follows what a verbal explanation would be: sum
    the elements of the array, starting from 0, and divide by the array’s length—simpler:
    impossible!'
  prefs: []
  type: TYPE_NORMAL
- en: Not-so-safe reducing
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, you could also have written `arr.reduce(sum)`
    without specifying the initial value (`0`) for the reduction; it’s even shorter
    and closer to the verbal description of the required calculation. This, however,
    is less safe, because it would fail (producing a runtime error) should the array
    be empty. So, it’s better to always provide the starting value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t, however, the only way of calculating the average. The reducing
    function also gets passed the index of the current position of the array as well
    as the array itself, so you could do something different from last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the current index (and, obviously, having access to the array’s length),
    we can do some trickery: in this case, our reducing `sumOrDivide()` function always
    sums values, but at the end of the array, it throws in a division so that the
    average value of the array will be returned. This is slick, but from the point
    of view of legibility, we can agree that the first version we saw was more declarative
    and closer to the mathematical definition than this second version.'
  prefs: []
  type: TYPE_NORMAL
- en: Impurity warning!
  prefs: []
  type: TYPE_NORMAL
- en: Getting the array and the index means you could also turn the function into
    an impure one. Avoid this! Anybody who sees a `reduce()` call will automatically
    assume it’s a pure function and will surely introduce bugs when using it.
  prefs: []
  type: TYPE_NORMAL
- en: This example and the previous one required calculating a single result, but
    it’s possible to go beyond this and calculate several values in a single pass.
    Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating several values at once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What would you do if you needed to calculate two or more results instead of
    a single value? This would seem to be a case for providing a clear advantage for
    standard loops, but there’s a trick that you can use. Let’s yet again revisit
    the average calculation. We could do it the old-fashioned way by looping and simultaneously
    summing and counting all the numbers. Well, `reduce()` only lets you produce a
    single result, but there’s no reason you can’t return an object with as many fields
    as desired, as we did in the *Impure functions* section in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,*
    *Behaving Properly*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Scrutinize the code carefully. We need two variables: one for the sum and one
    for the count of all numbers. We provide an object as the initial value for the
    accumulator, with two properties set to `0`, and our reducing function updates
    those two properties. After getting the final result with both `sum` and `count`,
    we divide to get the desired average.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, there are options other than using an object. You could also produce
    any other data structure; let’s see an example with a tuple. The resemblance is
    pretty obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To be frank, I think it’s way more obscure than the solution with the object.
    Consider this an alternative (and not well-recommended) way of calculating many
    values simultaneously!
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen several examples of the use of `reduce()`, so it’s high time
    to meet a variant of it, `reduceRight()`, which works similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Folding left and right
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complementary `reduceRight()` method works just as `reduce()` does, only
    starting at the end and looping until the beginning of the array. (Read more about
    `reduceRight()` at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight).)
    For many operations (such as the calculation of averages that we saw previously),
    this makes no difference, but there are some cases in which it will. See *Figure
    5**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall be seeing a clear case of this in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*; let’s go with a simpler example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The reduceRight() operation works the same way as reduce(),
    but in reverse order](img/Figure_5.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The reduceRight() operation works the same way as reduce(), but
    in reverse order
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to implement a function to reverse a string. (And, obviously,
    also that we don’t know that JavaScript already provides a `reverse()` method!)
    A solution could be to transform the string into an array by using `split()`,
    then reversing that array, and finally using `join()` to make it whole again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution works (and yes, it can be shortened, but that’s not the point
    here), but let’s do it in another way, just to experiment with `reduceRight()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we didn’t need to specify data types for the reducing function; just
    like earlier in this chapter, TypeScript was able to figure them out. Also, if
    you like to re-use code, look at *Question 5.2*!
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous examples, you can also get an idea: if you first apply `reverse()`
    to an array and then use `reduce()`, the effect will be the same as if you had
    just applied `reduceRight()` to the original array. There is only one point to
    take into account: `reverse()` alters the given array, so you would be causing
    an unintended side-effect by reversing the original array! The only way out would
    be to first generate a copy of the array and only then do the rest. Too much work,
    so it’s best to use `reduceRight()`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can draw another conclusion, showing a result we had foretold:
    it is possible, albeit more cumbersome, to use `reduce()` to simulate the same
    result as `reduceRight()`—and in later sections, we’ll also use it to emulate
    the other functions in the chapter. Let’s now move on to another common and powerful
    operation: **mapping**.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying an operation – map()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing lists of elements and applying some kind of operation to each of
    them is a quite common pattern in computer programming. Writing loops that systematically
    go through all the elements in an array or collection, starting at the first and
    looping until finishing with the last, and performing some kind of process on
    each of them is a basic coding exercise, usually learned in the first days of
    all programming courses. We already saw one such kind of operation in the previous
    section with `reduce()` and `reduceRight()`; let’s now turn to a new one, called
    `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, a `map()` function transforms an array of inputs into an array
    of outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Names, names, names…
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more terminology: we would say that an array is a **functor** because
    it provides a mapping operation with some prespecified properties, which we shall
    see later. And, in category theory, which we’ll talk about a little in [*Chapter
    12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*, the mapping
    operation itself would be called a **morphism**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner workings of the `map()` operation can be seen in *Figure 5**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The map() operation transforms each element of the input array
    by applying a mapping function](img/Figure_5.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The map() operation transforms each element of the input array
    by applying a mapping function
  prefs: []
  type: TYPE_NORMAL
- en: More maps available
  prefs: []
  type: TYPE_NORMAL
- en: 'The jQuery library provides a function, `$.map(array, callback)`, that is similar
    to the `map()` method. Be careful, though, because there are important differences.
    The jQuery function processes the undefined values of the array, while `map()`
    skips them. Also, if the applied function produces an array as its result, jQuery
    flattens it and adds each of its individual elements separately, while `map()`
    just includes those arrays in the result. Underscore, and Ramda also provide similar
    functions. Finally, JavaScript itself provides an alternative way of doing `map()`:
    check out the `Array.from()` method at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
    and pay special attention to its second argument!'
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using `map()` over using a straightforward loop?
  prefs: []
  type: TYPE_NORMAL
- en: First, you don’t have to write any loops, so that’s one less possible source
    of bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you don’t even have to access the original array or the index position,
    even though they are there for you to use if you really need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, a new array is produced, so your code is pure (although, of course,
    if you really want to produce side effects, you can!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are only two caveats when doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Always return something from your mapping function. If you forget this, then
    you’ll just produce an array filled with `undefined` values, because JavaScript
    always provides a default `return undefined` for all functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input array elements are objects or arrays, and you include them in the
    output array, then JavaScript will still allow the original elements to be accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, there’s a restriction. In JavaScript, `map()` is basically available only
    for arrays (you can read more about this at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map));
    however, in the *Extending current data types* section in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will learn how to make it available for other
    basic types, such as numbers, Booleans, strings, and even functions. Also, libraries
    such as Lodash, Underscore, and Ramda, provide similar functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: As we did earlier with `reduce()`, let’s now look at some examples of the use
    of `map()` for common processes so that you’ll better appreciate its power and
    convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with a simple example. Suppose that we have some geographic data
    (as shown in the following snippet) related to some South American countries and
    the coordinates (latitude and longitude) of their capitals. Let’s say that we
    want to calculate the average position of those cities. (No, I don’t have a clue
    why we’d want to do that.) How would we go about it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A lot of negativity?
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering whether all the data is negative and if so, why, it’s
    because the countries shown here are all south of the Equator and west of the
    Greenwich Meridian. However, some South American countries, such as Colombia and
    Venezuela, have positive latitudes. We’ll return to these data a little later
    when we study the `some()` and `every()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would want to use our `average()` function (which we developed earlier in
    this chapter), but there is a problem: that function can only be applied to an
    array of *numbers*, and what we have here is an array of *objects*. We can, however,
    do a trick: we can focus on calculating the average latitude (we can deal with
    the longitude later, in a similar fashion). We can map each element of the array
    to its latitude, and we would then have an appropriate input for `average()`.
    The solution would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Mapping an array to extract data is powerful, but you must be careful. Let’s
    now look at a case that seems right but produces incorrect results!
  prefs: []
  type: TYPE_NORMAL
- en: Parsing numbers tacitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working with `map()` is usually far safer and simpler than looping by hand,
    but some edge cases may trip you up. Say you received an array of strings representing
    numeric values and wanted to parse them into actual numbers. Can you explain the
    following results?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s analyze the results. When we used `parseFloat()` to get floating-point
    results, everything was OK; however, when we wanted to truncate the results to
    integer values with `parseInt()`, the output was really awry, and weird `NaN`
    values appeared. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in a problem with tacit programming. (We have already seen
    some uses of tacit programming in the *An unnecessary mistake* section of [*Chapter
    3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*, and we’ll
    see more in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*.)
    When you don’t explicitly show the parameters to a function, it’s easy for there
    to be oversights. Look at the following code, which will lead us to the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the unexpected behavior with `parseInt()` is that this function
    can also receive a second parameter—namely, the radix to use when converting the
    string into a number. For instance, a call such as `parseInt("100010100001", 2)`
    will convert a binary number of `100010100001` into a decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `parseInt()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt),
    where the radix parameter is explained in detail. You should always provide it
    because some browsers might interpret strings with a leading zero to be octal,
    which would once again produce unwanted results.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens when we provide `parseInt()` to `map()`? Remember that `map()`
    calls your mapping function with three parameters: the array element value, its
    index, and the array itself. When `parseInt` receives these values, it ignores
    the array but assumes that the provided index is actually a radix, and `NaN` values
    are produced since the original strings are not valid numbers in the given radix.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, some functions can lead you astray when mapping, and you now know what to
    look for. Let’s keep enhancing the way we work by using ranges to write code that
    would usually require a hand-written loop.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now turn to a helper function, which will come in handy for many uses.
    We want a `range(start,stop)` function that generates an array of numbers, with
    values ranging from `start` (inclusive) to `stop` (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Why `fill(0)`? Undefined array elements are skipped by `map()`, so we need to
    fill them with something or our code will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your range
  prefs: []
  type: TYPE_NORMAL
- en: Libraries such as Underscore and Lodash provide a more powerful version of our
    `range()` function, letting us go in ascending or descending order and also specifying
    the step to use—as in `_.range(0, -8, -2)`, which produces `[0, -2, -4, -6]`—but
    for our needs, the version we wrote is enough. Refer to the *Questions* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we use it? In the following section, we’ll see some uses for controlled
    looping with `forEach()`, but we can redo our factorial function by applying `range()`
    and then `reduce()`. The idea of this is to generate all the numbers from 1 to
    `n` and then multiply them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to check the border cases, but the function also works for zero;
    can you see why? The reason for this is that the produced range is empty: the
    call is `range(1,1)`, which returns an empty array. Then, `reduce()` doesn’t do
    any calculations and returns the initial value (`1`), which is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we’ll have the opportunity to use `range()` to generate source code; check out
    the *Currying with eval()* and *Partial application with* *eval()* sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use these numeric ranges to produce other kinds of ranges. For example,
    should you need an array with the alphabet, you could certainly (and tediously)
    write `["A", "B", "C"`... up to ...`"X", "Y", "Z"]`. A simpler solution would
    be to generate a range with the ASCII codes for the alphabet and map those to
    letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `charCodeAt()` to get the ASCII codes for the letters and `String.fromCharCode(x)`
    to transform the ASCII code into a character.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping is very important and often used, so let’s now analyze how you could
    implement it on your own, which could help you develop code for more complex cases.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating map() with reduce()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw how `reduce()` could be used to implement `reduceRight()`.
    Now, let’s see how `reduce()` can also be used to provide a polyfill for `map()`
    (not that you will need it because nowadays, browsers offer both methods, but
    it will give you more of an idea of what you can achieve with these tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our own `myMap()` is a one-liner but can be hard to understand. We apply the
    function to each element of the array and use `concat()` to append the result
    to a result array (which is initially empty). When the loop finishes working with
    the input array, the result array will have the desired output values. Let’s first
    see a plain JavaScript version before getting to data typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We apply the mapping function to each array element, one by one, and we concatenate
    the result to the accumulated output array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this with an array and a simple function. We will use both the original
    `map()` method and `myMap()`, and the results should match! Our mapping function
    will return double its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first log shows the expected result, produced by `map()`. The second output
    gives the same result, so it seems that `myMap()` works! And the final output
    is just to check that the original input array wasn’t modified in any way; mapping
    operations should always produce a new array. See *Question 5.3* for testing our
    `myMap()` function more thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review our `myMap()` function and add typing. The needed data types are
    more complex, and we’ll have a generic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `myMap()` function receives an array of elements of type `T` and an `fn()`
    mapping function that transforms its `T` argument into an `R`-type result. The
    result of this mapping is an array of `R`-type elements. Examine the accumulator
    function by yourself; is its typing understandable?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try a different mapping function to verify that our typing is correct.
    We’ll use one that returns strings instead of numbers – it just adds dashes before
    and after its input, to produce a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: OK, it seems that our complex type definitions were correct!
  prefs: []
  type: TYPE_NORMAL
- en: All the previous examples in the chapter focused on simple arrays. But what
    happens if things get more complicated, say if you had to deal with an array whose
    elements were arrays themselves? Fortunately, there’s a way out of that. Let’s
    move on.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with arrays of arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have worked with an array of (single) values as an input, but what
    would happen if your input was an array of arrays? If you consider this to be
    a far-fetched case, there are many possible scenarios where this could apply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For some applications, you could have a table of distances, which in JavaScript
    requires an array of arrays: `distance[i][j]` would be the distance between `i`
    and `j`. How could you find the maximum distance between any two points? Finding
    the maximum is simple with a common array, but how do you deal with an array of
    arrays?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A more complex example, also in a geographic vein, is that you could query
    a geographic API for cities matching a string, and the response could be an array
    of countries, each with an array of states, each itself with an array of matching
    cities: an array of arrays of arrays!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, you could want a single array with all distances, and in
    the second, an array with all cities; how would you manage this? A new operation,
    **flattening**, is required; let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ES2019, two operations were added to JavaScript: `flat()`, which we’ll look
    at now, and `flatMap()`, which we’ll look at later. It’s easier to show what they
    do than to explain—bear with me!'
  prefs: []
  type: TYPE_NORMAL
- en: No flat() allowed?
  prefs: []
  type: TYPE_NORMAL
- en: 'As often happens, not all browsers have been updated to include these new methods,
    and Microsoft’s Internet Explorer and others were deficient in this regard, so
    for web programming, a polyfill will be required. As usual, for updated compatibility
    data, check out the *Can I use?* site, in this case, at [caniuse.com/#feat=array-flat](http://caniuse.com/#feat=array-flat).
    A piece of good news: since September 2018, all major browsers provide this feature
    natively!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flat()` method creates a new array, concatenating all elements of its
    subarrays to the desired level, which is, by default, `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how could we use this function to solve our problems? Using `flat()`, spreading,
    and `Math.max()` answers the first question (as we saw back in the *Spread* section
    of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional*; we
    could have used the `maxArray()` function we wrote back then), and we can also
    use `reduce()` for variety. Suppose we have the following table of distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can find our maximum distance in a couple of ways: we either flatten
    the array, spread it, and use `Math.max()`, or flatten the array and use reducing
    to explicitly find the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go back to the second question. Suppose we queried a geographic API for
    cities that have `"LINCOLN"` (upper or lower case) in their names and got the
    following answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the list of cities can be done by applying `map()` and `flat()`
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have seen how to use `flat()` to flatten an array; let’s now see how to use
    `flatMap()`, an interesting mixture of `flat()` and `map()`, to further streamline
    our coding and even further shorten our preceding second solution! (And if you
    think this exercise wasn’t hard enough and its output was sort of lame, try out
    *Question 5.10* for a more challenging version!)
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and flattening – flatMap()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basically, what `flatMap()` does is first apply a `map()` function and then
    apply `flat()` to the result of the mapping operation. This is an interesting
    combination because it lets you produce a new array with a different number of
    elements. (With the normal `map()` operation, the output array would be precisely
    the same length as the input array). If your mapping operation produces an array
    with two or more elements, then the output array will include many output values,
    and if you produce an empty array, the output array will include fewer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a (somehow nonsensical) example. Assume that we have a list of
    names, such as `"Winston Spencer Churchill"`, `"Abraham Lincoln"`, and `"Socrates"`.
    Our rule is that if a name has several words, exclude the initial one (the first
    name, we assume) and separate the rest (last names), but if a name is a single
    word, drop it (assuming the person has no last name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the output array has a different number of elements than the
    input array: just because of this, we could consider `flatMap()` to be an upgraded
    version of `map()`, even including some aspects of `filter()`, like when we excluded
    single names.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to a simple example. Keeping with the Lincolnian theme from
    the last section, let’s count how many words are in Lincoln’s Gettysburg address,
    given as an array of sentences. By the way, this address is usually considered
    to be 272 words long, but the version I found doesn’t produce that number! This
    may be because there are five manuscript copies of the address written by Lincoln
    himself, plus another version transcribed from shorthand notes taken at the event.
    In any case, I will leave the discrepancy to historians and stick to coding!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `flatMap()` to split each sentence into an array of words and then
    see the length of the flattened array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go back to the problem with the cities. If we notice that each `map()`
    was followed by `flat()`, an alternative solution is immediately apparent. Compare
    this solution with the one we wrote in the *Flattening an array* section; it’s
    essentially the same but conflates each `map()` with its following `flat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen the new operations. (And, yes, it’s perfectly possible to solve
    the problems in this section without mapping, but that wouldn’t be a good example
    for this section! See *Question 5.11* for an alternative to the word counting
    problem.) Let’s now learn how to emulate these operations should you not have
    them readily available.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating flat() and flatMap()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen how `reduce()` could be used to emulate `map()`. Let’s
    now see how to work out equivalents for `flat()` and `flatMap()` to get more practice.
    We’ll also throw in a recursive version, a topic we’ll return to in [*Chapter
    9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*. As was mentioned
    earlier, we are not aiming for the fastest or smallest or any particular version
    of the code; instead, we want to focus on using the concepts we’ve been looking
    at in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Totally flattening an array can be done with a recursive call. We use `reduce()`
    to process the array element by element, and if an element happens to be an array,
    we recursively flatten it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Flattening an array to a given level (not infinity; let’s leave that for later)
    is easy if you can first flatten an array one level. We can do this either by
    using spreading or with `reduce()`. Let’s write a `flatOne()` function that flattens
    just a single level of an array. There are two versions of this; pick whichever
    you prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using either of these two functions, we can flatten an array of several levels,
    and we can do this in two different ways. Our two versions of a `flat()` function
    use our previous `flatOne()` and `flatAll()` functions, but the first one only
    uses standard looping, while the second one works in a fully recursive way. Which
    one do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I think the recursive one is nicer and more aligned with the theme of this book.
    Still, it’s up to you, really—although if you don’t feel comfortable with the
    ternary operator, then the recursive version is definitely not for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to polyfill these functions (despite our suggestions not to), it’s
    not complex, and is similar to what we did with the `average()` method previously.
    I took care not to create any extra methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our `flatOneX()` and `flatAllX()` methods are just copies of what we developed
    before, and you’ll recognize the code of our previous `flat2()` function at the
    end of our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, emulating `flatMap()` is simple in itself, and we can skip it because
    it’s just a matter of applying `map()` first, and then `flat()`; no big deal!
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to work with arrays in several ways, but sometimes what you
    need isn’t really well served by any of the functions we have seen. Let’s move
    on to more general ways of looping, for greater power.
  prefs: []
  type: TYPE_NORMAL
- en: More general looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding examples that we’ve seen all loop through arrays, doing some work.
    However, sometimes, you need to loop, but the required process doesn’t really
    fit `map()` or `reduce()`. So, what can be done in such cases? There is a `forEach()`
    method that can help. (Read more about it at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).)
  prefs: []
  type: TYPE_NORMAL
- en: 'You must provide a callback that will receive the value, the index, and the
    array on which you are operating. (The last two arguments are optional.) JavaScript
    will take care of the loop control, and you can do whatever you want at each step.
    For instance, we can program an object copying method by using `Object` methods
    to copy the source object attributes one at a time and generate a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is: we create a `copy` object with the same prototype as the original
    `obj`, and then for each property in the original, we define an equivalent property
    in the copy. The function’s signature makes clear that the input and output types
    are the same. One particular detail: given the loop we are writing, we know for
    sure that `Object.getOwnPropertyDescriptor(obj, prop)` will be a string (and not
    `undefined`), but TypeScript cannot tell; adding `as string` solves this.'
  prefs: []
  type: TYPE_NORMAL
- en: Shallow or deep?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, of course, we could have written `myCopy={...myObj}`, but where’s the
    fun in that? It would be better, but I needed a nice example to use `forEach()`
    with. Sorry about that! Also, there are some hidden inconveniences in that code,
    which we’ll explain in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*, when we try to get frozen, unmodifiable objects. Just a hint: the new
    object may share values with the old one because we have a shallow copy, not a
    deep one. We’ll learn more about this later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `range()` function that we defined previously, we can also perform
    common loops of the `for(let i=0; i<10; i++)` variety. We might write yet another
    version of factorial (!) using that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition of factorial really matches the usual description: it generates
    all the numbers from 1 to *n* inclusive and multiplies them—simple!'
  prefs: []
  type: TYPE_NORMAL
- en: For greater generality, consider expanding `range()` so it can generate ascending
    and descending ranges of values, possibly stepping by a number other than 1\.
    This would allow you to replace all the loops in your code with `forEach()` loops.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have seen many ways of processing arrays to generate results,
    but other objectives may be of interest, so let’s now move on to logical functions,
    which will also simplify our coding needs.
  prefs: []
  type: TYPE_NORMAL
- en: Logical HOFs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we have been using HOFs to produce new results. However, some other
    functions produce logical results by applying a predicate to all the elements
    of an array. (By the way, we’ll see much more about HOFs in the next chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Many meanings
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of terminology: the word **predicate** can be used in several senses
    (as in predicate logic), but for us, in computer science, it has the meaning of
    *a function that returns true or false*. OK, this isn’t a very formal definition,
    but it’s enough for our needs. For example, saying that we will filter an array
    depending on a predicate means that we get to decide which elements are included
    or excluded depending on the predicate’s result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these functions implies that your code will become shorter: you can get
    results corresponding to a whole set of values with a single line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will encounter a common need to filter the elements of an array according
    to a specific condition. The `filter()` method lets you inspect each element of
    an array in the same fashion as `map()`. The difference is that instead of producing
    a new element, the result of your function determines whether the input value
    will be kept in the output (if the function returned `true`) or if it will be
    skipped (if the function returned `false`). Also, similar to `map()`, `filter()`
    doesn’t alter the original array but produces a new array with the chosen items.
    You can read more on the `filter()` function at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).
  prefs: []
  type: TYPE_NORMAL
- en: 'See *Figure 5**.4* for a diagram showing the input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy
    a given predicate](img/Figure_5.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy
    a given predicate
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to remember when filtering an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`, and since that’s a falsy value, the output will be an empty array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The copy that is made is shallow**: If the input array elements are objects
    or arrays, then the original elements will still be accessible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get into more detail by seeing a practical example of `filter()` and then
    looking at how we could implement that functionality by using `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: A filter() example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a practical example. Suppose a service has returned a JSON object,
    which has an array of objects containing an account’s `id` value and `balance`.
    How can we get the list of IDs *“in the red”*, with a negative balance? The input
    data could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We could get the delinquent accounts with something like the following. You
    can check that the value of the `delinquent` variable correctly includes the two
    IDs of accounts with a negative balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, given that the filtering operation produced yet another array,
    if you just wanted the accounts IDs, you could get them by mapping the output
    to only get the `id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you didn’t care for the intermediate result, a one-liner would have
    worked as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Filtering is a very useful function, so now, to get a better handle on it, let’s
    see how you can emulate it, which you could use as a basis for more sophisticated,
    powerful functions of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating filter() with reduce()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we did before with `map()`, we can also create our own version of `filter()`
    by using `reduce()`. The idea is similar: loop through all the elements of the
    input array, apply the predicate to it, and if the result is `true`, add the original
    element to the output array. When the loop is done, the output array will only
    have those elements for which the predicate was `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function is generic; it takes an array of elements of type `T` and a predicate
    that accepts a `T`-type parameter and generates a new array of elements of type
    `T`. We can quickly see that our function works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The output is the same pair of accounts that we saw earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, instead of filtering all the elements of an array, you want to find
    an element that satisfies a given predicate. There are a couple of functions that
    can be used for this, depending on your specific needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find()` searches through the array and returns the value of the first element
    that satisfies a given condition, or `undefined` if no such element is found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findIndex()` performs a similar task, but instead of returning an element,
    it returns the index of the first element in the array that satisfies the condition,
    or `-1` if none were found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The similarity to `includes()` and `indexOf()` is clear; these functions search
    for a specific value instead of an element that satisfies a more general condition.
    We can easily write equivalent one-liners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the geographic data we used earlier, we could easily find a given
    country by using the `find()` method. For instance, let’s get data for Brazil
    ( `"BR"`); it just takes a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t use the simpler `includes()` method because we have to delve into
    the object to get the field we want. If we wanted the position of the country
    in the array, we would have used `findIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: OK, this was easy! What about a special case, which could even be a trick interview
    question? Read on!
  prefs: []
  type: TYPE_NORMAL
- en: A special search case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you had an array of numbers and wanted to run a sanity check, studying
    whether any of them were `NaN`. How would you do this? A tip: don’t try checking
    the types of the array elements—even though `NaN` stands for not a number, `typeof
    NaN` *is* `"number"`. You’ll get a surprising result if you try to search in an
    obvious way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s going on here? It’s a bit of interesting JavaScript trivia: `NaN` is
    the only value that isn’t equal to itself. Should you need to look for `NaN`,
    you’ll have to use the new `isNaN()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'ESLint would help with the `use-isnan` rule: see eslint.org/docs/latest/rules/use-isnan
    for more on this. *Figure 5**.5* shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – ESLint prevents you from a NaN-related mistake](img/Figure_5.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – ESLint prevents you from a NaN-related mistake
  prefs: []
  type: TYPE_NORMAL
- en: This was a particular case worth knowing about; I had to deal with it once!
    Now, let’s continue as we have done previously, by emulating the searching methods
    with `reduce()` so that we can see more examples of the power of that function.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating find() and findIndex() with reduce()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the other methods, let’s finish this section by studying how to implement
    the methods we showed by using the omnipotent `reduce()`. This is a good exercise
    to get accustomed to working with HOFs, even if you will never actually use these
    polyfills!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find()` method requires a bit of work. We start the search with an `undefined`
    value, and if we find an array element so that the predicate is `true`, we change
    the accumulated value to that of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In terms of performance, there’s a slight difference with the standard `find()`
    method. The language specification (at [tc39.es/ecma262/#sec-array.prototype.find](http://tc39.es/ecma262/#sec-array.prototype.find))
    shows that the search stops as soon as an element satisfies the search. Our code,
    however, keeps processing the rest of the array (because that’s how `reduce()`
    works), although it doesn’t evaluate the predicate again; can you see why?
  prefs: []
  type: TYPE_NORMAL
- en: 'For `findIndex()`, we must remember that the callback function receives the
    accumulated value, the array’s current element, and the index of the current element,
    but other than that, the equivalent expression is quite similar to the one for
    `find()`; comparing them is worth the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The initial accumulated value is `-1` here, which will be the returned value
    if no element fulfills the predicate. Whenever the accumulated value is still
    `-1`, but we find an element that satisfies the predicate, we change the accumulated
    value to the array index.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we are now done with searches: let’s move on to considering higher-level
    predicates that will simplify testing arrays for a condition, but always in the
    declarative style we’ve been using so far.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-level predicates – every() and some()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last functions we will consider greatly simplify going through arrays to
    test for conditions. These functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`every()`, which is `true` if and only if every element in the array satisfies
    a given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`some()`, which is `true` if at least one element in the array satisfies the
    predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we could quickly check our hypothesis about all the countries
    having negative coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to find equivalents to these two functions in terms of `reduce()`,
    the two alternatives show nice symmetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first folding operation evaluates `fn(y)` and ANDs the result with the previous
    tests; the only way the final result will be `true` is if every test succeeds.
    The second folding operation is similar, but ORs the result with the previous
    results and will produce `true` unless every test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean duality
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Boolean algebra, the alternative formulations for `every()` and
    `some()` exhibit duality. This duality is the same kind that appears in the `x
    === x && true` and `x === x || false` expressions; if `x` is a Boolean value,
    and we exchange `&&` and `||`, and also `true` and `false`, then we transform
    one expression into the other, and both are valid.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to check for a given Boolean condition. Let’s finish
    by seeing how to check a negative condition by inventing a method of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Checking negatives – none()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wanted, you could also define `none()` as the complement of `every()`.
    This new function would be `true` only if none of the elements of the array satisfied
    the given predicate. The simplest way of coding this would be by noting that if
    no elements satisfy the condition, then all elements satisfy the negation of the
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn it into a method by modifying the array prototype, as we saw earlier.
    It’s still a bad practice, but it’s what we have until we start looking into better
    methods for composing and chaining functions, which we will do in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to use `function()` instead of an arrow function for the same reasons
    we saw on earlier occasions: we need `this` to be correctly assigned. We also
    had to add a global definition like when we used averages so that TypeScript wouldn’t
    object to the newly added `none()` method. Other than that, it’s simple coding,
    and we now have a `none()` method available for all arrays. In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we will see yet other ways of negating a function by writing
    an appropriate HOF of our own.'
  prefs: []
  type: TYPE_NORMAL
- en: In this and the preceding section, we worked with everyday problems and saw
    how to solve them declaratively. However, things change a bit when you start working
    with `async` functions. We will see in the following section that new solutions
    will be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with async functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the examples and code we studied in the previous sections were meant to
    be used with common functions, specifically meaning *not* `async` ones. When you
    want to do mapping, filtering, reducing, and so on, but the function you are using
    is an `async` one, the results may surprise you. To simplify our work and not
    deal with actual API calls, let’s create a `fakeAPI(delay, value)` function that
    will delay a while before returning the given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also have a function to display what `fakeAPI()` returns so that we can
    see that things are working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the modern `async` and `await` features from ES2017 to simplify
    our code, and we are avoiding the top-level `await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are previsible: we get the `START` text, then about 1 second (1,000
    milliseconds) later, the result of the fake API call (`229`), and finally the
    `END` text. What could go wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: Top-level await
  prefs: []
  type: TYPE_NORMAL
- en: Why are we using the immediate invocation pattern we saw in [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*? The reason is that the use of `await` at the top
    level has been available for Node.js since version 14.8 (August 2020) and browsers
    since 2021, so it’s not yet widespread. So, as you can only use `await` within
    an `async` function, I opted to go with an IIFE here for major compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The critical problem is that all the functions we saw earlier in this chapter
    are not `async`-*aware*, so they won’t work as you’d expect. Let’s start looking
    at this.
  prefs: []
  type: TYPE_NORMAL
- en: Some strange behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a simple quiz: are results what you expected? Let’s look at
    a couple of examples of code involving `async` calls, and we’ll see some unexpected
    results. First, let’s look at a typical straightforward sequence of `async` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you’ll get the following results, which are indeed what
    you would expect—a `START SEQUENCE` text, four individual lines with the results
    of the fake API calls, and a final `END SEQUENCE` text. Nothing special here—everything
    is fine!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go for an alternative second version, which you’d expect to be equivalent
    to the first one. The only difference here is that we are using looping to do
    the four API calls; it should be the same, shouldn’t it? (We could also have used
    a `forEach()` loop with the `range()` function that we saw earlier, but that makes
    no difference.) I kept using an IIFE, though in this particular case, it wasn’t
    needed; can you see why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This code certainly looks equivalent to the first one, but it produces something
    entirely different!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `END FOREACH` text appears before the results of the API calls. What’s
    happening? The answer is what we mentioned before: methods similar to `forEach()`
    and the like are meant to be used with standard, sync function calls and behave
    strangely with `async` function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: The key concept is that `async` functions always return promises, so after getting
    the `START FOREACH` text, the loop actually creates four promises (which will
    eventually be resolved at some point), *but without waiting for them*, and our
    code goes on to print the `END` `FOREACH` text.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is not only with `forEach()` but also affects all other similar
    methods. Let’s see how we can work around this situation and write `async`-aware
    functions to let us keep working in a declarative fashion, as we did earlier in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Async-ready looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we cannot directly use methods such as `forEach()`, `map()`, and the like,
    we’ll have to develop new versions of our own. Let’s see how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over async calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `async` calls return promises, we can emulate `forEach()` with `reduce()`
    by starting with a resolved promise and chaining to it the promises for each value
    in the array. The `then()` methods will be called in the proper order, so the
    results will be correct. The following piece of code manages to get the right,
    expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As `forEachAsync()` returns a promise, we must remember to await it before showing
    the final text message. Other than not forgetting all the `await` statements,
    the code is similar to what we build using `forEach()` with the crucial difference
    being that this does work as expected!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping async calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Can we use the other functions? Writing `mapAsync()`, a version of `map()`
    that can work with an `async` mapping function, is simple because you can take
    advantage of `Promise.all()` to create a promise out of an array of promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The structure of the solution is similar to the `forEachAsync()` code. As before,
    we must remember to `await` the result of `mapAsync()` before continuing the process.
    Other than that, the logic is straightforward, and the results are as expected;
    the mapping function delays for a while and returns 10 times its input argument,
    and we see the correct output is produced.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with async calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filtering with an `async` function is a tad more complicated. We will have
    to use `mapAsync()` to produce an array of `true` or `false` results and then
    use the standard `filter()` method to pick values out of the original array depending
    on what the `async` filtering function returned. Let’s try out a simple example,
    calling the API and accepting only even results utilizing a `fakeFilter()` function,
    which, for our example, accepts even numbers and rejects odd ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The needed `async` filtering code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result of the mapping of `async` calls is a Boolean array (`arr2`),
    which we then use with `filter()` to select elements from the original array of
    values (`arr`); this can be tricky to understand!
  prefs: []
  type: TYPE_NORMAL
- en: Reducing async calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, finding an equivalent for `reduce()` is a bit more complex, but not
    so much after the other functions that we’ve seen. The key idea is the same as
    for `forEachAsync()`: each function call will return a promise, which must be
    awaited in order to update the accumulator in an upcoming `then()`. We set up
    this iteration with an initial promise that immediately resolves to the initial
    value for the accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the reducing, let’s use an `async` `fakeSum()` function that will sum
    the API-returned values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the critical detail: in our reducing function, we must first `await` the
    value of the accumulator and only afterward `await` the result of our `async`
    function. This is an important point you must not miss: since we are reducing
    in an `async` fashion, getting the accumulator is also an `async` matter, so we
    need to `await` both the accumulator and the new API call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result shows four intermediate values and the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: By looking at these equivalents, we have seen that `async` functions, despite
    producing problems with the usual declarative methods that we studied at the beginning
    of the chapter, may also be handled by similar new functions of our own, so we
    can keep the new style even for these cases. Even if we have to use a somewhat
    different set of functions, your code will still be declarative, tighter, and
    clearer; an all-around win!
  prefs: []
  type: TYPE_NORMAL
- en: Working with parallel functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript provides concurrency through `async` functions, meaning that several
    tasks can go on at the same time, even if a single CPU is doing all the jobs.
    **Web workers** (for the frontend) and **worker threads** (for the backend) allow
    processing in parallel in a different core, for better performance. This can offload
    work from the main thread and solve potential problems, in line with our FP approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll see how to avoid bottlenecks in frontend and backend
    programming by using workers in functional ways, along the lines of the previous
    sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unresponsive pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s return to our Fibonacci slow-performing code from the *Memoization* section
    in the previous chapter. Suppose we want to create a web page that will allow
    users to enter a number and calculate the corresponding Fibonacci number, as in
    *Figure 5**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A Fibonacci calculator](img/Figure_5.6_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A Fibonacci calculator
  prefs: []
  type: TYPE_NORMAL
- en: The code for this page is very basic—and no, I’m not even trying to do any styling;
    that’s not the problem here!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The script code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding Fibonacci number is calculated and shown when the user enters
    a number and clicks on the **Locally** button, but what happens if a fairly large
    number (say, around 50) is entered? *Figure 5**.7* illustrates the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – A long-running process eventually blocks the browser](img/Figure_5.7_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – A long-running process eventually blocks the browser
  prefs: []
  type: TYPE_NORMAL
- en: As the code runs, the page becomes totally unresponsive, and you cannot click
    anywhere or enter a new number. Furthermore, if a process requires too much processing
    time, the browser will think there’s a problem and offer the user to kill the
    page… not what we want!
  prefs: []
  type: TYPE_NORMAL
- en: What’s the solution? We want to offload the calculation to a worker, which will
    run in parallel, freeing the browser. Let’s see how we’d set this up in not a
    particularly functional way!
  prefs: []
  type: TYPE_NORMAL
- en: A frontend worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Workers (see developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API for web
    workers and nodejs.org/api/worker_threads.html for Node.js worker threads) work
    in similar ways. They are plain JavaScript code that can listen to messages, and
    after doing their work, they respond to their caller by sending another message.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Fibonacci calculation, the following would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the code provides all the interaction between the caller and
    the worker. On getting a message, `e`, its `e.data` value is passed to the `fib()`
    function, and the result is posted back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'How would this be used? *Figure 5**.8* shows the result we try to achieve.
    We now want to allow two ways of calculating Fibonacci numbers: locally, as before,
    subject to lengthy processing time problems, or in parallel, by offloading the
    job to a worker.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Calculating Fibonacci numbers by using workers as an option](img/Figure_5.8_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Calculating Fibonacci numbers by using workers as an option
  prefs: []
  type: TYPE_NORMAL
- en: 'The new code is as follows; we’ll highlight the additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The new script file is just like the previous one, with some additions at the
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The new `Parallelly` button calls the corresponding `parallelly()` function.
    This function gets the number that the user entered and posts it via a message
    to the worker that had been created earlier. The `onmessage` method of that worker
    receives the calculated result and shows it onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, the user can ask for any Fibonacci number, and the window
    will remain responsive, and no warning will pop up for the user to close the page;
    see *Figure 5**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The page remains responsive even as calculations take a long
    time](img/Figure_5.9_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The page remains responsive even as calculations take a long time
  prefs: []
  type: TYPE_NORMAL
- en: OK, using workers clearly helps if you have lots of calculations to perform
    at the frontend; let’s see a similar implementation for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: A backend worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see a quick example of a backend worker, as we could use with Node.js
    or similar. The example will be very bare-bones; in real life, we’d include route
    definitions and much more, but we want to focus on worker creation and usage here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our worker is similar to the web worker; the differences are easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The idea is precisely the same; when the `message` event occurs, we call `fib()`
    to calculate the corresponding Fibonacci number, and we use `postMessage()` to
    send it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The caller code would be simple too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The code is totally analogous to the frontend code. We create a worker (with
    the `new Worker()` call), we post a message to it with `postMessage()`, and we
    listen to the worker’s `message` event. When we receive the computed result, we
    display it, and `terminate()` the worker. Running this code produces the following
    simple result—the last line takes a while to appear!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We have seen how to use workers in event-oriented programming, but this isn’t
    particularly suited to our desired FP way of working; let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Workers, FP style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Workers are appropriate for FP programming for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Workers run in separate contexts, so they cannot interact with the DOM or global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: All communication is done through messages; otherwise, workers are separated
    from their caller.
  prefs: []
  type: TYPE_NORMAL
- en: Data passed to and from workers is a copy; it is serialized before it is passed
    and deserialized when received. Even if the worker were to modify the arguments
    it received, that wouldn’t cause any problem for the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can work with events, but it would be better to wrap workers in promises
    so we can apply the `async` functions we developed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Events or promises?
  prefs: []
  type: TYPE_NORMAL
- en: Workers can send multiple messages to their caller. If this is the case, a promise
    won’t be a good idea because it will be resolved after the first result, disregarding
    future messages. In most cases, a single result is expected, so promises are OK,
    but keep in mind there are other possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A direct way to wrap a worker would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `callWorker` object we create is a promise that will resolve when the worker
    sends back a result. Results are as expected: the `START` text, the `AWAITED`
    result from the worker, and the `END` text. Note that we are using a point-free
    style for processing the `message` event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These code examples work well, but they have a performance issue: every time
    you call them, a worker is created (meaning that its JavaScript code must be read,
    parsed, and processed), so there will be delays. Let’s think about ways to avoid
    that.'
  prefs: []
  type: TYPE_NORMAL
- en: Long-living pooled workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Workers can stay unterminated and will be able to receive new messages and reply
    to them. Messages get queued, so if you need to use the same worker more than
    once at the same time, there will be a logical delay; calls will go out sequentially.
    If you need a worker and it’s free, you can call it directly, but if you need
    it and it’s occupied, it makes sense to create a new worker. We’ll keep a pool
    of threads, and whenever a call comes in, we’ll check whether there’s an available
    worker to deal with it or whether we need to create a new worker first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to do this. First, we’ll need a pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PoolEntry` objects will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `worker` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename corresponding to the path with which the worker was created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value with which it was called the last time we used this worker (just for
    logging; we can do without it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the `inUse` flag to show whether it’s available or not. `pool` is just an array
    of `PoolEntry` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need a function that will allow us to call a worker; let’s name it `workerCall()`.
    We’ll have to specify the filename of the function to call, and the value to pass
    to it. The function will first see whether there’s an appropriate available free
    worker (with the same filename and not in use) in a very declarative fashion;
    if no worker of this kind is found, it will create a new one. Then, the worker
    will be called by using a promise, as in the previous section, and when a result
    comes, the worker will be marked as not in use, ready for a new call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how this works with our previous Fibonacci worker, plus a new random
    one that delays a while before returning a random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of running this code are as follows—but I disabled the `"Resolving"`
    logging line since I was also logging output in another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The results of Fibonacci calls come in order; this is logical since we know
    their calculation time grows. The 3 calls to the random worker take a bit longer,
    but less than the calculation of the 44th Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t ask for the 11th Fibonacci number until the result for
    the 10th had come in. Our pool correctly detected it had an available worker to
    use, and it didn’t create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: You could explore several extra ideas (see the *Questions* section at the end
    of this chapter), but we achieved an efficient solution that let us run functional
    code in parallel with good performance; a nice win!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started working with HOFs to show a more declarative way
    of working with shorter, more expressive code. We went over several operations:
    we used `reduce()` and `reduceRight()` to get a single result from an array, `map()`
    to apply a function to each element of an array, `forEach()` to simplify looping,
    `flat()` and `flatMap()` to work with arrays of arrays, `filter()` to pick elements
    from an array, `find()` and `findIndex()` to search in the arrays, and `every()`
    and `some()` (plus a made-up `none()`) to verify general logic conditions. We
    then considered some unexpected situations when you deal with `async` functions,
    and we wrote special functions for those cases. Finally, we showed how to do parallel
    work functionally for extra performance.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we
    will continue working with HOFs, but we will write our own ones to gain more expressive
    power for our coding.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5.1 `filter()` → `map()` → `reduce()` sequence is quite common (even though
    sometimes you won’t use all three), and we’ll come back to this in the *Functional
    design patterns* section of [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*,
    Implementing Design Patterns*. The problem here is how to use those functions
    (and no others!) to produce an unordered list of elements (`<ul>...</ul>`) that
    can later be used onscreen. Your input is an array of characters such as the following
    (does the list date me?), and you must produce a list of each name that corresponds
    to chess or checkers players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be something like the following (although it doesn’t matter
    if you don’t generate spaces and indentation). It would be easier if you could
    use, say, `join()`, but in this case, it won’t be allowed; only the three functions
    mentioned can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '5.2 **More formal testing**: In some preceding examples, such as those in the
    *Emulating map() with reduce()* section, we didn’t write actual unit tests but
    were satisfied with doing some console logging. Can you write appropriate unit
    tests instead?'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 `reverseString2()` function, we used a summing function for the reduction,
    but we already had written a `sum()` function in the *Summing an array* section;
    couldn’t we use it here? Why not? How can we solve that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 5.4 `reverseString2()` function (see the previous question) if we summed `x`
    and `y` the reverse way, writing this instead?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 5.5 `range()` function we saw here has many uses but lacks a bit of generality.
    Can you expand it to allow for descending ranges, as in, `range(10,1)`? (What
    should the last number in the range be?) Could you also include a step size to
    specify the difference between consecutive numbers in the range? With this, `range(1,10,2)`
    would produce `[1, 3, 5,` `7, 9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 `range()` function. Instead of first generating a whole array of numbers
    and then processing them, a generator-based solution generates the range numbers
    one at a time. Can you provide such an implementation?
  prefs: []
  type: TYPE_NORMAL
- en: '5.7 `map(x => String.fromCharCode(x))`, you had written `map(String.fromCharCode)`?
    Can you explain the different behavior? Hint: we have seen a similar problem elsewhere
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.8 `\n` stands for the newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 5.9 `flat1()` and `flat2()` work properly if applied to arrays with empty places,
    such as `[22, , 9, , , 60, , ]`. Why do they work?
  prefs: []
  type: TYPE_NORMAL
- en: '5.10 **Producing better output**: Modify the cities query to produce a list
    of strings that includes not only the name of the city but the state and country
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.11 **Old-style code only!**: Can you rewrite the word-counting solution without
    using any mapping or reducing? This is more of a JavaScript problem than an FP
    one, but why not?'
  prefs: []
  type: TYPE_NORMAL
- en: 5.12 `someArray`, and apply the following `filter()` to it, which at first sight
    doesn’t even look like valid JavaScript code. What will be in the new array, and
    why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 5.13 `fact4(0)` produce the correct result, i.e., 1? Why, or why not?
  prefs: []
  type: TYPE_NORMAL
- en: 5.14 `...Async()` functions are not methods; can you modify them and add them
    to `Array.prototype` so that we can write, for example, `[1,2,3,4].mapAsync(…)`?
    And by the way, will chaining work with your solution?
  prefs: []
  type: TYPE_NORMAL
- en: 5.15 `forEach()`, `map()`, `filter()`, and `reduce()` equivalents for `async`,
    but we didn’t do the same for `find()`, `findIndex()`, `some()`, and `every()`;
    can you?
  prefs: []
  type: TYPE_NORMAL
- en: '5.16 **Emptying the pool**: As coded, the pool of workers can only grow in
    size. What can you do to prevent it from growing indefinitely? Try this idea:
    whenever there are more than, say, 10 workers not in use, remove some from the
    pool.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.17 **Queueing for the pool**: You cannot have an unlimited number of parallel
    workers running simultaneously. Implement a queueing procedure so that all calls
    will be accepted, but they will only call a worker when the number of workers
    in use is below a certain threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.18 `showResult()` function in the last section is interesting; how does it
    work? It’s a function that returns a function; an optimal example of FP!
  prefs: []
  type: TYPE_NORMAL
- en: 5.19 `workerCall()` in the *Long-living pooled workers* section, we wrote the
    following—is this the best way to find the available workers?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 5.20 `workerCall()` more suited to real-world problems?
  prefs: []
  type: TYPE_NORMAL
