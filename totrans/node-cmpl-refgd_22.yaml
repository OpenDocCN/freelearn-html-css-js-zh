- en: State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our microservice base layout on different frameworks,
    it's time to read our code more carefully and see if everything looks good. It's
    easy to just keep writing code and stop thinking about what we're doing, but later
    on, when we do stop for a while, we'll be wasting time deleting repeated code
    and reorganizing our service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s always better to think before we code. This is something you''ll learn
    with time, to value the time you dedicate to plan your service or think about
    a new feature. It''s never a good idea to just start coding. In theory, your **Service**
    should be inside a **Security** layer, with a good and stable connection to **State**:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fafb30f-c4b5-4361-a42c-fc1ca74f7259.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: State
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of state as a person's memory. Usually, a service has state, which means
    it has memory of actions and information it's serving. The idea is that our service
    will run indefinitely, but sometimes we're forced to restart it or even stop it
    for some time because of maintenance or an upgrade.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, a service should resume without losing state, giving its users the
    perception that it never stopped. This is achieved by doing one of two things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Having state stored in a persistent storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving state in a persistent storage before stopping and loading that state
    after restarting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option will make your service a bit slower (nothing is faster than
    state in system memory) but should give you a more consistent state across restarts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The second option is trickier, because sometimes our service might stop abruptly
    and be unable to save that state, but for those use cases, you may not care about
    the state. It's up to you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of options to store state; it will depend on what you want to
    store. For a microservice, you should avoid the filesystem so as to make your
    service more compatible with multiple operating systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Storing state
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on your service, you can store state using:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A **relational database management system** (**RDBMS**), such as MySQL or PostgreSQL
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **non-relational database management system**, or NoSQL, such as MongoDB or
    RethinkDB
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **in-memory database** (**IMDB**), such as Redis or Memcached
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is still the most commonly used one. You'll rely on stable
    and more than proven database systems that run in multiple systems and that you
    can find on any cloud service where you might want to deploy your microservice.
    Apart from the maturity of most solutions, a relational database, if properly
    set up, should give you consistency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The second option is more recent compared to the first one. Usually, there are
    no fixed tables as in RDBMS, and you normally work with collections of documents
    that are just common JSON structures. It's more agile as there are usually no
    restrictions, and each document might have a different structure. The more agile,
    the less consistent.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: All three options, depending on the specific system you choose, support replication,
    which should enable fault tolerance and improve speed in geographically spaced
    instances.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's try each of the three options using one of the suggested systems. Let's
    begin with the relational database, and use MySQL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing MySQL is very simple. Just head to the official website and follow
    the instructions. You'll usually be asked for a password for the root user, which
    you can use later on to manage the server settings and user accounts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: There are some options to connect to a MySQL server using Node.js, but the best
    tools are the `mysql` and `mysql2` modules. They both serve the required purpose,
    and neither is the next version of the other, they're just a bit different in
    design and supported features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the dependency to our service. On the terminal, go to our
    service folder and type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now include our dependency and configure a connection to the database.
    To avoid having the credentials in our code, we can create a separate file and
    put settings there that we may change in the future, and that shouldn't belong
    in the code. We can take advantage of Node.js being able to include JSON files,
    and just write our settings in JSON.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `settings.json`, and add the following content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We defined a setting called `db` that has a database URI, which is a handy way
    of defining our database access and credentials using an address similar to any
    website address. Our database uses `mysql`; it's at `localhost` (using the default
    port), which can be accessed using the username `root` and the password `test`,
    and our database name is called `imagini`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now include the module and settings, and create the connection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This module only connects to the database when you make a query. This means
    the service would start and you wouldn''t know whether your connection settings
    are correct until you make the first query. We don''t want to figure out we can''t
    connect to the database only when the service is used later on, so let''s force
    a connection and check if the server is running and accepts our connection:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This way, if anything is wrong with the database, the service won''t start
    and will throw an exception, which will notify you to check what''s wrong. Here''s
    an example of a possible error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This indicates you probably typed the password incorrectly, or the user doesn't
    match, or even the hostname or database may be wrong. Ensuring you connect to
    the database before setting up the service means your service won't be exposed
    to the public without a proper state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Our microservice has a very simple state, so to speak. Our state is the images
    previously uploaded. Instead of using the filesystem, we can now use the database
    and create a table to store them all:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can issue this query every time the service starts because it will create
    the images table only if it doesn't exist already. If we don't change its structure,
    it's fine to always do this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: You can see we're creating a table with a unique identification number (`id`),
    a creation date (`date_created`), a date to know when our image has been used(`date_used`),
    the `name` of the image, the `size` of it in bytes, and the image `data`. The
    size is a little redundant here as we could just check the data length, but bear
    with me, this is just an example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We also defined our name as a unique key, meaning it has an index for quickly
    finding images by name, and also ensures our name does not repeat and that no
    one can overwrite an image (without removing it first).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the images stored this way on a database table gives you several advantages,
    such as regarding:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: How many images you have
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of every image and the total size
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the images were created and last used
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also enables you to improve your service; for example, you can delete images
    that are not used for longer than a specific time period. You can also make this
    dependent on the image sizes. Later, you can add authentication (mandatory or
    not) and have user-specific rules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It's also easy to back up and replicate the state to another site. There are
    plenty of tools for backing up databases, and you can have another MySQL server
    acting as a slave to this one and have your images replicated in real time to
    another geographical location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Let's change our service from the previous chapter to use our table instead
    of the previously used folder on our filesystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove our  `fs` module dependency (don''t remove the path dependency
    for now):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our `app.param` is completely different. We now validate the `image` against
    our `image` table. If it doesn''t find it, it returns code `404`. If it does find
    it, it stores the `image` information in `req.image`. We can now change our `image`
    upload to store the `image` on our table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Uploading images no longer use the filesystem and instead creates a new row
    on our table. We don''t need to specify the `id` as it''s automatic. Our creation
    date is also automatic as it defaults to the current timestamp. Our use date defaults
    to `NULL`, which means we haven''t used the `image` yet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `image` check method now gets extremely simple as it relies on the previous
    `app.param` to check whether the `image` exists, so, if we get to this point,
    we already know the image exists (it's on `req.image`), so we just need to return
    the code `200`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Before updating our image `fetch` method, let''s try our service. If you start
    it on the console, you can immediately open any MySQL administration tool and
    check our database. I''m using Sequel Pro for macOS. Although there''s a Pro in
    the name, it''s free software and it''s damn good:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65b81b98-1531-4dfd-9cc2-1987f3662fcc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Our table was created, and you can check it has all the properties and indexes
    we defined. Let''s now upload an `image` once again:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51f3e97d-d8ed-4e1f-9d58-0fb7277a8c99.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'As before, it returns a JSON response with a success status and the size of
    the `image`. If you look at Sequel again, on the content separator, you''ll see
    our images data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8abacb08-a0fd-4724-9b17-2280b0cd71ab.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try and upload the `image` again. Previously, our service would just
    overwrite it. Now, because of our unique index, it should deny an `INSERT` with
    the same name:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44849b11-4ec0-40e4-92cb-d6604f5515cc.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Great! The `ER_DUP_ENTRY` is the MySQL code for duplicate insertion. We can
    rely on that and deny overwriting images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check whether our `image` exists using the `check` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2f9f4a5-884f-444e-b8ae-2de6bcf310ba.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'If we use another name, we''ll get a code `404`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c33c9c5a-0af8-4b77-b65b-08cdd3acd9b6.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'It looks like everything is working great. Let''s now change our final method,
    the `image` manipulation one. This method is almost the same; we just don''t have
    to read the `image` file, as it''s already available:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see how we used the path dependency to get the extension of the `image`
    name. The rest is the same. We just add an update to our image every time we request
    this method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a web browser to test our method and see our previously uploaded
    image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88605934-5962-4af5-b5fb-821ef77a428d.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Everything should just work as before because we haven''t changed our image
    manipulation dependency, so blurring and the other actions should work as expected:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd78552-7907-4854-b1fc-27fd4eb936a4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'We can now improve our service and add a method we didn''t expose before: deleting
    an `image`. To do that, we can use the `DELETE` verb from HTTP and just remove
    the `image` from our table:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We just have to check whether the query resulted in an error. If so, we respond
    with a code `500` (internal server error). If not, we respond with the usual code
    `200`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s restart our microservice and try to delete our `image`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f332e424-4eb1-4153-9c9e-0807469373fe.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'It looks like it worked; it responded with a code `200`. If we try to open
    our image in the web browser, we should see something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eced36f5-8a89-4228-ad2f-779c7b69b60a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'On Sequel, the table should now be empty too:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/480a78b6-72cc-4286-bb0e-719f3fea3f71.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: We now have a functional microservice with a state that persists across restarts,
    as we intended. You can now deploy to any cloud service with no dependency on
    the filesystem, just a database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You could easily change MySQL to another database or use an **o****bject relational ****mapping**
    (**ORM**) module to enable you to change database server without changing your
    code. An ORM is a library that allows you to use a common interface to access
    different types of databases. Usually, this kind of abstraction involves not using
    SQL at all and reducing your interaction with the databases to simpler queries
    (to allow for interoperability between database servers).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this opportunity to go a little further and add a few methods that
    got simplified by this migration to the database. Let's create a method that exposes
    statistics about our database, and let's remove old images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first statistics method should just return a JSON structure with some useful
    information. Let''s expose the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The total number of images
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total size of the images
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long our service is running
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the last time was that we uploaded an image
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of how our statistics method could look:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Restart the service, and let''s try it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277cd1a8-085e-410c-b712-0e6d1f58d1f2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: As we can see, we have no images as we just removed our image previously. There's
    no size because we have no images. There's also no used date, and the service
    uptime is 5 seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'If we upload our previous image, we will get different results, something like
    the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac4b4b76-7cad-4ba4-b35e-40b11c7ca310.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Now, for our second task, deleting old images, we need to check our database
    periodically. We'll use an interval timer and just run a `DELETE` query. The intervals
    mentioned in the following query are just an example; you can write the conditions
    you want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This query deletes `images` that were not used in the past month (but were used
    before) or images that were not used in the past week (and never used before).
    This means that images uploaded need to be used at least once or they will get
    removed quickly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a different strategy, or use no strategy and delete manually
    if you want. Now that we've seen MySQL, let's move on and look at another kind
    of database server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Adding code coverage
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our test suite is working and has one test, let's introduce code coverage.
    Adding this from the beginning of development is very easy and will help us focus
    on parts of the code that need to be tested, especially some use cases that involve
    specific conditions (such as `if-then-else` statements in our code). Having it
    all set up from the start of development is easy. On the other hand, if you have
    a fully working code and want to add tests and coverage, it will be harder and
    will take quite some time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To add code coverage, we''ll introduce another module. We''ll install it globally
    to be able to run the tests with it directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run our tests with the following instrumentation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This should run our tests with the instrumentation installed. In the end, you'll
    get a nice console report.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99619f27-c68e-49d6-8b6a-a3ad0178c91a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: The coverage results are stored inside in a `.nyc_output` folder. This enables
    you to look at the last test results without running tests again. This is useful
    if your test suite is big and takes some time to finish.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the results, you just run `nyc report`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd9cb784-7cdb-4a9f-8136-5c8c2e133c2a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'The result is a console report. There are several other styles of reports.
    One particularly useful one is the `html` report. Let''s generate it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should now have a `coverage` folder with an `index.html` file. Open that
    in your browser, and you should see something like the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90266f17-41c9-456b-ae43-f238f88d56bb.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: We only have one file that represents our microservice. If we had more, they
    would be listed hierarchically. There are global average statistics for every
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important groups of columns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Statements**: Which represent code statements (conditions, assignments, assertions,
    calls, and so on)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branches**: Which represent possible code control workflows, such as if-then-else
    or switch-case statement possibilities'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: Which represent our actual code functions and callbacks'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can click in our file, look at the specific details of it and, more specifically,
    see the code and information line by line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9331f44e-72e3-4ca6-ab78-8be70c2f63e8.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: To the right of every line number, you see a gray area and, in this case, you
    see `2x` in some of the lines. This is the execution count for that line. The
    execution has passed by that line twice. This is actually not that important,
    unless you're looking for bits of code that get largely executed and you want
    to do some kind of optimization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see that *line 12* has two changes. First, there''s a pinkish
    background in the back of `throw err`. That means that statement never got executed,
    which is normal for now as we always successfully connected to the database. The
    mark before the `if` statement means that the condition never got executed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0945b756-7b35-43c7-ae99-dd753f2e554f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: If you scroll a few lines down, we'll see more lines with marks. For example,
    we can see our image upload method got almost completely covered. The only statement
    missing is the error handling.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As we delete our test image before running the tests, our image deletion method
    is also covered. Again, the only missing branch is if the database returns an
    error to our `DELETE` query.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further with the image upload, let''s add another `integration`
    test file called `image-parameter.js`, and add some tests to increase our coverage:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run our test suite and see how it goes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44cfd9bd-5ed2-43df-9b75-925c62c0c5da.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Refresh the HTML report page and look at our parameter method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feb5c546-faf8-48dd-9033-b7d921f98985.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we now cover the following condition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following condition:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have full coverage on this method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: There are other coverage lines that are harder to test, such as timers (you
    can see one on *line 28*), `catch` statements, or external errors coming from
    databases or other storage sources. There are ways of mocking those events, and
    we'll cover them later on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: RethinkDB
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the differences for a non-relational database using RethinkDB. If
    you don''t have it, just install it by following the official documentation ([https://www.rethinkdb.com/docs/](https://www.rethinkdb.com/docs/)).
    Let''s just start the server:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will start the server, which comes with a very nice administration console
    on port `8080`. You can open it in the web browser:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a25af14-fa51-4597-9eff-d47bcde127d9.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Go to the Tables section on top to see the databases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a5cad5-13fc-40b5-9aa5-c36694406605.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Create a database called `imagini` using the Add Database button. You should
    now have our database ready. You need nothing else here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5be39ecd-34f7-42c4-8266-fbad8ad61e0b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: 'To use our new database, we need to install the `rethinkdb` dependency. You
    can remove the MySQL dependency:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s change our `settings` file. This module doesn''t accept a connection
    string, so we''ll use a JSON structure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To include our dependency, we just need to include the module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, use this to connect to our server:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After connecting, we can create our table as we did before. This time, we don''t
    need to specify any structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `rethinkdb` object is the one we'll use to manipulate our table, and the
    `db` object is a connection object used to reference the connection and to indicate
    where to run our manipulations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If you restart our service just like this, you''ll see a new table on our previously
    created database:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/976d103d-a00f-4bc1-b830-ada32e107310.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'If you restart our service again, you''ll get an error trying to create the
    table that already exists. We need to check whether it already exists, and only
    issue the command if not:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Moving on, our upload method should be changed slightly to something like the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you restart the server just like this, you should be able to upload an `image`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5591f6a1-af2d-414b-9d22-9b5defb7c872.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'We receive the same response, just like with MySQL. We can go to the Data Explorer
    section in the administration console and get our record to see whether it''s
    there:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b05c2929-88d4-46bb-aa48-61055e014f06.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Looks good. Notice our record ID is not a number, it's a **Universally Unique
    Identifier** (**UUID**). This is because RethinkDB has support for sharding (our
    table is sharded by default if there was more than one server) and it's easier
    to shard unique identifiers than an incremental number.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to our Express parameter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this change, we can now restart our service and see whether our `image`
    exists:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf087587-648d-4091-aa9f-e0d9a8a15fd7.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'We need to change the download just a little bit. We need to remove the previous
    query to update our usage date and replace it with a new one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now download our image using the web browser:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/454e1973-472e-414f-af6e-2b0abbb621ea.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to update our image removal method. It''s as easy as our upload:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we used the image unique ID to remove it. If we try again using
    the `curl` command, we''ll receive a code `200`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8c95a69-2e76-4e9d-b83f-7990119543e7.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'If we try to get the first record of our table, we''ll see there''s nothing
    there:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/600662dc-1ded-4417-a286-899f773f6fc1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Finally, there are our two extra features that we added after introducing MySQL:
    the statistics and removing old unused images.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Our statistics method is not so simple as running an SQL query with aggregations.
    We must calculate each of our statistics:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We should have a similar result to before:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81ddd5ab-115d-42c0-867b-95a7319a2555.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Removing old images is more or less easy; we just need to filter the images
    we want to remove, and then remove them:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I simplified the previous strategy and am just removing `images` older than 1
    month (30 days, times 86,400 seconds a day, times 1,000 milliseconds).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-memory databases are different from the previous two types, as they're usually
    not structured, which means you have no tables. What you have is normally lists
    of some kind that you can look up and manipulate, or simple hash tables.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the Redis instance we installed previously for Hydra, let''s
    see another drawback, or actually feature, of this kind of database. Let''s connect
    to our Redis instance and make the following sequence of instructions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b204f94-7078-4020-9b1d-bf1f62f402cc.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'What we did here was to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the Redis service using `redis-cli`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is nil (nothing), because we haven't defined
    it yet.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the counter, which is now automatically defined and set to `1`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the counter again, which is now `2`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is of course `2`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down the Redis service.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Redis service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the Redis service again.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is nil (nothing).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where's our counter? Well, this is an in-memory database, so everything is gone
    when we shut down the Redis service. This is the design of almost all kinds of
    in-memory databases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: They're designed to be fast and in-memory. Their purpose is normally to cache
    data that is expensive to get, such as some complex calculations, or extensive
    to download, and we want that to be available faster (in-memory).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: I wasn't completely fair with Redis as it actually allows your data to be saved
    between service restarts. So, let's see how far we can go in using it to save
    our microservice state.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, let''s uninstall `rethinkdb` and install the `redis` module:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's ignore our `settings.json` file (you can remove it if you prefer) and
    assume Redis will be on our local machine.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include the `redis` module and create a `Client` instance:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then need to wait until it connects:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are a couple of ways we can use Redis to store our data. To make it simple,
    as we don't have tables, let's use hashes to store our images. Each image will
    have a different hash, and the name of the hash will be the name of the image.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: As there are no tables in this kind of database, our initialization code can
    just be removed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s change our upload method to store data on Redis. As I mentioned,
    let''s store it in a hash with the name of the `image`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `hmset` command lets us set multiple fields of a hash, in our case, `size`
    and `data`. Notice we''re storing our image content in `base64` encoding, otherwise
    we''ll lose data. If we restart our service and try to upload our test `image`,
    it should work fine:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69d28e98-498a-4a5f-8dca-9532bb9027e6.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'We can then use `redis-cli` and see whether our image is there. Well, we''re
    checking to see whether our hash has the field size and matches our image size:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3112df7b-958f-4b55-97c6-d3623d694963.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Great! We can now change our Express parameter to look for the `image` hash:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our `image` check method should work now. And, for our download method to work,
    we just need to change the image loading to decode our previous `base64` encoding:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our images are now being served from Redis. As a bonus, we''re adding/updating
    a `date_used` field in our `image` hash to indicate when it was last used:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c617c24a-e4df-4878-a442-2ce3ff909f1b.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Removing our `image` is as simple as removing our hash:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then try to remove our `test` image:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3557032f-1cf1-42f1-9943-00c31ef5fd66.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Using `redis-cli` to check whether the hash exists, we see that it''s gone:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/716dfce9-3eaa-405a-ac5f-91f5bdd7424a.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: The only two features missing are the statistics and removing old images.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: For the statistics, that could be hard as we're using generic hash tables and
    we can't be sure how many hash tables are defined, and if all or any have image
    data. We would have to scan all hash tables, which is complex for large sets.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: To remove old images, the problem is the same as there's no way of looking for
    hash tables with a specific condition, such as a field value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: There are still other paths available to tackle this problem. For example, we
    could have another hash table with just our image names and use dates. But, the
    complexity would increase, and the integrity could be at risk as we're splitting
    information through different hash tables with no certainty of making **Atomicity**,
    **Consistency**, **Isolation**, and **Durability** (**ACID**) operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, there are plenty of options to store our microservice state.
    Depending on the type of information we're manipulating, there are databases better-prepared
    to handle our data.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'It all depends on a few different questions we should ask ourselves:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Is our data integrity important?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is our data structure complex?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and what type of information do we need to acquire?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our data integrity is important or the data structure is complex, do not
    use in-memory databases. Depending on the complexity, see if you need a non-relational
    database, or whether you can go with a relational database that can handle more
    complex manipulation and data aggregation operations, which will help you to achieve
    the last point.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One good practice is to write code iteratively, testing every time we make a
    new small feature or improvement, and always write code thinking of all the features
    we envision for our service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the service roadmap allows you to prepare the service for future
    improvements, reducing the amount of code wasted or replaced later on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in terms of security:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Is our service secure? Is it prepared for some types of malicious attacks?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is our service private? Should it have some kind of authentication or authorization
    mechanism?
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, our frameworks allow our code to be composed and allow us to add layers
    of security later. For example, using Express or Hydra, we can add a precedent
    routing function that will run before any of our service methods, allowing us
    to enforce, for example, authentication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our service, since it exposes its methods using HTTP, there are
    a couple of improvements we can add to it, for example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Forcing anyone that uses it to identify themselves. Or,
    just the upload and removal methods. It''s up to you. There could also be user
    accounts, and each user would see their respective list of images.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Restricting, for example, what networks could access the
    service, independently of having a valid authentication or not.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidentiality**: Giving your users protection against prying eyes over
    the network traffic.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Restricting the maximum usage frequency of the service, per
    client, to ensure a single client cannot block your entire service.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To introduce these improvements, you may add an authentication module such as
    the Passport module, and use a certificate to give your users a more secure HTTPS
    experience.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Other types of insecurity come directly from your code and don''t improve by
    adding a certificate or forcing authentication. I''m referring to:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Bugs, programming logic flaws, and use cases not properly tested, which can
    lead to minor or serious problems
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency bugs, which you might not be aware of but can still ruin your service
    and may force you to look for alternative dependencies, which is never a pleasant
    task
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To minimize these events, you should always keep evolving your test suite, adding
    use cases as they show up, ensuring a new bug that is solved does not reappear
    later. Regarding dependency bugs, you can subscribe to the Node Security Project
    and even integrate it with your code to always know when one of your dependencies
    is a risk.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化这些事件，你应该始终不断进化你的测试套件，随着用例的出现添加它们，确保解决的新问题不会在以后再次出现。关于依赖性问题，你可以订阅Node Security
    Project，甚至将其集成到你的代码中，以便始终知道你的依赖项中是否有任何一个是风险的。
- en: 'If there were source code commandments, the next four would surely be on the
    list:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有源代码戒律，接下来的四条肯定会在列表上：
- en: Keep the code simple. If the code is getting complex, stop, look back, and split
    the code into simpler parts.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持代码简单。如果代码变得复杂，就停下来，回顾一下，并将代码拆分成更简单的部分。
- en: Validate external input, whether it's the user or another service. Never trust
    data from the outside.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证外部输入，无论是用户还是另一个服务。永远不要相信来自外部的数据。
- en: Deny by default and not the opposite, checking whether someone has access to
    a resource and denying anyone that is not.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认拒绝而不是相反，检查某人是否有权访问资源，并拒绝任何无权访问的人。
- en: Add test cases from the beginning of the project.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从项目开始时就添加测试用例。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The state is part of any service, and state is built upon data. For a more cloud-native
    experience, a service cannot depend on a traditional filesystem and needs to use
    other kinds of storage structures to store data. Databases are a natural progress,
    and there are some types of databases to choose from, depending on how important
    and complex our data is.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是任何服务的一部分，状态建立在数据之上。为了获得更云原生（cloud-native）的体验，服务不能依赖于传统的文件系统，而需要使用其他类型的存储结构来存储数据。数据库是一个自然的发展，根据我们的数据的重要性和复杂性，我们可以选择一些数据库类型。
- en: Assuming our state is securely stored in a database service of some kind, it's
    also important to ensure our data cannot be corrupted using our service. There
    can be security flaws and bugs in our service that may put our data at risk, so
    it's important to write simple code, validate input, and think about security
    in general when planning the service roadmap.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的状态已安全存储在某些类型的数据库服务中，确保我们的数据不能通过我们的服务被破坏也同样重要。我们的服务中可能存在安全漏洞和错误，可能会使我们的数据处于风险之中，因此，在规划服务路线图时，编写简单的代码、验证输入和考虑安全性是很重要的。
- en: To progress our service, let's introduce something we haven't done yet, and
    should, which is a proper test suite. In the next chapter, we'll see some good
    options and create a test suite, establishing whether anything needs to change
    in order to make our service as secure as possible.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推进我们的服务，让我们引入我们尚未做但应该做的事情，那就是一个合适的测试套件。在下一章中，我们将看到一些好的选择，并创建一个测试套件，确定是否需要改变以使我们的服务尽可能安全。
