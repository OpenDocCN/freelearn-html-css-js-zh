- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our microservice base layout on different frameworks,
    it's time to read our code more carefully and see if everything looks good. It's
    easy to just keep writing code and stop thinking about what we're doing, but later
    on, when we do stop for a while, we'll be wasting time deleting repeated code
    and reorganizing our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s always better to think before we code. This is something you''ll learn
    with time, to value the time you dedicate to plan your service or think about
    a new feature. It''s never a good idea to just start coding. In theory, your **Service**
    should be inside a **Security** layer, with a good and stable connection to **State**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fafb30f-c4b5-4361-a42c-fc1ca74f7259.png)'
  prefs: []
  type: TYPE_IMG
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of state as a person's memory. Usually, a service has state, which means
    it has memory of actions and information it's serving. The idea is that our service
    will run indefinitely, but sometimes we're forced to restart it or even stop it
    for some time because of maintenance or an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, a service should resume without losing state, giving its users the
    perception that it never stopped. This is achieved by doing one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Having state stored in a persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving state in a persistent storage before stopping and loading that state
    after restarting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option will make your service a bit slower (nothing is faster than
    state in system memory) but should give you a more consistent state across restarts.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is trickier, because sometimes our service might stop abruptly
    and be unable to save that state, but for those use cases, you may not care about
    the state. It's up to you.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of options to store state; it will depend on what you want to
    store. For a microservice, you should avoid the filesystem so as to make your
    service more compatible with multiple operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Storing state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on your service, you can store state using:'
  prefs: []
  type: TYPE_NORMAL
- en: A **relational database management system** (**RDBMS**), such as MySQL or PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **non-relational database management system**, or NoSQL, such as MongoDB or
    RethinkDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **in-memory database** (**IMDB**), such as Redis or Memcached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is still the most commonly used one. You'll rely on stable
    and more than proven database systems that run in multiple systems and that you
    can find on any cloud service where you might want to deploy your microservice.
    Apart from the maturity of most solutions, a relational database, if properly
    set up, should give you consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is more recent compared to the first one. Usually, there are
    no fixed tables as in RDBMS, and you normally work with collections of documents
    that are just common JSON structures. It's more agile as there are usually no
    restrictions, and each document might have a different structure. The more agile,
    the less consistent.
  prefs: []
  type: TYPE_NORMAL
- en: All three options, depending on the specific system you choose, support replication,
    which should enable fault tolerance and improve speed in geographically spaced
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try each of the three options using one of the suggested systems. Let's
    begin with the relational database, and use MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing MySQL is very simple. Just head to the official website and follow
    the instructions. You'll usually be asked for a password for the root user, which
    you can use later on to manage the server settings and user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: There are some options to connect to a MySQL server using Node.js, but the best
    tools are the `mysql` and `mysql2` modules. They both serve the required purpose,
    and neither is the next version of the other, they're just a bit different in
    design and supported features.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the dependency to our service. On the terminal, go to our
    service folder and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can now include our dependency and configure a connection to the database.
    To avoid having the credentials in our code, we can create a separate file and
    put settings there that we may change in the future, and that shouldn't belong
    in the code. We can take advantage of Node.js being able to include JSON files,
    and just write our settings in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `settings.json`, and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We defined a setting called `db` that has a database URI, which is a handy way
    of defining our database access and credentials using an address similar to any
    website address. Our database uses `mysql`; it's at `localhost` (using the default
    port), which can be accessed using the username `root` and the password `test`,
    and our database name is called `imagini`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now include the module and settings, and create the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This module only connects to the database when you make a query. This means
    the service would start and you wouldn''t know whether your connection settings
    are correct until you make the first query. We don''t want to figure out we can''t
    connect to the database only when the service is used later on, so let''s force
    a connection and check if the server is running and accepts our connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, if anything is wrong with the database, the service won''t start
    and will throw an exception, which will notify you to check what''s wrong. Here''s
    an example of a possible error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This indicates you probably typed the password incorrectly, or the user doesn't
    match, or even the hostname or database may be wrong. Ensuring you connect to
    the database before setting up the service means your service won't be exposed
    to the public without a proper state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our microservice has a very simple state, so to speak. Our state is the images
    previously uploaded. Instead of using the filesystem, we can now use the database
    and create a table to store them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can issue this query every time the service starts because it will create
    the images table only if it doesn't exist already. If we don't change its structure,
    it's fine to always do this.
  prefs: []
  type: TYPE_NORMAL
- en: You can see we're creating a table with a unique identification number (`id`),
    a creation date (`date_created`), a date to know when our image has been used(`date_used`),
    the `name` of the image, the `size` of it in bytes, and the image `data`. The
    size is a little redundant here as we could just check the data length, but bear
    with me, this is just an example.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined our name as a unique key, meaning it has an index for quickly
    finding images by name, and also ensures our name does not repeat and that no
    one can overwrite an image (without removing it first).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the images stored this way on a database table gives you several advantages,
    such as regarding:'
  prefs: []
  type: TYPE_NORMAL
- en: How many images you have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of every image and the total size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the images were created and last used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also enables you to improve your service; for example, you can delete images
    that are not used for longer than a specific time period. You can also make this
    dependent on the image sizes. Later, you can add authentication (mandatory or
    not) and have user-specific rules.
  prefs: []
  type: TYPE_NORMAL
- en: It's also easy to back up and replicate the state to another site. There are
    plenty of tools for backing up databases, and you can have another MySQL server
    acting as a slave to this one and have your images replicated in real time to
    another geographical location.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change our service from the previous chapter to use our table instead
    of the previously used folder on our filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove our  `fs` module dependency (don''t remove the path dependency
    for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `app.param` is completely different. We now validate the `image` against
    our `image` table. If it doesn''t find it, it returns code `404`. If it does find
    it, it stores the `image` information in `req.image`. We can now change our `image`
    upload to store the `image` on our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Uploading images no longer use the filesystem and instead creates a new row
    on our table. We don''t need to specify the `id` as it''s automatic. Our creation
    date is also automatic as it defaults to the current timestamp. Our use date defaults
    to `NULL`, which means we haven''t used the `image` yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our `image` check method now gets extremely simple as it relies on the previous
    `app.param` to check whether the `image` exists, so, if we get to this point,
    we already know the image exists (it's on `req.image`), so we just need to return
    the code `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before updating our image `fetch` method, let''s try our service. If you start
    it on the console, you can immediately open any MySQL administration tool and
    check our database. I''m using Sequel Pro for macOS. Although there''s a Pro in
    the name, it''s free software and it''s damn good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65b81b98-1531-4dfd-9cc2-1987f3662fcc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our table was created, and you can check it has all the properties and indexes
    we defined. Let''s now upload an `image` once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51f3e97d-d8ed-4e1f-9d58-0fb7277a8c99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As before, it returns a JSON response with a success status and the size of
    the `image`. If you look at Sequel again, on the content separator, you''ll see
    our images data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8abacb08-a0fd-4724-9b17-2280b0cd71ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try and upload the `image` again. Previously, our service would just
    overwrite it. Now, because of our unique index, it should deny an `INSERT` with
    the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44849b11-4ec0-40e4-92cb-d6604f5515cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! The `ER_DUP_ENTRY` is the MySQL code for duplicate insertion. We can
    rely on that and deny overwriting images.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check whether our `image` exists using the `check` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2f9f4a5-884f-444e-b8ae-2de6bcf310ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use another name, we''ll get a code `404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c33c9c5a-0af8-4b77-b65b-08cdd3acd9b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like everything is working great. Let''s now change our final method,
    the `image` manipulation one. This method is almost the same; we just don''t have
    to read the `image` file, as it''s already available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see how we used the path dependency to get the extension of the `image`
    name. The rest is the same. We just add an update to our image every time we request
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a web browser to test our method and see our previously uploaded
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88605934-5962-4af5-b5fb-821ef77a428d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything should just work as before because we haven''t changed our image
    manipulation dependency, so blurring and the other actions should work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cd78552-7907-4854-b1fc-27fd4eb936a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now improve our service and add a method we didn''t expose before: deleting
    an `image`. To do that, we can use the `DELETE` verb from HTTP and just remove
    the `image` from our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We just have to check whether the query resulted in an error. If so, we respond
    with a code `500` (internal server error). If not, we respond with the usual code
    `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s restart our microservice and try to delete our `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f332e424-4eb1-4153-9c9e-0807469373fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like it worked; it responded with a code `200`. If we try to open
    our image in the web browser, we should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eced36f5-8a89-4228-ad2f-779c7b69b60a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On Sequel, the table should now be empty too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/480a78b6-72cc-4286-bb0e-719f3fea3f71.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a functional microservice with a state that persists across restarts,
    as we intended. You can now deploy to any cloud service with no dependency on
    the filesystem, just a database.
  prefs: []
  type: TYPE_NORMAL
- en: You could easily change MySQL to another database or use an **o****bject relational ****mapping**
    (**ORM**) module to enable you to change database server without changing your
    code. An ORM is a library that allows you to use a common interface to access
    different types of databases. Usually, this kind of abstraction involves not using
    SQL at all and reducing your interaction with the databases to simpler queries
    (to allow for interoperability between database servers).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this opportunity to go a little further and add a few methods that
    got simplified by this migration to the database. Let's create a method that exposes
    statistics about our database, and let's remove old images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first statistics method should just return a JSON structure with some useful
    information. Let''s expose the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total size of the images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long our service is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the last time was that we uploaded an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of how our statistics method could look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the service, and let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277cd1a8-085e-410c-b712-0e6d1f58d1f2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we have no images as we just removed our image previously. There's
    no size because we have no images. There's also no used date, and the service
    uptime is 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we upload our previous image, we will get different results, something like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac4b4b76-7cad-4ba4-b35e-40b11c7ca310.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, for our second task, deleting old images, we need to check our database
    periodically. We'll use an interval timer and just run a `DELETE` query. The intervals
    mentioned in the following query are just an example; you can write the conditions
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This query deletes `images` that were not used in the past month (but were used
    before) or images that were not used in the past week (and never used before).
    This means that images uploaded need to be used at least once or they will get
    removed quickly.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a different strategy, or use no strategy and delete manually
    if you want. Now that we've seen MySQL, let's move on and look at another kind
    of database server.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our test suite is working and has one test, let's introduce code coverage.
    Adding this from the beginning of development is very easy and will help us focus
    on parts of the code that need to be tested, especially some use cases that involve
    specific conditions (such as `if-then-else` statements in our code). Having it
    all set up from the start of development is easy. On the other hand, if you have
    a fully working code and want to add tests and coverage, it will be harder and
    will take quite some time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add code coverage, we''ll introduce another module. We''ll install it globally
    to be able to run the tests with it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run our tests with the following instrumentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This should run our tests with the instrumentation installed. In the end, you'll
    get a nice console report.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99619f27-c68e-49d6-8b6a-a3ad0178c91a.png)'
  prefs: []
  type: TYPE_IMG
- en: The coverage results are stored inside in a `.nyc_output` folder. This enables
    you to look at the last test results without running tests again. This is useful
    if your test suite is big and takes some time to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the results, you just run `nyc report`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd9cb784-7cdb-4a9f-8136-5c8c2e133c2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a console report. There are several other styles of reports.
    One particularly useful one is the `html` report. Let''s generate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have a `coverage` folder with an `index.html` file. Open that
    in your browser, and you should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90266f17-41c9-456b-ae43-f238f88d56bb.png)'
  prefs: []
  type: TYPE_IMG
- en: We only have one file that represents our microservice. If we had more, they
    would be listed hierarchically. There are global average statistics for every
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important groups of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statements**: Which represent code statements (conditions, assignments, assertions,
    calls, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branches**: Which represent possible code control workflows, such as if-then-else
    or switch-case statement possibilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**: Which represent our actual code functions and callbacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can click in our file, look at the specific details of it and, more specifically,
    see the code and information line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9331f44e-72e3-4ca6-ab78-8be70c2f63e8.png)'
  prefs: []
  type: TYPE_IMG
- en: To the right of every line number, you see a gray area and, in this case, you
    see `2x` in some of the lines. This is the execution count for that line. The
    execution has passed by that line twice. This is actually not that important,
    unless you're looking for bits of code that get largely executed and you want
    to do some kind of optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see that *line 12* has two changes. First, there''s a pinkish
    background in the back of `throw err`. That means that statement never got executed,
    which is normal for now as we always successfully connected to the database. The
    mark before the `if` statement means that the condition never got executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0945b756-7b35-43c7-ae99-dd753f2e554f.png)'
  prefs: []
  type: TYPE_IMG
- en: If you scroll a few lines down, we'll see more lines with marks. For example,
    we can see our image upload method got almost completely covered. The only statement
    missing is the error handling.
  prefs: []
  type: TYPE_NORMAL
- en: As we delete our test image before running the tests, our image deletion method
    is also covered. Again, the only missing branch is if the database returns an
    error to our `DELETE` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further with the image upload, let''s add another `integration`
    test file called `image-parameter.js`, and add some tests to increase our coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our test suite and see how it goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44cfd9bd-5ed2-43df-9b75-925c62c0c5da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Refresh the HTML report page and look at our parameter method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feb5c546-faf8-48dd-9033-b7d921f98985.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we now cover the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have full coverage on this method.
  prefs: []
  type: TYPE_NORMAL
- en: There are other coverage lines that are harder to test, such as timers (you
    can see one on *line 28*), `catch` statements, or external errors coming from
    databases or other storage sources. There are ways of mocking those events, and
    we'll cover them later on.
  prefs: []
  type: TYPE_NORMAL
- en: RethinkDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the differences for a non-relational database using RethinkDB. If
    you don''t have it, just install it by following the official documentation ([https://www.rethinkdb.com/docs/](https://www.rethinkdb.com/docs/)).
    Let''s just start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the server, which comes with a very nice administration console
    on port `8080`. You can open it in the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a25af14-fa51-4597-9eff-d47bcde127d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the Tables section on top to see the databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a5cad5-13fc-40b5-9aa5-c36694406605.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a database called `imagini` using the Add Database button. You should
    now have our database ready. You need nothing else here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5be39ecd-34f7-42c4-8266-fbad8ad61e0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use our new database, we need to install the `rethinkdb` dependency. You
    can remove the MySQL dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change our `settings` file. This module doesn''t accept a connection
    string, so we''ll use a JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To include our dependency, we just need to include the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this to connect to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After connecting, we can create our table as we did before. This time, we don''t
    need to specify any structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `rethinkdb` object is the one we'll use to manipulate our table, and the
    `db` object is a connection object used to reference the connection and to indicate
    where to run our manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you restart our service just like this, you''ll see a new table on our previously
    created database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/976d103d-a00f-4bc1-b830-ada32e107310.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you restart our service again, you''ll get an error trying to create the
    table that already exists. We need to check whether it already exists, and only
    issue the command if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, our upload method should be changed slightly to something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you restart the server just like this, you should be able to upload an `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5591f6a1-af2d-414b-9d22-9b5defb7c872.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We receive the same response, just like with MySQL. We can go to the Data Explorer
    section in the administration console and get our record to see whether it''s
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b05c2929-88d4-46bb-aa48-61055e014f06.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks good. Notice our record ID is not a number, it's a **Universally Unique
    Identifier** (**UUID**). This is because RethinkDB has support for sharding (our
    table is sharded by default if there was more than one server) and it's easier
    to shard unique identifiers than an incremental number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to our Express parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, we can now restart our service and see whether our `image`
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf087587-648d-4091-aa9f-e0d9a8a15fd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to change the download just a little bit. We need to remove the previous
    query to update our usage date and replace it with a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now download our image using the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/454e1973-472e-414f-af6e-2b0abbb621ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to update our image removal method. It''s as easy as our upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we used the image unique ID to remove it. If we try again using
    the `curl` command, we''ll receive a code `200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8c95a69-2e76-4e9d-b83f-7990119543e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try to get the first record of our table, we''ll see there''s nothing
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/600662dc-1ded-4417-a286-899f773f6fc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, there are our two extra features that we added after introducing MySQL:
    the statistics and removing old unused images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our statistics method is not so simple as running an SQL query with aggregations.
    We must calculate each of our statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We should have a similar result to before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81ddd5ab-115d-42c0-867b-95a7319a2555.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Removing old images is more or less easy; we just need to filter the images
    we want to remove, and then remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I simplified the previous strategy and am just removing `images` older than 1
    month (30 days, times 86,400 seconds a day, times 1,000 milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-memory databases are different from the previous two types, as they're usually
    not structured, which means you have no tables. What you have is normally lists
    of some kind that you can look up and manipulate, or simple hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the Redis instance we installed previously for Hydra, let''s
    see another drawback, or actually feature, of this kind of database. Let''s connect
    to our Redis instance and make the following sequence of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b204f94-7078-4020-9b1d-bf1f62f402cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we did here was to:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the Redis service using `redis-cli`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is nil (nothing), because we haven't defined
    it yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the counter, which is now automatically defined and set to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the counter again, which is now `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is of course `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down the Redis service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Redis service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the Redis service again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the content of the counter, which is nil (nothing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where's our counter? Well, this is an in-memory database, so everything is gone
    when we shut down the Redis service. This is the design of almost all kinds of
    in-memory databases.
  prefs: []
  type: TYPE_NORMAL
- en: They're designed to be fast and in-memory. Their purpose is normally to cache
    data that is expensive to get, such as some complex calculations, or extensive
    to download, and we want that to be available faster (in-memory).
  prefs: []
  type: TYPE_NORMAL
- en: I wasn't completely fair with Redis as it actually allows your data to be saved
    between service restarts. So, let's see how far we can go in using it to save
    our microservice state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, let''s uninstall `rethinkdb` and install the `redis` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's ignore our `settings.json` file (you can remove it if you prefer) and
    assume Redis will be on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include the `redis` module and create a `Client` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to wait until it connects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of ways we can use Redis to store our data. To make it simple,
    as we don't have tables, let's use hashes to store our images. Each image will
    have a different hash, and the name of the hash will be the name of the image.
  prefs: []
  type: TYPE_NORMAL
- en: As there are no tables in this kind of database, our initialization code can
    just be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s change our upload method to store data on Redis. As I mentioned,
    let''s store it in a hash with the name of the `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hmset` command lets us set multiple fields of a hash, in our case, `size`
    and `data`. Notice we''re storing our image content in `base64` encoding, otherwise
    we''ll lose data. If we restart our service and try to upload our test `image`,
    it should work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69d28e98-498a-4a5f-8dca-9532bb9027e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then use `redis-cli` and see whether our image is there. Well, we''re
    checking to see whether our hash has the field size and matches our image size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3112df7b-958f-4b55-97c6-d3623d694963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! We can now change our Express parameter to look for the `image` hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `image` check method should work now. And, for our download method to work,
    we just need to change the image loading to decode our previous `base64` encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our images are now being served from Redis. As a bonus, we''re adding/updating
    a `date_used` field in our `image` hash to indicate when it was last used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c617c24a-e4df-4878-a442-2ce3ff909f1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Removing our `image` is as simple as removing our hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then try to remove our `test` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3557032f-1cf1-42f1-9943-00c31ef5fd66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `redis-cli` to check whether the hash exists, we see that it''s gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/716dfce9-3eaa-405a-ac5f-91f5bdd7424a.png)'
  prefs: []
  type: TYPE_IMG
- en: The only two features missing are the statistics and removing old images.
  prefs: []
  type: TYPE_NORMAL
- en: For the statistics, that could be hard as we're using generic hash tables and
    we can't be sure how many hash tables are defined, and if all or any have image
    data. We would have to scan all hash tables, which is complex for large sets.
  prefs: []
  type: TYPE_NORMAL
- en: To remove old images, the problem is the same as there's no way of looking for
    hash tables with a specific condition, such as a field value.
  prefs: []
  type: TYPE_NORMAL
- en: There are still other paths available to tackle this problem. For example, we
    could have another hash table with just our image names and use dates. But, the
    complexity would increase, and the integrity could be at risk as we're splitting
    information through different hash tables with no certainty of making **Atomicity**,
    **Consistency**, **Isolation**, and **Durability** (**ACID**) operations.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, there are plenty of options to store our microservice state.
    Depending on the type of information we're manipulating, there are databases better-prepared
    to handle our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all depends on a few different questions we should ask ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: Is our data integrity important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is our data structure complex?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and what type of information do we need to acquire?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our data integrity is important or the data structure is complex, do not
    use in-memory databases. Depending on the complexity, see if you need a non-relational
    database, or whether you can go with a relational database that can handle more
    complex manipulation and data aggregation operations, which will help you to achieve
    the last point.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One good practice is to write code iteratively, testing every time we make a
    new small feature or improvement, and always write code thinking of all the features
    we envision for our service.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the service roadmap allows you to prepare the service for future
    improvements, reducing the amount of code wasted or replaced later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in terms of security:'
  prefs: []
  type: TYPE_NORMAL
- en: Is our service secure? Is it prepared for some types of malicious attacks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is our service private? Should it have some kind of authentication or authorization
    mechanism?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, our frameworks allow our code to be composed and allow us to add layers
    of security later. For example, using Express or Hydra, we can add a precedent
    routing function that will run before any of our service methods, allowing us
    to enforce, for example, authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our service, since it exposes its methods using HTTP, there are
    a couple of improvements we can add to it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Forcing anyone that uses it to identify themselves. Or,
    just the upload and removal methods. It''s up to you. There could also be user
    accounts, and each user would see their respective list of images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Restricting, for example, what networks could access the
    service, independently of having a valid authentication or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidentiality**: Giving your users protection against prying eyes over
    the network traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Restricting the maximum usage frequency of the service, per
    client, to ensure a single client cannot block your entire service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To introduce these improvements, you may add an authentication module such as
    the Passport module, and use a certificate to give your users a more secure HTTPS
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other types of insecurity come directly from your code and don''t improve by
    adding a certificate or forcing authentication. I''m referring to:'
  prefs: []
  type: TYPE_NORMAL
- en: Bugs, programming logic flaws, and use cases not properly tested, which can
    lead to minor or serious problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency bugs, which you might not be aware of but can still ruin your service
    and may force you to look for alternative dependencies, which is never a pleasant
    task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To minimize these events, you should always keep evolving your test suite, adding
    use cases as they show up, ensuring a new bug that is solved does not reappear
    later. Regarding dependency bugs, you can subscribe to the Node Security Project
    and even integrate it with your code to always know when one of your dependencies
    is a risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there were source code commandments, the next four would surely be on the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the code simple. If the code is getting complex, stop, look back, and split
    the code into simpler parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate external input, whether it's the user or another service. Never trust
    data from the outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny by default and not the opposite, checking whether someone has access to
    a resource and denying anyone that is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add test cases from the beginning of the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state is part of any service, and state is built upon data. For a more cloud-native
    experience, a service cannot depend on a traditional filesystem and needs to use
    other kinds of storage structures to store data. Databases are a natural progress,
    and there are some types of databases to choose from, depending on how important
    and complex our data is.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming our state is securely stored in a database service of some kind, it's
    also important to ensure our data cannot be corrupted using our service. There
    can be security flaws and bugs in our service that may put our data at risk, so
    it's important to write simple code, validate input, and think about security
    in general when planning the service roadmap.
  prefs: []
  type: TYPE_NORMAL
- en: To progress our service, let's introduce something we haven't done yet, and
    should, which is a proper test suite. In the next chapter, we'll see some good
    options and create a test suite, establishing whether anything needs to change
    in order to make our service as secure as possible.
  prefs: []
  type: TYPE_NORMAL
