<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Ember Router" id="1565U1-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Ember Router</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Defining an application route</li><li class="listitem">Setting up a route model</li><li class="listitem">Handling dynamic segments inside routes</li><li class="listitem">Defining routes with templates</li><li class="listitem">Using redirection with routes</li><li class="listitem">Working with asynchronous routing</li><li class="listitem">Loading and error handling</li><li class="listitem">Using query parameters</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Ember Router" id="1565U1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec33" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">The router in Ember is responsible for changing the state of the application when a user performs an action. This can be anything from the user changing the URL to hitting the back button in the application. Regardless of what action is performed, the route handler is responsible. It takes the current URL and maps it to the correct route so that it can be displayed to the user.</p><p class="calibre8">Route handlers take care of rendering templates, loading up the model, and redirecting and transitioning from one route to another. They can also handle actions that occur when the model changes.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Defining an application route"><div class="book" id="164MG2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Defining an application route</h1></div></div></div><p class="calibre8">When <a id="id177" class="calibre1"/>loading your application, the router looks at the URL and matches it to the route. We'll go over some basics on how this works.</p></div>

<div class="book" title="Defining an application route">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec60" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">The route map is used to define the URL mappings. Let's take a look at adding a new route using <code class="email">this.route</code>.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new <a id="id178" class="calibre1"/>application, open the <code class="email">router.js</code> file in the <code class="email">app</code> folder. To begin, we'll create a new route called <code class="email">about</code>:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('about');
});

export default Router;</pre></div><p class="calibre14"><code class="email">Router.map</code> in the preceding code handles the routing of the program. The <code class="email">this.route</code> creates the <code class="email">about</code> route. By default, the name of the route will be the same as the path to it. For example, the <code class="email">about</code> route path would be located at <code class="email">/about</code>. We can specifically set the path using <code class="email">path</code>.</p></li><li class="listitem" value="2">Instead of having all requests go to <code class="email">/about</code>, let's change the path so that they go to <code class="email">/me</code>:<div class="informalexample"><pre class="programlisting">// app/router.js
…
this.route('about',{ path: '/aboutme' });
…</pre></div><p class="calibre14">The new route <code class="email">about</code> will be mapped to the URL <code class="email">/aboutme now</code>.</p></li><li class="listitem" value="3">To test this, we can create a new template and add a <code class="email">link-to</code> helper to our application route. First, we'll create the template:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g template about</strong></span>
</pre></div><p class="calibre14">The Ember CLI generated will create the template for us. This will create the <code class="email">about.hbs</code> file in the <code class="email">app/templates</code> folder.</p></li><li class="listitem" value="4">Add the <code class="email">link-to</code> helper to the <code class="email">application.hbs</code> file:<div class="informalexample"><pre class="programlisting">// app/templates/about.hbs 
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}

{{#link-to 'about'}}about template{{/link-to}}</pre></div><p class="calibre14">The code creates a new link to the <code class="email">about</code> template in the main application template.</p></li><li class="listitem" value="5">Add a new <a id="id179" class="calibre1"/>message to the <code class="email">about</code> template that we just created:<div class="informalexample"><pre class="programlisting">// app/templates/about.hbs
&lt;br&gt;Hello from the about route!&lt;br&gt;</pre></div><p class="calibre14">This text will be displayed only when we navigate to this new route.</p></li><li class="listitem" value="6">We can now run the server and check the output. Run <code class="email">ember server</code> and click on the <span class="strong"><strong class="calibre9">about template</strong></span> link. The about route will load and will look as follows:<div class="mediaobject"><img src="../images/00008.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Application route</strong></span></p><p class="calibre8">When your app first boots up, the application route is loaded. Just like any other route, the application template will load by default. The application route is given for free and does not need to be added to the <code class="email">app/router.js</code> file. The <code class="email">{{outlet}}</code> will be used to render all other routes. It's a good idea to put the header, footer, and other decorative content here.</p></div></li></ol><div class="calibre15"/></div><div class="book" title="Working with nested routes in your application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec42" class="calibre1"/>Working with nested routes in your application</h3></div></div></div><p class="calibre8">At times, you <a id="id180" class="calibre1"/>may need multiple levels of routes. You might need templates within other templates. This can be accomplished using nested routes.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's say that we had <code class="email">about</code> with a nested <code class="email">location</code> and <code class="email">job</code> route:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('about', function() {
    this.route('location');
    this.route('job');
  });
});

export default Router;</pre></div></li><li class="listitem" value="2">The router <code class="email">map</code> has the highest-level route called <code class="email">about</code>. Underneath this route is the <code class="email">location</code> and <code class="email">job</code>. Create two templates needed for <code class="email">location</code> and <code class="email">job</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g template about/location</strong></span>
<span class="strong"><strong class="calibre9">$ ember g template about/job</strong></span>
<span class="strong"><strong class="calibre9">$ ember g template about</strong></span>
</pre></div><p class="calibre14">This will create the correct <code class="email">location.hbs</code> and <code class="email">job.hbs</code> files in the <code class="email">app/templates/about</code> folder as well as the <code class="email">about.hbs</code> file in the <code class="email">app/templates</code> folder.</p></li><li class="listitem" value="3">For us to be able to access nested routes, we'll need to edit <code class="email">about.hbs</code> and add <code class="email">outlet</code> for the <code class="email">location</code> and <code class="email">job</code> nested routes:<div class="informalexample"><pre class="programlisting">// app/templates/about.hbs
&lt;br&gt;Hello from the about route&lt;br&gt;
{{#link-to 'about.location'}}location{{/link-to}}&lt;br&gt;
{{#link-to 'about.job'}}job{{/link-to}}
&lt;br&gt;{{outlet}}&lt;br&gt;</pre></div><p class="calibre14">Note how the <code class="email">link-to</code> helpers route to <code class="email">about.location</code>. You can link nested routes with the dot notation. The <code class="email">location</code> and <code class="email">job</code> nested routes will render in <code class="email">{{outlet}}</code>.</p></li><li class="listitem" value="4">Just to <a id="id181" class="calibre1"/>make things interesting, we'll <a id="id182" class="calibre1"/>update the <code class="email">job</code> and <code class="email">location</code> route templates:<div class="informalexample"><pre class="programlisting">// app/templates/about/location.hbs
Hello from about/location route

// app/templates/about/job.hbs
Hi from the about/job route</pre></div></li><li class="listitem" value="5">Finally, we'll add a <code class="email">link-to</code> helper to the application route:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
&lt;br&gt;
&lt;br&gt;

{{#link-to 'about'}}Hello{{/link-to}}
{{outlet}}</pre></div><p class="calibre14">The <code class="email">link-to</code> helper will route to about. This will be rendered in <code class="email">outlet</code>.</p></li><li class="listitem" value="6">After running <code class="email">ember server</code>, you'll have access to click on the links and go between the routes. It should look similar to the following image:<div class="mediaobject"><img src="../images/00009.jpeg" alt="Working with nested routes in your application" class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">If we click on the <span class="strong"><strong class="calibre9">job</strong></span> link, the URL changes to <code class="email">http://localhost:4200/about/job</code>. The <code class="email">{{outlet}}</code> in the <code class="email">about</code> template <a id="id183" class="calibre1"/>will then display <a id="id184" class="calibre1"/>the <code class="email">job</code> template information.</p></li></ol><div class="calibre15"/></div></div><div class="book" title="Adding a wildcard"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec43" class="calibre1"/>Adding a wildcard</h3></div></div></div><p class="calibre8">You can <a id="id185" class="calibre1"/>use wildcards in your routes. This allows you to create URLs that match multiple segments. Let's create a wildcard for any URL that isn't found.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, update the <code class="email">router.js</code> file in the <code class="email">app</code> folder:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
    this.route('page-not-found', {path: '/*wildcard' });
});

export default Router;</pre></div><p class="calibre14">The <code class="email">/*wildcard </code>path will catch all the undefined routes and route them to <code class="email">page-not-found</code>.</p></li><li class="listitem" value="2">Create a new <code class="email">page-not-found</code> template:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g template page-not-found</strong></span>

<span class="strong"><strong class="calibre9">// app/templates/page-not-found</strong></span>
<span class="strong"><strong class="calibre9">&lt;br&gt;Not Found&lt;/br&gt;</strong></span>
</pre></div><p class="calibre14">This route will render in the <code class="email">application.hbs</code> outlet whenever a user navigates to a URL that matches <code class="email">/*</code> and no existing routes match.</p></li></ol><div class="calibre15"/></div></div><div class="book" title="Adding dynamic segments to our about application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec44" class="calibre1"/>Adding dynamic segments to our about application</h3></div></div></div><p class="calibre8">One <a id="id186" class="calibre1"/>important responsibility of the route is <a id="id187" class="calibre1"/>to load a model. In this example, we'll create a simple dynamic segment in the router that lists multiple jobs for the about route.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, edit the <code class="email">router.js</code> file and add the following code:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
    this.route('about', function(){
        this.route('location', {path: '/about/:location_id'});
    });
});

export default Router;</pre></div></li><li class="listitem" value="2">View <a id="id188" class="calibre1"/>the output, and we can see <a id="id189" class="calibre1"/>that the router map shows an <code class="email">about</code> route and a nested <code class="email">location</code> route below it. The <code class="email">location</code> route is a dynamic segment that starts with <code class="email">:</code> and is followed by an identifier. The <code class="email">:location_id</code> identifier will retrieve the model information from the <code class="email">location</code> model.<p class="calibre14">For example, if a user navigates to <code class="email">/about/5</code>, the route will set <code class="email">location_id</code> of <code class="email">5</code> so that the <code class="email">location</code> model with the ID of <code class="email">5</code> is loaded. We'll be going over the <code class="email">about</code> routes in more detail in the next section.</p><div class="note" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Index routes</strong></span></p><p class="calibre8">At every level of nesting, including the application layer, Ember.js automatically creates a <a id="id190" class="calibre1"/>route called <span class="strong"><strong class="calibre9">index</strong></span>. You don't need to map this in <code class="email">router.js</code>. Similar to the application route, it's already there. The index route will automatically be rendered in the outlet of its parent's template. For example, if you created an <code class="email">index.hbs</code> file in the <code class="email">app/templates</code> folder, it would automatically be rendered in the <code class="email">application.hbs</code> outlet. Keep this in mind when you create routes.</p></div></li></ol><div class="calibre15"/></div></div></div></div>

<div class="book" title="Defining an application route">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec61" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Routes in Ember.js are defined in the <code class="email">app/router.js</code> file. The router map is used to define each route, and it tells the Ember application what path should be used in the URL. By convention, each route has a corresponding template with the same name. Wildcards and dynamic segments can make routes more versatile so that they can load specific data.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Setting up a route model" id="173721-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Setting up a route model</h1></div></div></div><p class="calibre8">Occasionally, you'll need to retrieve data from a model for a template. The route is responsible <a id="id191" class="calibre1"/>for loading the appropriate model. This recipe will go over how to do this.</p></div>

<div class="book" title="Setting up a route model" id="173721-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec62" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new application, open the <code class="email">router.js</code> file and add a new route. We'll call this route <code class="email">students</code>:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('students');
});

export default Router;</pre></div><p class="calibre14">The <code class="email">students</code> route will retrieve data from the <code class="email">students</code> route handler.</p></li><li class="listitem" value="2">Generate the <code class="email">students</code> route. This will create the <code class="email">students</code> route handler and template:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route students</strong></span>
</pre></div></li><li class="listitem" value="3">In the <code class="email">students.js</code> file, add a new model that returns a JavaScript object:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return [1,2,3,4,5,6,7];
    }
});</pre></div><p class="calibre14">The <code class="email">model</code> hook normally returns an Ember Data record. However, it can also return any promise objects, plain JavaScript objects, or arrays. Ember will wait until the data is loaded or the promise is resolved before rending the template.</p><p class="calibre14">For simplicity in our example, we returned an array.</p></li><li class="listitem" value="4">Create a simple <code class="email">each</code> loop in the template to display the data from <code class="email">model</code>:<div class="informalexample"><pre class="programlisting">// app/templates/students.hbs
{{#each model as |number|}}
    Number: {{number}}&lt;br&gt;
{{/each}}</pre></div><p class="calibre14">The <code class="email">each</code> <a id="id192" class="calibre1"/>loop will display each <code class="email">number</code> in the array. The model data is returned from the route that we created earlier.</p></li><li class="listitem" value="5">Run <code class="email">ember server</code> and load the route at <code class="email">http://localhost:4200/students</code>. It will look like the following image after it is rendered:<div class="mediaobject"><img src="../images/00010.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Setting up a route model" id="173721-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec63" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">A very important job of a route is loading the model. Models are objects that represent data that your application may present to the user. The route can return an Ember Data record, array, or object.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Handling dynamic segments inside routes"><div class="book" id="181NK2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Handling dynamic segments inside routes</h1></div></div></div><p class="calibre8">Using <a id="id193" class="calibre1"/>dynamic segments and dynamic models is an <a id="id194" class="calibre1"/>important aspect of routes. The following recipe will go over how this can be accomplished.</p></div>

<div class="book" title="Handling dynamic segments inside routes">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec64" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before we begin our <a id="id195" class="calibre1"/>recipes, we'll need to set up a plugin called <span class="strong"><strong class="calibre9">Ember CLI Mirage</strong></span>. Ember plugins, also known as <a id="id196" class="calibre1"/>
<span class="strong"><strong class="calibre9">add-ons</strong></span>, make it easy to share common code between applications. The Ember CLI Mirage plugin makes it easy to create a mock server so that we can develop, test, and prototype our data. We won't cover too much of this add-on in this chapter. If you'd like more information, you can download it at <a class="calibre1" href="https://github.com/samselikoff/ember-cli-mirage">https://github.com/samselikoff/ember-cli-mirage</a>.</p><p class="calibre8">In this <a id="id197" class="calibre1"/>example, we'll use the <span class="strong"><strong class="calibre9">Ember Data's RESTAdapter</strong></span>, not the <a id="id198" class="calibre1"/>new <span class="strong"><strong class="calibre9">JSON API</strong></span> adapter.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, run this installation command in the <code class="email">application</code> folder:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember install ember-cli-mirage@0.1.11</strong></span>
</pre></div><p class="calibre14">This will install version <code class="email">0.1.11</code> of Ember CLI Mirage, Bower, and <code class="email">npm</code> packages in the application. We'll be using this version for all the examples in the book.</p></li><li class="listitem" value="2">Open the <code class="email">config.js</code> file in the <code class="email">app/mirage</code> folder. Add a couple of new routes:<div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

this.get('/students');
this.get('/students/:id');
}</pre></div><p class="calibre14">The first fake route, <code class="email">/students</code>, will return all the student data from our Mirage in the memory database. The second fake route, <code class="email">/students/:id</code>, will return only the data that matches the ID in the URL. This will be used later when we try out dynamic segments with our models.</p></li><li class="listitem" value="3">Create a new set of fixture data for <code class="email">students</code>. Create a new file called <code class="email">students.js</code> in the <code class="email">app/mirage/fixtures</code> directory:<div class="informalexample"><pre class="programlisting">// app/mirage/fixtures/students.js
export default [
  {id: 1, name: 'Jane Smith', age: 15},
  {id: 2, name: 'Erik Hanchett', age: 14},
  {id: 3, name: 'Suzy Q', age: 17}
];</pre></div><p class="calibre14">This file name, <code class="email">students.js</code>, matches the route and will be used to load the data in Mirages in the memory database. Be aware that Mirage also supports factories. Factories is an immensely powerful feature that makes it extremely easy to load lots of fake data. The factories can be used in test cases as well.</p><p class="calibre14">For simplicity's sake, we'll just use fixture data.</p></li><li class="listitem" value="4">Load a <a id="id199" class="calibre1"/>new scenario for our <a id="id200" class="calibre1"/>application. Update the <code class="email">app/mirage/scenarios/default.js</code> file:<div class="informalexample"><pre class="programlisting">// app/mirage/scenarios/default.js
export default function( server ) {

    server.loadFixtures();
}</pre></div><p class="calibre14">The <code class="email">default.js</code> file in the <code class="email">scenarios</code> folder is used to seed the database in development. The <code class="email">server.loadFixtures()</code> method loads all the fixture data so that it can be accessible to the <code class="email">/students</code> route.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Handling dynamic segments inside routes">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec65" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Data in our model may never change. On the other hand, that data might change many times depending on interactions with the user. This recipe will cover how to use dynamic segments with your routes and return data from the model.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Begin by creating a new resource called <code class="email">students</code>. Then generate an adapter named <code class="email">application</code> and finally, a route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g resource students</strong></span>
<span class="strong"><strong class="calibre9">$ ember g adapter application</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route application</strong></span>
</pre></div><p class="calibre14">This will generate the routes, adapter, and template files needed for this recipe. Keep in mind that by generating the <code class="email">application</code> route, you will be prompted to overwrite the <code class="email">application.hbs</code> file. You can select <span class="strong"><em class="calibre13">n</em></span>, for no, when this occurs.</p></li><li class="listitem" value="2">Update the <code class="email">router.js</code> file with the new dynamic segment route:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('students',  {path: '/students/:student_id'});
});

export default Router;</pre></div><p class="calibre14">This new <a id="id201" class="calibre1"/>route has a path of <code class="email">/students/:student_id</code>. This route will extract <code class="email">:student_id</code> from the <a id="id202" class="calibre1"/>URL and pass it to the model hook as the first argument.</p><p class="calibre14">For example, let's say that we have a list of <code class="email">students</code> and we wanted to be able to access each student's data by visiting <code class="email">/students/1</code> and <code class="email">/students/2</code>. Each URL would then return the data for that student.</p></li><li class="listitem" value="3">Update the <code class="email">application.js</code> file in the <code class="email">app/adapters</code> folder:<div class="informalexample"><pre class="programlisting">import DS from 'ember-data';

export default DS.RESTAdapter.extend({
});</pre></div><p class="calibre14">This will create a new <code class="email">RESTAdapter</code> that Ember will use for this example. This will be covered more in the models chapter.</p></li><li class="listitem" value="4">Edit the <code class="email">students.js</code> file in the <code class="email">app/models</code> folder. This file is our model and will be used to retrieve data from the Mirage mock server that we created earlier:<div class="informalexample"><pre class="programlisting"> // app/models/student.js
import DS from 'ember-data';

export default DS.Model.extend({
    name: DS.attr('string'),
    age: DS.attr('number')

});</pre></div><p class="calibre14">This creates a new model with two attributes, <code class="email">name</code> and <code class="email">age</code>. The model file defines what the data will look like. We'll be covering this more in the <span class="strong"><em class="calibre13">Chapter 7</em></span>, <span class="strong"><em class="calibre13">Ember Models and Ember Data</em></span>. For now, we will be retrieving this data from the mock server.</p></li><li class="listitem" value="5">Update <a id="id203" class="calibre1"/>the <code class="email">students.js</code> file in <a id="id204" class="calibre1"/>the <code class="email">app/routes</code> folder. Add the Ember Data <code class="email">findRecord</code> method:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(param) {
      return this.store.findRecord('student',param.student_id);
    }
});</pre></div><p class="calibre14">The <code class="email">model</code> hook here has one argument, <code class="email">param</code>. The <code class="email">param</code> argument is <code class="email">student_id</code> that is passed from the route's URL. Ember Data has a <code class="email">findRecord</code> method that takes two parameters. The first parameter is the name of the model and the second is the ID.</p><p class="calibre14">This model will return the student record with the ID passed to it. We can now use this in our template.</p></li><li class="listitem" value="6">Edit the <code class="email">students.hbs</code> file in the <code class="email">app/templates</code> folder. Add the model information:<div class="informalexample"><pre class="programlisting">// app/templates/students.hbs
{{model.name}}
{{model.age}}</pre></div><p class="calibre14">The <code class="email">{{model.name}}</code> and <code class="email">{{model.age}}</code> properties will retrieve the model information passed to the template from the route.</p><p class="calibre14">At this point, we should be able to run  <code class="email">ember server</code> and see data when we access <code class="email">http://localhost:4200/students/1</code>. To make things a little easier, we'll go ahead and create a new route handler for the main application route.</p></li><li class="listitem" value="7">Edit the <code class="email">application.js</code> file in the <code class="email">app/routes</code> folder:<div class="informalexample"><pre class="programlisting">// app/routes/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return this.store.findAll('student');
    }
});</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Multiple models</strong></span></p><p class="calibre8">At times, you may want to use multiple models in one route. This can be accomplished using <code class="email">Ember.RSVP.hash</code>. The hash takes parameters that return promises. When all the parameters are resolved, then <code class="email">Ember.RSVP.hash</code> is resolved. In the model, it may look like this: return <code class="email">Ember.RSVP.hash({ students: this.store.findAll('student')</code>, books: <code class="email">this.store.findAll('book')})</code>. Each model is separated by a comma.</p></div><p class="calibre14">This will allow our application to retrieve all the records from our student model.</p></li><li class="listitem" value="8">Open the <a id="id205" class="calibre1"/><code class="email">application.hbs</code> file in the <code class="email">app/templates</code> folder. We'll add an <code class="email">each</code> iterator that <a id="id206" class="calibre1"/>will link to each student's information:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Chapter 4&lt;/h2&gt;

{{#each model as |student|}}
    {{#link-to 'students' student.id}}{{student.name}}{{/link-to}}&lt;br&gt;
{{/each}}

{{outlet}} </pre></div><p class="calibre14">In this template, we are iterating through all the records in the <code class="email">student</code> model. We are using each individual student's name as a link to our dynamic segment. The <code class="email">student.id</code> argument is passed to the <code class="email">link-to</code> helper.</p></li><li class="listitem" value="9">After starting the server, you'll see a list of the students and a link to each student's information. After clicking on the student's name, the <code class="email">student.hbs</code> template will load with the student's information. It will look like the following image:<div class="mediaobject"><img src="../images/00011.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Handling dynamic segments inside routes">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec66" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Dynamic <a id="id207" class="calibre1"/>models allow data to change depending <a id="id208" class="calibre1"/>on the user action. This data will depend on the dynamic segment setup in the <code class="email">router.js</code> file. The segment is defined in the <code class="email">router</code> file and passed from the URL to the model hook as its first argument. Ember Data uses the <code class="email">findRecord</code> method to find the correct record and return it to the template so that it's available for use.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Defining routes with templates" id="190861-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>Defining routes with templates</h1></div></div></div><p class="calibre8">Another <a id="id209" class="calibre1"/>job of the route handler is rendering the appropriate <a id="id210" class="calibre1"/>template. Here is a recipe that goes over this.</p></div>

<div class="book" title="Defining routes with templates" id="190861-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec67" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In this recipe, we'll create a few nested routes and check where they get rendered.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, create a new <code class="email">students</code> and <code class="email">schools</code> route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route schools</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route schools/students</strong></span>
</pre></div><p class="calibre14">This will create the nested <code class="email">students</code> and <code class="email">schools</code> route.</p></li><li class="listitem" value="2">Let's take a look at the <code class="email">router.js</code> file:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('schools', {}, function() {
    this.route('students', {});
  });
});

export default Router;</pre></div><p class="calibre14">The <a id="id211" class="calibre1"/>generated command already created the <a id="id212" class="calibre1"/>routes that we need. The <code class="email">schools</code> route has a nested route called <code class="email">students</code>.</p><p class="calibre14">By convention, the route will render the template with the same name. Therefore, the <code class="email">schools</code> route will render to the <code class="email">schools.hbs</code> file while the <code class="email">students</code> route will be rendered to the <code class="email">schools/students.hbs</code> file.</p></li><li class="listitem" value="3">Update the <code class="email">schools.hbs</code> file:<div class="informalexample"><pre class="programlisting">// app/templates/schools.hbs
This is the school route&lt;br&gt;
{{outlet}}</pre></div><p class="calibre14">The <code class="email">{{outlet}}</code> will render the <code class="email">students.hbs</code> file in the <code class="email">schools</code> folder. Every template will be rendered to <code class="email">{{outlet}}</code> of its parent route's template.</p></li><li class="listitem" value="4">Update the <code class="email">students.hbs</code> file in the <code class="email">app/templates/schools</code> folder:<div class="informalexample"><pre class="programlisting">// app/templates/schools/students.hbs
This is the students route&lt;br&gt;
{{outlet}}</pre></div></li><li class="listitem" value="5">Run <code class="email">ember server</code> and you should see this result:<div class="mediaobject"><img src="../images/00012.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="6">By visiting <code class="email">http://localhost:4200/schools/students</code>, both the templates are displayed. The application <code class="email">{{outlet}}</code> renders the school template. The school template's <code class="email">{{outlet}}</code> renders the students template.</li><li class="listitem" value="7">If <a id="id213" class="calibre1"/>required, you can change where the route <a id="id214" class="calibre1"/>renders. Instead of rendering in the template with the same name, you can set it to anything using the <code class="email">renderTemplate()</code> method in the route handler:<div class="informalexample"><pre class="programlisting">// app/routes/school.js
import Ember from 'ember';

export default Ember.Route.extend({
  renderTemplate() {
    this.render('anotherSchool');
  }
});</pre></div><p class="calibre14">The school route will now render to the <code class="email">anotherSchool</code> template.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Defining routes with templates" id="190861-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec68" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Routes, by default, will render a template based on the same name as the route. Ember does this by convention. On the other hand, using <code class="email">renderTemplate</code> in the route handler can change this default. This is all done under the hood by the Ember API.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using redirection with routes" id="19UOO1-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Using redirection with routes</h1></div></div></div><p class="calibre8">A very <a id="id215" class="calibre1"/>important feature of routes is redirection. This <a id="id216" class="calibre1"/>recipe will go over using the <code class="email">transitionTo</code> method.</p></div>

<div class="book" title="Using redirection with routes" id="19UOO1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec69" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In our route handler, we have special hooks called <code class="email">beforeModel</code> and <code class="email">afterModel</code>. We can use these hooks to perform actions before the model is loaded or after the model is loaded. The <code class="email">transitionTo</code> method can be used to redirect the application to different routes.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new application, create a new <code class="email">students</code> route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route students</strong></span>
</pre></div><p class="calibre14">This will generate the <code class="email">students</code> route and template files.</p></li><li class="listitem" value="2">For the sake <a id="id217" class="calibre1"/>of simplicity, we'll have the route handler return a simple array of numbers:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return [1,2,3,4,5,6,7,8,9];
    }
});</pre></div></li><li class="listitem" value="3">Edit the <code class="email">routes/students.js</code> file again. This time, we'll add a before hook and a transition to it:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
…
beforeModel(){
  this.transitionTo('teachers');
}</pre></div><p class="calibre14">The <code class="email">transitionTo</code> method will redirect from one route to another. This option will redirect before the model is loaded and transition to the teacher's route.</p></li><li class="listitem" value="4">We can <a id="id218" class="calibre1"/>also transition after the model is loaded using the <code class="email">afterModel()</code> hook:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
…
afterModel(){
  this.transitionTo('teachers');
}</pre></div><p class="calibre14">This will wait until the model is fully loaded before transitioning to the new route. You can check the loaded route before transitioning, if needed.</p><div class="note" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Redirect</strong></span></p><p class="calibre8">When transitioning to nested routes, it's a good idea to use the <code class="email">redirect</code> method instead of the <code class="email">afterModel</code> or <code class="email">beforeModel</code> hooks. This will prevent <code class="email">beforeModel</code>, <code class="email">afterModel</code>, and model from firing again after redirecting. Keep this in mind when dealing with <code class="email">transitionTo</code> in nested routes.</p></div></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Using redirection with routes" id="19UOO1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec70" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="email">afterModel</code> and <code class="email">beforeModel</code> hooks occur after or before a model is loaded. The <code class="email">transitionTo</code> <a id="id219" class="calibre1"/>method is used to redirect from one route to another. It can be used in the route handler or anywhere else in the application.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with asynchronous routing" id="1AT9A1-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec39" class="calibre1"/>Working with asynchronous routing</h1></div></div></div><p class="calibre8">A more <a id="id220" class="calibre1"/>advanced feature of the router is dealing with asynchronous logic. The following recipes explain this concept using promises.</p></div>

<div class="book" title="Working with asynchronous routing" id="1AT9A1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec71" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In the route, Ember makes heavy use of promises. Promises are objects that represent an eventual value. We can use promises in our model.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new router for the application route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route application</strong></span>
</pre></div><p class="calibre14">If prompted to overwrite the template, type <code class="email">Y</code>. This will generate the router file for the default application route.</p></li><li class="listitem" value="2">Add a new <a id="id221" class="calibre1"/>model to the <code class="email">application.js</code> file in the <code class="email">app/router</code> folder:<div class="informalexample"><pre class="programlisting">// app/router/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return  new Ember.RSVP.Promise(function(resolve) {
        resolve({message: 'Resolved'});
      });
    } ,
    setupController(controller, model){
      this._super(controller, model);
      console.log(model.message);
    }
});</pre></div><p class="calibre14">In the router, we created a new model. This model will be accessible to our application template. In this model, we are returning <code class="email">Ember.RSVP.Promise</code>, which is Ember's way of dealing with a promise. It can either resolve or reject. For the sake of simplicity, we are having it return a message.</p><p class="calibre14">The <code class="email">setupController</code>  hook to set up the controller for the current route. As we are overwriting <code class="email">setupController</code>, it also overwrites its default behavior. Therefore, we must call <code class="email">super</code> on it. Otherwise it may effect how it normally behaves. We can use <code class="email">console.log</code> to output the model message to the console.</p><div class="note" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Asynchronous routing</strong></span></p><p class="calibre8">During a transition, the model hook is fired in the router. If, during this transition, the model is returning an array, it will return immediately. On the other hand, if the model is returning a promise, it must wait for this promise to fulfill or reject. The router will consider any object with a <code class="email">then</code> method defined on it to be a promise. After the promise fulfills, the transition will continue from where it left off. It's possible to chain multiple promises, so the next promise or model must be fulfilled before the transition will be complete.</p></div></li><li class="listitem" value="3">Let's edit the <a id="id222" class="calibre1"/>application router one more time and set it to reject:<div class="informalexample"><pre class="programlisting">// app/routes/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return Ember.RSVP.Promise.reject('error');
    },
    setupController(controller, model)
       this._super(controller, model);
       console.log(model.message);
    },
    actions: {
      error(reason){
        console.log(reason);
      }
    }
});</pre></div><p class="calibre14">In the preceding code, the model returns a rejected promise. As described in the <span class="strong"><em class="calibre13">Loading and error handling</em></span> recipe, there is something called an <code class="email">error</code> event. This will fire only when an error occurs in the model. We can then log the error to the console.</p></li><li class="listitem" value="4">We can test this by editing the <code class="email">application.hbs</code> file in the <code class="email">app/templates</code> folder:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
{{outlet}}

Message: {{model.message}}</pre></div><p class="calibre14">If the promise doesn't reject, the model message will be displayed. If the model rejects, then nothing will be displayed; the route halts the loading and the console will show the message, <span class="strong"><strong class="calibre9">error</strong></span>.</p><p class="calibre14">Error events bubble upwards. In this case, we are already on the application route and it can't bubble up any further. If we were in another route, we could have returned true and that error would have bubbled up to the application error event.</p></li><li class="listitem" value="5">Edit the <a id="id223" class="calibre1"/><code class="email">application.js</code> file again in the <code class="email">app/router</code> folder. Let's deal with the rejection:<div class="informalexample"><pre class="programlisting">// app/routers/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model() {
      return new Ember.RSVP.Promise(function(resolve,reject) {
        reject('error');
      }).then(null, function() {
        return {message: 'Returned from rejection};
      });
    },
    setupController(controller, model){
      this._super(controller, model);
      console.log(model.message);
    },
    actions: {
      error(reason){
        console.log(reason);
      }
    }

});</pre></div><p class="calibre14">In the preceding code, the <code class="email">RSVP</code> promise rejects. However, we then return the message anyway, by chaining another promise at the end. This way the transition won't halt and will continue.</p></li><li class="listitem" value="6">Run <code class="email">ember server</code> and open a web page. You should see this message:<div class="mediaobject"><img src="../images/00013.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">This message shows <span class="strong"><strong class="calibre9">Returned from rejection</strong></span> because we handled the promise reject callback and returned a message anyway.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Working with asynchronous routing" id="1AT9A1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec72" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Promises are a way for Ember to handle asynchronous logic. A promise is an object that represents an eventual value. The promise can either reject or fullfill, as in resolve a value. To <a id="id224" class="calibre1"/>retrieve the value or handle when it rejects, you can use the then method, which can accept two different callbacks. The first is for fulfillment and the second is for rejection. For example, you might use the rejection to retry or return different data.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Loading and error handling" id="1BRPS1-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Loading and error handling</h1></div></div></div><p class="calibre8">When <a id="id225" class="calibre1"/>routes are loading or there's an error, we have the ability to let the user know what's happening. This recipe will go over the basics on how to do this.</p></div>

<div class="book" title="Loading and error handling" id="1BRPS1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec73" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, create a new <code class="email">students</code> route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route students</strong></span>
</pre></div><p class="calibre14">The <code class="email">ember generate</code> command will create all the necessary files for the <code class="email">students</code> route.</p></li><li class="listitem" value="2">Edit the <code class="email">students.js</code> file in the <code class="email">app/routes</code> folder. Add a new model to return:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return new Ember.RSVP.Promise(function (resolve, reject) {
        Ember.run.later((function() {
          resolve( [1,2,3,4,5,6,7,8,9]);
        }), 2000);
      });
    }
});</pre></div><p class="calibre14">In our route file, we are returning an Ember <code class="email">RSVP</code> promise. This promise resolves to a simple array that will be returned. <code class="email">Ember.run.later</code> is a built-in Ember method that is a part of the Ember run loop. It acts like the JavaScript's <code class="email">setTimeout()</code>. In this case, we are setting the timeout for 2,000 milliseconds so that we can simulate what might occur if the model was slow to load. After two seconds pass, the resolve will return with the array.</p></li><li class="listitem" value="3">Add a <a id="id226" class="calibre1"/>loading substate template in the <code class="email">app/templates</code> folder:<div class="informalexample"><pre class="programlisting"> // app/templates/students-loading.hbs
&lt;h1&gt; Loading! Please wait! &lt;/h1&gt;</pre></div><p class="calibre14">This substate will be loaded while the students route is loading. A loading substate is created by adding a template with the name of the route and a dash loading at the end. For example, for the students route in our example, we called the <code class="email">students-loading.hbs</code> substate. The application loading the substate would be <code class="email">application-loading.hbs</code>.</p></li><li class="listitem" value="4">As an alternative to substates, we can use a loading event in the route. If the <code class="email">beforeModel</code>, <code class="email">model</code>, and <code class="email">afterModel</code> hooks don't resolve immediately, the loading event will be fired. Add a new loading action that displays an alert box while the model loads and transitions to the application route:<div class="informalexample"><pre class="programlisting">// app/routes/students.js
…
    },
    actions: {
      loading(transition, originRoute) {
        alert('Sorry this page is taking so long to load!');
        this.transitionTo('application');
      }
    }
…</pre></div><p class="calibre14">The alert box will fire while the route is loading.</p></li><li class="listitem" value="5">Navigate <a id="id227" class="calibre1"/>to <code class="email">http://localhost:4200/students</code> and you'll see the alert box while the model is loading.</li></ol><div class="calibre15"/></div><div class="book" title="Creating an error substate"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec45" class="calibre1"/>Creating an error substate</h3></div></div></div><p class="calibre8">Error <a id="id228" class="calibre1"/>substates occur whenever an error is encountered. It's very similar to the loading substate.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new application, create a <code class="email">teachers</code> route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route teachers</strong></span>
</pre></div><p class="calibre14">This will create all the necessary files for the <code class="email">teachers</code> route.</p></li><li class="listitem" value="2">Edit the <code class="email">teachers.js</code> file in the <code class="email">app/routes</code> folder. Add a new <code class="email">Ember.RSVP.Promise</code> with a reject:<div class="informalexample"><pre class="programlisting">// app/routes/teachers.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return new Ember.RSVP.Promise(function (resolve, reject) {
        reject('error');
      });
    }</pre></div><p class="calibre14">In this example, we return a new <code class="email">Ember.RSVP.Promise</code> that will reject. This will cause an error to occur.</p></li><li class="listitem" value="3">Create a new <code class="email">teachers-error.hbs</code> file in the <code class="email">app/templates</code> folder. This will be displayed when an error occurs in the <code class="email">teachers</code> route:<div class="informalexample"><pre class="programlisting">// app/templates/teachers-error.hbs
&lt;h1&gt;Error Loading!&lt;/h1&gt;</pre></div><p class="calibre14">Error substates, like loading substates, must be named after the route with a dash loading at the end. The template will be displayed during an error and doesn't need any other logic to occur.</p></li><li class="listitem" value="4">Alternatively, you can also use the error event in the route to display an error and redirect to a different route:<div class="informalexample"><pre class="programlisting">// app/routes/teachers.js
…
   },
    actions: {
      error(error, transition) {
        alert('Sorry this page is taking so long to load!');
        this.transitionTo('application');
      }
    }</pre></div><p class="calibre14">Using the error event is just another way to handle errors. We could certainly have created an error route to transition to.</p></li></ol><div class="calibre15"/></div></div></div></div>

<div class="book" title="Loading and error handling" id="1BRPS1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec74" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The Ember <a id="id229" class="calibre1"/>route has built-in methods and events to handle errors and loading. When loading information, the model hook is waiting for the query to get completed. During this time, a template with the name dash loading at the end will be transitioned to immediately and synchronously. The URL will not be effected. After the query completes, the loading route will be exited and the original route will continue.</p><p class="calibre8">When dealing with errors, the error template will be loaded. Once again, the URL will not change to the error route. The error will be passed to the error state as it's model.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using query parameters"><div class="book" id="1CQAE2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec41" class="calibre1"/>Using query parameters</h1></div></div></div><p class="calibre8">Query <a id="id230" class="calibre1"/>parameters allow you to use the URL for the application state. In these recipes, we'll use query parameters in several different ways to show how it works.</p></div>

<div class="book" title="Using query parameters">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec75" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Query parameters are optional key-value pairs. They will appear to the right of ? in a URL.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, generate a new <code class="email">application</code> controller:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g controller application</strong></span>
</pre></div><p class="calibre14">The <code class="email">application</code> controller will be generated in the <code class="email">app/controllers</code> folder.</p></li><li class="listitem" value="2">Update the application controller with a new <code class="email">queryParams</code> for <code class="email">student</code>:<div class="informalexample"><pre class="programlisting">/ app/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({
    queryParams: ['student'],
    student: null
});</pre></div><p class="calibre14">This will set up the binding between the <code class="email">student</code> query parameter in the URL and the <code class="email">student</code> property in the controller. If either one changes, the other will change as well.</p><p class="calibre14">If the <code class="email">student</code> property was set to anything other than null, then the <code class="email">student</code> <a id="id231" class="calibre1"/>property will have a default value. This is important to remember because query parameter values are cast to the same datatype as the default value. In other words, if the student property was defaulted to the number <span class="strong"><em class="calibre13">1</em></span> and you changed the URL to <code class="email">/?student=2</code>, the property would be set to the number <code class="email">2</code>, not the string <code class="email">"2"</code>. Additionally, remember that default values will not be serialized in the URL.</p></li><li class="listitem" value="3">Update the <code class="email">application.hbs</code> file in the <code class="email">app/templates</code> folder. We'll add the <code class="email">student</code> property to test:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}
student: {{student}}</pre></div><p class="calibre14">This is a very simple template that just displays the <code class="email">student</code> information from the controller.</p></li><li class="listitem" value="4">Start Ember server and try changing the URL. Navigate to <code class="email">http://localhost:4200?students=Erik</code>. The template will be updated in order to display the new student information:<div class="mediaobject"><img src="../images/00014.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li></ol><div class="calibre15"/></div><p class="calibre8">Everything to the right of the question mark ? in the URL can be used in the query parameter. Each parameter is separated by an ampersand. In this case, the student property is set to <a id="id232" class="calibre1"/>Erik. This will be updated in the template.</p><div class="book" title="Adding a link-to helper with a query parameter"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec46" class="calibre1"/>Adding a link-to helper with a query parameter</h3></div></div></div><p class="calibre8">It's <a id="id233" class="calibre1"/>important to realize that we can pass <a id="id234" class="calibre1"/>query parameters using the <code class="email">link-to</code> helper.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In a new project, create a new <code class="email">application.js</code> controller:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g controller application</strong></span>
</pre></div><p class="calibre14">This will generate the <code class="email">application</code> controller that we can use for our query parameter.</p></li><li class="listitem" value="2">Edit the application controller and add a new query parameter:<div class="informalexample"><pre class="programlisting">// app/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({
    queryParams: ['student'],
    student: null
});</pre></div><p class="calibre14">In this example, we created a simple query parameter called <code class="email">student</code>.</p></li><li class="listitem" value="3">Update the <code class="email">application.hbs</code> file in the <code class="email">app/templates</code> folder. Add the <code class="email">student</code> property and new <code class="email">link-to</code> helper with a query parameter:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}
student: {{student}}&lt;br&gt;
{{#link-to 'application' (query-params student='Jane')}}Jane Query{{/link-to}}</pre></div><p class="calibre14">You <a id="id235" class="calibre1"/>can add a query parameter <a id="id236" class="calibre1"/>to <code class="email">link-to</code> by surrounding it with parentheses and using the <code class="email">query-params</code> sub-expression helper. After the sub-expression comes the key-value pair. In this case, we have a <code class="email">student</code> key.</p></li><li class="listitem" value="4">Start Ember server and click on the <span class="strong"><strong class="calibre9">Jane Query</strong></span> link. The following page should appear:<div class="mediaobject"><img src="../images/00015.jpeg" alt="Adding a link-to helper with a query parameter" class="calibre10"/></div><p class="calibre26"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Using TransitionTo with query parameters</strong></span></p><p class="calibre8">Query parameters can be used when transitioning routes with the <code class="email">transitionTo</code> method. You can add the query parameter as the final argument with the object key, <code class="email">queryParmams</code>. For example, if you need to transition to the application route and you need to pass the query parameter for student, it might look like this:</p><p class="calibre8"><code class="email">this.transitionTo('application', { queryParams: { student: 'Erik' }});</code></p></div></li></ol><div class="calibre15"/></div></div><div class="book" title="Resetting a controller's query parameters"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec47" class="calibre1"/>Resetting a controller's query parameters</h3></div></div></div><p class="calibre8">By <a id="id237" class="calibre1"/>default, query parameters are sticky. In other words, they are preserved when you move in and out of the route. They will also preserve the model loaded in the route.</p><p class="calibre8">You can override this behavior in a couple of ways. One is to pass the default query parameter to the <code class="email">link-to</code> helper or use <code class="email">transitionTo</code>. The other way is to use the <code class="email">Route.resetController</code> hook.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new project and generate a new route called <code class="email">route1</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route route1</strong></span>
<span class="strong"><strong class="calibre9">$ ember g controller route1</strong></span>
</pre></div><p class="calibre14">This will create a new route and controller for <code class="email">route1</code>.</p></li><li class="listitem" value="2">Edit the <code class="email">route1.js</code> file in the <code class="email">app/controllers</code> folder:<div class="informalexample"><pre class="programlisting">// app/controllers/route1.js
import Ember from 'ember';

export default Ember.Controller.extend({
    queryParams: ['student'],
    student: null,
});</pre></div><p class="calibre14">Just like our previous example, we are using a simple query parameter called <code class="email">student</code>.</p></li><li class="listitem" value="3">Edit the <code class="email">route1.js</code> file in the <code class="email">app/routes</code> folder. Add a new <code class="email">resetController</code> hook to the route:<div class="informalexample"><pre class="programlisting">// app/routes/route1.js
import Ember from 'ember';

export default Ember.Route.extend({
    resetController: function (controller, isExiting, transition) {
        this._super(controller,isExiting,transition);
        if (isExiting) {
          controller.set('student', null);
        }
    }
});</pre></div><p class="calibre14">In this route, we are using the <code class="email">resetController</code> hook. This will fire whenever someone exits or transitions from the route. As before, we must call super so that we don't prevent the default behavior. The <code class="email">isExiting</code> argument will be false only if the route's model is changing, otherwise it will fire.</p><p class="calibre14">The <code class="email">controller.set</code> method is a way in which we can access the student property. We'll set it to null so that when we move away from route1, it will not be preserved.</p></li><li class="listitem" value="4">Edit the <a id="id238" class="calibre1"/><code class="email">application.hbs</code> file in the <code class="email">app/templates</code> folder. Add a <code class="email">link-to</code> helper to the new <code class="email">route1</code> route:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;
{{#link-to 'route1'}}Route 1{{/link-to}}&lt;br&gt;
{{outlet}}</pre></div><p class="calibre14">This template is very simple. All we are doing is creating a link to the new <code class="email">route1</code>.</p></li><li class="listitem" value="5">Edit the <code class="email">route1.hbs</code> file in the <code class="email">app/templates</code> folder. Add the <code class="email">student</code> property and a link back to the main <code class="email">application</code> route:<div class="informalexample"><pre class="programlisting">Route 1&lt;br&gt;
student: {{student}}&lt;br&gt;
{{#link-to 'application'}}App{{/link-to}}&lt;br&gt;</pre></div><p class="calibre14">This template displays the <code class="email">student</code> property that we can set via query parameters. It then has a link back to the main <code class="email">application</code> route.</p></li><li class="listitem" value="6">Run <code class="email">ember server</code> and load the application. Enter the URL, <code class="email">http://localhost:4200/route1?student=Erik</code>. This will display <code class="email">route1</code> with the query parameter for student. If you click on the app link, it will bring you back to the main application. If you click on the <span class="strong"><strong class="calibre9">Route 1</strong></span> link again, it will not preserve the query parameter and will be reset. It will look like the following image:<div class="mediaobject"><img src="../images/00016.jpeg" alt="Resetting a controller's query parameters" class="calibre10"/></div><p class="calibre26"> </p></li></ol><div class="calibre15"/></div></div></div></div>

<div class="book" title="Using query parameters">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec76" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Query <a id="id239" class="calibre1"/>parameters are key-value pairs that appear to the right of ? in the URL of the application. They help define an additional application state by serializing data in the URL. They are set in the route-driven controllers. We can use <code class="email">transitionTo</code> and <code class="email">link-to</code> helpers to navigate to them easily.</p></div></div></body></html>