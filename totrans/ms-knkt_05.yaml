- en: Chapter 5. Durandal – the Knockout Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to use RequireJS and SammyJS with
    Knockout, to add more standard functionality to our frontend stack with module
    definitions and client-side routing. Both of these concepts have become very common
    in the JavaScript world; you might even consider them as a standard for modern
    web applications. Knockout is a library and not a framework, in that it fills
    a specific role—data-binding—instead of trying to be the entire development framework
    for the frontend. This leaves a lot of decisions to be made if you want to create
    a modern JavaScript client, which can be burdensome, time-consuming, and, if your
    team is divided, contentious. Durandal is a framework that attempts to make many
    of these decisions while still keeping Knockout's MVVM philosophy in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Durandal was created by Blue Spire, whose principal developer, Rob Eisenberg,
    also created the popular WPF framework Caliburn.Micro, another MVVM framework.
    Over the next two chapters, we will be looking at how Durandal can help us build
    web applications easily while leveraging all of our experience and custom code
    from Knockout. This chapter is going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Durandal framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composition system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application's life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we will be using the `Contacts` application with the chapter's examples.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Durandal framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Durandal is built on top of Knockout, jQuery, and RequireJS. Durandal's core
    is a collection of AMD modules, which provide composition, events, and activation
    features, as well as some utility functions. In addition to the core modules,
    Durandal also provides several plugins that can optionally be activated, or added
    to with community or personal plugins. The plugins include the router (a basic
    requirement for every SPA framework), dialogs, and widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation for Durandal can be found at [http://durandaljs.com/docs.html](http://durandaljs.com/docs.html).
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To bring all of this together, Durandal's internal and external communication
    is handled through **promises**. If you aren't familiar with JavaScript promises—sometimes
    called *thenables* because they provide a `then` method—you're missing out. To
    explain briefly, promises change the way asynchronous actions are handled by replacing
    a callback with a return object that represents the asynchronous work. It allows
    asynchronous tasks to be chained, and does error handling in a simple, easy-to-debug
    manner. I won't be covering how promises work here, but it is going to be relevant.
    You should read up on them if you haven't already done so.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with promises, you may already know that jQuery''s promise
    implementation does not match the A+ specification ([https://promisesaplus.com](https://promisesaplus.com)),
    which most other promise libraries conform to. To minimize third-party dependencies,
    Durandal uses jQuery''s promises by default, but their documentation provides
    a simple patch to allow the use of another promise implementation. This example,
    which uses Q (a very popular promise library), is taken from the Durandal documentation.
    Use it before the call to `app.start()` (we will learn more about this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer another library, simply replace `Q` in the preceding code. I will
    be using Durandal's default promises in this chapter for simplicity, but I encourage
    you to use an A+ compliant implementation in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While Durandal''s only real requirement on your filesystem is that all its
    core modules should be in the same folder and all its plugins should be in their
    own folder, there are some conventions for the way things are organized, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This should be familiar, as it isn''t too different from what we have been
    using. The `app` directory contains our code, the `lib` directory contains third-party
    code, and the `content` directory contains our CSS and other visual assets. Durandal''s
    entire source, which contains some of its own CSS, its core modules, as well as
    the standard plugins directory, is dropped into `lib`. Our `main.js` configuration
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There shouldn''t be anything surprising here, as we covered the configuration
    of RequireJS in the previous chapter. All of the paths, except `bootstrap`, are
    required by Durandal. After configuration, Durandal needs to be initialized; this
    is generally placed in `main.js`, just below `require.config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `app` and `system` modules are Durandal objects. The `system.debug` call
    instructs Durandal to log all of the steps it takes to the console, which is useful
    for development. The `app.configurePlugins` call registers the plugins to be installed,
    though they are not run until `app.start` is called. The `app.start` call initializes
    all the Durandal modules and installs the registered plugins. As `app.start` is
    a promise-returning function, a `then` method is attached, which calls `app.setRoot`
    when it is finished. The `setRoot` method composes the specified module into the
    DOM as the root viewmodel of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root of the application is placed inside a `div` element with the `applicationHost`
    ID, which is expected to be in the DOM already. As Durandal will take care of
    all the HTML rendering, the original DOM is pretty thin. It only requires the
    CSS that will be used, the `applicationHost` ID, and the `script` tag for RequireJS.
    This is the standard `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Durandal has been started and everything after this point is going
    to be your application's code.
  prefs: []
  type: TYPE_NORMAL
- en: The composition system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at Knockout's new components feature, which
    lets us construct view/viewmodel pairs by instantiating them from the DOM with
    custom elements (or bindings). Knockout released this feature after Durandal,
    so there is some overlap between the two. Durandal's composition is like a blend
    of the components and the template binding.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is primarily invoked in two ways, with `setRoot` to compose the
    `applicationHost` ID, and with the compose binding for data-bound values. Composition
    works by pairing a viewmodel with a view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Durandal's documentation refers to viewmodels as modules, which I think is a
    bit confusing. I will be referring to composable modules as viewmodels throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When composition is given a viewmodel, it looks up the view, loads it with the
    RequireJS's text loader, binds it to the view, and finally, attaches it to the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Composing the application''s root**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the root composition of our shell viewmodel. Our preceding sample
    was setting the root to `shell/shell`. If our `app` directory has a `shell` folder,
    the `shell.js` module will be loaded by `setRoot` and composed. Composition uses
    Durandal's `viewLocator` module to find an HTML file, by replacing the file extension
    of the module; so for `shell.js`, it will look for `shell.html` and use it as
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a very simple example of this in `cp5-shell`. The `shell` module
    is very simple, containing just a `title` property that we will bind to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Durandal expects views to be partial HTML documents. They should not contain
    an `HTML`, `HEAD`, or `BODY` element; they should contain only the HTML that will
    be used as the template for the DOM contents.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code, you will see that this HTML is rendered into the DOM, and
    the title is bound to the `shell` module's `title` property. The object returned
    by the `shell` module is used as the binding context for the shell's view.
  prefs: []
  type: TYPE_NORMAL
- en: The compose binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, the root of the application does not change, and instead, serves
    as the layout or shell for the HTML. It displays content that is present on every
    page (such as a navigation bar), and hence it doesn't need to change. Composition
    can also be invoked with the compose binding, which takes a viewmodel as a binding
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `cp5-composition` branch. Notice that the shell view is back to containing
    our familiar navigation bar, as well as a compose binding, in its main content
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell viewmodel has a `currentModel` property, as well as two functions,
    to switch the `currentModel` property between the `edit` and `list` page objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try pressing the buttons in the navigation bar to see the body content switch
    between the two pages. The compose binding is taking a module instance, locating
    its view, and binding the view as the content of the DOM. As `currentModel` is
    observable, the composition reruns anytime it changes.
  prefs: []
  type: TYPE_NORMAL
- en: As the `list` and `edit` objects are constructed once and just swapped, you
    should notice that values entered on the edit page are persistent. This is because,
    while the HTML is discarded and recreated when switching, the new HTML is still
    being bound against the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the brevity of this example doesn't undercut the power of the composition
    system. The fact that they are so small should highlight just how easy composition
    is to work with; just by swapping a bound value, we can toggle between two completely
    different pages!
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that composition is like a mirror of Knockout components.
    Instead of a custom element or binding in the DOM choosing what will be rendered,
    composition renders the value specified by JavaScript. This ends up having a large
    impact on flexibility. A component is the element that the DOM says it is, but
    a single compose binding can hold any module and it can change at any time. They
    may seem like competing features, but I think they are serving different goals.
  prefs: []
  type: TYPE_NORMAL
- en: Components are like advanced binding handlers, allowing the HTML to instantiate
    behavior-driven templates.
  prefs: []
  type: TYPE_NORMAL
- en: Composition uses the relationships created and managed by our viewmodel code
    and reflects them in the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Composition options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at two examples of composition—`setRoot` and the compose binding—that
    each took an instance of an object to compose. Of course, Durandal is a thoughtful
    framework, so the composition has several other modes of operation. The value
    taken by the compose binding can be any of the following.
  prefs: []
  type: TYPE_NORMAL
- en: Module instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've already covered this, but for the sake of completion, the compose binding
    can take an instance of a module and use it to locate the view. See the `cp5-composition`
    branch for an example. This is the most common use case for composition with the
    compose binding.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `cp5-composition2` branch, you can see a modified shell that sets the
    `currentModel` property to the constructor functions directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While this isn't a great use case, it is supported. Constructors are most commonly
    used for modules tied to the router, as a fresh viewmodel is generally desirable
    when navigating between pages. Unlike the previous example, which stored a reference
    to a constructed viewmodel for each page, this method will recreate the viewmodel
    each time it navigates.
  prefs: []
  type: TYPE_NORMAL
- en: Module ID strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to use strings for the compose binding value. The first
    is by supplying a module ID. You can see this in the `cp5-composition3` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the module being composed. If the module returns an object,
    it is composed directly; if the module returns a function, it is treated as a
    constructor to create the object. Of course, because it''s a string, this could
    be used in the binding directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While supported, I personally feel like this violates the separation of concerns.
    It ties the HTML view directly to a viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: Viewpath strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second way to use strings in the compose binding is with a viewpath. If
    the string contains an extension that the `viewEngine` module recognizes, it will
    be used to load that view and bind it to the current binding context. The common
    use case here is partial views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again, the string could be in the HTML or come from the viewmodel. In this case,
    as a view is referring to another view, I think the string belongs to the HTML.
    Otherwise, the reverse violation of the separation of concerns occurs, where a
    viewmodel has a direct reference to a view.
  prefs: []
  type: TYPE_NORMAL
- en: This sample can be seen in `cp5-composition4`.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit models and views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compose binding can also take a settings object that specifies a model,
    a view, or both. There isn''t much to say about these examples, so this section
    is taken directly from the Durandal documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data-bind="compose: { model: model }"`: This uses the value of `model` with
    `viewLocator` to obtain a view. They are then bound and the view is injected into
    the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-bind="compose: { view: view }"`: This evaluates the value of `view`.
    If it is a string, then `viewLocator` is used to locate the view; otherwise, it
    is assumed to be a view. The resultant view is injected into the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-bind="compose: { model: model, view: view }"`: This resolves the value
    of `model`. The value of `view` is resolved and a view is constructed as indicated
    in the previous point. Both `model` and `view` are then bound and injected into
    the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-bind="compose: { model: model, view:''myView.html'' }"`: The value of
    `model` is resolved. The `viewLocator` module is then used to obtain the view
    indicated by the `view` property. They are then bound, and the view is injected
    into the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-bind="compose: { model:''shell'', view: view }"`: RequireJS is used to
    resolve the `shell` module. The value of `view` is resolved and a view is returned,
    as described in the previous point. The view is then bound to the resolved module
    and injected into the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-bind="compose: { model:''shell'', view:''myView.html'' }"`: RequireJS
    is used to resolve the `shell` module. The `viewLocator` module is then used to
    obtain the view indicated by `view`. The view is then bound to the resolved module
    and injected into the DOM node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerless composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the preceding examples work with Knockout''s containerless comment syntax
    as well, so the following is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The composition system has more features than there are in the scope of this
    chapter, including view caching, transitions, template mode, and custom view location
    strategies. They will be discussed in the next chapter, which covers more advanced
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: View locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the default behavior of the `viewLocator` module used
    by composition is to look for a view with the same path as the module, but with
    the `.html` extension. This results in modules grouped by folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![View locations](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, the `shell` directory contains the view and the viewmodel
    for the shell, and the `contacts` directory contains a base model for a contact,
    as well as a view and viewmodel for both `list` and `edit`. I think this organization
    is very easy to understand, and it scales well with large applications, as each
    feature or group of features is kept together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Durandal offers another strategy though, which it calls the conventional strategy.
    You can activate it by modifying your `main.js` file to call `useConvention` on
    the `viewlocator` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This causes Durandal to look for a module with the `viewmodels/contactList`
    ID at `views/contactList.html`. While you can enter any strings for the viewmodels
    and views, paths, this is actually the default. Calling `viewLocator.useConvention()`
    (with no parameters) will produce the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: I don't think this method scales as well, and I personally find it harder to
    work with. I prefer to have the viewmodel and view in the same location in the
    filesystem, so that I don't have to hunt for it. It's all up to you (or your team's)
    preference though.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code samples shown here will use the default behavior, not the conventional
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While technically an optional plugin, I don't imagine any real-world SPAs will
    do without the use of the router. While SammyJS ties a URL fragment to a function,
    Durandal's router ties the URL directly to a module ID. The module can return
    either a singleton or a constructor, and will be used to bind the view using the
    standard composition system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start configuring the router:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Route configuration is pretty straightforward. Here is the `shell` module with
    router configuration for the `Contact` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The router plugin is required in the `shell` module and is set up during its
    `activate` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `map` method takes an array of routes and `buildNavigationModel` sets up
    those routes. The `mapUnknownRoutes` function takes a module ID and a route to
    use as a catch-all for attempts to navigate to routes that have not been registered.
    Without this, navigation will be canceled instead, with no error displayed to
    the user!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will cover `activate` and the other life cycle hooks in detail in a bit.
    For now, just know that `activate` is called during composition. If the return
    value from `activate` is a `promise`, then composition will wait until the promise
    resolves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `router.activate`, which also returns a `promise`, is returned to the
    shell's `activate` method, which chains the wait from composition until the router
    has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The route''s configuration objects that are passed to the `map` function take
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`route`: This is the URL to map to. It can be a string or an array of strings.
    Each string can take one of the following forms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default route: This is `route: ''''`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static route: This is `route: ''contacts''`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameterized route: This is `route: ''contacts/:id''`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional parameter route: This is `route: ''contacts(/:id)''`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Splat route: This is `route: ''contacts*details''`. It is a *wild card*, and
    will match any URL starting with `contacts`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moduleId`: This is the module to bind the route to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash`: This is used primarily for data binding `<a>` tags. In most cases,
    the router will generate this automatically, but it can be overridden. It is necessary
    to override this property on routes with optional parameters or splats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The `document.title` property is set to this value. If present, then
    the route is active; if absent, the `document.title` is not changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav`: If `true`, the route will be included in the router''s `navigationModel`,
    an observable array of routes created when `buildNavigationModel` is called, which
    can be used to easily generate navigation bars. The default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a module with an `activate` or `canActivate` function is activated by the
    router, the route's parameters are passed as arguments to it. Again, activation
    and other life cycle hooks will be covered in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Query strings are also passed in as the last parameters to `activate`/`canActivate`
    as objects with a key/value pair query string key.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The router introduces a special binding, also called **router**, which wraps
    the compose binding with special handling logic. It shares the same properties
    as the compose binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `activeItem` object on the router holds the currently active routes'' module.
    If the `model` property on the router binding is omitted, the binding will look
    for a router property on the current binding context and take its `activeItem`
    object. The preceding example is equivalent to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The router also has a `navigationModel` observable array, which is very useful
    in generating navigation bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each route has an `isActive` property, which indicates when the route is active,
    and a `hash` property, which can be used for a tag's `href` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading or navigating, are also exposed as observables on the router. This
    makes it easy to bind loading indicators on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Okay, time to look at a live example. Open the `cp5-router` branch. Try moving
    around the application by editing contacts or using the navigation bar links.
    Notice that the URL's hash is updated to match the current route. You can even
    use the browsers back and forward buttons to control navigation, as the router
    is hooked into the `window.location` object. Like all true SPAs, the navigation
    occurs inside the app, not by performing browser navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Activating routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a route is activated, the associated viewmodel module is loaded with RequireJS
    and composed into the DOM. The module loaded by RequireJS must either be an object,
    which will be treated as a singleton and bound to the view, or a function, which
    will be treated as a constructor and used to `new` up an object to bind to the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation – hash change versus push state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just saw how the router handled navigation by changing the URL's hash. This
    is the default behavior, but the router also supports push state navigation. Push
    state navigation is the use of the HTML5 history API to modify the current URL
    and the history stack, without causing browser navigation. This results in prettier
    and normal looking URLs during router navigation. We see `http://localhost:3000/contacts/new`
    instead of `http://localhost:3000/#contacts/new`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mode of navigation can be activated by passing the `router.activate({
    pushState: true })` calling. Though older browsers don''t support push state,
    Durandal will gracefully degrade to hash change navigation when push state is
    not supported.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason this isn't the default behavior is because it requires support from
    the server to work properly. Currently, our server is only serving our application
    when we navigate to the root URL. If we try to navigate to `/contacts/new`, the
    server will display a `404` error. As Durandal is supposed to be in control of
    routes and navigation, adding this support route-by-route to the server would
    be a lot of duplication. The recommended way to support push state on the server
    is to use a wild card route to send all page requests to the index page. Once
    Durandal loads, it will detect the URL and activate the proper route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of wild card routes will depend entirely on your server
    backend. Our examples are using a Node.js server, which makes it pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That will take care of the page routing, but there is a much bigger supportability
    issue with push state routing; relative paths in HTML and the RequireJS config.
    Right now, all the links to CSS or the scripts in our code look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a problem if the page tries to load `/contacts/new`, because `content/css`
    is a relative path; it will be treated by the browser as `/contacts/content/css`.
    Obviously this will fail; either the server will display a `404` error, or worse,
    the wild card route will cause the index page to be returned!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, all the paths need to be absolute paths; they have to start with
    a forward slash (`/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This one can be nasty as is it requires manually updating any code with links
    in it, including the RequireJS config. As long as you are aware of the road you
    want to take when you start a project, this isn't much of a headache. If you can,
    I recommend going to the push state route. Having those nice looking URLs makes
    a big difference. It also frees the hash up to do its normal job of indicating
    a location or state on the page.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of the push state scenario in `cp5-pushstate`. Note that
    as a special treat, this branch supports IE 8 so that you can see the graceful
    degradation to hash change navigation. The rest of the examples in this chapter
    will use push state navigation, but will return only to supporting ES5-compatible
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the navigation from JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigation can easily be done with the router''s `navigate` function, which
    takes a URL string. The router is a singleton, and can be required into any module,
    using `plugins/router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Modal dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the overuse of modal dialogs in Windows, and alert boxes in early browser
    applications, modal dialogs have left a bad taste with some developers. However,
    when used appropriately, they are simple and powerful tools. Durandal's modal
    dialog implementation makes collecting user input from modals very easy, by making
    dialogs return promises that resolve when they close. Modal dialogs in Durandal
    come in two types, namely, message boxes and custom dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Message boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For simple cases such as displaying a notification or collecting a single piece
    of user input, Durandal provides a modal dialog on `app.showMessage`, which takes
    the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message (string)`: This contains the main contents of the message box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title (string, optional)`: This contains the title of the message box; the
    default title is `app.title`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Buttons (array, optional)`: This is an array of buttons to show; the default
    is `[''Ok'']`. The first button in the array will be the default action of the
    dialog. If the array is an array of strings, then the text will be both the button
    text and the return value of clicking that button. To specify the value of a button,
    use an array of objects, that is, `[{ text: "One", value: 1 }, { text: "Two",
    value: 2 }]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Autoclose (boolean, optional)`: If `true`, the dialog will be closed if the
    user clicks outside of the dialog window; the default is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Settings (object, optional)`: See the upcoming *Message box settings* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While a simple call to `app.showMessage(''This is a message!'')` is a good
    way to put something right in front of the user, I think the best use case for
    message boxes is the *Are you sure?* confirmation dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message boxes](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here we are showing a message box when someone tries to delete a contact. The
    message includes the contact's name (to provide context) and a title. The order
    of the two buttons, **No** then **Yes**, ensures that if the user hits enter immediately,
    **No** will be selected. I think it's good to default to the safer case. Whatever
    the user selects will be given to the promise returned from `showMessage`, which
    we can access in the `then` handler.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how you count those lines, we just double-checked a user action
    with a modal dialog in 2-3 lines of very-readable code. You can see an example
    of this in the `cp5-message` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Message box settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last parameter to `showMessage` is an object that controls display options.
    It takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buttonClass`: This specifies a class for all buttons. The default is `btn`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`primaryButtonClass`: This specifies an additional class for the first button.
    The default is `btn-primary`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secondaryButtonClass`: It specifies an additional class for buttons other
    than the first. The default is no class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`: This specifies the class of the outermost `div` element of the message
    box. The default is `"messageBox"`. Note that you must specify this property with
    quotes or it will crash in IE8; for example, `"class"` and `"myClass"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: This specifies additional styles for the outermost `div` element of
    the message box. The default is nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also control the default settings by passing the same settings object
    to `dialog.MessageBox.setDefaults`. This function will merge the settings passed
    to it with the defaults; if you leave settings out, they will be left alone, not
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: Custom dialogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message boxes are great for single input such as `yes`, `no`, or choosing an
    option from a list. However, when things need to get more complex than a single
    answer, Durandal allows us to create custom dialogs. To show a custom dialog,
    you can require the dialog object with `plugins/dialog` and call `dialog.show`,
    or use the alias `app.showDialog`. Dialogs use composition, so any viewmodel passed
    to `show` will look up and bind against its view using the standard methods.
  prefs: []
  type: TYPE_NORMAL
- en: To close itself and pass a result back to the caller, the dialog-hosted viewmodel
    will need to require `plugins/dialog` and call `dialog.close(self, result)`.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, open the `cp5-dialog` branch. The **Add Contact** button
    on the main list page will open the edit viewmodel in a dialog, which will either
    close with `null` for a canceled entry or a new contact for the saved entry. Just
    to show how flexible it is, the `Add Contact` link in the nav bar will still navigate
    to a new page to create a new contact. Both, the dialog and the page are run by
    the same viewmodel!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, almost nothing has changed. Instead of always using the router
    to navigate home when finished, the new close method checks `dialog.getDialog(self))`
    to see whether it is a dialog, and closes itself with the result (null or the
    newly created contact). The `dialog.getDialog(self))` method returns the dialog
    context, or is undefined if none is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list viewmodel has to only make the following change to open the dialog
    and keep the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `ContactVM` object is the edit viewmodel, which is being required in with
    `contact/edit`. A new one is constructed and passed to `app.showDialog`. Composition
    renders the viewmodel and returns the promise for the dialog's result. This promise
    will be completed by the `dialog.close` call in the edit viewmodel. The `then`
    handler just checks to make sure it exists and adds it to its list of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some HTML/CSS considerations with custom dialogs. Unlike message
    boxes, which are styled with Bootstrap''s modal classes by Durandal, custom dialogs
    are rendered into an empty `div` element that is centered with absolute positioning
    and a transparent background. Without some styling, the output looks pretty terrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom dialogs](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thankfully, it doesn''t take much to clean this up. This is the CSS I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding CSS produces this much nicer looking result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom dialogs](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While the need for this might be surprising, I think it's better than the alternative
    where Durandal does apply some default styling to all modals, which has to forcefully
    be overridden when it doesn't match what you want. In the next chapter, we will
    cover adding custom dialog hosts, which provides a much nicer way to control default
    modal appearance for both message boxes and custom dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To keep the calling viewmodel a little cleaner and less aware of how the dialog
    viewmodel works, I prefer to encapsulate the actual dialog code. This is easy
    to do by adding a `show` method to the edit viewmodel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And calling it instead of `app.showDialog`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This hides the specific method from the caller, allowing the edit viewmodel
    to control how it shows itself. The `show` method could even take the parameters
    that allowed configuration before showing the dialog. This is especially useful
    when multiple dialog hosts are available, which we will cover in the next chapter.
    You can see this example in the `cp5-dailog2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The application's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Durandal's composition and activator services allow optional callbacks to control
    or hook into their life cycles. They can be useful when performing setup and teardown,
    or implementing logic to block or redirect page changes.
  prefs: []
  type: TYPE_NORMAL
- en: The activation life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An activator is a special computed observable, whose `write` function enforces
    the activation life cycle. Unless you are managing composition or routing yourself,
    the only activators you will work with are the ones used by the router and the
    dialog system. Though, if you are interested, you can create your own activator
    by requiring in the `durandal/activator` module and using the `create` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following optional properties are called by the activator when the active
    value tries to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canActivate`: This is called on the new value; it should return either a Boolean
    or a promise that resolves to a Boolean. If the result is `false`, activation
    is cancelled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activate`: This is called on the new value after `canActivate`; it is used
    to perform any desired setup logic. If activate returns a promise, the new value
    will not become the active value until the promise resolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canDeactivate`: This is called on the old value; just like activate, it should
    return either a Boolean or a promise that resolves to a Boolean. If the result
    is false, activation is cancelled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deactivate`: This is called on the old value after activation succeeds, but
    before the switch is made. It is used to perform any teardown logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing viewmodels with activate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have already seen the use of `activate` in the list and edit viewmodels,
    where it is used to load data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What probably hasn't been obvious, because the mock data service is using local
    storage, is that if this service call actually took time, the page would render
    before the data got back. This could result in a jarring change when all of the
    contacts suddenly load. The `activate` call isn't waiting for this callback to
    finish, so Durandal is activating the viewmodel before it's really ready.
  prefs: []
  type: TYPE_NORMAL
- en: To see what this looks like, open the `cp5-timeout` branch. All the mock service
    calls have had a 1 second timeout added before their callbacks are used, which
    will result in a more real-world response time scenario. Loading the home page,
    you can see the list load after the rest of the page. This is especially problematic
    when trying to edit a contact, as the form will show the default values until
    the contact is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the page loading until the list is retrieved, we can return a promise
    from activate. The `durandal/system` module provides a way to create promises
    if you aren''t using your own library (such as Q) to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are returning a promise that will be resolved by the callback to our
    mock data service. The `system.defer` function takes a handler that performs asynchronous
    working, calling it with a deferred object. The deferred object has the resolve
    and reject functions, which can take values for success or failure. You can see
    this in the `cp5-activate` branch, where the same change was made for the edit
    page. As activate is waiting on this promise, activation will not continue until
    it resolves. These pages will not activate until their data is loaded, so the
    user never sees the page before it is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this method works, there is a cleaner way to do it. Instead of using
    callbacks in our data service and promises in our viewmodels, which really mixes
    strategies, we can use promises in our data service. If our data service returns
    a promise, the activate method looks much nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What an improvement! In fact, we can take it even further. As `self.contacts`
    is an observable array, which is just a function, we can cut out the anonymous
    function in the `then` handler with this shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This works because `self.contacts` becomes the `then` handler, so when the service
    returns the list of contacts, the promise resolves directly into it. This doesn't
    appeal to everyone, and it might even look confusing. However, if it doesn't impair
    readability for you, the shorter code might be nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method can be seen in the `cp5-activate2` branch, which fully converts
    all the data access code into promises, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because Durandal has this understanding of promises integrated into its life
    cycle hooks, it makes using promises for all asynchronous code that much more
    appealing. If you aren't doing this already, I strongly encourage you to consider
    it. All code samples from here on will be using promises.
  prefs: []
  type: TYPE_NORMAL
- en: This asynchronous activation is another advantage of the composition of components.
    Components can only construct and bind synchronously, which can make some components
    very tricky to initialize. Composition allows asynchronous work to be done, making
    it that much more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: A note on the router's isNavigating property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, *Binding the router*, we looked at the `isNavigating`
    property of the router, which is `true` during navigation. The activation life
    cycle is part of navigation, so `isNavigating` will be `true` during any asynchronous
    activity in the activation life cycle. This allows you to bind visual indicators
    on the page while your pages are loading, making your application feel more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Checking navigation with canDeactivate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `canActivate` and `canDeactivat`e methods also support promises. Going off
    to the server with an Ajax request to see whether a view can be deactivated might
    seem weird, but Ajax isn't the only source of promises. Perhaps the best possible
    use case for `canDeactivate` is with the promise from a simple message box—**You
    have unsaved changes, are you sure you want to leave?**
  prefs: []
  type: TYPE_NORMAL
- en: Open the `cp5-deactivate` branch and open up a contact to edit. If you hit **Cancel**,
    you will still be taken back to the list, but if you make changes and hit **Cancel**,
    you will be prompted. If you hit **No**, navigation will be cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that this is being done from the **Cancel** button, but it
    will also happen if the user clicks on the browser''s back button or the navigation
    link (basically, anything but a hard browser navigation). This is because `canDeactivate`
    is run no matter what source the attempted deactivation comes from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dirty flag in this sample is taken from Ryan Niemeyer's blog *Knock Me Out*
    at [http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html](http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html).
    It can be seen in the `common/extensions.js` file in the branch source code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are just showing a standard message box and transforming the result
    into a Boolean for `canDeactivate`. The promise for this result is returned, and
    `canDeactivate` will wait until it resolves, to determine whether or not activation
    can continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually shorten this, because the activator module will interpret the
    strings'' responses by checking them against a list of affirmations and responses
    that it considers to be true. This is the code Durandal uses to check activation
    results, taken from the activator module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This array of `truthy` strings can be changed by accessing `activator.defaults.affirmations`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, we can just return the promise from the message box directly.
    The activator module will consider `Yes` to be a truthy result, and any other
    string to be `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Doesn't that look nice? You can see this in the `cp5-deactivate2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: While these examples are short, hopefully, they give you an idea of what the
    activation life cycle is capable of, especially when combined with promises. Because
    promises can be chained, you could block deactivation when you go to the server
    to get some information, then display it to the user in a message box, and pass
    the result to the activator module.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The composition life cycle has another set of events that can be hooked into,
    which allow you to control how the DOM is rendered, or respond to various stages
    of composition. Again, all of these are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getView()`: This is a function that can return a view ID (path to a view file),
    or a DOM element. This overrides any other view location done by composition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewUrl`: This is a string property of a view ID, to override view location.
    It will only be used if `getView` is not present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activate()`: Just like activation''s `activate` method, this function will
    be called when composition begins. If the compose binding has an `activationData`
    method specified, it will be given to activate as a parameter. If a promise is
    returned, the composition will not continue until it resolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binding(view)`: This is called before binding occurs. The view is passed to
    this function as a parameter. If binding returns `false` or `{ applyBindings:false
    }`, binding will not be done on the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindingComplete(view)`: This is called when binding finishes. The view is
    passed as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attached(view, parent)`: This is called with the view and its parent DOM element
    after it is added to the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compositionComplete(view, parent)`: This is called with the view and its parent
    DOM element after all composition, including the composition of child elements,
    has been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detached(view, parent)`: This is called after the view has been removed from
    the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of the combined activation and composition life cycles, such as
    the router's navigation, the activation module's `activate` method is the only
    one called.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of binding, which can stop binding from occurring, the composition
    life cycle hooks do not offer the opportunity to control or cancel the process
    like the activation hooks do. Though it is generally discouraged in MVVM for the
    viewmodel to interact directly with the view, the composition life cycle is designed
    to make it easy to do so. Patterns should only be followed as long as they are
    helpful or possible, and if binding just can't get your work done, you may need
    to work with the DOM in your viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widgets in Durandal are similar to Knockout components, in that they are viewmodel/view
    pairs that are instantiated from the DOM. Components use a custom element while
    widgets use a custom binding. There is definitely some overlap between them, but
    Durandal's widget system came before Knockout's component system. Widgets also
    have a killer feature over components; their views can have replaceable sections
    that can be overridden. This feature is commonly known as **transclusion**—the
    inclusion of one document inside another.
  prefs: []
  type: TYPE_NORMAL
- en: It's difficult to talk about the widget API without using an example. When we
    looked at components, we made a contact list component; so let's see what it would
    look like doing the same thing with a widget. It may not be very reusable, making
    it an odd choice for a widget; but it will cover the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Durandal expects widgets to be located in a directory named `widgets`, at the
    root of your app, which, in our case, would be under `client/app/widgets`. Each
    widget will store its code in a folder, which will be used as the name of the
    widget. The code for a widget must be a JavaScript file named `viewmodel.js` and
    an HTML file named `view.html`. So to make our contacts list item widget, we will
    use the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new widget](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the view, we are just going to pull the whole list section out of the `list.html`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are going to be binding against a new viewmodel, I''ve changed the `foreach`
    binding from `displayContacts` to `contacts`. Our viewmodel is going to look very
    similar to our normal page viewmodels. Like pages instantiated by the router,
    our widget''s viewmodel won''t be able to receive construction parameters; data
    passed to the widget through the binding will be given to the `activate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We are passing in the data the view needs here, that is, the `contacts` array,
    and a callback for `edit` and `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Durandal provides several ways to use the widget. First, we have to activate
    the widget plugin in our `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the widget binding to create the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I don''t really like this though; it''s a little verbose. There are two ways
    to register the widget, which allow it to be used as if it was a binding itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I think this looks much nicer. To register a widget, you can either call `widget.registerKind(''contactList'')`,
    or modify the plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I personally prefer this last method; though if you have a lot of widgets, you
    might prefer one of the other methods. You can see this widget being used in the
    `cp5-widget` branch. The result looks identical to the previous version, but the
    list is now in a separate view.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying widgets with data-part attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, there isn't much to our widget. It doesn't add anything that a Knockout
    component couldn't have given us, and the components have the nicer looking custom
    element syntax going for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an element in your widget''s view with a `data-part` attribute,
    then that element can be overridden by the caller. Let''s say, for example, that
    we wanted to be able to change the way the phone number was displayed. The first
    step is to add a `data-part` attribute to the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to use the same `data-part` attribute in the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The result is the new `span` element that replaces the original small element
    inside the widget. You can see this in the `cp5-datapart` branch.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to notice here is that the new `span` element has a data
    binding that refers to a contact's `phoneNumber` property. The `data-part` attribute
    is overriding an element whose binding context is in the scope of the `foreach`
    loop of the widget, and this scope is maintained by the new element. The binding
    context of a `data-part` attribute, declared inside of a widget-bound element,
    is the binding context of the element it replaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The special `$root` property of a widget''s binding context is set to the declaring
    scope, which is especially handy for overriding `data-part` attributes. If we
    want to refer to properties on the list viewmodel, we can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that the matching button in the widget view has the `data-part="edit-btn"`
    attribute added to it. This button now directly references the `editContact` function
    on the list viewmodel, instead of the one on the widget. You can see this in action
    in the `cp5-datapart2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: A widget can have any number of `data-part` attributes, and each `data-part`
    attribute can contain other `data-part` attributes. This allows maximum flexibility
    in controlling the appearance and functionality of templated widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are just the basics of using Durandal, but hopefully you can already appreciate
    the power and simplicity the framework provides. It frequently happens online
    that Knockout is compared to more complete frameworks such as Angular, and where
    it lacks components, such as a router, they are taken as points against it. Durandal
    stacks up much more evenly with these frameworks while it still takes advantage
    of all of the things that make Knockout great.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you should have learned the composition system, as well as
    how the router brings organization and modularity to your application. We saw
    how promises combine with modal dialogs and the application life cycle to allow
    us to respond to asynchronous events easily and naturally. Finally, we saw how
    widgets can take the concepts behind Knockout components (reusable behavior-driven
    controls that are instantiated from the view markup) and add templated `data-part`
    attributes to achieve transclusion.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will continue to explore how the Durandal framework simplifies
    Knockout application development.
  prefs: []
  type: TYPE_NORMAL
