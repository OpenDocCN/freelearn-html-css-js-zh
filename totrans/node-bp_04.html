<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Developing a Chat with Socket.IO"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Developing a Chat with Socket.IO</h1></div></div></div><p class="calibre7">As we learned in the previous chapter, Node.js collaborates really well with frontend frameworks such as <a id="id158" class="calibre1"/>AngularJS. It's great that we can transfer data from the browser to Node.js and vice-versa. It's even better if we can do in this real time. Nowadays, real-time communication is heavily integrated in almost every web product. It gives a nice user experience and brings a lot of benefits to the application's owners. Usually, when we talk about real-time web components, we mean <a id="id159" class="calibre1"/>
<span class="strong"><strong class="calibre8">WebSockets</strong></span>. WebSocket is a protocol that allows us to establish a two-way (bidirectional) conversation between the browser and the server. This opens a whole new world and gives us the power to implement fast and robust apps. <span class="strong"><strong class="calibre8">Node.js</strong></span><a id="id160" class="calibre1"/> supports WebSockets, and we will see how to build a real-time chat with WebSockets. The application will use Socket.IO. It is a library that is built on top of WebSockets and provides mechanisms to cover the same functionalities if they are not available. We will have an input field, and every user who opens the page will be able to send messages to every other user who is available.</p><p class="calibre7">In this chapter, we will learn how to set up Socket.IO and how to use it in a browser and start a Node.js server, making real-time chat possible.</p></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Developing a Chat with Socket.IO">
<div class="book" title="Exploring WebSockets and Socket.IO"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec29" class="calibre1"/>Exploring WebSockets and Socket.IO</h1></div></div></div><p class="calibre7">Let's say that we want to <a id="id161" class="calibre1"/>build a<a id="id162" class="calibre1"/> chat feature. The first thing that we should do is to develop the part that shows the messages on the screen. In a typical scenario, we want these messages to be delivered fast, that is, almost immediately after they were sent. However, if we don't use sockets to receive the data from the server, we need to make an HTTP request. Also, the server should keep the information till we request it to do so. So, imagine what would happen if we had 10 users and each one of them starts sending data. </p><p class="calibre7">We need to maintain a user session in order to identify the user's requests. These problems are easily solved if we use sockets. Once the socket is opened, we have a long live channel, and we can send messages back and forth. This means that you can start receiving information without requesting it. The architecture is analogous to a big net of bridges. The bridge is always open, and if we need to go somewhere, we are free to do so. At the center of the net, we have a hub that connects every side with each other. In the context of the web, the hub is our server. Every time we need to reach some of the users attached to the net, we just need to send a message via the socket. The server receives it and bypasses it to the right person. This is one of the most effective ways to implement real-time communication. It saves time and resources.</p><p class="calibre7">As it happens with most of the cool technologies, we don't need to start from scratch and write low-level stuff, such as handshake requests for example. There are two types of developers: those who work really hard and abstract the complex things into simpler APIs and tools, and those who know how to use them. Developers in the second group can make use of libraries such as Socket.IO. This chapter deals extensively with the Socket.IO module. It acts as an abstraction over WebSockets and simplifies the process to a great extent.</p><p class="calibre7">Before we continue, <span class="strong"><strong class="calibre8">Socket.IO</strong></span><a id="id163" class="calibre1"/> is actually more than a layer over <a id="id164" class="calibre1"/>
<span class="strong"><strong class="calibre8">WebSockets</strong></span>. In practice, it does a lot more, as mentioned on the website <a id="id165" class="calibre1"/>at <a class="calibre1" href="http://socket.io/">http://socket.io/</a>:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre13"><span class="strong"><em class="calibre9">"Socket.IO aims to make realtime apps possible in every browser and mobile device, blurring the differences between the different transport mechanisms. It's care-free realtime 100% in JavaScript."</em></span></p></blockquote></div><p class="calibre7">There are some common situations that we usually encounter with the protocol, for example, heartbeats, timeouts, and disconnection support. All these events are not natively supported by the WebSocket API. Thankfully, Socket.IO is here to solve these issues. The library also eliminates some cross-browser problems and makes sure that your app works everywhere.</p></div></div>
<div class="book" title="Understanding the basic application structure"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Understanding the basic application structure</h1></div></div></div><p class="calibre7">In the previous chapter, we <a id="id166" class="calibre1"/>used Express and Jade to write the delivery of the assets (HTML, CSS, and JavaScript) of the application. Here, we will stick to pure JavaScript code and will avoid the usage of additional dependencies. The only thing that we need to add to our <code class="email">package.json</code> file is Socket.IO:</p><div class="informalexample"><pre class="programlisting">{
  "name": "projectname",
  "description": "description",
  "version": "0.0.1",
  "dependencies": {
    "socket.io": "latest"
  }
}</pre></div><p class="calibre7">After we call <code class="email">npm install</code> in<a id="id167" class="calibre1"/> our project's folder, Socket.IO is placed in a newly created <code class="email">node_modules</code> directory. Let's create two new directories. The following screenshot shows what the application file structure should look like:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Understanding the basic application structure" class="calibre10"/><div class="caption"><p class="calibre14">The file structure</p></div></div><p class="calibre11"> </p><p class="calibre7">The application will read the <code class="email">styles.css</code> file and deliver its content to the browser. The same thing will happen with <code class="email">/html/page.html</code>, which is the file that contains the HTML markup of the project. The Node.js code goes to <code class="email">/index.js</code>.</p></div>
<div class="book" title="Running the server"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Running the server</h1></div></div></div><p class="calibre7">Before we start using Socket.IO, let's first write a simple Node.js<a id="id168" class="calibre1"/> server code, which responds with the chat's page. We can see the server code as follows:</p><div class="informalexample"><pre class="programlisting">var http = require('http'),
  fs = require('fs'),
  port = 3000,
  html = fs.readFileSync(__dirname + '/html/page.html', {encoding: 'utf8'}),
  css = fs.readFileSync(__dirname + '/css/styles.css', {encoding: 'utf8'});

var app = http.createServer(function (req, res) {
  if(req.url === '/styles.css') {
    res.writeHead(200, {'Content-Type': 'text/css'});
    res.end(css);
  } else {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.end(html);
  }
}).listen(port, '127.0.0.1');</pre></div><p class="calibre7">The preceding <a id="id169" class="calibre1"/>code should be placed in <code class="email">/index.js</code>. The script starts with the definition of several global variables. The <code class="email">http</code> module is used to create the server, and the <code class="email">fs</code> module is used to read the CSS and HTML files from the disk. The <code class="email">html</code> and <code class="email">css</code> variables contain the actual code that will be sent to the browser. In our case, this data is static. That's why we are reading the files only once, that is, when the script is run. We are also doing this synchronously by using <code class="email">fs.readFileSync</code> and not <code class="email">fs.readFile</code>. Just after this, our server is initialized and run. The <code class="email">req.url</code> variable contains the currently requested file. According to its value, we respond to it with proper content. Once the server is run, the HTML and CSS code stays the same. If we change something, we need to stop and start the script again. That's because we are reading the file's content before we start the server. This could be considered as a good practice if there are no changes in <code class="email">/css/styles.css</code> or <code class="email">/html/page.html</code>. Inserting the <code class="email">fs.readFileSync</code> operations in the server's handler will make our chat a bit slow because we will read from the disk during every request.</p></div>
<div class="book" title="Adding Socket.IO"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Adding Socket.IO</h1></div></div></div><p class="calibre7">The implementation of the <a id="id170" class="calibre1"/>chat requires the code to be written in both places: at the server side and the client side. We will continue with the Node.js part by extending the previous code, as follows:</p><div class="informalexample"><pre class="programlisting">var io = require('socket.io').listen(app);
io.sockets.on('connection', function (socket) {
  socket.emit('welcome', { message: 'Welcome!' });
  socket.on('send', function (data) {
      io.sockets.emit('receive', data);
  });
});</pre></div><p class="calibre7">The <code class="email">http.createServer</code> method returns a new web server object. We have to pass this object to Socket.IO. Once everything is done, we have access to the wonderful and simple API. We may listen for incoming events and send messages to the users who are attached to the server. The <code class="email">io.sockets</code> property refers to all the sockets created in the system, while the <code class="email">socket</code> object, passed as an argument to the <code class="email">connection</code> handler, represents only one individual user.</p><p class="calibre7">For example, in the preceding code, we are listening for the <code class="email">connection</code> event, that is, for a new user to connect to the server. When this happens, the server sends a personal message to that user that reads <code class="email">Welcome!</code>
</p><p class="calibre7">The next thing that<a id="id171" class="calibre1"/> may happen is we receive a new type of message from the user, our script should distribute this information to all the available sockets. That's what <code class="email">io.sockets.emit</code> does. Keep in mind that the <code class="email">emit</code> method may receive our own custom event names and data. It is not necessary to strictly follow the format used here.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing the client side of the chat"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Writing the client side of the chat</h1></div></div></div><p class="calibre7">Having completed<a id="id172" class="calibre1"/> writing the code for the server side, we can now continue writing for the frontend, that is, write the necessary HTML and JavaScript that will communicate with the chat server.</p></div>

<div class="book" title="Writing the client side of the chat">
<div class="book" title="Preparing the HTML markup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec21" class="calibre1"/>Preparing the HTML markup</h2></div></div></div><p class="calibre7">With the development done so far, <a id="id173" class="calibre1"/>our chat feature would look like the following screenshot:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Preparing the HTML markup" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We have a container<a id="id174" class="calibre1"/> that acts as a holder for the incoming messages. There are two input boxes. The first one is for the name of the user and the second one accepts the message that we have to send. Every user has a random color applied to his/her texts. There is no button to send the data to the server; we can do this by pressing the <span class="strong"><em class="calibre9">Enter</em></span> key. Let's continue to read the HTML markup saved in <code class="email">/html/page.html</code> shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;section&gt;
          &lt;div id="chat"&gt;&lt;/div&gt;
          &lt;input type="text" id="name" placeholder="your name" /&gt;
          &lt;input type="text" id="input" disabled="disabled" /&gt;
        &lt;/section&gt;
        &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      window.onload = function() {
        var Chat = (function() {
          // ...
        })();
      }
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The CSS<a id="id175" class="calibre1"/> styles are added at the top of the page and to the scripts at the bottom. There are just three elements that represent the controls mentioned in the previous code. The bootstrap of the logic is placed in a <code class="email">window.onload</code> handler. We are doing this just to be sure that all the assets are fully loaded. Note that the input field, which will accept the message, is disabled by default. Once the socket connection is established, we will enable it. There is one last thing that we should clarify—the location/source where the <code class="email">/socket.io/socket.io.js</code> file is coming from. It is not downloaded and saved in the project directories from an external source; it is delivered at that location by Socket.IO. That's one of the reasons behind passing the <code class="email">web server</code> object to Socket.IO at the backend.</p></div></div>

<div class="book" title="Writing the client side of the chat">
<div class="book" title="Writing the chat logic"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec22" class="calibre1"/>Writing the chat logic</h2></div></div></div><p class="calibre7">The HTML <a id="id176" class="calibre1"/>markup<a id="id177" class="calibre1"/> itself is useless. The next step in our development process will be writing the JavaScript code that will communicate with the backend. We will need to catch the user's input and send it to the server. The messages displayed on the screen will be painted in different colors. We will start by defining two helper methods as follows:</p><div class="informalexample"><pre class="programlisting">var addEventListener = function(obj, evt, fnc) {
    if (obj.addEventListener) { // W3C model
        obj.addEventListener(evt, fnc, false);
        return true;
    } else if (obj.attachEvent) { // Microsoft model
        return obj.attachEvent('on' + evt, fnc);
    }
}
var getRandomColor = function() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '#';
    for (var i = 0; i &lt; 6; i++ ) {
        color += letters[Math.round(Math.random() * 15)];
    }
    return color;
}</pre></div><p class="calibre7">The first one, <code class="email">addEventListener</code> function, will add an event listener to a <code class="email">DOM </code>element. To make our chat work in Internet Explorer, we need to use <code class="email">attachEvent</code> instead of <code class="email">addEventListener</code>. The second, <code class="email">getRandomColor</code> function, delivers a different color every time. We will use this to distinguish messages from the different users.</p><p class="calibre7">Our client-side logic starts with the defining of a few variables:</p><div class="informalexample"><pre class="programlisting">var socket = io.connect('http://localhost:3000'),
  chat = document.querySelector("#chat"),
  input = document.querySelector("#input"),
  name = document.querySelector("#name"),
  color = getRandomColor();</pre></div><p class="calibre7">We will use the <code class="email">socket</code> variable to communicate with the server. The next three variables are shortcuts to the previously used <code class="email">DOM</code> elements. It is recommended to create such shortcuts because referencing elements all the time with <code class="email">document.getElementById</code> or <code class="email">document.querySelector</code> may cause of performance issues.</p><p class="calibre7">The chat does two things: it sends messages to the Node.js part and receives messages from there. Let's wrap everything into two simple functions, as follows:</p><div class="informalexample"><pre class="programlisting">var send = function(message) {
  var username = name.value === '' ? '' : '&lt;strong&gt;' + name.value + ': &lt;/strong&gt;';
  socket.emit('send', { 
    message: '&lt;span style="color:' + color + '"&gt;' + 
                   username + message + '&lt;/span&gt;'
  });
}

var display = function(message) {
  chat.innerHTML = chat.innerHTML + message + '&lt;br /&gt;';
  chat.scrollTop = chat.scrollHeight;
}</pre></div><p class="calibre7">Here, we are sending<a id="id178" class="calibre1"/> the <a id="id179" class="calibre1"/>message via the <code class="email">socket.emit</code> method and wrapping the text in a colored <code class="email">span</code> element. Of course, if the user types in something in the <code class="email">name</code> input field, we use the value and send it along with the rest of the data. The <code class="email">display</code> function is pretty simple. It just changes the <code class="email">innerHTML</code> property of the <code class="email">chat</code> element. What is interesting is the second line. If we use the chat feature a bit, we will notice that <code class="email">div</code> will be filled out very soon, and what we actually see are only the first messages. By setting the <code class="email">scrollTop</code> property to <code class="email">scrollHeight</code>, we make sure that the holder will be always scrolled downwards.</p><p class="calibre7">The next step in our small application is handling the user's input. This can be done using the following code:</p><div class="informalexample"><pre class="programlisting">addEventListener(input, "keydown", function(e) {
  if(e.keyCode === 13) {
    send(input.value);
    input.value = "";
  }
});</pre></div><p class="calibre7">The only one key that is interesting for us at the moment is the <span class="strong"><em class="calibre9">Enter</em></span> key. Its key code is 13. If the key is pressed, the value of the field is emitted to the server. We are flushing the input field to allow the user to type in a new message.</p><p class="calibre7">The last thing that we should do is write the code to receive the messages:</p><div class="informalexample"><pre class="programlisting">socket.on('welcome', function (data) {
  display(data.message);
  input.removeAttribute("disabled");
  input.focus();
}).on('receive', function(data) {
  display(data.message);
});</pre></div><p class="calibre7">There are two types of events that we are listening to. They are <code class="email">welcome</code> and <code class="email">receive</code>. The <code class="email">welcome</code> event is sent when the connection is established. The <code class="email">receive</code> event is an incoming event, when some of the users send a message (including ourselves). We may ask why we need to send our own message to the server and receive it after that. Isn't it easier to place the text directly onto the holder? The answer to this is that we need consistency of the data, that is, we should provide the same message in absolutely the same order to all the users. This can be guaranteed by only one piece of the app and that's the server.</p><p class="calibre7">With this<a id="id180" class="calibre1"/> last code <a id="id181" class="calibre1"/>snippet, we have finished building our chat feature. In the last part of this chapter, we will improve user-to-user communication.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementing user-to-user communication"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Implementing user-to-user communication</h1></div></div></div><p class="calibre7">Our chat is now <a id="id182" class="calibre1"/>functioning, but it would be nice if we could send a message to one specific user. Such a feature requires changes in both places: at the frontend and backend. Let's first change the Node.js script.</p></div>

<div class="book" title="Implementing user-to-user communication">
<div class="book" title="Changing the server-side code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec23" class="calibre1"/>Changing the server-side code</h2></div></div></div><p class="calibre7">So far, the users were<a id="id183" class="calibre1"/> anonymous in our system. We just passed the received message to all the sockets available. However, to implement a user-to-user conversation, we need to set unique ID for every user. Along with that, we have to keep references to all the created sockets so that we can emit messages to them. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">var crypto = require('crypto');
var users = [];</pre></div><p class="calibre7">We can make use of the <code class="email">crypto</code> module, which is available by default in Node.js to generate the random unique IDs, as follows:</p><div class="informalexample"><pre class="programlisting">var id = crypto.randomBytes(20).toString('hex');</pre></div><p class="calibre7">We should also notify the people in the chat about the available users. Otherwise, they will not be able to pick an appropriate user to chat with. The notification is done as follows:</p><div class="informalexample"><pre class="programlisting">var sendUsers = function() {
  io.sockets.emit('users', users.map(function(user) {
    return { id: user.id, name: user.username };
  }));
}</pre></div><p class="calibre7">The user's name was actually passed along with the message. It was a part of the message, and the backend doesn't use it at all. However, in the new scenario, we need it with the ID. The previous code sends the <code class="email">users</code> array to the browser, but before that, it filters it and passes only the ID and the name. As we will see in the following code, we also have a <code class="email">socket</code> property for every element. The following is the updated <code class="email">connection</code> handler:</p><div class="informalexample"><pre class="programlisting">io.sockets.on('connection', function (socket) {
  var id = crypto.randomBytes(20).toString('hex');
  users.push({ socket: socket, id: id, name: null });
  socket.emit('welcome', { message: 'Welcome!', id: id });
  sendUsers();
  socket.on('send', function (data) {
      if(data.username !== '') {
        setUsername(id, data.username);
      }
      if(data.toUser !== '') {
        users.forEach(function(user) {
      if(user.id === data.toUser || user.id === data.fromUser) {
        user.socket.emit('receive', data);
      }
    })
      } else {
        io.sockets.emit('receive', data);
      }
  });
});</pre></div><p class="calibre7">So, a new user connection is received at the server. We generate a new ID and create a new element inside the <code class="email">users</code> array. We keep the socket, the ID, and the name of the user. After that, we emit the good old <code class="email">welcome</code> message, but this time we send the ID as well. Now, the frontend can identify itself into the system, and because the <code class="email">users</code> variable is updated, we should notify the rest of the world about this via the <code class="email">sendUsers</code> function. We start listening for the <code class="email">send</code> message, and once it comes, we update the user's name in the array with the <code class="email">setUsername</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">var setUsername = function(id, name) {
  users.forEach(function(user) {
    if(user.id === id) {
      user.username = name;
      sendUsers();
    }
  });
}</pre></div><p class="calibre7">The subsequent<a id="id184" class="calibre1"/> lines check whether there is a <code class="email">toUser</code> property. If there is one, we know that it contains IDs of some of the other users. So, we simply find the user ID and pass the message to the exact socket. If there is no <code class="email">toUser</code> property, then the data is again sent to everyone using <code class="email">io.sockets.emit('receive', data)</code>. Together with <code class="email">toUser</code>, the frontend should also send <code class="email">fromUser</code>. That's because normally the guy who sends the text doesn't see its message on the screen until the server sends it back. We will use <code class="email">fromUser</code> to achieve this.</p></div></div>

<div class="book" title="Implementing user-to-user communication">
<div class="book" title="Making changes to the frontend of the chat"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec24" class="calibre1"/>Making changes to the frontend of the chat</h2></div></div></div><p class="calibre7">The first thing we have to <a id="id185" class="calibre1"/>do is to show the available users on the screen so that we can choose one of them to chat with. Just below the input fields, we will add a drop-down menu, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;select id="users"&gt;
    &lt;option value=""&gt;all&lt;/option&gt;
&lt;/select&gt;</pre></div><p class="calibre7">We will need a few new variables defined. A new shortcut to the <code class="email">select</code> element, the currently selected user from the list, and a variable that will hold the current user's ID. This is done as follows:</p><div class="informalexample"><pre class="programlisting">var users = document.querySelector("#users"),
  selectedUser = null,
  id = null;</pre></div><p class="calibre7">The <code class="email">send</code> method has changed a bit. We can see it as follows:</p><div class="informalexample"><pre class="programlisting">var send = function(message) {
  var username = name.value == '' ? '' : '&lt;strong&gt;' + name.value + ': &lt;/strong&gt;';
  socket.emit('send', { 
    message: '&lt;span style="color:' + color + '"&gt;' + username + message + '&lt;/span&gt;',
    username: name.value,
    toUser: users.value,
    fromUser: id
    });
}</pre></div><p class="calibre7">The difference is that we are sending the user's name in a separate property, that is, the ID of the user and the ID of the user we want to chat with. If there is no such user, then the value is just an empty string. The <code class="email">display</code> method can stay the same. We need one more event listener for the drop-down menu changes. We will add it as follows:</p><div class="informalexample"><pre class="programlisting">addEventListener(users, "change", function(e) {
  selectedUser = users.value;
});</pre></div><p class="calibre7">Most of the work is done in the listeners of the socket object:</p><div class="informalexample"><pre class="programlisting">socket.on('welcome', function (data) {
  id = data.id;
  display(data.message);
  input.removeAttribute("disabled");
  input.focus();
}).on('receive', function(data) {
  display(data.message);
}).on('users', function(data) {
  var html = '&lt;option value=""&gt;all&lt;/option&gt;';
  for(var i=0; i&lt;data.length; i++) {
    var user = data[i];
    if(id != user.id) {
      var username = user.name ? user.name : 'user' + (i+1);
      var selected = user.id === selectedUser ? ' selected="selected"': '';
      html += '&lt;option value="' + user.id + '"' + selected + '&gt;' + username + '&lt;/option&gt;';
    }
  }
  users.innerHTML = html;
});</pre></div><p class="calibre7">First, the <code class="email">welcome </code>message is received. It comes with the ID, so we will store it in our local variable. We show the welcome message, enable the input, and bring the focus there. No changes here. What is new is the last message listener. That's the place where we populate the drop-down menu with data. We compose an HTML string and set it as a value of the <code class="email">innerHTML</code> property at the end. There are two checks. The first one prevents the current user from showing in the <code class="email">select</code> element. The second condition automatically selects a user from the list. This is actually quite important because the user's message can be <a id="id186" class="calibre1"/>sent many times and the menu should maintain its selection.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we've learned how to create a real-time chat by using Socket.IO. It's a great Node.js module that simplifies work with WebSockets. It is a technology that is widely used today and is part of the future's applications.</p><p class="calibre7">In the next chapter, we will learn how to use BackboneJS to create a simple to-do application. Again, we will manage the data with the help of Node.js.</p></div></body></html>