- en: Using the Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a serverless project, you can group multiple features into a
    single big Lambda function or break each feature into its own small function.
    If you follow the second option, you will end up managing the deployment of dozens
    of different functions, each one of them with its own configuration and dependencies.
    Automating this process could be a real challenge, but it becomes an easy task
    when you use the Serverless Framework in your workflow. Besides handling the release
    process, the framework helps you architect the solution and manage different environments,
    and it provides a clean and succinct syntax for versioning the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to configure and use the Serverless Framework.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up and start using the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a hello-world application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating endpoints and enabling CORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring events to trigger functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing other AWS resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have learned the basics of how to build the backend
    of a serverless project.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools that have been developed to help manage serverless projects.
    The Serverless Framework is currently the most popular and will be used extensively
    in this book. This section will help you configure, use, and understand how it
    will fit in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Serverless Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Serverless Framework is a powerful Node.js *command-line tool*, not a cloud
    service. Its objective is to help developers be more productive by simplifying
    how they can use and manage cloud resources. It provides a set of commands that
    will help you quickly start a new project, add functions, endpoints, triggers,
    configure permissions, and more. In summary, the framework will manage your project,
    automate the deployment of your code, and integrate with many different services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdb2603f-bd1f-4950-a72d-a516fb6670ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have the following as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration**: Describes what and how different cloud services will trigger
    our Lambda functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: Sets permissions for Lambda functions, and defines the limits
    (timeout and RAM memory) under which they will run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugins**: Extends the framework functionalities with custom code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the framework provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture**: Helps to define an architecture that will keep our project
    consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy**: Automates code deployment. You can deploy anytime with a single
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Helps versioning the code configuration, which means versioning
    the infrastructure. Duplicating the same infrastructure into another region or
    environment is a trivial task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Currently, it supports the following cloud providers: AWS, Microsoft Azure,
    Google Cloud Platform, and IBM OpenWhisk. Migrating from one cloud to another
    is possible, but it is not simple. The framework uses the same commands for management
    tasks and tries to use similar settings, but each one of them requires different
    configurations and setups.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important characteristic is that the Serverless Framework is open source
    and MIT licensed, so it can be used for free, even in commercial products.
  prefs: []
  type: TYPE_NORMAL
- en: Other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless is a concept that promotes the development of applications without
    worrying about the servers that will operate them. It's a concept and doesn't
    specify the tools that will be used, nor the cloud vendors that host the applications.
    However, taking advantage of the word's hype, the creators of **JAWS** renamed
    their project to **Serverless Framework** at the end of 2015 and bought the [serverless.com](https://serverless.com)
    domain. To further improve their open source project, they started a venture-backed
    company named *Serverless, Inc*.
  prefs: []
  type: TYPE_NORMAL
- en: The Serverless Framework is currently the best tool to build a general-purpose
    serverless project, but **do not** confuse a product with the concept. The framework
    promotes serverless applications, but offers **only a subset** of what you can
    do with serverless. There are many other services and frameworks out there with
    different features and objectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Apex is another framework to manage AWS Lambda functions with
    an interesting feature that provides support for Go, Rust, and Clojure, even without
    native support by Lambda. There are also dozens of other tools. For more options,
    you can take a look at this curated list: [https://github.com/anaibol/awesome-serverless](https://github.com/anaibol/awesome-serverless).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the Serverless Framework uses Node.js, you can use npm to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@1.x` suffix asks npm to download a package compatible with the 1.x version.
    This restriction is suggested because this book was written following the 1.18
    specification of the framework and the examples may not be compatible with a future
    2.x version.
  prefs: []
  type: TYPE_NORMAL
- en: The Serverless Framework requires Node.js v6.5 or higher. Make sure that you
    have an updated version. You can check this by running `node --version`. If you
    need to update your Node version, consider using v6.10 because this is the latest
    version that AWS uses to run Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the framework was installed successfully, you can check its
    version by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `serverless` command, you can use the abbreviation `sls`
    for all commands. For example, `sls --version`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for each option that starts with two dashes, such as in `--version`, there
    will always exist a shorter alternative using just one letter, such as `-v` in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Serverless Framework uses the AWS SDK to manage your account resources,
    so the configuration that is needed is to set your credentials where the SDK can
    access them. As described in [Chapter 2](246b3080-28af-4aa3-805f-5fbf9908caae.xhtml),
    *Getting Started with AWS*, we have already created a user and set its **Access
    key** and **Secret access key** into environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: What is missing here is properly restricting this user access. For learning
    purposes, it's perfectly fine to use an administrator account with full access.
    However, if you are building a real product, follow the principle of least privilege
    and set access only for what is expected to be used by the framework. In the previous
    chapter, you learned how to configure it using the IAM console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
  prefs: []
  type: TYPE_NORMAL
- en: The minimum access requirements are **Lambda**, **CloudFormation**, **IAM**,
    and **CloudWatch**. While setting permissions, you can anticipate and give access
    that will be needed later in our sample project. The framework will also need
    access to **API Gateway**, **IoT**, **SimpleDB**, and **DynamoDB**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing permissions in a team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working in a team, it's mandatory that everyone must have their own user
    for a fine-grained set of permissions. Also, it allows audit and traceability
    which are very important. Audit discourages wrongdoings by team members and traceability
    is useful for unfortunate cases, for example, if your site is compromised, you
    can discover the source of the invasion. If you want those features, you must
    configure **AWS CloudTrail** to store into S3 the log files of the AWS API usage.
  prefs: []
  type: TYPE_NORMAL
- en: If each team member has a unique account, you can restrict access to the production
    environment for a reduced group of people. Access to production is a great responsibility
    that should only be entrusted to experienced people to avoid failures due to distraction
    or lack of knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder to store our project data. Name it `hello-serverless`
    and set the command prompt directory to this folder. Now, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdc49010-631f-4d66-9a14-c7e9256fcb4c.png)'
  prefs: []
  type: TYPE_IMG
- en: This command creates one *service* that is used to group related functions.
    You can compare a service as a bounded context as defined in **Domain-Driven Design**
    (**DDD**). For example, in this book, the sample application is an online store.
    We can say that features that will be implemented to exhibit products and handle
    sales are part of one context. The features that handle user accounts and profile
    data are part of another context. We will discuss serverless architectures in
    [Chapter 6](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml), *Developing the Backend*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the command, the following two files are created:'
  prefs: []
  type: TYPE_NORMAL
- en: The `handler.js` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `serverless.yml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the context of each one and understand their role.
  prefs: []
  type: TYPE_NORMAL
- en: The handler.js file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file contains the main function that will be executed by AWS Lambda. For
    a simple example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our `response` object has the properties `statusCode` and `body`. This schema
    is mandatory when you want to trigger Lambda functions using the API Gateway and
    when the Lambda is configured as a proxy, which is the default option selected
    in the Serverless Framework. Instead of configuring headers, status codes, and
    other parameters in the API Gateway, the Lambda proxy setting allows this configuration
    to be part of the code. This is the recommended practice for most use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function named `hello` will be configured as our main entry. It receives
    three arguments such as `event`, `context`, and `callback`. The `event` variable
    is our input data, and `callback` is the function that must be executed after
    the Lambda execution finishes and it receives an error object as the first parameter
    and a `response` object as the second one, and the `context` is an object that
    provides data related to our function execution. An example of the `context` content
    is displayed in the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we return `status code 200 (OK)`, and the response `body` will
    return a message that uses the event as an input variable.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless.yml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a configuration file that uses the YAML standard, which has the aim
    of being more readable by humans. The name YAML is a recursive acronym meaning
    *YAML Ain't Markup Language*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created the service, we used the argument `aws-nodejs`. It creates
    a file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following settings depicted in the preceding code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service`: This is just the service name that we have specified while creating
    the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provider`: This sets the cloud provider and the runtime. We have selected
    AWS and the latest Node.js version available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functions`: This is where we define the Lambda functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more options available, but we will cover them as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Lambda limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While setting the `serverless.yml` file, you can configure your function limits.
    The RAM memory size has the default value of 1,024 MB. The possible values range
    from 128 MB to 1,536 MB in chunks of 64 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible setting is the `timeout` property. If your function exceeds
    the expected time, it will be aborted. The default value is 6 seconds and the
    possible values range from 1 second to 300 seconds (5 minutes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In YAML syntax, a comment begins with the hash sign (`**#**`) and continues
    until the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change the default values by modifying the provider settings.
    These values will be used when your function doesn''t specify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Deploying a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying a service is a simple task. We just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a7da9ea-99c4-4739-980b-a0b4911b30af.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, it will deploy your functions in a `stage` named `dev` and in the
    `region` named `us-east-1`. The `stage` is used to simulate different environments.
    For example, you can create one for development and another for `production`,
    or you can use one for `v1` and another for `v2` if you want to create versioned
    APIs. Regarding the region, it's used to identify which AWS `region` will be used
    to host your Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two options to change the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is to modify the `serverless.yml` file, as shown in the following
    code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is to use the arguments of the deploy command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Under `provider`, you can set the configuration file to the `dev` stage, only
    when you want to deploy to `production`, you can do so using the stage argument
    with the command line. Using two different approaches for two different environments
    is a good way to avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `deploy` command, it can take a couple of minutes to execute,
    even for small projects. The performance issue is related with CloudFormation,
    which needs to update the stack across AWS machines. After deploying the function
    for the first time, we can use the `deploy function` command for code updates
    because this command will simply swap the ZIP package of the function. As it doesn''t
    need to execute any CloudFormation code, this is a much faster way of deploying
    changes. The following example shows how to use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Always remember to update the function's code using the `deploy function` command
    for fast deployment. If you need to update any kind of configuration, such as
    permissions or Lambda limits, you need to run the `deploy` command (without the
    `function` part).
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just created and deployed a Lambda function. Now, let''s see how this function
    can be invoked by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your project folder, create an `event.json` file with the following
    content. This file will serve as our input data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to invoke the function and confirm that it is working as expected.
    You can do so by executing the `invoke` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Passing the `event.json` file as input is not mandatory. We are using it because
    our example uses the input data to create the `response` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the invoke result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e2f4786-a807-477f-ac07-dc70db4bfc36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have functions deployed to multiple stages/regions, you can invoke them
    by specifying the stage/region explicitly. For example, take a look at the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last observation is that you can invoke functions locally. This invoke
    will execute the function using your machine instead of running the function hosted
    on AWS. For this, just use the `invoke local` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will see later that we can give or restrict permissions to Lambda functions.
    However, if you execute the code locally, it won't use the configured roles. The
    Lambda will execute under your local SDK credentials, so testing Lambda locally
    can be useful, but you need to know that you won't be testing it with the same
    permissions that will be used when the function is hosted on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a Lambda function fails due to an unhandled exception, the result will
    be a generic message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To troubleshoot errors, we need to retrieve the execution logs. You can do
    so by appending the `--log` option to the `invoke` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It will result in an error message similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides using the `--log` command when invoking a function, you can retrieve
    logs from the Lambda functions that are deployed without invoking new executions.
    The command for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot with an example of log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3592b2-dc26-4588-9874-1fafe517c916.png)'
  prefs: []
  type: TYPE_IMG
- en: One problem with this feature is that you *must* specify the function name.
    You can't have a generic view of how all functions are executing, which would
    be desirable in a project with dozens of functions.
  prefs: []
  type: TYPE_NORMAL
- en: When running in production, using the command line to watch for logs can be
    troublesome. You can reduce the amount of results using the `--filter string`
    command to show only messages that contain a specific string. This is useful in
    finding error messages, for example, using `--filter Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--filter string` option is case sensitive. If you want to find error messages,
    use `--filter Error` because most exception messages will start the error word
    with an uppercase letter, for example: `ReferenceError`'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to filter by time. You can use `--startTime time` to filter
    only the recent messages. For example, you could replace "time" with `30m` to
    see only messages that happened 30 minutes ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Also, you can add a listener that will output all new log messages received.
    In this case, you need to add the `--tail` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Adding endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Endpoints are the addresses that are exposed to the Internet through the API
    Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to create an endpoint for our Lambda example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoints are added by setting HTTP events in the `serverless.yml` file. In
    the following example, we specify that a `GET` HTTP verb used in the `my-service/resource`
    path will trigger this Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After editing the configuration file, deploy the service again using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41dae216-c0fe-4cc0-b6c6-521e60754489.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, in addition to the Lambda function update, the `deploy` command will
    create an API Gateway resource configured with the preceding path and method.
    In the previous chapter, we deployed an API Gateway resource that triggered a
    Lambda function, and it required a lot of steps. Do you see now how powerful the
    Serverless Framework is? If you have dozens of functions and endpoints, a single
    command is enough to deploy all of them. This automation and ease of use is what
    makes the framework so interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that the framework lists the endpoint
    address that was created. It uses the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use your browser to open this URL, you will see a `response` object
    containing our hello-world message. When using the API Gateway, the `event` variable
    will include much more data, adding information about headers and the request
    context. Most of this is not useful for us, but we need to use the `event` object
    to find the input data. As this is a `GET` request, we can add a query string
    to the end of the URL to pass variables values and retrieve them, looking for
    the `queryStringParameters` property inside the `event` object. Look at the following
    URL example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `?name=Serverless&foo=bar` file is the query string that will be mapped
    to a JSON object inside the `queryStringParameters` property of our `event` variable,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are now using the API Gateway instead of invoking the Lambda function
    directly, the `event` object received will be set with different properties. In
    this case, we need to adapt our Lambda function to handle it properly. The following
    example uses `event.queryStringParameters.name` instead of `event.name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To test, deploy the function again, and browse the endpoint address with the
    query string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will cover other HTTP verbs in [Chapter 6](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml),
    *Developing the Backend*.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try to call this API address inside a website through an Ajax call, it
    will throw an exception. This is because **Cross-Origin Resource Sharing** (**CORS**)
    is not enabled by default in API Gateway. CORS is a mechanism that allows a resource
    to be requested from a web page hosted in another domain. By default, it is disabled
    to force administrators to give permissions for cross-domain requests only when
    it makes sense and for specific domains.
  prefs: []
  type: TYPE_NORMAL
- en: We are building a website that will be hosted inside AWS, but the web page will
    be accessed through our own domain, such as [www.example.com](http://www.example.com),
    and not from [www.amazonaws.com](http://www.amazonaws.com). As a result, we need
    to enable CORS to allow our frontend code to consume our services. If you have
    a Lambda function that should be accessed only by another Lambda or internal AWS
    service, CORS is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable CORS, we need to modify our `handler.js` function to include the
    `"Access-Control-Allow-Origin"` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add only *one* origin per function. This is a problem when we need
    to support multiple origins, and this requirement is very common. For example,
    the following addresses are considered different origins because they have different
    protocols (HTTP versus HTTPS) or different subdomains (none versus www):'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://www.example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.example.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To support multiple origins, you need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Another solution, which is very common in traditional web servers, is to dynamically
    write the *response* headers based on the *request* headers that you can find
    inside the `event` object. If its origin is contained in a predefined whitelist,
    you can build the `response` object using the corresponding origin.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After finishing this example, we can delete our test function and API. The
    `remove` command will delete all AWS resources that were created, but it will
    leave the project files intact. The syntax is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have deployed services to stages or regions that are not configured
    in the current version of your `serverless.yml` file, you can use the `--stage`
    and `--region` options to selectively remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When you make a new deployment to the API Gateway, you receive an API key that
    is used to compose your API address, for example, `https://[key].execute-api.[region].amazonaws.com`.
    This key is important and will be saved into our frontend code. If you remove
    your services and recreate them again, a new key will be generated and the frontend
    key will need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore what more we can do using the Serverless Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using npm packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the Serverless Framework to deploy your Lambda function, it creates
    a ZIP file with everything that is inside your project folder. If you need to
    use a module that is not a Node.js core module or the AWS SDK, you just need to
    use Node's default workflow to add dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `package.json` file to store your project dependencies and use `npm
    install <your-module> --save` to download your required module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `node_modules` folder inside your project directory, the ZIP file will
    be deployed to AWS with the necessary dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, the Lambda function of the file `handle.js` uses
    an npm module called `cat-names`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The framework will zip everything that it finds inside the project folder,
    except what you configure in the `serverless.yml` file to be ignored. The following
    example uses the `package` configuration to remove some files that are commonly
    present in a project folder, but that should never be included in the ZIP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Hidden files and folders are not included in the ZIP package by default, for
    example, the `.gitignore` file and the `.serverless` folder, which are part of
    serverless projects, don't need to be explicitly excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test, just deploy and invoke the `catNames` function by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Accessing other AWS resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Lambda functions execute without any permissions. If you want to
    access S3 buckets, DynamoDB tables, or any kind of Amazon resource, your user
    must have access to them and you must give explicit permissions to your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is done in the `serverless.yml` file under the `provider`
    tag. The following example shows you how to give permissions to an S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this statement, we can modify our `handle.js` file to write and read
    files using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are writing a file that contains the `Test` string to a
    bucket and, after finishing the writing, we read the same file and return its
    contents in our response.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Serverless Framework currently supports the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon API Gateway**: This creates RESTful interfaces by triggering Lambda
    functions through HTTP messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon S3**: This triggers functions for post-processing when a new file
    is added or to take an action when a file is removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon SNS**: This handles SNS notifications with Lambda functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedule**: This triggers functions based on scheduled tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon DynamoDB**: This triggers a function when a new entry is added to
    a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Kinesis**: This uses Lambda functions to process Kinesis streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Alexa**: This triggers functions with Alexa Skills'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS IoT**: This handles messages sent to IoT topics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon CloudWatch**: This handles CloudWatch events and log messages using
    Lambda functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this list, there are only two services that we haven't seen yet. The first
    one is Amazon Kinesis, which is a service created to process and analyze streaming
    data generated by different sources, and the other one is Amazon Alexa, which
    is Amazon's intelligent personal assistant. Both of them are beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not cover all event types because the list is extensive, and each one
    of them requires different configurations. You can see how to use them in the
    official documentation at [https://serverless.com/framework/docs/providers/aws/events](https://serverless.com/framework/docs/providers/aws/events).
    In this chapter, we have already exemplified the API Gateway by creating an endpoint
    for our Lambda function. Now, we will take a look at two more examples: one for
    Amazon S3, to see how easy it is to create S3 events in comparison to the example
    from the previous chapter, and the other example is to **Schedule** triggers,
    which are very useful in running scheduled tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The S3 event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we configured S3 to trigger a Lambda function when
    a new file is added to a bucket and its name matches certain rules. The same configuration
    can be applied here using the following configuration in our `serverless.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The bucket name needs to be a new one. Due to limitations, you can't add events
    to an existing bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Schedule events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scheduling Lambda executions is a very important feature for many use cases.
    This setup is easily done by the framework by modifying the `serverless.yml` file
    using the `schedule` event. In the next example, the `processTask` function will
    be executed every 15 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This setting accepts either the `rate` or `cron` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cron` syntax is compounded by six required fields in the following order:
    `Minutes | Hours | Day-of-month | Month | Day-of-week | Year`. In the next example,
    the `cron` expression is used to schedule a function to run from Monday to Friday
    at 9:00 am (UTC):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following link for more details about this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html](http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTML pages with Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common misunderstanding is that Lambda was designed to serve only JSON
    data. That''s not true. As we have control over the response result, we can properly
    set the headers to serve HTML content. This is exemplified in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This approach can be useful for server-side rendering. In [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*, we will discuss Single-Page Applications, which use client-side
    rendering, and traditional web applications, which use server-side rendering.
    Serverless supports both models and it is up to the developer to choose the option
    that best suits their use case.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Serverless Framework allows the usage of variables in our `serverless.yml`
    configuration file. This flexibility is useful in centralizing configurations
    that can be referenced at multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many options for using variables. Let''s try them out by editing
    our configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference environment variables**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the environment variable used in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Load variables from CLI options**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the local variable used in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Store variables in another configuration file**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the usage of a variable defined in another file in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting feature offered by the Serverless Framework is that it is extendable
    through plugins. You can use plugins for new CLI commands or functionalities that
    will be executed by hooking into existing commands.
  prefs: []
  type: TYPE_NORMAL
- en: To show how useful they can be, we will test a serverless plugin that supports
    Lambda development with TypeScript. When we execute the `deploy` command, the
    plugin will compile the code and create a JavaScript version that will be zipped
    and used by Lambda with the Node.js runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this plugin to our project, we need to proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the plugin using npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the plugin reference to the end of our `serverless.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a TypeScript file and save it with the name `handler.ts`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy and test using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Showing deployment information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to know what functions were deployed and their related endpoints,
    you can use the `info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows this command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efb9f3c1-1ad9-4c71-9884-0c2c28ead25e.png)'
  prefs: []
  type: TYPE_IMG
- en: Scaffolding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaffolding is a technique that helps developers by providing a sample solution
    for a common problem. With a *boilerplate*, you can build a new project, taking
    advantage of the fact that some features are already configured, developed, and
    well tested. You start modifying the solution to meet your own requirements following
    the practices recommended by someone who has more experience than you with this
    technology and using a code that was used, tested, and improved by a lot of different
    people. This is the benefit of using open source projects. Also, it's a useful
    way to learn a new technology through *imitation*. You learn by seeing how someone
    else has solved the problem that you want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to scaffold a project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To scaffold a project, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can run the following command to scaffold a serverless service
    to send e-mails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The Serverless Framework team maintains an extensive list of useful examples.
    Check it out by visiting [https://github.com/serverless/examples](https://github.com/serverless/examples).
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective of this book is to build a sample serverless store. You can find
    all code that was developed with this objective on GitHub at [https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store).
    This project can also be scaffolded using the same command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `\` (backslash) character in this command was added because the command
    doesn't fit in one line. It is optional and works for Linux and macOS. On Windows,
    the `^` (caret) is the corresponding symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what the Serverless Framework is and how it will
    help us to build serverless applications. After configuring the framework, you
    have created a hello-world service, added endpoints, enabled CORS, and deployed
    it to be accessed through a public URL. You also learned how to add npm packages
    and access AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will host the frontend following the serverless concept.
    This will be done using Amazon S3, and we will configure a CloudFront distribution
    to add a free TLS certificate to support HTTPS connections.
  prefs: []
  type: TYPE_NORMAL
