- en: Chapter 11. Quick Tricks and Advanced Knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The language properties hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the portal session time and session policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Liferay with the SMTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intranet protection by the antisamy-hook plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating content from one database to another database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Liferay Service Bus for communication between portlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering Liferay Portal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers various topics that are not connected to each other. Recipes
    cover some standard scenarios that a Liferay administrator will face and provide
    solutions. It will help you perform those specific tasks for your intranet sites.
    Almost everyone should know how to configure SMTP in order to send e-mails and
    receive notifications. The next important aspect is security. Administrators and
    developers should know how to install the antisamy-hook plugin or how to set session
    time and session policy. This is extremely important regardless of what type of
    portal Liferay will be used for. Also, this chapter will introduce important knowledge
    about advanced tricks in Liferay. It will describe the Liferay Service Bus and
    show how a user can use it. Furthermore, it will provide a detailed description
    of how clustering works in Liferay and how to migrate content from one database
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: The language properties hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Liferay has a multilanguage architecture and enables users to add content with
    many translations. Moreover, it gives users out-of-the-box functionality to change
    languages. Apart from this, the content portal also contains many labels that
    also have their own translation. It means that the Liferay design has a functionality
    in which it is possible to translate labels or fields. If we look into the sources
    (`portal-impl/src/content`), there are a lot of files with the following names:
    `Language_en.properties`, `Language_de.properties`, `Language_pl.properties`,
    and so on. The ISO 639-1 standard defines a set of possible codes for every language,
    such as **en** for English, **de** for German, and so on. The Liferay Portal supports
    up to 47 languages, which are defined in the `portal-impl/src/portal.properties`
    file called **locales**. Default translations do not always meet our expectations.
    Thus, in this recipe, we will show you how to change the existing labels using
    the hook plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the functionalities of the hook plugin is to override messages in existing
    translations. Our goal is to change the **Sign in** label to **Intranet login**.
    The first step is generating a new hook called `language-hook`. To achieve it,
    use the Liferay Plugins SDK (`${SDK_HOME}/hook/create.sh language "Language hook"`)
    or Maven archetype generator (`mvn archetype:generate -Dfilter=liferay-hook`).
    If you encounter a problem with generating the language hook, go back and study
    the *Creating a custom portlet* recipe from [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Installation and Basic Configuration"), *Installation and Basic Configuration*.
    We assume that the user generates this plugin as a Maven project. Next, import
    the project to your favorite IDE, such as Eclipse, IntelliJ IDEA, or NetBeans,
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `src/main/webapp/WEB-INF/liferay-hook.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a new language property file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `i18n` folder in `src/main/resources` and create the `Language_en.properties`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Language_en.properties`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the plugin and deploy it by invoking the `mvn clean install liferay:deploy`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said at the beginning, Liferay supports many languages and translations.
    Every translation is kept in the `Language.properties` file with a specific suffix,
    such as `_pl`, `_en`, `_de`, and so on. All the available locales are defined
    in the portal properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first property specifies all the available locales in the Liferay Portal.
    The second one lists languages that are in beta. A set of beta properties means
    that the translation is not finished, and Liferay can contain some errors or mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to join the community that works with translations and participate
    with them. All the necessary information is available at [http://translate.liferay.com](http://translate.liferay.com).
  prefs: []
  type: TYPE_NORMAL
- en: The last property lists languages that Liferay supports by default. It is necessary
    to change it if we create a new project and fit it to our requirements. It can
    be changed later. This operation is available in the Control Panel section.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we showed you how to override the existing property. Overriding
    works for every single property defined in `portal-impl/src/content/Language.properties`.
    Additionally, in our `i18n/Language_en.properties`, it is possible to add a new
    property that can be used in our new functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In the Liferay language properties, there is a `portal-impl/src/content/Language.properties`
    file (without a language suffix). This set of properties is used when the system
    cannot find a property for the specific country/language.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from customizing language properties, Liferay lets you choose how your
    internationalization works. To understand this feature, you should know how to
    change the Liferay language first. By default, Liferay provides a unique URL for
    a specific language. The following are some of the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/pl/web/guest/home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/en_US/web/guest/home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This context (`/pl`, `/en_US`) is handled by `I18nServlet`, which is defined
    in the `web.xml` file. This servlet changes the language and renders a page with
    dedicated translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In detail, there is a property called `locale.prepend.friendly.url.style` located
    in `portal-impl/src/portal.properties`. It has four possible values that are defined
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | The locale is not automatically prepended to a URL. This means that
    each URL could potentially point to many different languages. For example, if
    a user sets the German language in their account settings, the Portal displays
    sites in English by default.If this property is set as 0, page `http://localhost:8080/web/guest`
    is displayed in English. However, when users log in, it is automatically translated
    to German. URI has the same value, `/web/guest`, without language context. |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | The locale is automatically prepended to a URL when the requested locale
    is not the default locale. This means that each URL points to just one language.
    Let''s analyze the situation from the first example where a user sets a language
    different from the default one. The first visit to the `http://localhost:8080`
    portal displays content in the default language (English). After the login action,
    the user is redirected to the `http://localhost:8080/de` URL. On every page, there
    is the `/de/web/guest/{PAGE}` URI. After logout, the portal remembers the language
    and displays German translations. |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | The locale is automatically prepended to every URL. This means that
    each URL points to just one language. |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | The locale is automatically prepended to a URL when the requested locale
    is not the default user locale. In the case of guest users, the behavior is the
    same as having a value of 1\. However, in the our case (the user has a different
    locale than the portal), there is the following situation:By default, the portal
    displays content in English, and there is no language context. The URL looks like
    `http://localhost:8080/`.When a user logs in, the language is German, but the
    URL is the same, `http://localhost:8080` (without language context).After the
    logout action, the URL is the same, but the language is still German. To change
    the language, it is necessary to invoke the `http://localhost:8080/en` URL. |'
  prefs: []
  type: TYPE_TB
- en: 'The last thing connected with language settings, is the default language definition.
    It is placed in `portal-impl/src/system.properties` and can be overridden by `system-ext.properties`.
    To set the default language, override the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to learn about creating plugins (especially portlets), refer to the
    *Creating a custom portlet* recipe in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Installation
    and Basic Configuration"), *Installation and Basic Configuration*
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the portal session time and session policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every project, especially the intranet one, the main functionality is authentication
    and authorization in order to provide correct permissions and serve dedicated
    content for an authenticated user. Every logged-in user has their own session;
    the expiry time can be set specifically. You can also set the session using any
    other settings, such as auto-extend session or redirection when a session expires.
    All the settings concerning the session can be found in `portal.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our goal is to configure the following session policy:'
  prefs: []
  type: TYPE_NORMAL
- en: The session expires after 10 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system redirects the user to the default page after session expiration (if
    all pages don't have guest permission to display for unauthenticated users, the
    system should display the login page)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two minutes before session ending, the system should display a warning with
    a counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The session identifier shouldn't be visible in the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said at the beginning, Liferay overrides session-specific properties
    via `portal-ext.properties`. To achieve our goal, open `portal-impl/src/portal-ext.properties`
    and set the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for the `session.timeout` setting, it is required that you set the same
    value in `web.xml`. To complete this task, open the main `web.xml` file, which
    is located in the `{$TOMCAT_HOME}/webapps/ROOT/WEB-INF` folder. Find an XML tag
    called `session-config` and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, save this file and restart your application server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first goal was to change a default session timeout, which was 30 minutes.
    We decreased it to 10 minutes. It is important to know that changing the `session.timeout`
    property is not sufficient because the `web.xml` configuration overrides this
    setting. To finish our configuration, we also had to change this value into the
    `web.xml` descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the assumption was connected with user redirection after timeout. In
    order to achieve our goal, we needed to change two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session.timeout.redirect.on.expire`: This is set to `true` and redirects the
    user to the default page when the session expires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session.timeout.auto.extend`: This is set to `false` to deny the autoextend
    session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `session.timeout.warning` property specifies the number of minutes before
    a warning, informing the user of the session expiration. We set this value to
    2 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The last assumption was connected with security requirements. Of course, it
    is disabled by default, but we decided to show how it can be configured. Thus,
    the last property called `session.enable.url.with.session.id` was set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Liferay with the SMTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Liferay sends e-mails in many cases, such as when adding calendar events and
    posts on the message board or when a user creates an account. In order to enable
    this function, it is required that you correctly configure the SMTP server and
    set the appropriate properties. In this recipe, we will explain how to configure
    the SMTP server in the easiest way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three ways to configure the SMTP server correctly. The easiest way
    is to use Liferay's Control Panel and configure the SMTP settings using the GUI
    interface. To achieve it, go to **Admin** | **Control Panel** | **Server Administration**
    and choose the **Mail** tab. After that, enter your settings for your mail session
    under the **Outgoing SMTP Server** section and click on the **Save** button. This
    type of setting is a great choice when there is only one instance of the SMTP
    server or the SMTP is a third-party external server. In many cases this setting
    is insufficient. The best example is an application running in a clustered environment
    where each node (Liferay instance) has its own SMTP local server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, for instance, in the clustered environment, it is a very common
    practice to install the SMTP server on the same node where the Liferay instance
    is. In this case, it is not possible to configure the SMTP server using the GUI
    interface, but this setting can be done in `portal-ext.properties`. In this file,
    we can put our settings that display the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last possibility is to use the application server''s mail session via **Java
    Naming and Directory Interface** (**JNDI**), which looks up the Java mail session.
    In order to enable the JNDI name, put the following configuration in the `portal-ext.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that, in your `{$TOMCAT_HOME}/conf/Catalina/localhost/ROOT.xml` file,
    there is defined a resource similar to the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Liferay Portal recommends SMTP configuration over the GUI or by setting
    the properties as a unified configuration of Java mail, which doesn't depend on
    the application server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Liferay has its own message bus implementation. It is a service-level API used
    to exchange messages within Liferay. In this specific case, an e-mail sending
    mechanism uses *Liferay Message Bus*. As in every message bus implementation,
    there is a sender, that sends messages to the destination. This functionality
    is implemented in the `com.liferay.mail.service.impl.MailServiceImpl` class in
    the `sendEmail` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we see in the preceding method, the sending action has quite a simple implementation
    that invokes only the `com.liferay.portal.kernel.messaging.MessageBusUtil.sendMessage`
    method, which gives with the type of destination and mail message arguments. `MailMessageListener`
    is responsible for sending e-mails to the specific address correctly.
  prefs: []
  type: TYPE_NORMAL
- en: At the opposite site, there is a listener that can recognize the message and
    consume it. For instance, it sends an e-mail message. This is the `com.liferay.mail.messaging.MailMessageListener`
    class, which receives the event (in this case, the mail event) and invokes an
    appropriate action to send the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Intranet protection by the antisamy-hook plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Liferay 6.x exposes a new functionality called sanitizers. This is an implementation
    that protects content (HTML and JavasScript) against malicious code that users
    may pass to the journal article, wiki, message board, and so on. This can happen
    if a user copies and pastes the content from any Internet resources. In the Liferay
    core implementation, there are no sanitizers. One of the reasons is that Liferay
    allows users to implement their own policy and install it as a hook plugin. Fortunately,
    Liferay has a plugin called `antisamy-hook` in the official GitHub repository
    at [https://github.com/liferay/liferay-plugins/tree/master/hooks/antisamy-hook](https://github.com/liferay/liferay-plugins/tree/master/hooks/antisamy-hook).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to install this plugin and also give you
    an idea about how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The antisamy-hook plugin, like other plugins, is available on the official Liferay
    marketplace. Therefore, the installation process is really simple and unified.
    In order to achieve your goal, log in as an administrator, go to **Admin** | **Control
    Panel** | **Store**, find the **Antisamy CE** plugin, and purchase it by clicking
    on the **Free** button. This plugin is free if you have a valid marketplace account.
    After that, go to the **Purchased** tab and click on the **Install** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the log file, you should find the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `antisamy-hook` plugin adds an *OWASP AntiSamy* implementation, which means
    that the plugin includes the OWASP `antisamy.jar` library, which is located in
    the `org.owasp.validator.html.AntiSamy` package. The OWASP AntiSamy project is
    an API that protects the content against malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details are available on the official OWASP site at [https://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project](https://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project).
  prefs: []
  type: TYPE_NORMAL
- en: 'From a technical point of view, the `antisamy-hook` plugin is a very simple
    but powerful tool. It is simple, because it just overrides the `sanitizer.impl`
    property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is powerful, because it uses an open source OWASP Antisamy project that filters
    our content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main implementation is in the `AntiSamySanitizerImpl` class (actually,
    there is only one class in this plugin) in the sanitize method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This implementation checks whether `contentType` is HTML and the `AntiSamy`
    implementation filters the content and returns the clean results. The OWASP library
    is responsible for correctly filtering content.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating content from one database to another database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The content migration tool is an interesting feature that Liferay provides as
    an out-of the-box core implementation. As you know, Liferay gives administrators
    a choice to select one of the database engines, such as MySQL, PostgreSQL, Oracle,
    and so on. It allows users to change the database engine without losing data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that our Liferay instance uses the PostgreSQL database, and we
    want to change it to MySQL engine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to migrate our content, we need to create a new MySQL database. To
    achieve it log in to your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new database using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This functionality is available out-of-the-box. Moreover, it doesn''t require
    developer support. All migration processes can be done with the help of the GUI.
    To migrate data, follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in as an administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Admin** | **Control Panel** | **Server Administration** and choose the
    **Data Migration** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the form as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **JDBC Driver Class Name**, enter `com.mysql.jdbc.Driver`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In **JDBC URL**, enter `jdbc:mysql://localhost/lportal?useUnicode=true&characterEncoding=UTF-8&useFastDateParsing=false`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In **JDBC User Name**, enter the database's user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In **JDBC Password**, enter the database user's password
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00376.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the **Execute** button. All information about operation details will
    be available on the logfile. The following message will progressively appear on
    the screen:![How to do it…](img/image00377.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the process is successfully finished. Inside the `catalina.out`
    logfile, you will find the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, shut down your application server, change the database properties to indicate
    a new database, and start an application server with a new configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The database migration process is supported by Liferay in order to retain compatibility
    with databases. This process uses Liferay Message Bus, which exposes listener
    to data migration. In this case, an event prepares and invokes the `com.liferay.portlet.admin.action.EditServerAction`
    class. The following listing shows how it was implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method is responsible for preparing specific data, showing a maintenance
    window, and sending an event to the message bus.
  prefs: []
  type: TYPE_NORMAL
- en: Listener is represented by `com.liferay.portal.convert.ConvertDatabase` with
    the `doConvert()` method. This method is responsible for preparing all database
    data and putting it into the new database. All details in this method are complex,
    but the main idea is to take every table, its data, and indexes and migrate them
    to the new database schema.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to migrate a storage data, refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Integration with the Amazon S3 cloud* recipe from [Chapter 6](part0050.xhtml#aid-1FLS41
    "Chapter 6. Documents and Media in Liferay"), *Documents and Media in Liferay*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Data migration between storage hooks* recipe from [Chapter 6](part0050.xhtml#aid-1FLS41
    "Chapter 6. Documents and Media in Liferay"), *Documents and Media in Liferay*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Liferay Service Bus for communication between portlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message bus is a mechanism for sending messages to different components
    in Liferay. This approach is very common, because it prevents class-loading issues.
    It is very important, because Liferay is a portlet container, and each portlet
    doesn't have information about the others. For that reason, Liferay provides a
    message bus that allows communication between portlets. An application that sends
    an event/message is called a producer, and an application that receives messages
    is called a consumer.
  prefs: []
  type: TYPE_NORMAL
- en: The message bus architecture supports asynchronous and synchronous messaging.
    Synchronous messages wait for a response, and asynchronous messages send a message,
    forget it, or receive a callback. The main difference between synchronous and
    asynchronous messages is the fact that the first one block threads and wait for
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to use a message bus in a real example.
    Let's assume that our goal is to write a search portlet with one input with the
    autocomplete feature. This will be a simple form with only one input that can
    autocomplete our query. After submitting the form, the search criteria should
    be sent to the existing out-of-the-box search portlet. The Liferay message bus
    will be used to communicate with the Lucene indexer.
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to show and explain all the implementations, so we will explain
    a piece of code with the message bus. In the following *How to do it…* section,
    we will show you the steps to compile, deploy, and install our portlet. In the
    *How it works…* section of this recipe, we will explain a message bus implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to correctly compile, deploy, and install the portlet, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download `quicksearch-portlet` from [http://www.liferay-guru.com/code/ch11/quicksearch-portlet.zip](http://www.liferay-guru.com/code/ch11/quicksearch-portlet.zip).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the portlet to the `workspace` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `quicksearch-portlet/pom.xml` and set the appropriate paths in the `<properties>`
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `mvn clean install liferay:deploy` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your Liferay instance and check whether, in the logfile, there is a message
    to successfully deploy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Log in as an administrator, create a page called **Search**, and put the **Search**
    portlet, which is available under the **Tools** category in the left menu called
    **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the second page, for example, `Quick Search`, and add the **QuickSearch**
    portlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a search portlet configuration window and set the layout to the Search
    portlet (in our case, it will be the **Search** page).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button and close the pop-up configuration window via the
    **X** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to write a word (with at least three letters) in the **QuickSearch** portlet
    and enjoy the autocomplete feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this portlet, Liferay Message Bus is used to ask the search engine about
    the autocomplete results. In our case, the producer is a class called `com.liferay.guru.portlet.quicksearch.util.QSMessageBusUtil`.
    Its code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has only one method that returns a JSON array with search results.
    The first three lines are responsible for creating the `Message` object, which
    will be sent to the message bus. The `Message` object is an instance of the `com.liferay.portal.kernel.messaging.Message`
    class with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String _destinationName`: This is the name of our destination. It is the place
    to which we address our message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object _payload`: This field represents an object (payload) that will be sent
    to the consumer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object _response`: This field contains an object that represents the response
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String _responseDestinationName`: The place where the consumer (listener)
    sends back the response. In our example, this is `DestinationNames.MESSAGE_BUS_DEFAULT_RESPONSE`,
    which defines the response back to the destination, the producer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String _responseId`: This value represents the response identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<String, Object> _values`: Additional maps of objects that will be sent
    to the consumer or producer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our implementation, we set the payload as `SearchContext` (our Lucene query)
    and set `responseDestinationName` as a default response.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send our message to the message bus, we invoked the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a question: which class should receive our message? The answer and
    all of the configuration are in the `applicationContext-messaging.xml` file, which
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration specifies the following beans:'
  prefs: []
  type: TYPE_NORMAL
- en: The `listener` bean with the `messageListener.autocomplete.lucene` ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `destination` bean with the `destination.search.autocomplete` ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `configurator` bean that maps listeners to their destinations. In our case,
    it maps our `destination.search.autocomplete` destination to the `messageListener.autocomplete.lucene`
    bean. In other words, it links the destination with the listener.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at our listener implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`AutocompleteListener` extends `BaseMessageListener` and overrides the `doReceive`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: The body of this method is responsible for creating a new response and sending
    it back to our producer. An object that was received and that will be sent is
    put to the payload field. Therefore, our implementation gets an object from payload,
    checks whether it is `SearchContext`, looks for new suggestions, and sets suggestions
    as a new payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarizing this recipe, remember the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Liferay Message Bus implements a communication between producer and consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Message` object is sent between the producer and consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The producer creates a `Message` object with the following attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload`: This field represents the object (payload) that will be sent to
    the consumer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseDestinationName`: This is the name that is provided for listeners
    to use in replying'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, `responseId` (the `setResponseId` method) and other objects that
    should be sent to the consumer as a key/value pair (put method)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To send a synchronous message, you should use the `MessageBusUtil.sendSynchronousMessage`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listener (consumer) must be registered in the XML definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listener has a `doReceive` method that sends back a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consumer extracts values from the message and prepares a response message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageBusUtil.createResponseMessage` should be used to create a response
    message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumers send back a message to the producer via the `MessageBusUtil.sendMessage`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we discussed only synchronous communication that is a basic
    example of using a message bus. As a matter of fact, using synchronous messaging
    is not a good idea in many cases. Why? The answer is simple: this type of communication
    blocks waiting for a response from a recipient. Communication via messages was
    basically designed for asynchronous communication. There are two types of asynchronous
    messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**send and forget**: This means *push an event and forget about it*. This type
    of communication is useful in notification cases, for example, if a producer wants
    to notify listeners about some action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**call-back**: The producer defines a call back destination in `responseDestinationName`
    for the message. The listener can send the message back to the specific `responseDestinationName`.
    The important information is that the producer is free for further processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a technical point of view, an asynchronous implementation is very similar
    to our example. The main difference is that it invokes a different method from
    `MessageBusUtil`. To send an asynchronous message, the following invocation should
    be used, as you can see in the listener code when you send the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The important information is that the `sendMessage` method does not return
    any values, because it is an asynchronous message, and we don''t know whether
    there is call-back information or not. All of the configurations where call back
    should be sent are placed in the `messaging.xml` file. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to learn about creating plugins (especially portlets), refer to the
    *Creating a custom portlet* recipe from [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Installation
    and Basic Configuration"), *Installation and Basic Configuration.*
  prefs: []
  type: TYPE_NORMAL
- en: Clustering Liferay Portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Liferay supports clustering out-of-the-box in the **Community Edition** (**CE**)
    version as well as the **Enterprise Edition** (**EE**) version. It is designed
    to build scalable systems that can be used by large companies with a huge amount
    of data, so it allows us to run several portal instances on parallel servers.
    In order to build Liferay clusters, you need to know which components are sensitive
    to clustering. The clustering process has a huge impact on the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Databases, where Liferay instances keep their data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents and media as a folder on the hard drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lucene search engine files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liferay caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will go through each point and show you how to cluster Liferay correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is not a tutorial on how to correctly run clustered environments,
    such as Apache server, load balancers, and so on. Instead, our goal is to show
    you how to correctly configure Liferay so that it works with a parallel environment.
    Let's assume that you have properly configured all the components. The last step
    is configuring Liferay to work in a cluster properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said at the beginning, there are several points that should be checked
    before running Liferay on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Check database configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing, which is really simple, is checking database configuration.
    There should be one database instance shared between all Liferay nodes. To check
    configuration correctness, open the property file where database access configuration
    is present. Usually, it is `portal-ext.properties`. Make sure that, in every node,
    the configuration is the same. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Documents and media clustering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 6](part0050.xhtml#aid-1FLS41 "Chapter 6. Documents and Media in
    Liferay"), *Documents and Media in Liferay*, we explained how the Documents and
    Media portlet works. It is also important to know that file metadata is stored
    in a database, but binary data (files) are stored on the hard drive. As you can
    guess, it will be a problem when Liferay works as a clustered environment, because
    each node can have its own repository and files are not shared between nodes.
    In order to resolve this problem, there are three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharing the repository between nodes via **Storage Area Network** (**SAN**),
    **Network Attached Storage** (**NAS**), GlusterFS and so on: Ask your system administrator
    which option is available on a specific machine and correctly install the clustered
    filesystem. In many solutions, we have seen a GlusterFS system, which shared a
    data folder between nodes. This solution guarantees that each node has the same
    repository of files. Make sure that the following property indicates a proper
    location for shared disk storage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using database storage: All data, including binary files, is stored in a database
    table. To enable this configuration, set the following property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This setting automatically uses the database instead of filesystem. The database
    should support the BLOB's field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using external storage systems, such as the following ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Cloud**: We showed you how to configure this storage in the *Integration
    with the Amazon S3 cloud* recipe in [Chapter 6](part0050.xhtml#aid-1FLS41 "Chapter 6. Documents
    and Media in Liferay"), *Documents and Media in Liferay*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Management Interoperability Services** (**CMIS**) Store such as Alfresco:
    After successful installation of Alfresco (or other CMIS Store system), set the
    following properties:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**A Java Content Repository** (**JCR**) store such as Jackrabbit: This is an
    Apache project implemented as a JSR-170 specification. Liferay supports it, but
    this configuration is deprecated because of performance issues and concurrency
    conflicts. In this solution, the Jackrabbit repository must be placed on the SAN
    shared storage (mounted on every node).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Search engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already mentioned the search engine topic in [Chapter 8](part0059.xhtml#aid-1O8H61
    "Chapter 8. Search and Content Presentation Tools"), *Search and Content Presentation
    Tools*. We showed two search engines: Apache Lucene and Apache Solr. If you use
    Solr or Solr Cloud as a search engine, everything will work perfectly because
    Solr is an external application with which Liferay establishes a connection. In
    the clustered environment, this is the best option because of performance and
    the quality of the search results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, Lucene keeps its data in a local storage filesystem. It is a problem
    to keep an up-to-date index on every Liferay node in the clustered environment.
    We cannot replicate the index file by GlusterFS, because Lucene sometimes locks
    data when it writes to an index or optimizes it. In order to resolve this conflict,
    Liferay gives a functionality that provides a replication mechanism between all
    Liferay''s nodes. To enable this functionality, set the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These properties need to be set for all of Liferay's nodes. The `cluster.link.enabled`
    property turns on the whole mechanism of cache replication, which we will describe
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Cache replication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Liferay uses EhCache to cache some content, such as the result of SQL queries.
    In a clustered environment, cache distribution is a very important issue. Each
    node should know about the changes on the database and cache invalidations. Phil
    Karlton once quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"There are only two hard things in Computer Science: cache invalidation and
    naming things."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I completely agree with him.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cache distribution between nodes works perfectly with multicasting. Make sure
    that your servers support multicasting. Next, set the following property to enable
    replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This property turns on the clustered mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties define five channels for distributing messages between
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Set a proper IP addresses and port number for the preceding properties (settings).
    In many environments, it works out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Unicast
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some servers, it might not be possible to send messages by multicasting.
    Fortunately, it is possible to force Liferay to use unicast protocols instead
    of multicast. Configuration is not very difficult, but it is hard to discover
    it. To reduce the time spent on Google, follow this part of the recipe and correctly
    set this type of communication.
  prefs: []
  type: TYPE_NORMAL
- en: First, turn on the clustering mode by setting the `cluster.link.enabled` property
    with the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you have to use the `JGroups` library to establish communication via
    TCP. To achieve this, set the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Analyze the highlighted part in the preceding section. All channels have references
    to the `unicast-ehcache.xml` file. Thus, create the `unicast-ehcache.xml` file
    on a classpath (`${TOMCAT_HOME}webapps/ROOT/WEB-INF/classes`). It is also possible
    to create it in the `ext` plugin at `ext-impl/src/main/resources/unicast-ehcache.xml`.
    The content of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to enable communication is to tell `JGroups` about the available
    nodes (Liferay instances). Let''s assume there are two nodes of Liferay with the
    following IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**node1** with 192.168.0.10 address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**node2** with 192.168.0.11 address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to configure it, set the following `JAVA_OPTS` variable in your application
    server (for instance, at `${TOMCAT_HOME}/bin/setenv.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '**node1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**node2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we touched upon several subjects from database configuration
    to Ehcache replication. All of these steps are necessary to correctly run Liferay
    in a clustered environment. Liferay is a huge system with many dependencies, so
    it is quite difficult to install it in many server instances. We believe that
    our advice will help you configure and run Liferay CMS. Our intention was to introduce
    the possible ways of configuration. Every company has its own ideas and solutions
    to install Liferay. In our experience, here are some of the best configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache with the `mod_jk` module and load balancer as a reverse proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squid as a caching proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GlusterFS as a shared filesystem where documents and media portlets keep their
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Solr server and Zookeeper as a search engine cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL database with a master/slave configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EhCache replication via multicast (or unicast)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need more detailed information, go to Liferay's official documentation
    at [https://dev.liferay.com/discover/deployment/-/knowledge_base/6-2/liferay-clustering](https://dev.liferay.com/discover/deployment/-/knowledge_base/6-2/liferay-clustering).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to learn more about scalable infrastructure, refer to the following
    recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Scalable infrastructure* recipe from [Chapter 12](part0088.xhtml#aid-2JTHG1
    "Chapter 12. Basic Performance Tuning"), *Basic Performance Tuning*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Integration with the Amazon S3 cloud* and the *Data migration between storage
    hooks* recipes from [Chapter 6](part0050.xhtml#aid-1FLS41 "Chapter 6. Documents
    and Media in Liferay"), *Documents and Media in Liferay*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
