<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Templating</h1></div></div></div><p>We have our Web API in place, so let's turn our attention to the client. In this chapter, we will consume our Web API and present our data using a mixture of both server-side and client-side templating. We will serve a<code class="literal">./views/index.html</code> masterpage file from the server with Express and use <code class="literal">consolidate.js</code> and <code class="literal">handlebars.js</code> for templating. On the client side we will use <code class="literal">backbone.js</code> and precompiled handlebars templates served directly out of the <code class="literal">./public</code> folder.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Server-side templating</h1></div></div></div><p>Up until now our<a id="id82" class="indexterm"/> Express server has only served JSON; let's install a couple of modules that will assist us in serving HTML.</p><p>
<code class="literal">consolidate.js</code> is a <a id="id83" class="indexterm"/>template engine consolidation library that was created to map all of Node's popular templating engines to the Express convention for templating, allowing them to work within Express:</p><div><pre class="programlisting">
<strong>npm install consolidate --save</strong>
</pre></div><p>
<code class="literal">handlebars.js</code> is an extension <a id="id84" class="indexterm"/>to the mustache templating language. Handlebars<a id="id85" class="indexterm"/> is a logic-less templating language that keeps view and code separated:</p><div><pre class="programlisting">
<strong>npm install handlebars --save</strong>
</pre></div><p>In order to be able to serve our handlebar templates, we will have to make some changes to our Express server. Let's change the default template engine to handlebars by setting the <code class="literal">app.engine</code>:</p><div><pre class="programlisting">app.engine('html', cons.handlebars);</pre></div><p>Now register <code class="literal">html</code> as our view file extension. If we did not set this, we would need to name our view <code class="literal">index.hbs</code> instead of <code class="literal">index.html</code>, with <code class="literal">.hbs</code> being the extension for handlebars templates.</p><div><pre class="programlisting">app.set('view engine', 'html');</pre></div><p>Let's create our single page application view; this will be served by our Express server:</p><div><pre class="programlisting">./views/index.html</pre></div><p>Next we define the location of our <code class="literal">views</code> folder and the location of our static files folder; it is here that we will store <code class="literal">components</code>, for example, CSS and JavaScript files.</p><div><pre class="programlisting">app.set('views', 'views');
app.use(express.static('public'));
app.use(express.static('public/components'));</pre></div><p>Now create a folder <a id="id86" class="indexterm"/>called <code class="literal">public</code> and add the following directory structure, so that static resources are served with the subdirectory as prefix, for example, <code class="literal">vision/vision.css.</code>
</p><div><pre class="programlisting">./public
./public/components
./public/components/vision</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Feature: Master Page</h1></div></div></div><div><pre class="programlisting">As a vision user
I want the vision application served as a single page
So that I can spend less time waiting for page loads</pre></div><p>Let's add a test to <code class="literal">./test/home.js</code> for our<a id="id87" class="indexterm"/> feature <code class="literal">Master Page</code>. This resource will <code class="literal">GET</code> our master page from route <code class="literal">./</code> and return a <code class="literal">200 OK</code> response. The <code class="literal">Content-Type</code> of the response should be <code class="literal">HTML:</code>
</p><div><pre class="programlisting">   var app = require('../app')
 , request = require('supertest');

describe('vision master page', function(){
  describe('when requesting resource /', function(){
    it('should respond with view', function(done){
      request(app)
        .get('/')
        .expect('Content-Type', /html/)
        .expect(200, done)
    });
  });
});</pre></div><p>Let's implement our <code class="literal">Master Page</code> feature. Let's create a new module that exposes a route <code class="literal">./lib/routes/home.js</code> and add a new <code class="literal">index</code> function. We start by defining a route called <code class="literal">index</code>. We create a view <code class="literal">model </code>with meta information for a page and then render the view passing the view <code class="literal">model</code>:</p><div><pre class="programlisting">exports.index = function(req, res){
  var model = {
    title: 'vision.',
    description: 'a project based dashboard for github',
    author: 'airasoul',
     user: 'Andrew Keig'
  };
  res.render('index', model);
};</pre></div><p>Let's add a new route to <a id="id88" class="indexterm"/>our Express server <code class="literal">./lib/express/index.js</code>:</p><div><pre class="programlisting">app.get('/', routes.home.index);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Package management with Bower</h1></div></div></div><p>We will now install the various components that make up our client, namely <code class="literal">Handlebars.js</code>, <code class="literal">Backbone.js</code>, and Twitter Bootstrap Version 2 using <a id="id89" class="indexterm"/>
<strong>Bower</strong>.</p><p>Bower is a package <a id="id90" class="indexterm"/>manager for the web. A Bower package can contain<a id="id91" class="indexterm"/> assets of different types, such as CSS, JavaScript, and images. Let's install Bower globally with the following command:</p><div><pre class="programlisting">
<strong>npm install -g bower</strong>
</pre></div><p>In Bower, dependencies are listed in a <code class="literal">bower.json</code> file, similar to Node's <code class="literal">package.json</code>. Let's create a <code class="literal">./bower.json</code> file and define our client-side dependencies:</p><div><pre class="programlisting">{
  "name": "vision",
  "version": "0.0.1",
  "dependencies": {
    "json2": "*",
    "jquery": "*",
    "underscore": "*",
    "backbone": "*",
    "handlebars": "*",
    "bootstrap": "2.3.2"
  }
}</pre></div><p>Now create the following Bower configuration file <code class="literal">./.bowerrc</code>, which allows us to define our target directory and the name of our <code class="literal">bower.json </code>file:</p><div><pre class="programlisting">{
    "directory": "public/components",
    "json": "bower.json"
}</pre></div><p>Run the following command to install all of the dependencies listed in our <code class="literal">bower.json</code>
<code class="literal"> </code>file:</p><div><pre class="programlisting">
<strong>bower install</strong>
</pre></div><p>Twitter Bootstrap's assets are <a id="id92" class="indexterm"/>stored in the folder specified in the path in the following snippet, so <a id="id93" class="indexterm"/>let's add a <code class="literal">static</code> middleware to override our Express server. This will keep our paths consistent on the client:</p><div><pre class="programlisting">app.use('/bootstrap', express.
  static('public/components/bootstrap/docs/assets/css'));</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Templates</h1></div></div></div><p>Our master page contains the following sections. In order to facilitate a client-side templating model using <code class="literal">backbone.js</code>, we will split up our <a id="id94" class="indexterm"/>master<a id="id95" class="indexterm"/> page into templates.</p><p>Let's create a new folder called <code class="literal">./templates</code> and add the following files:</p><div><pre class="programlisting">./templates
  projects.hbs
  project-form.hbs
  repositories.hbs
  commits.hbs
  issues.hbs</pre></div><p>In order to avoid compiling the templates on demand, let's install the grunt task <code class="literal">grunt-contrib-handlebars</code>, which will precompile our handlebar templates:</p><div><pre class="programlisting">
<strong>npm install grunt-contrib-handlebars --save-dev</strong>
</pre></div><p>We outline the grunt configuration for our handlebars compilation in the following code; it simply takes as input a template location <code class="literal">templates/*.hbs</code> and compiles these templates into a single JavaScript file and stores it at <code class="literal">public/components/vision/templates.js</code>.</p><div><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-handlebars');

handlebars: {
  compile: {
    options: {
      namespace: "visiontemplates"
    },
    files: {
      "public/components/vision/templates.js": ["templates/*.hbs"]
    }
  }
},</pre></div><p>We complete this section by taking a look at the master page template <code class="literal">./views/index.html</code>. The <a id="id96" class="indexterm"/>body contains the following areas: a <a id="id97" class="indexterm"/>header, which includes either a <code class="literal">login</code> button or a <code class="literal">logout</code> button with a <code class="literal">welcome</code> message, a <code class="literal">project-list</code> form, <code class="literal">repository-list</code>, <code class="literal">commit-list</code>, and <code class="literal">issue-list</code>.</p><div><pre class="programlisting">  {{#if user}}
       &lt;p class="navbar-text"&gt;welcome {{user}},
       &lt;a href="/logout" class="navbar-link"&gt;
         click here to sign out&lt;/a&gt;
       &lt;/p&gt;
  {{else}}
        &lt;a href="/auth/github"&gt;
        &lt;img src="img/github.png" id='login'&gt;
        &lt;/a&gt;
      {{/if}}
    
      {{#if user}}
      &lt;div class="span3"&gt;
          &lt;h2&gt;Projects&lt;/h2&gt;
          &lt;ul id="projects-list"  class="nav nav-list"&gt;&lt;/ul&gt;
          &lt;br/&gt;&lt;a id="showForm" class="btn btn-large btn-block btn-primary" href="#add"&gt;Add project&lt;/a&gt;
      &lt;/div&gt;
      &lt;div class="span3"&gt;
        &lt;h2&gt;Repositories&lt;/h2&gt;
        &lt;ul id="repository-list" class="nav inline nav-list"&gt;&lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class="span3"&gt;
        &lt;h2&gt;Commits&lt;/h2&gt;
        &lt;ul id="commits-list" class="media-list"&gt;&lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class="span3"&gt;
        &lt;h2&gt;Issues&lt;/h2&gt;
        &lt;ul id="issues-list" class="media-list"&gt;&lt;/ul&gt;
      &lt;/div&gt;
      {{else}}   
        &lt;div class="span12"&gt;
          &lt;div class="hero-unit"&gt;
            &lt;h1&gt;vision&lt;/h1&gt;
            &lt;lead&gt;a real-time multiple repository dashboard for GitHub issues and commits&lt;/lead&gt;
            &lt;p&gt;&lt;small&gt;In order to use vision; please login to a valid GitHub Account&lt;/small&gt;&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      {{/if}}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Client-side development with Backbone.js</h1></div></div></div><p>
<code class="literal">Backbone.js</code> is <a id="id98" class="indexterm"/>a lightweight and very flexible <strong>JavaScript Model View</strong> (<strong>MV*</strong>) framework<a id="id99" class="indexterm"/> that simplifies the building<a id="id100" class="indexterm"/> of complex JavaScript applications. It includes some very basic primitives that allow us to decouple our client's model and logic from its view. Backbone supports<a id="id101" class="indexterm"/> a <strong>RESTful JSON</strong> interface that ties models/collections to a RESTful API. Further information on <code class="literal">Backbone.js</code> can be found at <a class="ulink" href="http://backbonejs.org">http://backbonejs.org</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>Feature: List projects</h1></div></div></div><p>Let's build the client for our<a id="id102" class="indexterm"/> feature <code class="literal">List projects</code>. Each item in the list consists of a project name and an edit and delete button. Clicking on the name will display a list of repositories; clicking on <strong>edit</strong> will display an inline form populated with the models' data, and clicking on <strong>delete</strong> will delete the item from our database. We will return to hook up these three functions later. For now, we will simply display a project list.</p><p>What follows is an HTML template <code class="literal">./templates/projects.hbs</code> for a project item; it contains a placeholder <code class="literal">{{_id}}</code>, which will be replaced by our Backbone application:</p><div><pre class="programlisting">&lt;a href="#{{_id}}" data-id="{{_id}}"&gt;{{name}}&lt;/a&gt;
&lt;button class="delete btn btn-mini btn-primary list-btn"&gt;del &lt;/ button&gt;
&lt;button class="edit btn btn-mini btn-primary list-btn spacer "&gt;edit e&lt;/button&gt;</pre></div><p>Let's define a skeleton Backbone application with all of its pieces in place: <code class="literal">./public/components/vision/vision.js</code>. We start by defining the <code class="literal">Vision</code> namespace; we add to it an outer function called <code class="literal">Application</code>, that has a single method called <code class="literal">start</code>. Here we instantiate a <code class="literal">router</code> and call <code class="literal">Backbone.history.start()</code> in order to start the Backbone application. We then call <code class="literal">router.navigate('index', true)</code> and navigate to our home page. With this function in place, we instantiate new <code class="literal">Vision.Application()</code> and call <code class="literal">start()</code>.</p><div><pre class="programlisting">var Vision = Vision || {};

Vision.Application = function(){
    this.start = function(){
        var router = new Vision.Router();
        Backbone.history.start();
        router.navigate('index', true);
    }
};

$(function(){
    var app = new Vision.Application();
    app.start();
});</pre></div><p>Let's now create the application <code class="literal">Router</code>. Generally, Backbone applications only have one of these; a router is the entry point for our application.</p><p>First we add a function <code class="literal">Router</code>, which extends the Backbone <code class="literal">Router</code> type. We add  a view for our list of projects called <code class="literal">projectListView</code>, and add a <code class="literal">routes</code> hash, which defines a single route. The entry point for our application is an empty route mapped to a method called <code class="literal">index</code>. The <code class="literal">initialize</code> or constructor method is called when the router is instantiated; from here we call a<a id="id103" class="indexterm"/> method <code class="literal">project</code>, which instantiates a <code class="literal">ProjectListView</code>. The <code class="literal">index</code> method, which matches the route as defined previously, renders our view by calling <code class="literal">projectApplication.render()</code>.</p><div><pre class="programlisting">Vision.Router = Backbone.Router.extend({
    projectListView : "",

    routes: {
        "" : "index",
    },

    initialize : function(){
      this.project();
    },

    project : function(){
      this.projectListView = new Vision.ProjectListView();
    },  

    index : function(){
        this.projectListView.render();
    }
});</pre></div><p>Let's implement our <code class="literal">Project</code> model to support our view. We start by adding a function <code class="literal">Project</code>, which extends the Backbone <code class="literal">Model</code> type and includes a hash of default values for the two properties in our model. We override the <code class="literal">idAttribute</code> parameter in order to accommodate MongoDB identifiers. We will use the MongoDB <code class="literal">_id</code> as our model identifier; by default Backbone will use <code class="literal">id</code>. This identifier will be appended to any request Backbone makes to the server, for example, when performing GET, POST, PUT, or DELETE. We already added the API for this model in <a class="link" href="ch02.html" title="Chapter 2. Building a Web API">Chapter 2</a>, <em>Building a Web API</em>. The <code class="literal">urlRoot</code> parameter links this model to the web API route <code class="literal">/project</code> to return a project.</p><div><pre class="programlisting">Vision.Project = Backbone.Model.extend({
    defaults: {
          id : ""
        , name: ""
    },

    idAttribute: "_id",
    urlRoot: '/project'
});</pre></div><p>Let's implement a collection; <code class="literal">ProjectList</code> for our <code class="literal">Project</code> model. We add a function, <code class="literal">ProjectList</code>, that extends the Backbone <code class="literal">Collection</code> type and we specify model type as <code class="literal">Vision.Project</code>. We add a <code class="literal">url</code> method which returns our web API route <code class="literal">/project</code> to return a list of projects. The <code class="literal">initialize</code> method is called when the collection is instantiated; from here we do our <a id="id104" class="indexterm"/>initial <code class="literal">fetch()</code> to get our projects; thus calls the API <code class="literal">/project</code>.</p><div><pre class="programlisting">Vision.ProjectList = Backbone.Collection.extend({
    model: Vision.Project,

    url: function () {
        return "/project/";
    },

    initialize: function() {
        this.fetch();
    }
});</pre></div><p>Before we implement <code class="literal">ProjectListView</code>, let's create <code class="literal">event_aggregator</code>; this will allow our views to trigger and bind named events that other views can respond to. We will need to do this in order for <code class="literal">ProjectListView</code> to inform <code class="literal">RepositoryListView</code> that it's time to display a <code class="literal">RepositoryList</code>.</p><p>Let's add an <code class="literal">event_aggregator</code> function to the Backbone view prototype using the <code class="literal">underscore.js</code> extend method to mix in the Backbone <code class="literal">event</code> module into our views:</p><div><pre class="programlisting">Backbone.View.prototype.event_aggregator = _.extend({}, Backbone.Events);</pre></div><p>Let's implement a view for our <code class="literal">Project</code> collection— <code class="literal">ProjectListView</code>. We start by defining a function <code class="literal">ProjectListView</code> which extends the Backbone <code class="literal">View</code> type, and add a <code class="literal">Projects</code> array for our project list. We assign a DOM element to <code class="literal">el</code>; an unordered list called <code class="literal">projects-list</code>. This is the element our view will be inserted into. Backbone will construct an empty <code class="literal">div</code> tag if you do not assign it to <code class="literal">el</code>.</p><p>The <code class="literal">initialize</code> method is called when the view is instantiated; here we instantiate a new <code class="literal">ProjectList</code>, passing our <code class="literal">Projects</code> array. We then call <code class="literal">collection.on('add')</code>, which upon fetching data from the API will call the <code class="literal">add</code> method. The <code class="literal">add</code> method instantiates  <code class="literal">ProjectView</code>, passing to it a <code class="literal">project</code> model. We then append  <code class="literal">ProjectView</code> to our DOM element via <code class="literal">$el</code> and return the view.</p><div><pre class="programlisting">Vision.ProjectListView = Backbone.View.extend({
    Projects: [],
    el: $("ul#projects-list"),

    initialize: function () {
      this.collection = new Vision.ProjectList(this.Projects);
      this.collection.on('add', this.add, this);
    },

    add: function (project) {
      var projectView = new Vision.ProjectView({
        model: project
      });

      this.$el.append(projectView.render().el);
      return projectView;
    }
});</pre></div><p>We complete this section by <a id="id105" class="indexterm"/>implementing a view for a single project—<code class="literal">ProjectView</code>. We start by defining a function <code class="literal">ProjectView</code>, which extends the Backbone <code class="literal">View</code> type, and add a <code class="literal">tagName</code> and assign <code class="literal">li</code> to it. This tag will be wrapped around our project view; our DOM element is a <code class="literal">ul</code> tag.</p><p>We then include <code class="literal">viewTemplate</code> and assign our precompiled handlebars template to it. Although the templates are compiled to a single file —<code class="literal">./vision/templates.js</code>— we still refer to the template by name; <code class="literal">templates/projects.hbs</code>. The <code class="literal">render</code> method renders the view; we pass the <code class="literal">project</code> model to our <code class="literal">viewTemplate</code>, which is then added via <code class="literal">$el</code> to our DOM element and we return the view:</p><div><pre class="programlisting">Vision.ProjectView = Backbone.View.extend({
    tagName: "li",
    viewTemplate: visiontemplates["templates/projects.hbs"],

    render: function () {
        var project = this.viewTemplate(this.model.toJSON());
        this.$el.html(project);
        return this;
    }
});</pre></div><p>If you go into MongoDB and add the following record to the projects collection in the vision database, when visiting the Vision application in a browser you can see this record in the project list view:</p><div><pre class="programlisting">{
    "_id" : ObjectId("525c61bcb89855fc09000018"),
    "created" : ISODate("2013-10-17T22:58:37Z"),
    "name" : "test name",
    "token" : "#TOKEN#",
    "user" : "#USER#"
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec42"/>Feature: List repositories</h1></div></div></div><p>Let's build the client for our <a id="id106" class="indexterm"/>feature <code class="literal">List repositories</code>. Each item in the list consists of a repository name, a short description, and a checkbox; which allows us to add or remove the repository from the project.</p><p>What follows is an HTML template <code class="literal">./templates/repositories.hbs</code> for a repository item:</p><div><pre class="programlisting">&lt;li&gt;
  &lt;label class="checkbox inline"&gt;
  &lt;input id="{{id}}" type="checkbox" {{enabled}} value="{{name}}"&gt;&lt;h4 class="media-heading repoItem"&gt;{{name}}&lt;/h4&gt;
  &lt;small&gt;{{description}}&lt;/small&gt;
  &lt;/label&gt;
&lt;/li&gt;</pre></div><p>Let's add a <code class="literal">Repository</code> model. We add a function <code class="literal">Repository</code> that extends the Backbone <code class="literal">Model</code> type and add a hash of default values for the four properties in our model. The <code class="literal">enabled</code> property signifies that a repository is included in the selected project.</p><div><pre class="programlisting">Vision.Repository = Backbone.Model.extend({
    defaults: {
          id : ""
        , name: ""
        , description: ""
        , enabled: ""
    }
});</pre></div><p>Let's implement a collection for our <code class="literal">Repository</code> model. We start by defining a function <code class="literal">RepositoryList</code>, which extends the Backbone <code class="literal">Collection</code> type. We add the <code class="literal">projectId</code> of the selected project, and set the model type as <code class="literal">Vision.Repository</code>. We then add a <code class="literal">url</code> method and use the web API route <code class="literal">/project/:id/repos</code> to get a list of <a id="id107" class="indexterm"/>repositories for a project.</p><p>The <code class="literal">initialize</code> method is called when the collection is instantiated; from here, we assign the selected <code class="literal">projectId</code>. The <code class="literal">parse</code> method is called when a fetch is performed and will parse the response; here we assign our MongoDB <code class="literal">_id</code> to the <code class="literal">response.id</code>.</p><div><pre class="programlisting">Vision.RepositoryList = Backbone.Collection.extend({
    projectId: '',
    model: Vision.Repository,

    url : function() {
      return '/project/' + this.projectId + '/repos';
    },

    initialize: function(items, item) {
        this.projectId = item.projectId;
    },

    parse: function( response ) {
        response.id = response._id;
        return response;
    }
});</pre></div><p>We now implement a view for a single repository. We add a function, <code class="literal">RepositoryView</code>, that extends the Backbone <code class="literal">View</code> type and add a <code class="literal">tagName</code> and assign <code class="literal">li</code> to it. This tag will be wrapped around our <code class="literal">RepositoryView</code> function; our DOM element is a <code class="literal">ul</code> tag. We include a <code class="literal">viewTemplate</code> function and assign our precompiled handlebars template <code class="literal">templates/repositories.hbs</code> to it. The <code class="literal">render</code> method renders the view; we pass the <code class="literal">repository</code> model to our <code class="literal">viewTemplate</code> function, which is then added via <code class="literal">$el</code> to our DOM element, and we return the view.</p><div><pre class="programlisting">Vision.RepositoryView = Backbone.View.extend({
    tagName: "li",
    viewTemplate: visiontemplates["templates/repositories.hbs"],

    render: function () {
        this.$el.html(this.viewTemplate(this.model.toJSON()));
        return this;
    }
});</pre></div><p>Let's implement a view for our <code class="literal">RepositoryList</code> called <code class="literal">RepositoryListView</code>. We start by defining a function, <code class="literal">RepositoryListView</code>, that extends the Backbone <code class="literal">View</code> type and adds a <code class="literal">Repositories</code> array for our repository list. We add an <code class="literal">initialize</code> method; if <code class="literal">projectId</code> is empty we return. A valid <code class="literal">projectId</code> results in rendering the view; first, we clear the DOM element, and we then assign a new <code class="literal">RepositoryList</code> function to the views <code class="literal">collection</code>. We initialize the list with our <code class="literal">Repositories</code> array and our <code class="literal">projectId</code>, we then call <code class="literal">fetch</code> in our collection, and then we call <code class="literal">render</code> for a successful fetch.</p><p>The <code class="literal">render</code> method uses<a id="id108" class="indexterm"/> underscore to loop through the repository collection called <code class="literal">collection.models</code>, calling <code class="literal">add(item)</code> for each project. We include an <code class="literal">add</code> method that instantiates a <code class="literal">RepositoryView</code> function, passing to it a <code class="literal">repository</code> model. We then append a rendered <code class="literal">RepositoryView</code> to our DOM element via <code class="literal">$el</code> and return the view.</p><div><pre class="programlisting">Vision.RepositoryListView = Backbone.View.extend({
    Repositories: [],

    initialize: function (args) {
      if (!args.projectId) return;
      var me = this;
      this.$el.html('');
      this.collection = new Vision.RepositoryList(this.Repositories, {
          projectId : args.projectId
        });
        this.collection.fetch({success: function(){
          me.render();
        }});
    },

    render: function () {
      _.each(this.collection.models, function (item) {
        this.add(item);
      }, this);
    },

    add: function (item) {
      var repositoryView = new Vision.RepositoryView({
        model: item
      });

      this.$el.append(repositoryView.render(this.editMode).el);
      return repositoryView;
    }
});</pre></div><p>Let's make a few changes to our <code class="literal">ProjectView</code> and add a click event when selecting a project. We start by defining an <code class="literal">events</code> hash with a single event called click a, that calls the <code class="literal">repository</code> method. The <code class="literal">repository</code> method grabs <code class="literal">projectId</code> from our model and then calls the <code class="literal">trigger</code> <a id="id109" class="indexterm"/>method on <code class="literal">event_aggregator</code> for the event <code class="literal">repository:join</code>, passing <code class="literal">projectId</code>. We will listen to this event on <code class="literal">ProjectListView</code>.</p><div><pre class="programlisting">    events: {
      "click a" : "repository"
    },

    repository: function() {
      var data = { projectId: this.model.toJSON()._id }
      this.event_aggregator.trigger('repository:join', data);
    },</pre></div><p>Let's hook up the other side of the previous event and add an event binder to  <code class="literal">ProjectListView</code>. We add an <code class="literal">event_aggregator.bind</code> statement to our <code class="literal">initialize</code> method, binding the event <code class="literal">repository:join</code> to the <code class="literal">repository</code> method. The <code class="literal">repository</code> method triggers a <code class="literal">join</code> event on the router.</p><div><pre class="programlisting">    initialize: function () {
      this.event_aggregator.on('repository:join', this.repository, this);
        this.collection = new Vision.ProjectList(this.Projects);
        this.render();
    },

    repository: function(args){
      this.trigger('join', args);
    },</pre></div><p>Let's complete the picture and change router to listen to the <code class="literal">join</code> event. We add a <code class="literal">repositoryListView</code> function to the router and add a <code class="literal">listenTo</code> event to the <code class="literal">initialize</code> method that calls the <code class="literal">join</code> method. The <code class="literal">join</code> method calls <code class="literal">repository</code>, which instantiates the <code class="literal">RepositoryListView</code> function, passing <code class="literal">projectId</code>.</p><div><pre class="programlisting">repositoryListView:'',

initialize : function(){
  this.project();
  this.listenTo(this.projectListView , 'join', this.join);
},

join : function(args){
  this.repository(args);
},

repository : function(args){
  this.repositoryListView =new Vision.RepositoryListView({ el: 'ul#repository-list', projectId: args.projectId });
},</pre></div><p>Now, when you click on a project item's name in <code class="literal">ProjectView</code>, <code class="literal">RepositoryListView</code> is displayed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Feature: Create a project</h1></div></div></div><p>Let's add a project form for our<a id="id110" class="indexterm"/> feature <code class="literal">Create a project</code>. It consists of a large <strong>Add project</strong> button, a text box for our project name, and <code class="literal">save</code> and <code class="literal">cancel</code> buttons. Clicking on <strong>save</strong> will POST the project to our Express server, whereas, clicking on <strong>cancel</strong> closes the form.</p><p>What follows is an HTML template <code class="literal">./templates/project-form.hbs</code> for a repository item:</p><div><pre class="programlisting">&lt;form class="form-inline"&gt;
  &lt;ul class="errors help"&gt;&lt;/ul&gt;
  &lt;label&gt;name&lt;/label&gt;
  &lt;input class="name" placeholder="project name" required="required" value="{{name}}" autofocus /&gt;
  &lt;br/&gt;&lt;button class="cancel btn btn-mini btn-primary form-btn"&gt;cancel&lt;/button&gt;
  &lt;button class="save btn btn-mini btn-primary form-btn form-spacer"&gt;save&lt;/button&gt;
&lt;/form&gt;</pre></div><p>Let's make a few changes to <code class="literal">router</code> and wire up a route to our <code class="literal">Add Project</code> button. <code class="literal">routes</code> now includes a route called <code class="literal">add</code>, which calls a method called <code class="literal">add</code>. We include an <code class="literal">add</code> method that calls <code class="literal">projectListView.showForm()</code>, rendering our form:</p><div><pre class="programlisting">    routes: {
      "" : "index",
      "add" : "add"
    },
    add : function(){
      this.projectListView.showForm();
    }</pre></div><p>Let's make some changes to <code class="literal">projectListView</code> and modify the <code class="literal">initialize</code> method. We bind this view to the <code class="literal">reset</code>, <code class="literal">add</code>, and <code class="literal">remove</code> events of the <code class="literal">collection</code>. We also add a <code class="literal">showForm</code> method as called in the preceding code. The method renders a project form by calling <code class="literal">this.add()</code>, passing <code class="literal">new Vision.Project()</code>, and calling <code class="literal">add()</code> on the view returned.</p><div><pre class="programlisting">initialize: function () {
  this.event_aggregator.on('repository:join', this.repository, this);
  this.collection = new Vision.ProjectList(this.Projects);
  this.collection.on('reset', this.render, this);
  this.collection.on('add', this.add, this);
  this.collection.on('remove', this.remove, this);
},

showForm: function () {
  this.add(new Vision.Project()).add();
}</pre></div><p>Let's add some <a id="id111" class="indexterm"/>validation to our <code class="literal">Project</code> model so we can validate form input for our project. We add a <code class="literal">validate</code> method to our <code class="literal">Project</code> model and validate our <code class="literal">Project</code> model's name. If validation fails, we return an <code class="literal">errors</code> array containing error messages. We are actually overriding the <code class="literal">validate</code> method. <code class="literal">Backbone.js</code> requires that you override the validate method with your custom validation logic. By default, the method <code class="literal">validate</code> is also called as part of a <code class="literal">save</code> call.</p><div><pre class="programlisting">validate: function(attrs) {
  var errors = [];
  if (attrs.name === '') errors.push("Please enter a name");
  if (errors.length &gt; 0) return errors;
}</pre></div><p>Let's make some changes to <code class="literal">projectView</code>. We start by adding a new template called <code class="literal">formTemplate</code>, which displays a form for adding a new project. We add two new events to the <code class="literal">events</code> hash—a button <code class="literal">save</code> event and a button <code class="literal">cancel </code>event.</p><p>The <code class="literal">cancel</code> method, which responds to the cancel event, will get the current <code class="literal">projectId</code> from our model and check if the <code class="literal">model.isNew</code>. If it's new we simply remove the <code class="literal">projectView</code> from our <code class="literal">projectListView</code>. If its not new, we render our view and also render <code class="literal">repositoryListView</code> by calling <code class="literal">repository</code>. We then navigate to the <code class="literal">index</code> page using <code class="literal">history.navigate</code>.</p><p>The <code class="literal">save</code> method, which responds to the <code class="literal">save</code> event, grabs <code class="literal">projectId</code> from our model and the form data. We then call <code class="literal">model.isValid</code>, which calls the <code class="literal">validate</code> method in our project model. Any error returned results in calling <code class="literal">formError</code>. If the model is valid, we go off and get our selected repositories and assign this to our form. We then attempt to save the form as <code class="literal">Project</code> with a call to <code class="literal">model.save</code>. Any error returned results in calling <code class="literal">formError</code>. A successful save enables us to render the <code class="literal">project</code> in <code class="literal">ProjectListView</code>. We also render <code class="literal">RepositoryListView</code> by calling <code class="literal">repository</code>. We then<a id="id112" class="indexterm"/> navigate to the <code class="literal">index</code> page using <code class="literal">history.navigate</code>.</p><div><pre class="programlisting">formTemplate: visiontemplates["templates/project-form.hbs"],

events: {
    "click a" : "repository"
    "click button.save": "save",
    "click button.cancel": "cancel"
},

add: function () {
    this.$el.html(this.formTemplate(this.model.toJSON()));
    this.repository();
},

cancel: function () {
    var projectId = this.model.toJSON()._id;

    if (this.model.isNew()) {
      this.remove();
    } else {
      this.render();
      this.repository();
    }

    Backbone.history.navigate('index', true);
},

  save: function (e) {
    e.preventDefault();

    var me = this
    , formData = {}
    , projectId = this.model.toJSON()._id;

    $(e.target).closest("form")
    .find(":input").not("button")
    .each(function () {
      formData[$(this).attr("class")] = $(this).val();
    });

    if (!this.model.isValid()) {
      me.formError(me.model, me.model.validationError, e);
    } else {
      formData.repositories = $('#repository-list')
      .find("input:checkbox:checked")
      .map(function(){
      return $(this).val();
    }).get();
  }

  this.model.save(formData, {
    error: function(model, response) {
      me.formError(model, response, e);
    },
    success: function(model, response) {
      me.render();
      me.repository();
      Backbone.history.navigate('index', true);
    }
  });
},

formError: function(model, errors, e) {
  $(e.target).closest('form').find('.errors').html('');

  _.each(errors, function (error) {
    $(e.target).closest('form').find('.errors')
    .append('&lt;li&gt;' + error + '&lt;/li&gt;')
  });
}</pre></div><p>You will now be able to complete the form and add a new project.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Feature: Edit a project</h1></div></div></div><p>Let's add an edit project<a id="id113" class="indexterm"/> form for our feature <code class="literal">Edit a project</code>. It consists of a text box for the project name a save and cancel button. Clicking on <strong>save</strong> will PUT the project to our Express server; clicking on <strong>cancel</strong> closes the form. We will use the same handlebars template we used for adding a project. In order to make <code class="literal">RepositoryListView</code> editable, we will need to introduce the concept of an edit state. We have called <code class="literal">editMode</code>.</p><p>Let's make some changes to <code class="literal">projectView</code>. We start by adding a new event <code class="literal">edit</code> to the <code class="literal">events</code> hash, which calls an <code class="literal">edit</code> function. We change our <code class="literal">repository</code> method by passing a new <code class="literal">arg.editMode</code> to <code class="literal">event_aggregator</code>, which will inform our <code class="literal">RepositoryListView</code> that it is in edit mode.</p><p>The <code class="literal">edit</code> method, which displays our project <code class="literal">formTemplate</code>, populated with our <code class="literal">project</code> model data calls the <code class="literal">repository</code> method with <code class="literal">editMode</code> set to <code class="literal">false</code>, informing <code class="literal">RepositoryListView</code> that it is in edit mode. Finally, we update our <code class="literal">add</code>, <code class="literal">cancel</code>, and <code class="literal">save</code> methods; calls in<a id="id114" class="indexterm"/> these methods to the <code class="literal">repository</code> method should pass <code class="literal">{editMode:false}</code>.</p><div><pre class="programlisting">    Events: {
      ...
        "click button.edit": "edit"
    },

    repository: function(args) {
      var data = { projectId: this.model.toJSON()._id, editMode: args.editMode || false }
      ...
    },

    edit: function () {
      var model = this.model.toJSON();
      this.$el.html(this.formTemplate(model));
      this.repository({editMode:true});
    },</pre></div><p>Let's make some changes to <code class="literal">RepositoryListView</code>. The <code class="literal">initialize</code> method will now either enable or disable the form checkboxes based on <code class="literal">editMode</code> when <code class="literal">collection.fetch</code> makes a successful request. The <code class="literal">enableForm</code> function removes the <code class="literal">disabled</code> tag from our <code class="literal">RepositoryListView</code> checkbox list. The <code class="literal">disableForm</code> function adds the <code class="literal">disabled</code> tag to our <code class="literal">RepositoryListView</code> checkbox list.</p><div><pre class="programlisting">    initialize: function (args) {
      ...
      this.collection.fetch({ success: function(){
        me.render();
        (args.editMode) ?  me.enableForm() : me.disableForm();
      }});
    },

    enableForm: function(){
      this.$el.find("input:checkbox").remove('disabled');
    },

    disableForm: function(){
      this.$el.find("input:checkbox").attr('disabled', 'disabled');
    }</pre></div><p>Now you will be able to edit your existing projects.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec45"/>Feature: Delete a project</h1></div></div></div><p>Let's add a <strong>delete</strong> button to our <a id="id115" class="indexterm"/>form for the feature <code class="literal">Delete a project</code>.</p><p>Let's make a change to <code class="literal">ProjectView</code> and add a new event to the <code class="literal">events</code> hash, called <code class="literal">delete</code>, which calls the <code class="literal">delete</code> method. We add a <code class="literal">delete</code> method, which destroys the model and removes <code class="literal">ProjectView</code>. We then call <code class="literal">repository</code>, removing <code class="literal">RepositoryListView</code>.</p><div><pre class="programlisting">    events: {
      ...
      "click button.delete": "delete",
    },

    delete: function () {
      this.model.destroy();
      this.remove();
      this.repository({editMode:false});
    },</pre></div><p>Let's make a change to <code class="literal">ProjectListView</code> and add a <code class="literal">collection</code> event handler to <code class="literal">initialize</code>. The event handler calls the <code class="literal">remove</code> method when an item is removed. The <code class="literal">remove</code> method grabs the model's attributes and searches the <code class="literal">Projects</code> collection, removing the item when finding it.</p><div><pre class="programlisting">    initialize: function () {
      ...
      this.collection.on("remove", this.remove, this);
    },

    remove: function (removedModel) {
      var removed = removedModel.attributes;

      _.each(this.Projects, function (project) {
        if (_.isEqual(project, removed)) {
          this.Projects.splice(_.indexOf(projects, project), 1);
        }
      });
    },</pre></div><p>You will now be able to delete a project by clicking on the delete button.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec46"/>Feature: List commits</h1></div></div></div><p>Let's add a list of commits for the feature<a id="id116" class="indexterm"/> <code class="literal">List Commits</code>. Each item in the list consists of a commit <code class="literal">message</code>, project <code class="literal">name</code>, a <code class="literal">date</code>, and the committer's <code class="literal">username</code>. The following is a HTML template <code class="literal">./templates/commits.hbs</code> for a commit item:</p><div><pre class="programlisting">  &lt;a class="pull-left" href="#"&gt;
    &lt;img class="media-object" src="img/{{avatar_url}}"   
      style="width:64px; height:64px"&gt;
  &lt;/a&gt;
  &lt;div class="media-body"&gt;
    &lt;h4 class="media-heading"&gt;{{message}}&lt;/h4&gt;
    &lt;small&gt;{{repository}}&lt;/small&gt;
    &lt;small&gt;{{ago}}&lt;/small&gt;
    &lt;br/&gt;&lt;small&gt;{{login}}&lt;/small&gt;
  &lt;/div&gt;</pre></div><p>Let's implement our <code class="literal">Commit</code> model. We define a function, <code class="literal">Commit</code>, which extends the Backbone <code class="literal">Model</code> type, and we include a hash of default values for the properties in our model.</p><div><pre class="programlisting">Vision.Commit = Backbone.Model.extend({
    defaults: {
      date : '',
      ago: '',
      message : '',
      login : '',
      avatar_url : ''
    }
});</pre></div><p>Let's implement a collection, <code class="literal">CommitList</code>, for our <code class="literal">Commit</code> model. We define a function, <code class="literal">CommitList</code>, which extends the Backbone <code class="literal">Collection</code> type. We specify the model type as <code class="literal">Vision.Commit</code>. We add a <code class="literal">url</code> method that uses the web API route <code class="literal">/project/:id/commits</code> to return a list of commits. The <code class="literal">initialize</code> method is called when the collection is instantiated; from here we assign <code class="literal">projectId</code>. The <code class="literal">parse</code> method is called when a fetch is performed and will parse the response. Here we assign our MongoDB <code class="literal">_id</code> to <code class="literal">response.id</code>.</p><div><pre class="programlisting">Vision.CommitList = Backbone.Collection.extend({
    projectId: '',
    model: Vision.Commit,

    url : function() {
      return '/project/' + this.projectId + '/commits';
    },

    initialize: function(items, item) {
      this.projectId = item.projectId;
    },

    parse: function( response ) {
      response.id = response._id;
      return response;
    }
});</pre></div><p>Let's implement a view for our <code class="literal">Commit</code> collection. We define a function, <code class="literal">CommitListView</code>, which extends the Backbone <code class="literal">View </code>type, and adds a <code class="literal">Commits</code> array for our commits list. The <code class="literal">initialize</code> method is called when the view is instantiated; from here we call <code class="literal">create</code> and instantiate a new <code class="literal">CommitList</code>, passing our <code class="literal">Commits</code> array. We call <code class="literal">refresh</code> ,which loops through the <code class="literal">Commits</code> collection rendering the view with a call to <code class="literal">render</code>. The <code class="literal">render </code>method uses underscore to loop through the <code class="literal">Commits</code> collection called <code class="literal">collection.models</code> by calling <code class="literal">add(item)</code> for each <code class="literal">commit</code>. The method <code class="literal">add</code> instantiates <code class="literal">CommitView</code>, passing<a id="id117" class="indexterm"/> to it a <code class="literal">Commit</code> model, it then appends a rendered <code class="literal">CommitView</code> to the DOM element via <code class="literal">$el</code> and returns the view.</p><div><pre class="programlisting">Vision.CommitListView = Backbone.View.extend({
  Commits: [],

  initialize: function (args) {
    if (!args.projectId) return;
    this.Commits = args.commits || [];
    this.$el.html('');
    this.create(args);
    this.refresh();
  },

  refresh: function(){
    var me = this;

    if (!this.Commits.length) {
      this.collection.fetch({ success: function(){
        me.render();
      }});
    }
  },

  create: function(args) {
    this.collection = new Vision.CommitList(this.Commits, { projectId : args.projectId });
    this.render();
  },

  render: function () {
    _.each(this.collection.models, function (item) {
      this.add(item);
    }, this);
  },

  add: function (item) {
    var commitView = new Vision.CommitView({ model: item });

    this.$el.append(commitView.render().el);
    return commitView;
  }
});</pre></div><p>We continue by adding a view for a single <a id="id118" class="indexterm"/>commit item. We define a function, <code class="literal">CommitView</code>, which extends the Backbone <code class="literal">View</code> type, and add a <code class="literal">tagName</code> and assign <code class="literal">li</code> to it. This tag will be wrapped around our commit view; our DOM element is a <code class="literal">ul</code> tag. We include <code class="literal">viewTemplate</code> and assign our precompiled handlebars template <code class="literal">./templates/commits.hbs</code> to it. The <code class="literal">render</code> method renders the view; we pass the <code class="literal">commit</code> model to our <code class="literal">viewTemplate</code>, which is then added via <code class="literal">$el</code> to our DOM element and we return the view.</p><div><pre class="programlisting">Vision.CommitView = Backbone.View.extend({
    tagName: 'li',
    className: 'media',
    viewTemplate: visiontemplates['templates/commits.hbs'],

    render: function () {
      this.$el.html(this.viewTemplate(this.model.toJSON()));
      return this;
    }
});</pre></div><p>Let's complete the picture and change our router; we add a <code class="literal">CommitListView</code> to the router and call <code class="literal">commits</code> inside the <code class="literal">join</code> method. The <code class="literal">commits</code> method instantiates a <code class="literal">CommitListView</code> passing the current <code class="literal">projectId</code> and a list of commits.</p><div><pre class="programlisting">CommitListView:'',

join : function(args){
  this.repository(args);
  this.commits(args);
},

commits : function(args){
  this.commitListView = new Vision.CommitListView({ el: 'ul#commits-list', projectId: args.projectId, commits : args.commits});
},</pre></div><p>Vision will now display a list of commits when selecting a project.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec47"/>Feature: List issues</h1></div></div></div><p>Let's build our issues list. Each item<a id="id119" class="indexterm"/> in the list simply consists of an issue title, project name, a date, the issuer's username, and its status.</p><p>What follows is an HTML template <code class="literal">./templates/issues.hbs </code>for a issues item:</p><div><pre class="programlisting">&lt;a class="pull-left" href="#"&gt;
  &lt;img class="media-object" src="img/{{avatar_url}}"style="width:64px; height:64px"&gt;
&lt;/a&gt;
&lt;div class="media-body"&gt;
  &lt;h4 class="media-heading"&gt;{{title}}&lt;/h4&gt;
  &lt;small&gt;{{repository}}&lt;/small&gt;
  &lt;small&gt;{{ago}}&lt;/small&gt;
  &lt;br/&gt;&lt;small&gt;{{login}},&lt;b&gt;{{state}}&lt;/b&gt;&lt;/small&gt;
&lt;/div&gt;</pre></div><p>Let's implement our <code class="literal">Issue</code> model; we define a function <code class="literal">Issue</code>, which extends the Backbone <code class="literal">Model</code> type, and includes a hash of <code class="literal">default</code> values for the properties in our model.</p><div><pre class="programlisting">Vision.Issue = Backbone.Model.extend({
  defaults: {
    title : '',
    state : '',
    date : '',
    ago: '',
    login : '',
    avatar_url : ''
  }
});</pre></div><p>Let's implement a collection called <code class="literal">IssueList</code> for our <code class="literal">Issue</code> model. We define a function, <code class="literal">IssueList</code>, which extends the Backbone <code class="literal">Collection</code> type, and specifies the model type as <code class="literal">Vision.Issue</code>. We add a <code class="literal">url</code> method that uses the web API route <code class="literal">/project/:id/issues</code> to return a list of issues. The <code class="literal">initialize</code> method is called when the collection is instantiated; from here we assign the selected <code class="literal">projectId</code>. The <code class="literal">parse</code> method is called when a fetch is performed and will parse the response; here we assign our MongoDB <code class="literal">_id</code> to the <code class="literal">response.id</code>.</p><div><pre class="programlisting">Vision.IssueList = Backbone.Collection.extend({
  projectId: '',
  model: Vision.Issue,

  url : function() {
    return '/project/' + this.projectId + '/issues';
  },

  initialize: function(items, item) {
    this.projectId = item.projectId;
  },

  parse: function( response ) {
    response.id = response._id;
    return response;
  }
});</pre></div><p>Let's implement a view for our <code class="literal">Issue</code> <a id="id120" class="indexterm"/>collection. We define a function, <code class="literal">IssueListView</code>, which extends the Backbone <code class="literal">View</code> type, and add an <code class="literal">Issues</code> array for our issue list. The <code class="literal">initialize</code> method is called when the <code class="literal">view</code> is instantiated; from here we call <code class="literal">create</code> and instantiate a new <code class="literal">IssueList</code>, passing our <code class="literal">Issues</code> array. We then call <code class="literal">refresh</code>, which loops through the <code class="literal">Issues</code> collection, rendering the view with a call to <code class="literal">render</code>. The <code class="literal">render</code> method uses underscore to loop through the <code class="literal">Issues</code> collection called <code class="literal">collection.models</code>; and calls <code class="literal">add(item)</code>for each issue. The method <code class="literal">add</code> instantiates <code class="literal">IssueView</code>, passing to it an <code class="literal">Issue</code> model. We then append a rendered <code class="literal">IssueView</code> to our DOM element via <code class="literal">$el</code> and return the view.</p><div><pre class="programlisting">Vision.IssueListView = Backbone.View.extend({
  Issues: [],

  initialize: function (args) {
    if (!args.projectId) return;
    this.Issues = args.issues || [];
    this.$el.html('');
    this.create(args);
    this.refresh();
  },

  create: function(args) {
    this.collection = new Vision.IssueList(this.Issues, { projectId : args.projectId });
    this.render();
  },

  refresh: function(){
    var me = this;

    if (!this.Issues.length) {
      this.collection.fetch({ success: function(){
        me.render();
      }});
    }
  },

  render: function () {
    _.each(this.collection.models, function (item) {
      this.add(item);
    }, this);
  },

  add: function (item) {
    var issueView = new Vision.IssueView({ model: item });

    this.$el.append(issueView.render().el);
    return issueView;
  }
});</pre></div><p>We continue by adding a view for a <a id="id121" class="indexterm"/>single issue. We define a function, <code class="literal">IssueView</code>, which extends the Backbone <code class="literal">View</code> type, and add a <code class="literal">tagName</code> and assign <code class="literal">li</code> to it; this tag will be wrapped around our <code class="literal">IssueView</code> function. Our DOM element is a <code class="literal">ul</code> tag. We include a <code class="literal">viewTemplate</code> and assign our precompiled handlebars template <code class="literal">templates/issues.hbs </code>to it. The <code class="literal">render</code> method renders the view; we pass the <code class="literal">issue</code> model to <code class="literal">viewTemplate</code> which is then added via <code class="literal">$el</code> to our DOM element and we return the view.</p><div><pre class="programlisting">Vision.IssueView = Backbone.View.extend({
  tagName: 'li',
  className: 'media',
  viewTemplate: visiontemplates['templates/issues.hbs'],

  render: function () {
    this.$el.html(this.viewTemplate(this.model.toJSON()));
    return this;
  }
});</pre></div><p>Let's complete the picture and change our router; we add a <code class="literal">issueListView</code> to the router and call <code class="literal">issues</code> inside the <code class="literal">join</code> method. The <code class="literal">issues</code> method instantiates <code class="literal">IssueListView</code>, passing <code class="literal">projectId</code> and a list of issues.</p><div><pre class="programlisting">issueListView:'',

join : function(args){
    this.repository(args);
    this.issues(args);
    this.commits(args);
},

issues : function(args){
    this.issueListView = new Vision.IssueListView({ el: 'ul#issues-list', projectId: args.projectId, issues: args.issues});
},</pre></div><p>Vision will now display a list of <a id="id122" class="indexterm"/>issues when selecting a project.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec48"/>Summary</h1></div></div></div><p>We have now completed the first part of our client. We have implemented a project list view that allows us to add, update, and remove projects. We have also implemented a repository list view that displays a list of repositories for our access token; these repositories can be assigned to the project. We also display a list of commits and issues for all repositories in our project. In the next chapter, we will display a real-time list of commits and issues using Socket.IO.</p></div></body></html>