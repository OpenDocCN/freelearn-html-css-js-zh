<html><head></head><body>
        

                            
                    <h1 class="header-title">Introducing REST APIs</h1>
                
            
            
                
<p class="mce-root">An <strong>Application Programming Interface</strong> (<strong>API</strong>), in general, is used to get data from one application to another. There are different kinds of APIs that are used in different areas, such as hardware and programming, but we will be talking only about web APIs. Web APIs are a form of web service that provides an interface to communicate between multiple applications. Data from one application is sent to another application via an HTTP protocol using such APIs.</p>
<p>In this chapter, we will talk about:</p>
<ul>
<li>REST architecture and RESTful APIs</li>
<li>HTTP verbs and status codes</li>
<li>Developing and testing APIs using Postman</li>
</ul>
<p>Web APIs work in a similar way to how the browser interacts with our application server. The client requests some data from the server and the server responds with the formatted data to the client; APIs do something similar. For example, there is a contract set beforehand between the multiple applications. So, if there are two applications that need to share data, then one application will submit a request to another application, saying it needs this data in this format. When another application receives the request, it fetches the data from its server and responds with the structured and formatted data to the client or the requester.</p>
<p class="mce-root">Web APIs are classified into <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>), <strong>Remote Procedure Call</strong> (<strong>RPC</strong>), or <strong>Representational State Transfer</strong> (<strong>REST</strong>) categories. The response format for these APIs can be in various forms, such as XML, JSON, HTML, images, and videos.</p>
<p>APIs also have different models, such as Public APIs and Private APIs: </p>
<ul>
<li><strong>Private APIs</strong>: Private or internal APIs are only used in internal applications within an organization</li>
<li><strong>Public APIs</strong>: Public or external APIs are designed in a way such that they can be shared with the public parties outside of an organization as well</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is REST?</h1>
                
            
            
                
<p>REST is a web service used for exchanging data between multiple applications via an HTTP protocol. RESTful Web Services are scalable and easily maintainable.</p>
<p>Here is a simple diagram that explains how the REST Web Service works:</p>
<div><img class="alignnone size-full wp-image-468 image-border" src="img/82db25c3-9e77-47ae-9a64-81168d222fb9.jpg" style="width:23.50em;height:19.58em;"/></div>
<p>As we can see in the diagram, the client requests some data by making a call to the Rest Web Service Server. Here, when we send an HTTP Request, we also provide some headers, such as what type of data we want as a response. These responses could be JSON, XML, HTML, or any other form. When the server receives the request and pulls data from storage, it does not simply return the database resources as a response. It sends a representation of these resources. That's why it is called <strong>representational</strong>. When the server responds to the client with this formatted data, the state of our application changes. And that's why it's called <strong>state transfer</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing REST APIs</h1>
                
            
            
                
<p>REST APIs are designed with a RESTful architecture. The APIs built with the principles of RESTful architecture are called RESTful APIs. RESTful architecture is also called a <strong>stateless architecture</strong> because the connection between the client and server is not preserved. The connection is reset after every transaction between the client and the server.</p>
<p>Since there are multiple web services, we have to be able to choose what our requirements and needs are in order to build the perfect API for our application. The SOAP and REST protocols both have some benefits as well as limitations.</p>
<p>The SOAP protocol was designed in 1998 by Dave Winer. It uses <strong>Extensible Markup Language</strong> (<strong>XML</strong>) for data exchange. The choice between whether to use SOAP or REST depends on which programming language we choose when we are developing and the needs of the application.</p>
<p>REST APIs let us communicate between the applications in a JSON/XML data format. JSON/XML is a representation of data that is easy to format and readable for a human. With RESTful APIs, we can perform <strong>Create</strong>, <strong>Read</strong>, <strong>Update</strong>, and <strong>Delete</strong> (<strong>C</strong><strong>RUD</strong>) operations from one application to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of REST API</h1>
                
            
            
                
<p>REST API provides a lot of benefits. Here are some of the advantages that we can get by using REST APIs:</p>
<ul>
<li>It is easy to make requests and get responses from one application to other.</li>
<li>Responses can be retrieved in human readable format in the form of JSON or XML.</li>
<li>Everything is manipulated in the form of URI, which means every request is identified by the URI request.</li>
<li>The separation between client and server makes it easy to migrate to a different server when needed with minimal change. The segregation between client and server makes it easy to scale as well. </li>
<li>It is independent of any programming languages. We can implement REST architecture irrespective of whether we are using PHP, JAVA, Rails, Node.js, and so on.</li>
<li>it is very easy to get started and the learning curve is short.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP verbs</h1>
                
            
            
                
<p>HTTP verbs are the different methods that are used to define the action that we want to execute for the resources. The most used HTTP verbs are GET, POST, PUT, PATCH, and DELETE. HTTP verbs are the request methods that make it possible to communicate between multiple applications. These HTTP verbs make it possible to perform several actions on a resource without needing to alter the URLs entirely. Let's look into each of these in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GET</h1>
                
            
            
                
<p><kbd>GET</kbd> requests are the idempotent requests. This is used when we want to fetch the information about resources. This does not modify or delete the resource. The equivalent CRUD operation for <kbd>GET</kbd> requests is <kbd>READ</kbd>, which means it only fetches the information and that's it. An example URL for a <kbd>GET</kbd> request is:</p>
<ul>
<li>To fetch all records:</li>
</ul>
<pre style="padding-left: 60px"><strong>GET http://www.example.com/users</strong></pre>
<ul>
<li>To fetch information about a single user:</li>
</ul>
<pre style="padding-left: 60px"><strong>GET http://www.example.com/users/{user_id}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">POST</h1>
                
            
            
                
<p>The equivalent CRUD operation for the <kbd>POST</kbd> request is <kbd>CREATE</kbd>. This is used with new records to the collection. Since this changes the state of the server, this is not an idempotent request. If we request a <kbd>POST</kbd> method twice with the same parameters, that will create two new identical resources in the database. An example URL for a <kbd>POST</kbd> request is:</p>
<pre><strong>POST http://www.example.com/users/</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">PUT</h1>
                
            
            
                
<p>The <kbd>PUT</kbd> request is used to create or update a record. It creates a new record if the resource does not exist yet and updates the existing record if the resource already exists. The equivalent CRUD operation is <kbd>update()</kbd>. It replaces the existing representation of the resource. An example URL for a <kbd>PUT</kbd> request is as follows:</p>
<pre><strong>PUT http://www.example.com/users/</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">DELETE</h1>
                
            
            
                
<p>This is used to remove resources from a collection. The equivalent CRUD operation is <kbd>delete()</kbd>.</p>
<p>An example URL for a <kbd>DELETE</kbd> request is as follows:</p>
<pre><strong>DELETE http://www.example.com/users/{user_id}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">HTTP status codes</h1>
                
            
            
                
<p>Status codes are the part of a response made by the server for a request made to that server. It indicates the status of a request, irrespective of whether it got successfully executed or not. The status codes have three digits. The first digit represents the class or the category of that response. The HTTP status codes range from <em>100-500</em>.  We will be covering some of the major status codes in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">2XX codes</h1>
                
            
            
                
<p>The 200 range status code is the success range for any request in the API. Within the 200 range, there is a lot of code that represents different forms of success. Explained here are a few of the many status codes that are available:</p>
<ul>
<li><strong>200 OK</strong>: This response is the standard one. It is just a representation of the request being successful. This status code also returns the resource on which the request was executed.</li>
<li><strong>201 Created</strong>: This represents the successful creation of a resource.</li>
<li><strong>204 No Content</strong>: This status code executes the request successfully, but does not return anything.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">4XX codes</h1>
                
            
            
                
<p>The 400 range status codes appear when there is an error on the client side:</p>
<ul>
<li><strong>400 Bad Request</strong>:<strong> </strong>When the request parameters are not well formatted, or the syntax is broken, then a 400 status code is returned by the server.</li>
<li><strong>401 Unauthorized</strong>:<strong> </strong>This status code is returned when an unauthorized party tries to send the API request. This basically checks the authentication part.</li>
<li><strong>403 Forbidden</strong>: This is somewhat similar to 401. This checks the authorization of the party performing the API request. This is basically done when there are different permission settings for different users performing the API.</li>
<li><strong>404 Not Found</strong>: This is returned when the resource that we are trying to perform some action on is not found by the server in the database.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">5XX codes</h1>
                
            
            
                
<p>The 500 range status code informs us that there is something wrong with the execution of the action performed in the given resource:</p>
<ul>
<li><strong>500 Internal Server Error</strong>:<strong> </strong>This status code is displayed when the action is not executed successfully. Like the 200 status code, this is a generic code returned by the server when something goes wrong.</li>
<li><strong>503 Service Unavailable</strong>: This status code is displayed when our server is not running.</li>
<li><strong>504 Gateway Timeout</strong>: This indicates that the request was sent to the server, but it did not get any response in the given time.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Postman</h1>
                
            
            
                
<p>Postman is a tool that lets us develop and test our APIs faster. This tool provides a GUI that makes it easy to tweak our APIs faster, which decreases the development time of our APIs. We can also maintain a history by creating a collection of all the APIs that we have developed.</p>
<p>There are different alternatives for Postman as well, such as Runscope and Paw. We will be using Postman for this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Postman</h1>
                
            
            
                
<p>There are different ways to use Postman:</p>
<ol>
<li>We can get the Chrome extension as follows: If you visit <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en</a>, we will see the following:</li>
</ol>
<div><img class="alignnone size-full wp-image-469 image-border" src="img/7cf083eb-f22c-4715-be35-a6349a5190cb.png" style="width:58.67em;height:31.25em;"/></div>
<p class="CDPAlignCenter CDPAlign">Click on the Add to Chrome button and the extension will be installed.</p>
<ol start="2">
<li>We can download the right desktop application for our operating system via<br/>
 <a href="https://www.getpostman.com/">https://www.getpostman.com/</a>.<a href="https://www.getpostman.com/"/></li>
</ol>
<p>We have used the desktop application for this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing APIs with Postman</h1>
                
            
            
                
<p>First, let's have a quick recap of what we have done so far. In the app that we are building, the <kbd>app.js</kbd> file should have the following code:</p>
<pre>var express = require('express');<br/>var path = require('path');<br/>var favicon = require('serve-favicon');<br/>var logger = require('morgan');<br/>var cookieParser = require('cookie-parser');<br/>var bodyParser = require('body-parser');<br/>var fs = require('file-system');<br/>var mongoose = require('mongoose');<br/><br/>var app = express();<br/>var mongoose = require('mongoose');<br/>mongoose.connect('mongodb://localhost:27017/tutorial2', {<br/>  useMongoClient: true<br/>});<br/>var db = mongoose.connection;<br/>db.on("error", console.error.bind(console, "connection error"));<br/>db.once("open", function(callback){<br/>  console.log("Connection Succeeded");<br/>});<br/><br/>// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'pug');<br/><br/>// uncomment after placing our favicon in /public<br/>//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));<br/>app.use(logger('dev'));<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, 'public')));<br/><br/>// Include controllers<br/>fs.readdirSync("controllers").forEach(function (file) {<br/>  if(file.substr(-3) == ".js") {<br/>    const route = require("./controllers/" + file)<br/>    route.controller(app)<br/>  }<br/>})<br/><br/>// catch 404 and forward to error handler<br/>app.use(function(req, res, next) {<br/>  var err = new Error('Not Found');<br/>  err.status = 404;<br/>  next(err);<br/>});<br/><br/>// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get('env') === 'development' ? err : {};<br/><br/>  // render the error page<br/>  res.status(err.status || 500);<br/>  res.render('error');<br/>});<br/><br/>module.exports = app;<br/><br/>app.listen(3000, function() {<br/>  console.log('listening on 3000')<br/>})</pre>
<p>Since this file is auto-generated when we build the application via command CLI, it uses typescript syntax. If we want to use the ES 6 syntax, we can replace <kbd>var</kbd> with <kbd>const</kbd>.</p>
<p>In our <kbd>models/User.js</kbd>, we have the following:</p>
<pre>const mongoose = require("mongoose")<br/>const Schema = mongoose.Schema<br/>const UserSchema = new Schema({<br/> name: String,<br/> email: String<br/>})<br/><br/>const User = mongoose.model("User", UserSchema)<br/>module.exports = User</pre>
<p>Also, in <kbd>controllers/users.js</kbd>, we have the following:</p>
<pre>module.exports.controller = (app) =&gt; {<br/>  // get homepage<br/>  app.get('/users', (req, res) =&gt; {<br/>    res.render('index', { title: 'Users' });<br/>  })<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a GET endpoint in the users controller</h1>
                
            
            
                
<p>Let's add a route to our <kbd>controllers/users.js</kbd> that will fetch all the user's records from the database.</p>
<p>Currently, with the code we have in our <kbd>users</kbd> controller, when we visit <kbd>http://localhost:3000/users</kbd>, it only returns a title, <kbd>Users</kbd>. Let's modify this code to incorporate a <kbd>GET</kbd> request to fetch all user requests. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching all users</h1>
                
            
            
                
<p>First, start the server with <kbd>$ nodemon app.js</kbd>. Now, in <kbd>controllers/users.js</kbd>:</p>
<pre>var User = require("../models/User");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  // get all users<br/>  app.get('/users', (req, res) =&gt; {<br/>    User.find({}, 'name email', function (error, users) {<br/>      if (error) { console.log(error); }<br/>      res.send(users);<br/>    })<br/>  })<br/>}</pre>
<p>Now that we have our code in place, let's test this endpoint using the Postman app. In the Postman app, add the necessary details in the URL. When we hit the Send button, we should see the response as follows:</p>
<div><img class="alignnone size-full wp-image-470 image-border" src="img/699d3e88-8a89-4a99-adc1-b1f6787ede61.png" style="width:162.50em;height:90.58em;"/></div>
<p>The <kbd>_id</kbd> is the Mongo ID of the user, which is sent by Mongoose query by default, and we are fetching the name and email of the user. If we want the names only, we can change our query in the <kbd>users</kbd> controller to fetch only the name.</p>
<p>Postman lets us edit the endpoints and requests are easy to develop. If we want to use our own local browser to test, we can do that as well.</p>
<p>I have used a Chrome plugin called JSONview to format the JSON response. You can get the plugin from here: <br/>
<a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc</a>.</p>
<p>As I mentioned earlier, if we visit <kbd>http://localhost:3000/users</kbd>, we should be able to see something similar to the following:</p>
<div><img class="alignnone size-full wp-image-471 image-border" src="img/30e07339-0247-45ce-8dc0-5eb058c78d6e.png" style="width:33.50em;height:49.67em;"/></div>
<p>We can use the <kbd>save</kbd> query feature given by Postman to run those queries in future as well. Just click the Save button, which is in the top right-hand corner of the app. And create new queries as we go forward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching a single user</h1>
                
            
            
                
<p>As mentioned in the HTTP verbs section, to fetch a single record from the collection, we have to pass an <kbd>id</kbd> of the user in the parameter in order to get the user details. From the preceding Postman response example, let's pick an <kbd>id</kbd> and use it to fetch the record of a user. First, let's add the endpoint to our controller. In <kbd>controllers/users.js</kbd>, add the following lines of code:</p>
<pre>var User = require("../models/User");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  // get all users<br/>  app.get('/users', (req, res) =&gt; {<br/>    User.find({}, 'name email', function (error, users) {<br/>      if (error) { console.log(error); }<br/>       res.send({<br/>        users: users<br/>      })<br/>    })<br/>  })<br/><br/>  <strong>//get a single user details</strong><br/><strong>  app.get('/users/:id', (req, res) =&gt; {</strong><br/><strong>    User.findById(req.params.id, 'name email', function (error, user) {</strong><br/><strong>      if (error) { console.log(error); }</strong><br/><strong>      res.send(user)</strong><br/><strong>    })</strong><br/><strong>  })</strong><br/>}</pre>
<p>Now create a new query in Postman with the following parameters. We will create a <kbd>GET</kbd> request with the URL <kbd>http://localhost:3000/users/:user_id</kbd> where <kbd>user_id</kbd> is the <kbd>id</kbd> of any user that you have created in your database. With this setting, we should be able to view something like this:</p>
<div><img class="alignnone size-full wp-image-472 image-border" src="img/dffcc2de-bd58-430f-9737-d443c9e04934.png" style="width:162.50em;height:90.50em;"/></div>
<p>The query should return the details of the user with the given ID in the URL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a POST endpoint in the users controller</h1>
                
            
            
                
<p>Let's look at an example. Let's create an API that will use the MongoDB <kbd>insert()</kbd> command to save user resources in the database. In the users controller, add a new endpoint:</p>
<pre>// add a new user<br/>  app.post('/users', (req, res) =&gt; {<br/>    const user = new User({<br/>      name: req.body.name,<br/>      email: req.body.email<br/>    })<br/><br/>    user.save(function (error, user) {<br/>      if (error) { console.log(error); }<br/>      res.send(user)<br/>    })<br/>  })</pre>
<p>In Postman, set the method as <kbd>POST</kbd>, the URL as <kbd>http://localhost:3000/users</kbd>, set the parameters to raw JSON, and provide the following input:</p>
<pre><strong>{</strong><br/><strong>  "name": "Dave",</strong><br/><strong>  "email": "dave@mongo.com"</strong><br/><strong>}</strong></pre>
<div><img class="alignnone size-full wp-image-473 image-border" src="img/88888180-6c04-4733-80ab-7c2fb1956557.png" style="width:59.58em;height:33.25em;"/></div>
<p>Unlike the <kbd>GET</kbd> request, we have to pass the name and email of the user we want to add in the <kbd>body</kbd> parameter. Now, if we run a <kbd>GET all users</kbd> query, we should be able to see this new user. If we run the <kbd>POST</kbd> request twice with the same parameters, then it creates two different resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a PUT endpoint in the users controller</h1>
                
            
            
                
<p>Let's update a user with ID <kbd>5a3153d7ba3a827ecb241779</kbd> (change this ID to the ID of your document), which we just created. Let's rename the email: to do that, first let's add the endpoint in our users controller, in other words, <kbd>controllers/user.js</kbd>: </p>
<pre>// update a user<br/>  app.put('/users/:id', (req, res) =&gt; {<br/>    User.findById(req.params.id, 'name email', function (error, user) {<br/>      if (error) { console.error(error); }<br/><br/>      user.name = req.body.name<br/>      user.email = req.body.email<br/>      user.save(function (error, user) {<br/>        if (error) { console.log(error); }<br/>        res.send(user)<br/>      })<br/>    })<br/>  })</pre>
<p>What we did here is, we added an endpoint for a <kbd>PUT</kbd> request, which takes the name and email as parameters and saves it to the database. The corresponding Postman would look as follows:</p>
<div><img class="alignnone size-full wp-image-474 image-border" src="img/b2e262b8-d7e5-43d9-8e8f-b5e4770de526.png" style="width:162.50em;height:90.67em;"/></div>
<p>Here, we can see that the user's name has been updated. And, if we look at the request parameters, we have also added an <kbd>age</kbd> parameter. But since we haven't added <kbd>age</kbd> to our Schema while defining the User model, it discards the age value but updates the rest.</p>
<p>We can also use the <kbd>PATCH</kbd> method to update a resource. The difference between the <kbd>PUT</kbd> and <kbd>PATCH</kbd> methods is: the <kbd>PUT</kbd> method updates the whole resource, whereas <kbd>PATCH</kbd> is used for a partial update on resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a DELETE endpoint in the users controller</h1>
                
            
            
                
<p>Similarly, for delete, let's add an endpoint in <kbd>controllers/users.js</kbd>:</p>
<pre>// delete a user<br/>  app.delete('/users/:id', (req, res) =&gt; {<br/>    User.remove({<br/>      _id: req.params.id<br/>    }, function(error, user){<br/>      if (error) { console.error(error); }<br/>      res.send({ success: true })<br/>    })<br/>  })</pre>
<p>The preceding code takes the ID of the user and removes the user with the given ID from the database. In Postman, the endpoint would look as follows:</p>
<div><img class="alignnone size-full wp-image-475 image-border" src="img/b749f8ca-090b-4425-baa2-f34541438cb7.png" style="width:39.42em;height:21.92em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about what a RESTful API is, the different HTTP verbs and the status codes, and how to develop RESTful APIs and test them using Postman.</p>
<p>In the next chapter, we will be jumping into the Vue.js introduction and will be building an application using Vue.js.</p>


            

            
        
    </body></html>