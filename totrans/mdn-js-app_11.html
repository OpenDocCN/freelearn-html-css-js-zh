<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Building an RSS Reader Using React and Flux </h1></div></div></div><p>React is not enough to build a complete application, as it's just the view layer. We need an architecture for holding the application logic and data, and this is where Flux comes in. Obviously, React can be used with any other architecture, but Flux is what is mostly used with React, as Flux is based on unidirectional data flow, like React. In this chapter, we will build a single-page RSS reader using React and Flux.</p><p>We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flux architecture in depth</li><li class="listitem" style="list-style-type: disc">Routing using the React Router library</li><li class="listitem" style="list-style-type: disc">Using Flux.js to create a dispatcher</li><li class="listitem" style="list-style-type: disc">Using MicroEvent.js to emit events</li><li class="listitem" style="list-style-type: disc">Integrating Flux and routing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Understanding Flux</h1></div></div></div><p>
<strong>Flux</strong> is an <a id="id479" class="indexterm"/>application architecture and not a framework. You can think of it as an alternative to MVC. It was primarily developed to be used with React as both of them are based <a id="id480" class="indexterm"/>on unidirectional data flow. The Flux architecture enforces unidirectional data flow.</p><p>Here is a diagram that shows all the parts of the Flux architecture and how data flows in it:</p><div><img src="img/B05154_11_01.jpg" alt="Understanding Flux"/></div><p>Here is <a id="id481" class="indexterm"/>how <a id="id482" class="indexterm"/>each part works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Actions</strong>: An action <a id="id483" class="indexterm"/>is an object that describes what we want to do and the data that we need to do it. In Flux, all events and data from all sources are converted to actions. Even UI events are converted to actions.</li><li class="listitem" style="list-style-type: disc"><strong>Dispatcher</strong>: The dispatcher <a id="id484" class="indexterm"/>is a special type of event system. It is used to broadcast actions to registered callbacks. What the dispatcher does is not the same as a pub/sub system, as callbacks are not subscribed to particular events. Instead, every action is dispatched to every registered callback. An application should contain only one dispatcher.</li><li class="listitem" style="list-style-type: disc"><strong>Action creators</strong>: Action creators <a id="id485" class="indexterm"/>are methods that dispatch actions to the dispatcher.</li><li class="listitem" style="list-style-type: disc"><strong>Stores</strong>: Stores <a id="id486" class="indexterm"/>are objects that store the application data and logic. Stores react to actions. Callbacks ping the store to take appropriate action whenever an action that the store depends on is dispatched by the dispatcher.</li><li class="listitem" style="list-style-type: disc"><strong>React views</strong>: React views <a id="id487" class="indexterm"/>are the React components that can retrieve data from stores and display as well as listen to events emitted from stores whenever there is a change in the data stored by them. Note that the events emitted by stores are not converted into actions.</li></ul></div><p>So, in Flux, all the events and data from different sources are dispatched to the dispatcher as actions, then <a id="id488" class="indexterm"/>the stores update themselves whenever the dispatcher dispatches <a id="id489" class="indexterm"/>actions, and finally, views get updated whenever stores update.</p><p>Here is an another diagram, which provides a much higher-level abstraction of how Flux works:</p><div><img src="img/B05154_11_02.jpg" alt="Understanding Flux"/></div><p>Here you can see that the data flows in a single direction, that is, data and events first go to the <a id="id490" class="indexterm"/>
<strong>Dispatcher</strong>, then <a id="id491" class="indexterm"/>to the <strong>Store</strong>, and finally <a id="id492" class="indexterm"/>to the <strong>View</strong>. So, we can say that dispatcher, store, and view are the three major parts of the Flux architecture.</p><p>Just as there are many MVC frameworks, such as Angular, Ember, and Backbone, there are many Flux frameworks, such as Fluxible, Reflux, Alt, and Redux. But to keep things simple and easier to learn, we will not use any of these frameworks. Instead, we will use the Flux.js and MicroEvent.js libraries to implement the Flux architecture.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Using Flux.js</h1></div></div></div><p>The <strong>Flux.js</strong> is <a id="id493" class="indexterm"/>a library created by the creators of Flux. It is used to build <a id="id494" class="indexterm"/>dispatchers. You can <a id="id495" class="indexterm"/>find the Flux.js source code at <a class="ulink" href="https://github.com/facebook/flux">https://github.com/facebook/flux</a> and <a id="id496" class="indexterm"/>the CDN version at <a class="ulink" href="https://cdnjs.com/libraries/flux">https://cdnjs.com/libraries/flux</a>.</p><p>A dispatcher <a id="id497" class="indexterm"/>is created using the <code class="literal">Dispatcher</code> constructor. It has five methods, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">register(callback)</code>: This <a id="id498" class="indexterm"/>method lets us register a callback. It returns a string called the <code class="literal">callback</code> ID to uniquely identify a callback.</li><li class="listitem" style="list-style-type: disc"><code class="literal">unregister(id)</code>: This <a id="id499" class="indexterm"/>is a method lets us unregister a registered callback. To unregister, we need to pass the ID of the callback that we want to unregister.</li><li class="listitem" style="list-style-type: disc"><code class="literal">waitFor(array)</code><a id="id500" class="indexterm"/>: This waits for the specified callbacks to be invoked before continuing with the execution of the current callback. This method should only be used by a callback in response to a dispatched action.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dispatch(action)</code>: This <a id="id501" class="indexterm"/>dispatches an action to registered callbacks.</li><li class="listitem" style="list-style-type: disc"><code class="literal">isDispatching()</code>: This <a id="id502" class="indexterm"/>returns a Boolean indication of whether the dispatcher is currently dispatching.</li></ul></div><p>We will <a id="id503" class="indexterm"/>go <a id="id504" class="indexterm"/>through example code while building the RSS feed reader.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Using MicroEvent.js</h1></div></div></div><p>
<strong>MicroEvent.js</strong> <a id="id505" class="indexterm"/>is an event emitter library, which provides the <a id="id506" class="indexterm"/>observer pattern to JavaScript objects. We need MicroEvent.js for triggering events from stores to update views.</p><p>You <a id="id507" class="indexterm"/>can get MicroEvent.js from <a class="ulink" href="http://notes.jetienne.com/2011/03/22/microeventjs.html">http://notes.jetienne.com/2011/03/22/microeventjs.html</a>.</p><p>To make an object or constructor be able to emit events and others to be able to subscribe to it, we need to integrate a <code class="literal">MicroEvent</code> interface into the object or constructor using the <code class="literal">MicroEvent.mixin</code> method.</p><p>Now, inside the object or constructor, we can trigger events using <code class="literal">this.trigger()</code>, and others can subscribe to events using the <code class="literal">bind()</code> method of the object. We can also unbind using the <code class="literal">unbind()</code> method.</p><p>We will look at example code while building the RSS feed reader.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec82"/>Introduction to React Router</h1></div></div></div><p>The RSS feed <a id="id508" class="indexterm"/>reader application we will create is going to be a single-page application. In single-page applications, routes are defined on the frontend instead of the backend. We need some sort of library that lets us define routes and assign components to them, that is, it can keep the UI in sync with the URL.</p><p>
<strong>React Router</strong> is the most popular and recommended routing library for React. It provides a simple API <a id="id509" class="indexterm"/>with powerful features such as dynamic route matching and location transition handling built in.</p><p>You can <a id="id510" class="indexterm"/>find the source code of React Router at <a class="ulink" href="https://github.com/reactjs/react-router">https://github.com/reactjs/react-router</a> and the CDN version at <a class="ulink" href="https://cdnjs.com/libraries/react-router">https://cdnjs.com/libraries/react-router</a>.</p><p>Here is a code sample of how to define routes using React Router and assign components to them:</p><div><pre class="programlisting">var Router = ReactRouter.Router;
var Route = ReactRouter.Route;
var Link = ReactRouter.Link;
var BrowserHistory = ReactRouter.browserHistory;

var Routes = (
  &lt;Router history={BrowserHistory}&gt;
    &lt;Route path="/" component={Home}&gt;&lt;/Route&gt;
    &lt;Route path="/profile/:username" component={Profile}&gt;&lt;/Route&gt;
    &lt;Route path="*" component={NotFound}/&gt;
  &lt;/Router&gt;
)

ReactDOM.render(Routes, document.body);</pre></div><p>Here is how the preceding code works:</p><div><ol class="orderedlist arabic"><li class="listitem">React Router lets us define routes and their components using React components themselves. This makes it easy to write routes.</li><li class="listitem">A<code class="literal"> Route</code> component is used to define individual routes. The paths of the routes are of the same pattern as the paths in Express.</li><li class="listitem">All the <code class="literal">Route</code> components are wrapped with the <code class="literal">Router</code> component and the <code class="literal">Router</code> component is rendered on the page. The <code class="literal">Router</code> component finds the matching route for the current URL and renders the component assigned to the route.</li><li class="listitem">We assigned the <code class="literal">history</code> property of the <code class="literal">Router</code> component to <code class="literal">ReactRouter.browserHistory</code>, which makes <code class="literal">Router</code> use the HTML5 History API.</li><li class="listitem">The <code class="literal">Link</code> component should be used instead of the <code class="literal">&lt;a&gt;</code> tag as this component prevents full-page reloads and instead just changes the URL and renders the matching component.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec83"/>Creating the RSS feed reader</h1></div></div></div><p>The RSS <a id="id511" class="indexterm"/>feed reader we will create will let you add feed URLs, view a list of added URLs, and view the content of each feed URL. We will be storing the URLs in HTML5 local storage.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec80"/>Setting up the project directories and files</h2></div></div></div><p>In the <a id="id512" class="indexterm"/>exercise files of this chapter, you <a id="id513" class="indexterm"/>will find two directories: <code class="literal">Initial</code> and <code class="literal">Final</code>. <code class="literal">Final</code> contains the final source code of the application whereas <code class="literal">Initial</code> contains the files to help you quickly get started with building the application.</p><p>In the <code class="literal">Initial</code> directory, you will find <code class="literal">app.js</code>, <code class="literal">package.json</code>, and a public directory containing files to be served to the frontend. The <code class="literal">app.js</code> file will contain backend code. Currently, <code class="literal">app.js</code> and <code class="literal">package.json</code> contain no code.</p><p>We will put our HTML code in <code class="literal">public/html/index.html</code>, and in the <code class="literal">public/js/index.js</code> file, we will place our frontend JavaScript code, that is, React code.</p><p>Let's first build the backend, after which we will build the frontend.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec81"/>Building the backend</h2></div></div></div><p>First, let's <a id="id514" class="indexterm"/>download the packages required for the backend. Place this code in the <code class="literal">package.json</code> file:</p><div><pre class="programlisting">{
  "name": "rss-reader",
  "dependencies": {
    "express": "4.13.3",
    "request": "2.69.0",
    "xml2json": "0.9.0"
  }
}</pre></div><p>Now, run <code class="literal">npm install</code> in the <code class="literal">Initial</code> directory to download the packages. Here, we require the <code class="literal">express</code>, <code class="literal">request</code> and <code class="literal">xml2json</code> npm packages.</p><p>Place the following code in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">var express = require("express");
var app = express();
var request = require("request");
var parser = require("xml2json");


app.use(express.static(__dirname + "/public"));

app.get("/feed", function(httpRequest, httpResponse, next){
  request(httpRequest.query.url, function (error, response, body) {
    if (!error &amp;&amp; response.statusCode == 200)
    {
      httpResponse.send(parser.toJson(body));
    }
  })
})

app.get("/*", function(httpRequest, httpResponse, next){
  httpResponse.sendFile(__dirname + "/public/html/index.html");
})

app.listen(8080);</pre></div><p>This is <a id="id515" class="indexterm"/>how the preceding code works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we import the libraries.</li><li class="listitem">Then, we add a middleware program to serve static files.</li><li class="listitem">We then create a route that takes a URL as a query parameter, fetches the content of the URL, and sends it back as a response. We cannot fetch the feeds from the frontend because of CROS; therefore, we will fetch it through this route. It also converts the XML to JSON, because JSON is easier to work with.</li><li class="listitem">Then, for all other paths, we return the <code class="literal">index.html</code> file.</li><li class="listitem">Finally, we listen on port number <code class="literal">8080</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec82"/>Building the frontend</h2></div></div></div><p>In the <a id="id516" class="indexterm"/>
<code class="literal">public/js</code> directory, you will find all the libraries that we will be using in the frontend. In the <code class="literal">public/css</code> directory, you will find Bootstrap 4, which we will use for designing.</p><p>Place this code in the <code class="literal">index.html</code> file to enqueue the JS and CSS files as well as creating a container for React components to render:</p><div><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;RSS Feed Reader&lt;/title&gt;

    &lt;link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;div id="appContainer"&gt;&lt;/div&gt;

    &lt;script src="img/react.js"&gt;&lt;/script&gt;
    &lt;script src="img/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="img/ReactRouter.js"&gt;&lt;/script&gt;
    &lt;script src="img/Flux.js"&gt;&lt;/script&gt;
    &lt;script src="img/microevent.js"&gt;&lt;/script&gt;
    &lt;script src="img/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>At first, we <a id="id517" class="indexterm"/>enqueued Bootstrap 4. Then, we enqueued the React, React Router, Flux, and MicroEvent libraries. Finally, we enqueued the <code class="literal">index.js</code> file, in which we will put our application code.</p><p>The <code class="literal">appContainer</code> element is the one inside which all of the UI will be displayed.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec23"/>Defining routes</h3></div></div></div><p>Here is the <a id="id518" class="indexterm"/>code to define routes for our application. Compile it using Babel and place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var Router = ReactRouter.Router;
var Route = ReactRouter.Route;
var Link = ReactRouter.Link;
var BrowserHistory = ReactRouter.browserHistory;

var Routes = (
  &lt;Router history={BrowserHistory}&gt;
    &lt;Route path="/" component={FeedList}&gt;&lt;/Route&gt;
    &lt;Route path="/feed/:id" component={Feed}&gt;&lt;/Route&gt;
    &lt;Route path="submit" component={SubmitFeed}&gt;&lt;/Route&gt;
    &lt;Route path="*" component={NotFound}/&gt;
  &lt;/Router&gt;
)

ReactDOM.render(Routes, document.getElementById("appContainer"));</pre></div><p>We've defined four routes here, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">The first route is for the home page. When a user visits the home page, we will display a list of feed URLs that the user has added.</li><li class="listitem">The second route is for displaying the content of a feed.</li><li class="listitem">The third route is for adding a new feed URL.</li><li class="listitem">Finally, if <a id="id519" class="indexterm"/>nothing matches, then the fourth route displays a <strong>not found</strong> message.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec24"/>Creating dispatcher, actions, and stores</h3></div></div></div><p>Let's create <a id="id520" class="indexterm"/>the dispatcher, a store that lets <a id="id521" class="indexterm"/>us manage feed URLs, and the <code class="literal">FeedList</code> <a id="id522" class="indexterm"/>component for displaying the feed URLs on the home page. To create all these, compile and place the following code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var AppDispatcher = new Flux.Dispatcher();

var FeedStore = {
  addFeed: function(url){
    var valid = /^(ftp|http|https):\/\/[^ "]+$/.test(url);

    if(valid)
    {
      var urls = localStorage.getItem("feed-urls");
      urls = JSON.parse(urls);

      if(urls == null)
      {
        urls = [url];
      }
      else
      {
        urls[urls.length] = url;
      }

      localStorage.setItem("feed-urls", JSON.stringify(urls));

      this.trigger("valid-url");
    }
    else
    {
      this.trigger("invalid-url");
    }
  },
  getFeeds: function(){
    var urls = localStorage.getItem("feed-urls");
    urls = JSON.parse(urls);

    if(urls == null)
    {
      return [];
    }
    else
    {
      return urls;
    }
  }
}

MicroEvent.mixin(FeedStore);

var Header = React.createClass({
  render: function(){
    return(
      &lt;nav className="navbar navbar-light bg-faded"&gt;
        &lt;ul className="nav navbar-nav"&gt;
          &lt;li className="nav-item"&gt;
            &lt;Link className="nav-link" to="/"&gt;Home&lt;/Link&gt;
          &lt;/li&gt;
          &lt;li className="nav-item"&gt;
            &lt;Link className="nav-link" to="submit"&gt;Add&lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    )
  }
})

var FeedList = React.createClass({
  getInitialState: function(){
    return {
      urls: FeedStore.getFeeds()
    };
  },
  render: function(){
    var count = 0;
    return(
      &lt;div&gt;
        &lt;Header /&gt;
        &lt;div className="container"&gt;
          &lt;br /&gt;
          &lt;ul&gt;
              {
                this.state.urls.map(function(url)
                {
                  count++;
                  return &lt;li&gt; &lt;Link to={"/feed/" + count}&gt;{url}&lt;/Link&gt;&lt;/li&gt;;
              })}
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
})</pre></div><p>This is <a id="id523" class="indexterm"/>how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we <a id="id524" class="indexterm"/>create a dispatcher for our app.</li><li class="listitem">Then, we <a id="id525" class="indexterm"/>create a store named <code class="literal">FeedStore</code>, which provides us methods to add or retrieve a list of feed URLs. If we try to add an invalid URL, it sends out an <code class="literal">invalid-url</code> event; otherwise, it sends out a <code class="literal">valid-url</code> event so that we can display a message to the user indicating whether the URL was successfully added. This store stores and retrieves feed URLs from the HTML5 local storage.</li><li class="listitem">Then, we call <code class="literal">MicroEvent.mixin</code> by passing <code class="literal">FeedStore</code> as an argument so that the store is able to trigger events and others can bind to those events.</li><li class="listitem">Then, we create a <code class="literal">Header</code> component, which will be our application header. The <code class="literal">Header</code> component currently displays only two links: the root path and the path to add a new URL.</li><li class="listitem">Finally, we create the <code class="literal">FeedList</code> component. The <code class="literal">getInitialState</code> method of the component retrieves the list of feed URLs from <code class="literal">FeedStore</code> and returns them to be displayed. Note that we are not using the <code class="literal">&lt;a&gt;</code> tag while displaying the list; instead, we are using the <code class="literal">Link</code> component. The ID of a feed is its position in the array stored in local storage.</li></ol></div><p>Now, let's create the <code class="literal">SubmitFeed</code> component, which lets us add a new feed URL and then displays whether the URL has been added successfully. Here is the code for it. Compile and place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var SubmitFeed = React.createClass({
  add: function(){
    AppDispatcher.dispatch({
      actionType: "add-feed-url",
      feedURL: this.refs.feedURL.value
    });
  },
  componentDidMount: function()
  {
    FeedStore.bind("invalid-url", this.invalid_url);
    FeedStore.bind("valid-url", this.valid_url);
  },
  valid_url: function()
  {
    alert("Added successfully");
  },
  invalid_url: function()
  {
    alert("Please enter a valid URL");
  },
  componentWillUnmount: function()
  {
    FeedStore.unbind("invalid-url", this.invalid_url);
    FeedStore.unbind("valid-url", this.valid_url);
  },
  render: function(){
    return(
      &lt;div&gt;
        &lt;Header /&gt;
        &lt;div className="container"&gt;
          &lt;br /&gt;
          &lt;form&gt;
            &lt;fieldset className="form-group"&gt;
              &lt;label for="formGroupURLInput"&gt;Enter URL&lt;/label&gt;
              &lt;input type="url" className="form-control" id="formGroupURLInput" ref="feedURL" placeholder="Enter RSS Feed URL" /&gt;
            &lt;/fieldset&gt;
            &lt;input type="button" value="Submit" className="btn" onClick={this.add} /&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
})

AppDispatcher.register(function(action){
  if(action.actionType == "add-feed-url")
  {
    FeedStore.addFeed(action.feedURL);
  }
})</pre></div><p>Here is how this code works:</p><div><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">SubmitFeed</code> component displays a form with a text field and a button to submit it.</li><li class="listitem">When a <a id="id526" class="indexterm"/>user clicks on the <strong>Submit</strong> <a id="id527" class="indexterm"/>button, the <code class="literal">add</code> handler is <a id="id528" class="indexterm"/>invoked. The <code class="literal">add</code> handler dispatches an action with the <code class="literal">add-feed-url</code> action type and the URL to be added as the data.</li><li class="listitem">As soon as the component is mounted, we start listening to the <code class="literal">invalid-url</code> and <code class="literal">valid-url</code> events from <code class="literal">FeedStore</code>. If a URL is added successfully, we display a success message; otherwise, we get a failure message.</li><li class="listitem">And, as soon as the component is unmounted, we stop listening to events from <code class="literal">FeedStore</code>. We should unbind, or we will end up with multiple listeners.</li><li class="listitem">Finally, we register an action callback that checks for the <code class="literal">add-feed-url</code> action type and invokes the <code class="literal">addFeed</code> method of the <code class="literal">FeedStore</code> store.</li></ol></div><p>Now, let's create the <code class="literal">Feed</code> component, which displays the content of an individual feed URL. Here's the code for it. Compile and place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var SingleFeedStore = {
  get: function(id){
    var urls = localStorage.getItem("feed-urls");
    urls = JSON.parse(urls);

    var request_url = urls[id - 1];

    var request;
    if(window.XMLHttpRequest)
    {
      request = new XMLHttpRequest();
    } 
    else if(window.ActiveXObject) 
    {
      try 
      {
        request = new ActiveXObject("Msxml2.XMLHTTP");
      } 
      catch (e) 
      {
        try 
        {
          request = new ActiveXObject("Microsoft.XMLHTTP");
        } 
        catch (e)
        {}
      }
    }

    request.open("GET", "/feed?url=" + encodeURIComponent(request_url));

    var self = this;

    request.addEventListener("load", function(){
      self.trigger("feed-fetched", request.responseText);
    }, false);

    request.send(null);
  }
}

MicroEvent.mixin(SingleFeedStore);

var Feed = React.createClass({
  getInitialState: function(){
    return {
      data: []
    };
  },
  componentDidMount: function(){
    SingleFeedStore.get(this.props.params.id);
    SingleFeedStore.bind("feed-fetched", this.update);
  },
  update: function(data){
    var data = JSON.parse(data);
    this.setState({data: data.rss.channel.item});
  },
  componentWillUnmount: function(){
    SingleFeedStore.unbind("feed-fetched", this.update);
  },
  render: function(){
    return(
      &lt;div&gt;
        &lt;Header /&gt;
        &lt;div className="container"&gt;
          &lt;br /&gt;
          &lt;ul&gt;
              {this.state.data.map(function(post) {
                  return &lt;li&gt;&lt;a href={post.link}&gt;{post.title}&lt;/a&gt;&lt;/li&gt;;
              })}
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/div&gt; 
    )
  }
})</pre></div><p>Here's how it works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we <a id="id529" class="indexterm"/>create <code class="literal">SingleFeedStore</code>, which has a <code class="literal">get</code> method that returns the content of a feed <a id="id530" class="indexterm"/>URL. It uses our server route to fetch the content of the URL. Once the content has been fetched, it triggers <a id="id531" class="indexterm"/>the <code class="literal">feed-fetched</code> event with that content.</li><li class="listitem">Then, we called <code class="literal">MicroEvent.mixin</code> by passing <code class="literal">SingleFeedStore</code> as an argument so that the store is able to trigger events and others can bind to those events.</li><li class="listitem">Then, in the <code class="literal">getInitialState</code> method of the <code class="literal">Feed</code> component, we return an empty data array, and inside the <code class="literal">componentDidMount</code> method, we make a request to <code class="literal">SingleFeedStore</code> as the <code class="literal">get</code> method of <code class="literal">SingleFeedStore</code> gets the data asynchronously.</li><li class="listitem">In <code class="literal">componentDidMount</code>, we bind an event handler for the <code class="literal">feed-fetched</code> event and update the view as soon as the event occurs.</li><li class="listitem">As usual, we unbind the event handler as soon as the component is unmounted.</li></ol></div><p>Finally, let's create the <code class="literal">NotFound</code> component. Here is the code for it. Compile and place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var NotFound = React.createClass({
  render: function(){
    return(
      &lt;h1&gt;Page Not Found&lt;/h1&gt;
    )
  }
})</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec83"/>Testing the application</h2></div></div></div><p>We are <a id="id532" class="indexterm"/>now done with building the application. To run the webserver, inside the <code class="literal">Initial</code> directory, run <code class="literal">node app.js</code>. Now, in a browser, open <code class="literal">localhost:8080</code>. You will only be able to see the header as we haven't added anything yet. Here is how it should look:</p><div><img src="img/B05154_11_03.jpg" alt="Testing the application"/></div><p>Now, click <a id="id533" class="indexterm"/>on the <strong>Add</strong> menu item. You would see a form like this:</p><div><img src="img/B05154_11_04.jpg" alt="Testing the application"/></div><p>Enter a <a id="id534" class="indexterm"/>valid feed URL, such as <a class="ulink" href="http://qnimate.com/feed/">http://qnimate.com/feed/</a>, and click on <strong>Submit</strong>. Now, go back to the home page, and you will see this output:</p><div><img src="img/B05154_11_05.jpg" alt="Testing the application"/></div><p>Now, click <a id="id535" class="indexterm"/>on the URL to see the content of the feed. The output will be something like this:</p><div><img src="img/B05154_11_06.jpg" alt="Testing the application"/></div><p>Clicking <a id="id536" class="indexterm"/>on any of the titles will open the URL in the same tab.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Summary</h1></div></div></div><p>In this chapter, we learned how to build a single page application using React and Flux. We also explored many libraries, such as <code class="literal">xml2json</code>, <code class="literal">Flux.js</code>, <code class="literal">MicroEvent.js</code>, and React Router. Afterwards, we built a fully operational RSS feed reader.</p><p>You can now go ahead and add new things to the app, such as real-time feed updates and notifications.</p></div></body></html>