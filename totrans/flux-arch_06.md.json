["```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { LOAD_DOC } from '../actions/load-doc';\n\n// The generic \"Docs\" store keeps an index\n// of document names, since they're used\n// by many other stores.\nclass Docs extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = [];\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n        case LOAD_DOC:\n\n          // When a \"LOAD_DOC\" action is dispatched,\n          // we take the \"payload.docs\" data and\n          // transform it into the generic state that's\n          // required by many other stores.\n          for (let doc of e.payload.docs) {\n            this.state[doc.id] = doc.name;\n          }\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Docs();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport docs from './docs';\nimport { LOAD_DOC } from '../actions/load-doc';\n\n// The specific store that depends on the generic\n// \"docs\" store.\nclass Doc extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = {\n      name: ''\n    };\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n        case LOAD_DOC:\n\n          // The \"id\" of the document...\n          let { id } = e.payload;\n\n          // Here's where the generic store data\n          // comes in handy - we only care about\n          // the document name. We can use the \"id\"\n          // to look this up from the generic store.\n          this.state.name = docs.state[id];\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Doc();\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport constLOAD_DOC = 'LOAD_DOC';\n\n// Loads the name of a specific document.\nexport function loadDoc(id) {\n\n  // The API data resolves raw document data...\n  new Promise((resolve, reject) => {\n    resolve([\n      { id: 1, name: 'Doc 1' },\n      { id: 2, name: 'Doc 2' },\n      { id: 3, name: 'Doc 3' }\n    ]);\n  }).then((docs) => {\n\n    // The payload contains both the raw document\n    // collection and the specific document \"id\".\n    // The generic \"docs\" store uses the raw\n    // \"docs\" data while the specific store depends\n    // on this generic collection.\n    dispatcher.dispatch({\n      type: LOAD_DOC,\n      payload: {\n        id: id,\n        docs: docs\n      }\n    });\n  });\n}\n```", "```js\n// We have to import the generic \"docsStore\", even though\n// we're not using it here, so that it can register with\n// the dispatcher and respond to \"LOAD_DOC\" actions.\nimport docsStore from './stores/docs';\nimport docStore from './stores/doc';\nimport { loadDoc } from './actions/load-doc';\n\n// Logs the data our specific store gets from\n// the generic store.\ndocStore.on('change', (state) => {\n  console.log('name', `\"${state.name}\"`);\n});\n\n// Load the document with an id of 2.\nloadDoc(2);\n// → name \"Doc 2\"\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { LOAD_GROUPS } from '../actions/load-groups';\n\n// A generic store for user groups...\nclass Groups extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = [];\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n\n        // Stores the payload of a group array \"as-is\".\n        case LOAD_GROUPS:\n          this.state = e.payload;\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Groups();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport groups from './groups';\nimport { LOAD_USERS } from '../actions/load-users';\n\n// A users store that depends on the generic\n// groups store so that it can perform the necessary\n// state transformations.\nclass Users extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = [];\n\n    dispatcher.register((e) => {\n      switch(e.type) {\n        case LOAD_USERS:\n\n          // We only want to keep enabled users.\n          let users = e.payload.filter(\n            x => x.enabled);\n\n          // Maps to a new users array, each user object\n          // containing a new \"groupName\" property. This\n          // comes from the generic group store, and is\n          // looked up by id.\n          this.state = users.map(\n            x =>Object.assign({\n              groupName: groups.state.find(\n                y =>y.id === x.group\n              ).name\n            }, x));\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Users();\n```", "```js\nimport dispatcher from '../dispatcher';\n\n// The action identifier...\nexport constLOAD_USERS = 'LOAD_USERS';\n\n// Dispatches a \"LOAD_USERS\" action once the\n// asynchronous data has resolved.\nexport function loadUsers() {\n  new Promise((resolve, reject) => {\n    resolve([\n      { group: 1, enabled: true, name: 'User 1' },\n      { group: 2, enabled: false, name: 'User 2' },\n      { group: 2, enabled: true, name: 'User 3' }\n    ]);\n  }).then((users) => {\n    dispatcher.dispatch({\n      type: LOAD_USERS,\n      payload: users\n    });\n  });\n}\n```", "```js\nimport groupsStore from './stores/groups';\nimport usersStore from './stores/users';\nimport { loadGroups } from './actions/load-groups';\nimport { loadUsers } from './actions/load-users';\n\n// Log the state of the \"usersStore\" to make\n// sure that includes data from the generic\n// \"groupsStore\"\nusersStore.on('change', (state) => {\n  state.forEach(({ name, groupName }) => {\n    console.log(`${name} (${groupName})`);\n  });\n});\n\n// We always load the generic data first. Especially\n// if it doesn't change often.\nloadGroups();\nloadUsers();\n// →\n// User 1 (Group 1)\n// User 3 (Group 2)\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\nclass Second extends EventEmitter {\n  constructor() {\n    super();\n\n    // Registering a callback with the dispatcher\n    // returns an identifier...\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case MY_ACTION:\n          this.emit('change');\n          break;\n      }\n    });\n  }\n}\n\nexport default new Second();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\nimport second from './second';\n\nclass First extends EventEmitter {\n  constructor() {\n    super();\n\n    // Registering a callback with the dispatcher\n    // returns an identifier...\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case MY_ACTION:\n\n          // This tells the dispatcher to process any\n          // callback functions that were registered\n          // to \"second.id\" before continuing here.\n          dispatcher.waitFor([ second.id ]);\n          this.emit('change');\n          break;\n      }\n    });\n  }\n}\n\nexport default new First();\n```", "```js\n// The order of store imports no longer matters,\n// since the stores use the dispatcher to\n// explicitly handle dependency resolution.\nimport first from './stores/first';\nimport second from './stores/second';\nimport { myAction } from './actions/my-action';\n\n// The first store changed...\nfirst.on('change', () => {\n  console.log('first store changed');\n});\n\n// The second store changed...\nsecond.on('change', () => {\n  console.log('second store changed');\n});\n\n// Dispatches \"MY_ACTION\"...\nmyAction();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { FIRST } from '../actions/first';\nimport { SECOND } from '../actions/second';\n\nclass Checkboxes extends EventEmitter {\n  constructor() {\n    super();\n\n    this.state = {\n      first: true,\n      second: true\n    };\n\n    // Sets the dispatch id of this store\n    // so that other stores can depend on it.\n    // Depending on the action, this handler\n    // changes the boolean UI state of a given\n    // checkbox.\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n        case FIRST:\n          this.state.first = e.payload;\n          this.emit('change', this.state);\n          break;\n        case SECOND:\n          this.state.second = e.payload;\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Checkboxes();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { FIRST } from '../actions/first';\nimport { SECOND } from '../actions/second';\nimport checkboxes from './checkboxes';\n\nclass Labels extends EventEmitter {\n  constructor() {\n    super();\n\n    // The initial state of this store depends\n    // on the initial state of the \"checkboxes\"\n    // store.\n    this.state = {\n      first: checkboxes.state.first ?\n        'line-through' : 'none',\n      second: checkboxes.state.second ?\n        'line-through' : 'none'\n    };\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // The \"FIRST\" action was dispatched, so wait\n        // for the \"checkboxes\" UI state, then update\n        // the UI state of the \"first\" label.\n        case FIRST:\n          dispatcher.waitFor([ checkboxes.id ]);\n\n          this.state.first = checkboxes.state.first ?\n            'line-through' : 'none';\n\n          this.emit('change', this.state);\n          break;\n\n        // The \"SECOND\" action was dispatched, so wait\n        // for the \"checkboxes\" UI state, then update\n        // the UI state of the \"second\" label.\n        case SECOND:\n          dispatcher.waitFor([ checkboxes.id ]);\n\n          this.state.second = checkboxes.state.second ?\n            'line-through' : 'none';\n\n          this.emit('change', this.state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Labels();\n```", "```js\nimport checkboxes from '../stores/checkboxes';\nimport { first } from '../actions/first';\nimport { second } from '../actions/second';\n\nclass Checkboxes {\n  constructor() {\n\n    // The DOM elements our view manipulates (these\n    // are checkboxes).\n    this.first = document.getElementById('first');\n    this.second = document.getElementById('second');\n\n    // Dispatch the appropriate action when either\n    // of the checkboxes change. The action payload\n    // is the \"checked\" property of the UI element.\n    this.first.addEventListener('change', (e) => {\n      first(e.target.checked);\n    });\n\n    this.second.addEventListener('change', (e) => {\n      second(e.target.checked);\n    });\n\n    // When the \"checkboxes\" store changes state,\n    // render the view using the new state.\n    checkboxes.on('change', (state) => {\n      this.render(state);\n    });\n\n  }\n\n  // Sets the \"checked\" properties of the checkbox\n  // UI elements. By default, we use the initial\n  // state of the \"checkboxes\" store. Otherwise,\n  // we use whatever state is passed.\n  render(state=checkboxes.state) {\n    this.first.checked = state.first;\n    this.second.checked = state.second;\n  }\n}\n\nexport default new Checkboxes();\n```", "```js\nimport labels from '../stores/labels';\n\nclass Labels {\n  constructor() {\n\n    // The DOM elements this view manipulates (these\n    // are labels).\n    this.first = document.querySelector('[for=\"first\"]');\n    this.second = document.querySelector('[for=\"second\"]');\n\n    // When the \"labels\" store changes, render\n    // the view using the new state.\n    labels.on('change', (state) => {\n      this.render(state);\n    });\n  }\n\n  // Updates the \"textDecoration\" style of our\n  // label UI elements, using the \"labels\" store\n  // state as the default. Otherwise, we use whatever\n  // state is passed in.\n  render(state=labels.state) {\n    this.first.style.textDecoration = state.first;\n    this.second.style.textDecoration = state.second;\n  }\n}\n\nexport default new Labels();\n```"]