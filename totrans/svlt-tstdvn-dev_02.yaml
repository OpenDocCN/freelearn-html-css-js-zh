- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introducing the Red-Green-Refactor Workflow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍红绿重构工作流程
- en: This chapter introduces the **Red-Green-Refactor** workflow, which is at the
    heart of **Test-Driven Development** (**TDD**). You’ll use it to write a first
    Svelte component, including a unit-test suite that specifies the behavior of the
    component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**红-绿-重构**工作流程，这是**测试驱动开发**（**TDD**）的核心。你将使用它来编写第一个Svelte组件，包括一个单元测试套件，该套件指定了组件的行为。
- en: This workflow benefits you because it provides a structure for implementing
    software. It makes it less likely that you’ll implement the wrong thing. It also
    helps you to avoid overcomplicating solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流程对你有益，因为它为软件实现提供了结构。这使你不太可能实现错误的东西。它还帮助你避免过度复杂化解决方案。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding the Red-Green-Refactor workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解红-绿-重构工作流程
- en: Thinking ahead with up-front design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前瞻性设计
- en: Writing a failing test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写失败的测试
- en: Making it pass
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让它通过
- en: Refactoring the tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构测试
- en: Adding styles to the component
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件添加样式
- en: By the end of the chapter, you’ll have written your first pieces of Svelte functionality
    using TDD.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将使用TDD编写你的第一块Svelte功能。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在网上找到，地址为[https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start)。
- en: Understanding the Red-Green-Refactor workflow
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解红绿重构工作流程
- en: The Red-Green-Refactor workflow (or cycle) is a process that defines the mechanics
    of how you write software. It has enduring appeal because it has helped so many
    developers be more productive by providing structure to their day-to-day jobs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 红绿重构工作流程（或周期）是一个定义你如何编写软件的机制的过程。它具有持久的吸引力，因为它通过为他们的日常工作提供结构，帮助许多开发者提高了生产力。
- en: You do your work by making repeated cycles through the workflow until your software
    is complete. Red-Green-Refactor also lends itself to pairs and groups of developers
    working together, because it gives you a way to organize your discussion and decision
    making.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在工作流程中重复循环，直到软件完成来完成任务。红-绿-重构也适合成对或团队合作开发，因为它为你提供了一种组织讨论和决策的方式。
- en: '*Figure 2**.1* shows the workflow. It has three parts:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.1*显示了工作流程。它有三个部分：'
- en: '**Red**: To begin, you write a failing test. This sounds easier than it is,
    because first you have to know *what* you’re intending to build.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红**：首先，你编写一个失败的测试。这听起来比实际要容易，因为你首先必须知道你打算**建造什么**。'
- en: '**Green**: Once you have a failing test, you make it pass. You strive to find
    the *shortest* route possible to solve the test.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿**：一旦你有一个失败的测试，你让它通过。你努力找到解决测试的**最短**路线。'
- en: '**Refactor**: Make it good. Take a step back and think about the design. Even
    though you took the shortest route there, did you make a mess? Are there any abstractions
    beginning to appear that can be made real, or are there existing abstractions
    that need to be adjusted?'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：让它变得更好。退一步思考设计。即使你选择了最短的路线，你是否弄乱了？是否有任何抽象开始出现，可以被实现，或者现有的抽象需要调整？'
- en: '![Figure 2.1 – The Red-Green-Refactor workflow](img/Figure_2.1_B19611.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 红绿重构工作流程](img/Figure_2.1_B19611.jpg)'
- en: Figure 2.1 – The Red-Green-Refactor workflow
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 红绿重构工作流程
- en: This gives you a structure for building software. You start from nothing, and
    by repeating the cycle, you build up your software product, test by test, until
    it does something useful. (Of course, you need to know your trajectory, but that
    is part of the first step, as we’ll soon see.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你构建软件提供了结构。你从无到有，通过重复循环，测试一次，构建你的软件产品，直到它变得有用。（当然，你需要知道你的轨迹，但这将是第一步的一部分，正如我们很快将看到的。）
- en: We’ll look at the Red and Green steps in more detail in the two remaining parts
    of this chapter. First, we’ll write some code to lend as an example, and then
    we’ll discuss what we’ve done.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章剩余的两部分中更详细地探讨红和绿步骤。首先，我们将编写一些代码作为示例，然后我们将讨论我们所做的。
- en: The third part, Refactor, is more easily explained when we have more code to
    play with, so we’ll focus on that in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving Form Data*, and [*Chapter 5*](B19611_05.xhtml#_idTextAnchor070), *Validating*
    *Form Data*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分，重构，在我们有更多代码可以操作时更容易解释，所以我们将重点放在 [*第 4 章*](B19611_04.xhtml#_idTextAnchor060)，*保存表单数据*，和
    [*第 5 章*](B19611_05.xhtml#_idTextAnchor070)，*验证表单数据*。
- en: You’ve now covered the theory behind Red-Green-Refactor. Let’s try it out, shall
    we?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了 Red-Green-Refactor 的理论。让我们试试看，好吗？
- en: Thinking ahead with some up-front design
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提前进行一些初步设计
- en: If you imagine that we are a team of developers embarking on a new project,
    it would be very unlikely that we’d start a project without a project brief –
    you can’t just start writing tests with no purpose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象我们是一支即将开始新项目的开发团队，那么在没有项目概要的情况下开始项目是非常不可能的——你不能没有目的就随意编写测试。
- en: 'The goal of this section, therefore, is two things:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的目标有两件事：
- en: Discuss, at a high level, what we’ll build in the first part of the book
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书的第一部分，从高层次上讨论我们将要构建的内容
- en: Learn just enough so that we can write our first failing test
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习足够多的知识，以便我们可以编写第一个失败的测试
- en: The Birthdays application
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Birthdays 应用程序
- en: We will build a web application called *Birthdays* that manages a list of people
    and their birthdays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个名为 *Birthdays* 的网络应用程序，用于管理人员名单及其生日。
- en: '*Figure 2**.2* shows this application in action. The main page is a list of
    birthdays that have been stored. At the bottom there’s a form to add a new birthday,
    which is stored as a person’s name (just a single text field) and their date of
    birth.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.2* 展示了该应用程序的实际运行情况。主页是一个存储的生日列表。底部有一个表单，可以添加新的生日，这些生日以人员的姓名（仅一个文本字段）和他们的出生日期存储。'
- en: '![Figure 2.2 – The Birthdays application](img/Figure_2.2_B19611.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Birthdays 应用程序](img/Figure_2.2_B19611.jpg)'
- en: Figure 2.2 – The Birthdays application
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Birthdays 应用程序
- en: The user accesses this application by navigating to the `/birthdays` URL of
    our website.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过访问我们网站的 `/birthdays` URL 来访问这个应用程序。
- en: 'In this chapter, we’ll focus on building a Svelte component that displays each
    birthday in a list. It can be used like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于构建一个 Svelte 组件，该组件以列表的形式显示每个生日。它可以这样使用：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can start with a test that specifies what this `Birthday` component will
    do with its `name` prop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个测试开始，这个测试指定了`Birthday`组件将如何使用其`name`属性。
- en: Up-front design and TDD
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 初步设计和 TDD
- en: The Red part of the workflow states *write a failing test*. Okay, but what test?
    In fact, every time you start the Red cycle, you should be thinking of your trajectory.
    What do we need next? What did we learn about our design? This is the *up-front
    design* that you should be doing before each test.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程中的 Red 部分要求*编写一个失败的测试*。好吧，但写什么测试呢？实际上，每次你开始 Red 循环时，你应该在思考你的轨迹。我们接下来需要什么？我们对我们设计了解到了什么？这就是你应该在每次测试之前进行的*初步设计*。
- en: The trick, however, is doing *just enough* to know for certain what test you’re
    writing. You don’t need to have the whole system mapped out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，技巧在于只做*足够多*的事情，以便确切地知道你要编写什么测试。你不需要把整个系统都规划出来。
- en: This is all the up-front design we need to do at this point. We know what we
    can make a start on – a check that the component displays the name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这个阶段需要做的所有初步设计。我们知道我们可以从哪里开始——一个检查组件是否显示名称的检查。
- en: Writing a failing test
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个失败的测试
- en: In this section, you’ll write your first unit test for the Vitest test runner.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为 Vitest 测试运行器编写第一个单元测试。
- en: 'Create a new file named `src/routes/birthdays/Birthday.test.js` and start with
    the following `import` statements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/routes/birthdays/Birthday.test.js` 的新文件，并从以下 `import` 语句开始：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `describe` function is used to group tests into a suite of tests. Every
    test file (such as `Birthday.test.js`) will have at least one `describe` block.
    These blocks can also be nested; in future chapters, we’ll look at a couple of
    scenarios where you’ll want to do this. For example, in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving Form Data*, you’ll use them to group tests according to the individual
    form fields that appear within an HTML form.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 函数用于将测试分组为测试套件。每个测试文件（如 `Birthday.test.js`）至少有一个 `describe` 块。这些块也可以嵌套；在未来的章节中，我们将探讨一些场景，在这些场景中，你可能想要这样做。例如，在
    [*第 4 章*](B19611_04.xhtml#_idTextAnchor060)，*保存表单数据*，你将使用它们根据 HTML 表单中出现的单个表单字段来分组测试。'
- en: The `it` function is a basic function for defining unit tests, and it is named
    this way so that the test description reads like a specification. The function
    is designed to be fluent, meaning its invocations should be read like plain English.
    That’s generally something we aim for when writing tests, since it helps them
    to read like specifications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`it` 函数是定义单元测试的基本函数，它被这样命名是为了让测试描述读起来像规范。这个函数被设计成流畅的，意味着它的调用应该像普通英语一样阅读。这通常是我们在编写测试时追求的目标，因为它有助于它们像规范一样阅读。'
- en: The `expect` function is the one that we use to check our software did what
    we *expected* it to do.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 函数是我们用来检查我们的软件是否做了我们 *期望* 它做的事情。'
- en: The `render` and `screen` functions help us manipulate the `render` will output
    the component result into the current DOM document, and following that call, `screen`
    gives us a number of locator functions for finding DOM elements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 和 `screen` 函数帮助我们操作 `render` 将组件结果输出到当前的 DOM 文档中，随后调用 `screen` 会给我们提供一系列定位函数，用于查找
    DOM 元素。'
- en: 'The final import is for the `Birthday` component. This component doesn’t exist
    yet. In fact, the file doesn’t exist yet. This is intentional. Notice how we’ve
    already made design choices: where the file should reside, what it’s called, and
    what the component is named.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个导入是 `Birthday` 组件。这个组件目前还不存在。事实上，文件还不存在。这是故意的。注意我们已经做出了设计选择：文件应该存放的位置，它的名称，以及组件的名称。
- en: Design discussions at the unit level
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单位级别的设计讨论
- en: If we were working together as a group, we’d have had a discussion about all
    these decisions. Although it might seem obvious, the TDD workflow gives us space
    to discuss these issues freely with our teammates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们作为一个团队一起工作，我们会就所有这些决策进行讨论。尽管这看起来可能很显然，但 TDD 工作流程给了我们与队友自由讨论这些问题的空间。
- en: Naming things is hard. That’s why it really helps to discuss the naming. One
    thing I’ve learned about myself is that when I discuss a difficult variable name
    with others, we always come up with a better name than my own first choice.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 命名事物很难。这就是为什么讨论命名非常有帮助。关于我自己，我学到的就是当我与他人讨论一个困难的变量名时，我们总能想出一个比我最初选择更好的名字。
- en: 'Contrast this with being a solo developer, where you’d have your work reviewed
    after you’d completed it, perhaps packaged beautifully in a pull request. Imagine
    having done all the work only to be told later on by your teammates: *I think
    this name could be improved…* Frustrating, right? Having the discussion up front
    means you save yourself all that emotional turmoil later on.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相对的是作为一个独立开发者，你会在完成工作后进行工作审查，可能在一个漂亮的拉取请求中打包。想象一下，你完成了一切工作，后来队友告诉你：“我认为这个名字可以改进……”
    这不是很令人沮丧吗？提前讨论意味着你可以避免之后的所有情绪困扰。
- en: 'Let’s continue with writing the test. The first thing we need is the `describe`
    block and the `it` test description. Add the following just below the `import`
    definitions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写测试。我们首先需要的是 `describe` 块和 `it` 测试描述。在 `import` 定义下方添加以下内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See how the descriptions given to the `describe` and `it` functions form a plain
    English sentence? *Birthday displays the name of* *the person*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 `describe` 和 `it` 函数给出的描述是如何形成一个简单的英文句子的？*Birthday 显示了* *该人的* *名字*。
- en: 'Now we can fill out the test:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以填写测试：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `render` call takes our `Birthday` component together with the `name` prop
    passed in. It will mount the `Birthday` component into the DOM, ready for us to
    check its result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 调用将我们的 `Birthday` 组件与传递的 `name` 属性一起调用。它将 `Birthday` 组件挂载到 DOM 上，以便我们检查其结果。'
- en: 'Next, it’s time for the assertion. Complete the test with a call to the `expect`
    function, shown in the following code block:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是断言的时间。通过以下代码块中的 `expect` 函数完成测试：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a couple of important things to note in this expectation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个期望中，有几个重要的事情需要注意。
- en: First, note the use of the locator, `screen.queryByText`. The `screen` object
    has a whole bunch of query functions like this, all designed to find something
    individual elements in the DOM. We will uncover the common query functions as
    the book progresses. The `queryByText` function searches for the provided text
    and returns `null` if it isn’t anywhere to be found.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意定位器的使用，`screen.queryByText`。`screen` 对象有一系列这样的查询函数，所有这些函数都是为了在 DOM 中找到单个元素。随着本书的进展，我们将揭示常见的查询函数。`queryByText`
    函数搜索提供的文本，如果找不到则返回 `null`。
- en: queryBy versus getBy query function variants
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`queryBy` 与 `getBy` 查询函数变体'
- en: If you have experience with Testing Library, you’ll know that each of the query
    functions has a `getBy` and `queryBy` variant. When I’m using TDD, I use `queryBy`
    in the first test that introduces a new element. That makes it clear that I don’t
    expect the element to exist yet. But once that test is green (and passing), subsequent
    tests can use `getBy`, which throws an exception if the element isn’t found. This
    helps make it clear that this test depends on a previous test to prove the existence
    of the element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用Testing Library的经验，您会知道每个查询函数都有一个`getBy`和`queryBy`变体。当我使用TDD时，我在引入新元素的第一个测试中使用`queryBy`。这使得很清楚，我不期望元素此时存在。但是一旦这个测试变为绿色（并且通过），后续的测试就可以使用`getBy`，如果找不到元素，它会抛出一个异常。这有助于清楚地表明这个测试依赖于前面的测试来证明元素的存在。
- en: The other important thing is the `toBeVisible` function call that’s chained
    off the `expect` function call. This checks that whatever we got in the first
    call is visible in the DOM document.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是`toBeVisible`函数调用，它连接在`expect`函数调用之后。这检查我们在第一次调用中获得的内容是否在DOM文档中可见。
- en: 'If you’re familiar with Testing Library, you might be aware that there’s a
    more functionally appropriate matcher that we could have used here. We could have
    used `not.toBeNull`, like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Testing Library，您可能知道这里有一个更功能上合适的匹配器我们可以使用。我们可以使用`not.toBeNull`，如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I say this is more *functionally appropriate* because the `queryByText` query
    function will return `null` if it doesn’t find the text on the page, and that’s
    what we’re really interested in here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是更*功能上合适*的做法，因为`queryByText`查询函数如果找不到页面上的文本，将返回`null`，这正是我们真正感兴趣的。
- en: The reason I prefer `toBeVisible` is that it makes the test more readable, continuing
    with the theme of fluent, plain English matcher statements. Of course, it’s also
    important to know what the failure messages look like when the test fails, which
    we’re about to see.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`toBeVisible`的原因是它使测试更易于阅读，继续使用流畅、简洁的英语匹配语句的主题。当然，了解测试失败时的错误信息也很重要，我们马上就会看到。
- en: The final step of the Red stage is watching the test fail. Go ahead and run
    it now, either in your IDE or on the Terminal. (If you followed the instructions
    for setting up in [*Chapter 1*](B19611_01.xhtml#_idTextAnchor015), *Setting up
    for Testing*, you will be able to run tests with either the `v` shell command
    or `npm` `run test:unit`.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 红阶段的最后一步是观察测试失败。现在就运行它，无论是在您的IDE中还是在终端上。（如果您遵循了[*第1章*](B19611_01.xhtml#_idTextAnchor015)中设置说明的指示，*为测试设置*，您将能够使用`v`
    shell命令或`npm run test:unit`来运行测试。）
- en: 'You should see output like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This isn’t actually a test failure! It’s telling us the file we imported doesn’t
    exist. This is the time to create it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不是一个测试失败！它告诉我们我们导入的文件不存在。这是创建文件的时候了。
- en: Go ahead and simply create a blank file at the `src/routes/birthdays/Birthday.svelte`
    location.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请在`src/routes/birthdays/Birthday.svelte`位置创建一个空白文件。
- en: Then, rerun the tests. What happens?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新运行测试。会发生什么？
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Perfect – we have a test failure! Note the cryptic message, `received value
    must be an HTMLElement or an SVGElement`. If we had instead used the `not.toBeNull`
    matcher, we would have seen something less cryptic. However, I think the test
    is simple enough that it’s clear what’s going on – especially because of this
    line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完美——我们得到了一个测试失败！注意这个神秘的错误信息，“接收到的值必须是HTMLElement或SVGElement”。如果我们使用了`not.toBeNull`匹配器，我们会看到更不神秘的东西。然而，我认为这个测试足够简单，所以很清楚发生了什么——特别是由于这一行：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This section has shown you how you can write a failing test using the basic
    `describe`, `it`, and `expect` functions. You’ve also seen how you can use the
    test runner to drive some of the plumbing work, such as creating files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示了如何使用基本的`describe`、`it`和`expect`函数编写一个失败的测试。您还看到了如何使用测试运行器来驱动一些管道工作，例如创建文件。
- en: 'That completes the Red portion of the cycle. Next up: Green.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了循环中的红部分。接下来是绿部分。
- en: Making it pass
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它通过
- en: In this section, we’ll make a very simple change to make the test pass, and
    then we’ll repeat the cycle again with a second test.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行一个非常简单的更改，使测试通过，然后我们将用第二个测试重复这个循环。
- en: 'To make this test pass, add the following content to the `src/routes/birthdays/Birthday.svelte`
    file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，请将以下内容添加到`src/routes/birthdays/Birthday.svelte`文件中：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Rerun your tests now, and you should see the following output from the Vitest
    test runner (you’ll see the tests from [*Chapter 1*](B19611_01.xhtml#_idTextAnchor015),
    *Setting up for Testing*, are still listed here):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行你的测试，你应该会看到Vitest测试运行器的以下输出（你将看到来自[*第1章*](B19611_01.xhtml#_idTextAnchor015)，*设置测试环境*的测试仍然列在这里）：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Repeating the process
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复此过程
- en: 'Let’s go ahead and add a next step for the `dob` prop. Back in the `src/routes/birthdays/Birthday.test.js`
    file, add this test, just below the original test and still within the `describe`
    block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加`dob`属性的下一步。回到`src/routes/birthdays/Birthday.test.js`文件，添加此测试，就在原始测试下方，仍然在`describe`块内：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Make sure to run your test and watch it fail. Then, to make it pass, make the
    following additions to `src/routes/birthdays/Birthday.svelte`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保运行你的测试并观察它失败。然后，为了使其通过，请在`src/routes/birthdays/Birthday.svelte`中添加以下修改：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the tests again, and you should see both are now green. However, there
    are some warnings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，你应该会看到现在两者都是绿色的。然而，有一些警告：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll fix those warnings in the next section, along with addressing a couple
    of other issues.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中修复这些警告，同时解决几个其他问题。
- en: Refactoring the tests
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构测试
- en: In this section, we’ll look at some of the refactoring work we can do before
    we start thinking about the next feature. We’ll start by fixing the test warnings
    from the last section, then we’ll add a third test as a completeness test, and
    we’ll finish by adding some styles.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看在开始考虑下一个功能之前我们可以进行的重构工作。我们首先修复上一节中的测试警告，然后添加第三个测试作为完整性测试，最后添加一些样式。
- en: Refactoring and changing behavior
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重构和改变行为
- en: The usual definition of refactoring is *any internal change that does not affect
    external behavior*. It is a bit of a stretch to include CSS style changes in this,
    or indeed changes that remove warnings. But I find that early on in a project,
    there are always little changes such as these ones that need to be made. The key
    point is that your test suite is *green* and remains *green* throughout.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重构的通常定义是*任何不影响外部行为的内部更改*。将CSS样式更改包括在内，或者确实删除警告的更改，这有点牵强。但我在项目早期发现，总是需要做出这样的小改动。关键点是，你的测试套件是*绿色*的，并且在整个过程中保持*绿色*。
- en: Cleaning up warnings
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理警告
- en: It’s important to clean up any warnings as they appear. That’s because without
    doing this, the test runner output becomes full of noise. We want the output to
    be as short as possible so that it’s quick to decipher any problems that occur.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清理任何出现的警告非常重要。因为如果不这样做，测试运行器的输出就会充满噪音。我们希望输出尽可能简短，以便快速解析出现的问题。
- en: 'In the `src/routes/birthdays/Birthday.test.js` file, add a new definition named
    `exampleBirthday` at the top of the `describe` block:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/routes/birthdays/Birthday.test.js`文件中，在`describe`块顶部添加一个名为`exampleBirthday`的新定义：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, update the first test to include this variable as the *base* props that
    are passed to the component:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新第一个测试以包括此变量作为传递给组件的*基本*属性：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now update the second test, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新第二个测试，如下所示：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run your tests now, you should see the warnings have disappeared and
    the tests still pass.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你应该会看到警告已经消失，测试仍然通过。
- en: Adding a third test to triangulate
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加第三个测试以进行三角测量
- en: What happens if you update the `Birthday.svelte` file to have hardcoded values
    like this?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`Birthday.svelte`文件更新为具有如下硬编码值，会发生什么？
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go ahead and try it; you’ll find that your tests still pass.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，试试看；你会发现你的测试仍然通过。
- en: In fact, your tests do not protect against hardcoding. This highlights an interesting
    facet of TDD. When we’re building software guided by tests, we always aim to build
    the simplest thing that could possibly work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你的测试并不能防止硬编码。这突出了TDD（测试驱动开发）的一个有趣方面。当我们根据测试构建软件时，我们总是旨在构建可能工作的最简单的东西。
- en: 'To move beyond hardcoded values, we can add a second test for each individual
    property. Add this test to the test suite:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了超越硬编码的值，我们可以为每个单独的属性添加第二个测试。将此测试添加到测试套件中：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll see that the hardcoded version no longer works. The simplest way to get
    both of these tests working is to simply output the `name` prop value passed in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到硬编码版本不再工作。使这两个测试都能正常工作的最简单方法就是简单地输出传入的`name`属性值。
- en: This section has covered a little bit of the Refactor step. There will be plenty
    more refactoring work as the book progresses.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已简要介绍了重构步骤。随着本书的进展，将会有更多的重构工作。
- en: Adding styles to the component
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组件添加样式
- en: 'Finally, you can add the following `<style>` block to the `Birthday.svelte`
    file, which completes the `Birthday` component and means you’ll be ready to display
    it on a page, which you’ll do in the next chapter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在`Birthday.svelte`文件中添加以下`<style>`块，这完成了`Birthday`组件，意味着你将准备好在页面上显示它，你将在下一章中这样做：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can avoid writing unit tests for CSS since that is static information.
    Unit tests are specifically about behavior: what happens when this thing or that
    thing changes, or a different `name` prop is passed in?'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以避免为CSS编写单元测试，因为那是一种静态信息。单元测试专门关于行为：当这个或那个东西发生变化，或者传递了一个不同的`name`属性时会发生什么？
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taken a detailed look at the steps involved in the Red-Green-Refactor
    workflow. You have seen how much thinking is involved in every single step, and
    how the TDD process provides a scaffold for both solo work and work as a team.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细探讨了红-绿-重构工作流程中涉及的步骤。你已经看到了每一步都涉及了多少思考，以及TDD过程如何为个人工作和团队工作提供支架。
- en: You have also seen how to create a Svelte component using TDD to write a unit
    test for the Vitest test runner.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何使用TDD创建Svelte组件，并为Vitest测试运行器编写单元测试。
- en: The value of this kind of critical thinking is that it will help you map out
    your intended work from start to finish, removing the fear of going down a wrong
    path or getting lost. If you take time to practice this workflow, it will soon
    become second nature.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种批判性思维的价值在于，它将帮助你从始至终规划你的预期工作，消除走错路或迷失方向的风险。如果你花时间练习这种工作流程，它很快就会变成一种本能。
- en: In the next chapter, we’ll introduce Playwright testing, and you’ll build a
    page to hold the `Birthday` component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Playwright测试，你将构建一个页面来容纳`Birthday`组件。
