- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing the Red-Green-Refactor Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the **Red-Green-Refactor** workflow, which is at the
    heart of **Test-Driven Development** (**TDD**). You’ll use it to write a first
    Svelte component, including a unit-test suite that specifies the behavior of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: This workflow benefits you because it provides a structure for implementing
    software. It makes it less likely that you’ll implement the wrong thing. It also
    helps you to avoid overcomplicating solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Red-Green-Refactor workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking ahead with up-front design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a failing test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding styles to the component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have written your first pieces of Svelte functionality
    using TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the chapter can be found online at [https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start](https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Red-Green-Refactor workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Red-Green-Refactor workflow (or cycle) is a process that defines the mechanics
    of how you write software. It has enduring appeal because it has helped so many
    developers be more productive by providing structure to their day-to-day jobs.
  prefs: []
  type: TYPE_NORMAL
- en: You do your work by making repeated cycles through the workflow until your software
    is complete. Red-Green-Refactor also lends itself to pairs and groups of developers
    working together, because it gives you a way to organize your discussion and decision
    making.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.1* shows the workflow. It has three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red**: To begin, you write a failing test. This sounds easier than it is,
    because first you have to know *what* you’re intending to build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: Once you have a failing test, you make it pass. You strive to find
    the *shortest* route possible to solve the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor**: Make it good. Take a step back and think about the design. Even
    though you took the shortest route there, did you make a mess? Are there any abstractions
    beginning to appear that can be made real, or are there existing abstractions
    that need to be adjusted?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The Red-Green-Refactor workflow](img/Figure_2.1_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The Red-Green-Refactor workflow
  prefs: []
  type: TYPE_NORMAL
- en: This gives you a structure for building software. You start from nothing, and
    by repeating the cycle, you build up your software product, test by test, until
    it does something useful. (Of course, you need to know your trajectory, but that
    is part of the first step, as we’ll soon see.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at the Red and Green steps in more detail in the two remaining parts
    of this chapter. First, we’ll write some code to lend as an example, and then
    we’ll discuss what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: The third part, Refactor, is more easily explained when we have more code to
    play with, so we’ll focus on that in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving Form Data*, and [*Chapter 5*](B19611_05.xhtml#_idTextAnchor070), *Validating*
    *Form Data*.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now covered the theory behind Red-Green-Refactor. Let’s try it out, shall
    we?
  prefs: []
  type: TYPE_NORMAL
- en: Thinking ahead with some up-front design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you imagine that we are a team of developers embarking on a new project,
    it would be very unlikely that we’d start a project without a project brief –
    you can’t just start writing tests with no purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this section, therefore, is two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss, at a high level, what we’ll build in the first part of the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn just enough so that we can write our first failing test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Birthdays application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build a web application called *Birthdays* that manages a list of people
    and their birthdays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* shows this application in action. The main page is a list of
    birthdays that have been stored. At the bottom there’s a form to add a new birthday,
    which is stored as a person’s name (just a single text field) and their date of
    birth.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Birthdays application](img/Figure_2.2_B19611.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Birthdays application
  prefs: []
  type: TYPE_NORMAL
- en: The user accesses this application by navigating to the `/birthdays` URL of
    our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll focus on building a Svelte component that displays each
    birthday in a list. It can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can start with a test that specifies what this `Birthday` component will
    do with its `name` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Up-front design and TDD
  prefs: []
  type: TYPE_NORMAL
- en: The Red part of the workflow states *write a failing test*. Okay, but what test?
    In fact, every time you start the Red cycle, you should be thinking of your trajectory.
    What do we need next? What did we learn about our design? This is the *up-front
    design* that you should be doing before each test.
  prefs: []
  type: TYPE_NORMAL
- en: The trick, however, is doing *just enough* to know for certain what test you’re
    writing. You don’t need to have the whole system mapped out.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the up-front design we need to do at this point. We know what we
    can make a start on – a check that the component displays the name.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a failing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll write your first unit test for the Vitest test runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `src/routes/birthdays/Birthday.test.js` and start with
    the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` function is used to group tests into a suite of tests. Every
    test file (such as `Birthday.test.js`) will have at least one `describe` block.
    These blocks can also be nested; in future chapters, we’ll look at a couple of
    scenarios where you’ll want to do this. For example, in [*Chapter 4*](B19611_04.xhtml#_idTextAnchor060),
    *Saving Form Data*, you’ll use them to group tests according to the individual
    form fields that appear within an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: The `it` function is a basic function for defining unit tests, and it is named
    this way so that the test description reads like a specification. The function
    is designed to be fluent, meaning its invocations should be read like plain English.
    That’s generally something we aim for when writing tests, since it helps them
    to read like specifications.
  prefs: []
  type: TYPE_NORMAL
- en: The `expect` function is the one that we use to check our software did what
    we *expected* it to do.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` and `screen` functions help us manipulate the `render` will output
    the component result into the current DOM document, and following that call, `screen`
    gives us a number of locator functions for finding DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final import is for the `Birthday` component. This component doesn’t exist
    yet. In fact, the file doesn’t exist yet. This is intentional. Notice how we’ve
    already made design choices: where the file should reside, what it’s called, and
    what the component is named.'
  prefs: []
  type: TYPE_NORMAL
- en: Design discussions at the unit level
  prefs: []
  type: TYPE_NORMAL
- en: If we were working together as a group, we’d have had a discussion about all
    these decisions. Although it might seem obvious, the TDD workflow gives us space
    to discuss these issues freely with our teammates.
  prefs: []
  type: TYPE_NORMAL
- en: Naming things is hard. That’s why it really helps to discuss the naming. One
    thing I’ve learned about myself is that when I discuss a difficult variable name
    with others, we always come up with a better name than my own first choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with being a solo developer, where you’d have your work reviewed
    after you’d completed it, perhaps packaged beautifully in a pull request. Imagine
    having done all the work only to be told later on by your teammates: *I think
    this name could be improved…* Frustrating, right? Having the discussion up front
    means you save yourself all that emotional turmoil later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with writing the test. The first thing we need is the `describe`
    block and the `it` test description. Add the following just below the `import`
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See how the descriptions given to the `describe` and `it` functions form a plain
    English sentence? *Birthday displays the name of* *the person*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can fill out the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `render` call takes our `Birthday` component together with the `name` prop
    passed in. It will mount the `Birthday` component into the DOM, ready for us to
    check its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, it’s time for the assertion. Complete the test with a call to the `expect`
    function, shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of important things to note in this expectation.
  prefs: []
  type: TYPE_NORMAL
- en: First, note the use of the locator, `screen.queryByText`. The `screen` object
    has a whole bunch of query functions like this, all designed to find something
    individual elements in the DOM. We will uncover the common query functions as
    the book progresses. The `queryByText` function searches for the provided text
    and returns `null` if it isn’t anywhere to be found.
  prefs: []
  type: TYPE_NORMAL
- en: queryBy versus getBy query function variants
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience with Testing Library, you’ll know that each of the query
    functions has a `getBy` and `queryBy` variant. When I’m using TDD, I use `queryBy`
    in the first test that introduces a new element. That makes it clear that I don’t
    expect the element to exist yet. But once that test is green (and passing), subsequent
    tests can use `getBy`, which throws an exception if the element isn’t found. This
    helps make it clear that this test depends on a previous test to prove the existence
    of the element.
  prefs: []
  type: TYPE_NORMAL
- en: The other important thing is the `toBeVisible` function call that’s chained
    off the `expect` function call. This checks that whatever we got in the first
    call is visible in the DOM document.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with Testing Library, you might be aware that there’s a
    more functionally appropriate matcher that we could have used here. We could have
    used `not.toBeNull`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I say this is more *functionally appropriate* because the `queryByText` query
    function will return `null` if it doesn’t find the text on the page, and that’s
    what we’re really interested in here.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I prefer `toBeVisible` is that it makes the test more readable, continuing
    with the theme of fluent, plain English matcher statements. Of course, it’s also
    important to know what the failure messages look like when the test fails, which
    we’re about to see.
  prefs: []
  type: TYPE_NORMAL
- en: The final step of the Red stage is watching the test fail. Go ahead and run
    it now, either in your IDE or on the Terminal. (If you followed the instructions
    for setting up in [*Chapter 1*](B19611_01.xhtml#_idTextAnchor015), *Setting up
    for Testing*, you will be able to run tests with either the `v` shell command
    or `npm` `run test:unit`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t actually a test failure! It’s telling us the file we imported doesn’t
    exist. This is the time to create it.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and simply create a blank file at the `src/routes/birthdays/Birthday.svelte`
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Then, rerun the tests. What happens?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect – we have a test failure! Note the cryptic message, `received value
    must be an HTMLElement or an SVGElement`. If we had instead used the `not.toBeNull`
    matcher, we would have seen something less cryptic. However, I think the test
    is simple enough that it’s clear what’s going on – especially because of this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This section has shown you how you can write a failing test using the basic
    `describe`, `it`, and `expect` functions. You’ve also seen how you can use the
    test runner to drive some of the plumbing work, such as creating files.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the Red portion of the cycle. Next up: Green.'
  prefs: []
  type: TYPE_NORMAL
- en: Making it pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll make a very simple change to make the test pass, and
    then we’ll repeat the cycle again with a second test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, add the following content to the `src/routes/birthdays/Birthday.svelte`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun your tests now, and you should see the following output from the Vitest
    test runner (you’ll see the tests from [*Chapter 1*](B19611_01.xhtml#_idTextAnchor015),
    *Setting up for Testing*, are still listed here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Repeating the process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go ahead and add a next step for the `dob` prop. Back in the `src/routes/birthdays/Birthday.test.js`
    file, add this test, just below the original test and still within the `describe`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to run your test and watch it fail. Then, to make it pass, make the
    following additions to `src/routes/birthdays/Birthday.svelte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests again, and you should see both are now green. However, there
    are some warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ll fix those warnings in the next section, along with addressing a couple
    of other issues.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll look at some of the refactoring work we can do before
    we start thinking about the next feature. We’ll start by fixing the test warnings
    from the last section, then we’ll add a third test as a completeness test, and
    we’ll finish by adding some styles.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and changing behavior
  prefs: []
  type: TYPE_NORMAL
- en: The usual definition of refactoring is *any internal change that does not affect
    external behavior*. It is a bit of a stretch to include CSS style changes in this,
    or indeed changes that remove warnings. But I find that early on in a project,
    there are always little changes such as these ones that need to be made. The key
    point is that your test suite is *green* and remains *green* throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to clean up any warnings as they appear. That’s because without
    doing this, the test runner output becomes full of noise. We want the output to
    be as short as possible so that it’s quick to decipher any problems that occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/routes/birthdays/Birthday.test.js` file, add a new definition named
    `exampleBirthday` at the top of the `describe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the first test to include this variable as the *base* props that
    are passed to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now update the second test, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you run your tests now, you should see the warnings have disappeared and
    the tests still pass.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a third test to triangulate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if you update the `Birthday.svelte` file to have hardcoded values
    like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and try it; you’ll find that your tests still pass.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, your tests do not protect against hardcoding. This highlights an interesting
    facet of TDD. When we’re building software guided by tests, we always aim to build
    the simplest thing that could possibly work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move beyond hardcoded values, we can add a second test for each individual
    property. Add this test to the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that the hardcoded version no longer works. The simplest way to get
    both of these tests working is to simply output the `name` prop value passed in.
  prefs: []
  type: TYPE_NORMAL
- en: This section has covered a little bit of the Refactor step. There will be plenty
    more refactoring work as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, you can add the following `<style>` block to the `Birthday.svelte`
    file, which completes the `Birthday` component and means you’ll be ready to display
    it on a page, which you’ll do in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid writing unit tests for CSS since that is static information.
    Unit tests are specifically about behavior: what happens when this thing or that
    thing changes, or a different `name` prop is passed in?'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has taken a detailed look at the steps involved in the Red-Green-Refactor
    workflow. You have seen how much thinking is involved in every single step, and
    how the TDD process provides a scaffold for both solo work and work as a team.
  prefs: []
  type: TYPE_NORMAL
- en: You have also seen how to create a Svelte component using TDD to write a unit
    test for the Vitest test runner.
  prefs: []
  type: TYPE_NORMAL
- en: The value of this kind of critical thinking is that it will help you map out
    your intended work from start to finish, removing the fear of going down a wrong
    path or getting lost. If you take time to practice this workflow, it will soon
    become second nature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll introduce Playwright testing, and you’ll build a
    page to hold the `Birthday` component.
  prefs: []
  type: TYPE_NORMAL
