- en: Managing State with Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 管理状态
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Defining actions and action creators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义动作和动作创建器
- en: Defining reducer functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 Reducer 函数
- en: Creating a Redux store
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Redux 存储
- en: Binding action creators to the dispatch method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动作创建器绑定到分发方法
- en: Splitting and combining reducers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割和组合 Reducers
- en: Writing Redux store enhancers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Redux 存储增强器
- en: Time traveling with Redux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux 进行时间旅行
- en: Understanding Redux middleware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Redux 中间件
- en: Dealing with asynchronous data flow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步数据流
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB.
    You will also need to install Git, in order use the Git repository of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要有一个 IDE、Visual Studio Code、Node.js 和 MongoDB。您还需要安装 Git，以便使用本书的 Git 仓库。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，了解代码的实际应用：
- en: '[https://goo.gl/mU9AjR](https://goo.gl/mU9AjR)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/mU9AjR](https://goo.gl/mU9AjR)'
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Redux is a predictable state container for JavaScript applications. It allows
    developers to manage the state of their applications with ease. With Redux, the
    state is immutable. Thus, it is possible to go back and forth to the next or previous
    state of your application. Redux is bound to three core principles:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是 JavaScript 应用程序的可预测状态容器。它允许开发者轻松地管理他们应用程序的状态。使用 Redux，状态是不可变的。因此，您可以来回切换到应用程序的下一个或上一个状态。Redux
    绑定了三个核心原则：
- en: '**Single source of truth**: All the state of your application must be stored
    in a single object tree within one single store'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一事实来源**：您应用程序的所有状态都必须存储在单个对象树中，位于单个存储中'
- en: '**State is read-only**: You must not mutate the state tree. Only by dispatching
    an action can the state tree change'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态是只读的**：您不得修改状态树。只有通过分发一个动作，状态树才能改变'
- en: '**Changes are made with pure functions**: These are called reducers, which
    are functions that accept the previous state and an action and compute a new state.
    Reducers must never mutate the previous state but rather always return a new one'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改是通过纯函数进行的**：这些被称为 Reducers，它们是接受前一个状态和一个动作并计算新状态的函数。Reducers 必须永远不修改前一个状态，而应始终返回一个新的状态'
- en: 'Reducers work in a very similar way to how the `Array.prototype.reduce` function
    does. The `reduce` method executes a function for every item in an array against
    an accumulator to reduce it to a single value. For example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers 的工作方式与 `Array.prototype.reduce` 函数非常相似。`reduce` 方法对数组中的每个项目执行一个函数，针对累加器进行操作，以将其减少到单个值。例如：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The resulting value in variable `c` while reducing `a` and `b` against the
    `accumulator`, is `15` and the initial value is `0`. The reducer function here
    is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量 `c` 中，当对 `a` 和 `b` 进行累加器 `accumulator` 的减少操作时得到的结果是 `15`，初始值是 `0`。这里的 reducer
    函数是：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Redux reducers are written in a similar way and they are the most important
    concept of Redux. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Reducers 的编写方式类似，并且是 Redux 中最重要的概念。例如：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this chapter, we will focus on learning how to manage simple and complex
    state trees with Redux. You will learn as well how to deal with asynchronous data
    flows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于学习如何使用 Redux 管理简单和复杂的状态树。您还将学习如何处理异步数据流。
- en: Defining actions and action creators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作和动作创建器
- en: Reducers accept an `action` object that describes the action that is going to
    be performed and decides how to transform the state based on this `action` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers 接受一个描述将要执行的动作的 `action` 对象，并根据这个 `action` 对象决定如何根据状态转换状态。
- en: 'Actions are just plain objects and they have only one required property that
    needs to be present, the action-type. For instance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 动作只是普通的对象，并且它们只有一个必需的属性，即动作类型。例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also provide additional properties as well. For instance:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提供额外的属性。例如：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Actions creators are just functions that return actions, for instance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Actions creators 是返回动作的函数，例如：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will see how these simple Redux concepts can be applied
    with `Array.prototype.reduce` to decide how data should be accumulated or reduced.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将看到这些简单的 Redux 概念如何与 `Array.prototype.reduce` 结合使用，以决定数据应该如何累积或减少。
- en: We won't need the Redux library yet for this purpose.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前不需要Redux库来完成此目的。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build a small JavaScript application that will increase or decreased a counter
    based on the action provided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个小的JavaScript应用程序，该应用程序将根据提供的动作增加或减少计数器。
- en: Create a new file named `counter.js`
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`counter.js`的新文件
- en: 'Define action-types as constants:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作类型定义为常量：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define two action creators for generating two kinds of actions to `increment`
    and `decrement` the counter:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作创建器，用于生成两种类型的动作来`increment`和`decrement`计数器：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Initialize the initial accumulator to `0`, then reduce it by passing several
    actions. The reducer function will decide which kind of action to perform based
    on the action type:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将初始累加器初始化为`0`，然后通过传递几个动作来减少它。reducer函数将根据动作类型决定执行哪种类型的动作：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Log the resulting value:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录结果值：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the file
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Open a terminal and run:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Outputs: `8`'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出：`8`
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first action type that the reducer encounters is `increment(10)` which will
    increment the accumulator by `10`. Because the initial value of the accumulator
    is `0`, the next current value will be `10`
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遇到的第一个动作类型是`increment(10)`，这将使累加器增加`10`。因为累加器的初始值是`0`，下一个当前值将是`10`
- en: The second action type tells the reducer function to decrement the accumulator
    by `5`. Thus, the accumulator's value will be `5`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个动作类型告诉reducer函数将累加器减少`5`。因此，累加器的值将是`5`。
- en: The last action type tells the reducer function to increment the accumulator
    by `3`. As a result, the accumulator's value will be `8`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个动作类型告诉reducer函数将累加器增加`3`。因此，累加器的值将是`8`。
- en: Defining reducer functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义reducer函数
- en: 'Redux reducers are pure functions. That means, they have no side-effects. Given
    the same arguments, the reducer must always generate the same shape of state.
    Take for example the following reducer function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Redux reducer是纯函数。这意味着，它们没有副作用。给定相同的参数，reducer必须始终生成相同形状的状态。例如，以下reducer函数：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we execute this function providing the same arguments, the result will always
    be the same:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供相同的参数执行此函数，结果总是相同的：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, take into account that even though the returned values have the same
    shape, these are two different objects. For instance, comparing the above:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，尽管返回的值具有相同的形状，但这些是两个不同的对象。例如，比较上面的：
- en: '`console.log(a === b)` returns false.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(a === b)`返回`false`。'
- en: 'Impure reducer functions prevent your application state from being predictable
    and make difficult to reproduce the same state. For instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不纯净的reducer函数会阻止你的应用程序状态可预测，并使重现相同状态变得困难。例如：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we execute this function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此函数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, after executing the function for a second time after 2 seconds,
    we get a different result. To make it pure, you can consider re-writing the previously
    impure reducer as:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在2秒后执行函数第二次后，我们得到了不同的结果。为了使其纯净，你可以考虑重新编写之前的不纯净reducer，如下所示：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you can safely pass a time property inside your action to set the time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以安全地在你的动作中传递一个时间属性来设置时间：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach makes your state predictable and the state is easy to reproduce.
    For instance, you could re-create a scenario of how your application will act
    if you pass the `time` property for any time in morning or afternoon.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使你的状态可预测，并且状态易于重现。例如，你可以重新创建一个场景，即如果你在早上或下午的任何时间传递`time`属性，你的应用程序将如何行动。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Now that you understand the concept of how reducers work, in this recipe, you
    will build a small application that will act differently according to the state
    change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了reducer的工作原理，在这个菜谱中，你将构建一个应用程序，该应用程序将根据状态变化而采取不同的行动。
- en: For this purpose, you won't need to install or use the Redux library yet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，你目前不需要安装或使用Redux库。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Build an application that will remind you what kind of meal you should get
    according to your local time. Manage all the state of our application in a single
    object tree. Also provide a way to simulate what the application will display
    if it''s `00:00a.m` or `12:00p.m`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个应用程序，它会提醒你根据当地时间你应该吃什么类型的餐点。将我们应用程序的所有状态管理在一个单独的对象树中。还提供一种模拟如果时间是`00:00a.m`或`12:00p.m`时应用程序将显示什么的方式：
- en: Create a new file named `meal-time.html`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`meal-time.html`的新文件。
- en: 'Add the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside the script tag add the code defined in the next steps, starting on step
    4.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内添加以下步骤中定义的代码，从第4步开始。
- en: 'Define a variable `state` that will contain all the state tree and later the
    next state:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含所有状态树和稍后下一个状态的变量 `state`：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a reference to the HTML elements that we will use to display data or
    add event listeners:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引用 HTML 元素的引用，我们将使用它来显示数据或添加事件监听器：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define two action types:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作类型：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define an action creator for setting the kind of meal the user should have:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个设置用户应享用的餐类的动作创建器：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define an action creator for setting the time:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个设置时间的动作创建器：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define a reducer function that will compute a new state when an action is dispatched:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个当动作被分发时计算新状态的还原函数：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a function that we will call when the state changes, so we can update our
    view:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个当状态改变时我们将调用的函数，以便我们可以更新我们的视图：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define a dispatch function that will generate a new state tree by passing the
    current state and an action to the reducer. Then, it will call the `onChangeState`
    function to notify your application that the state has changed:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个将当前状态和动作传递给还原器以生成新状态树的分发函数。然后，它将调用 `onChangeState` 函数来通知应用程序状态已更改：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add an event listener for the button that will emulate that the time is `00:00a.m`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件监听器，模拟时间为 `00:00a.m`：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add an event listener for the button that will emulate that the time is `12:00p.m`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件监听器，模拟时间为 `12:00p.m`：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the script is running, dispatch an action with the current time for the
    view to update:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本开始运行，分发一个包含当前时间的动作以更新视图：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save the file.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试它...
- en: 'To see your previous work in action:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您之前的工作效果：
- en: Open the `meal-time.html` file in your web browser. You can do so by double-clicking
    on the file, or right-clicking on the file and choosing Open with....
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开 `meal-time.html` 文件。您可以通过双击文件或右键单击文件并选择“打开方式”来完成此操作。
- en: You should be able to see your current local time and a message stating what
    kind of meal you should have. For instance, if your local time is `20:42:35 GMT+0800
    (CST)`, you should see `Dinner time!`
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够看到您当前的本地区时以及一条消息，说明您应该享用什么类型的餐。例如，如果您的本地时间是 `20:42:35 GMT+0800 (CST)`，您应该看到
    `Dinner time!`
- en: Click on the button `"Let's pretend is 00:00:00"` to see what your application
    would display if the time was `00:00a.m`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮 `"Let's pretend is 00:00:00"` 来查看如果时间是 `00:00a.m`，您的应用程序会显示什么。
- en: The same way, click on the button `"Let's pretend is 12:00:00"` to see what
    your application would display if the time was `12:00p.m`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式，点击按钮 `"Let's pretend is 12:00:00"` 来查看如果时间是 `12:00p.m`，您的应用程序会显示什么。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can summarize our application like the following to understand how it works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下总结我们的应用程序以了解其工作原理：
- en: Action types `SET_MEAL` and `SET_TIME` were defined.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了 `SET_MEAL` 和 `SET_TIME` 动作类型。
- en: 'Two action creators were defined:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了两个动作创建器：
- en: '`setMeal` which generates an action with the `SET_MEAL` action type and a `kindOfMeal`
    property with the provided argument'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setMeal` 函数生成一个具有 `SET_MEAL` 操作类型和 `kindOfMeal` 属性的 `kindOfMeal` 提供的参数的动作'
- en: '`setTime` which generates an action with the `SET_TIME` action type and a `time`
    property with the provided argument'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setTime` 函数生成一个具有 `SET_TIME` 操作类型和 `time` 属性的 `time` 提供的参数的动作'
- en: 'A reducer function was defined:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个还原函数：
- en: For the action type `SET_MEAL`, computes a new state with a new `kindOfMeal`
    property
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `SET_MEAL` 动作类型，计算一个新的状态，包含新的 `kindOfMeal` 属性
- en: For the action type `SET_TIME`, computes a new state with a new `time` property
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `SET_TIME` 动作类型，计算一个新的状态，包含新的 `time` 属性
- en: We defined a function that will get called when the state tree changes. Inside
    the function, we updated the view according to the new state.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个当状态树改变时将被调用的函数。在函数内部，我们根据新的状态更新了视图。
- en: A `dispatch` function was defined that calls the reducer function providing
    the previous state and an action object to generate a new state.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个 `dispatch` 函数，它调用还原函数，提供前一个状态和一个动作对象以生成新状态。
- en: Creating a Redux store
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Redux 存储
- en: In the previous recipes, we have seen how to define reducers and actions. We
    have also seen how to create a dispatch function to dispatch actions for the reducers
    to update the state. The store is an object that provides a small API to put all
    of that together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们看到了如何定义还原器和动作。我们还看到了如何创建一个分发函数来分发动作以更新状态。存储是一个对象，它提供了一个小的 API 来将这些功能组合在一起。
- en: 'The redux module exposes the `createStore` method which we can use to create
    a store. It has the following signature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 模块公开了 `createStore` 方法，我们可以使用它来创建存储。它具有以下签名：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The two last arguments are optional. For example, creating a store with a single
    reducer could look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数是可选的。例如，创建一个包含单个还原器的存储库可能看起来像这样：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling `createStore` will expose four methods:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `createStore` 将公开四个方法：
- en: '`store.dispatch(action)`: Where action is an object that contains at least
    one property named `type` that specifies the action type'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.dispatch(action)`: 其中 action 是一个包含至少一个名为 `type` 的属性的对象，该属性指定了动作类型'
- en: '`store.getState()`: Returns the whole state tree'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.getState()`: 返回整个状态树'
- en: '`store.subscribe(listener)`: Where listener is a callback function that will
    get triggered whenever the state tree changes. Several listeners can be subscribed'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.subscribe(listener)`: 其中 listener 是一个回调函数，每当状态树发生变化时都会被触发。可以订阅多个监听器'
- en: '`store.replaceReducer(reducer)`: Replaces the current Reducer function with
    a new one'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.replaceReducer(reducer)`: 用新的还原器函数替换当前的还原器函数'
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will re-build the application that you built in the previous
    recipe. However, this time you will use Redux. Before you start, create a new
    `package.json` file with the following content:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将重新构建你在上一个菜谱中构建的应用程序。然而，这次你将使用 Redux。在你开始之前，创建一个包含以下内容的新的 `package.json`
    文件：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, install the dependencies by opening a terminal and running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, build a small ExpressJS server application whose sole purpose will be
    to serve an HTML file and the Redux module:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小型的 ExpressJS 服务器应用程序，其唯一目的是提供 HTML 文件和 Redux 模块
- en: Create a new file named `meal-time-server.js`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `meal-time-server.js` 的新文件
- en: 'Include the ExpressJS and `path` module and initialize a new ExpressJS Application:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 ExpressJS 和 `path` 模块，并初始化一个新的 ExpressJS 应用程序：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Serve the Redux library on `/lib` path. Make sure that the path points to the
    `node_modules` folder:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/lib` 路径上提供 Redux 库。确保路径指向 `node_modules` 文件夹：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Serve the client application on the root path `/`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根路径 `/` 上提供客户端应用程序
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listen for new connections on port `1337`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 `1337` 上监听新的连接：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save the file
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Now, build the client application using Redux following the next steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤使用 Redux 构建客户端应用程序：
- en: Create a new file named `meal-time-client.html`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `meal-time-client.html` 的新文件
- en: 'Add the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inside the script tag, add the code for the next steps, starting from step 4.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内，添加从第 4 步开始的代码
- en: 'Extract the `createStore` method from the Redux library:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Redux 库中提取 `createStore` 方法
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define the initial state of your application:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你应用程序的初始状态
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Keep a reference of the HTML DOM elements that will be used to display the
    state or interact with the application:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持对将用于显示状态或与应用程序交互的 HTML DOM 元素的引用
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define two action types:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作类型：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define two action creators:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作创建者：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the reducer that will transform the state when `SET_TIME` and/or `SET_TIME`
    action types are dispatched:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义当 `SET_TIME` 和/或 `SET_TIME` 动作类型被分派时将转换状态的还原器：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new Redux Store:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Redux 存储
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Subscribe a callback function to the changes of the store. Whenever the store
    changes this callback will be triggered and it will update the view according
    to the changes in the store:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个回调函数订阅到存储的变化。每当存储发生变化时，这个回调函数都会被触发，并根据存储中的变化更新视图：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add an event listener for the `click` event for our button that will dispatch
    the `SET_TIME` action type to set the time to `00:00:00`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮添加一个 `click` 事件的监听器，将 `SET_TIME` 动作类型分发给设置时间为 `00:00:00`
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add an event listener for the `click` event for our button that will dispatch
    the `SET_TIME` action type to set the time to `12:00:00`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮添加一个 `click` 事件的监听器，将 `SET_TIME` 动作类型分发给设置时间为 `12:00:00`
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the application is first started, dispatch an action to set the time to
    the current local time:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序首次启动时，分派一个动作来设置时间为当前本地区时：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Save the file
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来测试一下...
- en: 'To see the previous work in action:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作效果：
- en: 'Open a new terminal and run:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In your web browser, visit:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中，访问：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You should be able to see your current local time and a message stating what
    kind of meal you should have. For instance, if your local time is `20:42:35 GMT+0800
    (CST)`, you should see `Dinner time!`
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够看到你当前的本地区时以及一条消息，说明你应该吃什么样的餐。例如，如果你的本地时间是 `20:42:35 GMT+0800 (CST)`，你应该看到
    `Dinner time!`
- en: Click on the button `"Let's pretend is 00:00:00"` to see what your application
    would display if the time was `00:00a.m`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮 `"Let's pretend is 00:00:00"` 来查看如果时间是 `00:00a.m.`，你的应用程序会显示什么
- en: The same way, click on the `"Let's pretend is 12:00:00"` button to see what
    your application would display if the time was `12:00p.m`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，点击 `"Let's pretend is 12:00:00"` 按钮，看看如果时间是 `12:00p.m.`，您的应用程序会显示什么。
- en: There's more
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'You can use the ES6 spread operator instead of `Object.assign` to merge your
    previous state with the next one, for instance, we re-wrote the reducer function
    of the previous recipe:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ES6 扩展运算符来代替 `Object.assign` 来合并你的前一个状态和下一个状态，例如，我们重新编写了之前食谱中的 reducer
    函数：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We rewrote it as the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其重写为以下内容：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This could make the code more readable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使代码更易于阅读。
- en: Binding action creators to the dispatch method
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到 dispatch 方法
- en: 'Actions creators are just functions that generate action objects which can
    later be used to dispatch actions using the `dispatch` method. Take for example
    the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建者只是生成动作对象的函数，这些对象可以稍后用于使用 `dispatch` 方法分发动作。以下是一个例子：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Later, somewhere in your application, you can dispatch these actions using
    the `dispatch` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的应用程序的某个地方，您可以使用 `dispatch` 方法分发这些动作：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, as you can see, calling the `dispatch` method every time seems like
    a repeated and unnecessary step. You could simply wrap the action creators around
    the `dispatch` function itself like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如您所见，每次调用 `dispatch` 方法似乎是一个重复且不必要的步骤。您可以简单地将动作创建者包装在 `dispatch` 函数本身周围，如下所示：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Even though this seems like a good solution, there is a problem. It means,
    you would need to create the store first, then define your action creators binding
    them to the `dispatch` method. In addition, it would be difficult to maintain
    the action creators in a separate file since they depend on the `dispatch` method
    to be present. There is a solution provided by the Redux module, a helper method
    called `bindActionCreators` which accepts two arguments. The first argument is
    an object with keys, which represent the name of an action creator, and values,
    which represent a function that returns an action. The second argument is expected
    to be the `dispatch` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是一个不错的解决方案，但存在一个问题。这意味着，您需要首先创建存储，然后定义动作创建者并将它们绑定到 `dispatch` 方法。此外，由于它们依赖于
    `dispatch` 方法存在，因此在单独的文件中维护动作创建者将变得困难。Redux 模块提供了一个解决方案，这是一个名为 `bindActionCreators`
    的辅助方法，它接受两个参数。第一个参数是一个对象，其键代表动作创建者的名称，值代表返回动作的函数。第二个参数预期是 `dispatch` 函数：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This helper method will map all the action creators to the dispatch method.
    For instance, we could re-write the previous example as the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助方法将所有动作创建者映射到 dispatch 方法。例如，我们可以将之前的例子重写为以下内容：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, later somewhere in your application, you can call these methods without
    wrapping them around the `dispatch` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的应用程序的某个地方，您可以调用这些方法，而无需将它们包装在 `dispatch` 方法周围：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, our bound action creators look more like regular functions
    now. In fact, by destructuring the `actions` object, you can use only the methods
    you need. For instance:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的绑定动作创建者现在看起来更像常规函数。实际上，通过解构 `actions` 对象，您可以使用您需要的任何方法。例如：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, you can call them like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像这样调用它们：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will build a simple To-do application and you will use
    the concepts that you just have learned about binding action creators. First,
    create a new `package.json` file with the following content:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将构建一个简单的待办事项应用程序，并且您将使用您刚刚学到的绑定动作创建者的概念。首先，创建一个包含以下内容的 `package.json`
    文件：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To build your To-do application, for the purpose of this recipe, define only
    one action creator and use `bindActionCreators` to bind it to the `dispatch` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本食谱的目的，定义一个动作创建者，并使用 `bindActionCreators` 将其绑定到 `dispatch` 方法。
- en: 'First, build a small ExpressJS application that will serve the HTML file containing
    the To-do client application which we will build after:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小型的 ExpressJS 应用程序，该应用程序将提供包含我们之后将要构建的待办事项客户端应用程序的 HTML 文件：
- en: Create a new file named `bind-server.js`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `bind-server.js` 的新文件
- en: 'Add the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Save the file
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build the To-do application in an HTML file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 HTML 文件中构建待办事项应用程序：
- en: Create a new file named `bind-index.html`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `bind-index.html` 的新文件。
- en: 'Add the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Inside the script tag, add the code in the following steps, starting from step
    4.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内，按照以下步骤添加代码，从第 4 步开始。
- en: 'Keep a reference to the HTML DOM element that will be used in the application:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留将用于应用程序的 HTML DOM 元素的引用：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define the initial state of your application:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义应用程序的初始状态：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define an action type:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个动作类型：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define an action creator:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个动作创建器：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define a reducer function that will add a new item to the list whenever the
    `ADD_ITEM` action type is dispatched. The state will keep only 5 items:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个还原函数，每当派发 `ADD_ITEM` 动作类型时，都会向列表中添加一个新项目。状态将只保留 5 个项目：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a store and bind the `dispatch` function to the action creator:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储库并将 `dispatch` 函数绑定到动作创建器：
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Subscribe to the store and whenever the state changes add a new item to the
    list. If an item was already defined, we will re-use it instead of creating a
    new one:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅存储库，每当状态改变时，向列表中添加一个新项目。如果项目已经定义，我们将重用它而不是创建一个新的：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Add an event listener to the form for the `submit` event. This way, we can
    get the input value and dispatch an action:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件监听器添加到表单的 `submit` 事件上。这样，我们就可以获取输入值并派发一个动作：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Save the file.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试一下...
- en: 'To see the previous work in action:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到之前的工作效果：
- en: 'Open a new Terminal and run:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In your browser, visit:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，访问：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Type something in the input box and press Enter. A new item should appear in
    the list.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入框中输入一些内容并按 Enter。列表中应该会出现一个新项目。
- en: Try to add more than five items to the list. The last one displayed will be
    removed and only five items are kept on the view.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试向列表中添加超过五个项目。最后显示的项目将被移除，并且只保留五个项目在视图中。
- en: Splitting and combining reducers
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分和组合还原器
- en: As your application grows, you probably wouldn't want to write all the logic
    for how the state of your application needs to be transformed in a simple reducer
    function. What you would probably want is to write smaller reducers that specialize
    in managing independent parts of the state.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，你可能不希望在一个简单的还原函数中编写所有关于如何转换应用程序状态的逻辑。你可能想要编写更小的还原器，这些还原器专门管理状态的不同部分。
- en: 'Take for example the following reducer function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下还原函数为例：
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You have two properties that manage the state of two different parts of an
    application. One manages the state of a Todo, list while the other manages the
    Chat messages. You could split this reducer into two reducer functions, where
    each manages one slice of the state, for instance:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个属性管理应用程序两个不同部分的状态。一个管理 Todo 列表的状态，另一个管理聊天消息。你可以将这个还原器拆分为两个还原函数，其中每个管理状态的一部分，例如：
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However, because `createStore` method accepts only one reducer as the first
    argument, you would need to combine them into a single reducer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为 `createStore` 方法只接受一个还原器作为第一个参数，所以你需要将它们组合成一个单一的还原器：
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this way, we are able to split our reducers into smaller reducers that specialize
    in managing only one slice of the state, and later combine them together into
    a single reducer function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们能够将我们的还原器拆分为更小的还原器，这些还原器专门管理状态的一小部分，然后稍后将其组合成一个单一的还原器函数。
- en: 'Redux provides a helper method named `combineReducers` that allows you to combine
    reducers in a similar way to what we just did but without having to repeat a lot
    of code; for instance, we could rewrite the previous way of combining reducers
    like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 提供了一个名为 `combineReducers` 的辅助方法，它允许你以与我们刚才做的方式类似的方式组合还原器，但不需要重复很多代码；例如，我们可以像这样重写之前组合还原器的方式：
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `combineReducers` method is a *higher-order reducer* function. It accepts
    an object mapping specifies keys to a certain slice of the state managed by a
    specific `reducer` function and returns a new reducer function. If you run the
    following code, for instance:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineReducers` 方法是一个 *高阶还原器* 函数。它接受一个对象映射，指定键到由特定 `reducer` 函数管理的特定状态的一部分，并返回一个新的还原器函数。例如，如果你运行以下代码：'
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You will see that the generated shape of the state looks like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到生成的状态形状如下所示：
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can try as well if our combined reducers are working and managing only the
    part of the state assigned to them. For instance:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试如果我们的组合还原器正在工作并且只管理分配给它们的州的一部分。例如：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should display the generated state as the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该显示生成的状态如下所示：
- en: '[PRE82]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This shows that each reducer is managing only the slice of the state assigned
    to them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明每个还原器只管理分配给它们的州的一部分。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will recreate the To-do application as in the pervious
    recipe. However, you will add other functionalities such as remove and toggle
    a To-do item. You will define other state of your application that will be managed
    by separate reducer functions. First, create a new `package.json` file with the
    following content:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将重新创建与之前菜谱中相同的To-do应用程序。然而，你将添加其他功能，如删除和切换To-do项。你将定义其他由单独的reducer函数管理的应用程序状态。首先，创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE84]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, build a small ExpressJS server application that will serve the client
    application and the Redux library installed in `node_modules`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小型的ExpressJS服务器应用程序，该应用程序将提供客户端应用程序和安装在`node_modules`中的Redux库：
- en: Create a new file named `todo-time.js`
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`todo-time.js`的新文件：
- en: 'Add the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Save the file
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build the To-do client application. Also include a separate reducer to
    manage state for the current local time and a random lucky number generator:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建To-do客户端应用程序。还包括一个单独的reducer来管理当前本地时间和随机幸运数字生成器的状态：
- en: Create a new file named `todo-time.html`
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`todo-time.html`的新文件：
- en: 'Add the following HTML code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下HTML代码：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Inside the script tag add the JavaScript code following the next steps, starting
    from step 4
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内，按照以下步骤添加JavaScript代码，从第4步开始：
- en: 'Keep a reference of the HTML elements that we will use to display data or interact
    with the application:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留我们将用于显示数据或与应用程序交互的HTML元素的引用：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Get the `createStore` method and helper methods from the Redux library:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Redux库中获取`createStore`方法和辅助方法：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set action types:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置动作类型：
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Define action creators:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作创建者：
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define a reducer function to manage the slice of state that keeps the time:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理保持时间的状态片段：
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define a reducer function to manage the slice of state that keeps a lucky number
    that will be generated every time the user loads your application:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理每次用户加载你的应用程序时生成的幸运数字的状态片段：
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Define a reducer function to manage the slice of state that keeps an array
    of To-do items:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个reducer函数来管理保持To-do项数组的州片段：
- en: '[PRE93]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Combine all reducers into a single one:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有reducers合并为一个：
- en: '[PRE94]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a store:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个store：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Bind all actions creators to the `dispatch` method of the store:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有动作创建者绑定到store的`dispatch`方法：
- en: '[PRE96]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Subscribe a listener to the store that will update the HTML element, that will
    hold the time, whenever the state changes:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新持有时间的HTML元素：
- en: '[PRE97]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Subscribe a listener to the store that will update the HTML element, that will
    display a lucky number, whenever the state changes:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新显示幸运数字的HTML元素：
- en: '[PRE98]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Subscribe a listener to the store that will update the HTML element that will
    display the list of To-do items, whenever the state changes. Set the attribute
    `draggable` for the `li` HTML elements to allow the user to drag and drop the
    items on the view:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听器到store，当状态改变时更新显示To-do项列表的HTML元素。将`li`HTML元素的属性`draggable`设置为允许用户在视图中拖放项目：
- en: '[PRE99]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Add an event listener for the `click` event on the list HTML element that will
    toggle a To-do item''s `completed` property whenever the item is clicked:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表HTML元素上添加一个`click`事件监听器，当项目被点击时切换To-do项的`completed`属性：
- en: '[PRE100]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add an event listener for the `drag` event on the list HTML element that will
    remove a To-do Item when this one is dragged outside of the list:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表HTML元素上添加一个`drag`事件监听器，当项目被拖出列表外时删除To-do项：
- en: '[PRE101]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add an event listener for the `submit` event on the form that contains an input
    HTML element that will dispatch a new action to add a new To-do item:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含输入HTML元素的表上添加一个`submit`事件监听器，该监听器将派发一个新动作来添加一个新的To-do项：
- en: '[PRE102]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When the page loads for the first time, dispatch an action to set a lucky number
    and define a function that will get triggered every second to update the current
    time in the state of the application:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面第一次加载时，派发一个动作来设置幸运数字，并定义一个每秒被触发以更新应用程序状态中的当前时间的函数：
- en: '[PRE103]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Save the file
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试一下...
- en: 'To see the previous work in action:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前工作的实际效果：
- en: 'Open a new Terminal and run:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE104]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In your browser, visit:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，访问：
- en: '[PRE105]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Introduce something in the input box and press enter. A new item should appear
    in the list.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入框中输入一些内容并按回车键。一个新的项目应该出现在列表中。
- en: Click on one of the items that you have added to mark it as completed.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你添加的其中一个项目以标记它为已完成。
- en: Click once again on one of the items marked as completed to mark it as not completed.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击标记为已完成的其中一个项目以标记它为未完成。
- en: Click and drag one of the items outside of the list to remove it from the To-do
    list.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动列表外的其中一个项目以从待办事项列表中移除它。
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Three reducer functions were defined to independently manage each slice of
    the state that has the following shape:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了三个reducer函数，以独立管理具有以下形状的每个状态切片：
- en: '[PRE106]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We used the `combineReducers` helper method from the Redux library to combine
    those three reducers into a single one
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了Redux库中的`combineReducers`辅助方法将这三个reducer组合成一个。
- en: Then, a store was created providing the combined reducer function
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建了一个提供组合reducer函数的存储。
- en: For convenience, we subscribed three listener functions that get triggered whenever
    the state changes to update the HTML elements used to display the data from the
    state
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们订阅了三个监听函数，每当状态改变时，这些函数就会被触发以更新用于显示状态数据的HTML元素。
- en: 'We also defined three event listeners: one to detect when a user submits a
    form that contains an input HTML element to add a new To-do item, another to detect
    when the user clicks on a To-do item displayed on the screen to toggle its state
    from not completed to completed or vice versa, and finally one event listener
    to detect when the user drags an element from the list to dispatch an action to
    remove it from the list of To-do items'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了三个事件监听器：一个用于检测用户提交包含用于添加新待办事项的输入HTML元素的表单，另一个用于检测用户点击屏幕上显示的待办事项以切换其状态从未完成到完成或反之，最后一个是用于检测用户将元素从列表中拖动以从待办事项列表中移除的事件监听器
- en: Writing Redux store enhancers
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Redux存储增强器
- en: 'A Redux store enhancer is a higher-order function that takes a store creator
    function and returns a new enhanced store creator function. The `createStore`
    method is a store creator which has the following signature:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Redux存储增强器是一个高阶函数，它接受一个存储创建函数并返回一个新的增强存储创建函数。`createStore`方法是一个存储创建函数，其签名如下：
- en: '[PRE107]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'While a store enhancer function has the following signature:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 而存储增强器函数的签名如下：
- en: '[PRE108]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It may look a bit difficult to understand now, but you don't really have to
    worry if you don't get it at first because you will probably never need to write
    a store enhancer. The purpose of this recipe was simply to help you to understand
    their purpose in a very simple way.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来可能有点难以理解，但如果你一开始不理解，其实不必担心，因为你可能永远不需要编写存储增强器。这个菜谱的目的是简单地帮助你以非常简单的方式理解它们的目的。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will create a store enhancer to expand the functionality
    of Redux by allowing the definition of reducer functions in a `Map` JavaScript
    native object. First, create a new `package.json` file with the following content:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将创建一个存储增强器，通过允许在`Map`JavaScript原生对象中定义reducer函数来扩展Redux的功能。首先，创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE109]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE110]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Remember that `createStore` accepts a single reducer function as the first
    argument. We write a store enhancer to allow the `createStore` method to accept
    a `Map` object containing key-value pairs, where key is the property or slice
    of state that will be managed, and value is a `reducer` function. Then, define
    two reducer functions using a `Map` object to handle two slices of the state,
    one for a counter and the other for setting the current time:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`createStore`接受一个reducer函数作为第一个参数。我们编写一个存储增强器，允许`createStore`方法接受一个包含键值对的`Map`对象，其中键是将被管理的属性或状态切片，值是一个`reducer`函数。然后，使用`Map`对象定义两个reducer函数来处理两个状态切片，一个用于计数器，另一个用于设置当前时间：
- en: Create a new file named `map-store.js`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`map-store.js`的新文件。
- en: 'Include the Redux library:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含Redux库：
- en: '[PRE111]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Define a store enhancer function that will allow the `createStore` method to
    accept a `Map` object as an argument. It will go through each key-value pair of
    the `Map` and add it to an object which will then be used to combine the reducers
    using the `combineReducers` method:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个存储增强器函数，它将允许`createStore`方法接受一个`Map`对象作为参数。它将遍历`Map`中的每个键值对，并将它们添加到一个对象中，然后使用`combineReducers`方法将这个对象与reducer组合：
- en: '[PRE112]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Define actions types:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作类型：
- en: '[PRE113]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Define actions creators:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作创建者：
- en: '[PRE114]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Define a `map` constant that will contain an instance of `Map`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`Map`实例的`map`常量：
- en: '[PRE115]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add a new reducer function to the `map` object with a key `counter`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `map` 对象中添加一个新的还原函数，键为 `counter`：
- en: '[PRE116]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Add another reducer function to the `map` object with a key `time`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `map` 对象中添加另一个名为 `time` 的还原函数：
- en: '[PRE117]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create a new store providing the `map` as the first argument and the **store
    enhancer** as the second argument to extend the functionality of the `createStore`
    method:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储，将 `map` 作为第一个参数，将 **存储增强器** 作为第二个参数提供给 `createStore` 方法以扩展其功能：
- en: '[PRE118]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Bind the previously defined actions creators to the `dispatch` method of the
    store:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将先前定义的动作创建者绑定到存储的 `dispatch` 方法：
- en: '[PRE119]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To test the code in NodeJS, use the `setInterval` global method to repeatedly
    call a function every second. It will first dispatch an action to set the current
    time, then, based on the criteria, it will decide if to increment or decrement
    the counter. After, pretty print in the terminal the current value of the store:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 NodeJS 中测试代码，使用 `setInterval` 全局方法每秒重复调用一个函数。它将首先派发一个动作来设置当前时间，然后，根据标准，它将决定是否增加或减少计数器。之后，在终端中漂亮地打印存储的当前值：
- en: '[PRE120]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Save the file.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Open a new Terminal and run:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE121]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The current state would be displayed every second having this shape:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前状态将每秒显示一次，其形状如下：
- en: '[PRE122]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The enhancer composes the store creator into a new one. For instance, the following
    line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 增强器将存储创建者组合成一个新的。例如，以下行：
- en: '[PRE123]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Could be written as:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成：
- en: '[PRE124]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Which actually, in a way, wraps the original `createStore` method into another
    `createStore` method.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在某种程度上，它将原始的 `createStore` 方法包装在另一个 `createStore` 方法中。
- en: 'Composition can be explained as a set of functions that are called accepting
    the result argument of the previous function. For instance:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 组合可以解释为一组函数，这些函数接受前一个函数的结果参数。例如：
- en: '[PRE125]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This composes functions `f`, `g`, and `h` from right to left into a single
    function `c`. That means, we could write the previous line of code also like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从右到左将函数 `f`、`g` 和 `h` 组合成一个单独的函数 `c`。这意味着，我们也可以像这样编写前面的代码行：
- en: '[PRE126]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Here `_createStore` is the result of composing `createStore` and your store
    enhancer function.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `_createStore` 是组合 `createStore` 和你的存储增强器函数的结果。
- en: Time traveling with Redux
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 进行时间旅行
- en: 'Even though, you may probably never need to write store enhancers, there is
    one special that you may find very useful for debugging your Redux powered applications
    to time travel through the state of your application. You can enable time traveling
    on your application by simple installing **Redux DevTools Extension** (for Chrome
    and Firefox): [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension).'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能永远不需要编写存储增强器，但有一个特殊的增强器你可能发现对调试你的 Redux 驱动的应用程序进行时间旅行非常有用。你可以通过简单地安装 **Redux
    DevTools 扩展**（适用于 Chrome 和 Firefox）来在你的应用程序上启用时间旅行：[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)。
- en: Getting ready
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'In this recipe, we will see an example of how to take advanced of this feature
    and analyze how the state of your application has changed over the time that was
    running on the browser. First, create a new `package.json` file with the following
    content:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到一个如何充分利用这个功能的例子，并分析你的应用程序状态是如何随时间在浏览器上运行而变化的。首先，创建一个包含以下内容的新的 `package.json`
    文件：
- en: '[PRE127]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行来安装依赖项：
- en: '[PRE128]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Make sure to have installed the Redux DevTools Extension in your web browser.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已安装 Redux DevTools 扩展到你的网络浏览器中。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Build a counter application that will randomly increment or decrement the initial
    specified counter 10 times when the application is run on the browser. However,
    because it happens fast, the user won't be able to notice that the state has actually
    changed 10 times since the application started. We will use the Redux DevTools
    Extension to navigate and analyze how the state has changed over time.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个计数器应用程序，当应用程序在浏览器上运行时，将随机增加或减少初始指定的计数器 10 次。然而，因为发生得很快，用户将无法注意到自应用程序开始以来状态实际上已经改变了
    10 次。我们将使用 Redux DevTools 扩展来导航和分析状态是如何随时间变化的。
- en: 'First, build a small ExpressJS server application that will serve the client
    application and the Redux library installed in `node_modules`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一个小型的 ExpressJS 服务器应用程序，该应用程序将提供客户端应用程序和安装在 `node_modules` 中的 Redux 库：
- en: Create a new file named `time-travel.js`
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `time-travel.js` 的新文件
- en: 'Add the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE129]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Save the file
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'Next, build your counter, Redux powered application, with time travel capabilities:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建你的计数器，Redux 驱动的应用程序，具有时间旅行功能：
- en: Create a new file named `time-travel.html`
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `time-travel.html` 的新文件
- en: 'Add the following HTML code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 HTML 代码：
- en: '[PRE130]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Inside the script tag add the JavaScript code that follows the next steps, starting
    from step 4
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本标签内添加以下 JavaScript 代码，从第 4 步开始：
- en: 'Keep a reference to the `span` HTML element that will display the current value
    of the counter whenever the state changes:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留一个对 `span` HTML 元素的引用，该元素将在状态更改时显示计数器的当前值：
- en: '[PRE131]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Get the `createStore` method and `bindActionCreators` method from the Redux
    library:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Redux 库中获取 `createStore` 方法 和 `bindActionCreators` 方法：
- en: '[PRE132]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Define two action types:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作类型：
- en: '[PRE133]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Define two action creators:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个动作创建者：
- en: '[PRE134]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Define a reducer function that will transform the state according to the given
    action type:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个根据给定动作类型转换状态的 reducer 函数：
- en: '[PRE135]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Create a new store providing a store enhancer function that will be available
    on the `window` object when the Redux DevTools extension is installed:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 store，提供一个 store enhancer 函数，当 Redux DevTools 扩展安装时，该函数将在 `window` 对象上可用：
- en: '[PRE136]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Bind the action creators to the `dispatch` method of the store:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到 store 的 `dispatch` 方法：
- en: '[PRE137]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Subscribe a listener function to the store that will update the `span` HTML
    element whenever the state changes:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅一个监听函数到 store，当状态更改时，它会更新 `span` HTML 元素：
- en: '[PRE138]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Let''s create a `for` loop that will update increment or decrement the counter
    randomly 10 times when the application is run:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `for` 循环，当应用程序运行时，它会随机更新计数器 10 次：
- en: '[PRE139]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Save the file
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: Let's test it...
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试一下...
- en: 'To see the previous work in action:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前的工作效果：
- en: 'Open a new Terminal and run:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE140]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In your Browser, visit:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中访问：
- en: '[PRE141]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Open Developer Tools of your Browser and look for the Redux tab. You should
    see a tab like this:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器中的开发者工具并查找 Redux 选项卡。你应该看到一个像这样的标签：
- en: '![](img/d6635f01-f201-44b1-91ba-76ee735152da.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6635f01-f201-44b1-91ba-76ee735152da.png)'
- en: Redux DevTools – Tab Window
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – 标签窗口
- en: 'The slider allows you to move from the last state to the very first state of
    your application. Try moving the slider to a different position:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑块允许你从最后一个状态移动到应用程序的第一个状态。尝试将滑块移动到不同的位置：
- en: '![](img/64146aed-2c98-42af-bfef-96fa08b2d098.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64146aed-2c98-42af-bfef-96fa08b2d098.png)'
- en: Redux DevTools – Moving Slider
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – 滑块移动
- en: While moving the slider, you would be able to see in your browser the counters
    initial value and how it changed those ten times in the for loop
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你移动滑块时，你会在浏览器中看到计数器的初始值以及它在 for 循环中改变了十次：
- en: There's more
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: '**Redux DevTools** has some features that you will probably find amazing and
    helpful for debugging and managing the state of your application. In fact, if
    you followed the previous recipes, I suggest you go back to the projects we wrote
    and enable this enhancer and try to experiment with Redux DevTools.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux DevTools** 有一些你可能觉得非常神奇且对调试和管理应用程序状态非常有用的功能。实际上，如果你遵循了之前的食谱，我建议你回到我们编写的项目，启用此增强器并尝试使用
    Redux DevTools 进行实验。'
- en: 'One of many features of Redux DevTools is the Log monitor, which displays in
    chronological order which action was dispatched and the resulting value of transforming
    the state:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools 的许多功能之一是日志监控器，它按时间顺序显示哪个动作被分发以及转换状态的结果：
- en: '![](img/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png)'
- en: Redux DevTools – Log Monitor
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Redux DevTools – 日志监控器
- en: Understanding Redux middleware
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Redux 中间件
- en: Probably the easiest and best way of extending the Redux functionality is by
    using middleware.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Redux 功能最简单、最好的方法之一是使用中间件。
- en: 'There is a store enhancer function that comes in the Redux library named `applyMiddleware`
    and allows you define one or multiple middleware functions. The way middleware
    works in Redux is simple, it allows you to wrap the `dispatch` method of the store
    to extend its functionality. The same way as store enhancer functions, middleware
    is composable and has the following signature:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 库中有一个名为 `applyMiddleware` 的 store enhancer 函数，允许你定义一个或多个中间件函数。Redux 中中间件的工作方式很简单，它允许你包装
    store 的 `dispatch` 方法来扩展其功能。与 store enhancer 函数一样，中间件是可组合的，并且具有以下签名：
- en: '[PRE142]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Here, `API` is an object containing the `dispatch` and `getState` methods from
    the store, destructuring the `API`, the signature looks like this:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`API` 是一个包含从 store 中获取的 `dispatch` 和 `getState` 方法的对象，解构 `API`，其签名如下：
- en: '[PRE143]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Let''s analyze how it works:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析它是如何工作的：
- en: 'The `applyMiddleware` function receives one or more middleware functions as
    arguments. For example:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`applyMiddleware` 函数接收一个或多个中间件函数作为参数。例如：'
- en: '[PRE144]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Each middleware function is kept internally as an `Array`. Then, internally
    using the `Array.prototype.map` method, the array maps each middleware function
    by calling itself providing the middleware `API` object which contains the `dispatch`
    and `getState` methods of the store. Similar to this:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个中间件函数都作为 `Array` 内部保持。然后，内部使用 `Array.prototype.map` 方法，该数组通过调用自身来映射每个中间件函数，提供包含存储的
    `dispatch` 和 `getState` 方法的中间件 `API` 对象。类似于以下：
- en: '[PRE145]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then, by composing all the middleware functions, it computes a new value for
    the `dispatch` method providing the `next` argument. In the very first middleware
    that is executed, the `next` argument refers to the original `dispatch` method
    before any middleware was applied. For instance, if applying three middleware
    functions, the new computed dispatch method''s signature would be:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过组合所有中间件函数，它为 `dispatch` 方法提供一个带有 `next` 参数的新值。在执行的第一个中间件中，`next` 参数指的是应用任何中间件之前的原始
    `dispatch` 方法。例如，如果应用了三个中间件函数，新的计算出的分发方法的签名将是：
- en: '[PRE146]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Which means that a middleware function can interrupt the chain and prevent a
    certain action from being dispatched if the `next(action)` method is not called
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着如果未调用 `next(action)` 方法，中间件函数可以中断链路并阻止某些动作被分发。
- en: The dispatch method from the middleware `API` object, allows you to call the
    dispatch method of the store with the previously applied middleware. That means,
    if you are not careful while using this method, you may create an infinite loop
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件 `API` 对象中的分发方法允许你调用存储的分发方法，该方法带有之前应用的中件。这意味着，如果你在使用此方法时不够小心，你可能会创建一个无限循环。
- en: Understanding how it works internally may not be so simple at first, but I assure
    you that you will get it soon.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 最初理解其内部工作原理可能并不简单，但我向你保证，你很快就会明白。
- en: Getting ready
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will write a middleware function that will warn the user
    when dispatching an action type that has not been defined. First, create a new
    `package.json` file with the following content:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将编写一个中间件函数，当分发未定义的动作类型时，它会警告用户。首先，创建一个包含以下内容的新的 `package.json` 文件：
- en: '[PRE147]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Then, install the dependencies by opening a Terminal and running:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE148]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: How to do it...
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Redux doesn''t warn you or display errors when an action type, that was never
    defined within your reducers, is used. Build a NodeJS application that will use
    Redux to manage its state. Focus on writing a middleware function that will check
    that the dispatched actions types are defined or else throw an error:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在您的 reducer 中从未定义的动作类型时，Redux 不会警告您或显示错误。构建一个使用 Redux 来管理其状态的 NodeJS 应用程序。专注于编写一个中间件函数，该函数将检查分发动作的类型是否已定义，否则抛出错误：
- en: Create a new file named `type-check-redux.js`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `type-check-redux.js` 的新文件。
- en: 'Include the Redux library:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 Redux 库：
- en: '[PRE149]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Define an object containing the allowed action types:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含允许的动作类型的对象：
- en: '[PRE150]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Create a dummy reducer function that returns its original state whichever action
    type is called. We don''t need it for the purpose of this recipe:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟的 reducer 函数，无论调用哪种动作类型，它都返回其原始状态。我们不需要它来完成这个菜谱的目的：
- en: '[PRE151]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Define a middleware function that will intercept every action that is being
    dispatched and check whether the action type exists in the `TYPE` object. If the
    action exists allow the action to be dispatched, or otherwise, throw an error
    and inform the user that an invalid action type was dispatched. Additionally,
    let''s provide the user, as part of the error message, information about which
    valid types are allowed:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个中间件函数，该函数将拦截正在分发的每个动作并检查动作类型是否存在于 `TYPE` 对象中。如果动作存在，允许分发动作，否则抛出错误并通知用户已分发无效的动作类型。此外，让我们在错误消息中为用户提供有关哪些有效类型允许的信息：
- en: '[PRE152]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create a store and apply the defined middleware function:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储并应用定义的中间件函数：
- en: '[PRE153]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Dispatch two action types. The first action type is valid, and it exists in
    the `TYPE` object. However, the second one is an action type that was never defined:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发两个动作类型。第一个动作类型是有效的，它存在于 `TYPE` 对象中。然而，第二个是一个从未定义过的动作类型：
- en: '[PRE154]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Save the file.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试它...
- en: 'First, open a new Terminal and run:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端并运行：
- en: '[PRE155]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The Terminal output should display an error similar to this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 终端输出应显示类似于以下错误：
- en: '[PRE156]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In this example, the stack trace tells us that the error happened on line `18`,
    which points to our middleware function. However, the next one points to line
    `33`, `store.dispatch({ type: ''MISTAKE'' })`, which is a good thing because it
    can help you track exactly where certain actions are dispatched that were never
    defined.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，堆栈跟踪告诉我们错误发生在第`18`行，这指向了我们的中间件函数。然而，下一个错误指向第`33`行，`store.dispatch({
    type: ''MISTAKE'' })`，这是一个好事，因为它可以帮助你追踪某些从未定义的动作的确切分发位置。'
- en: How it works...
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's pretty simple, the middleware function checks the action type, of the action
    being dispatched, to see if it exists as a property of the `TYPE` object constant.
    If it exists, then the middleware passes control to the next middleware in the
    chain. However, in our case, there is no next middleware, so the control is passed
    to the original dispatch method of the store that will apply the reducer and transform
    the state. On the other side, if the action type was not defined, the middleware
    function interrupts the middleware chain by not calling the `next` function and
    by throwing an error.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，中间件函数检查正在分发的动作的类型，看它是否是`TYPE`对象常量的属性。如果是，那么中间件将控制权传递给链中的下一个中间件。然而，在我们的情况下，没有下一个中间件，所以控制权传递给了存储的原始`dispatch`方法，它将应用reducer并转换状态。另一方面，如果动作类型未定义，中间件函数通过不调用`next`函数并抛出错误来中断中间件链。
- en: Dealing with asynchronous data flow
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步数据流
- en: By default, Redux doesn't handle asynchronous data flow. There are several libraries
    out there that can help you with these tasks. However, for the purpose of this
    chapter, we will build our own implementation using middleware functions to give
    the `dispatch` method the ability to dispatch and handle asynchronous data flow.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Redux不处理异步数据流。市面上有多个库可以帮助你处理这些任务。然而，为了本章的目的，我们将使用中间件函数构建自己的实现，以赋予`dispatch`方法分发和处理异步数据流的能力。
- en: Getting ready
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, you will build an ExpressJS application with a very small API
    to test your application when making HTTP requests and dealing with asynchronous
    data flow and errors. First, create a new `package.json` file with the following
    content:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将构建一个ExpressJS应用程序，它有一个非常小的API，用于在发送HTTP请求和处理异步数据流及错误时测试你的应用程序。首先，创建一个包含以下内容的新的`package.json`文件：
- en: '[PRE157]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Then install the dependencies by opening a Terminal and running:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过打开终端并运行以下命令来安装依赖项：
- en: '[PRE158]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: How to do it...
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Build a simple RESTful API server that will have two endpoints or answer to
    paths `/time` and `/date` when a GET request is made. However, on `/date` path,
    we will pretend that there is an internal error and make the request fail in order
    to see how to handle errors in asynchronous requests as well:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个简单的RESTful API服务器，该服务器在接收到GET请求时将有两个端点或响应路径`/time`和`/date`。然而，在`/date`路径上，我们将假装存在内部错误，使请求失败，以便了解如何处理异步请求中的错误：
- en: Create a new file named `api-server.js`
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`api-server.js`的新文件
- en: 'Include the ExpressJS library and initialize a new ExpressJS application:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含ExpressJS库并初始化一个新的ExpressJS应用程序：
- en: '[PRE159]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'For `/time` path, simulates a delay of `2s` before sending a response:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`/time`路径，在发送响应之前模拟`2s`的延迟：
- en: '[PRE160]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'For `/date` path, simulates a delay of `2s` before sending a failed response:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`/date`路径，在发送失败响应之前模拟`2s`的延迟：
- en: '[PRE161]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Listen on port `1337` for new connections
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听`1337`端口以接收新的连接
- en: '[PRE162]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Save the file
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件
- en: 'As for the client, build a NodeJS application using Redux that will dispatch
    synchronous and asynchronous actions. Write a middleware function to allow the
    dispatch method to handle asynchronous actions:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，使用Redux构建一个NodeJS应用程序，该应用程序将分发同步和异步动作。编写一个中间件函数，允许`dispatch`方法处理异步动作：
- en: Create a new file named `async-redux.js`
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`async-redux.js`的新文件
- en: 'Include the `node-fetch` and Redux libraries:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含`node-fetch`和Redux库：
- en: '[PRE163]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Define three kinds of status. Each status represents the state of an asynchronous
    operation:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三种状态。每种状态代表异步操作的状态：
- en: '[PRE164]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Define two action types:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两种动作类型：
- en: '[PRE165]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Define action creators. Notice that the value property is an asynchronous function
    in the first two action creators. Your, later defined, middleware function will
    be responsible for making Redux understand these actions:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义动作创建者。注意，前两个动作创建者的值属性是异步函数。你稍后定义的中间件函数将负责让Redux理解这些动作：
- en: '[PRE166]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Define a common function for setting values from an action object that will
    be used in your reducer:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于从动作对象设置值的通用函数，该函数将在你的reducer中使用：
- en: '[PRE167]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Define the initial state of your application:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你应用程序的初始状态：
- en: '[PRE168]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Define a reducer function. Notice that it is only one reducer that handles
    two slices of the state, the `time` and the `date`:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个还原函数。注意，只有一个还原函数处理两个状态片段，即`time`和`date`：
- en: '[PRE169]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Define a middleware function that will check whether a dispatched action type
    has a function as the `value` property. If that is so, assume that the `value`
    property is an async function. First, we dispatch an action to set the status
    as `PENDING`. Then, when the async function is resolved, we dispatch another action
    to set the status as `RESOLVED` or in case of an error as `REJECTED`:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个中间件函数，该函数将检查派发的动作类型是否具有作为`value`属性的函数。如果是这样，假设`value`属性是一个异步函数。首先，我们派发一个动作将状态设置为`PENDING`。然后，当异步函数解决时，我们派发另一个动作将状态设置为`RESOLVED`或错误情况下设置为`REJECTED`：
- en: '[PRE170]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Create a new store and apply your defined middleware function to extend the
    functionality of the `dispatch` method:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储并将你定义的中间件函数应用到扩展`dispatch`方法的功能：
- en: '[PRE171]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Bind action creators to the `dispatch` method of the store:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作创建者绑定到存储的`dispatch`方法：
- en: '[PRE172]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Subscribe a function listener to the store and display in terminal the state
    tree, as a JSON string, every time there is a change in the state:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个函数监听器订阅到存储中，并在终端中显示状态树，作为JSON字符串，每次状态有变化时：
- en: '[PRE173]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Dispatch a synchronous action to set the time:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发一个同步动作来设置时间：
- en: '[PRE174]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Dispatch an asynchronous action to fetch and set the time:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发一个异步动作来获取并设置时间：
- en: '[PRE175]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Dispatch another asynchronous action to fetch and try to set the date. Remember
    that this operation is supposed to fail and it''s intentional:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发另一个异步动作来获取并尝试设置日期。请记住，这个操作应该失败，这是故意的：
- en: '[PRE176]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Save the file.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Let's test it...
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们测试一下...
- en: 'To see your previous work in action:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的先前工作效果：
- en: 'Open a new terminal and run:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行：
- en: '[PRE177]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Without closing the previously running NodeJS process, open another Terminal
    and run:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不关闭之前运行的NodeJS进程的情况下，打开另一个终端并运行：
- en: '[PRE178]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: How it works...
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every time there is a change in the state, the subscribed listener function
    will pretty print in the terminal the current state tree
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当状态有变化时，订阅的监听器函数将在终端中格式化打印当前状态树
- en: 'The first dispatched action is synchronous. It will cause the time slice of
    the state tree to be updated like this, for example:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个派发的动作是同步的。它将导致状态树的时间片段更新如下，例如：
- en: '[PRE179]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The second action being dispatched is asynchronous. Internally, two actions
    are dispatched to reflect the state of the asynchronous operation, one when the
    async function is still in execution, and another when the async function was
    fulfilled:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被派发的第二个动作是异步的。内部，派发了两个动作来反映异步操作的状态，一个是在异步函数仍在执行时，另一个是在异步函数解决时：
- en: '[PRE180]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The third action being dispatched is also asynchronous. Internally, it also
    causes two actions to be dispatched to reflect the state of the async operation:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被派发的第三个动作也是异步的。内部，它也会导致两个动作被派发以反映异步操作的状态：
- en: '[PRE181]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Take into account that because the operations are asynchronous, the output displayed
    in the terminal may not always be in the same order
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到操作是异步的，终端中显示的输出可能不会总是按相同的顺序
- en: Notice that the first async operation is fulfilled and the status marked as
    `RESOLVED` while the second async operation is fulfilled and its status marked
    as `REJECTED`
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，第一个异步操作已完成，状态标记为`RESOLVED`，而第二个异步操作已完成，其状态标记为`REJECTED`
- en: The statuses `PENDING`, `RESOLVED`, and `REJECTED` reflect the three statuses
    that a JavaScript Promise can be, and they are not obligatory names, simply easy
    to remember
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态`PENDING`、`RESOLVED`和`REJECTED`反映了JavaScript Promise可能的三种状态，并且这些名称不是强制的，只是易于记忆
- en: There's more...
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If you don''t want to write your own middleware functions or store enhancers
    to deal with asynchronous operations, you can opt to use one of the many libraries
    for Redux that exist out there. Two of the most use or popular ones are these:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想编写自己的中间件函数或存储增强器来处理异步操作，你可以选择使用许多Redux库中的一个。其中两个最常用或最受欢迎的是这些：
- en: Redux Thunk—[https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk)
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Thunk—[https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk)
- en: Redux Saga—[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Saga—[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)
