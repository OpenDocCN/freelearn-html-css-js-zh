- en: Chapter 7. Using Client Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用客户端方法
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Creating dynamic graphs with SVG and Ajax
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SVG和Ajax创建动态图表
- en: Using the HTML FileReader to upload images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML FileReader上传图片
- en: Creating a coloring book with the Canvas element
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas元素创建彩色书
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Web programming, on the client side, has come a long way since the inception
    of HTML. Up until recently, it was necessary to write/use third party **polyfill**
    libraries to do simple things, such as build graphs, read files, and draw on the
    screen. But that cute lil' bucktoothed kid we all knew and disliked has grown
    up! With powerful, easy to use scripting and graphics APIs and objects now supported
    in nearly every browser, web programming is finally ready to be used on its own.
    The recipes in this chapter will go through some of the most popular Web API objects,
    and show you how to implement them inside Meteor.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自从HTML诞生以来，客户端的Web编程已经取得了长足的进步。直到最近，为了做一些简单的事情，比如构建图表、读取文件和在屏幕上绘制，还需要编写/使用第三方**polyfill**库。但那个我们所有人都知道且不喜欢的小男孩已经长大了！随着强大的、易于使用的脚本和图形API以及对象现在几乎在所有浏览器中都得到了支持，Web编程终于可以独立使用了。本章中的食谱将介绍一些最受欢迎的Web
    API对象，并展示如何在Meteor中实现它们。
- en: Creating dynamic graphs with SVG and Ajax
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG和Ajax创建动态图表
- en: While there are a lot of graphing libraries out there (all of which you can
    use in Meteor, by the way!) it's good to know how to implement fundamental shapes
    inside an HTML page, using **SVG** **templates**. Sometimes implementing a full-fledged
    graphing library is overkill, and having a working knowledge of SVG in your back
    pocket can be very useful. However, this is a Meteor recipe; we not only want
    to see an example of SVG, but we want to see it in action! This recipe will teach
    you how to stream a live data source into MongoDB collections, and then represent
    that dynamic collection graphically, using SVG tags.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在有很多图表库（所有这些你都可以在Meteor中使用，顺便提一下！）但了解如何在HTML页面内部实现基本形状，使用**SVG** **模板**，是很有好处的。有时实现一个完整的图表库可能有些过度，而掌握SVG的相关知识可以非常有用。然而，这是一个Meteor食谱；我们不仅想看到一个SVG的例子，还想看到它在实际中的应用！这个食谱将教你如何将实时数据源流式传输到MongoDB集合中，然后使用SVG标签图形化地表示这个动态集合。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using a default project installation, with `client`, `server`, and
    `both` folders, to keep the code clean and readable. In a terminal window, navigate
    to where you would like your project to reside, and execute the following commands:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认项目安装，包含`client`、`server`和`both`文件夹，以保持代码的整洁和可读性。在终端窗口中，导航到你希望项目所在的位置，并执行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also want to make use of a few packages, and remove the `autopublish` package,
    so let''s do that now. Run the following commands in the terminal window:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要使用一些包，并移除`autopublish`包，所以现在就来做这件事。在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We're now ready to start creating our SVG streaming data graph.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建我们的SVG流数据图表了。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Our project is going to read the comments stream from [http://www.meetup.com/](http://www.meetup.com/),
    which is freely available, and very easy to use. We will record the comments from
    the stream, and display a sum total of comments by state. We will need to create
    the interface, which will display state totals as a vertical bar chart, and will
    also show us the last comment made, along with a picture of the Meetup Group it
    came from.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将读取来自[http://www.meetup.com/](http://www.meetup.com/)的评论流，该流是免费提供的，并且非常容易使用。我们将记录流中的评论，并显示按州的总评论数。我们需要创建一个界面，该界面将显示州的总数作为垂直条形图，并显示最后一条评论以及它来自的Meetup
    Group的图片。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: We are using the data stream collecting code for demonstration purposes only!
    There is no redundancy checking or hardening built into it. We strongly recommend
    against using this code as-is in anything even resembling a production application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅为了演示目的使用数据流收集代码！它没有内置冗余检查或加固。我们强烈建议不要将此代码直接用于任何类似生产的应用程序。
- en: 'Proceed with the following steps to create dynamic graphs with SVG and Ajax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤使用SVG和Ajax创建动态图表：
- en: 'We will first create the SVG element with the `id` of `stateBars`. We will
    then create a `<rect>` element for each individual state, and adjust the height
    using the `stateStat` template. Inside the `[project root]/client/` folder, create
    a `client.html` file, add the following HTML code, and save the file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将创建一个具有`id`为`stateBars`的SVG元素。然后，我们将为每个单独的状态创建一个`<rect>`元素，并使用`stateStat`模板调整高度。在`[project
    root]/client/`文件夹中，创建一个`client.html`文件，添加以下HTML代码，并保存文件：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to provide some basic styling on our page, so let''s get that out of
    the way. In the `[project root]/client` folder, create a `style.css` file, and
    add the following style declarations:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在页面上提供一些基本的样式，所以让我们先把这件事处理掉。在`[project root]/client`文件夹中，创建一个`style.css`文件，并添加以下样式声明：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let''s set up the `Comments` and `CountryTotals` collections. To keep
    things cleaner, logic-wise, on the client we will use some server-side logic to
    aggregate the incoming comments. We first need to declare our collections for
    use on both the client and the server. In the `[project root]/both/` folder, create
    a new file called `model.js`, and add the following two declarations to the file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置`Comments`和`CountryTotals`集合。为了在逻辑上保持事情更清晰，在客户端我们将使用一些服务器端逻辑来聚合传入的评论。我们首先需要声明我们的集合，以便在客户端和服务器端使用。在`[project
    root]/both/`文件夹中，创建一个名为`model.js`的新文件，并将以下两个声明添加到该文件中：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s set up monitoring for the `commentsStream` data, and add a code
    to count the totals. As we removed the `autopublish` package, we need to declare
    our `Comments` publication, and at the same time, we want to update the totals
    for a state whenever any new comments come in. We can accomplish this by using
    the `Meteor.publish()` function and using the `cursor.observeChanges()` method.
    In your `[project root]/server/` folder, create a new file called `svggraph-server.js`,
    and add the following method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置对`commentsStream`数据的监控，并添加代码来统计总数。由于我们移除了`autopublish`包，我们需要声明我们的`Comments`发布，同时，我们希望在每次有新的评论到来时更新某个状态的总数。我们可以通过使用`Meteor.publish()`函数和`cursor.observeChanges()`方法来实现这一点。在你的`[project
    root]/server/`文件夹中，创建一个名为`svggraph-server.js`的新文件，并添加以下方法：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to declare the `Meteor.publish()` method for our state totals
    by country, so let''s do that as well. Append the following to the end of the
    `svggra``ph-server.js` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要通过国家声明我们的状态总数`Meteor.publish()`方法，因此让我们也这样做。将以下内容追加到`svggraph-server.js`文件的末尾：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need to keep track of the country that we are monitoring, and what the last
    comment and picture from the Meetup Group were. The most straightforward way to
    do this is through `Session` variables, so let''s create a file called `svggraph-client.js`
    in the `[project root]/client/` folder, and add the following three variables
    at the top:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要跟踪我们正在监控的国家，以及Meetup Group的最后一条评论和图片。最直接的方法是通过`Session`变量来实现，因此让我们在`[project
    root]/client/`文件夹中创建一个名为`svggraph-client.js`的文件，并在顶部添加以下三个变量：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have specified the country that we will be monitoring, we can add
    our `Meteor.subscribe` statements, which both take the country as a parameter.
    In the `svggraph-client.js` file, add the following statements inside a `T``racker.autorun`
    block:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经指定了我们将要监控的国家，我们可以添加我们的`Meteor.subscribe`语句，这两个语句都接受国家作为参数。在`svggraph-client.js`文件中，在`Tracker.autorun`块内添加以下语句：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will hook up the data later, but we still need to add the `Template.helpers`
    method for displaying the latest pictures and comments, based on the `Session`
    variables declared in the preceding steps. In the `svggraph-client.js` file, add
    the following code just below the `Tracker.autorun` block:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在稍后连接数据，但仍然需要添加基于前面步骤中声明的`Session`变量的`Template.helpers`方法来显示最新的图片和评论。在`svggraph-client.js`文件中，在`Tracker.autorun`块下方添加以下代码：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In anticipation of incoming data from the client, we need a few `helper` methods,
    to message data and perform *aggregate queries* on our Mongo DB collections. We
    also want a quick way to reset our collections, because the sheer amount of data
    we''re collecting can get messy for a sample application. As such, we will create
    the following server-side methods:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针对客户端即将到来的数据，我们需要一些`helper`方法，用于发送数据和在我们的Mongo DB集合上执行*聚合查询*。我们还想有一个快速重置我们集合的方法，因为收集到的数据量对于示例应用来说可能会变得杂乱无章。因此，我们将创建以下服务器端方法：
- en: '`addMsg`: This is used for inserting a message into our `Comments` collection.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addMsg`：这个方法用于将消息插入到我们的`Comments`集合中。'
- en: '`totalsByState`: This is used to aggregate the total number of `Comments`,
    by state.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalsByCountry`: This is used to aggregate totals, by country.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetDB`: This is used to reset the `Comments` and `CountryTotals` collections.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `svggraph-server.js` and add the following code:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With our server-side helper logic all in place, it''s time to read and parse
    the data stream. In the `svggraph-client.js` file, add the following `connect`,
    `disconnect`, `onopen`, `onclose`, and `onmessage` websocket functions:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the data stream all ready to go, all that''s left is to add our display
    logic, and flip the switch. In the `svggraph-client.js` file, locate the `Template.cPic.helpers`
    code block, and add the following helper function just below the `curComment`
    event (don''t forget the comma!):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need a few style helpers to properly position our text data, and to let
    us know where the most recent comment was added (to make the things all fancy!).
    Append the following `Template.helpers` code block to the bottom of the `svggraph-client.js`
    file:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the `Template.rendered` method block, we will turn our data stream on
    and update our `lastState` session variable whenever a new comment is posted,
    using a simple `autorun` method. Enter the following code at the bottom of your
    `svggraph-client.js` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save all changes, and open a browser (if you haven't already) to `http://localhost:3000`.
    Wait just a bit, and you should see the new comments coming in, with state totals
    being updated, as shown in the following screenshot:![How to do it...](img/image00386.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let it run for a bit, so that more states appear. If you let it run long enough,
    you''ll eventually get all 50 states (and maybe even Puerto Rico!). If you would
    like to reset your collection, open your browser console and enter the following
    command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the recipe introduction, there are two critical pieces to graphing
    dynamic data. The first has to do with rendering SVG objects, and can be found
    mostly in the HTML template code, in the `[project root]/clie` `nt/client.html`
    file. We first used the `{{> cPic}}` template inclusion to reference our `cPic`
    template. The template itself declares our `<svg>` element, then runs a standard
    `{{#each }}` control structure on the `stateStats` collection:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We set the width and height of the `<svg>` element directly (note that they
    are *not* CSS style attributes, but are actual element attributes instead), and
    add a unique `id` attribute for CSS styling as well, as shown in the following
    example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `stateStat` template, we create a `<rect>` element and set pretty much
    every attribute dynamically:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`width`: This is set based on the number of comments.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: This is set based on the total number of states.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: This is the vertical position and is set based on position in the data
    collection.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: This is the color value which is set to green if it was the last state
    updated.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We likewise set the position of the text SVG element to make sure it lines
    up with the corresponding `<rect>` element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样设置了文本SVG元素的位置，以确保它与相应的`<rect>`元素对齐：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's important to understand that SVG elements are not positioned relative to
    other elements inside the same `<svg>` block. This is why we had to set the position
    of each element. Also, some attributes (`width` and `height` for example) can
    be set directly. SVG elements are truly a hybrid between a bonafide DOM element
    and a graphic element.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解SVG元素不是相对于同一`<svg>`块内的其他元素定位的。这就是为什么我们必须设置每个元素的位置。此外，一些属性（例如`width`和`height`）可以直接设置。SVG元素实际上是真正的DOM元素和图形元素的混合体。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a great introduction to SVG, you can read the MDN SVG tutorial, found at
    [https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SVG的精彩介绍，你可以阅读MDN SVG教程，位于[https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial)。
- en: 'The second critical piece surrounds the use of the `WebSocket` HTML5 Web API
    object, found in our `MeetupsStream` function of the `svggraph-client.js` file.
    In this function, we prepare a pretty standard Ajax (actually `WebSocket`) call
    by setting handlers for `.ondisconnect`, `.onopen`, and `.onmessage`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键部分围绕着`WebSocket` HTML5 Web API对象的使用，该对象位于`svggraph-client.js`文件的`MeetupsStream`函数中。在这个函数中，我们通过设置`.ondisconnect`、`.onopen`和`.onmessage`处理程序来准备一个相当标准的Ajax（实际上是`WebSocket`）调用：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The one we are most interested in is the `.onmessage` handler, where we parse
    the data (which comes in as a string) into an `EJSON` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的是`.onmessage`处理器，其中我们将数据（以字符串形式传入）解析为`EJSON`对象：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then (conditionally) set the `msgPic` variable, which immediately changes
    the image displayed in our `cPic` template. We likewise update `msgComment` to
    change the displayed comment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后（条件性地）设置`msgPic`变量，这立即改变了`cPic`模板中显示的图像。我们同样更新`msgComment`来更改显示的评论：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we make a `Meteor.call` method to the server-side `''addMsg''` method,
    which puts things in motion to update our state totals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在服务器端的`'addMsg'`方法上创建了一个`Meteor.call`方法，这使我们的状态总数更新开始运转：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `WebSocket` object also has a good MDN tutorial, found at [https://developer.mozilla.org/en-US/docs/WebSockets](https://developer.mozilla.org/en-US/docs/WebSockets).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket`对象也有一个很好的MDN教程，位于[https://developer.mozilla.org/en-US/docs/WebSockets](https://developer.mozilla.org/en-US/docs/WebSockets)。'
- en: A few more odds and ends can be found in the code we used, such as the `meteorhacks:aggregate`
    package, which lets us do summations and groupings on the MongoDB collections
    (official support coming soon!) via the .`aggregate` method, but this recipe was
    meant to focus on the SVG and Ajax (`WebSocket`) aspects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的代码中还可以找到一些其他零散的内容，例如`meteorhacks:aggregate`包，它允许我们通过`.aggregate`方法在MongoDB集合上进行求和和分组（官方支持即将推出！）但这个菜谱旨在关注SVG和Ajax（`WebSocket`）方面。
- en: See also
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating dynamic lists* recipe in [Chapter 3](part0036.xhtml#aid-12AK81
    "Chapter 3. Building Great User Interfaces"), *Building Great User Interfaces*
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0036.xhtml#aid-12AK81 "第3章。构建出色的用户界面")的*创建动态列表*菜谱中，*构建出色的用户界面*
- en: The *Handling asynchronous events* recipe in [Chapter 11](part0083.xhtml#aid-2F4UM1
    "Chapter 11. Leveraging Advanced Features"), *Leveraging Advanced Features*
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第11章](part0083.xhtml#aid-2F4UM1 "第11章。利用高级功能")的*处理异步事件*菜谱中，*利用高级功能*
- en: Using the HTML FileReader to upload images
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML FileReader上传图像
- en: Adding files via a web application is a pretty standard functionality nowadays.
    That doesn't mean that it's easy to do, programmatically. New browsers support
    Web APIs to make our job easier, and a lot of quality libraries/packages exist
    to help us navigate the file reading/uploading forests, but, being the coding
    lumberjacks that we are, we like to know how to roll our own! In this recipe,
    you will learn how to read and upload image files to a Meteor server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络应用添加文件现在是一个相当标准的功能。但这并不意味着它容易通过编程来实现。新浏览器支持Web API来简化我们的工作，并且存在许多高质量的库/包来帮助我们导航文件读取/上传的森林，但作为我们这样的编码伐木工，我们喜欢知道如何自己动手！在这个菜谱中，你将学习如何读取和上传图像文件到Meteor服务器。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using a default project installation, with `client`, `server`, and
    `both` folders, and with the addition of a special folder for storing images.
    In a terminal window, navigate to where you would like your project to reside,
    and execute the following commands:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认的项目安装，包括 `client`、`server` 和 `both` 文件夹，以及用于存储图像的特殊文件夹。在终端窗口中，导航到你希望项目存放的位置，并执行以下命令：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the dot in the `.images` folder. This is really important because we don't
    want the Meteor application to automatically refresh every time we add an image
    to the server! By creating the images folder as `.images`, we are hiding it from
    the eye-of-Sauron-like monitoring system built into Meteor, because folders starting
    with a period are "invisible" to Linux or Unix.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `.images` 文件夹中的点。这非常重要，因为我们不希望每次向服务器添加图像时，Meteor 应用程序都会自动刷新！通过将图像文件夹命名为 `.images`，我们将其隐藏在
    Meteor 内置的类似索伦之眼的监控系统之下，因为以点开头的文件夹对 Linux 或 Unix 来说是“不可见”的。
- en: 'Let''s also take care of the additional Atmosphere packages we''ll need. In
    the same terminal window, execute the following commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也注意一下我们需要的额外大气层（Atmosphere）包。在同一个终端窗口中，执行以下命令：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're now ready to get started on building our image upload application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始构建我们的图像上传应用程序了。
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We want to display the images we upload, so we'll be using a layout package
    (`voodoohop:masonrify`) for display purposes. We will also initiate uploads via
    drag and drop, to cut down on UI components. Lastly, we'll be relying on an npm
    module to make the file upload much easier. Let's break this down into a few steps,
    starting with the user interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想显示我们上传的图像，因此我们将使用布局包（`voodoohop:masonrify`）进行显示。我们还将通过拖放来启动上传，以减少 UI 组件。最后，我们将依赖一个
    npm 模块来使文件上传变得更容易。让我们将其分解为几个步骤，从用户界面开始。
- en: 'In the `[project root]/client` folder, create a file called `imageupload.html`
    and add the following templates and `template` inclusions:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[项目根目录]/client` 文件夹中，创建一个名为 `imageupload.html` 的文件，并添加以下模板和 `template` 包含：
- en: '[PRE25]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We want to add just a little bit of styling, including an "active" state for
    our drop zone, so that we know when we are safe to drop files onto the page. In
    your `[project root]/client/` folder, create a new `style.css` file and enter
    the following CSS style directives:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只想添加一点点的样式，包括为我们的拖放区域添加一个“激活”状态，这样我们就能知道何时可以安全地将文件拖放到页面上。在你的 `[项目根目录]/client/`
    文件夹中，创建一个新的 `style.css` 文件，并输入以下 CSS 样式指令：
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now want to create an `Images` collection to store references to our uploaded
    image files. To do this, we will be relying on **EJSON**. EJSON is Meteor''s extended
    version of JSON, which allows us to quickly transfer binary files from the client
    to the server. In your `[project root]/both/` folder, create a file called `imgFile.js`
    and add the MongoDB collection by adding the following line:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想创建一个 `Images` 集合来存储上传的图像文件的引用。为此，我们将依赖 **EJSON**。EJSON 是 Meteor 对 JSON
    的扩展版本，它允许我们快速将二进制文件从客户端传输到服务器。在你的 `[项目根目录]/both/` 文件夹中，创建一个名为 `imgFile.js` 的文件，并添加以下
    MongoDB 集合的代码行：
- en: '[PRE27]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will now create the `imgFile` object, and declare an EJSON type of `imgFile`
    to be used on both the client and the server. After the preceding `Images` declaration,
    enter the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建 `imgFile` 对象，并声明一个用于客户端和服务器上的 `imgFile` EJSON 类型。在先前的 `Images` 声明之后，输入以下代码：
- en: '[PRE28]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To properly initialize `imgFile` as an EJSON type, we need to implement the
    `fromJSONValue()`, `prototype()`, and `toJSONValue()` methods. We will then declare
    `imgFile` as an EJSON type using the `EJSON.addType()` method. Add the following
    code just below the `imgFile` function declaration:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确初始化 `imgFile` 作为 EJSON 类型，我们需要实现 `fromJSONValue()`、`prototype()` 和 `toJSONValue()`
    方法。然后我们将使用 `EJSON.addType()` 方法将 `imgFile` 声明为 EJSON 类型。在 `imgFile` 函数声明下方添加以下代码：
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The EJSON code used in this recipe is heavily inspired by Chris Mather's Evented
    Mind file upload tutorials. We recommend checking out his site and learning even
    more about file uploading at [https://www.eventedmind.com](https://www.eventedmind.com).
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本食谱中使用的 EJSON 代码深受克里斯·马瑟（Chris Mather）的事件驱动思维文件上传教程的启发。我们建议查看他的网站，并了解更多关于文件上传的信息。[https://www.eventedmind.com](https://www.eventedmind.com)。
- en: 'Even though it''s usually cleaner to put client-specific and server-specific
    code in separate files, because the code is related to the `imgFile` code we just
    entered, we are going to put it all in the same file. Just below the `EJSON.addType()`
    function call in the preceding step, add the following `Meteor.isClient` and `Meteor.isServer`
    code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管通常将客户端特定和服务器特定代码放在单独的文件中会更干净，但由于代码与刚刚输入的 `imgFile` 代码相关，我们将把它们都放在同一个文件中。在上一步中
    `EJSON.addType()` 函数调用下方，添加以下 `Meteor.isClient` 和 `Meteor.isServer` 代码：
- en: '[PRE30]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we will add some `Images` collection `insert` helpers. We will provide
    the ability to add either references (URIs) to images, or to upload files into
    our `.images` folder on the server. To do this, we need some `Meteor.methods`.
    In the `[project root]/server/` folder, create an `imageupload-server.js` file,
    and enter the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些 `Images` 集合的 `insert` 辅助工具。我们将提供添加图像引用（URI）或上传文件到服务器上的 `.images`
    文件夹的能力。为此，我们需要一些 `Meteor.methods`。在 `[project root]/server/` 文件夹中，创建一个 `imageupload-server.js`
    文件，并输入以下代码：
- en: '[PRE31]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We now need to establish the code to process/serve images from the `.images`
    folder. We need to circumvent Meteor''s normal asset serving capabilities for
    anything found in the (hidden) `.images` folder. To do this, we will use the `fs`
    npm module, and redirect any content requests accessing the `Images/` folder address
    to the actual `.images` folder found on the server. Just after the `Meteor.methods`
    block entered in the preceding step, add the following `WebApp.connectHandlers.use()`
    function code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要建立从 `.images` 文件夹处理/提供图像的代码。我们需要绕过 Meteor 的正常资产服务能力，以处理在（隐藏的）`.images`
    文件夹中找到的内容。为此，我们将使用 `fs` npm 模块，并将任何访问 `Images/` 文件夹地址的内容请求重定向到服务器上找到的实际 `.images`
    文件夹。在上一步中输入的 `Meteor.methods` 块之后，添加以下 `WebApp.connectHandlers.use()` 函数代码：
- en: '[PRE32]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our images `display` template is entirely dependent on the `Images` collection,
    so we need to add the appropriate reactive `Template.helpers` function on the
    client side. In your `[project root]/client/` folder, create an `imageupload-client.js`
    file, and add the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的图像 `display` 模板完全依赖于 `Images` 集合，因此我们需要在客户端添加适当的反应式 `Template.helpers` 函数。在你的
    `[project root]/client/` 文件夹中，创建一个 `imageupload-client.js` 文件，并添加以下代码：
- en: '[PRE33]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we add pictures we don''t like and want to remove them quickly, the easiest
    way to do that is by double clicking on a picture. So, let''s add the code for
    doing that just below the `Template.helpers` method in the same file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们添加了不喜欢的图片并想快速删除它们，最简单的方法是在图片上双击。所以，让我们在这个文件中 `Template.helpers` 方法下方添加执行此操作的代码：
- en: '[PRE34]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now for the fun stuff. We''re going to add drag and drop visual feedback cues,
    so that whenever we drag anything over our drop zone, the drop zone will provide
    visual feedback to the user. Likewise, once we move away from the zone, or actually
    drop items, the drop zone should return to normal. We will accomplish this through
    a `Session` variable, which modifies the CSS class in the `div.dropzone` element,
    whenever it is changed. At the bottom of the `imageupload-client.js` file, add
    the following `Template.helpers` and `Template.events` code blocks:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候添加一些有趣的功能了。我们将添加拖放视觉反馈提示，这样无论何时我们将任何东西拖到我们的拖放区域，拖放区域都会向用户提供视觉反馈。同样，一旦我们离开该区域，或者实际上放下项目，拖放区域应该恢复到正常状态。我们将通过一个
    `Session` 变量来实现这一点，该变量在 `div.dropzone` 元素的 CSS 类被更改时修改。在 `imageupload-client.js`
    文件的底部，添加以下 `Template.helpers` 和 `Template.events` 代码块：
- en: '[PRE35]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last task is to evaluate what has been dropped in to our page drop zone.
    If what''s been dropped is simply a URI, we will add it to the `Images` collection
    as is. If it''s a file, we will store it, create a URI to it, and then append
    it to the `Images` collection. In the `imageupload-client.js` file, just before
    the final closing curly bracket inside the `Template.dropzone.events` code block,
    add the following event handler logic:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的任务是评估被拖放到页面拖放区域的内容。如果拖放的是简单的 URI，我们将直接将其添加到 `Images` 集合中。如果是文件，我们将存储它，创建一个指向它的
    URI，然后将它附加到 `Images` 集合中。在 `imageupload-client.js` 文件中，在 `Template.dropzone.events`
    代码块最后的闭合花括号之前，添加以下事件处理逻辑：
- en: '[PRE36]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save all your changes and open a browser to `http://localhost:3000`. Find some
    pictures from any web site, and drag and drop them in to the drop zone. As you
    drag and drop the images, the images will appear immediately on your web page,
    as shown in the following screenshot:![How to do it…](img/image00387.jpeg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有更改并打开浏览器到 `http://localhost:3000`。从任何网站找到一些图片，并将它们拖放到拖放区域。当你拖放图像时，图像将立即出现在你的网页上，如下面的截图所示：![如何操作…](img/image00387.jpeg)
- en: 'As you drag and drop the dinosaur images in to the drop zone, they will be
    uploaded as shown in the following screenshot:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你将恐龙图像拖放到拖放区域时，它们将按以下截图所示上传：
- en: '![How to do it…](img/image00388.jpeg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00388.jpeg)'
- en: 'Similarly, dragging and dropping actual files will just as quickly upload and
    then display images, as shown in the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，拖放实际文件也会迅速上传并显示图像，如下面的截图所示：
- en: '![How to do it…](img/image00389.jpeg)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00389.jpeg)'
- en: As the files are dropped, they are uploaded and saved in the `.images/` folder:![How
    to do it…](img/image00390.jpeg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文件被拖放时，它们会被上传并保存在 `.images/` 文件夹中：![如何操作…](img/image00390.jpeg)
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are a lot of moving parts to the code we just created, but we can refine
    it down to four areas.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的代码有很多组成部分，但我们可以将它精简为四个区域。
- en: First, we created a new `imgFile` object, complete with the internal functions
    added via the `Object.prototype = {…}` declaration. The functions added here (
    `typeName`, `equals`, `clone`, `toJSONValue` and `fromJSONValue`) are primarily
    used to allow the `imgFile` object to be *serialized* and *deserialized* properly
    on the client and the server. Normally, this isn't needed, as we can just `insert`
    into Mongo Collections directly, but in this case it is needed because we want
    to use the `FileReader` and Node `fs` packages on the client and server respectively
    to directly load and save image files, rather than write them to a collection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的 `imgFile` 对象，包括通过 `Object.prototype = {…}` 声明添加的内部函数。这里添加的函数（`typeName`、`equals`、`clone`、`toJSONValue`
    和 `fromJSONValue`）主要用于允许 `imgFile` 对象在客户端和服务器上正确地进行 *序列化* 和 *反序列化*。通常情况下，这并不是必需的，因为我们可以直接将数据
    `insert` 到 Mongo 集合中，但在这个例子中是必需的，因为我们想在客户端和服务器上分别使用 `FileReader` 和 Node `fs` 包来直接加载和保存图像文件，而不是将它们写入集合。
- en: Second, the underscore `_.extend()` method is used on the client side to create
    the `read()` function, and on the server side to create the `save()` function.
    `read` takes the file(s) that were dropped, reads the file into an `ArrayBuffer`,
    and then calls the included `callback`, which uploads the file to the server.
    The `save` function on the server side reads the `ArrayBuffer`, and writes the
    subsequent image file to a specified location on the server (in our case, the
    `.images` folder).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，客户端使用下划线 `_.extend()` 方法创建 `read()` 函数，而服务器端则用于创建 `save()` 函数。`read` 函数接收被拖放的文件，将其读取到
    `ArrayBuffer` 中，然后调用包含的 `callback`，将文件上传到服务器。服务器端的 `save` 函数读取 `ArrayBuffer`，并将后续的图像文件写入服务器上的指定位置（在我们的例子中，是
    `.images` 文件夹）。
- en: 'Third, we created an `ondropped` event handler, using the `''drop #dropzone''`
    event. This handler determines whether an actual file was dragged and dropped,
    or if it was simply an HTML `<img>` element, which contains a URI link in the
    `src` property. In the case of a file (determined by `files.length`), we call
    the `imgFile.read` command, and pass a callback with an immediate `Meteor.call(''uploadIMG''…)`
    method. In the case of an `<img>` tag, we parse the URI from the `src` attribute,
    and use `Meteor.call(''addURL'')` to update the `Images` collection.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '第三，我们创建了一个 `ondropped` 事件处理器，使用 `''drop #dropzone''` 事件。此处理器确定是否实际文件被拖放并放下，或者它只是一个包含
    `src` 属性中 URI 链接的 HTML `<img>` 元素。在文件的情况下（由 `files.length` 确定），我们调用 `imgFile.read`
    命令，并传递一个带有立即 `Meteor.call(''uploadIMG''…)` 方法的回调。在 `<img>` 标签的情况下，我们解析 `src` 属性中的
    URI，并使用 `Meteor.call(''addURL'')` 更新 `Images` 集合。'
- en: Fourth, we have our `helper` functions for updating the UI. These include `Template.helpers`
    functions, `Template.events` functions, and the `WebApp.connectedHandlers.use()`
    function, used to properly serve uploaded images without having to update the
    UI each time a file is uploaded. Remember, Meteor will update the UI automatically
    on any file change. This unfortunately includes static files, such as images.
    To work around this, we store our images in a file invisible to Meteor (using
    `.images`). To redirect the traffic to that hidden folder, we implement the `.use()`
    method to listen for any traffic meant to hit the `'/images/'` folder, and redirect
    it accordingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们有用于更新UI的`helper`函数。这些包括`Template.helpers`函数、`Template.events`函数以及`WebApp.connectedHandlers.use()`函数，用于在每次上传文件时无需更新UI的情况下正确地服务上传的图片。记住，Meteor会在任何文件更改时自动更新UI。遗憾的是，这包括静态文件，例如图片。为了解决这个问题，我们将我们的图片存储在一个对Meteor不可见的文件中（使用`.images`）。为了将流量重定向到那个隐藏文件夹，我们实现了`.use()`方法来监听任何意图访问`'/images/'`文件夹的流量，并相应地重定向。
- en: As with any complex recipe, there are other parts to the code, but this should
    cover the major aspects of file uploading (the four areas mentioned in the preceding
    section).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何复杂的配方一样，代码中还有其他部分，但这应该涵盖了文件上传的主要方面（前面章节中提到的四个区域）。
- en: There's more…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The next logical step is to not simply copy the URIs from remote image files,
    but rather to download, save, and serve local copies of those remote images. This
    can also be done using the `FileReader` and Node `fs` libraries, and can be done
    either through the existing client code mentioned in the preceding section, or
    directly on the server, as a type of *cron* job.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤不是简单地复制远程图像文件的URI，而是下载、保存并服务这些远程图像的本地副本。这也可以使用`FileReader`和Node `fs`库来完成，可以通过前面章节中提到的现有客户端代码，或者直接在服务器上作为*cron*作业来完成。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on `FileReader`, please see the MDN FileReader article,
    located at [https://developer.mozilla.org/en-US/docs/Web/API/FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`FileReader`的信息，请参阅位于[https://developer.mozilla.org/en-US/docs/Web/API/FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)的MDN
    FileReader文章。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using npm packages directly* recipe in [Chapter 8](part0069.xhtml#aid-21PMQ1
    "Chapter 8. Integrating Third-party Libraries"), *Intergrating Third-party Libraries*
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](part0069.xhtml#aid-21PMQ1 "第8章。集成第三方库")中的*直接使用npm包*配方，*集成第三方库*'
- en: The *Creating custom EJSON objects* recipe in [Chapter 11](part0083.xhtml#aid-2F4UM1
    "Chapter 11. Leveraging Advanced Features"), *Leveraging Advanced Features*
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](part0083.xhtml#aid-2F4UM1 "第11章。利用高级功能")中的*创建自定义EJSON对象*配方，*利用高级功能*'
- en: Creating a coloring book with the Canvas element
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas元素制作彩色书
- en: There are now multiple ways to display graphics on a web page. DOM elements,
    SVG, WebGL, and, perhaps the most user-friendly, the `Canvas` element. Using JavaScript,
    the `Canvas` element provides a flexible graphics area where you can paint, erase,
    color, cut and paste to your heart's content. A good representation of what you
    can do with the `Canvas` element is found in this recipe, where you will learn
    how to build a coloring book app from scratch.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有多种方式可以在网页上显示图形。DOM元素、SVG、WebGL，以及可能是最用户友好的`Canvas`元素。使用JavaScript，`Canvas`元素提供了一个灵活的图形区域，你可以随心所欲地绘画、擦除、上色、剪切和粘贴。你可以在这个配方中找到一个很好的`Canvas`元素的应用示例，你将学习如何从头开始构建一个彩色书应用。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Get your crayons! Okay, maybe those won't be needed (don't use them on your
    monitor!) but what we're about to create is the next best thing, so let's get
    the app structure and packages out of the way, so we can start coloring!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出你的蜡笔！好吧，可能不需要（不要在显示器上使用它们！）但我们即将创建的是最好的替代品，所以让我们先处理掉应用结构和包，这样我们就可以开始涂色了！
- en: 'In addition to the usual suspects, we will need some specialty folders to make
    the grouping of our code cleaner and more manageable. Open a terminal window,
    navigate to where you would like to create your root project, and execute the
    following commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的文件夹外，我们还需要一些特殊文件夹来使我们的代码分组更干净、更易于管理。打开一个终端窗口，导航到你想要创建根项目的地方，并执行以下命令：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: It may not seem like it on the surface, but there's actually a lot to developing
    a coloring book application. You have to worry about user preferences, undo/redo,
    picking colors, erasing, and so on. We will tackle these steps one at a time,
    adding packages and functionality as we go along.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上可能看起来不多，但实际上开发一本涂色书应用有很多工作要做。你必须考虑用户偏好、撤销/重做、选择颜色、擦除等等。我们将一步一步地解决这些问题，随着项目的进行添加包和功能。
- en: 'First, we will add user management packages. Meteor has some fantastic out-of-the-box
    functionality for user account management, and we will take advantage of that
    functionality. In a terminal window, navigate to your `[project root]` folder
    and add the following two Meteor libraries by entering the following commands:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加用户管理包。Meteor 提供了一些非常出色的开箱即用的用户账户管理功能，我们将利用这些功能。在终端窗口中，导航到你的 `[项目根目录]`
    文件夹，并输入以下命令添加以下两个 Meteor 库：
- en: '[PRE38]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will want to display these on the screen, so let''s add the necessary UI
    elements and style them appropriately. Create a file called `cb-ui.html` in your
    `[project root]/client/` folder, and add the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在屏幕上显示这些样式，所以让我们添加必要的 UI 元素并适当地进行样式化。在你的 `[项目根目录]/client/` 文件夹中创建一个名为 `cb-ui.html`
    的文件，并添加以下代码：
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your page will look very spartan at the moment, but just like that, we already
    have accounts and account creation! In a browser, navigate to `http://localhost:3000`
    and you should see the accounts dialog dropdown at the top left of your screen,
    similar to the following screenshot:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前你的页面看起来非常简洁，但就像那样，我们已经有账户和账户创建功能了！在浏览器中，导航到 `http://localhost:3000`，你应该会在屏幕左上角看到账户对话框下拉菜单，类似于以下截图：
- en: '![How to do it…](img/image00391.jpeg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00391.jpeg)'
- en: 'Let''s finish up the visual aspects of our UI by adding a toolbar, where we
    can see color swatches and adjust the size of our brush; and let''s also add our
    `canvas` element, with a background `<div>` to display the picture we want to
    color. In the same `cb-ui.html` file, add the following template inclusions in
    the `body` element block:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加一个工具栏来完成 UI 的视觉方面，在这个工具栏中我们可以看到颜色样本并调整画笔的大小；同时，我们也要添加我们的 `canvas` 元素，以及一个背景
    `<div>` 来显示我们想要着色的图片。在同一个 `cb-ui.html` 文件中，在 `body` 元素块中添加以下模板包含：
- en: '[PRE40]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `picture` template is actually the easiest, so we''ll add the code for
    that first. Add the following template code just below the `</body>` tag:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`picture` 模板实际上是最简单的，所以我们将首先添加该代码。在 `</body>` 标签下方添加以下模板代码：'
- en: '[PRE41]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we add the `toolbar` and the `swatch` templates, which use a bit of SVG
    and `Masonry.js` to display our brush and color swatches. Just below the template
    code added in the preceding step, add the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加 `toolbar` 和 `swatch` 模板，这些模板使用 SVG 和 `Masonry.js` 来显示我们的画笔和颜色样本。在上一步骤添加的模板代码下方，添加以下代码：
- en: '[PRE42]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To get everything all pretty, we need to add some Atmosphere packages, and
    just a bit of CSS styling. In a terminal window, navigate to your `[project root]`
    folder and run the following commands:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让一切看起来都很漂亮，我们需要添加一些 Atmosphere 包，以及一点 CSS 样式。在终端窗口中，导航到你的 `[项目根目录]` 文件夹，并运行以下命令：
- en: '[PRE43]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, create a file named `cb-style.css` in the `[project root]/client/` folder,
    and add the following style declarations:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `[项目根目录]/client/` 文件夹中创建一个名为 `cb-style.css` 的文件，并添加以下样式声明：
- en: '[PRE44]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that the `bgpicture` element has a background image in it, called `'RAWR.GIF'—`You
    can either obtain this picture from the source files for this recipe, or you can
    add your own image to be colored. The image *must* have a transparent background,
    and will look better if it is `800x600` pixels, but in any case, the image you
    want displayed should go into the `[project root]/public/` folder, and you should
    change the `background` property in the preceding step, so that it will display
    properly on the screen.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到 `bgpicture` 元素中有一个背景图片，名为 `'RAWR.GIF'`——你可以从本菜谱的源文件中获取这张图片，或者你可以添加自己的图片进行着色。图片
    *必须* 有透明背景，如果它是 `800x600` 像素，看起来会更好，但无论如何，你想要显示的图片应该放入 `[项目根目录]/public/` 文件夹中，并且你应该在上一步中更改
    `background` 属性，以便它在屏幕上正确显示。
- en: 'We will need to be able to change brush sizes, change colors, and paint/erase
    on the canvas, and we want to do that no matter what device we are on, so we will
    use the official `Hammer.js` package. We also want to include global shortcut
    keys for undo (*control* + *Z*) and redo (*shift* + *control* + *Z*), so we''ll
    add a handy library that does that! In a terminal window, in your `[project root]`
    folder, enter the following two commands:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要能够更改画笔大小、更改颜色，并在画布上绘画/擦除，并且我们希望在无论什么设备上都能做到这一点，因此我们将使用官方的`Hammer.js`包。我们还希望包括全局快捷键来撤销（*control*
    + *Z*）和重做（*shift* + *control* + *Z*），因此我们将添加一个方便的库来实现这一点！在终端窗口中，在你的`[项目根]`文件夹中，输入以下两个命令：
- en: '[PRE45]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It''s cleaner and easier to use `Hammer.js` events in the `Template.events`
    block, so we want to add the jQuery plugin for the `Hammer.js` file. As Meteor
    piggybacks on jQuery event handlers, if the plugin is added to jQuery, it''s added
    to Meteor! As of this writing, the most reliable way to add the plugin is to manually
    copy the `plugin` script file into your `[project root]/client/scripts/` folder.
    You can either obtain the script by going to [http://hammerjs.github.io/jquery-plugin/](http://hammerjs.github.io/jquery-plugin/)
    and following the instructions there, or by creating a file in your `scripts`
    folder called `jquery.hammer.js`, and adding the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Template.events`块中使用`Hammer.js`事件更干净、更易于使用，因此我们希望为`Hammer.js`文件添加jQuery插件。由于Meteor依赖于jQuery事件处理器，如果插件添加到jQuery中，它也会添加到Meteor中！截至本文撰写时，添加插件最可靠的方法是将`plugin`脚本文件手动复制到你的`[项目根]/client/scripts/`文件夹中。你可以通过访问[http://hammerjs.github.io/jquery-plugin/](http://hammerjs.github.io/jquery-plugin/)并遵循那里的说明来获取脚本，或者在你的`scripts`文件夹中创建一个名为`jquery.hammer.js`的文件，并添加以下代码：
- en: '[PRE46]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will now add the `Activities`, `Prefs`, and `Swatches` collections. As mentioned
    previously, we will need to keep track of our undo/redo, through recording activities.
    We will also need to keep track of color swatches, user preferences for brush
    size, and so on. To do this, we will declare three MongoDB collections. In your
    `[project root]/both/` folder, create a file called `cb-model.js` and add the
    following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加`Activities`、`Prefs`和`Swatches`集合。如前所述，我们需要通过记录活动来跟踪我们的撤销/重做。我们还需要跟踪颜色样本、用户对画笔大小的偏好等。为此，我们将声明三个MongoDB集合。在你的`[项目根]/both/`文件夹中，创建一个名为`cb-model.js`的文件，并添加以下代码：
- en: '[PRE47]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We'll be using these later on, on both the client and on the server, but for
    now we're all done. You can close the `cb-model.js` file and move on to the next
    step.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后将在客户端和服务器端使用这些，但现在我们已经完成了所有工作。你可以关闭`cb-model.js`文件，继续下一步。
- en: 'Let''s add the server-side logic for the preferences and undo/redo history.
    As unbelievable as this may seem, the server-side code for the coloring book is
    very light, compared to the client code. So, we''re going to get it out of the
    way. We need to do several things on the server:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加偏好设置和撤销/重做历史记录的服务器端逻辑。尽管这听起来可能令人难以置信，但与客户端代码相比，彩色书的服务器端代码非常轻量。因此，我们将把它放在一边。我们需要在服务器上做一些事情：
- en: Initialize swatches and other preferences
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化样本和其他偏好设置
- en: Allow new swatches to be added, if desired
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，允许添加新的样本
- en: Track and recall our painting activity (undo/redo)
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪和回忆我们的绘画活动（撤销/重做）
- en: Clear everything out, so we can start over
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除一切，以便从头开始
- en: 'In your `[project root]/server/` folder, create a file called `cb-server.js`
    and add the following `Meteor.methods` declaration:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的`[项目根]/server/`文件夹中，创建一个名为`cb-server.js`的文件，并添加以下`Meteor.methods`声明：
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now add the `Accounts.onLogin()` event handler in the same file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在同一个文件中添加`Accounts.onLogin()`事件处理器：
- en: '[PRE49]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It''s time to build the main logic that allows us to draw on the screen, using
    the `canvas` element. Create a file called `cb-client.js` in the `[project root]/client/`
    folder and add the following initial default values that control what we are drawing,
    and what our paintbrush color should be:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候构建允许我们使用`canvas`元素在屏幕上绘制的主体逻辑了。在`[项目根]/client/`文件夹中创建一个名为`cb-client.js`的文件，并添加以下初始默认值，这些值控制我们要绘制的内容以及我们的画笔颜色：
- en: '[PRE50]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Because it''s used in multiple places, we want to create a `drawLine` function
    that will draw/erase parts of the screen as needed. Add the following code just
    below the `Session.setDefault` declarations:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它被用于多个地方，我们希望创建一个`drawLine`函数，该函数将根据需要绘制/擦除屏幕的一部分。在`Session.setDefault`声明下方添加以下代码：
- en: '[PRE51]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, add some helper functions that help us clean up the screen, or calculate
    the paint stroke positioning, relative to the page:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一些辅助函数，帮助我们清理屏幕，或计算相对于页面的绘画笔迹定位：
- en: '[PRE52]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Whenever the user lifts their mouse/stylus/finger off of the screen, we want
    to record what they just drew, so let''s add a snapshot-taking function just below
    our helpers:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When we first log in, or when we go up and down the undo/redo history chain,
    we need to repaint the screen. Add the following helper function just below the
    `addSnapshot` helper:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Okay, we''re ready for the final touches, which include enabling our toolbar,
    and hooking up all the touch/mouse events to adjust brush sizes, change colors,
    paint and erase. In your `[project root]/client/` folder, create a file named
    `tmpl-toolbar.js`, and add the following interaction event handler code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In that same file, add the `Template.helpers` function for displaying brush
    size, color preference, and so on:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s also add the interactivity logic, via the `Template.events` helper block:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We have a little bit of logic/event handling for the `swatch` template as well,
    so let''s create a file called `tmpl-swatch.js` in the `[project root]/client/`
    folder, and add the following event listener and event interaction logic:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Two more files and we''re done! We have quite a bit of interaction to handle
    in the `picture` template (where our `canvas` element is), so let''s create a
    file called `tmpl-picture.js` in the `[project root]/client/` folder, and add
    our initialization logic, via the `Template.rendered` method block. Add the following
    code to the `tmpl-picture.js` file:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On preference changes, or on login/logout of a user, we have to perform some
    reactive logic to clean up or initialize our canvas. Add two `autorun` method
    blocks just below `Template.picture.rendered`, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The last item of business for the `picture` template is to hook up the drawing
    events themselves. When we start drawing, we need event handlers for `panstart`,
    `panmove`, `panend`, and we also need one to clean everything up when we `doubletap`
    on the page. Add the following `Template.events` method block to the bottom of
    `tmpl-pictur``e.js`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'All that''s left now is the `keydown` event logic, so that we have proper undo/redo.
    Quickly make a file called `tmpl-body.js` in your `[project root]/client/` folder
    and add the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Whew! We made it through! Save all of your changes and navigate to your project
    in a browser, via `http://localhost:3000`. After you log in/create an account,
    you should see a nice color palette, a picture of your choice, and a brush size/preview.
    The following features are available:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click on the brush preview to toggle `'eraser'` mode
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click and drag left and right on the brush preview to resize the brush
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-click on the page to erase and clear your undo history
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *Z* or *CMD* + *Z* to undo your strokes
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Shift* + *Ctrl* + *Z* or *Shift* + *CMD* + *Z* to redo your strokes
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Log out and in with another user, to allow multi-user use
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do note that your undo/redo history chain is preserved, even if you log out.
    Once you log back in, you can go through your paint creations, stroke by stroke.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are a particularly awesome artist like my daughter, and you have properly
    coded everything, your page will look similar to the following masterpiece:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00392.jpeg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oh boy! That was a lot of code, just to demonstrate how the `canvas` element
    works, wasn't it? Instead of going through all of it step by step, let's go through
    the important pieces, related to the `Canvas` element.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of `tmpl-picture.js`, we initialize our `canvas`. In the `Template.picture.rendered()`
    helper block, we first find our `canvas` element using `this.$(''#picture'')`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then get the context (the handle) using the very appropriately-named `getContext()`
    function. We only want the 2D representation and not the 3D, so we pass `''2d''`
    as the argument to `getContext`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Moving on to `cb-client.js`, we have several uses for the context, passed around
    in the global `ctx` variable. In the `drawLine` function, we set the size (`lineWidth`),
    color (`strokeStyle`) and we set the type of stroke (`globalCompositeOperation`)
    according to whether we are erasing (`''destination-out''`) or laying down some
    paint (`''source-over''`):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Once all that is set/determined, we tell the canvas that we are starting to
    draw (`beginPath`); we move our stroke (`moveTo`, `lineTo`) and then we clean
    up (`closePath`, `stroke`):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To save database space/transactions, we don''t record every stroke. Instead,
    we wait for a stroke to be finished (the `''panend #picture''` event) and we add
    a snapshot of the entire canvas. We did this inside the `addSnapshot` helper function,
    with a call to the `canvas.toDataURL()` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once we have the `canvas` graphics element represented as data, we simply save
    it to the `Activities` collection, via `Activities.insert()`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Retrieving and displaying a saved screenshot from the `Activities` Collection
    is just as easy. The `ctx` handle takes care of the drawing for us. All we have
    to do to get that monkey to dance is give it the data. So, inside `paintActivity`,
    we create a new `Image()` object and we add a `.src` to that `imageObj`. We then
    call `ctx.drawImage()` when the `.onLoad` event callback is triggered:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Lastly, and most simply, if we want to `wipe` the screen, we simply call `ctx.clearRect()`
    with the dimensions we want cleared (in this case, the `width` and `height` of
    the canvas):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's a lot of Meteor magic going on, in coordination, so that we are using
    as little functional programming as possible, but that coordination is covered
    in other recipes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, there's a whole lot more! We could have added custom color swatches
    (use `Meteor.call('addSwatch','#yourcolorhere')` to do that from the console,
    by the way), or enabled drag and drop, and the storing of other pictures. You
    can use the *Using the HTML FileReader to upload images* recipe found in this
    chapter to do that, if you would like.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有更多！我们本来可以添加自定义颜色样本（顺便说一句，你可以使用 `Meteor.call('addSwatch','#yourcolorhere')`
    从控制台完成此操作），或者启用拖放，以及存储其他图片。如果你想要这样做，可以使用本章中找到的 *使用 HTML FileReader 上传图片* 菜单。
- en: 'The core functionality, however, will remain the same: reference a `<canvas>`
    object, grab the context, and draw, baby draw!'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，核心功能将保持不变：引用一个 `<canvas>` 对象，获取上下文，然后绘制，宝贝，画吧！
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For an informative and thorough tutorial on HTML canvas, please visit: [http://www.html5canvastutorials.com/](http://www.html5canvastutorials.com/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 想要一个关于 HTML canvas 的信息丰富且详尽的教程，请访问：[http://www.html5canvastutorials.com/](http://www.html5canvastutorials.com/)。
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding Meteor packages* recipe in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Customizing with Packages"), *Customizing with Packages*
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 2 章](part0028.xhtml#aid-QMFO1 "第 2 章。使用包进行自定义") 的 *添加 Meteor 包* 菜单，*使用包进行自定义*
- en: The *Inserting templates with Spacebars* and *Creating customized global helpers*
    recipes in [Chapter 3](part0036.xhtml#aid-12AK81 "Chapter 3. Building Great User
    Interfaces"), *Building Great User Interfaces*
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0036.xhtml#aid-12AK81 "第 3 章。构建出色的用户界面") 的 *使用 Spacebars 插入模板*
    和 *创建自定义全局辅助函数* 菜单，*构建出色的用户界面*
- en: The *Creating and consuming a reactive value* recipe in [Chapter 6](part0058.xhtml#aid-1NA0K1
    "Chapter 6. Mastering Reactivity"), *Mastering Reactivity*
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](part0058.xhtml#aid-1NA0K1 "第 6 章。掌握反应性") 的 *创建和消费反应性值* 菜单，*掌握反应性*
- en: The *Using the HTML FileReader to upload images* recipe in this chapter
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 HTML FileReader 上传图片* 菜单
