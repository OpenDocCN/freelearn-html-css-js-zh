<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Modular Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Modular Programming</h1></div></div></div><p>
<span class="strong"><strong>Modular programming</strong></span><a id="id471" class="indexterm"/> is one of the most important and frequently used software design techniques. Unfortunately, JavaScript didn't support modules natively that lead JavaScript programmers to use alternative techniques to achieve modular programming in JavaScript. But now, ES6 brings modules in to JavaScript officially.</p><p>This chapter is all about how to create and import JavaScript modules. In this chapter, we will first learn how the modules were created earlier, and then we will jump to the new built-in module system that was introduced in ES6, known as the<a id="id472" class="indexterm"/> ES6 modules.</p><p>In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is modular programming?</li><li class="listitem" style="list-style-type: disc">The benefits of modular programming</li><li class="listitem" style="list-style-type: disc">The basics of IIFE modules, AMD, UMD, and CommonJS</li><li class="listitem" style="list-style-type: disc">Creating and importing the ES6 modules</li><li class="listitem" style="list-style-type: disc">The basics of the Modular Loader</li><li class="listitem" style="list-style-type: disc">Creating a basic JavaScript library using modules</li></ul></div><div class="section" title="The JavaScript modules in a nutshell"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>The JavaScript modules in a nutshell</h1></div></div></div><p>The practice of breaking down <a id="id473" class="indexterm"/>programs and libraries into modules is called modular programming.</p><p>In JavaScript, a module is a collection of related objects, functions, and other components of a program or library that are wrapped together and isolated from the scope of the rest of the program or library.</p><p>A module exports some variables to the outside program to let it access the components wrapped by the module. To use a module, a program needs to import the module and the variables exported by the module.</p><p>A module can also be split into further modules called as its submodules, thus creating a module hierarchy.</p><p>Modular programming <a id="id474" class="indexterm"/>has many benefits. Some benefits are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It keeps our code both cleanly separated and organized by splitting into multiple modules</li><li class="listitem" style="list-style-type: disc">Modular programming leads to fewer global variables, that is, it eliminates the problem of global variables, because modules don't interface via the global scope, and each module has its own scope</li><li class="listitem" style="list-style-type: disc">Makes code reusability easier as importing and using the same modules in different projects is easier</li><li class="listitem" style="list-style-type: disc">It allows many programmers to collaborate on the same program or library, by making each programmer to work on a particular module with a particular functionality</li><li class="listitem" style="list-style-type: disc">Bugs in an application can easily be easily identified as they are localized to a particular module</li></ul></div></div></div>
<div class="section" title="Implementing modules &#x2013; the old way"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Implementing modules – the old way</h1></div></div></div><p>Before ES6, JavaScript <a id="id475" class="indexterm"/>had never supported modules natively. Developers used other techniques and third-party libraries to implement modules in JavaScript.</p><p>Using <a id="id476" class="indexterm"/>
<span class="strong"><strong>Immediately-invoked function expression</strong></span> (<span class="strong"><strong>IIFE</strong></span>), <a id="id477" class="indexterm"/>
<span class="strong"><strong>Asynchronous Module Definition</strong></span> (<span class="strong"><strong>AMD</strong></span>), <a id="id478" class="indexterm"/>
<span class="strong"><strong>CommonJS</strong></span>, and <span class="strong"><strong>Universal Module Definition</strong></span> (<span class="strong"><strong>UMD</strong></span>)<a id="id479" class="indexterm"/> are various popular ways of implementing modules in ES5. As these ways were not native to JavaScript, they had several problems. Let's see an overview of each of these old ways of implementing modules.</p><div class="section" title="The Immediately-Invoked Function Expression"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>The Immediately-Invoked Function Expression</h2></div></div></div><p>The IIFE is used to create<a id="id480" class="indexterm"/> an anonymous<a id="id481" class="indexterm"/> function that invokes itself. Creating modules using IIFE is the most popular way of creating modules.</p><p>Let's see an example of how to create a module using IIFE:</p><div class="informalexample"><pre class="programlisting">//Module Starts

(function(window){
  var sum = function(x, y){
    return x + y;
  }

  var sub = function(x, y){
    return x - y;
  }

  var math = {
    findSum: function(a, b){
      return sum(a,b);
    },
    findSub: function(a, b){
      return sub(a, b);
    }
  }

  window.math = math;
})(window)

//Module Ends

console.log(math.findSum(1, 2)); //Output "3"
console.log(math.findSub(1, 2)); //Output "-1"</pre></div><p>Here, we created a <a id="id482" class="indexterm"/>module using <a id="id483" class="indexterm"/>IIFE. The <code class="literal">sum</code> and <code class="literal">sub</code> variables are global to the module, but not visible outside of the module. The <code class="literal">math</code> variable is exported by the module to the main program to expose the functionalities that it provides.</p><p>This module works completely independent of the program, and can be imported by any other program by simply copying it into the source code, or importing it as a separate file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>A library using IIFE, such as jQuery, wraps its all of its APIs in a single IIFE module. When a program uses a jQuery library, it automatically imports the module.</p></div></div></div><div class="section" title="Asynchronous Module Definition"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Asynchronous Module Definition</h2></div></div></div><p>AMD<a id="id484" class="indexterm"/> is <a id="id485" class="indexterm"/>a specification for implementing modules in browser. AMD is designed by keeping the browser limitations in mind, that is, it imports modules asynchronously to prevent blocking the loading of a webpage. As AMD is not a native browser specification, we need to use an AMD library. <span class="strong"><strong>RequireJS</strong></span><a id="id486" class="indexterm"/> is the most popular AMD library.</p><p>Let's see an <a id="id487" class="indexterm"/>example on<a id="id488" class="indexterm"/> how to create and import modules using RequireJS. According to the AMD specification, every module needs to be represented by a separate file. So first, create a file named <code class="literal">math.js</code> that represents a module. Here is the sample code that will be inside the module:</p><div class="informalexample"><pre class="programlisting">define(function(){
  var sum = function(x, y){
    return x + y;
  }
  var sub = function(x, y){
    return x - y;
  }
  var math = {
    findSum: function(a, b){
      return sum(a,b);
    },
    findSub: function(a, b){
      return sub(a, b);
    }
  }
  return math;
});</pre></div><p>Here, the module exports the <code class="literal">math</code> variable to expose its functionality.</p><p>Now, let's create a file named <code class="literal">index.js</code>, which acts like the main program that imports the module and the exported variables. Here is the code that will be inside the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">require(["math"], function(math){
  console.log(math.findSum(1, 2)); //Output "3"
  console.log(math.findSub(1, 2)); //Output "-1"
})</pre></div><p>Here, <code class="literal">math</code> variable in the first parameter is the name of the file that is treated as the AMD module. The <code class="literal">.js</code> extension to the file name is added automatically by RequireJS.</p><p>The <code class="literal">math</code> variable, which is in the second parameter, references the exported variable.</p><p>Here, the module is imported asynchronously, and the callback is also executed asynchronously.</p></div><div class="section" title="CommonJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>CommonJS</h2></div></div></div><p>CommonJS<a id="id489" class="indexterm"/> is a specification for implementing modules in <a id="id490" class="indexterm"/>
<span class="strong"><strong>Node.js</strong></span>. According to the CommonJS specification, every module <a id="id491" class="indexterm"/>needs to be represented by a separate file. The CommonJS modules are imported synchronously.</p><p>Let's see an example on how to create and import modules using CommonJS. First, we will create a file named <code class="literal">math.js</code> that represents a module. Here is a sample code that will be inside the module:</p><div class="informalexample"><pre class="programlisting">var sum = function(x, y){
  return x + y;
}

var sub = function(x, y){
  return x - y;
}

var math = {
  findSum: function(a, b){
    return sum(a,b);
  },

  findSub: function(a, b){
    return sub(a, b);
  }
}

exports.math = math;</pre></div><p>Here, the module exports the <code class="literal">math</code> variable to expose its functionality.</p><p>Now, let's create a file named <code class="literal">index.js</code>, which acts like the main program that imports the module. Here is the code that will be inside the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var math = require("./math").math;

console.log(math.findSum(1, 2)); //Output "3"
console.log(math.findSub(1, 2)); //Output "-1"</pre></div><p>Here, the <code class="literal">math</code> variable is the name of the file that is treated as module. The <code class="literal">.js</code> extension to the file name is added automatically by CommonJS.</p></div><div class="section" title="Universal Module Definition"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>Universal Module Definition</h2></div></div></div><p>We saw three different <a id="id492" class="indexterm"/>specifications of implementing modules. These three specifications have their own<a id="id493" class="indexterm"/> respective ways of creating and importing modules. Wouldn't it have been great if we can create modules that can be imported as an IIFE, AMD, or CommonJS module?</p><p>UMD is a set of techniques that is used to create modules that can be imported as an IIFE, CommonJS, or AMD module. Therefore now, a program can import third-party modules, irrespective of what module specification it is using.</p><p>The most popular UMD technique is <code class="literal">returnExports</code>. According to the <code class="literal">returnExports</code> technique, every module needs to be represented by a separate file. So, let's create a file named <code class="literal">math.js</code> that represents a module. Here is the sample code that will be inside the module:</p><div class="informalexample"><pre class="programlisting">(function (root, factory) {
  //Environment Detection
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.returnExports = factory();
  }
}(this, function () {
  //Module Definition
  var sum = function(x, y){
    return x + y;
  }
  var sub = function(x, y){
    return x - y;
  }
  var math = {
    findSum: function(a, b){
      return sum(a,b);
    },
    findSub: function(a, b){
      return sub(a, b);
    }
  }
  return math;
}));</pre></div><p>Now, you can successfully import the <code class="literal">math.js</code> module any way that you wish, for instance, by using CommonJS, RequireJS, or IIFE.</p></div></div>
<div class="section" title="Implementing modules &#x2013; the new way"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Implementing modules – the new way</h1></div></div></div><p>ES6 introduced a <a id="id494" class="indexterm"/>new module system called ES6 modules. The ES6 modules are supported natively and therefore, they can be referred as the standard JavaScript modules.</p><p>You should consider using ES6 modules instead of the old ways, because they have neater syntax, better performance, and many new APIs that are likely to be packed as the ES6 modules.</p><p>Let's have a look at the ES6 modules in detail.</p><div class="section" title="Creating the ES6 modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec115"/>Creating the ES6 modules</h2></div></div></div><p>Every ES6 module needs <a id="id495" class="indexterm"/>to be represented by a separate <code class="literal">.js</code> file. An ES6 module can contain any JavaScript code, and it can export any number of variables.</p><p>A module can export a variable, function, class, or any other entity.</p><p>We need to use the <code class="literal">export</code> statement in a module to export variables. The <code class="literal">export</code> statement comes in many different formats. Here are the formats:</p><div class="informalexample"><pre class="programlisting">export {variableName};
export {variableName1, variableName2, variableName3};
export {variableName as myVariableName};
export {variableName1 as myVariableName1, variableName2 as myVariableName2};
export {variableName as default};
export {variableName as default, variableName1 as myVariableName1, variableName2};
export default function(){};
export {variableName1, variableName2} from "myAnotherModule";
export * from "myAnotherModule";</pre></div><p>Here are the differences in these formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first format exports a variable.</li><li class="listitem" style="list-style-type: disc">The second format is used to export multiple variables.</li><li class="listitem" style="list-style-type: disc">The third format is used to export a variable with another name, that is, an alias.</li><li class="listitem" style="list-style-type: disc">The fourth format is used to export multiple variables with different names.</li><li class="listitem" style="list-style-type: disc">The fifth format uses <code class="literal">default</code> as the alias. We will find out the use of this later in this chapter.</li><li class="listitem" style="list-style-type: disc">The sixth format is similar to fourth format, but it also has the <code class="literal">default</code> alias.</li><li class="listitem" style="list-style-type: disc">The seventh format works similar to fifth format, but here you can place an expression instead of a variable name.</li><li class="listitem" style="list-style-type: disc">The eighth format is used to export the exported variables of a submodule.</li><li class="listitem" style="list-style-type: disc">The ninth format is used to export all the exported variables of a submodule.</li></ul></div><p>Here are some<a id="id496" class="indexterm"/> important things that you need to know about the <code class="literal">export</code> statement:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An export statement can be used anywhere in a module. It's not compulsory to use it at the end of the module.</li><li class="listitem" style="list-style-type: disc">There can be any number of <code class="literal">export</code> statements in a module.</li><li class="listitem" style="list-style-type: disc">You cannot export variables on demand. For example, placing the <code class="literal">export</code> statement in the <code class="literal">if…else</code> condition throws an error. Therefore, we can say that the module structure needs to be static, that is, exports can be determined on compile time.</li><li class="listitem" style="list-style-type: disc">You cannot export the same variable name or alias multiple times. But you can export a variable multiple times with a different alias.</li><li class="listitem" style="list-style-type: disc">All the code inside a module is executed in the <code class="literal">strict</code> mode by default.</li><li class="listitem" style="list-style-type: disc">The values of the exported variables can be changed inside the module that exported them.</li></ul></div></div><div class="section" title="Importing the ES6 modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec116"/>Importing the ES6 modules</h2></div></div></div><p>To import a module, we <a id="id497" class="indexterm"/>need to use the <code class="literal">import</code> statement. The <code class="literal">import</code> statement comes in many different formats. Here are the formats:</p><div class="informalexample"><pre class="programlisting">import x from "module-relative-path";
import {x} from "module-relative-path";
import {x1 as x2} from "module-relative-path";
import {x1, x2} from "module-relative-path";
import {x1, x2 as x3} from "module-relative-path";
import x, {x1, x2} from "module-relative-path";
import "module-relative-path";
import * as x from "module-relative-path";
import x1, * as x2 from "module-relative-path";</pre></div><p>An <code class="literal">import</code> statement consists of two parts: the variable names we want to import and the relative path of the module.</p><p>Here are the differences in these formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first format, the <code class="literal">default</code> alias is imported. The <code class="literal">x</code> is alias of the <code class="literal">default</code> alias.</li><li class="listitem" style="list-style-type: disc">In the second format, the <code class="literal">x</code> variable is imported.</li><li class="listitem" style="list-style-type: disc">The third format is the same as the second format. It's just that <code class="literal">x2</code> is an alias of <code class="literal">x1</code>.</li><li class="listitem" style="list-style-type: disc">In the fourth format, we import the <code class="literal">x1</code> and <code class="literal">x2</code> variables.</li><li class="listitem" style="list-style-type: disc">In the fifth format, we import the <code class="literal">x1</code> and <code class="literal">x2</code> variables. The <code class="literal">x3</code> is an alias of the <code class="literal">x2</code> variable.</li><li class="listitem" style="list-style-type: disc">In the sixth format, we import the <code class="literal">x1</code> and <code class="literal">x2</code> variable, and the <code class="literal">default</code> alias. The <code class="literal">x</code> is an alias of the <code class="literal">default</code> alias.</li><li class="listitem" style="list-style-type: disc">In the seventh format, we just import the module. We do not import any of the variables exported by the module.</li><li class="listitem" style="list-style-type: disc">In the eighth format, we import all the variables, and wrap them in an object called <code class="literal">x</code>. Even the <code class="literal">default</code> alias is imported.</li><li class="listitem" style="list-style-type: disc">The ninth format is the same as the eighth format. Here, we give another alias to the <code class="literal">default</code> alias.</li></ul></div><p>Here are some <a id="id498" class="indexterm"/>important things that you need to know about the <code class="literal">import</code> statement:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">While importing a variable, if we import it with an alias, then to refer to that variable, we have to use the alias and not the actual variable name, that is, the actual variable name will not be visible, only the alias will be visible.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">import</code> statement doesn't import a copy of the exported variables; rather, it makes the variables available in the scope of the program that imports it. Therefore, if you make a change to an exported variable inside the module, then the change is visible to the program that imports it.</li><li class="listitem" style="list-style-type: disc">The imported variables are read-only, that is, you cannot reassign them to something else outside of the scope of the module that exports them.</li><li class="listitem" style="list-style-type: disc">A module can only be imported once in a single instance of a JavaScript engine. If we try to import it again, then the already imported instance of the module will be used.</li><li class="listitem" style="list-style-type: disc">We cannot import modules on demand. For example, placing the <code class="literal">import</code> statement in the <code class="literal">if…else</code> condition throws an error. Therefore, we can say that the imports should be able to be determined on compile time.</li><li class="listitem" style="list-style-type: disc">The ES6 imports are faster than the AMD and CommonJS imports, because the ES6 imports are supported natively and also as importing modules and exporting variables are not decided on demand. Therefore, it makes JavaScript engine easier to optimize performance.</li></ul></div></div><div class="section" title="The module loader"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec117"/>The module loader</h2></div></div></div><p>A module loader is a <a id="id499" class="indexterm"/>component of a JavaScript engine that is responsible for importing modules.</p><p>The <code class="literal">import</code> statement uses the build-in module loader to import modules.</p><p>The built-in module loaders of the different JavaScript environments use different module loading mechanisms. For example, when we import a module in JavaScript running in the browsers, then the module is loaded from the server. On the other hand, when we import a module in Node.js, then the module is loaded from filesystem.</p><p>The module loader loads modules in a different manner, in different environments, to optimize the performance. For example, in the browsers, the module loader loads and executes modules asynchronously in order to prevent the importing of the modules that block the loading of a webpage.</p><p>You can programmatically interact with the built-in module loader using the module loader API to customize its behavior, intercept module loading, and fetch the modules on demand.</p><p>We can also use this API to create our own custom module loaders.</p><p>The specifications of the module loader are not specified in ES6. It is a separate standard, controlled by the<a id="id500" class="indexterm"/> <span class="strong"><strong>WHATWG</strong></span> browser standard group. You can find the specifications of the module loader at <a class="ulink" href="http://whatwg.github.io/loader/">http://whatwg.github.io/loader/</a>.</p><p>The ES6 specifications only specify the <code class="literal">import</code> and <code class="literal">export</code> statements.</p></div><div class="section" title="Using modules in browsers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Using modules in browsers</h2></div></div></div><p>The code <a id="id501" class="indexterm"/>inside the <code class="literal">&lt;script&gt;</code> tag doesn't support the <code class="literal">import</code> statement, because <a id="id502" class="indexterm"/>the tag's synchronous nature is incompatible with the asynchronicity of the modules in browsers. Instead, you need to use the new <code class="literal">&lt;module&gt;</code> tag to import modules.</p><p>Using the new <code class="literal">&lt;module&gt;</code> tag, we can define a script as a module. Now, this module can import other modules using the <code class="literal">import</code> statement.</p><p>If you want to import a module using the <code class="literal">&lt;script&gt;</code> tag, then you have to use the<a id="id503" class="indexterm"/> <span class="strong"><strong>Module Loader API</strong></span>.</p><p>The specifications of the <code class="literal">&lt;module&gt;</code> tag are not specified in ES6.</p></div><div class="section" title="Using modules in the eval() function"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec119"/>Using modules in the eval() function</h2></div></div></div><p>You cannot<a id="id504" class="indexterm"/> use<a id="id505" class="indexterm"/> the <code class="literal">import</code> and <code class="literal">export</code> statements in the <code class="literal">eval()</code> function. To import modules in the <code class="literal">eval()</code> function, you need to use the Module Loader API.</p></div><div class="section" title="The default exports vs. the named exports"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec120"/>The default exports vs. the named exports</h2></div></div></div><p>When we export a<a id="id506" class="indexterm"/> variable with the <code class="literal">default</code> alias, then it's called<a id="id507" class="indexterm"/> as a <span class="strong"><strong>default export</strong></span>. Obviously, there can only be one default export in a module, as an alias can be used only once.</p><p>All the other exports except the default export are called as <span class="strong"><strong>named exports</strong></span>.</p><p>It's recommended that a module should either use default export or named exports. It's not a good practice to use both together.</p><p>The default export is used when we want to export only one variable. On the other hand, the named exports are used when we want to export the multiple variables.</p></div><div class="section" title="Diving into an example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Diving into an example</h2></div></div></div><p>Let's create a basic JavaScript library using the <a id="id508" class="indexterm"/>ES6 modules. This will help us understand how to use the <code class="literal">import</code> and <code class="literal">export</code> statements. We will also learn how a module can import other modules.</p><p>The library that we will create is going to be a math library, which provides basic logarithmic and trigonometric functions. Let's get started with creating our library:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a file named <code class="literal">math.js</code>, and a directory named <code class="literal">math_modules</code>. Inside the <code class="literal">math_modules</code> directory, create two files named <code class="literal">logarithm.js</code> and <code class="literal">trigonometry.js,</code> respectively.<p>Here, the <code class="literal">math.js</code> file is the root module, whereas the <code class="literal">logarithm.js</code> and the <code class="literal">trigonometry.js</code> files are its submodules.</p></li><li class="listitem" style="list-style-type: disc">Place this code inside the <code class="literal">logarithm.js</code> file:<div class="informalexample"><pre class="programlisting">var LN2 = Math.LN2;
var N10 = Math.LN10;

function getLN2()
{
  return LN2;
}

function getLN10()
{
  return LN10;
}

export {getLN2, getLN10};</pre></div><p>Here, the module is exporting the functions named as exports.</p></li></ul></div><p>It's preferred that the<a id="id509" class="indexterm"/> low-level modules in a module hierarchy should export all the variables separately, because it may be possible that a program may need just one exported variable of a library. In this case, a program can import this module and a particular function directly. Loading all the modules when you need just one module is a bad idea in terms of performance.</p><p>Similarly, place this code in the <code class="literal">trigonometry.js</code> file:</p><div class="informalexample"><pre class="programlisting">var cos = Math.cos;
var sin = Math.sin;

function getSin(value)
{
  return sin(value);
}

function getCos(value)
{
  return cos(value);
}

export {getCos, getSin};</pre></div><p>Here we do something similar. Place this code inside the <code class="literal">math.js</code> file, which acts as the root module:</p><div class="informalexample"><pre class="programlisting">import * as logarithm from "math_modules/logarithm";
import * as trigonometry from "math_modules/trigonometry";

export default {
  logarithm: logarithm,
  trigonometry: trigonometry
}</pre></div><p>It doesn't contain any library functions. Instead, it makes easy for a program to import the complete library. It imports its submodules, and then exports their exported variables to the main program.</p><p>Here, in case the <code class="literal">logarithm.js</code> and <code class="literal">trigonometry.js</code> scripts depends on other submodules, then the <code class="literal">math.js</code> module shouldn't import those submodules, because <code class="literal">logarithm.js</code> and <code class="literal">trigonometry.js</code> are already importing them.</p><p>Here is the code <a id="id510" class="indexterm"/>using which a program can import the complete library:</p><div class="informalexample"><pre class="programlisting">import math from "math";

console.log(math.trigonometry.getSin(3));
console.log(math.logarithm.getLN2(3));</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we saw what modular programming is and learned different modular programming specifications. Finally, we created a basic library using the modular programming design technique. Now, you should be confident enough to build the JavaScript apps using the ES6 modules.</p></div></body></html>