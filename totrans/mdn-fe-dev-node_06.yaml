- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Web Apps with Bundlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered an important set of auxiliary tooling –
    linters and formatters. While code quality is important, the undoubtedly most
    important aspect of every project is what is shipped and used by the customer.
    This is the area where a special kind of tooling – called bundlers – shines.
  prefs: []
  type: TYPE_NORMAL
- en: A bundler is a tool that understands and processes source code to produce files
    that can be placed on a web server and are ready to be consumed by web browsers.
    It takes HTML, CSS, JavaScript, and related files into consideration to make them
    more efficient and readable. In this process, a bundler would merge, split, minify,
    and even translate code from one standard such as ES2020 into another standard
    such as ES5.
  prefs: []
  type: TYPE_NORMAL
- en: Today, bundlers are no longer nice to have, but necessarily used for most projects
    directly or indirectly. Pretty much every web framework offers tooling that is
    built upon a bundler. Often, the challenge is to configure a bundler so that it
    understands our code base and does exactly what we’d expect it to do. Since web
    code bases are quite different, bundlers need to be flexible in many directions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll build up an understanding of what bundlers do and how
    you can control their inner processes. We’ll also introduce the most important
    bundlers as of today, and see how they can be used and configured to work efficiently
    for us. This will help you get your web project from raw source code to production-ready
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the available bundlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using esbuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Parcel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter is available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3G0NiMX](https://bit.ly/3G0NiMX).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bundlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing a modern web application is quite difficult. One of the reasons for
    the level of difficulty is the large variety of different technologies that need
    to be involved in the process. Let’s just mention a few:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML for writing documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS for styling those documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript with the DOM API to bring some interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaScript UI framework to create interactive components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CSS preprocessor to use variables, nesting, and more features for CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially TypeScript or some other typed system to improve reliability in
    certain source code areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service and web workers need to be mastered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All static files should be easy to cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the introduction of a new class of tooling that was capable of building
    up module graphs, dedicated task runners such as **Grunt** or **Gulp** were used.
    These runners were inspired by more generic approaches such as **Makefiles**.
    The problem, however, was that two aspects – the build process and the source
    code – needed to be kept in sync. Just adding one file to the source code was
    not sufficient; the build process had to be informed about this new file. With
    bundlers, this all changed.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, a bundler is a tool that leverages other tools. The most important
    addition is that a bundler understands the module graph – that is, the relationships
    (imports and exports) of code modules such as the CommonJS or ESM modules we discussed
    in the previous chapters. It can build up a module graph and use that to let other
    tools such as Babel work.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, a bundler requires so-called entry points – quite often, these
    are referred to as entries. These are files that are used as roots in the module
    graph. These files may depend on other files, in which case the bundler will continue
    in these files to build up the module graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.1* shows an example module graph constructed from two entry points.
    The interesting property of this graph is that the content of **Entry 2** is fully
    contained in **Entry 1**, too. In many situations, there won’t be any significant
    overlap between the module graphs of multiple entry points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Example module graph constructed from two entry points ](img/Figure_6.1_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Example module graph constructed from two entry points
  prefs: []
  type: TYPE_NORMAL
- en: 'Most bundlers work in phases. While each bundler uses slightly different terminology,
    they almost always come with the following high-level phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Module resolution
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module transformation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chunk and asset generation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying optimizations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module transformation is often necessary. On the one hand, the bundler needs
    to understand the module to find imported modules to build up the module graph;
    on the other hand, the chunk generation must rely on normalized input modules.
  prefs: []
  type: TYPE_NORMAL
- en: While the transformation phase needs to work hand-in-hand with a resolver to
    continuously build up the module graph, all other phases are pretty much independent.
    Quite often, the optimization phase is either reduced or fully disabled during
    development. This reduction helps speed up the bundling process by a fair margin.
    Additionally, further instructions that are quite helpful during debugging will
    be kept.
  prefs: []
  type: TYPE_NORMAL
- en: Minification
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common optimizations is minification. The goal of minification
    is to make the files as small as possible without using active compression. While
    minification on the surface is rather easy and efficient in a language such as
    JavaScript, other languages such as CSS or HTML are a bit more problematic. Especially
    minification of HTML has been proven to be a hard problem without as many gains
    compared to the minification of JavaScript. After minification, files are usually
    not as readable as they were previously. One reason is the removal of unnecessary
    whitespace, which was introduced to give the original code readability and structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole bundling process can be sketched in a diagram. *Figure 6**.2* shows
    how the different entries enter the different phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – High-level phases of a modern web bundler ](img/Figure_6.2_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – High-level phases of a modern web bundler
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider is that the chunk generation will mostly also introduce
    some kind of JavaScript runtime. This can be as lightweight as teaching the resulting
    code how to load additional bundles that have been created as script files, but
    it can also include full support for loading shared dependencies from foreign
    code and more. The introduced code is fully bundler-specific.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s see what kind of bundlers are out there and how they
    compare.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing available bundlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple generations of bundlers. The first generation was centered
    around the belief that Node.js applications are the only kind of applications
    that should be written. Therefore, changing these applications into JavaScript
    files that work in the browser has been the primary concern of the bundlers from
    that generation. The most popular one in that category is **Browserify**.
  prefs: []
  type: TYPE_NORMAL
- en: The second generation went on to extend the idea from the first generation to
    pretty much all JavaScript code. Here, even HTML and CSS assets could be understood.
    For instance, using `@import` rules in CSS would extend the module graph to another
    CSS module. Importantly, while the *CommonJS* (or later on, *ESM*) syntax was
    still used to derive the JavaScript module graph, these second-generation bundlers
    did not care about Node.js. They always assumed that the code was written for
    the browser. Quite often, however, you could change the target and also bundle
    code for Node.js with them. The most popular one in this category is **Webpack**,
    even though Webpack always tried to go with the times and adapt.
  prefs: []
  type: TYPE_NORMAL
- en: Third-generation bundlers introduced a much-improved user experience. They tried
    to find a native or obvious way of handling things and often did not even require
    any configuration. The most popular tool in this category is the original *Parcel*
    bundler.
  prefs: []
  type: TYPE_NORMAL
- en: The current fourth-generation bundlers are all about performance. They either
    come with a dedicated runtime or sit on top of natively written tooling, which
    usually outperforms their older JavaScript-written counterparts. Here, we see
    tools such as **esbuild** or experimental runtimes such as **Bun**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is: When should you use what? With half a dozen popular bundlers
    and more available, the question is not easy to answer. Surely, if a team is already
    really familiar with one of the options, then going with it for a project is very
    often the right choice. Otherwise, look for similar projects and try to understand
    what bundler they picked – and why. In any other case, you could use the following
    catalog of questions to identify which bundler might be the best option:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of assets are involved? If only JavaScript is involved, then Webpack
    might be good. If you have multiple HTML pages that all need to be processed,
    then **Vite** might be a great option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many dependencies are you using? Especially when you use older libraries
    from npm, a bundler with a broad range of support – such as Webpack – may be the
    best choice. Otherwise, look for faster options, such as esbuild.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How familiar is the team with bundlers and their options? If the team is not
    familiar with bundling at all, then Parcel could be a great way to get started.
    Otherwise, Webpack potentially has the most documentation out there. A community
    that is rather new and very active and helpful can be found with Vite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you building an application or just want to optimize the assets of a library?
    Especially for a library, something smaller, such as esbuild, might be useful.
    On the other hand, Parcel has a lot to offer here, too. In general, Vite should
    be avoided for libraries. Support is there, but it just does not feel to be ready
    yet for building libraries more efficiently than Rollup.js and esbuild.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need support for advanced scenarios such as offline mode or web workers?
    In these cases, the ecosystem of Webpack is very often hard to beat. Parcel also
    does a good job of offering helpers in this area. esbuild should be avoided for
    such scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How important is performance? If you have a larger code base (above 1,000 modules
    or 100,000 lines of code), then Webpack is known to be a performance killer, taking
    easily 30 seconds to minutes. Picking something such as Vite or – if possible
    – esbuild will certainly help speed up the process. While the former is more developer
    friendly, it also comes with a lot of hidden complexity. The latter is more direct
    but lacks standard features such as **hot-module** **reloading** (**HMR**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much maintenance is acceptable? Bundlers that rely on a lot of plugins are
    traditionally much harder to maintain. Upgrading Webpack to the next major version
    has been notoriously difficult. From missing plugins to breaking changes in the
    plugin’s API – everything that can happen will also happen in such cases. Prefer
    bundlers such as Parcel or Vite that try to come with everything necessary out
    of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How important are additional development features such as bundle insights? If
    these are supercritical, then nothing is better than Webpack. As the Webpack ecosystem
    is super large, you’ll find additional tools, libraries, and guides easily. On
    the other hand, choosing something with a growing community such as Vite might
    also work fine. If something is missing, the community should be capable of picking
    it up quickly, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we’ll go over an example project to see how some
    of the most popular bundlers can be used to build it. We’ll use a project with
    a small, but non-trivial code base. For this example, we’ll use **React** – but
    don’t worry, you don’t need to know React to follow this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs: []
  type: TYPE_NORMAL
- en: React is arguably the most popular UI library for web frontend development.
    It allows developers to build UIs quickly in JavaScript by leveraging a language
    extension known as `Button` or `Carousel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code base for the example we’ll cover consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code of a **single-page** **application** (**SPA**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `index.html`) of the SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several asset files (videos, images in different formats, audio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several non-trivial dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some files that use TypeScript instead of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special **CSS** preprocessor called **SASS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web framework (React with React Router) is being used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different virtual routes should lead to different pieces of the page that have
    to be lazy loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, this example should produce a small demo application that contains
    a video and audio player that uses third-party dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading describes a technique where not all parts required by an application
    are loaded immediately. For a SPA, this makes sense – after all, not every component
    or part of the SPA will be required for the current user interaction. And even
    if it isn’t required, it could be at some later point in time. Lazy loading usually
    involves loading additional script (or other) files when some action such as a
    user clicking on a button or following some internal link is performed. The implementation
    of lazy loading needs to be supported by the respective UI framework (for example,
    React has a function called `lazy`) but is done by the bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boilerplate for this example can be created by initializing a new Node.js
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll add all the runtime dependencies – that is, the packages that will
    be required when our application runs in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the day, it will be the job of the bundler to add the preceding
    dependencies to scripts that can be run in the browser. However, for us, it makes
    sense to do this to get a clear view of which packages are just required for the
    tooling, and which dependencies are needed for the code to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic `devDependencies` – that is, the ones that are required for the tooling
    – are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Additional tooling dependencies are required, too, but will be bundler-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example application contains the following source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`: Template for the SPA website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script.tsx`: Starts to run the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App.tsx`: The application root'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Layout.tsx`: The layout of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Home.tsx`: The home page containing links to all pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Video.tsx`: The page containing the video player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Audio.tsx`: The page containing the audio player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player.jsx`: The React component for the video and audio player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`earth.mp4`: Video file to play'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`river.webp`: Preview image (`.webp` format) for the video file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snow.jpg`: Preview image (`.jpg` format) for the sound file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sound.mp3`: Audio file to play'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of showing a UI is usually called rendering. When React first renders
    the application, it needs to mount its component tree on the DOM tree. This is
    done in the `script.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: script.tsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The usage of angle brackets for initiating `App` is referred to as JSX. Under
    the hood, the additional `x` in the file extension (`tsx`) enables such expressions
    to be processed, where `<App />` will be transformed into `React.createElement(App)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App` component itself is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: App.tsx
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This kind of structure is typical for a SPA. All the different routes come together
    in a router or root component to be displayed when a certain path is found. For
    instance, in our application, the `/video` path would show the `Video` component,
    while the `/audio` path would show the `Audio` component. All these components
    will be embedded in a `Layout` component, which is responsible for the general
    layout, such as showing the header and the footer, of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the `App.tsx` file, lazy loading is initiated by using the ESM `import` function.
    Bundlers should be capable of transforming that into loading another script and
    returning a `Promise` at that location.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs: []
  type: TYPE_NORMAL
- en: The specification describes an `import` function to return a `Promise`. A `Promise`
    is an object that can be used to determine when an asynchronous operation is finished.
    The object exposes functions, which are called with the result of the asynchronous
    operation or with an error that was thrown during the operation. The most important
    functions are `then` and `catch`. The former can be used to define what to do
    when something is successfully returned, while the latter can be used to handle
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a SPA, it makes sense to put every page in a router into lazy loading. *Figure
    6**.3* shows a high-level overview of the example application’s modules. The dashed
    boxes indicate bundling areas – that is, source files that can be grouped into
    combined output files. This bundling is one of the most crucial aspects of any
    bundler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The example application’s modules ](img/Figure_6.3_B18989.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The example application’s modules
  prefs: []
  type: TYPE_NORMAL
- en: While some of the given aspects should be rather simple to implement in a bundler,
    other properties of the example application might be challenging. For instance,
    what is the behavior of a bundler when duplicate modules are found? Some bundlers
    may duplicate the generated code while others may create a shared bundle that
    is a loading prerequisite for the generated side bundles.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this example, we can see that `Player.jsx` appears twice. We’ll
    use this to answer the question for each bundler. Furthermore, pretty much every
    module requires `react`; however, since it is already required in the initial
    script module (`script.tsx`), it should not be duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s see how this example application can be bundled using
    Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Using Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is presumably the most popular option among the available bundlers.
    It is also among the oldest bundlers – dating back to a time when Node.js was
    still young and the whole idea of bundling was rather new. At this time, task
    runners were still dominantly used. However, the increasing complexity of frontend
    development opened the door for much more elaborate tooling.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that makes Webpack stand out is its ecosystem. From the very beginning,
    Webpack decided to develop only a very shallow core focusing on module resolution.
    In some sense, Webpack is just the wrapper holding all these plugins together
    with a fixed plan of execution. It pretty much combines the configuration that
    was thrown in by the user, with the power of all the selected plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Webpack can also work without plugins or a configuration. At least in
    theory. In practice, every project that goes beyond some simple examples will
    require a bit of configuration. Also, interesting features such as support for
    other languages such as TypeScript will require a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Webpack, we need to install the `webpack` and `webpack-cli`
    packages using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we only wanted to use Webpack programmatically, such as from a Node.js script,
    then we could also spare the `webpack-cli` package installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Webpack from the command line, you can use `npx` together with the `webpack`
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Just running Webpack like this will not be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the warning about `mode` is rather simple – all we need to do is to provide
    a CLI flag such as `--mode production`. The more problematic issue is that Webpack
    does not find any entry point.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned already, there is a chance that Webpack may just work, but usually,
    we’ll be forced to create a configuration file. Webpack uses real Node.js modules
    to provide the configuration, which gives us the full power of the Node.js ecosystem.
    A Webpack configuration is called `webpack.config.js` and should be placed next
    to the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a rather lightweight one. The highlighted property is one of Webpack’s
    fundamental configuration sections, telling the bundler what entry points to use:'
  prefs: []
  type: TYPE_NORMAL
- en: webpack.config.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try running Webpack again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better, but we’re still not there yet. Webpack requires a plugin to
    understand special files such as TypeScript or SASS sources. Therefore, we need
    to install these development dependencies, too. In this case, we require quite
    a list of plugins to make everything work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ts-loader` is a plugin for handling TypeScript files by transforming them
    into JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sass-loader` is a plugin for handling SASS files by transforming them into
    CSS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`css-loader` is a plugin for handling CSS by transforming it into a text module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style-loader` is a plugin for handling CSS by transforming it into a JavaScript
    module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babel-loader` is a plugin for using Babel to transform JavaScript files with
    additional syntax (such as JSX) into plain JS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html-webpack-plugin` is a plugin for loading an HTML file as a template for
    the output HTML file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big disadvantage of Webpack is that everything must be a JavaScript module
    in the end. Quite often, plugins perform some tricks to end up with empty modules,
    but they still emit the result (such as a separate image or CSS file) to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the remaining dependencies can be done from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing we also need to supply is a proper `tsconfig.json`. Without this
    file, TypeScript won’t be configured correctly. The `ts-loader` plugin of Webpack
    works quite closely together with TypeScripts, so it requires this file to know
    what files to consider and which files to drop. It also uses this to properly
    transform the file:'
  prefs: []
  type: TYPE_NORMAL
- en: tsconfig.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, TypeScript has been set up to process JSX in the default
    React way (that is, transforming JSX into `React.createElement` calls). The configuration
    will also output ESM module syntax (the highlighted option), which is important
    for Webpack to correctly identify imports and exports. Without this, bundle splitting
    won’t work if triggered from TypeScript files. Finally, we include all the files
    in the `src` folder and exclude the `node_modules` folder. The latter is a common
    practice to save a substantial amount of processing time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to get all these things working together, we need to extend the Webpack
    configuration quite a bit. First, we need to import (that is, `require`) all the
    plugins that we’d like to use. In this case, we only want to use `html-webpack-plugin`.
    Next, we need to set up the rules for all the loaders we need to include. This
    is done via the `module.rules` array. Finally, we need to define what to do with
    the remaining assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the Webpack configuration could be written to successfully bundle
    our example:'
  prefs: []
  type: TYPE_NORMAL
- en: webpack.config.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite lengthy. One of the often-heard criticisms of Webpack
    is that its configuration tends to become quite complex quickly.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of a Webpack configuration is the use of regular expressions.
    The `test` and `exclude` parts of a rule work best with a regular expression.
    Therefore, instead of having a string with some magic behavior or a very explicit
    and repetitive function, a regular expression is supplied that will check if the
    current module should be processed by this rule or not.
  prefs: []
  type: TYPE_NORMAL
- en: The options for each loader or plugin are determined by the respective loader
    or plugin. Therefore, knowing Webpack is not sufficient to successfully write
    a Webpack configuration. You’ll always need to look up the documentation of the
    different parts that are used in the configuration. In the preceding configuration,
    this has been the case with the `ts-loader` and `babel-loader` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders are evaluated from right to left. For instance, in the case of `*.scss`
    files, the content is first transformed by `sass-loader`, which then hands over
    to `css-loader`. In the end, all the content is packaged up as a `style` tag by
    `style-loader`.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t always need to use a dedicated package for loaders. Using the `type`
    property highlighted in the previous code, we can use some premade loaders from
    Webpack, such as the resource loader (`asset/resource`) to return the paths to
    referenced files. Other options include data URIs (`asset/inline`) and accessing
    a file’s raw content (`asset/source`).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to use Webpack is to start a small server during development. Whenever
    we make updates to the code, the bundler can reprocess the changed parts and automatically
    update any active browsing sessions. All in all, this is a very convenient and
    quite productive way of writing a frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Webpack’s live server to work, we’ll need to install yet another tooling
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to run the `serve` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The live server will keep on running until it is forcefully shut down. On the
    command line, this can be done by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to add to `webpack.config.js` would be the history API fallback for
    the development server (the `devServer` section in a Webpack configuration). This
    will improve the development experience of a SPA by a fair margin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This setting will respond to all 404 URLs with `index.html` of the root directory
    – just like a SPA should be configured in production mode. This way, refreshing
    when being on a page with a different path than `/` will still work. Without the
    shown configuration, the 404 error will be shown in the browser – no SPA will
    load and handle the route.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how bundling the example application works in Webpack, it’s
    time to look at a more lightweight alternative named esbuild.
  prefs: []
  type: TYPE_NORMAL
- en: Using esbuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: esbuild is quite a new tool that focuses on performance. The key to esbuild’s
    enhanced performance is that it was written from the ground up in the Go programming
    language. The result is a native binary that has certain advantages over pure
    JavaScript solutions.
  prefs: []
  type: TYPE_NORMAL
- en: If esbuild stopped at providing a native solution, it would potentially not
    be qualified to make this list. After all, flexibility and the option to extend
    the original functionality are key for any kind of bundler. Luckily, the creator
    of esbuild has thought about this and come up with an elegant solution. While
    the core of esbuild remains native – that is, written in Go and provided as a
    binary – plugins can be written using JavaScript. This way, we get the best of
    both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with esbuild, we need to install the `esbuild` package using
    npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this one installation, you can use esbuild programmatically, as well as
    directly from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run esbuild from the command line, you can use `npx` together with the `esbuild`
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show all the CLI options. To do something, at least one entry point
    needs to be supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we miss a few configuration steps. As with Webpack, the best way
    to teach esbuild about these extra bits is by creating a configuration. Unlike
    Webpack, we do not have a predefined configuration file – instead, the way to
    configure esbuild is by using it programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we must create a new file called `build.js` and import the `esbuild`
    package. We can use the `build` and `buildSync` functions to trigger the bundling
    process via esbuild.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous CLI command can be written programmatically like this:'
  prefs: []
  type: TYPE_NORMAL
- en: build.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the given script will essentially give us the same error as using
    the CLI directly. Therefore, let’s add a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`esbuild-sass-plugin` integrates the transformation of SASS into CSS files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@craftamap/esbuild-plugin-html` allows us to use template HTML files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can use these two plugins, we need to install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the plugins are installed, we can extend the `build.js` file so that it
    includes these two plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: build.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Along the way, we taught esbuild about our preference for the given file extensions.
    With the `loader` section, we map extensions to specific file loaders. The `file`
    type refers to a loader that will produce an external file. The import of that
    file will result in a reference to the file’s relative output path.
  prefs: []
  type: TYPE_NORMAL
- en: To enable bundle splitting, the `splitting` option needs to be set. This also
    makes the use of the `esm` format necessary. It’s the only format where esbuild
    knows how to produce scripts that can lazy load something. Additionally, `htmlPlugin`
    requires esbuild to produce a metafile to reflect the build artifacts. Therefore,
    the `metafile` option needs to be set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Like Webpack, the ecosystem of esbuild is what makes this tool so flexible,
    yet hard to master. The options for the different plugins need to be collected
    from the different plugin documentation. Like the Webpack ecosystem beforehand,
    the quality of these plugins, as well as their maturity and the community behind
    them, varies a lot.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to have a development server – just like the one we added to Webpack
    in the previous section – you can use the `serve` function, which can be imported
    from `esbuild`. The first argument describes server-specific settings such as
    the port where the service should be listening. The second argument comprises
    the build options – that is, the options we are supplying right now – as the only
    argument to the `build` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write another script called `serve.js` to illustrate this usage:'
  prefs: []
  type: TYPE_NORMAL
- en: serve.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: One thing that esbuild does not do at the moment is HMR. Consequently, the developer’s
    experience of just using esbuild may be a little bit underwhelming in that area
    when compared to similar tools.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s explore yet another option that is widely used for
    bundling – let’s have a look at the configuration-less Parcel bundler.
  prefs: []
  type: TYPE_NORMAL
- en: Using Parcel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Parcel arrived in the community, the hype around it was massive. The reason
    for this was to be found in one new feature: configuration-free bundling. Parcel
    tried to leverage information that was already given in `package.json` – or configuration
    files written for specific tools such as Babel. Using this mechanism, the creators
    of Parcel thought to remove the complexity of configuring a bundler.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, however, the whole aspect backfired in some sense. As mentioned
    previously, a bundler requires some flexibility. To achieve this kind of flexibility,
    a sound configuration system is necessary. While the configuration system of Webpack
    is a bit too verbose and complex, the one provided with esbuild might be a bit
    too low-level.
  prefs: []
  type: TYPE_NORMAL
- en: The successor of the original Parcel now also offers an optional configuration
    system, which tries to be right between the verbosity of Webpack and the low-level
    one of esbuild. This makes Parcel no longer configuration-free, but rather a configuration-less
    bundler.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Parcel, we need to install the `parcel` package using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this installation, you can use Parcel programmatically, as well as directly
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Parcel from the command line, you can use `npx` together with the `parcel`
    executable. For Parcel, the entry point can be the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we still need to modify the HTML so that it also points to the
    other source files to continue building up the module graph. A version of the
    `index.html` file that fits much better with Parcel would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, we’ve added the stylesheet and script entry points. These will
    be detected by Parcel and properly bundled. In the end, the HTML file will be
    used as a template – with the entry points being replaced by the bundled stylesheet
    and script file references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting Parcel right now will already partially work, but at this time, Parcel
    still has some problems with our audio and video files. While Parcel knows most
    image files (such as `*.webp` or `*.png`) already, some other assets need to be
    configured first. In Parcel, this means creating a `.parcelrc` file and adding
    a section about the transformers to use:'
  prefs: []
  type: TYPE_NORMAL
- en: .parcelrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The configuration instructs Parcel to still rely on the very well-chosen defaults.
    However, we also added the definitions for the two file types in question to the
    section that handles the transformation logic. Like Webpack or esbuild, Parcel
    also has an in-built type to handle such imports by returning a filename that
    can be used within the code. In the case of Parcel, this type is called `@parcel/transformer-raw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see if Parcel is already running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Parcel will start a development server. This already contains everything
    that is needed for developing an application. Quite convenient. If we want to
    build the files – for example, to place the output artifacts on a server – we
    can use the `build` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are CLI flags and options to set almost everything, such as the output
    directory. Nevertheless, by default, the quite common `dist` folder is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, let’s have a look at the quite trendy Vite bundler, which
    tries to combine the advantages of all previous approaches into a single tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest addition to the set of popular bundlers is Vite. It combines a few
    existing tools – such as Rollup.js and esbuild – together with a unified plugin
    system to allow rapid development. Vite’s approach is to give you the power of
    Webpack at the speed of esbuild.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, Vite was built by the creator of the frontend framework Vue. However,
    as time went on, Vite’s plugin system became a lot more powerful. With its increased
    API surface, other frontend frameworks such as React or Svelte could be supported.
    Now, Vite has evolved from a single-purpose tool to a real Swiss Army knife –
    thanks to a well-thought-out plugin mechanism with an active community.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Vite, we need to install the `vite` package using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this installation, you can use Vite programmatically, as well as directly
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to know about Vite is that it embraces having an `index.html` file
    as an entry point even more than Parcel. For Vite to work as intended, we need
    to move the `index.html` file from the `src` folder to the parent directory –
    that is, the project’s root folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did previously, we should set the references properly:'
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Vite from the command line, you can use `npx` together with the `vite`
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This starts quickly as nothing has been bundled or transformed yet. Only when
    we hit the server will Vite start to transform things – and only the things that
    we are currently looking at. If you are interested in a more realistic picture,
    then the `preview` subcommand can be handy. It does a production build but exposes
    the outcome via the development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, like with Parcel, we can still produce files that can be placed
    on a server. Very similar to Parcel, we can do this with the `build` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For this example, Vite is the only bundler that just works – at least once all
    the prerequisites have been fulfilled. If you require a custom configuration,
    such as for adding some plugins, then you can follow Webpack’s approach and create
    a `vite.config.js` file in the project’s root folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s recap what you’ve learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what a bundler is, why you need it, what bundlers
    exist, and how you can configure and use them. You are now able to take your web
    projects from their raw source code to build production-ready assets.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with detailed knowledge about bundlers, you can create very reliable
    code bases that are tailored toward efficiency. Not only will unnecessary code
    be removed upon bundling, but also all referenced files will be processed and
    taken into consideration. Therefore, you’ll never have to worry about missing
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: The large variety of existing bundlers can be intimidating at first. While there
    are some obvious choices, such as the very popular Webpack bundler, other options
    may be even better due to less complexity or better performance, depending on
    the project you have at hand. If in doubt, you can refer to the *Comparing available
    bundlers* section of this chapter to ascertain which bundler might be the best
    fit for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take closer look at another category of crucial
    development tools. We’ll see how testing tools give us confidence that our code
    works as it should, both today and in the future.
  prefs: []
  type: TYPE_NORMAL
