- en: Chapter 9. Modular Application Design and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章：模块化应用程序设计和测试
- en: Now that we have completed the implementation of our application, it is time
    for us to talk about testing it. Of course, we test our application to make sure
    things works as expected and that the future changes to our code-base do not break
    our application's functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了应用程序的实现，是时候讨论如何对其进行测试了。当然，我们测试应用程序是为了确保一切按预期工作，并且未来的代码库更改不会破坏应用程序的功能。
- en: One thing to keep in mind here, is that we are writing our tests after we have
    completed our implementation. However, there are times when we write our tests
    before our application's code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要记住的一件事是，我们是在完成实现后编写测试的。然而，有时我们会在编写应用程序代码之前编写测试。
- en: The idea is that we write our tests first and expect them to fail since there
    is no implementation of the code. Then, as we implement our application, our tests
    start passing and we can be sure that the implemented code behaves as expected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是我们首先编写测试，并预期它们会失败，因为没有代码实现。然后，随着我们实现应用程序，测试开始通过，我们可以确信实现的代码按预期运行。
- en: You may choose this approach over implementation first and testing later for
    your projects, but I would like to emphasize the point that, regardless of the
    approach, you need to write some automated tests!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在项目中选择这种方法，即先实现后测试，但我想要强调的是，无论采用哪种方法，你都需要编写一些自动化测试！
- en: With that in mind, in this chapter we are going to have a look at how we can
    write some unit tests, and how our modular approach in our application design
    makes writing automated tests easier and more maintainable. For brevity, we will
    only write unit tests for two of our modules but the principles discussed can
    be used to test our other modules too.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，在本章中，我们将探讨如何编写一些单元测试，以及我们的应用程序设计中模块化方法如何使编写自动化测试更加容易和可维护。为了简洁起见，我们只为两个模块编写单元测试，但讨论的原则也可以用于测试其他模块。
- en: 'In this chapter we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: How our modules can be tested individually
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何单独测试我们的模块
- en: Writing tests without the need for third-party frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需第三方框架编写测试
- en: Improving and streamlining our unit tests using third party tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方工具改进和简化我们的单元测试
- en: Using Jasmine as a testing framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jasmine 作为测试框架
- en: Using Mocha and its related assertion libraries as a testing framework
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mocha 及其相关断言库作为测试框架
- en: Advantages of writing automated tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自动化测试的优势
- en: As developers, our primary concern is to write code that can produce the expected
    functionality and results. While principle holds true, the way we achieve our
    final implementation goal is also very important.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们的主要关注点是编写能够产生预期功能和结果的代码。虽然这个原则是正确的，但我们实现最终实现目标的方式也非常重要。
- en: A properly designed application is not just about achieving the final goal of
    the application but it should also be about implementing an easily extensible
    and maintainable code-base.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计得当的应用程序不仅关乎实现应用程序的最终目标，还应该关于实现一个易于扩展和维护的代码库。
- en: Using a modular approach certainly helps us with achieving such objectives but
    as we make changes to our code-base, and as our application goes through its life
    cycle, we need to make sure all the pieces of the application still work properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 采用模块化方法当然有助于我们实现这些目标，但随着我们对代码库进行更改，以及我们的应用程序经历其生命周期，我们需要确保应用程序的所有部分仍然正常工作。
- en: When we make a change to one part of the application, we need to make sure that
    the change does not adversely affect the other parts of our code base. Of course,
    one way of assuring this, is to test everything manually and check every aspect
    of our application under all the circumstance that it was designed for.. But such
    an approach is not only time-consuming, it is also very tedious as we need to
    go through the same process for every single change in our application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对应用程序的一部分进行更改时，我们需要确保更改不会对代码库的其他部分产生不利影响。当然，确保这一点的其中一种方法是对所有内容进行手动测试，并检查应用程序在所有设计情况下设计的每个方面。但这种方法不仅耗时，而且非常繁琐，因为我们需要为应用程序的每一次更改都通过相同的过程。
- en: Also, especially in big projects, other developers could be working on various
    pieces of the application. How can we be sure that their changes would not have
    undesired effects on the parts of the application that we are responsible for?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，特别是在大型项目中，其他开发者可能正在处理应用程序的各个部分。我们如何确保他们的更改不会对我们负责的应用程序部分产生不希望的影响？
- en: Automated tests enable us to check the functionality that we expect from our
    code base, either in a targeted manner for a particular piece of code or for the
    entire application as a whole. We write the tests once, and then can run them
    many times at will, either when there is a change in the code-base or on a continuous
    basis as part of our regular and testing process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试使我们能够检查我们从代码库中期望的功能，无论是针对特定代码片段还是整个应用程序。我们一次编写测试，然后可以随意多次运行它们，无论是代码库发生变化还是作为我们常规测试过程的一部分。
- en: The other advantage of automated tests is that, as we are implementing our code,
    we get into the habit of considering how we can test the particular functionality
    using automated tests. This mindset results in writing better, more targeted and
    modular code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的另一个优点是，随着我们实现代码，我们养成了考虑如何使用自动化测试来测试特定功能的好习惯。这种思维方式导致编写更好、更针对性和模块化的代码。
- en: Different types of automated tests
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的自动化测试
- en: 'There are many different types of automated tests, but we will consider and
    talk about only three categories of such tests as listed here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的类型有很多，但我们将考虑并讨论以下列出的三个测试类别：
- en: Unit testing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End to end testing
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Unit testing
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are usually designed to test the functionality of individual pieces
    of our code in isolation. This usually means testing our functions and methods,
    one at a time, to make sure they do exactly what is expected of them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常设计为测试我们代码各个部分的功能，在隔离状态下进行。这通常意味着一次测试我们的函数和方法，以确保它们确实按照预期执行。
- en: We usually write such tests in a manner that can verify the functionality of
    our methods and individual pieces of our code in various scenarios.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常以可以验证我们的方法和代码各个部分在不同场景下的功能的方式编写此类测试。
- en: There are two main styles of writing unit tests; **Test Driven Development**
    (**TDD**) and **Behavioral Driven Development** (**BDD**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试有两种主要风格；**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**）。
- en: Let's have a simplified overview of what they are and how they are different.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对它们是什么以及它们如何不同有一个简化的概述。
- en: TDD unit tests
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD 单元测试
- en: TDD unit testing is mostly used to test the implementation of our code. This
    is done by testing the actual result that a method produces against what is expected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 单元测试主要用于测试我们代码的实现。这是通过测试方法产生的实际结果与预期结果进行比较来完成的。
- en: 'The TDD process can be thought of as the following loop, if we write our tests
    before the code implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码实现之前编写测试，TDD 流程可以被视为以下循环：
- en: Write a unit test
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Run the test and expect it to fail
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并预期它失败
- en: Write the code required to make the test pass
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使测试通过的代码
- en: Run the test again to make sure the test passes
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试以确保测试通过
- en: Re-factor the code if needed
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，重构代码
- en: Start from the first step again
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一步重新开始
- en: As you can see, TDD is meant to be implemented from the beginning of the project
    and to continue through the project's life cycle.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，TDD 的目的是从项目的开始阶段实施，并贯穿整个项目生命周期。
- en: BDD unit tests
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BDD 单元测试
- en: This style of testing is focused on the expected behavior of our code and not
    necessarily the implementation of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试风格关注的是我们代码的预期行为，而不是其实现。
- en: When we use BDD style of writing unit tests, we write our assertions in a way
    that can be read like a natural sentence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 BDD 风格编写单元测试时，我们以类似自然句子的方式编写我们的断言。
- en: For instance a test should read as, "returns a value that is incremented by
    1 from the previous value".
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试应该读作：“返回一个比前一个值增加 1 的值”。
- en: BDD can also follow the same process loop shown in the TDD section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 也可以遵循 TDD 部分中显示的相同过程循环。
- en: TDD versus BDD
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD 与 BDD
- en: Imagine that we have a function which is a counter, and when it is called for
    the first time, it will return the value 1 and every time after that, it will
    return the previous counter value plus 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个计数器函数，当它第一次被调用时，它将返回值 1，之后每次调用都将返回前一个计数器的值加 1。
- en: In TDD style of writing unit tests, we test that our function is initialized
    with the default value (start value) of zero, since that is tied with the very
    first time that the function is called.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD风格的单元测试编写中，我们测试函数是否以默认值（起始值）零初始化，因为这与函数第一次被调用时的非常第一次调用相关联。
- en: This detail (that the start value is 0) is an implementation aspect, and TDD
    style of writing tests checks for such implementation details. It also means that
    if we decide the default value (start value) in our counter function should change
    to 2, our test case also needs to change accordingly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个细节（起始值是0）是实现方面，TDD风格的测试编写检查这样的实现细节。这也意味着，如果我们决定在我们的计数器函数中，默认值（起始值）应该更改为2，我们的测试用例也需要相应地更改。
- en: In BDD style of writing unit tests, we don't check to see what the returned
    value is when the function is called for the very first time. We only check to
    see that every time the function is called the counter has been incremented by
    1\. This means that if we change the start value of the function at some later
    time, it has no effect on the expected behavior of the function. Our function
    should always increment the previous value by 1, regardless of the starting value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在BDD风格的单元测试编写中，我们不会检查函数第一次被调用时返回的值。我们只检查每次函数被调用时计数器是否增加了1。这意味着，如果我们后来改变函数的起始值，它对函数的预期行为没有影响。我们的函数应该始终将前一个值增加1，无论起始值是多少。
- en: The difference between TDD and BDD is very subtle but important to keep in mind.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TDD和BDD之间的区别非常微妙但很重要。
- en: In this chapter we will focus on writing unit tests in BDD style.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于以BDD风格编写单元测试。
- en: Test coverage
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: It is ideal to write enough unit tests to achieve 100 percent test coverage
    of our code. However, in reality, it is not always possible to write unit tests
    for every aspect of the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 写足够的单元测试以实现代码的100%测试覆盖率是理想的。然而，在现实中，并不总是可能为代码的每个方面编写单元测试。
- en: Of course, the more tests we write, the better the code quality we can expect,
    but time lines also need to be kept in mind for every project. In reality, we
    do not always have sufficient time to achieve the full coverage of our code base
    with unit tests. However, we should keep in mind that in the long run, we save
    more time on finding and fixing bugs when we have more code coverage with our
    tests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们编写的测试越多，我们预期的代码质量就越好，但每个项目的时间线也需要考虑。实际上，我们并不总是有足够的时间通过单元测试实现代码库的全面覆盖。然而，我们应该记住，从长远来看，当我们有更多的代码覆盖率时，我们在查找和修复错误上节省的时间会更多。
- en: In the absence of sufficient time, my recommendation is to make sure that you
    at least write unit tests for the core pieces of your application and cover them
    100 percent. Then, if time permits, turn your focus to other non-critical pieces
    of your application and write as many unit tests as you can for those pieces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间不足，我的建议是确保你至少为应用程序的核心部分编写单元测试，并覆盖100%。然后，如果时间允许，将你的注意力转向其他非关键部分，并为这些部分尽可能多地编写单元测试。
- en: This way, you can make sure of the quality and integrity of the application
    core and isolate possible issues in non-core and non-critical modules.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以确保应用程序核心的质量和完整性，并隔离非核心和非关键模块中可能的问题。
- en: Integration testing
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: This type of testing is mainly focused on making sure that different pieces
    of the application can work together properly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试主要关注确保应用程序的不同部分可以正确协同工作。
- en: When different methods and modules are involved to provide a certain functionality,
    we want to test and see if the desired functionality has been achieved by the
    sum of collaboration among such pieces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及不同的方法和模块以提供某种功能时，我们希望测试并查看这些组件之间的协作总和是否实现了所需的功能。
- en: An example could be that one function reads a string from a file and passes
    it to another function, which creates an array based on the comma delimiter in
    the string. Our integration test will make sure that the correct array was produced
    based on these two functions working together to read and process the string.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个函数可以从文件中读取一个字符串并将其传递给另一个函数，该函数根据字符串中的逗号分隔符创建一个数组。我们的集成测试将确保基于这两个函数一起读取和处理字符串，生成了正确的数组。
- en: End to end testing
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: These tests usually checks the flow of the application's functionality from
    the start to finish to make sure that the application as a whole is working properly
    and as intended.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试通常检查应用程序功能从开始到结束的流程，以确保整个应用程序按预期正常工作。
- en: For instance, to test the correct behavior of the application based on the form
    submission on a page, we can submit the form values to the server using an AJAX
    call, get the results from the server, and then refresh the content area of the
    application based on the returned values. By examining the final result, we can
    be sure that our application behaves as expected.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了测试基于页面表单提交的应用程序的正确行为，我们可以使用 AJAX 调用将表单值提交到服务器，从服务器获取结果，然后根据返回的值刷新应用程序的内容区域。通过检查最终结果，我们可以确信我们的应用程序按预期运行。
- en: '**End to end** (also known as **E2E**) testing is usually done after our unit
    tests and integration tests have passed.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端**（也称为**E2E**）测试通常在单元测试和集成测试通过后进行。'
- en: A simple start to writing our unit tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试的简单开始
- en: Writing unit tests is not about using the latest and greatest unit testing tools
    and libraries. It is simply about testing little pieces of the code in isolation.
    The simple fact which we should always keep in mind is that the main goal of unit
    testing is to ensure the proper functionality and integrity of our code. Even
    if you are not familiar with any unit testing tools, you can still write you own
    unit tests, using the skills that you already have in JavaScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试并不是关于使用最新和最好的单元测试工具和库。它只是关于在隔离状态下测试代码的小片段。我们应该始终牢记的一个简单事实是，单元测试的主要目标是确保我们代码的正确功能和完整性。即使您不熟悉任何单元测试工具，您仍然可以使用您在
    JavaScript 中已有的技能编写自己的单元测试。
- en: However, as you will see later in this chapter, using third-party tools and
    frameworks can greatly help us to write better and more sophisticated tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如您将在本章后面看到的那样，使用第三方工具和框架可以极大地帮助我们编写更好、更复杂的测试。
- en: For the rest of the chapter, we will target two of our sub-modules (`CookieHandler`
    and `StorageHandler`) and will write some simple unit tests for them. We will
    also explore how our modular architecture can help us write targeted and independent
    unit tests for each module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将针对两个子模块（`CookieHandler`和`StorageHandler`）进行目标测试，并为它们编写一些简单的单元测试。我们还将探讨我们的模块化架构如何帮助我们为每个模块编写有针对性的独立单元测试。
- en: Writing unit tests without any unit testing frameworks
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用任何单元测试框架编写单元测试
- en: While I don't recommend writing your unit tests without any help from third-party
    libraries and frameworks, my focus here is to get you started writing unit tests,
    regardless of whether you use a testing framework or not. Once you get started,
    you will slowly get used to the process and soon it will become a part of your
    regular development routine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不建议在没有第三方库和框架的帮助下编写单元测试，但我的重点是让您开始编写单元测试，无论您是否使用测试框架。一旦开始，您将逐渐习惯这个过程，很快它就会成为您常规开发流程的一部分。
- en: Thus, as a starting point, we will write our unit tests using plain JavaScript.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个起点，我们将使用纯 JavaScript 编写我们的单元测试。
- en: Adding an AppTester module to our application
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 AppTester 模块添加到我们的应用程序中
- en: As our client architecture is based on a modular design, we will continue with
    that approach and create a module that is responsible for running our unit tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的客户端架构基于模块化设计，我们将继续采用这种方法，创建一个负责运行我们的单元测试的模块。
- en: Have a look at how I have structured this module in our project.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我是如何在这个项目中构建这个模块的。
- en: '![Adding an AppTester module to our application](img/B04910_09_01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![将 AppTester 模块添加到我们的应用程序中](img/B04910_09_01.jpg)'
- en: 'The `AppTester` module resides in the `AppTester.js` file, and adds itself
    to our MainCore Module (`ImagesInc_Core`) as a sub-module, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppTester` 模块位于 `AppTester.js` 文件中，并将其作为子模块添加到我们的主核心模块（`ImagesInc_Core`）中，如下所示：'
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This sub-module exposes two methods: `runAllUnitTests` which runs all the unit
    tests that have been added to it and `reportTestResults` which is our unit test
    reporter responsible for displaying the result of our unit tests when they are
    run.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此子模块公开了两个方法：`runAllUnitTests`，它运行添加到其中的所有单元测试，以及`reportTestResults`，这是我们负责在运行时显示单元测试结果的单元测试报告器。
- en: Notice that we are using the logging mechanism of our core module for reporting
    our test results, which demonstrates the re-usability of our modules and sub-modules
    in different contexts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用核心模块的日志记录机制来报告我们的测试结果，这展示了我们的模块和子模块在不同上下文中的可重用性。
- en: Adding unit test suites to our test-runner
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将单元测试套件添加到我们的测试运行器
- en: We are going to add our unit tests to our test-runner `AppTester`, using the
    tight augmentation technique that you are now quite familiar with.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用你现在非常熟悉的紧耦合增强技术，将我们的单元测试添加到测试运行器 `AppTester` 中。
- en: Generally speaking, it is a good idea to have at least one test file per module
    which contains all the related unit tests for that module in our application.
    As such, we have two files in our project; `CookieHandlerTester.js` and `StorageHandlerTester.js`.
    As the names imply, one of them holds all the unit tests related to `CookieHandler`
    sub-module and the other contains all the related tests for `StorageHandler` sub-module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，为每个模块创建至少一个包含该模块所有相关单元测试的测试文件是一个好主意。因此，在我们的项目中，我们有两个文件；`CookieHandlerTester.js`
    和 `StorageHandlerTester.js`。正如其名称所暗示的，其中一个包含与 `CookieHandler` 子模块相关的所有单元测试，另一个包含与
    `StorageHandler` 子模块相关的所有测试。
- en: Keep in mind that if you create a large number of unit tests (the more, the
    better), you can further break down your unit tests into smaller chunks and files,
    which focus the different functionality of each module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您创建了大量的单元测试（越多越好），您可以进一步将单元测试分解成更小的块和文件，这些块和文件专注于每个模块的不同功能。
- en: In our application, since we have a limited number of unit tests, we have kept
    all of them in their related files, one file per module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，由于我们只有有限数量的单元测试，我们已将它们全部保留在其相关文件中，每个模块一个文件。
- en: In the following sections, we will only discuss one of them as they are both
    structured in a very similar manner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将只讨论其中之一，因为它们的结构非常相似。
- en: CookieHandler module unit tests
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CookieHandler 模块单元测试
- en: The unit test suite related to our `CookieHandler` sub-module is added to the
    `AppTester` module as an object property. This enables our test runner (`AppTester`)
    to easily loop through all of our unit tests and execute them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的 `CookieHandler` 子模块相关的单元测试套件被添加到 `AppTester` 模块作为一个对象属性。这使得我们的测试运行器（`AppTester`）能够轻松地遍历所有单元测试并执行它们。
- en: 'Consider the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note how we have added an object as a property to `AppTester` module. This object
    (test suite) has all the related tests as its properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将一个对象作为属性添加到 `AppTester` 模块中。这个对象（测试套件）拥有所有相关的测试作为其属性。
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every individual unit test is added to this object, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的单元测试都添加到该对象中，如下所示：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The array `unitTests` is used to run all of our tests using a loop when `AppTester`
    module calls the `cookieTester.runAllTests` method, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `unitTests` 用于在 `AppTester` 模块调用 `cookieTester.runAllTests` 方法时，通过循环运行所有测试，如下所示：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To run individual unit tests, we can call them by using their name identifier,
    directly on the `CookieTester` object, like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行单个单元测试，我们可以通过使用它们的名称标识符，直接在 `CookieTester` 对象上调用它们，如下所示：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That is why each individual unit test is added to both the `CookieTester` object
    and the `unitTests` array when defined, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，当定义时，每个单独的单元测试都被添加到 `CookieTester` 对象和 `unitTests` 数组中，如下所示：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I highly recommend that you have a look at the code related to the `AppTester`
    and `CookieHandlerTester` modules in the accompanying project for this chapter
    to see how they are implemented.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您查看本章附带项目中与 `AppTester` 和 `CookieHandlerTester` 模块相关的代码，以了解它们是如何实现的。
- en: Running CookieHandler unit tests
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 CookieHandler 单元测试
- en: In our project setup, since we are not using an automated build system, we can
    add the functionality to our `index.html` and our core module to run all the unit
    tests when `index.html` is loaded in the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目设置中，由于我们没有使用自动构建系统，我们可以将运行所有单元测试的功能添加到我们的 `index.html` 和核心模块中，以便在浏览器中加载
    `index.html` 时运行。
- en: Of course, we do not want to do this in a production environment. Usually, a
    good development environment leverages task runners such as **Grunt** or **Gulp**
    to run the unit tests as well as all the other client application build tasks
    such as linting, minifying and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想在生产环境中这样做。通常，一个好的开发环境会利用任务运行器，如 **Grunt** 或 **Gulp** 来运行单元测试以及所有其他客户端应用程序构建任务，如代码检查、压缩等。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not familiar with these task runners, please check the following
    resources online:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这些任务运行器，请查看以下在线资源：
- en: '[http://gruntjs.com/](http://gruntjs.com/)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gruntjs.com/](http://gruntjs.com/)'
- en: '[http://gulpjs.com/](http://gulpjs.com/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://gulpjs.com/](http://gulpjs.com/)'
- en: 'In our environment, to run the unit tests, we call the following method in
    our `index.html` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的环境中，为了运行单元测试，我们在`index.html`文件中调用以下方法：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`runAllUnitTests` method in our MainCore module, will use `AppTester` module
    to run all of our unit tests.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们MainCore模块中的`runAllUnitTests`方法将使用`AppTester`模块来运行所有我们的单元测试。
- en: 'Consider the following implementation in our MainCore module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们MainCore模块中的以下实现：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we first check to see if `AppTester` module is present, and if so, we
    call `runAllUnitTests` method on that module.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查`AppTester`模块是否存在，如果存在，我们就调用该模块上的`runAllUnitTests`方法。
- en: 'In `AppTester` module, the code loops through all the unit test suites (in
    our case, unit tests for the `CookieHandler` and `StorageHandler` modules) which
    are the properties of the `AppTester` object. This is shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppTester`模块中，代码会遍历所有单元测试套件（在我们的例子中，是`CookieHandler`和`StorageHandler`模块的单元测试），这些是`AppTester`对象上的属性。如下所示：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In turn, this method calls the `runAllTests` method on each unit test suite
    as you saw earlier:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个方法会依次调用每个单元测试套件上的`runAllTests`方法，正如你之前看到的：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because of our modular architecture, as we can add individual unit test suites
    for each module to our `AppTester` module; we can also remove them. This is done
    so in a similar way as we added `CookieHandler` test suite to `AppTester` but
    by removing the property related to test suite instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模块化架构，我们可以为每个模块添加单独的单元测试套件到`AppTester`模块中；我们也可以移除它们。这是通过类似我们添加`CookieHandler`测试套件到`AppTester`的方式完成的，但通过移除与测试套件相关的属性。
- en: When we run our unit tests by loading `index.html`, we will see the following
    output in the browser's console (I'm using Chrome Development Tools).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过加载`index.html`运行单元测试时，我们将在浏览器控制台中看到以下输出（我使用的是Chrome开发工具）。
- en: '![Running CookieHandler unit tests](img/B04910_09_02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![运行CookieHandler单元测试](img/B04910_09_02.jpg)'
- en: I recommend that you try writing some of your own unit tests and adding them
    to the application's test suites.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你尝试编写一些自己的单元测试并将它们添加到应用程序的测试套件中。
- en: All the needed setup for this has already been implemented for you in the accompanying
    code for this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为此所需的所有设置已经在本章的配套代码中为你实现了。
- en: Cleaning up after running our unit tests
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行单元测试后的清理
- en: It is always a good idea to design our unit tests in a way that they clean up
    after themselves, so any modification made either to the application or the environment
    is reset to its original state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 总是设计我们的单元测试，以便它们在完成后自行清理，这样对应用程序或环境所做的任何修改都会重置到其原始状态。
- en: If you look at the code for both of our unit test suites, there is a clean-up
    method in each one of them that does just that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们两个单元测试套件的代码，每个套件中都有一个清理方法，它正是这样做的。
- en: 'Consider the following method in `CookieHandlerTester.js`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`CookieHandlerTester.js`中的方法：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, since our unit tests add a few cookies to the browser, and manipulates
    them, we want to make sure that all the created cookies are removed and the environment
    is reset to its original state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于我们的单元测试向浏览器添加了一些cookie，并对其进行了操作，我们想确保所有创建的cookie都被删除，并且环境被重置到原始状态。
- en: '`CookieHandler.deleteAllCookies` method takes care of removing all the cookies
    in the browser.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`CookieHandler.deleteAllCookies` 方法负责清除浏览器中的所有cookie。'
- en: Writing unit tests using third party frameworks
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用第三方框架编写单元测试
- en: While it is possible to write our unit tests using only JavaScript and no third-party
    frameworks, it is a lot of manual work, even when writing a few simple tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以仅使用JavaScript而不使用第三方框架编写单元测试，但这需要大量的手动工作，即使只是编写一些简单的测试也是如此。
- en: Our approach in the previous section for writing unit tests was a good exercise
    but I think we can do much better by leveraging third-party frameworks designed
    specifically for this task. Such frameworks enable us to write more sophisticated
    tests with much less effort.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们编写单元测试的方法是一个很好的练习，但我认为我们可以通过利用专门为此任务设计的第三方框架做得更好。这些框架使我们能够以更少的努力编写更复杂的测试。
- en: In this section, I'll introduce you to two very popular third-party frameworks,
    which allow us to write good, clean, and professional-grade unit tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你介绍两个非常流行的第三方框架，它们允许我们编写良好、干净且专业级的单元测试。
- en: The goal here is to give you a good starting point and provide you with a general
    overview of each library, but we will not explore any of them in great depth.
    Nevertheless, I'm hoping to get you excited enough about using third-party unit
    testing libraries (frameworks) that you will spend some time getting to know them
    better on your own and use them in your future projects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是给你一个良好的起点，并提供每个库的一般概述，但我们不会深入探讨任何一个。尽管如此，我希望能够激发你对使用第三方单元测试库（框架）的兴趣，让你花些时间自己更好地了解它们，并在未来的项目中使用它们。
- en: Introduction to Jasmine
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jasmine简介
- en: Jasmine defines itself as "a behavior-driven development framework for testing
    JavaScript code."
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine将自己定义为“一个用于测试JavaScript代码的行为驱动开发框架。”
- en: Jasmine does not require a DOM and can be used for writing and running JavaScript
    unit tests both on the server and client side.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine不需要DOM，可以在服务器端和客户端编写和运行JavaScript单元测试。
- en: Setting up **Jasmine** is easy, especially on the client side, and is created
    in a way that provides all the functionality that you may require from a professional-grade
    testing framework in one package. I think you will find the syntax quite intuitive
    and easy to follow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设置**Jasmine**很简单，尤其是在客户端，并且以提供所有可能从专业级测试框架中需要的功能的方式打包。我认为你会发现语法非常直观且易于理解。
- en: I personally like Jasmine quite a bit and am very grateful to its creators for
    providing us with such a great tool.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人非常喜欢Jasmine，非常感谢其创造者为我们提供如此出色的工具。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this section, I''ll be using Jasmine 2.4 and encourage you to visit the
    related site at: [http://jasmine.github.io/](http://jasmine.github.io/).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用Jasmine 2.4，并鼓励你访问相关网站：[http://jasmine.github.io/](http://jasmine.github.io/)。
- en: Setting up Jasmine
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置Jasmine
- en: When you visit Jasmine's site, you will be presented with a link to download
    the standalone version of the framework, which is the version that we will be
    using for our unit tests here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问Jasmine的网站时，你会看到一个下载框架独立版本的链接，这是我们在这里将用于单元测试的版本。
- en: 'After downloading the zip file, and extracting its contents, you will see the
    following structure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下载zip文件并提取其内容后，你会看到以下结构：
- en: '![Setting up Jasmine](img/B04910_09_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![设置Jasmine](img/B04910_09_03.jpg)'
- en: We will be using a similar file structure for our tests, however, without the
    need for the `src` folder, which is the location of the source files that Jasmine
    loads to run the tests against.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的测试使用类似的文件结构，但是不需要`src`文件夹，这是Jasmine加载以运行测试的源文件的位置。
- en: In our tests, we will be loading `MainCore` module and `CookieHandler` module
    directly from where they reside currently in our project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将直接从它们目前在项目中的位置加载`MainCore`模块和`CookieHandler`模块。
- en: The `lib` folder is where all the source code for Jasmine itself is kept and
    the `spec` folder is where we will store our test specs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`文件夹是Jasmine本身的源代码存放的地方，而`spec`文件夹是我们将存储我们的测试规范的地方。'
- en: 'Here is how the final file structure has been implemented in our application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，这是最终文件结构是如何实现的：
- en: '![Setting up Jasmine](img/B04910_09_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![设置Jasmine](img/B04910_09_04.jpg)'
- en: 'In order to load our test specs in `SpecRunner.html`, we need to make the following
    modifications to this file, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`SpecRunner.html`中加载我们的测试规范，我们需要对这个文件进行以下修改，如下所示：
- en: '![Setting up Jasmine](img/B04910_09_05.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![设置Jasmine](img/B04910_09_05.jpg)'
- en: As you can see, we have pointed `SpecRunner.html` to the file locations of our
    `MainCore` and `CookieHandler` modules in the application, instead of using the
    default Jasmine `src` folder.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将`SpecRunner.html`指向了应用程序中`MainCore`和`CookieHandler`模块的文件位置，而不是使用默认的Jasmine
    `src`文件夹。
- en: That is all we have to do to get Jasmine set up and ready for use in our client
    application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为了在客户端应用程序中使用Jasmine设置和准备所需做的所有事情。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why load MainCore.js?**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么加载MainCore.js？**'
- en: As you may have noticed in `SpecRunner.html`, I'm loading both the `MainCore.js`
    and `CookieHandler.js` files. This is not necessary, as long as `CookieHandler.js`
    returns a global object, which can then be used in `CookieHandlerSpec.js` to run
    the tests against. In such a scenario, `CookieHandler` object will act as an independent
    module, thanks to our modular architecture. However, to keep the code as is, I
    load MainCore module first and then use `CookieHandler` as a sub-module of MainCore;
    thus both files need to be loaded.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 `SpecRunner.html` 中可能已经注意到的，我在加载 `MainCore.js` 和 `CookieHandler.js` 文件。这并不是必要的，只要
    `CookieHandler.js` 返回一个全局对象，然后就可以在 `CookieHandlerSpec.js` 中使用它来运行测试。在这种情况下，`CookieHandler`
    对象将作为一个独立的模块运行，这要归功于我们的模块化架构。然而，为了保持代码不变，我首先加载 MainCore 模块，然后使用 `CookieHandler`
    作为 MainCore 的子模块；因此，这两个文件都需要被加载。
- en: Creating our Jasmine spec file
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建我们的 Jasmine spec 文件
- en: To write and run our tests, we need to first create the structure of our spec
    file. We do this by implementing our test suites.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和运行我们的测试，我们首先需要创建我们的 spec 文件的结构。我们通过实现我们的测试套件来完成这项工作。
- en: 'A test suite is constructed using `describe` function of Jasmine framework.
    This function takes two parameters, a string which describe the test suite and
    a callback function used to implement the test suite itself. This is shown below:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件是通过 Jasmine 框架的 `describe` 函数构建的。这个函数接受两个参数，一个字符串用于描述测试套件，一个回调函数用于实现测试套件本身。如下所示：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inside the callback function is where we write our test specs. Keep in mind
    that we can nest `describe` functions too. This means that we can use one `describe`
    function to create a test suite for the whole module and use nested `describe`
    functions inside that to create test suites for each individual method of the
    module. Also, any variables that we declare inside a `describe` function is available
    to all the specs which reside inside that `describe` block.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数内部是我们编写测试 spec 的地方。请注意，我们也可以嵌套 `describe` 函数。这意味着我们可以使用一个 `describe` 函数来创建整个模块的测试套件，并在其中使用嵌套的
    `describe` 函数来为模块的每个单独的方法创建测试套件。此外，在 `describe` 函数内部声明的任何变量都可以在该 `describe` 块内的所有
    spec 中使用。
- en: 'Let''s have a look at our first spec for `CookieHandler` sub-module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `CookieHandler` 子模块的第一个 spec：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have used the outer `describe` function to encapsulate all
    the unit tests related to `CookieHandler` sub-module. Inside that, we are using
    another `describe` function to write the related specs for `createCookie` method
    of this sub-module. The `it` function is where we write our expectations, which
    are our assertions about the method that we are testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了外部的 `describe` 函数来封装与 `CookieHandler` 子模块相关的所有单元测试。在这个内部，我们使用另一个 `describe`
    函数来编写与该子模块的 `createCookie` 方法相关的相关 spec。`it` 函数是我们编写预期的地方，这些预期是我们对正在测试的方法的断言。
- en: The expectations use matchers to implement a comparison between the actual value
    and the expected value. Jasmine comes with a slew of built-in matchers but it
    also provides us with the ability to write our own custom matchers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 预期使用匹配器来实现实际值和预期值之间的比较。Jasmine 提供了一系列内置匹配器，但它也允许我们编写自己的自定义匹配器。
- en: In the code snippet above, we are telling Jasmine to check to see if `cookieHandler.createCookie`
    has been defined.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们告诉 Jasmine 检查 `cookieHandler.createCookie` 是否已定义。
- en: Notice how we are describing our tests using strings passed to `describe` and
    `it` methods. When the tests are run, these strings should read like sentences,
    describing what our tests are, and what kind of results we should be expecting
    from running such tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用传递给 `describe` 和 `it` 方法的字符串来描述我们的测试的。当运行测试时，这些字符串应该像句子一样阅读，描述我们的测试是什么，以及运行此类测试时应期望得到什么样的结果。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Important point to keep in mind when writing unit tests**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写单元测试时需要注意的重要点**'
- en: Ideally, we want each unit test to only test one functionality, and not have
    any dependency on another functionality in the code. For instance, if we want
    to test that a method can read from a cookie, we should only test that and not
    if we can write to the cookie first, and then read the value, all in one test
    spec. In some of our specs we have not followed such a rule. To eliminate these
    types of dependencies, we need to use **spies**, **stubs**, and **mocks** which
    require more in-depth knowledge of our testing frameworks as they are considered
    more advanced features. Since, this is only an introduction to unit testing, such
    advanced functionality of the frameworks are beyond the scope of this book, but
    I highly recommend that you research them further on your own as such features
    are very useful in writing unit tests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望每个单元测试只测试一个功能，而不依赖于代码中的另一个功能。例如，如果我们想测试一个方法能否从 cookie 中读取，我们应只测试这一点，而不是先测试能否写入
    cookie，然后再读取值，所有这些都在一个测试规范中完成。在我们的某些规范中，我们没有遵循这样的规则。为了消除这些类型的依赖，我们需要使用 **间谍**、**存根**和**模拟**，这些需要更深入地了解我们的测试框架，因为它们被认为是更高级的功能。由于这只是一个单元测试的介绍，这些框架的高级功能超出了本书的范围，但我强烈建议您自行进一步研究，因为这些功能在编写单元测试时非常有用。
- en: Running our Jasmine unit tests
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行我们的 Jasmine 单元测试
- en: 'We can run our unit tests by loading `SpecRunner.html` in the browser. When
    our tests have completed running, we will see the following results displayed
    in our browser window:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在浏览器中加载 `SpecRunner.html` 来运行我们的单元测试。当我们的测试完成运行后，我们将在浏览器窗口中看到以下结果：
- en: '![Running our Jasmine unit tests](img/B04910_09_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的 Jasmine 单元测试](img/B04910_09_06.jpg)'
- en: As you can see, the sentence in our test suite tells us what method the group
    of tests belongs to, and the sentence in our assertion tells us what the test
    is for.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试套件中的句子告诉我们这组测试属于哪个方法，而断言中的句子告诉我们测试的目的。
- en: 'Our results show that all of our tests are passing. If one of our tests fails,
    Jasmine notifies us as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果显示，所有测试都通过了。如果我们的某个测试失败，Jasmine 会如下通知我们：
- en: '![Running our Jasmine unit tests](img/B04910_09_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的 Jasmine 单元测试](img/B04910_09_07.jpg)'
- en: The message shows us what test has failed along with a stack trace related to
    that test. This allows us to quickly identify the failing test and look into what
    needs to be done to fix it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 消息显示失败的测试以及与该测试相关的堆栈跟踪。这使我们能够快速识别失败的测试，并查看需要做什么来修复它。
- en: Exploring Jasmine further
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步探索 Jasmine
- en: Jasmine is a complete testing framework for JavaScript. My goal was to only
    introduce you to it, and give a very quick overview of some of its capabilities.
    However, Jasmine provides much more functionality to satisfy any testing needs
    that you might have, such as using **spies**, **stubs**, and **mocks**, as well
    as support for asynchronous testing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是一个完整的 JavaScript 测试框架。我的目标是仅向您介绍它，并快速概述其一些功能。然而，Jasmine 提供了更多功能以满足您可能有的任何测试需求，例如使用
    **间谍**、**存根**和**模拟**，以及支持异步测试。
- en: I recommend that you first have a look at the test suite that I have created
    for our `CookieHandler` sub-module, in the code accompanying this chapter. Then,
    go to Jasmine's website and learn more about the framework. I think once you start
    using Jasmine, you will be very impressed with its capabilities and ease of use.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您首先查看我为本章代码中 `CookieHandler` 子模块创建的测试套件。然后，访问 Jasmine 网站，了解更多关于该框架的信息。我认为一旦您开始使用
    Jasmine，您会对它的功能和易用性印象深刻。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, refer to the following link: [http://jasmine.github.io/2.4/introduction.html](http://jasmine.github.io/2.4/introduction.html)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅以下链接：[http://jasmine.github.io/2.4/introduction.html](http://jasmine.github.io/2.4/introduction.html)
- en: Introduction to Mocha
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha 简介
- en: Mocha is another great testing framework which allows us to use any assertion
    library that we like, and provides great flexibility in that aspect. As indicated
    on Mocha's website, "*if it throws an error, it will work!"*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是另一个优秀的测试框架，它允许我们使用我们喜欢的任何断言库，并在这一方面提供了极大的灵活性。正如 Mocha 网站上所指示的，“*如果它抛出错误，它就会工作！*”。
- en: We will be using **Chai** assertion library in our tests and we will talk about
    this library very shortly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中使用 **Chai** 断言库，我们很快就会讨论这个库。
- en: Mocha can be run both on the server and the client side and it supports both
    BDD and TDD style tests. We can also use different reporters with Mocha, such
    as **Dot Matrix** and **List**.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 可以在服务器端和客户端运行，并且它支持 BDD 和 TDD 风格的测试。我们还可以使用不同的报告器与 Mocha 一起使用，例如 **点阵**
    和 **列表**。
- en: For our purposes, we will be focusing on how to run Mocha in the browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将专注于如何在浏览器中运行 Mocha。
- en: Setting up Mocha
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 Mocha
- en: To set up Mocha for running our tests in the browser, we can use `sample.html`
    file that Mocha provides on its website.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要为在浏览器中运行我们的测试设置 Mocha，我们可以使用 Mocha 网站上提供的 `sample.html` 文件。
- en: 'In this file, Mocha is loaded using a **content delivery network** (**CDN**).
    We can also download the framework from GitHub, at: [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们使用 **内容分发网络**（**CDN**）加载 Mocha。我们也可以从 GitHub 下载框架，地址为：[https://github.com/mochajs/mocha](https://github.com/mochajs/mocha)。
- en: 'For our application, I have downloaded Mocha and created the following structure
    in the project:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我已经下载了 Mocha，并在项目中创建了以下结构：
- en: '![Setting up Mocha](img/B04910_09_08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Mocha](img/B04910_09_08.jpg)'
- en: In the preceding screenshot, `MochaRunner.html` is our test-runner page and
    loads Mocha, Chai (the assertion library), our source file (`StorageHandlerSpec.js`),
    and the related spec file, `storageHandlerSpec.js`. This file stores all of our
    Mocha tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`MochaRunner.html` 是我们的测试运行页面，它加载 Mocha、Chai（断言库）、我们的源文件（`StorageHandlerSpec.js`）以及相关的
    spec 文件，`storageHandlerSpec.js`。此文件存储了所有我们的 Mocha 测试。
- en: 'This is how our `MochaRunner.html` is set up:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `MochaRunner.html` 的设置方式：
- en: '![Setting up Mocha](img/B04910_09_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Mocha](img/B04910_09_09.jpg)'
- en: As you can see, we are also telling Mocha that we will be using BDD style test
    specs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们也在告诉 Mocha 我们将使用 BDD 风格的测试规范。
- en: This is all we have to do to implement a simple setup for Mocha.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现 Mocha 简单设置所需做的所有事情。
- en: Chai
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Chai
- en: Chai is a very popular assertion library that integrates well with Mocha and
    provides different assertion styles. In my opinion, one of the best assertion
    styles to use is **Expect**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个非常流行的断言库，它与 Mocha 集成良好，并提供不同的断言风格。在我看来，最好的断言风格之一是 **Expect**。
- en: I think you will find Expect syntax similar to Jasmine assertion syntax and
    easy to understand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你会发现 Expect 语法与 Jasmine 断言语法相似，并且容易理解。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use Chai, you can simply download the code (copy/paste) from the following
    location and add it to your project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Chai，您可以从以下位置下载代码（复制/粘贴）并将其添加到您的项目中：
- en: '[http://chaijs.com/chai.js](http://chaijs.com/chai.js)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://chaijs.com/chai.js](http://chaijs.com/chai.js)'
- en: As you saw previously, I have already downloaded and installed Chai in the project
    library and it is ready for us to use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，我已经在项目库中下载并安装了 Chai，并且它已准备好供我们使用。
- en: Creating our Mocha spec file
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建我们的 Mocha 测试文件
- en: The setup for a Mocha `spec` file is very similar to Jasmine's spec file. We
    create our test suites using the global `describe` function and pass it a callback
    function which contains the code for our assertions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha `spec` 文件的设置与 Jasmine 的 spec 文件非常相似。我们使用全局的 `describe` 函数创建我们的测试套件，并将其传递一个包含我们断言代码的回调函数。
- en: Just as with Jasmine, we use strings to identify our tests and use `it` function
    to write our assertions. Also, similar to Jasmine, we can use nested `describe`
    blocks, and any variable defined in a `describe` block is available to all the
    assertions in that block.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Jasmine 一样，我们使用字符串来标识我们的测试，并使用 `it` 函数来编写我们的断言。同样，类似于 Jasmine，我们可以使用嵌套的 `describe`
    块，并且在该块中定义的任何变量都对该块中的所有断言可用。
- en: 'Have a look at the following code snippet from our `storageHandlerSpec.js`
    file as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下来自我们的 `storageHandlerSpec.js` 文件中的代码片段，如下所示：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we have set the variable `expect` on `chai.expect` global object,
    and then this variable is used in our assertions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将变量 `expect` 设置在 `chai.expect` 全局对象上，然后这个变量被用于我们的断言中。
- en: Chai provides a great set of matchers which we can use in writing our unit tests.
    However, the set of matchers provided by Chai is not as complete as Jasmine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 提供了一组很好的匹配器，我们可以在编写单元测试时使用。然而，Chai 提供的匹配器集合并不像 Jasmine 那样完整。
- en: For instance, to use spies, stubs, and mocks, which are considered more advanced
    testing features, we need to use a different library such as **Sinon**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用间谍（spies）、存根（stubs）和模拟（mocks），这些被认为是更高级的测试功能，我们需要使用不同的库，例如 **Sinon**。
- en: 'Since such features are beyond the scope of this book, we will not explore
    them here but I encourage you to visit Sinon''s web site for more information
    at: [http://sinonjs.org/](http://sinonjs.org/).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些功能超出了本书的范围，我们在此不会探讨它们，但我鼓励您访问 Sinon 的网站以获取更多信息：[http://sinonjs.org/](http://sinonjs.org/)。
- en: Running our Mocha-Chai unit tests
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行我们的 Mocha-Chai 单元测试
- en: 'If we load our project''s `MochaRunner.html` file in the browser, we will see
    the following test results displayed, after all the tests are run:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中加载项目的 `MochaRunner.html` 文件，在所有测试运行完毕后，我们将看到以下测试结果显示：
- en: '![Running our Mocha-Chai unit tests](img/B04910_09_10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的 Mocha-Chai 单元测试](img/B04910_09_10.jpg)'
- en: Of course, the check marks beside our tests indicate that the tests have passed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们测试旁边的勾选标记表示测试已通过。
- en: 'The following image shows the page when one of our tests fails:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了我们的测试失败时的页面：
- en: '![Running our Mocha-Chai unit tests](img/B04910_09_11.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的 Mocha-Chai 单元测试](img/B04910_09_11.jpg)'
- en: As you can see, to report a related error, Mocha uses the string that we have
    passed to `it` function of our test spec.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了报告相关错误，Mocha 使用我们传递给测试规范中 `it` 函数的字符串。
- en: Exploring Mocha further
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步探索 Mocha
- en: Using Mocha in conjunction with Chai and Sinon enables us to create a robust
    testing framework. We can even go beyond that by leveraging Mocha on the server
    side as part of our client's build system. This allows us to set up and run our
    tests automatically as one of the build steps, using **Node.js**. Furthermore,
    while not specific to Mocha, using **GitHub** as our source repository enables
    us to upload our Mocha tests into GitHub and have our tests run automatically
    in various browsers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Mocha 与 Chai 和 Sinon 结合使用，使我们能够创建一个健壮的测试框架。我们甚至可以通过在客户端构建系统中利用 Mocha 作为服务器端的一部分来更进一步。这使得我们可以将测试自动设置为构建步骤之一，使用
    **Node.js**。此外，虽然这并非特定于 Mocha，但使用 **GitHub** 作为我们的源代码库使我们能够将 Mocha 测试上传到 GitHub，并在各种浏览器中自动运行我们的测试。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can get a lot more information regarding this feature at the following
    site:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网站上获取更多有关此功能的信息：
- en: '[https://ci.testling.com/](https://ci.testling.com/)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://ci.testling.com/](https://ci.testling.com/)'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about various types of tests and why continuous testing
    of our code is important to the integrity of our application as a whole. One of
    the ways to implement continuous testing is using unit tests.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了各种测试类型以及为什么持续测试我们的代码对于整个应用程序的完整性至关重要。实现持续测试的一种方法就是使用单元测试。
- en: We explored how we can write some simple unit tests using plain JavaScript and
    saw that using third-party testing frameworks enables us to have more capable
    and robust tests in our application, with much less effort.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用纯JavaScript编写一些简单的单元测试，并发现使用第三方测试框架可以使我们在应用程序中拥有更强大和健壮的测试，而且所需的工作量更少。
- en: Using a modular architecture, allows us to easily test our modules in isolation
    and to quickly find and fix possible issues in our code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块化架构，我们可以轻松地对我们的模块进行单独测试，并快速找到和修复代码中可能的问题。
- en: We also glanced over two very popular open source testing frameworks, Jasmine
    and Mocha. However, we barely scratched the surface of the capabilities that these
    frameworks offer, and I encourage you to explore them further on your own.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了两个非常流行的开源测试框架，Jasmine 和 Mocha。然而，我们对这些框架提供的功能只是浅尝辄止，我鼓励您自己进一步探索它们。
- en: All the tests shown in this chapter are included in the source code accompanying
    this book, and I highly recommend that you have a look at the test suites and
    spend some time to become familiar with them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有测试都包含在本书附带的源代码中，我强烈建议您查看测试套件，并花些时间熟悉它们。
- en: In the next chapter, we will look at different approaches for loading modules
    into our application and see how we can manage module dependencies using industry's
    best practices.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将模块加载到我们的应用程序中的不同方法，并了解我们如何使用行业最佳实践来管理模块依赖关系。
