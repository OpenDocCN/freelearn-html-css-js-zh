- en: Chapter 9. Modular Application Design and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have completed the implementation of our application, it is time
    for us to talk about testing it. Of course, we test our application to make sure
    things works as expected and that the future changes to our code-base do not break
    our application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind here, is that we are writing our tests after we have
    completed our implementation. However, there are times when we write our tests
    before our application's code.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we write our tests first and expect them to fail since there
    is no implementation of the code. Then, as we implement our application, our tests
    start passing and we can be sure that the implemented code behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You may choose this approach over implementation first and testing later for
    your projects, but I would like to emphasize the point that, regardless of the
    approach, you need to write some automated tests!
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, in this chapter we are going to have a look at how we can
    write some unit tests, and how our modular approach in our application design
    makes writing automated tests easier and more maintainable. For brevity, we will
    only write unit tests for two of our modules but the principles discussed can
    be used to test our other modules too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How our modules can be tested individually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests without the need for third-party frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving and streamlining our unit tests using third party tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jasmine as a testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Mocha and its related assertion libraries as a testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of writing automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, our primary concern is to write code that can produce the expected
    functionality and results. While principle holds true, the way we achieve our
    final implementation goal is also very important.
  prefs: []
  type: TYPE_NORMAL
- en: A properly designed application is not just about achieving the final goal of
    the application but it should also be about implementing an easily extensible
    and maintainable code-base.
  prefs: []
  type: TYPE_NORMAL
- en: Using a modular approach certainly helps us with achieving such objectives but
    as we make changes to our code-base, and as our application goes through its life
    cycle, we need to make sure all the pieces of the application still work properly.
  prefs: []
  type: TYPE_NORMAL
- en: When we make a change to one part of the application, we need to make sure that
    the change does not adversely affect the other parts of our code base. Of course,
    one way of assuring this, is to test everything manually and check every aspect
    of our application under all the circumstance that it was designed for.. But such
    an approach is not only time-consuming, it is also very tedious as we need to
    go through the same process for every single change in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Also, especially in big projects, other developers could be working on various
    pieces of the application. How can we be sure that their changes would not have
    undesired effects on the parts of the application that we are responsible for?
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests enable us to check the functionality that we expect from our
    code base, either in a targeted manner for a particular piece of code or for the
    entire application as a whole. We write the tests once, and then can run them
    many times at will, either when there is a change in the code-base or on a continuous
    basis as part of our regular and testing process.
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage of automated tests is that, as we are implementing our code,
    we get into the habit of considering how we can test the particular functionality
    using automated tests. This mindset results in writing better, more targeted and
    modular code.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different types of automated tests, but we will consider and
    talk about only three categories of such tests as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End to end testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are usually designed to test the functionality of individual pieces
    of our code in isolation. This usually means testing our functions and methods,
    one at a time, to make sure they do exactly what is expected of them.
  prefs: []
  type: TYPE_NORMAL
- en: We usually write such tests in a manner that can verify the functionality of
    our methods and individual pieces of our code in various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main styles of writing unit tests; **Test Driven Development**
    (**TDD**) and **Behavioral Driven Development** (**BDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a simplified overview of what they are and how they are different.
  prefs: []
  type: TYPE_NORMAL
- en: TDD unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD unit testing is mostly used to test the implementation of our code. This
    is done by testing the actual result that a method produces against what is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TDD process can be thought of as the following loop, if we write our tests
    before the code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a unit test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test and expect it to fail
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code required to make the test pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test again to make sure the test passes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-factor the code if needed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start from the first step again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, TDD is meant to be implemented from the beginning of the project
    and to continue through the project's life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: BDD unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This style of testing is focused on the expected behavior of our code and not
    necessarily the implementation of it.
  prefs: []
  type: TYPE_NORMAL
- en: When we use BDD style of writing unit tests, we write our assertions in a way
    that can be read like a natural sentence.
  prefs: []
  type: TYPE_NORMAL
- en: For instance a test should read as, "returns a value that is incremented by
    1 from the previous value".
  prefs: []
  type: TYPE_NORMAL
- en: BDD can also follow the same process loop shown in the TDD section.
  prefs: []
  type: TYPE_NORMAL
- en: TDD versus BDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that we have a function which is a counter, and when it is called for
    the first time, it will return the value 1 and every time after that, it will
    return the previous counter value plus 1.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD style of writing unit tests, we test that our function is initialized
    with the default value (start value) of zero, since that is tied with the very
    first time that the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: This detail (that the start value is 0) is an implementation aspect, and TDD
    style of writing tests checks for such implementation details. It also means that
    if we decide the default value (start value) in our counter function should change
    to 2, our test case also needs to change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In BDD style of writing unit tests, we don't check to see what the returned
    value is when the function is called for the very first time. We only check to
    see that every time the function is called the counter has been incremented by
    1\. This means that if we change the start value of the function at some later
    time, it has no effect on the expected behavior of the function. Our function
    should always increment the previous value by 1, regardless of the starting value.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between TDD and BDD is very subtle but important to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will focus on writing unit tests in BDD style.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is ideal to write enough unit tests to achieve 100 percent test coverage
    of our code. However, in reality, it is not always possible to write unit tests
    for every aspect of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the more tests we write, the better the code quality we can expect,
    but time lines also need to be kept in mind for every project. In reality, we
    do not always have sufficient time to achieve the full coverage of our code base
    with unit tests. However, we should keep in mind that in the long run, we save
    more time on finding and fixing bugs when we have more code coverage with our
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of sufficient time, my recommendation is to make sure that you
    at least write unit tests for the core pieces of your application and cover them
    100 percent. Then, if time permits, turn your focus to other non-critical pieces
    of your application and write as many unit tests as you can for those pieces.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can make sure of the quality and integrity of the application
    core and isolate possible issues in non-core and non-critical modules.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of testing is mainly focused on making sure that different pieces
    of the application can work together properly.
  prefs: []
  type: TYPE_NORMAL
- en: When different methods and modules are involved to provide a certain functionality,
    we want to test and see if the desired functionality has been achieved by the
    sum of collaboration among such pieces.
  prefs: []
  type: TYPE_NORMAL
- en: An example could be that one function reads a string from a file and passes
    it to another function, which creates an array based on the comma delimiter in
    the string. Our integration test will make sure that the correct array was produced
    based on these two functions working together to read and process the string.
  prefs: []
  type: TYPE_NORMAL
- en: End to end testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These tests usually checks the flow of the application's functionality from
    the start to finish to make sure that the application as a whole is working properly
    and as intended.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to test the correct behavior of the application based on the form
    submission on a page, we can submit the form values to the server using an AJAX
    call, get the results from the server, and then refresh the content area of the
    application based on the returned values. By examining the final result, we can
    be sure that our application behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**End to end** (also known as **E2E**) testing is usually done after our unit
    tests and integration tests have passed.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple start to writing our unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing unit tests is not about using the latest and greatest unit testing tools
    and libraries. It is simply about testing little pieces of the code in isolation.
    The simple fact which we should always keep in mind is that the main goal of unit
    testing is to ensure the proper functionality and integrity of our code. Even
    if you are not familiar with any unit testing tools, you can still write you own
    unit tests, using the skills that you already have in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you will see later in this chapter, using third-party tools and
    frameworks can greatly help us to write better and more sophisticated tests.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the chapter, we will target two of our sub-modules (`CookieHandler`
    and `StorageHandler`) and will write some simple unit tests for them. We will
    also explore how our modular architecture can help us write targeted and independent
    unit tests for each module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests without any unit testing frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While I don't recommend writing your unit tests without any help from third-party
    libraries and frameworks, my focus here is to get you started writing unit tests,
    regardless of whether you use a testing framework or not. Once you get started,
    you will slowly get used to the process and soon it will become a part of your
    regular development routine.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, as a starting point, we will write our unit tests using plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an AppTester module to our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As our client architecture is based on a modular design, we will continue with
    that approach and create a module that is responsible for running our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at how I have structured this module in our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an AppTester module to our application](img/B04910_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `AppTester` module resides in the `AppTester.js` file, and adds itself
    to our MainCore Module (`ImagesInc_Core`) as a sub-module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This sub-module exposes two methods: `runAllUnitTests` which runs all the unit
    tests that have been added to it and `reportTestResults` which is our unit test
    reporter responsible for displaying the result of our unit tests when they are
    run.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are using the logging mechanism of our core module for reporting
    our test results, which demonstrates the re-usability of our modules and sub-modules
    in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding unit test suites to our test-runner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to add our unit tests to our test-runner `AppTester`, using the
    tight augmentation technique that you are now quite familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, it is a good idea to have at least one test file per module
    which contains all the related unit tests for that module in our application.
    As such, we have two files in our project; `CookieHandlerTester.js` and `StorageHandlerTester.js`.
    As the names imply, one of them holds all the unit tests related to `CookieHandler`
    sub-module and the other contains all the related tests for `StorageHandler` sub-module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you create a large number of unit tests (the more, the
    better), you can further break down your unit tests into smaller chunks and files,
    which focus the different functionality of each module.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, since we have a limited number of unit tests, we have kept
    all of them in their related files, one file per module.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will only discuss one of them as they are both
    structured in a very similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: CookieHandler module unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unit test suite related to our `CookieHandler` sub-module is added to the
    `AppTester` module as an object property. This enables our test runner (`AppTester`)
    to easily loop through all of our unit tests and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how we have added an object as a property to `AppTester` module. This object
    (test suite) has all the related tests as its properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Every individual unit test is added to this object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The array `unitTests` is used to run all of our tests using a loop when `AppTester`
    module calls the `cookieTester.runAllTests` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To run individual unit tests, we can call them by using their name identifier,
    directly on the `CookieTester` object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That is why each individual unit test is added to both the `CookieTester` object
    and the `unitTests` array when defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I highly recommend that you have a look at the code related to the `AppTester`
    and `CookieHandlerTester` modules in the accompanying project for this chapter
    to see how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Running CookieHandler unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our project setup, since we are not using an automated build system, we can
    add the functionality to our `index.html` and our core module to run all the unit
    tests when `index.html` is loaded in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we do not want to do this in a production environment. Usually, a
    good development environment leverages task runners such as **Grunt** or **Gulp**
    to run the unit tests as well as all the other client application build tasks
    such as linting, minifying and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not familiar with these task runners, please check the following
    resources online:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gruntjs.com/](http://gruntjs.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gulpjs.com/](http://gulpjs.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our environment, to run the unit tests, we call the following method in
    our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`runAllUnitTests` method in our MainCore module, will use `AppTester` module
    to run all of our unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following implementation in our MainCore module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first check to see if `AppTester` module is present, and if so, we
    call `runAllUnitTests` method on that module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `AppTester` module, the code loops through all the unit test suites (in
    our case, unit tests for the `CookieHandler` and `StorageHandler` modules) which
    are the properties of the `AppTester` object. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In turn, this method calls the `runAllTests` method on each unit test suite
    as you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because of our modular architecture, as we can add individual unit test suites
    for each module to our `AppTester` module; we can also remove them. This is done
    so in a similar way as we added `CookieHandler` test suite to `AppTester` but
    by removing the property related to test suite instead.
  prefs: []
  type: TYPE_NORMAL
- en: When we run our unit tests by loading `index.html`, we will see the following
    output in the browser's console (I'm using Chrome Development Tools).
  prefs: []
  type: TYPE_NORMAL
- en: '![Running CookieHandler unit tests](img/B04910_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I recommend that you try writing some of your own unit tests and adding them
    to the application's test suites.
  prefs: []
  type: TYPE_NORMAL
- en: All the needed setup for this has already been implemented for you in the accompanying
    code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up after running our unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to design our unit tests in a way that they clean up
    after themselves, so any modification made either to the application or the environment
    is reset to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the code for both of our unit test suites, there is a clean-up
    method in each one of them that does just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following method in `CookieHandlerTester.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, since our unit tests add a few cookies to the browser, and manipulates
    them, we want to make sure that all the created cookies are removed and the environment
    is reset to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: '`CookieHandler.deleteAllCookies` method takes care of removing all the cookies
    in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests using third party frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is possible to write our unit tests using only JavaScript and no third-party
    frameworks, it is a lot of manual work, even when writing a few simple tests.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach in the previous section for writing unit tests was a good exercise
    but I think we can do much better by leveraging third-party frameworks designed
    specifically for this task. Such frameworks enable us to write more sophisticated
    tests with much less effort.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll introduce you to two very popular third-party frameworks,
    which allow us to write good, clean, and professional-grade unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to give you a good starting point and provide you with a general
    overview of each library, but we will not explore any of them in great depth.
    Nevertheless, I'm hoping to get you excited enough about using third-party unit
    testing libraries (frameworks) that you will spend some time getting to know them
    better on your own and use them in your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jasmine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine defines itself as "a behavior-driven development framework for testing
    JavaScript code."
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine does not require a DOM and can be used for writing and running JavaScript
    unit tests both on the server and client side.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up **Jasmine** is easy, especially on the client side, and is created
    in a way that provides all the functionality that you may require from a professional-grade
    testing framework in one package. I think you will find the syntax quite intuitive
    and easy to follow.
  prefs: []
  type: TYPE_NORMAL
- en: I personally like Jasmine quite a bit and am very grateful to its creators for
    providing us with such a great tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, I''ll be using Jasmine 2.4 and encourage you to visit the
    related site at: [http://jasmine.github.io/](http://jasmine.github.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Jasmine
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you visit Jasmine's site, you will be presented with a link to download
    the standalone version of the framework, which is the version that we will be
    using for our unit tests here.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the zip file, and extracting its contents, you will see the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Jasmine](img/B04910_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will be using a similar file structure for our tests, however, without the
    need for the `src` folder, which is the location of the source files that Jasmine
    loads to run the tests against.
  prefs: []
  type: TYPE_NORMAL
- en: In our tests, we will be loading `MainCore` module and `CookieHandler` module
    directly from where they reside currently in our project.
  prefs: []
  type: TYPE_NORMAL
- en: The `lib` folder is where all the source code for Jasmine itself is kept and
    the `spec` folder is where we will store our test specs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the final file structure has been implemented in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Jasmine](img/B04910_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to load our test specs in `SpecRunner.html`, we need to make the following
    modifications to this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Jasmine](img/B04910_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have pointed `SpecRunner.html` to the file locations of our
    `MainCore` and `CookieHandler` modules in the application, instead of using the
    default Jasmine `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: That is all we have to do to get Jasmine set up and ready for use in our client
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why load MainCore.js?**'
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed in `SpecRunner.html`, I'm loading both the `MainCore.js`
    and `CookieHandler.js` files. This is not necessary, as long as `CookieHandler.js`
    returns a global object, which can then be used in `CookieHandlerSpec.js` to run
    the tests against. In such a scenario, `CookieHandler` object will act as an independent
    module, thanks to our modular architecture. However, to keep the code as is, I
    load MainCore module first and then use `CookieHandler` as a sub-module of MainCore;
    thus both files need to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Jasmine spec file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write and run our tests, we need to first create the structure of our spec
    file. We do this by implementing our test suites.
  prefs: []
  type: TYPE_NORMAL
- en: 'A test suite is constructed using `describe` function of Jasmine framework.
    This function takes two parameters, a string which describe the test suite and
    a callback function used to implement the test suite itself. This is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Inside the callback function is where we write our test specs. Keep in mind
    that we can nest `describe` functions too. This means that we can use one `describe`
    function to create a test suite for the whole module and use nested `describe`
    functions inside that to create test suites for each individual method of the
    module. Also, any variables that we declare inside a `describe` function is available
    to all the specs which reside inside that `describe` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at our first spec for `CookieHandler` sub-module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the outer `describe` function to encapsulate all
    the unit tests related to `CookieHandler` sub-module. Inside that, we are using
    another `describe` function to write the related specs for `createCookie` method
    of this sub-module. The `it` function is where we write our expectations, which
    are our assertions about the method that we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: The expectations use matchers to implement a comparison between the actual value
    and the expected value. Jasmine comes with a slew of built-in matchers but it
    also provides us with the ability to write our own custom matchers.
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippet above, we are telling Jasmine to check to see if `cookieHandler.createCookie`
    has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we are describing our tests using strings passed to `describe` and
    `it` methods. When the tests are run, these strings should read like sentences,
    describing what our tests are, and what kind of results we should be expecting
    from running such tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important point to keep in mind when writing unit tests**'
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we want each unit test to only test one functionality, and not have
    any dependency on another functionality in the code. For instance, if we want
    to test that a method can read from a cookie, we should only test that and not
    if we can write to the cookie first, and then read the value, all in one test
    spec. In some of our specs we have not followed such a rule. To eliminate these
    types of dependencies, we need to use **spies**, **stubs**, and **mocks** which
    require more in-depth knowledge of our testing frameworks as they are considered
    more advanced features. Since, this is only an introduction to unit testing, such
    advanced functionality of the frameworks are beyond the scope of this book, but
    I highly recommend that you research them further on your own as such features
    are very useful in writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Running our Jasmine unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can run our unit tests by loading `SpecRunner.html` in the browser. When
    our tests have completed running, we will see the following results displayed
    in our browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our Jasmine unit tests](img/B04910_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the sentence in our test suite tells us what method the group
    of tests belongs to, and the sentence in our assertion tells us what the test
    is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our results show that all of our tests are passing. If one of our tests fails,
    Jasmine notifies us as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our Jasmine unit tests](img/B04910_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The message shows us what test has failed along with a stack trace related to
    that test. This allows us to quickly identify the failing test and look into what
    needs to be done to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Jasmine further
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Jasmine is a complete testing framework for JavaScript. My goal was to only
    introduce you to it, and give a very quick overview of some of its capabilities.
    However, Jasmine provides much more functionality to satisfy any testing needs
    that you might have, such as using **spies**, **stubs**, and **mocks**, as well
    as support for asynchronous testing.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you first have a look at the test suite that I have created
    for our `CookieHandler` sub-module, in the code accompanying this chapter. Then,
    go to Jasmine's website and learn more about the framework. I think once you start
    using Jasmine, you will be very impressed with its capabilities and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information, refer to the following link: [http://jasmine.github.io/2.4/introduction.html](http://jasmine.github.io/2.4/introduction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocha is another great testing framework which allows us to use any assertion
    library that we like, and provides great flexibility in that aspect. As indicated
    on Mocha's website, "*if it throws an error, it will work!"*.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using **Chai** assertion library in our tests and we will talk about
    this library very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha can be run both on the server and the client side and it supports both
    BDD and TDD style tests. We can also use different reporters with Mocha, such
    as **Dot Matrix** and **List**.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we will be focusing on how to run Mocha in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mocha
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set up Mocha for running our tests in the browser, we can use `sample.html`
    file that Mocha provides on its website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, Mocha is loaded using a **content delivery network** (**CDN**).
    We can also download the framework from GitHub, at: [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, I have downloaded Mocha and created the following structure
    in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Mocha](img/B04910_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, `MochaRunner.html` is our test-runner page and
    loads Mocha, Chai (the assertion library), our source file (`StorageHandlerSpec.js`),
    and the related spec file, `storageHandlerSpec.js`. This file stores all of our
    Mocha tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our `MochaRunner.html` is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Mocha](img/B04910_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we are also telling Mocha that we will be using BDD style test
    specs.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we have to do to implement a simple setup for Mocha.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Chai is a very popular assertion library that integrates well with Mocha and
    provides different assertion styles. In my opinion, one of the best assertion
    styles to use is **Expect**.
  prefs: []
  type: TYPE_NORMAL
- en: I think you will find Expect syntax similar to Jasmine assertion syntax and
    easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use Chai, you can simply download the code (copy/paste) from the following
    location and add it to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://chaijs.com/chai.js](http://chaijs.com/chai.js)'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw previously, I have already downloaded and installed Chai in the project
    library and it is ready for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Mocha spec file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The setup for a Mocha `spec` file is very similar to Jasmine's spec file. We
    create our test suites using the global `describe` function and pass it a callback
    function which contains the code for our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with Jasmine, we use strings to identify our tests and use `it` function
    to write our assertions. Also, similar to Jasmine, we can use nested `describe`
    blocks, and any variable defined in a `describe` block is available to all the
    assertions in that block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet from our `storageHandlerSpec.js`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have set the variable `expect` on `chai.expect` global object,
    and then this variable is used in our assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Chai provides a great set of matchers which we can use in writing our unit tests.
    However, the set of matchers provided by Chai is not as complete as Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to use spies, stubs, and mocks, which are considered more advanced
    testing features, we need to use a different library such as **Sinon**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since such features are beyond the scope of this book, we will not explore
    them here but I encourage you to visit Sinon''s web site for more information
    at: [http://sinonjs.org/](http://sinonjs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Running our Mocha-Chai unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we load our project''s `MochaRunner.html` file in the browser, we will see
    the following test results displayed, after all the tests are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our Mocha-Chai unit tests](img/B04910_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, the check marks beside our tests indicate that the tests have passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the page when one of our tests fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our Mocha-Chai unit tests](img/B04910_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, to report a related error, Mocha uses the string that we have
    passed to `it` function of our test spec.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Mocha further
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using Mocha in conjunction with Chai and Sinon enables us to create a robust
    testing framework. We can even go beyond that by leveraging Mocha on the server
    side as part of our client's build system. This allows us to set up and run our
    tests automatically as one of the build steps, using **Node.js**. Furthermore,
    while not specific to Mocha, using **GitHub** as our source repository enables
    us to upload our Mocha tests into GitHub and have our tests run automatically
    in various browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get a lot more information regarding this feature at the following
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://ci.testling.com/](https://ci.testling.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about various types of tests and why continuous testing
    of our code is important to the integrity of our application as a whole. One of
    the ways to implement continuous testing is using unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how we can write some simple unit tests using plain JavaScript and
    saw that using third-party testing frameworks enables us to have more capable
    and robust tests in our application, with much less effort.
  prefs: []
  type: TYPE_NORMAL
- en: Using a modular architecture, allows us to easily test our modules in isolation
    and to quickly find and fix possible issues in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We also glanced over two very popular open source testing frameworks, Jasmine
    and Mocha. However, we barely scratched the surface of the capabilities that these
    frameworks offer, and I encourage you to explore them further on your own.
  prefs: []
  type: TYPE_NORMAL
- en: All the tests shown in this chapter are included in the source code accompanying
    this book, and I highly recommend that you have a look at the test suites and
    spend some time to become familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at different approaches for loading modules
    into our application and see how we can manage module dependencies using industry's
    best practices.
  prefs: []
  type: TYPE_NORMAL
