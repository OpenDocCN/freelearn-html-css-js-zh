- en: Mastering the Art of Defining Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how to create types from libraries that we are
    not working directly with but importing inside our TypeScript project. The main
    difference is that when consuming code outside our project, we will not use TypeScript
    code directly, but its definition. The reason is that JavaScript is provided in
    those libraries, not TypeScript code. We will see how it is possible to master
    the art of creating definition files for code that does not provide them, allowing
    us to keep working in a strong environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use a third-party library definition file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How TypeScript can generate a definition file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manually add a definition file for a JavaScript project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to merge types into an existing definition file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a definition file for a JavaScript project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for a strong type but want to use a JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need to use another module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add a definition file to an extension of an existing module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a third-party library definition file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript works well when it knows the type of every variable and function.
    However, when using third-party libraries written in JavaScript, you do not have
    a definition file. TypeScript is smart and tries to infer type as much as it can
    by leveraging the standard documentation JSDoc, but nothing beats a signature
    written with TypeScript rules. However, there are many useful libraries written
    in JavaScript that do not have TypeScript’s types. A definition file fills the
    gap between JavaScript and TypeScript. For a third-party library, the idea is
    to use a definition file. The definition file source can come from a manual edition
    if the original library is written in JavaScript or generated automatically by
    TypeScript if coded in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a third-party library definition file, you need to have the file in
    our project. The TypeScript definition file is a .d.ts extension. TypeScript will
    search for a definition file in the `node_modules` folder as well as in our project.
    Because TypeScript uses the `node_modules`, it means it can fetch definition files
    from NPM. TypeScript has one of the most active GitHub repositories, which has
    over 4,200 definition files supported by the community. They are all accessible
    using NPM under `@types`. Here is an example of how to get JQuery definition files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The rising popularity of TypeScript made many libraries incorporate the definition
    file directly into their main npm package. For example, Redux, has `index.d.ts`
    at the root of the main `npm` package. It means that you may already have the
    definition files without noticing. The reason library brings the definition files
    directly in the NPM package is that the versions of the types are always synchronized
    with the code. It has also benefited people who use JavaScript and using a code
    editor that can read the definition file. Some code editors can leverage the definition
    file to provide autocomplete features.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the `node_modules`, TypeScript reads the configuration `types` and
    `typeroots` in the `tsconfig.json` file. For further details, refer to [Chapter
    1](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml), *Getting Started with TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: If a definition file is missing for a third party, you can create one; create
    a type that sets to `any` the main export that would remove the type safety but
    be able to access anything. There is also the option to enhance an existing third-party
    library by merging new definitions into the existing one. We will cover this area
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How typescript can generate a definition file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if the code is built in TypeScript, when it is time to share with the
    world, only the JavaScript files are published. The reason is to have everyone,
    including JavaScript and TypeScript developers, to use your code. It is better
    to publish TypeScript''s types in a format where the sole purpose is to provide
    type capability instead of using a full TypeScript code. On the other hand, TypeScript
    can generate JavaScript files that allow a browser to interpret the code flawlessly.
    Having TypeScript generating two kinds of files, the definition file and the JavaScript
    file, open the compatibility for the developers and browsers. While the definition
    file can be crafted by hand, which is handy for a library written in JavaScript
    that wants to offer TypeScript support, it is faster and generates less errors
    to have it generated automatically. That being said, TypeScript is the best to
    produce automatically the definition, since it is present in the .ts file. This
    is why TypeScript has a compilation option to produce the definition at compilation
    time called `declaration`, which the path can be controlled by the other option
    `declarationDir`. Both options have been discussed in [Chapter 1](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml),
    *Getting Started with TypeScript*. Here is the line that allows the generation
    of the `definition` file from a TypeScript compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to manually add a definition file for a JavaScript project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many projects are written in JavaScript but still want to have TypeScript uses
    to the benefice of type. Or, some JavaScript projects produce TypeScript's definition
    files to have good support in their code editor. Finally, some people outside
    the main repository of the JavaScript library develop manual definition files
    for every TypeScript user to consume the library.
  prefs: []
  type: TYPE_NORMAL
- en: To create a definition file from a project that you do not own, you need to
    create a folder with the name of the module you want to add types to, and add
    an index.d.ts file. However, if you own the library, you can set the `types` or
    `typing` (they are synonyms) to the path and filename of the `definition` file.
    In the following code example, the definition file is set to `main.d.ts` under
    the `lib` folder. If the `types` or `typing` are not provided, the definition
    file must be called `index.d.ts` at the root of the package folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `index.d.ts` is the best practice because TypeScript is optimized to
    search for `index.d.ts` when doing module resolution, as well as having the file
    with the name of the module (followed by `.d.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As with `library`, all dependencies must be specified. This time, all the definition
    file libraries must be mentioned in the `package.json`. It is important to notice
    that we are not referring to the definition files in the `dev` dependencies, because
    we want to have all the types downloaded and installed by the consumer of our
    `definition` file library.
  prefs: []
  type: TYPE_NORMAL
- en: How to merge types into an existing definition file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Types can be written in several places and merged into a single set of definitions
    that TypeScript can rely on. The principle is that you may be able to extend existing
    definitions with your own. The merging capability is helpful when you have JavaScript
    code that can be enhanced with plugins or with extensions. For example, the library Redux
    has its definition files in its repository and NPM package. The library named
    `Redux-thunk` also has its definition file, which adds to Redux a new `dispatch`
    function signature that overrides the one defined by `redux`. The definition file
    relies on merging type to add its own definition of the dispatch into the `redux`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Merging type requires to have some knowledge of how TypeScript allows. The first
    rule is that all namespace can be defined more than once in one or many files.
    It means that you can define code inside many namespace scopes and that TypeScript
    will see it was all in the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of a namespace is shared only if tagged as an exported element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be written in a single namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, interfaces can be merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, `type` does not act as an interface and does not allow to merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can have its definition enhanced by having an interface of the same
    name. So, it means that you can have the interface defined with the same name
    as the concrete class (in JavaScript) and be able to define a strongly typed definition.
    It also means that you can provide extension members of the class in the definition,
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A namespace can be used to define a function variable. In JavaScript, it is
    possible to assign a variable to a function by using the function name and the
    dot notation. To define the type of this function, it requires specifying not
    only the parameter name and return type but also the variable. This is possible
    by defining a namespace with the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to declare at the `global` scope an `interface` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating a definition file for a JavaScript project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today’s world of open source reduces the barrier of examples. TypeScript has
    one of the most active repositories, which is the one that all the types of third-party
    libraries that do not have the definition file in their main repository. A quick
    look at a few libraries shows a fragmentation on how to write definition files.
    This is due to the high amount of different library structure. JavaScript has
    a global, modular, UMD, plugins, and global-modifying.
  prefs: []
  type: TYPE_NORMAL
- en: Definition file for global structure library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The epitome of a global library is JQuery with its popular dollar sign. Global
    library adds their functions and variables to the window scope. This can be done
    explicitly by using `window` or implicitly by defining a var. It does not use
    any import, export, or require functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a definition file for a global structure library, you can use many
    TypeScript keywords to define a type. In the case of a function, you can use `function`
    preceded by `declare` and write the signature of the function as you would do
    in an interface, without a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `declare` is there to say that the function is present somewhere
    else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a type instead of a function declared at the global scope, you
    can use an interface. The keyword `declare` is omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The global interface allows declaring a variable of a global type without prefixing
    the type by anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A global interface allows specifying a type in a group of a cohesive element.
    It often represents a function scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The namespace can include an interface to define an object, a type to define
    a variable of a specific type and to use a `function` for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the object, variable, and function always uses the namespace name
    because it is exposed globally by the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we saw how to define a global library that can have a global
    function or variable but also a global variable that can hold an object, a primitive
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Definition file for module library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `definition` file for a library is similar but also different. If you need
    to provide a definition file, it is recommended to name an `index.d.ts` with the
    following rules. First, there is an optional export declaration that is needed
    if the library supports UMD. This happens when the library exports a variable.
    The variable exposed in the following code example is `myScope`, where the whole
    module resides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next steps are to add every function directly to the definition file. There
    is no need to englobe the functions into a namespace. This is the same for an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the function, interface, and variable would be like this in the
    actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining feature would be to have an object inside your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the actual usage of the namespace, which, like the functions, object,
    and data, is available in two formats. The first is with the explicit callout
    of the element to be retrieved from the module or the second with the star, which
    gets the whole content definition into the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in some cases, this won''t work. It depends how the JavaScript module
    is written. The following code works for modern module creation. It uses the declare
    statement with a module. The module name must be the library name between quotes.
    Inside the module, you can define your export for `CommonJs/Amd` with `export
    =`, followed by what you want to export by default. In the following code, the
    class `MessageFormat` is the default export. It is possible to not have a `CommonJs/Amd`
    export and to export every type. You can export a namespace that contains many
    types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript library without a definition file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to use a third-party library that does not have any definition
    file, you can start by a single-line declaration. You need to create a file with
    the name of the module with the extension `.d.ts` and add this single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This won't give you any Intellisence, auto-completion, but the file will be
    importable inside your TypeScript file without any issue with the compiler. You
    can start with this one-line approach and then slowly move to a more elaborate
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using another module from a definition file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may need to consume another module from your definition file. The reason
    might be to get types from another library. To be able to use the type of another
    library, you can use `import *` and assign an alias with `as` from the type you
    want to refer in your `definition` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding a definition file to an extension of an existing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea is to use the `declare` and the name of the module to extend. A system
    can have more than one declaration of the same module, allowing the possibility
    to add an exported `type`, `function`, `interface`, or `class`. The following
    code shows also the usage of another module that is used by the extension of the
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we illustrated how to work with definition files. We explained
    many facets of how to work with definition files as well as many details to facilitate
    the creation of definition, depending on how the JavaScript code was written.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we summarized everything that is essential to get started with
    TypeScript. This quick starting guide goal was to set the table for a wonderful
    meal that you can prepare with TypeScript. The book talked about how to code from
    a basic concept with primitive type to a more advanced one with generic. Hopefully,
    you will be as delighted as I am working with a typed language that is close to
    JavaScript but more powerful in terms of maintainability, as well as being easier
    to read. Thanks to type and TypeScript, web development is safer, more productive,
    and enjoyable.
  prefs: []
  type: TYPE_NORMAL
