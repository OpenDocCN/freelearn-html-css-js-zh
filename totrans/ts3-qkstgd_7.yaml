- en: Mastering the Art of Defining Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握定义类型艺术
- en: In this chapter, we will see how to create types from libraries that we are
    not working directly with but importing inside our TypeScript project. The main
    difference is that when consuming code outside our project, we will not use TypeScript
    code directly, but its definition. The reason is that JavaScript is provided in
    those libraries, not TypeScript code. We will see how it is possible to master
    the art of creating definition files for code that does not provide them, allowing
    us to keep working in a strong environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何从我们未直接工作但导入到 TypeScript 项目中的库中创建类型。主要区别在于，当我们消费项目外部的代码时，我们不会直接使用
    TypeScript 代码，而是使用其定义。原因是那些库中提供的是 JavaScript，而不是 TypeScript 代码。我们将看到如何掌握为不提供它们的代码创建定义文件的艺术，使我们能够在强环境中继续工作。
- en: 'This chapter covers the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: How to use a third-party library definition file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用第三方库定义文件
- en: How TypeScript can generate a definition file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 如何生成定义文件
- en: How to manually add a definition file for a JavaScript project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何手动为 JavaScript 项目添加定义文件
- en: How to merge types into an existing definition file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类型合并到现有的定义文件中
- en: How to create a definition file for a JavaScript project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为 JavaScript 项目创建定义文件
- en: No need for a strong type but want to use a JavaScript library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要强类型但想使用 JavaScript 库
- en: The need to use another module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用另一个模块
- en: How to add a definition file to an extension of an existing module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将定义文件添加到现有模块的扩展中
- en: How to use a third-party library definition file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用第三方库定义文件
- en: TypeScript works well when it knows the type of every variable and function.
    However, when using third-party libraries written in JavaScript, you do not have
    a definition file. TypeScript is smart and tries to infer type as much as it can
    by leveraging the standard documentation JSDoc, but nothing beats a signature
    written with TypeScript rules. However, there are many useful libraries written
    in JavaScript that do not have TypeScript’s types. A definition file fills the
    gap between JavaScript and TypeScript. For a third-party library, the idea is
    to use a definition file. The definition file source can come from a manual edition
    if the original library is written in JavaScript or generated automatically by
    TypeScript if coded in TypeScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TypeScript 知道每个变量和函数的类型时，它运行得很好。然而，当使用用 JavaScript 编写的第三方库时，您没有定义文件。TypeScript
    很智能，它通过利用标准文档 JSDoc 尽可能多地推断类型，但没有任何东西能比得上用 TypeScript 规则编写的签名。然而，有许多用 JavaScript
    编写的有用库没有 TypeScript 的类型。定义文件填补了 JavaScript 和 TypeScript 之间的差距。对于第三方库，想法是使用定义文件。如果原始库是用
    JavaScript 编写的，定义文件源可以来自手动编辑；如果用 TypeScript 编写，则可以由 TypeScript 自动生成。
- en: 'To use a third-party library definition file, you need to have the file in
    our project. The TypeScript definition file is a .d.ts extension. TypeScript will
    search for a definition file in the `node_modules` folder as well as in our project.
    Because TypeScript uses the `node_modules`, it means it can fetch definition files
    from NPM. TypeScript has one of the most active GitHub repositories, which has
    over 4,200 definition files supported by the community. They are all accessible
    using NPM under `@types`. Here is an example of how to get JQuery definition files:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第三方库定义文件，您需要将文件放在我们的项目中。TypeScript 定义文件具有 .d.ts 扩展名。TypeScript 将在 `node_modules`
    文件夹以及我们的项目中搜索定义文件。因为 TypeScript 使用 `node_modules`，这意味着它可以从 NPM 获取定义文件。TypeScript
    拥有最活跃的 GitHub 仓库之一，该仓库有超过 4,200 个由社区支持的定义文件。它们都可以通过 NPM 下的 `@types` 访问。以下是如何获取
    JQuery 定义文件的示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rising popularity of TypeScript made many libraries incorporate the definition
    file directly into their main npm package. For example, Redux, has `index.d.ts`
    at the root of the main `npm` package. It means that you may already have the
    definition files without noticing. The reason library brings the definition files
    directly in the NPM package is that the versions of the types are always synchronized
    with the code. It has also benefited people who use JavaScript and using a code
    editor that can read the definition file. Some code editors can leverage the definition
    file to provide autocomplete features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript日益增长的流行度使得许多库直接将定义文件集成到它们的主npm包中。例如，Redux在主`npm`包的根目录下有`index.d.ts`。这意味着您可能已经拥有了定义文件而没有注意到。库将定义文件直接带到NPM包中的原因是类型的版本始终与代码同步。这也使使用JavaScript并使用能够读取定义文件的代码编辑器的人受益。一些代码编辑器可以利用定义文件提供自动完成功能。
- en: Other than the `node_modules`, TypeScript reads the configuration `types` and
    `typeroots` in the `tsconfig.json` file. For further details, refer to [Chapter
    1](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml), *Getting Started with TypeScript*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`node_modules`之外，TypeScript读取`tsconfig.json`文件中的`types`和`typeroots`配置。有关更多详细信息，请参阅[第一章](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml)，*TypeScript入门*。
- en: If a definition file is missing for a third party, you can create one; create
    a type that sets to `any` the main export that would remove the type safety but
    be able to access anything. There is also the option to enhance an existing third-party
    library by merging new definitions into the existing one. We will cover this area
    in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少第三方定义文件，您可以创建一个；创建一个类型，将主要导出设置为`any`，这将移除类型安全但能够访问任何内容。还有将新定义合并到现有第三方库中以提高其功能的选项。我们将在本章中介绍这一领域。
- en: How typescript can generate a definition file
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript如何生成定义文件
- en: 'Even if the code is built in TypeScript, when it is time to share with the
    world, only the JavaScript files are published. The reason is to have everyone,
    including JavaScript and TypeScript developers, to use your code. It is better
    to publish TypeScript''s types in a format where the sole purpose is to provide
    type capability instead of using a full TypeScript code. On the other hand, TypeScript
    can generate JavaScript files that allow a browser to interpret the code flawlessly.
    Having TypeScript generating two kinds of files, the definition file and the JavaScript
    file, open the compatibility for the developers and browsers. While the definition
    file can be crafted by hand, which is handy for a library written in JavaScript
    that wants to offer TypeScript support, it is faster and generates less errors
    to have it generated automatically. That being said, TypeScript is the best to
    produce automatically the definition, since it is present in the .ts file. This
    is why TypeScript has a compilation option to produce the definition at compilation
    time called `declaration`, which the path can be controlled by the other option
    `declarationDir`. Both options have been discussed in [Chapter 1](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml),
    *Getting Started with TypeScript*. Here is the line that allows the generation
    of the `definition` file from a TypeScript compilation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码是用TypeScript编写的，当需要与世界分享时，也只发布JavaScript文件。这样做的原因是让所有人，包括JavaScript和TypeScript开发者，都能使用您的代码。最好以只提供类型能力的格式发布TypeScript的类型，而不是使用完整的TypeScript代码。另一方面，TypeScript可以生成允许浏览器完美解释代码的JavaScript文件。TypeScript生成两种类型的文件，即定义文件和JavaScript文件，这为开发者和浏览器打开了兼容性。虽然定义文件可以手动制作，这对于想要提供TypeScript支持的JavaScript库来说很方便，但自动生成它既快又少出错。也就是说，TypeScript是生成定义的最佳选择，因为它存在于.ts文件中。这就是为什么TypeScript有一个在编译时生成定义的编译选项，称为`declaration`，其路径可以通过另一个选项`declarationDir`来控制。这两个选项已经在[第一章](e45856f0-cecc-4d35-a781-e1102e9a2a86.xhtml)，*TypeScript入门*中讨论过。以下是允许从TypeScript编译生成`definition`文件的行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to manually add a definition file for a JavaScript project
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何手动为JavaScript项目添加定义文件
- en: Many projects are written in JavaScript but still want to have TypeScript uses
    to the benefice of type. Or, some JavaScript projects produce TypeScript's definition
    files to have good support in their code editor. Finally, some people outside
    the main repository of the JavaScript library develop manual definition files
    for every TypeScript user to consume the library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目是用 JavaScript 编写的，但仍然希望利用 TypeScript 的类型优势。或者，一些 JavaScript 项目生成 TypeScript
    的定义文件，以便在代码编辑器中获得良好的支持。最后，一些位于 JavaScript 库主仓库之外的人为每个 TypeScript 用户开发手动定义文件，以便使用该库。
- en: To create a definition file from a project that you do not own, you need to
    create a folder with the name of the module you want to add types to, and add
    an index.d.ts file. However, if you own the library, you can set the `types` or
    `typing` (they are synonyms) to the path and filename of the `definition` file.
    In the following code example, the definition file is set to `main.d.ts` under
    the `lib` folder. If the `types` or `typing` are not provided, the definition
    file must be called `index.d.ts` at the root of the package folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个不属于你的项目中创建一个定义文件，你需要创建一个以你想要添加类型的模块命名的文件夹，并添加一个 index.d.ts 文件。然而，如果你拥有这个库，你可以将
    `types` 或 `typing`（它们是同义词）设置为 `definition` 文件的路径和文件名。在下面的代码示例中，定义文件被设置为 `lib`
    文件夹下的 `main.d.ts`。如果没有提供 `types` 或 `typing`，定义文件必须在包文件夹的根目录下命名为 `index.d.ts`。
- en: 'Using `index.d.ts` is the best practice because TypeScript is optimized to
    search for `index.d.ts` when doing module resolution, as well as having the file
    with the name of the module (followed by `.d.ts`):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `index.d.ts` 是最佳实践，因为 TypeScript 在进行模块解析时已经优化了搜索 `index.d.ts`，以及具有与模块名称相同的文件名（后跟
    `.d.ts`）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with `library`, all dependencies must be specified. This time, all the definition
    file libraries must be mentioned in the `package.json`. It is important to notice
    that we are not referring to the definition files in the `dev` dependencies, because
    we want to have all the types downloaded and installed by the consumer of our
    `definition` file library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `library` 一样，所有依赖项都必须指定。这次，所有定义文件库都必须在 `package.json` 中提及。重要的是要注意，我们不是在提及
    `dev` 依赖项中的定义文件，因为我们希望所有类型都由我们的 `definition` 文件库的消费者下载和安装。
- en: How to merge types into an existing definition file
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将类型合并到现有的定义文件中
- en: 'Types can be written in several places and merged into a single set of definitions
    that TypeScript can rely on. The principle is that you may be able to extend existing
    definitions with your own. The merging capability is helpful when you have JavaScript
    code that can be enhanced with plugins or with extensions. For example, the library Redux
    has its definition files in its repository and NPM package. The library named
    `Redux-thunk` also has its definition file, which adds to Redux a new `dispatch`
    function signature that overrides the one defined by `redux`. The definition file
    relies on merging type to add its own definition of the dispatch into the `redux`
    module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以写在不同地方，并合并成 TypeScript 可以依赖的单一定义集。原则是，你可能能够通过自己的定义扩展现有定义。合并能力在你有可以增强的 JavaScript
    代码（通过插件或扩展）时非常有用。例如，Redux 库在其仓库和 NPM 包中都有自己的定义文件。名为 `Redux-thunk` 的库也有自己的定义文件，它为
    Redux 添加了一个新的 `dispatch` 函数签名，覆盖了 `redux` 中定义的签名。定义文件依赖于合并类型来将其自己的 `dispatch`
    定义添加到 `redux` 模块中：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Merging type requires to have some knowledge of how TypeScript allows. The first
    rule is that all namespace can be defined more than once in one or many files.
    It means that you can define code inside many namespace scopes and that TypeScript
    will see it was all in the same namespace.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 合并类型需要了解 TypeScript 允许的方式。第一条规则是，所有命名空间可以在一个或多个文件中定义多次。这意味着你可以在多个命名空间作用域内定义代码，而
    TypeScript 会将其视为同一个命名空间中的代码。
- en: 'The content of a namespace is shared only if tagged as an exported element:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的内容只有在标记为导出元素时才会共享：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be written in a single namespace:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以写在一个命名空间中：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, interfaces can be merged:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，接口也可以合并：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, `type` does not act as an interface and does not allow to merge.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`type` 并不作为一个接口，并且不允许合并。
- en: 'A class can have its definition enhanced by having an interface of the same
    name. So, it means that you can have the interface defined with the same name
    as the concrete class (in JavaScript) and be able to define a strongly typed definition.
    It also means that you can provide extension members of the class in the definition,
    if needed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以通过具有相同名称的接口来增强其定义。这意味着你可以定义一个与具体类（在JavaScript中）具有相同名称的接口，并能够定义一个强类型定义。这也意味着如果需要，你可以在定义中提供类的扩展成员：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A namespace can be used to define a function variable. In JavaScript, it is
    possible to assign a variable to a function by using the function name and the
    dot notation. To define the type of this function, it requires specifying not
    only the parameter name and return type but also the variable. This is possible
    by defining a namespace with the function name:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命名空间来定义一个函数变量。在JavaScript中，可以通过使用函数名和点符号来将变量赋给一个函数。要定义此函数的类型，需要指定不仅参数名和返回类型，还要指定变量。这可以通过使用函数名定义一个命名空间来实现：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is possible to declare at the `global` scope an `interface` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`全局`作用域中可以声明一个`接口`函数：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a definition file for a JavaScript project
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为JavaScript项目创建定义文件
- en: Today’s world of open source reduces the barrier of examples. TypeScript has
    one of the most active repositories, which is the one that all the types of third-party
    libraries that do not have the definition file in their main repository. A quick
    look at a few libraries shows a fragmentation on how to write definition files.
    This is due to the high amount of different library structure. JavaScript has
    a global, modular, UMD, plugins, and global-modifying.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的开源世界降低了示例的门槛。TypeScript拥有最活跃的仓库之一，这是所有那些在主仓库中没有定义文件的第三方库的类型。快速查看几个库会显示出在编写定义文件方面的碎片化。这是由于大量不同的库结构。JavaScript有全局的、模块化的、UMD、插件和全局修改的。
- en: Definition file for global structure library
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局结构库的定义文件
- en: The epitome of a global library is JQuery with its popular dollar sign. Global
    library adds their functions and variables to the window scope. This can be done
    explicitly by using `window` or implicitly by defining a var. It does not use
    any import, export, or require functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 全局库的典范是带有流行美元符号的JQuery。全局库将它们的函数和变量添加到window作用域。这可以通过使用`window`或通过定义一个变量来显式完成。它不使用任何导入、导出或`require`函数。
- en: 'To create a definition file for a global structure library, you can use many
    TypeScript keywords to define a type. In the case of a function, you can use `function`
    preceded by `declare` and write the signature of the function as you would do
    in an interface, without a body:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为全局结构库创建一个定义文件，你可以使用许多TypeScript关键字来定义一个类型。在函数的情况下，你可以使用`declare`前缀的`function`，并像在接口中那样编写函数签名，但不包含函数体：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The keyword `declare` is there to say that the function is present somewhere
    else:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`declare`的存在是为了表明函数存在于其他地方：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you have a type instead of a function declared at the global scope, you
    can use an interface. The keyword `declare` is omitted:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你全局作用域中声明的是一个类型而不是函数，你可以使用一个接口。关键字`declare`被省略了：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The global interface allows declaring a variable of a global type without prefixing
    the type by anything:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 全局接口允许声明一个全局类型的变量，无需在类型前添加任何前缀：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A global interface allows specifying a type in a group of a cohesive element.
    It often represents a function scope:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 全局接口允许在一系列连贯元素中指定一个类型。它通常代表一个函数作用域：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The namespace can include an interface to define an object, a type to define
    a variable of a specific type and to use a `function` for functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以包括一个接口来定义一个对象，一个类型来定义特定类型的变量，以及一个`function`来定义函数：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The usage of the object, variable, and function always uses the namespace name
    because it is exposed globally by the variable name:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对象、变量和函数的使用总是使用命名空间名称，因为它通过变量名在全局范围内暴露：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we saw how to define a global library that can have a global
    function or variable but also a global variable that can hold an object, a primitive
    of a function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何定义一个全局库，它可以有一个全局函数或变量，也可以有一个全局变量，它可以包含一个对象、一个函数的原始类型。
- en: Definition file for module library
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块库的定义文件
- en: 'The `definition` file for a library is similar but also different. If you need
    to provide a definition file, it is recommended to name an `index.d.ts` with the
    following rules. First, there is an optional export declaration that is needed
    if the library supports UMD. This happens when the library exports a variable.
    The variable exposed in the following code example is `myScope`, where the whole
    module resides:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 库的 `definition` 文件类似但也有一些不同。如果你需要提供定义文件，建议使用以下规则命名一个 `index.d.ts` 文件。首先，有一个可选的导出声明，如果库支持
    UMD，则需要这个声明。这发生在库导出一个变量时。以下代码示例中暴露的变量是 `myScope`，整个模块都驻留在其中：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next steps are to add every function directly to the definition file. There
    is no need to englobe the functions into a namespace. This is the same for an
    object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将每个函数直接添加到定义文件中。没有必要将函数包含在命名空间中。对于对象也是同样的：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The usage of the function, interface, and variable would be like this in the
    actual code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、接口和变量在真实代码中的使用方式如下：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The remaining feature would be to have an object inside your module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的功能是在你的模块中有一个对象：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the actual usage of the namespace, which, like the functions, object,
    and data, is available in two formats. The first is with the explicit callout
    of the element to be retrieved from the module or the second with the star, which
    gets the whole content definition into the alias:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是命名空间的实际使用方式，它像函数、对象和数据一样，有两种格式。第一种是明确调用模块中要检索的元素，第二种是使用星号，它将整个内容定义导入到别名中：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, in some cases, this won''t work. It depends how the JavaScript module
    is written. The following code works for modern module creation. It uses the declare
    statement with a module. The module name must be the library name between quotes.
    Inside the module, you can define your export for `CommonJs/Amd` with `export
    =`, followed by what you want to export by default. In the following code, the
    class `MessageFormat` is the default export. It is possible to not have a `CommonJs/Amd`
    export and to export every type. You can export a namespace that contains many
    types as well:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，这不会起作用。这取决于 JavaScript 模块的编写方式。以下代码适用于现代模块创建。它使用带有模块的声明语句。模块名称必须是引号中的库名称。在模块内部，你可以使用
    `export =` 定义你的 `CommonJs/Amd` 导出，然后跟随着你想要默认导出的内容。在以下代码中，类 `MessageFormat` 是默认导出。你也可以不进行
    `CommonJs/Amd` 导出，并导出每一个类型。你也可以导出一个包含许多类型的命名空间：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: JavaScript library without a definition file
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有定义文件的 JavaScript 库
- en: 'If you need to use a third-party library that does not have any definition
    file, you can start by a single-line declaration. You need to create a file with
    the name of the module with the extension `.d.ts` and add this single line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用没有定义文件的第三方库，你可以从一个单行声明开始。你需要创建一个具有模块名称的文件，并添加这个单行：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This won't give you any Intellisence, auto-completion, but the file will be
    importable inside your TypeScript file without any issue with the compiler. You
    can start with this one-line approach and then slowly move to a more elaborate
    definition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会给你任何智能提示、自动完成，但文件可以在你的 TypeScript 文件中无任何问题地导入。你可以从这种单行方法开始，然后逐渐过渡到一个更详细的定义。
- en: Using another module from a definition file
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义文件中的另一个模块
- en: 'You may need to consume another module from your definition file. The reason
    might be to get types from another library. To be able to use the type of another
    library, you can use `import *` and assign an alias with `as` from the type you
    want to refer in your `definition` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要从你的定义文件中消费另一个模块。原因可能是为了从另一个库中获取类型。为了能够使用另一个库的类型，你可以使用 `import *` 并从你想要引用的类型中用
    `as` 分配一个别名到你的 `definition` 文件中：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding a definition file to an extension of an existing module
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将定义文件添加到现有模块的扩展中
- en: 'The idea is to use the `declare` and the name of the module to extend. A system
    can have more than one declaration of the same module, allowing the possibility
    to add an exported `type`, `function`, `interface`, or `class`. The following
    code shows also the usage of another module that is used by the extension of the
    module:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是使用 `declare` 和模块名称来扩展。一个系统可以有多个相同模块的声明，允许添加导出的 `type`、`function`、`interface`
    或 `class`。以下代码还展示了另一个模块的使用，该模块被模块的扩展所使用：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we illustrated how to work with definition files. We explained
    many facets of how to work with definition files as well as many details to facilitate
    the creation of definition, depending on how the JavaScript code was written.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用定义文件。我们解释了如何使用定义文件的多方面内容，以及许多细节，以便根据JavaScript代码的编写方式来促进定义的创建。
- en: In this book, we summarized everything that is essential to get started with
    TypeScript. This quick starting guide goal was to set the table for a wonderful
    meal that you can prepare with TypeScript. The book talked about how to code from
    a basic concept with primitive type to a more advanced one with generic. Hopefully,
    you will be as delighted as I am working with a typed language that is close to
    JavaScript but more powerful in terms of maintainability, as well as being easier
    to read. Thanks to type and TypeScript, web development is safer, more productive,
    and enjoyable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们总结了开始使用TypeScript所必需的一切。这本快速入门指南的目标是为一场美味的餐宴做好准备，你可以用TypeScript来准备这场餐宴。书中讨论了如何从基本概念（原始类型）开始编码，到更高级的概念（泛型）。希望你能像我一样，对使用接近JavaScript但更强大（在可维护性方面）且更容易阅读的强类型语言感到高兴。感谢类型和TypeScript，Web开发变得更加安全、高效和愉快。
