<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with Collections</h1></div></div></div><p>The purpose of the Backbone collection<a id="id169" class="indexterm"/> is pretty straightforward. As an ordered set of models, a collection provides a number of useful methods to play around with, including a set of Underscore.js utility methods. A collection includes functionality to add, remove, sort, and filter models, and save to or fetch data from the server. A collection listens to the events fired on its models–if an event is fired on a model of a collection, it will also be fired on the collection itself. This facility is quite significant when you want to listen to an attribute-change event of the model. We will look into it using some examples in the <em>Basic usage of collections</em> section of this chapter.</p><p>In the previous chapters, we saw a number of implementations of a simple collection to display multiple items in a list view. However, there can be cases where you want to sort the list with a number of criteria or you want to filter the list items to show only a particular type. In such cases, you have to either alter the collection to restructure the model positions or get the data that matches the filter condition. Let us look into what we will learn in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Basic usage of collections</strong>: Understanding the basic use of the Backbone collection and data operations with collections</li><li class="listitem" style="list-style-type: disc"><strong>Sorting collection</strong>: Basic and multiple sorting of a collection</li><li class="listitem" style="list-style-type: disc"><strong>Filtering collection</strong>: Performing basic filtering, avoiding re-filtering a filtered collection with duplicate collection, and filtering with full data pointers</li><li class="listitem" style="list-style-type: disc"><strong>Collection with multiple model types</strong>: Managing a collection when a mixed set of data is passed from the server and each type belongs to separate models</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Basic usage of collections</h1></div></div></div><p>We will <a id="id170" class="indexterm"/>start looking<a id="id171" class="indexterm"/> into different features of the <code class="literal">Backbone</code> collection with a simple example. Let's assume we have a <code class="literal">User</code> model and a <code class="literal">Users</code> collection.</p><div><pre class="programlisting">// Model definition
var User = Backbone.Model.extend({
  initialize: function () {
    this.on('change', function () {
      console.log('User model changed!');
    });
  }
});

// Collection definition
var Users = Backbone.Collection.extend({
  model: User,
  url : '/users',
  initialize: function () {
    this.on('change', function () {
      console.log('Users collection changed!');
    });
  }
});

var users = new Users(),
  newUser = new User({
    name: 'Jayashi De',
    age: 21
  });

users.add([newUser]);

// Change an attribute of the model
newUser.set('age', 22);</pre></div><p>In the preceding <a id="id172" class="indexterm"/>code, simple model and collection definitions have been described. Here, we tried to demonstrate, as we mentioned in the introduction of this chapter, that any event fired on a model will get fired on the collection too. When you run this code, the model-change handler is run first, then followed by the collection change-event handler.</p><p>The <code class="literal">Backbone</code> collection provides a huge set of methods along with a number of <code class="literal">Underscore</code> utility methods to work on it. Because a collection deals with multiple data, you will find the <code class="literal">Underscore</code> utility methods are very useful to operate on it. Discussing all these methods and their functionality is beyond the scope of this book, but we are going to see how to use the <code class="literal">fetch()</code> and <code class="literal">save()</code> methods to retrieve data from and save data to the server using an AJAX request in the next section.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Performing data operations with collections</h2></div></div></div><p>You can use<a id="id173" class="indexterm"/> AJAX requests to save and <a id="id174" class="indexterm"/>fetch data to and from the server. The result then needs to be applied on the collection. However, Backbone simplifies the complete process by providing a few methods such as <code class="literal">fetch()</code> and <code class="literal">save()</code> to directly <a id="id175" class="indexterm"/>interact with the server. We will use the same collection that we used in the previous section to demonstrate how we can perform all data operations with collections.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Fetching data from the server</h3></div></div></div><p>Fetching data from<a id="id176" class="indexterm"/> the server is quite easy. You just call the <code class="literal">fetch()</code> method<a id="id177" class="indexterm"/> on the collection as shown in the following code line, and a <code class="literal">GET</code> request is sent to the URL that we added in the collection's configuration. It receives a <code class="literal">JSON</code> array with objects that get added to the collection as models.</p><div><pre class="programlisting">users.fetch();</pre></div><p>On receiving the data, the <code class="literal">set()</code> method<a id="id178" class="indexterm"/> of the collection is automatically called to update the collection. If a model doesn't exist, it gets added; if the model exists already, the latest data gets merged with it; and if the collection has a model that is not there in the new data, it gets removed.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Saving data to the server</h3></div></div></div><p>Unlike fetching <a id="id179" class="indexterm"/>data from the server, collections do not have a method to store data as a whole to the server. Instead, the <code class="literal">save()</code> method of each individual model needs to be called as shown in the following code snippet:</p><div><pre class="programlisting">var user = users.get(1);
user.save();</pre></div><p>The <code class="literal">save()</code> method appends the model's ID to the server's URL (<code class="literal">/users/1</code>) and sends a <code class="literal">PUT</code> request to that URL. So, to save the complete collection to the server, you need to iterate through the collection and call the <code class="literal">save()</code> method on each model individually.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Sorting a collection</h1></div></div></div><p>Sorting a collection <a id="id180" class="indexterm"/>is fairly easy with Backbone as built-in methods are already available for this purpose. To sort a collection, add a <code class="literal">comparator</code> to the collection, which in general, is a function that can take a single model or two consecutive models for comparison, or it can be a string that points to an attribute of its model. Whenever a model is added to the collection, the comparator sorts the collection accordingly. Changing an attribute of a model later doesn't initiate the sort functionality automatically and you need to call the <code class="literal">sort()</code> method<a id="id181" class="indexterm"/> on the collection again to re-sort it. Let's look into a simple example of sorting a collection:</p><div><pre class="programlisting">var User = Backbone.Model.extend();

var Users = Backbone.Collection.extend({
  model: User,
  comparator: 'age'
});

var users = new Users();
users.add([{
  name: 'John Doe', 
  age: 29
}, {
  name: 'Richard Smith',
  age: 35
}, {
  name: 'Swarnendu De',
  age: 29
}, {
  name: 'Emily Johnson',
  age: 25
}, {
  name: 'Sarah Castle',
  age: 40
}, {
  name: 'Ben Cooper',
  age: 29
}]);

console.log(users.pluck('name')); // ["Emily Johnson", "John Doe", // "Swarnendu De", "Ben Cooper", "Richard Smith", "Sarah Castle"]

console.log(users.pluck('age')); // 25, 29, 29, 29, 35, 40</pre></div><p>As you can see, the output is a collection sorted by age. Similarly, we can implement the alphabetical<a id="id182" class="indexterm"/> order with <code class="literal">name</code> as the comparator. The preceding functionality can also be replicated by the following two options:</p><div><pre class="programlisting">// Underscore's sortBy() comparator
comparator: function (model) {
  return model.get('age');
}

// Underscore's sort() comparator
comparator: function (model1, model2) {
  return model1.get('age') &lt; model2.get('age');
}</pre></div><p>The first case is simple; it provides a string attribute to the comparator. The second case provides a comparison between two models (<code class="literal">model1</code> and <code class="literal">model2</code>). If the <code class="literal">age</code> attribute of <code class="literal">model1</code> is greater than that of <code class="literal">model2</code>, <code class="literal">model1</code> and <code class="literal">model2</code> will interchange their positions to be in ascending order.</p><div><div><div><div><h2 class="title"><a id="ch04lvl3sec09"/>Sorting a collection with multiple attributes</h2></div></div></div><p>Note that there<a id="id183" class="indexterm"/> are three 29-years-old values in the example mentioned in the preceding section. What if we want to sort these models according to the <code class="literal">name</code> attribute too? The string comparison can also be done the same way as we did for numbers; the functionality will be simple (see the following example):</p><div><pre class="programlisting">comparator: function (model1, model2) {
  // If age is same, then sort by name
  if (model1.get('age') === model2.get('age')) {
    return model1.get('name') &gt; model2.get('name');
  } else {
    return model1.get('age') &gt; model2.get('age');
  }
}  

console.log(users.pluck('name'));
console.log(users.pluck('age'));</pre></div><p>The preceding code only sorts the collection by the <code class="literal">name</code> attribute. If two models have the same age values, the result will look like the following:</p><div><pre class="programlisting">["Emily Johnson", "Ben Cooper", "John Doe", "Swarnendu De", "Richard Smith", "Sarah Castle"]
[25, 29, 29, 29, 35, 40]</pre></div><p>A <code class="literal">sort</code> event is always fired when there is a comparator present in the collection and you add some data to it. It also gets fired when you specifically call the <code class="literal">sort()</code> method on the collection.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Filtering a collection</h1></div></div></div><p>Filtering a collection<a id="id184" class="indexterm"/> is a fairly simple concept; here we want to get a part of the data based on a certain criteria. For example, if you have a list of items and you want to filter the list to only show a subset of all the items, you filter the attached collection. By default, Backbone provides some built-in functions that take care of basic filtering. The two methods<a id="id185" class="indexterm"/> <code class="literal">where()</code> and <code class="literal">findWhere()</code> produce similar functionality, though <code class="literal">findWhere()</code><a id="id186" class="indexterm"/> only returns the first model that matches the condition.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Performing basic filtering</h2></div></div></div><p>The <a id="id187" class="indexterm"/>
<code class="literal">where()</code> method <a id="id188" class="indexterm"/>accepts a set of model attributes and returns an array of the matched models.</p><div><pre class="programlisting">var users = new Backbone.Collection([
  { name: 'John', company: 'A' }, 
  { name: 'Bill', company: 'B' }, 
  { name: 'Rick', company: 'A' }
]);

users.where({
  company: 'A'
});</pre></div><p>The result will be an array of two models that have <code class="literal">A</code> as their company. However, note that filtering the collection does not change the original collection data at all; instead, it just returns an array with the results. If there is a Backbone view that is displaying the collection data as a list, filtering the collection will not have any effect on the list.</p><p>So, how are we going to resolve this? One simple task can be done—let's reset the collection with the filtered data and re-render the list. The following code will work fine and the collection will only have the filtered data with it:</p><div><pre class="programlisting">var filteredData = users.where({
  company: 'A'
});

// Reset the collection with array with filtered data
users.reset(filteredData);

// A collection with only filtered data
console.log(users);</pre></div><p>Now, if you re-render the list, it will only show the filtered data. This looks fine; however, if you want to re-filter the collection, it will not be applied on the complete collection of data but on the previously filtered data. This is wrong; it is advisable to avoid such patterns that may lead to severe problems in a later stage. When you filter a collection only once, there should not be any problem, but multiple filtering of the collection will surely cause problems if the same collection is used elsewhere too. The following code, for example, will return zero results for the same reason:</p><div><pre class="programlisting">users.where({
  company: 'B'
});</pre></div><p>Let's attempt a few options to find a solution to this problem. We will first try this using a duplicate collection.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Filtering a collection with a duplicate collection</h2></div></div></div><p>There are <a id="id189" class="indexterm"/>multiple solutions to the problem we found in the preceding section. For example, we can create another collection instance whenever a collection is filtered and we always reset this second collection with the filtered data. That way, the main collection will not be altered and passing the second collection to the view instance will produce the desired result.</p><div><pre class="programlisting">var filteredData = users.where({
  company: 'A'
});

// Create a new collection that will only hold filtered data
var filteredCollection = new Backbone.Collection();

// Reset this collection every time 
// there is a new set of filtered data
filteredCollection.reset(filteredData);

console.log(filteredCollection, users);</pre></div><p>This time, the original collection holds its state and the new filtered collection provides the necessary functionality. This process can become quite beneficial for displaying a filtered set of data. The main disadvantage of this process is that you need to create another new instance of the collection in order to filter it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Self-filtering with full data pointers</h2></div></div></div><p>The disadvantage<a id="id190" class="indexterm"/> of multiple filtering<a id="id191" class="indexterm"/> can also be eliminated by keeping a reference to the complete dataset before applying filters. If we can save the initial data in a property inside the collection itself and then apply a filter on it, the collection data gets changed but the raw data is still available. Therefore, if we need to re-apply another filter on the collection, we can first reset it with the total data and then apply the new filter. To understand the concept with an example, we will define a custom <code class="literal">FilterCollection</code> class:</p><div><pre class="programlisting">var FilterCollection = Backbone.Collection.extend({
  _totalData: [],
  _isFiltered: false,

  initialize: function (data) {
    // The initial data sent to collection will be saved
    if (data) {
      this._setTotalData(data);
    }

    // If some data is added later, 
    // that should reflect in _totalData 
    this.on('add', function () {
      this._setTotalData();
    }, this);
  },

  // Every time a new data has been added to the collection
  _setTotalData: function (data) {
    this._totalData = data || this.toJSON();
  },

  // Apply a new filter to the collection
  applyFilter: function (criteria) {
    // Clear the previous filter
    this.clearFilter();

    // Apply new filter 
    this.reset(this.where(criteria));

    // Mark this as filtered
    this._isFiltered = true;
  },

  // Clear all filters applied to this collection
  clearFilter: function () {
    // skip first reset event while the collection 
    // has the original data
    if (this._isFiltered) {
      // Reset the collection with complete data set
      this.reset(this._totalData);
      this._isFiltered = false;
    }
  }
});</pre></div><p>We create a <a id="id192" class="indexterm"/>custom <code class="literal">Collection</code> class that has a <code class="literal">_totalData</code> property, which is supposed to hold the complete data of that collection. In the <code class="literal">initialize</code> method, we check whether any data has been passed to the collection; if it has been passed, we save that data in this variable. We also include an <code class="literal">add</code> event listener so that the newly added data gets reflected.</p><p>Now, once you call the <code class="literal">applyFilter()</code> method on the collection, it first resets the collection with full data and then applies the filter on this collection. That way, each time you filter the collection with this method, you do not need to worry about whether it is being applied to the previously filtered collection or not. Let's analyze the functionality with a test case:</p><div><pre class="programlisting">var filteredCollection = new FilterCollection ([
  { name: 'John', company: 'A' }, 
  { name: 'Bill', company: 'B' }, 
  { name: 'Rick', company: 'A' }
]);

// Add another data to check whether add event is working or not
filteredCollection.add({
  name: 'John',
  company: 'C'
});

// Filter with company
filteredCollection.applyFilter({
  company: 'A'
});

// Filter with name
filteredCollection.applyFilter({
  name: 'John'
});

console.log(filteredCollection); 
// Shows two data both with name : 'John'</pre></div><p>Earlier, after<a id="id193" class="indexterm"/> second-time filtering, you received only one set of data because the collection had been filtered twice and the returned model had the name <code class="literal">John</code> and the company <code class="literal">A</code>. But now, because the collection is refreshed before every filtering, you will get a proper result.</p><p>The preceding code is not ready for production, and you need to make it more sophisticated so that <code class="literal">_totalData</code> should always have the latest data. Anyhow, the pattern comes useful in certain cases, and keeping a filterable collection extension or a <code class="literal">Filterable</code> mixin ready can get you an immediate solution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Understanding the collection of multiple model types</h1></div></div></div><p>There are<a id="id194" class="indexterm"/> cases when we have a mixed set of data coming from the server and we need to put the complete data in a single collection. For example, assume that the server is sending the complete employee details of a company. Now, there are different types of employees—developers, managers, designers, and so on, and you want to have different model types for each of these. How is the collection supposed to hold all types of models together? Here is an example with which you can get the desired functionality:</p><div><pre class="programlisting">var Employee = Backbone.Model.extend();
var Developer = Employee.extend();
var Manager = Employee.extend();

var Employees = Backbone.Collection.extend({
  url: 'employees.json',
  model: function (attrs, options) {
    // For each data, check the attribute type
    switch (attrs.type) {
      case "Developer":
        return new Developer(attrs, options);
        break;

      case "Manager":
        return new Manager(attrs, options);
        break;
    }
  }
});

var employees = new Employees();
employees.fetch();
console.log(employees);</pre></div><p>The model that a collection asks for is either the model itself, an instance of it that is created every time data is added to the collection, or can hold a function to which data attributes are passed to and you can check for the related model according to the data and pass an instance of it. Here, in the preceding example, we did the same thing and returned separate models depending on the type of data attribute.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>Working with collections is a basic requirement of Backbone, and the questions associated with a collection are related to the models too. For example, the most common issue that almost every developer faces is nested collections, and the solution to the problem is related to how the data is parsed inside the model itself. We discussed the relational data plugin in <a class="link" href="ch03.html" title="Chapter 3. Working with Models">Chapter 3</a>, <em>Working with Models</em>, that wonderfully solves the problem with nested models and collections. It is highly recommended to use this plugin for any such data relationships.</p><p>This chapter discussed how we can sort and filter collections. Simple sorting and multiple sorting processes were described with examples. We also saw a number of methods for filtering a collection, which can be useful in different situations.</p><p>A collection can hold different types of model data inside—the solution to which was described with an example. In general, any dataset needs a handful of utility methods to work with. A large set of Underscore.js utility methods made it much easier for us to work with Backbone collections.</p><p>In the next chapter, we are going to discuss the necessities of Backbone routers and why the use of multiple subrouters is beneficial for uncomplex applications.</p></div></body></html>