<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. REST and Storage</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Architecting the REST API for the backend</li><li class="listitem" style="list-style-type: disc">Prototyping a RESTful backend with MongoLab</li><li class="listitem" style="list-style-type: disc">Synchronizing models and collections with a RESTful service</li><li class="listitem" style="list-style-type: disc">Building a RESTful frontend with Backbone</li><li class="listitem" style="list-style-type: disc">Using the polling technique to fetch data</li><li class="listitem" style="list-style-type: disc">Working with local storage</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Introduction</h1></div></div></div><p>This chapter focuses on the way Backbone.js synchronizes models and collections with a RESTful backend, or stores them in the HTML5 local storage.</p><p>We will learn how to design the REST API for our backend, which can be implemented with almost any programming framework, such as Symphony, Ruby on Rails, Django, or Node.js.</p><p>Throughout the chapter, we will use MongoLab (<a class="ulink" href="http://mongolab.com">http://mongolab.com</a>), which is the cloud version of MongoDB, with a RESTful interface. We will also learn what tools to use to debug the RESTful service when the frontend app has not been built yet.</p><p>Finally we will make the Backbone application communicate with the RESTful service, performing full set of CRUD operations supported by the REST server. We will also learn how to use the polling technique to update data in a collection in the application dynamically.</p><p>We will also discuss about an extension that allows us to keep data in HTML5's local storage instead of keeping them in the remote server.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Architecting the REST API for the backend</h1></div></div></div><p><strong>Representational State Transfer</strong> (<strong>REST</strong>) is an <a class="indexterm" id="id564"/>architectural style for designing network applications<a class="indexterm" id="id565"/> that communicate amongst each other. Unlike COBRA or SOAP, REST can be easily implemented on top of pure HTTP.</p><p>REST-style architectures consist of clients and servers. The client calls the HTTP request method (<code class="literal">POST</code>, <code class="literal">GET</code>, <code class="literal">PUT</code>, or <code class="literal">DELETE</code>) to perform CRUD (created, read, update, and delete) operation over a resource that can be either a collection or a single element.</p><p>In this recipe, we are going to architect an API of the REST server for the Billing application.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec205"/>How to do it...</h2></div></div></div><p>Follow these steps to architect an API of a RESTful service:</p><div><ol class="orderedlist arabic"><li class="listitem">Define the base REST URI used by the client to access resources stored on the server; for example, it can look like <code class="literal">http://example.com/resources</code>.</li><li class="listitem">Define URIs to access your app-specific resources. These URIs should be relative to the base REST URI:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Invoice collection</strong>: <code class="literal">&lt;rest-uri&gt;/invoices</code></li><li class="listitem" style="list-style-type: disc"><strong>Invoice</strong>: <code class="literal">&lt;rest-uri&gt;/invoices/&lt;invoice-id&gt;</code></li><li class="listitem" style="list-style-type: disc"><strong>Buyer collection</strong>: <code class="literal">&lt;rest-uri&gt;/buyers</code></li><li class="listitem" style="list-style-type: disc"><strong>Buyer</strong>: <code class="literal">&lt;rest-uri&gt;/buyers/&lt;buyer-id&gt;</code></li><li class="listitem" style="list-style-type: disc"><strong>Seller</strong>: <code class="literal">&lt;rest-uri&gt;/seller</code></li></ul></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec206"/>How it works...</h2></div></div></div><p>The URI to access the <a class="indexterm" id="id566"/>resource can look like <code class="literal">http://example.com/resources/items and data</code>, which are transferred through REST, and are typically in the JSON format, XML, or any other valid Internet media types.</p><p>The following table describes what happens when the REST operation is performed on a specific resource type:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Resource URI</p>
</td><td style="text-align: left" valign="top">
<p>Collection:</p>
<p><code class="literal">http://example.com/resources/items</code></p>
</td><td style="text-align: left" valign="top">
<p>Element:</p>
<p><code class="literal">http://example.com/resources/items/1</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">POST</code></p>
</td><td style="text-align: left" valign="top">
<p>This request creates a new item in the collection and returns a newly created item or its URI.</p>
</td><td style="text-align: left" valign="top">
<p>It's not typically used. If used, it does the same job as a POST query for a collection's resource.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">GET</code></p>
</td><td style="text-align: left" valign="top">
<p>This request lists collection items or theirs URIs.</p>
</td><td style="text-align: left" valign="top">
<p>This request retrieves collection items by their URIs.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">PUT</code></p>
</td><td style="text-align: left" valign="top">
<p>This request replaces the entire collection with another collection.</p>
</td><td style="text-align: left" valign="top">
<p>This request replaces collection items or creates one if it does not exist.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">DELETE</code></p>
</td><td style="text-align: left" valign="top">
<p>This request deletes the entire collection.</p>
</td><td style="text-align: left" valign="top">
<p>This request deletes items from the collection.</p>
</td></tr></tbody></table></div><p>Refer to the Roy Fieldings' PhD thesis, which is the first and most complete work about REST, to learn more about REST at <a class="ulink" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Prototyping a RESTful backend with MongoLab</h1></div></div></div><p>Let's say we want to<a class="indexterm" id="id567"/> create a Backbone application that will communicate with a RESTful service. Should we start with creating a backend or a frontend? This question sounds like a dilemma, but the answer is very simple.</p><p>The easiest way is to create a prototype using a simple database with a REST-style interface, so we can quickly replace it with our own backend in the future.</p><p>There is a good tool for that named MongoLab<a class="indexterm" id="id568"/> (<a class="ulink" href="http://mongolab.com">http://mongolab.com</a>), <a class="indexterm" id="id569"/>which is the cloud version of MongoDB with a REST-style interface. MongoDB is a NoSQL document-oriented database that works with JSON-like data. MongoLab will not require us to write even a single line of code on the backend, so it is perfect for us as a prototyping tool.</p><p>To test and debug the MongoLab backend, we will use the Advanced REST client, which is an extension to the Chrome browser. It allows performing HTTP queries on a RESTful service and visualizes JSON data.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec207"/>Getting ready...</h2></div></div></div><p>Follow these steps to be prepared for this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an account on the MongoLab website (<a class="ulink" href="https://mongolab.com">https://mongolab.com</a>), or log in if you have an existing one.</li><li class="listitem">Install the Advanced REST client <a class="indexterm" id="id570"/>on your browser using the URL <a class="ulink" href="https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo">https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo</a>. If you're using Firefox or Safari, you can easily find a similar extension for this purpose.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec208"/>How to do it...</h2></div></div></div><p>Follow these steps to create a<a class="indexterm" id="id571"/> MongoLab database and fill it with data:</p><div><ol class="orderedlist arabic"><li class="listitem">Go to <a class="ulink" href="https://mongolab.com/newdb">https://mongolab.com/newdb</a> and create a new database named <code class="literal">billing-app</code> within your MongoLab account.</li><li class="listitem">Go to <code class="literal">https://mongolab.com/user?username=&lt;username&gt;</code> and get an API key that you can use for authentication.</li><li class="listitem">To check databases in your account, perform a <code class="literal">GET</code> request on a URI, say <code class="literal">https://api.mongolab.com/api/1/databases?apiKey=&lt;your-api-key&gt;</code>, using the Advanced REST client.<div><img alt="How to do it..." src="img/2728_07_01.jpg"/></div><p>The result will look like the following screenshot:</p><div><img alt="How to do it..." src="img/2728_07_02.jpg"/></div></li><li class="listitem">To get a list of collections in the database, perform a <code class="literal">GET</code> request on the URI <code class="literal">https://api.mongolab.com/api/1/databases/billing-app/collections?apiKey=&lt;your-api-key&gt;</code>. The result will look like the following screenshot:<div><img alt="How to do it..." src="img/2728_07_03.jpg"/></div></li><li class="listitem">To create a new collection, let's send the collection items defined in the JSON format using a <code class="literal">POST</code> query on this URI: <code class="literal">https://api.mongolab.com/api/1/databases/billing-app/collections/invoices?apiKey=&lt;your-api-key&gt;</code>. Make sure that the <strong>application/json Content-Type</strong> header is set.<div><img alt="How to do it..." src="img/2728_07_04.jpg"/></div><p>The result <a class="indexterm" id="id572"/>of such an operation will look like the following screenshot:</p><div><img alt="How to do it..." src="img/2728_07_05.jpg"/></div><p>By performing a <code class="literal">GET</code> request on the same resource again, we will be returned inserted items with their IDs in the JSON format.</p><div><img alt="How to do it..." src="img/2728_07_06.jpg"/></div></li><li class="listitem">To update an existing item in the collection, we need to perform a <code class="literal">PUT</code> request on the<a class="indexterm" id="id573"/> collection item resource, specified by its ID, in the URI <code class="literal">https://api.mongolab.com/api/1/databases/billing-app/collections/invoices/&lt;invoice-id&gt;?apiKey=&lt;your-api-key&gt;</code>. In the <code class="literal">PUT</code> request, we should pass an updated model in the JSON format. The result is also returned in JSON, as shown in the following screenshot:<div><img alt="How to do it..." src="img/2728_07_07.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec209"/>How it works...</h2></div></div></div><p>MogoLab translates <a class="indexterm" id="id574"/>HTTP requests into MongoDB queries, which are executed, and the results are returned in the MongoDB Extended JSON format.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec210"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the MongoLab's REST API to learn more about performing queries at <a class="ulink" href="https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB">https://support.mongolab.com/entries/20433053-REST-API-for-MongoDB</a>.</li><li class="listitem" style="list-style-type: disc">You can also visit the following URL in order to meet specifications of the MongoDB Extended JSON format at<a class="ulink" href="http://%20http://docs.mongodb.org/manual/reference/mongodb-extended-json/"> http://docs.mongodb.org/manual/reference/mongodb-extended-json/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Synchronizing models and collections with a RESTful service</h1></div></div></div><p>In this recipe, we are going<a class="indexterm" id="id575"/> to learn how to synchronize models and collections with a RESTful service. Just as we did in all other recipes, we will use MongoLab for a RESTful service.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec211"/>How to do it...</h2></div></div></div><p>Follow these steps to get familiar with REST in Backbone.js:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a configuration object that stores a server URL and an authentication key for MongoLab.<div><pre class="programlisting">var appConfig = {
  baseURL: 'https://api.mongolab.com/api/1/databases/billing-app/collections/',

  addURL: '?apiKey=kNCrqJUqB4n1S_qW7wnXH43NH9XKjdIL'
}</pre></div></li><li class="listitem">Define a <code class="literal">url()</code> method<a class="indexterm" id="id576"/> <a class="indexterm" id="id577"/>that returns a resource URL to perform a REST request. Such URLs should contain a model ID, if a model is already synchronized with a RESTful service. Also, such URLs should contain a MongoLab's authentication key.<div><pre class="programlisting">  var InvoiceModel = Backbone.Model.extend({
    url: function() {
      if (_.isUndefined(this.id)) {
        return appConfig.baseURL +
          'invoices' + appConfig.addURL;
      }
      else {
        return appConfig.baseURL + 'invoices/' +
          encodeURIComponent(this.id) + appConfig.addURL;
      }
    },
  });</pre></div><p>Another way to do this is to define the <code class="literal">urlRoot</code> property, though it does not allow adding parameters to the URL.</p><div><pre class="programlisting">  var InvoiceModel = Backbone.Model.extend({
    urlRoot: appConfig.baseURL;
  });</pre></div></li><li class="listitem">Define a new collection and a <code class="literal">url</code> property or <code class="literal">url()</code> method that should return the URL to a collection resource.<div><pre class="programlisting">  var InvoiceCollection = Backbone.Collection.extend({
    model: InvoiceModel,
    url: appConfig.baseURL +'invoices' + appConfig.addURL
  });</pre></div></li><li class="listitem">To load data from a server into a collection, use the <code class="literal">fetch()</code> method. You can pass <code class="literal">success</code> and <code class="literal">error</code> callbacks as a parameter. Either of them will be called asynchronously if a synchronization succeeds or fails.<div><pre class="programlisting">  var collection = new InvoiceCollection();

  collection.fetch({
    success: function(collection, response, options) {
      $('body').html(
        new View({ collection: collection}).render().el
      );
    },
    error: function(collection, response, options) {
      alert('error!');
    }
  });</pre></div><p>When the <code class="literal">fetch()</code> method<a class="indexterm" id="id578"/> is run, the read event is triggered. Also, on success, the sync event is triggered.</p></li><li class="listitem">To load a <a class="indexterm" id="id579"/>specific model that exists on a server, you can also use the <code class="literal">fetch()</code> method, which works in a similar way as it worked for collection.<div><pre class="programlisting">  var model = new InvoieModel();

  model.id = '5176396ce4b0c62bf3e53d79';
  model.fetch(
    success: function(model, response, options) {
      // success
    },
    error: function(collection, response, options) {
      // error
    }
  );</pre></div></li><li class="listitem">To sync a model with a RESTful service, use the <a class="indexterm" id="id580"/><code class="literal">save()</code> method.<div><pre class="programlisting">  model.save();</pre></div><p>To perform an update for a specific attribute, pass hash of changed attributes in the first parameter and <code class="literal">{patch: true}</code> in the second parameter.</p><div><pre class="programlisting">  model.save({ status: 'complete'}, {patch: true});</pre></div><p>By default, the <code class="literal">save()</code> method works asynchronously, so you need to handle results in the <code class="literal">success</code> or <code class="literal">error</code> callbacks. However, if you need to run the <code class="literal">save()</code> method synchronously, pass <code class="literal">null</code> in the first parameter and <code class="literal">{wait: true}</code> in the second parameter.</p><div><pre class="programlisting">  model.save(null, {wait: true});</pre></div></li><li class="listitem">You can <a class="indexterm" id="id581"/>create a new model within a collection using the <code class="literal">create()</code> method. In this case, Backbone.js automatically calls the <code class="literal">save()</code> method and a new module is pushed to the server.<div><pre class="programlisting">  var model = collection.create(
    { referenceNumber: '123', status: complete },
    { wait: true }
  );</pre></div></li><li class="listitem">You can destroy a model using the <code class="literal">destroy()</code> method<a class="indexterm" id="id582"/>, which removes a model both from a collection and a server.<div><pre class="programlisting">  model.save(null, {
    success: function(model, response, options) {
      // success
    },
    wait: true
 });</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec212"/>How it works...</h2></div></div></div><p>The <code class="literal">fetch()</code>, <code class="literal">save()</code>, or <code class="literal">destroy()</code> methods call the <code class="literal">sync()</code> method<a class="indexterm" id="id583"/> to perform HTTP queries to synchronize models and collections with a RESTful service. The <code class="literal">sync()</code> method accepts the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: It can be either create, update, patch, delete, or read.</li><li class="listitem" style="list-style-type: disc"><code class="literal">model</code>: It's either a model or a collection used to sync.</li><li class="listitem" style="list-style-type: disc"><code class="literal">options</code>: These are the options accepted by the <code class="literal">$.ajax</code> variable.</li></ul></div><p>You can override the <code class="literal">sync()</code> method if you need to override synchronization, or to use storage without a REST support.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec213"/>There's more...</h2></div></div></div><p>MongoLab returns data in the MongoDB Extended JSON format, which is not supported by Backbone.js by default. In this recipe, we are going to fix this and find a good solution to process MongoDB Extended JSON directly in a Backbone application.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec63"/>Handling MongoDB Extended JSON</h3></div></div></div><p>MongoLab (<a class="ulink" href="http://mongolab.com">http://mongolab.com</a>) is a RESTful service that transforms HTTP requests into <a class="indexterm" id="id584"/>MongoDB queries and returns the results in the MongoDB Extended JSON, which will look like the following code snippet:</p><div><pre class="programlisting">{ 
    "_id": { 
        "$oid": "516eb001e4b0799160e0e864" 
    }, 
}</pre></div><p>For appropriate results, we need to handle such IDs. The idea behind this is to override the <code class="literal">parse()</code> method<a class="indexterm" id="id585"/>, which processes JSON and initializes the model properties out of it. We are going to replace the format of an ID here:</p><div><pre class="programlisting">Backbone.Model.prototype.parse = function(resp, options) {
  if (_.isObject(resp._id)) {
    resp[this.idAttribute] = resp._id.$oid;
      delete resp._id;
  }
  return resp;
},
</pre></div><p>Also, when the <code class="literal">sync()</code> method is run, we need to make sure that data is exported in the MongoDB Extended JSON format. In all the other cases, it should be exported in a regular JSON format. Data export is performed only in the <code class="literal">toJSON()</code> method, so we can do this by replacing the <code class="literal">toJSON()</code> method<a class="indexterm" id="id586"/> during the <code class="literal">sync()</code> method execution.</p><div><pre class="programlisting">// Convert regular JSON into MongoDB extended one.
  Backbone.Model.prototype.toExtendedJSON= function() {
    var attrs = this.attributes;

    var attrs = _.omit(attrs, this.idAttribute);
    if (!_.isUndefined(this[this.idAttribute])) {
      attrs._id = { $oid: this[this.idAttribute] };
    }

    return attrs;
  },

// Substute toJSON method when performing synchronization.
  Backbone.Model.prototype.sync = function() {
    var toJSON = this.toJSON;
    this.toJSON = this.toExtendedJSON;

    var ret = Backbone.sync.apply(this, arguments);

    this.toJSON = toJSON;

    return ret;
  }
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec214"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a Backbone.js extension with Grunt</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Special Techniques">Chapter 8</a>, <em>Special Techniques</em></li><li class="listitem" style="list-style-type: disc">You may also be interested in checking the source code of <code class="literal">Backbone.sync</code> at <a class="ulink" href="http://backbonejs.org/docs/backbone.html#section-134">http://backbonejs.org/docs/backbone.html#section-134</a>.</li><li class="listitem" style="list-style-type: disc">Visit the following URL in order to meet specifications of MongoDB Extended JSON at <a class="ulink" href="http://docs.mongodb.org/manual/reference/mongodb-extended-json/">http://docs.mongodb.org/manual/reference/mongodb-extended-json/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Building a RESTful frontend with Backbone</h1></div></div></div><p>In this recipe, we<a class="indexterm" id="id587"/> are going to write a frontend application that will act as a client for a RESTful service. For the backend, we will use the MongoLab service, which is a cloud version of MongoDB with a REST interface.</p><p>We will use the <a class="indexterm" id="id588"/>LayoutManager extension to output our views in a neat format. To build our application, we will take an example app from <a class="link" href="ch06.html" title="Chapter 6. Templates and UX sugar">Chapter 6</a>, <em>Templates and UX sugar</em>, and will modify it, so it will support data sync via REST and will look like the following screenshot:</p><div><img alt="Building a RESTful frontend with Backbone" src="img/2728_07_08.jpg"/></div><p>In the left-hand side pane, we can see a list of invoice titles, and in the right-hand side pane, we can see the <a class="indexterm" id="id589"/>invoice details. By default, these details are shown for the first invoice until the user clicks on a link in the left-hand side pane.</p><p>If the user clicks on the <strong>Edit</strong> button, the following form is shown:</p><div><img alt="Building a RESTful frontend with Backbone" src="img/2728_07_09.jpg"/></div><p>When the user clicks on the <strong>Save</strong> button, the model is updated, and it's JSON is sent to the server via REST, and <a class="indexterm" id="id590"/>the list in the left pane is also updated.</p><p>If the user clicks on the <strong>Delete</strong> button, a delete confirmation form appears, as shown in the following screenshot:</p><div><img alt="Building a RESTful frontend with Backbone" src="img/2728_07_10.jpg"/></div><p>If the user confirms the deletion, the model is destroyed and removed from the server via REST.</p><p>Users can also<a class="indexterm" id="id591"/> create a new invoice by clicking on the <strong>Add an invoice</strong> link at the top of the page. Then, an Add Invoice form is shown, which is identical to the Edit form, with no data shown.</p><div><img alt="Building a RESTful frontend with Backbone" src="img/2728_07_11.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec215"/>Getting ready...</h2></div></div></div><p>Follow these<a class="indexterm" id="id592"/> steps to be prepared for this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure the LayoutManager extension is installed. The usage and installation of this extension is described in the <em>Assembling layouts with LayoutManager</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Templates and UX sugar">Chapter 6</a>, <em>Templates and UX Sugar</em>.</li><li class="listitem">Override <code class="literal">Backbone.Model</code> to support the MongoDB Extended JSON format, which is used in MongoLab.<div><pre class="programlisting">  // Convert MongoDB Extended JSON into regular JSON.
  Backbone.Model.prototype.parse = function(resp, options) {
    if (_.isObject(resp._id)) {
      resp[this.idAttribute] = resp._id.$oid;
      delete resp._id;
    }

    return resp;
  },


  // Convert regular JSON into MongoDB extended one.
  Backbone.Model.prototype.toExtendedJSON= function() {
    var attrs = this.attributes;

    var attrs = _.omit(attrs, this.idAttribute);
    if (!_.isUndefined(this[this.idAttribute])) {
      attrs._id = { $oid: this[this.idAttribute] };
    }

    return attrs;
  },

  // Substute toJSON method when performing synchronization.
  Backbone.Model.prototype.sync = function() {
    var toJSON = this.toJSON;
    this.toJSON = this.toExtendedJSON;

    var ret = Backbone.sync.apply(this, arguments);

    this.toJSON = toJSON;

    return ret;
  }
This allows Backbone to work correctly with data IDs in a format like this:
{ 
    "_id": { 
        "$oid": "516eb001e4b0799160e0e864" 
    }, 
}
</pre></div><p>This allows Backbone to work correctly with data IDs in a format like this:</p><div><pre class="programlisting">{ 
    "_id": { 
        "$oid": "516eb001e4b0799160e0e864" 
    }, 
}</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec216"/>How to do it...</h2></div></div></div><p>Follow these steps to<a class="indexterm" id="id593"/> create a RESTful application with Backbone:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a configuration object that we will store the server URL and authentication key.<div><pre class="programlisting">var appConfig = {
  baseURL: 'https://api.mongolab.com/api/1/databases/billing-app/collections/',

  addURL: '?apiKey=kNCrqJUqB4n1S_qW7wnXH43NH9XKjdIL'
}</pre></div></li><li class="listitem">Define <code class="literal">InvoiceModel</code> and set the <code class="literal">url()</code> method, which will return the model's resource URL to perform REST requests.<div><pre class="programlisting">  var InvoiceModel = Backbone.Model.extend({
    url: function() {
      if (_.isUndefined(this.id)) {
        return appConfig.baseURL +
          'invoices' + appConfig.addURL;
      }
      else {
        return appConfig.baseURL + 'invoices/' +
          encodeURIComponent(this.id) + appConfig.addURL;
      }
    },
  });</pre></div></li><li class="listitem">Define <code class="literal">InvoiceCollection</code> and the <code class="literal">url()</code> method for the model.<div><pre class="programlisting">  var InvoiceCollection = Backbone.Collection.extend({
    model: InvoiceModel,
    url: function() {
      return appConfig.baseURL +
        'invoices' + appConfig.addURL;
    },
  });</pre></div></li><li class="listitem">Define a<a class="indexterm" id="id594"/> router and add the <code class="literal">initialize()</code> method, which creates an empty collection and layout objects and renders a layout.<div><pre class="programlisting">  // Define router object.
  var Workspace = Backbone.Router.extend({
    initialize: function() {

      //  Create collection.
      this.collection = new InvoiceCollection();

      // Create new layout.
      this.layout = new Backbone.Layout({
          // Attach the layout to the main container.
          el: 'body',

          // Set template selector.
          template: '#layout',

          // Declaratively bind a nested View to the layout.
          views: {
            '#first-pane': new InvoiceListPane({
              collection: this.collection
            }),
          },
      });

      // Render whole layout for the first time.
      this.layout.render();
    },
  });</pre></div></li><li class="listitem">Add a<a class="indexterm" id="id595"/> layout template into <code class="literal">index.html</code>.<div><pre class="programlisting">  &lt;script class="template" type="template" id="layout"&gt;
    &lt;h1&gt;Billing application&lt;/h1&gt;
    &lt;div id="links-pane"&gt;
      &lt;a href="#invoice/add"&gt;+ Add an invoice&lt;/a&gt;
    &lt;/div&gt;
    &lt;div id="first-pane"&gt;&lt;/div&gt;
    &lt;div id="second-pane"&gt;&lt;/div&gt;
  &lt;/script&gt;</pre></div></li><li class="listitem">Add <code class="literal">routes</code> and callbacks to the router object. Each callback calls the <code class="literal">switchPane()</code> method<a class="indexterm" id="id596"/>, which switches the right-hand side pane of the layout.<div><pre class="programlisting">    routes: {
      '': 'invoicePage',
      'invoice': 'invoicePage',
      'invoice/add': 'addInvoicePage',
      'invoice/:id/edit': 'editInvoicePage',
      'invoice/:id/delete': 'deleteInvoicePage',
      'invoice/:id': 'invoicePage',
    },

    // Page callbacks.
    invoicePage: function(id) {
      this.switchPane('InvoicePane', id);
    },
    addInvoicePage: function() {
      this.switchPane('EditInvoicePane', null);
    },
    editInvoicePage: function(id) {
      this.switchPane('EditInvoicePane', id);
    },
    deleteInvoicePage: function(id) {
      this.switchPane('DeleteInvoicePane', id);
    },</pre></div></li><li class="listitem">Add<a class="indexterm" id="id597"/> the <code class="literal">switchPane()</code> method to <a class="indexterm" id="id598"/>the router, which fetches collection from the RESTful service and switches the right-hand side pane.<div><pre class="programlisting">    switchPane: function(pane_name, id) {

      // Define panes array.
      // This will allow use to create new object from string. 
      var panes = {
        InvoicePane: InvoicePane,
        EditInvoicePane: EditInvoicePane,
        DeleteInvoicePane: DeleteInvoicePane 
      };

      // Update collection.
      this.collection.fetch({ success: function(collection) {

        // Get model by id or take first model
        // from collection.
        var model = _.isUndefined(id) ?
          collection.at(0) : collection.get(id);

        // Create new pane and pass model and collection.
        pane = new panes[pane_name] ({
          model: model, collection: collection
        });

        // Render pane.
        pane.render();

        // Switch views.
        window.workspace.layout.removeView('#second-pane');
        window.workspace.layout.setView('#second-pane', pane);

      }, reset: true });
    },</pre></div></li><li class="listitem">Define the invoice list pane.<div><pre class="programlisting">  var InvoiceListPane = Backbone.Layout.extend({

    // Returns selector for template.
    template: '#invoice-list-pane',

    // Set selector for template.
    serialize: function() {
      return { invoices: _.chain(this.collection.models) };
    },

    // Bind callbacks to collection event.
    initialize: function() {
      this.listenTo(this.collection, 'reset', this.render);
    }
  });</pre></div><p>Add a template for it in <code class="literal">index.html</code>.</p><div><pre class="programlisting"> &lt;script class="template" type="template" id="invoice-list-pane"&gt;
    &lt;h3&gt;Invoices:&lt;/h3&gt;
    &lt;ul&gt;
      &lt;% invoices.each(function(invoice) { %&gt;
        &lt;li&gt;
          &lt;a href="#invoice/&lt;%= invoice.id %&gt;"&gt;
            &lt;%= invoice.get('referenceNumber') %&gt;
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;% }); %&gt;
    &lt;/ul&gt;
  &lt;/script&gt;</pre></div></li><li class="listitem">Define a<a class="indexterm" id="id599"/> view invoice pane.<div><pre class="programlisting">  var InvoicePane = Backbone.Layout.extend({

    // Set selector for template.
    template: '#invoice-pane',

    // Returns data for template.
    serialize: function() {
      return { invoice: this.model };
    },

    // Bind callbacks to model events.
    initialize: function() {
      this.listenTo(this.model, 'change', this.render);
    }
  });</pre></div><p>Add a template for it in <code class="literal">index.html</code>.</p><div><pre class="programlisting">  &lt;script class="template" type="template" id="invoice-pane"&gt;
    &lt;h3&gt;Invoice details:&lt;/h3&gt;
    Reference Number:
      &lt;%= invoice.get('referenceNumber') %&gt;&lt;br&gt;
    Date: &lt;%= invoice.get('date') %&gt;&lt;br&gt;
    Status: &lt;%= invoice.get('status') %&gt;&lt;br&gt;
    &lt;br&gt;
    &lt;a href="#invoice/&lt;%= invoice.id %&gt;/edit" class="btn"&gt;
      Edit
    &lt;/a&gt;
    &lt;a href="#invoice/&lt;%= invoice.id %&gt;/delete" class="btn"&gt;
      Delete
    &lt;/a&gt;
  &lt;/script&gt;</pre></div></li><li class="listitem">Define<a class="indexterm" id="id600"/> an edit invoice pane.<div><pre class="programlisting">  var EditInvoicePane = Backbone.Layout.extend({

    // Set selector for template.
    template: '#edit-invoice-pane',

    // Returns data for template.
    serialize: function() {

      // Create new model if no model is given.
      return {
        invoice:
          _.isEmpty(this.model) ?
            new InvoiceModel() : this.model
      };
    },

    // Bind callbacks form events.
    events: {
      "click .submit": "save"
    },

    // Save model
    save: function() {
      var data = {
        referenceNumber: 
          this.$el.find('.referenceNumber').val(),
        date: this.$el.find('.date').val(),
        status: this.$el.find('.status').val(),
      };

      var success = function(model, response, options) {
        window.workspace.navigate('#invoice/' + model.id, {
          trigger: true
        });
      };

      // Run appropriate method.
      if (_.isEmpty(this.model)) {
        this.collection.create(data, {success: success});
      }
      else {
        this.model.save(data, { success: success});
      }
    }
  });</pre></div><p>Add a<a class="indexterm" id="id601"/> template for it in <code class="literal">index.html</code>.</p><div><pre class="programlisting">  &lt;script class="template" type="template"
      id="edit-invoice-pane"&gt;
    &lt;h3&gt;Enter invoice details:&lt;/h3&gt;
    Reference Number:&lt;br&gt;
    &lt;input class="referenceNumber" type="text"
          value="&lt;%= invoice.get('referenceNumber') %&gt;"&gt;&lt;br&gt;
    Date:&lt;br&gt;
    &lt;input class="date" type="text"
          value="&lt;%= invoice.get('date') %&gt;"&gt;&lt;br&gt;
    Status:&lt;br&gt;
    &lt;input class="status" type="text"
          value="&lt;%= invoice.get('status') %&gt;"&gt;&lt;br&gt;
    &lt;button class="btn btn-primary submit"&gt;Save&lt;/button&gt;
  &lt;/script&gt;</pre></div></li><li class="listitem">Define a delete invoice pane.<div><pre class="programlisting">  var DeleteInvoicePane = Backbone.Layout.extend({

    // Set selector for template.
    template: '#delete-invoice-pane',

    // Returns data for template.
    serialize: function() {
      return { invoice: this.model };
    },

    // Bind callbacks to form events.
    events: {
      "click .submit": "delete"
    },

    // Delete model.
    delete: function() {
      this.model.destroy({
        success: function(model, response) {
          window.workspace.navigate('#invoice', {
            trigger: true 
        });
      }});
    }
  });</pre></div><p>Add a template for it in <code class="literal">index.html</code>.</p><div><pre class="programlisting">&lt;script class="template" type="template"
    id="delete-invoice-pane"&gt;
  &lt;h3&gt;Are you sure you want to delete invoice
  &lt;%= invoice.get('referenceNumber') %&gt;?&lt;/h3&gt;
  &lt;button class="btn submit btn-primary"&gt;Yes&lt;/button&gt;
  &lt;a href="#invoice/&lt;%= invoice.id %&gt;" class="btn"&gt;No&lt;/a&gt;
&lt;/script&gt;</pre></div></li><li class="listitem">Create a<a class="indexterm" id="id602"/> router instance and start the application.<div><pre class="programlisting">  // Create the workspace.
  window.workspace = new Workspace();

  // Start the application.
  Backbone.history.start();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec217"/>How it works...</h2></div></div></div><p>To load the collection from a RESTful service, we need to call the <code class="literal">fetch()</code> method, which runs asynchronously as a regular AJAX call does. If we need to run any code after the data is fetched successfully, we need to pass the callback function in a second parameter keyed by the <code class="literal">success</code> key. If we need to perform a fallback behavior in case of an error, we should pass the callback function keyed by the <code class="literal">error</code> key in the function parameter.</p><div><pre class="programlisting">collection.fetch({
  success: function(collection, response, options){
    // success behavior
  },

  error: function(collection, response, options){
    // fall back behavior
  }
 })</pre></div><p>To sync<a class="indexterm" id="id603"/> model with a remote server via REST, we use the <code class="literal">save()</code> method. To remove the model entirely from a remote server, we use the <a class="indexterm" id="id604"/>
<code class="literal">destroy()</code> method. Both the methods accept the <code class="literal">success</code> and <code class="literal">error</code> callbacks.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec218"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Assembling layouts with LayoutManager</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Templates and UX sugar">Chapter 6</a>, <em>Templates and UX sugar</em></li><li class="listitem" style="list-style-type: disc">Refer to the official docs to get more information about Backbone methods we used in this recipe at <a class="ulink" href="http://backbonejs.org/">http://backbonejs.org/</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Using the polling technique to fetch data</h1></div></div></div><p>In the previous recipes, <a class="indexterm" id="id605"/>we were fetching data into a <a class="indexterm" id="id606"/>collection each time the router processed a URL change. We may wonder what happens if someone else updates data in the same storage? Can we see the updates immediately?</p><p>You might have seen how Facebook or Twitter updates a news feed in real time, and you may want to implement a similar behavior in your application. Typically, it can be done using the polling technique, which we are going to learn in this recipe.</p><p>We are going to create a web application that will update the collection view dynamically with the help of a polling technique.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec219"/>Getting ready...</h2></div></div></div><p>Override <code class="literal">Backbone.Model</code> and <code class="literal">Backbone.Collection</code> to support the MongoDB Extended JSON format, which is used in MongoLab.</p><div><pre class="programlisting">    // Convert MongoDB Extended JSON into regular JSON.
  Backbone.Model.prototype.parse = function(resp, options) {
    if (_.isObject(resp._id)) {
      resp[this.idAttribute] = resp._id.$oid;
      delete resp._id;
    }

    return resp;
  },


  // Convert regular JSON into MongoDB extended one.
  Backbone.Model.prototype.toExtendedJSON= function() {
    var attrs = this.attributes;

    var attrs = _.omit(attrs, this.idAttribute);
    if (!_.isUndefined(this[this.idAttribute])) {
      attrs._id = { $oid: this[this.idAttribute] };
    }

    return attrs;
  },

  // Substute toJSON method when performing synchronization.
  Backbone.Model.prototype.sync = function() {
    var toJSON = this.toJSON;
    this.toJSON = this.toExtendedJSON;

    var ret = Backbone.sync.apply(this, arguments);

    this.toJSON = toJSON;

    return ret;
  }
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec220"/>How to do it...</h2></div></div></div><p>Follow these steps<a class="indexterm" id="id607"/> to implement the polling technique:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new polling collection that fetches data recursively and provides methods to start or stop polling.<div><pre class="programlisting">  var PollingCollection = Backbone.Collection.extend({
    polling: false,

    // Set default interval in seconds.
    interval: 1,

    // Make all object methods to work from its own context.
    initialize: function() {
      _.bindAll(this);
    },

    // Starts polling.
    startPolling: function(interval) {
      this.polling = true;

      if (interval) {
        this.interval = interval;
      }
      this.executePolling();
    },

    // Stops polling.
    stopPolling: function() {
      this.polling = false;
    },

    // Executes polling.
    executePolling: function() {
      this.fetch({
        success: this.onFetch, error: this.onFetch
      });
    },

    // Runs recursion.
    onFetch: function() {
      setTimeout(this.executePolling, 1000 * this.interval)
    },
  });</pre></div></li><li class="listitem">Define <a class="indexterm" id="id608"/>a <a class="indexterm" id="id609"/>configuration object.<div><pre class="programlisting">  var appConfig = {
    baseURL:'https://api.mongolab.com/api/1/databases/billing-app/collections/',
    addURL: '?apiKey=kNCrqJUqB4n1S_qW7wnXH43NH9XKjdIL'
  }
Define a model and a collection.
  var InvoiceModel = Backbone.Model.extend({
    url: function() {
      if (_.isUndefined(this.id)) {
        return appConfig.baseURL + 'invoices' +
          appConfig.addURL;
      }
      else {
        return appConfig.baseURL + 'invoices/' +
          encodeURIComponent(this.id) + appConfig.addURL;
      }
    },
  });


  var InvoiceCollection = PollingCollection.extend({
    model: InvoiceModel,
    url: function() {
      return appConfig.baseURL + 'invoices' +
        appConfig.addURL;
    },
  });</pre></div></li><li class="listitem">Define <a class="indexterm" id="id610"/>an <a class="indexterm" id="id611"/>invoice view and bind callbacks to model events.<div><pre class="programlisting">  var InvoiceView = Backbone.View.extend({

    // Define element tag name.
    tagName: 'li',

    // Define template.
    template: _.template('Invoice #&lt;%= referenceNumber %&gt;.'),

    // Render view.
    render: function() {
      $(this.el).html(this.template(this.model.toJSON()));

      return this;
    },

    // Bind callback to the model events.
    initialize: function() {
      this.listenTo(this.model, 'change', this.render, this);
      this.listenTo(this.model, 'destroy', this.remove, this);
    }
  });</pre></div></li><li class="listitem">Define an invoice <a class="indexterm" id="id612"/>list view and bind callbacks to collection events.<div><pre class="programlisting">  var InvoiceListView = Backbone.View.extend({

    // Define element tag name.
    tagName: 'ul',

    // Render view.
    render: function() {
      $(this.el).empty();

      // Append table  with a row.
      _.each(this.collection.models, function(model, key) {
        this.append(model);
      }, this);

      return this;
    },

    // Add invoice item row to the table.
    append: function(model) {
      $(this.el).append(
         new InvoiceView({ model: model }).render().el
      );
    },

    // Remove model from collection.
    remove: function(model) {
      model.trigger('destroy');
    },

    // Bind callbacks to the collection events.
    initialize: function() {
     this.listenTo(this.collection,'reset',this.render,this);     
     this.listenTo(this.collection,'add',this.appen,this);
     this.listenTo(this.collection,'remove',this.remove,this);
    },
  });</pre></div></li><li class="listitem">Create a<a class="indexterm" id="id613"/> collection and render the corresponding view.<div><pre class="programlisting">    collection = new InvoiceCollection();

    $('body').append('&lt;h3&gt;Invoices&lt;/h3&gt;')
    $('body').append(new InvoiceListView({
      collection: collection,
    }).render().el);</pre></div></li><li class="listitem">Start polling.<div><pre class="programlisting">    collection.startPolling();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec221"/>How it works...</h2></div></div></div><p>The idea behind <a class="indexterm" id="id614"/>polling is to fetch the server regularly. However, we can't do this in a simple loop, because fetching works asynchronously, and we need to make sure AJAX requests do not overlap with each other. Thus, we need to make sure previous fetching is completed successfully before performing the next one.</p><p>In this recipe, <a class="indexterm" id="id615"/>we inherited a collection from <code class="literal">Backbone.Collection</code> and added new methods and properties that we needed to implement polling. In the <code class="literal">executePolling()</code> method<a class="indexterm" id="id616"/>, we are performing the <code class="literal">fetch()</code> method and passing the <code class="literal">onFetch()</code> method as a success callback. In the <code class="literal">onFetch() method</code><a class="indexterm" id="id617"/>, we call the <code class="literal">executePolling()</code> method with a timeout.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Working with local storage</h1></div></div></div><p>Sometimes, we need to <a class="indexterm" id="id618"/>store data on a browser storage rather than on a remote server. This is quite easy to do with the help of the Backbone extension known as localStorage Adapter, which overrides the behavior of the <code class="literal">Backbone.sync()</code> method<a class="indexterm" id="id619"/>
<a class="indexterm" id="id620"/> to sync data with HTML5 local storage. In this recipe, we are going to learn how to use this extension.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec222"/>Getting ready...</h2></div></div></div><p>You can download<a class="indexterm" id="id621"/> the Backbone localStorage adapter from its GitHub page at <a class="ulink" href="https://github.com/jeromegn/Backbone.localStorage">https://github.com/jeromegn/Backbone.localStorage</a>. To include this extension into your project, save the <code class="literal">backbone.localStorage.js</code> file into the <code class="literal">lib</code> folder and include a reference to it in <code class="literal">index.html</code>.</p><p>Including Backbone extension into your project is described in detail in the <em>Extending an application with plugins</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Backbone">Chapter 1</a>, <em>Understanding Backbone</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec223"/>How to do it...</h2></div></div></div><p>Extend the collection and set the <code class="literal">localStorage</code> key as follows:</p><div><pre class="programlisting">  var InvoiceCollection = Backbone.Collection.extend({
    model: InvoiceModel,

    // Use local storage.
    localStorage:
      new Backbone.LocalStorage("InvoiceCollection")
  });</pre></div><p>Here, we create an instance of <code class="literal">Backbone.LocalStorage</code> and pass the storage name as a constructor parameter. The storage name should be unique within your application.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec224"/>How it works...</h2></div></div></div><p>Backbone's localStorage adapter overrides<a class="indexterm" id="id622"/> the <code class="literal">Backbone.sync()</code> method, which executes a code to synchronize data with the HTML5 localStorage, if it is enabled for a collection.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p><strong>Be aware when creating new models</strong></p><p>The only thing you should avoid when using the localStorage adapter is creating new models and saving them by calling the <code class="literal">save()</code> method of the model. Instead, you should call the <code class="literal">create()</code> method of the collection object, because otherwise the model is not associated to a collection yet, and the localStorage adapter has no idea which local storage to use.</p><p>After the model is associated with a collection, the <code class="literal">save()</code> method works pretty well.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec225"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is also a Backbone extension that allows storing data in the WebSQL storage at <a class="ulink" href="https://github.com/MarrLiss/backbone-websql">https://github.com/MarrLiss/backbone-websql</a>.</li><li class="listitem" style="list-style-type: disc">There are plenty of extensions that allow using different storage engines at <a class="ulink" href="https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage">https://github.com/documentcloud/backbone/wiki/Extensions,-Plugins,-Resources#storage</a>.</li></ul></div></div></div></body></html>