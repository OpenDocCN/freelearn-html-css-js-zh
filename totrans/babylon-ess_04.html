<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Materials to Customize 3D Objects Appearance</h1></div></div></div><p>The objects that we call <em>materials</em> are essential in 3D rendering. They are used to render objects on the screen and how they are rendered. This means that the materials are used to apply textures and transformations such as waves, for example, manage transparency and more. In other words, materials are interfaces that are used to easily customize the 3D object's appearance.</p><p>The following is an example with Babylon.js:</p><pre class="programlisting">myMesh.material = new BABYLON.StandardMaterial("material", scene); &#13;
// Done! Now customize everything you want here &#13;
myMesh.material.diffuseTexture = diffuseTexture; &#13;
myMesh.material.transparency = 0.5; &#13;
// Etc. &#13;
</pre><p>We will be covering the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discussing the awesome theory behind the materials</li><li class="listitem" style="list-style-type: disc">Using the Babylon.js standard material</li><li class="listitem" style="list-style-type: disc">Using textures with materials</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec18"/>Discussing the awesome theory behind the materials</h1></div></div></div><p>The materials are used to customize 3D objects appearance; however, behind them lie two programs called <strong>shaders</strong>. The goal of materials is to hide this notion of shaders and simply work with the values in the material object. In other words, the values in the material can be the emissive color of the object, the diffuse color, the transparency level and so on.</p><p>In fact, to go further with the theory, there are several types of shader, as shown in the following list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Vertex Shader</strong>: This works directly on the 3D object geometry.</li><li class="listitem" style="list-style-type: disc"><strong>Pixel Shader</strong>: This works directly on the pixels on the screen.</li><li class="listitem" style="list-style-type: disc"><strong>Geometry Shader</strong> (not available on WebGL): This works on the 3D object geometry; however, here it is able to directly add polygons to the geometry of the 3D object according to the output of the vertex shader.</li><li class="listitem" style="list-style-type: disc"><strong>Compute Shader</strong> (not available on WebGL): This doesn't work directly on the 3D objects and pixels. It is just used to compute some user-defined data using the GPU instead of the CPU. For example, a compute shader will take a texture as the input (you can see that as a big matrix) and output the results of the program in another texture. The compute shader is highly used, for example, to compute realistic ocean waves or neural networks.</li><li class="listitem" style="list-style-type: disc"><strong>Tesselation Shader</strong> (not available on WebGL): This allows us to compute <strong>Level of Detail</strong> (<strong>LOD</strong>) directly on the GPU instead of the CPU (fairly new in the modern rendering pipelines, such as Direct3D 11 and OpenGL 4.0).</li></ul></div><p>In our case and with WebGL, only the vertex and pixel shaders are used to render 3D scenes on the screen; however, it would not be surprising to see the other types of shaders being implemented in WebGL in the future.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>The theory</h2></div></div></div><p>The meshes that we created in the previous chapters contain vertex buffers and index buffers. The vertex buffers describe the 3D positions of the vertices. The main problem is how to project the vertices in a 3D space into a 2D space, which is the screen space. Indeed, to draw elements on the screen, GPUs are used through programs to transform the vertices positions into 2D positions on the screen. These programs are the vertex shader and the pixel shader. They are written with a language named GLSL, which is the OpenGL shading language used with WebGL.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>The vertex shader</h2></div></div></div><p>The vertex shader is used to transform the vertices positions. It is executed by the GPU for each vertex and can be used for an infinite number of functions. For example, to create waves on a large ocean plane, we will use the vertex shader to compute the wave function for each vertex instead of using the TS code that is executed on the CPU side–leave the job to the real worker.</p><p>Once the vertex shader computes a triangle (a face) on the screen, thanks to the index buffer, the pixel shader is called to illuminate the pixels used by the current triangle (current face) of the current mesh that is rendered.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>The pixel shader</h2></div></div></div><p>The pixel shader has the same structure as the vertex shader; it is written with the same language (GLSL) and is called for each pixel used by the current triangle on the screen. The main function of the pixel shader is to return a color computed in the RGBA format, which can be determined from a user-defined value or directly from a texture.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec19"/>Using the Babylon.js standard material</h1></div></div></div><p>Babylon.js allows you to create materials, which means that it can create the custom materials with custom shaders; however, it provides a standard material with already-developed shaders that are designed to be adapted by many customizations.</p><p>In fact, when you add a light to a Babylon.js scene, the light properties such as diffuse color, are sent to the materials of the scene to compute the light contributions on the meshes.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>The standard material and its common properties</h2></div></div></div><p>In Babylon.js, each mesh has a material and the meshes can share the same material. Creating a standard material and assigning it to a mesh with Babylon.js is as easy as writing the following:</p><pre class="programlisting">myMesh.material = new BABYLON.StandardMaterial("materialName", scene); &#13;
</pre><p>Simply create a new <code class="literal">StandardMaterial</code> object by giving a name to the material and the scene where you want to add the material and assign it <code class="literal">the.material</code> property of a mesh. Once the material is created, you can start modifying the values and then customize the mesh appearance. The default material by default looks similar to the following image:</p><p>
</p><div><img src="img/image_04_001.png" alt="The standard material and its common properties"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The diffuse color: The diffuse color represents the color of the object, as follows:</li></ul></div><pre class="programlisting">    myMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Blue &#13;
</pre><p>
</p><div><img src="img/image_04_002.png" alt="The standard material and its common properties"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The specular color: The specular color represents the light color reflected by the object (this is mixed with the diffuse color), as shown in the following:</li></ul></div><pre class="programlisting">    myMaterial.specularColor = new BABYLON.Color3(1, 0, 0); // Red &#13;
</pre><p>
</p><div><img src="img/image_04_003.png" alt="The standard material and its common properties"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The emissive color: The emissive color represents the color emitted by the object (this is mixed with the specular color and the diffuse color), as follows:</li></ul></div><pre class="programlisting">    myMaterial.emissiveColor = new BABYLON.Color3(0, 1, 0); // Gre      en &#13;
</pre><p>
</p><div><img src="img/image_04_004.png" alt="The standard material and its common properties"/></div><p>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manage transparency: To manage transparency, the standard material provides a .alpha property in the [0, 1] interval, as follows:</li></ul></div><pre class="programlisting">myMaterial.alpha = 0.2; // 80% transparent &#13;
</pre><p>
</p><div><img src="img/image_04_005.png" alt="The standard material and its common properties"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Using the fog</h2></div></div></div><p>The standard material allows you to apply the fog effect that is related to the current scene that is rendered. To enable the fog on an object, simply set <code class="literal">the.fogEnabled</code> property to true on the materials and the scene, as shown in the following:</p><pre class="programlisting">myMaterial.fogEnabled = true; &#13;
scene.fogEnabled = true; &#13;
</pre><p>Let's start with the following scene:</p><p>
</p><div><img src="img/image_04_006.png" alt="Using the fog"/></div><p>
</p><p>The fog in a scene can be customized. There are several types of fog, as shown in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Linear fog (<code class="literal">BABYLON.Scene.FOGMODE_LINEAR</code>)</li><li class="listitem" style="list-style-type: disc">Exponential (<code class="literal">BABYLON.Scene.FOGMODE_EXP</code>)</li><li class="listitem" style="list-style-type: disc">Exponential 2 (faster than the previous) (<code class="literal">BABYLON.Scene.FOGMODE_EXP2</code>)</li></ul></div><p>With the linear mode, the two properties—<code class="literal">scene.fogStart</code> and <code class="literal">scene.fogEnd</code>—can be set. Consider the following, as an example:</p><pre class="programlisting">scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR; &#13;
scene.fogStart = 10; &#13;
scene.fogEnd = 100; &#13;
</pre><p>
</p><div><img src="img/image_04_007.png" alt="Using the fog"/></div><p>
</p><p>Change the fog color using the following:</p><pre class="programlisting">scene.fogColor = new BABYLON.Color3(1, 1, 1); // White &#13;
</pre><p>
</p><div><img src="img/image_04_008.png" alt="Using the fog"/></div><p>
</p><p>With the exponential mode, the <code class="literal">scene.fogDensity</code> property can be set.</p><p>Consider the following as an example:</p><pre class="programlisting">scene.fogMode = BABYLON.Scene.FOGMODE_EXP; &#13;
scene.fogDensity = 0.02; &#13;
</pre><p>
</p><div><img src="img/image_04_009.png" alt="Using the fog"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Using textures with materials</h1></div></div></div><p>This chapter is the right place to introduce the usage of textures. Textures are images (<code class="literal">.png</code>,<code class="literal">.jpeg</code>, and so on) that graphics libraries are able to apply to meshes. There are several types of texturing methods handled by Babylon.js, such as video textures, cube textures, and so on. Now, let's explain how to use textures with materials.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Load and apply a texture</h2></div></div></div><p>As you may have already guessed, loading and applying a texture to a mesh can be easy with Babylon.js. The standard material provides a way, as for colors, to apply a diffuse texture (for example, specular, emissive, and ambient textures). Simply set the <code class="literal">.diffuseTexture</code> property to the reference of your texture, as follows:</p><pre class="programlisting">myMaterial.diffuseTexture = myTexture; &#13;
</pre><p>To create the <code class="literal">myTexture</code> object, let's take a look at the <code class="literal">BABYLON.Texture</code> class, as shown in the following:</p><pre class="programlisting">var myTexture = new BABYLON.Texture("path_to_texture.png", scene); &#13;
</pre><p>This is done now. The diffuse texture will now be applied to the mesh. Consider the <code class="literal">floor_diffuse.png</code> image in the example files as an example:</p><p>
</p><div><img src="img/image_04_010.png" alt="Load and apply a texture"/></div><p>
</p><p>Now, let's play with the texture's properties. In the example files, there is a <code class="literal">cloud.png</code> texture that contains an alpha channel (transparency). If you apply the cloud texture, the result is as shown in the following image:</p><p>
</p><div><img src="img/image_04_011.png" alt="Load and apply a texture"/></div><p>
</p><p>The black part represents the alpha channel and looks like an artifact that pollutes the rendering part of the sphere. In fact, the textures are applied on meshes thanks to the pixel shaders, and you must tell the shaders that the textures can contain an alpha channel. This job can be done thanks to the <code class="literal">.hasAlpha</code> property of the texture, as follows:</p><pre class="programlisting">cloudTexture.hasAlpha = true; &#13;
</pre><p>The result is the following image:</p><p>
</p><div><img src="img/image_04_012.png" alt="Load and apply a texture"/></div><p>
</p><p>You can see that the back faces of the sphere are not rendered. This is due to the optimization of the graphics libraries as it is not necessarily needed (in most cases) to render the triangles of the back faces that the cameras cannot see. It is called <code class="literal">back-face culling</code>.</p><p>To disable the <code class="literal">back-face culling</code>, simply set the <code class="literal">.backFaceCulling</code> property of the material to false, as follows:</p><pre class="programlisting">myMaterial.backFaceCulling = false; &#13;
</pre><p>The result is as shown in the following image:</p><p>
</p><div><img src="img/image_04_013.png" alt="Load and apply a texture"/></div><p>
</p><p>Since textures are applied by the pixel shaders, a lot of parameters can be set thanks to the materials, for example, the vertical and horizontal scales of the texture. Let's start with the following texture:</p><p>
</p><div><img src="img/image_04_014.png" alt="Load and apply a texture"/></div><p>
</p><p>The <code class="literal">.uScale</code> and<code class="literal">.vScale</code> properties of a texture allow us to apply a repeat pattern to the mesh. The 1.0 default value means that the texture is repeated once on the mesh. Let's see the following result with <code class="literal">5.0</code>:</p><pre class="programlisting">myTexture.uScale = 5.0; &#13;
myTexture.vScale = 5.0; &#13;
</pre><p>
</p><div><img src="img/image_04_015.png" alt="Load and apply a texture"/></div><p>
</p><p>As for the textures scales, you can create an offset to adjust the texture's positions on the mesh according to the <code class="literal">.uScale</code> and<code class="literal">.vScale</code> properties, as follows:</p><pre class="programlisting">myTexture.vScale = 0.2; &#13;
myTexture.uScale = 0.2; &#13;
</pre><p>
</p><div><img src="img/image_04_016.png" alt="Load and apply a texture"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>The bump mapping</h2></div></div></div><p>In the texturing methods that Babylon.js is handling, we can the find the bump mapping technique. This technique is used to create a relief on a surface and have more realistic surfaces using two different textures: the diffuse texture and a <em>normal texture</em>. This technique is famous as it doesn't modify the original geometry of the mesh and is only computed by the shaders using the two textures.</p><p>The diffuse and normal textures are provided by the artists and are built by some artist's tools to help the production. An example of normal texture is as follows:</p><p>
</p><div><img src="img/image_04_017.png" alt="The bump mapping"/></div><p>
</p><p>In fact, the pixel shader applies the diffuse texture and modifies the pixels in the function of the normal texture.</p><p>Let's see the normal mapping effect. This is without normal mapping:</p><p>
</p><div><img src="img/image_04_018.png" alt="The bump mapping"/></div><p>
</p><p>With normal mapping, the image will look similar to the following:</p><p>
</p><div><img src="img/image_04_019.png" alt="The bump mapping"/></div><p>
</p><p>Applying the normal mapping effect with Babylon.js is as easy as applying a diffuse texture. Let's explain this with the following two lines of code:</p><pre class="programlisting">myMaterial.diffuseTexture = new BABYLON.Texture("diffuse.png", scene); &#13;
myMaterial.bumpTexture = new BABYLON.Texture("normal.png", scene); &#13;
</pre><p>The internal effect of the material is able to adapt the rendering in the function of the properties. Then, if the <code class="literal">.bumpTexture</code> property is set, the effect will compute the bump mapping technique.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Advanced texturing</h2></div></div></div><p>The standard material of Babylon.js allows us to apply a reflection texture. If this texture is set, the internal effect of the material will create a reflection effect using this texture.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>The cube texture</h3></div></div></div><p>The cube texture is special. An interesting use of the reflection texture with a cube texture is the skybox mesh. A skybox is composed of six faces and tends to reproduce the environment around a scene, typically the sky. To handle the six faces with a texture, the cube texture will load six textures and apply them to the mesh.</p><p>Let's load a cube texture with Babylon.js, as follows:</p><pre class="programlisting">var cubeTexture = new BABYLON.CubeTexture("skybox/TropicalSunnyDay", scene); &#13;
</pre><p>The parameters are as shown in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The path to the six textures. Each texture name must begin with <code class="literal">TropicalSunnyDay</code> in this example, followed by the six directions of the cube: <code class="literal">nx</code>, <code class="literal">ny</code>, <code class="literal">nz</code>, <code class="literal">px</code>, <code class="literal">py</code>, and <code class="literal">pz</code>.</li><li class="listitem" style="list-style-type: disc">The scene where to add the cube texture.</li></ul></div><div><div><h3 class="title"><a id="note5"/>Note</h3><p>Note: the default extension for the cube texture is .jpg. You can learn of the precise extension by passing a third parameter, which is an array of String. Consider the following as an example:</p></div></div><pre class="programlisting">var cubeTexture = new BABYLON.CubeTexture("skybox/TropicalSunnyDay", scene, ["_px.png", "_py.png", "_pz.png", "_nx.png", "_ny.png", "_nz.png"]); &#13;
</pre><p>Now, let's create a skybox. A skybox is a cube with <code class="literal">back-face culling</code> disabled as the camera will be in the cube, as follows:</p><pre class="programlisting">var skybox = BABYLON.Mesh.CreateBox("skybox", 300, scene); &#13;
var skyboxMaterial = new BABYLON.StandardMaterial("skyboxMaterial", scene); &#13;
skyboxMaterial.backFaceCulling = false; &#13;
skyboxMaterial.reflectionTexture = &#13;
  new BABYLON.CubeTexture("skybox/TropicalSunnyDay", scene); &#13;
</pre><p>In the result, the cube texture is applied to the cube; however, we can find some artifacts in the links between parts of the cube texture:</p><p>
</p><div><img src="img/image_04_020.png" alt="The cube texture"/></div><p>
</p><p>These artefacts are due to the coordinates mode of the texture. In fact, the textures are applied to meshes by the 2D coordinates provided by the mesh's geometry. As for the vertex buffer and the index buffer, the geometry contains a coordinate buffer commonly named the <strong>UVs</strong> buffer, and several methods exist to apply a certain coordinate pattern. In this case, the skybox coordinate mode should be applied. This is possible with <code class="literal">the.coordinatesMode</code> property, as follows</p><pre class="programlisting">myTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;</pre><p>Once the coordinates mode is set, the result looks great, as shown in the following image:</p><p>
</p><div><img src="img/image_04_021.png" alt="The cube texture"/></div><p>
</p><p>The result of the skybox outside the cube is as follows:</p><p>
</p><div><img src="img/image_04_022.png" alt="The cube texture"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>The mirror texture</h3></div></div></div><p>Let's explain the usage of a reflection texture with a new texture type named <strong>Mirror Texture</strong>. With Babylon.js, it is possible to reflect the world using a mirror texture. The mirror texture is particular as it is created by Babylon.js and can render the scene into a texture. Behind the reflection texture, a new texture type is used: the render target texture. Render target textures are used to directly render meshes into a texture for further use. Now, let's create a mirror texture, as follows:</p><pre class="programlisting">var mirror = new BABYLON.MirrorTexture("mirror", 512, scene); &#13;
</pre><p>The parameters are as shown in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The texture name: The name of the texture created by Babylon.js.</li><li class="listitem" style="list-style-type: disc">The texture size: The bigger the texture, the cleaner the mirror texture is. Unfortunately, bigger the texture, bigger will be its impact on the performance. The values 512 or 1024 (512 x 512 or 1024 x 1024 pixels) are good sizes for a mirror texture.</li><li class="listitem" style="list-style-type: disc">The scene where to add the texture.</li></ul></div><p>Now, to reflect the world, the mirror texture needs a last parameter: the mirror plane. If we take the ground as an example, we want the ground to reflect the world above itself:</p><pre class="programlisting">mirror.mirrorPlane = BABYLON.Plane.FromPositionAndNormal( &#13;
  new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, -1, 0)); &#13;
</pre><p>A plane has four properties: <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and <code class="literal">d</code>. The first three properties represent the normal vector, where <code class="literal">d</code> is the distance to the origin. The <code class="literal">FromPositionAndNormal</code> static method is a helper to create a plane. The parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The plane's position vector. Here, the origin (<code class="literal">x=0</code>, <code class="literal">y=0</code>, <code class="literal">z=0</code>).</li><li class="listitem" style="list-style-type: disc">In the example files, the plane position is (<code class="literal">x=0</code>, <code class="literal">y=-5</code>, <code class="literal">z=0</code>). Therefore, the plane's position must be (<code class="literal">x=0</code>, <code class="literal">y=5</code>, <code class="literal">z=0</code>).</li><li class="listitem" style="list-style-type: disc">The plane's normal vector. Here, the origin is (<code class="literal">x=0</code>, <code class="literal">y=-1</code>, <code class="literal">z=0</code>).</li></ul></div><p>Then, the code lines become the following:</p><pre class="programlisting">var mirror = new BABYLON.MirrorTexture("mirror", 512, scene); &#13;
mirror.mirrorPlane = BABYLON.Plane.FromPositionAndNormal( &#13;
  new BABYLON.Vector3(0, 0, 0), &#13;
new BABYLON.Vector3(0, -1, 0)); &#13;
myMaterial.reflectionTexture = mirror; &#13;
</pre><p>To configure the render target texture in the mirror texture, we must provide an array of <code class="literal">BABYLON.AbstractMesh</code>. This array is used to render only the meshes indexed in the array. The array is already created by the mirror texture and the property's name is<code class="literal">.renderList</code>. Then, the mirror texture will only expose the added meshes in the array, as follows:</p><pre class="programlisting">mirror.renderList.push(myMesh1); &#13;
mirror.renderList.push(myMesh2); &#13;
// Etc.</pre><p>The result with a ground (plane at the same position) and the reflected spheres is as shown in the following image:</p><p>
</p><div><img src="img/image_04_023.png" alt="The mirror texture"/></div><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, you saw what materials are, the theory about what is happening backstage, and how to use the standard materials of Babylon.js. You saw that using a material in Babylon.js is also easy.</p><p>The example files tend to reproduce the notions viewed in this chapter: colors, alpha, textures, fog, back-face culling, and so on. Now, you can practice with materials and customize appearance of meshes.</p><p>As a concrete example, the materials are highly used in all the 3D scenes and configured by 3D artists: if we take a scene of Babylon.js made by Michel Rousseau, where he used two meshes and two different materials to reproduce the following image:</p><p>
</p><div><img src="img/image_04_024.png" alt="Summary"/></div><p>
</p><p>The first mesh is the body of the vase with a standard material applied to it and the second mesh represents the embers with another standard material applied to them. Each material is configured with a different diffuse texture. If we set the body as <code class="literal">isVisible = false</code>, we can see how the embers look in reality, as shown in the following image:</p><p>
</p><div><img src="img/image_04_025.png" alt="Summary"/></div><p>
</p><p>Finally, all the meshes rendered in this scene are using standard materials, configured with different values and textures, to finally look similar to the following image:</p><p>
</p><div><img src="img/image_04_026.png" alt="Summary"/></div><p>
</p><p>In the next chapter, you'll create your first scene with an FPS camera and collisions management. You will learn how to manage collisions between objects and how to manage physics with Babylon.js.</p></div></body></html>