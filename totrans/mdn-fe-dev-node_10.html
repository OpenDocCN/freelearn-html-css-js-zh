<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor098"/>10</h1>
<h1 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor099"/>Integrating Native Code with WebAssembly</h1>
<p lang="en-GB">The whole point of actually using Node.js is convenience. Node.js never aspired to be the fastest runtime, the most complete one, or the most secure one. However, Node.js established a quick and powerful ecosystem that was capable of developing a set of tools and utilities to actually empower the web development standards that we are all used to today.</p>
<p lang="en-GB">With the growth of Node.js, the demand for more specialized systems also increased. The rise of new runtimes that offered alternatives to Node.js actually resulted from this need. An interesting alternative can be found in the WebAssembly language. WebAssembly is a portable binary-code format like the <strong class="bold" lang=""><a id="_idIndexMarker354"/></strong><strong class="bold" lang="">Java Virtual Machine</strong> (<strong class="bold" lang="">JVM</strong>) or the <a id="_idIndexMarker355"/><strong class="bold" lang="">Microsoft Intermediate Language</strong> (<strong class="bold" lang="">MSIL</strong>). This makes it a potential compilation offering for any language – especially lower-level languages such as C or Rust.</p>
<p lang="en-GB">In this chapter, you’ll learn what WebAssembly has to offer, how you can integrate existing WebAssembly code in your Node.js applications, and how you can generate WebAssembly code yourself. By the end, you will be prepared to take your scripts to the next level – whether it is with WebAssembly itself or with WebAssembly running in Node.js.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">The advantages of using WebAssembly</li>
<li lang="en-GB">Running WebAssembly in Node.js</li>
<li lang="en-GB">Writing WASM with AssemblyScript</li>
</ul>
<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor100"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3DPH53P">https://bit.ly/3DPH53P</a>.</p>
<h1 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor101"/>Advantages of using WebAssembly</h1>
<p lang="en-GB"><strong class="bold" lang="">WebAssembly</strong> (<strong class="bold" lang="">WASM</strong>) is a<a id="_idIndexMarker356"/> language without any runtime. Any kind of functionality – from allocating some memory to making an HTTP request – needs to be integrated by the consuming application. There are, however, some emerging standards <a id="_idIndexMarker357"/>such as the <strong class="bold" lang="">WebAssembly System Interface</strong> (<strong class="bold" lang="">WASI</strong>) that aim to bring a set of standard functionalities to any platform. This way, we can write platform-independent applications using WASM, with a runner integrating WASI.</p>
<p class="callout-heading" lang="en-GB">WASI specification</p>
<p class="callout" lang="en-GB">The WASI specification <a id="_idIndexMarker358"/>covers everything that is needed to run WASM outside of a browser. Popular WASM runtimes <a id="_idIndexMarker359"/>such as <strong class="bold" lang="">Wasmtime</strong> or <strong class="bold" lang="">Wasmer</strong> implement <a id="_idIndexMarker360"/>WASI to actually run WASM applications. WASI specifies how system resources can be accessed by WASM. As a result, besides having WASI implemented in the runtime, the executed WASM code also needs to know (and use) the API provided by WASI. More details can be <a id="_idIndexMarker361"/>found at <a href="https://wasi.dev/">https://wasi.dev/</a>.</p>
<p lang="en-GB">Consequently, one of the<a id="_idIndexMarker362"/> advantages of WASM is its portability and ability to run in a sandbox. After all, there is no linking and ability to run system commands or access critical system resources.</p>
<p lang="en-GB">Even something as simple as logging to the console (i.e., the equivalent of using <code>console.log()</code> in Node.js) needs to be provided by the WASI layer, which could leave the access decision for certain resources to the user.</p>
<p lang="en-GB">Another advantage of WASM is that it is not a language directly. Therefore, we can actually use any language that supports WASM as a compilation target. As of today, most system languages such as C/C++, Rust, Zig, and Go support WASM generation. Finally, the “write once, run everywhere” principle of Java seems to be fulfilled.</p>
<p lang="en-GB">Quite often, performance is considered another advantage of WASM. While WASM by itself can actually provide better performance than Node.js or similar runtimes, it will certainly still be slower than equivalent but very well-optimized native code. After all, this also just runs natively but with a bit less information, and in a more generic mode. Nevertheless, for some algorithms, the slowdown from WASM execution to native execution can be quite small, or even unnoticeable.</p>
<p lang="en-GB">So, how is<a id="_idIndexMarker363"/> this all achieved? Well, first of all, the format of a WASM file is binary – that is, as efficient as possible. The structure in this binary is tailored to be parsed and executed really quickly. Instead of having high-level instructions such as loops, the language only offers labels and jump points – much like a true machine language.</p>
<p lang="en-GB">In <em class="italic" lang="">Figure 10</em><em class="italic" lang="">.1</em>, you can see the general flow and portability promise offered by WASM. As a developer, we only need to care about compiling to a <code>.wasm</code> file. If our tooling is capable of doing that, users are able to consume such files with the WASM runtime of their choice, which can be a browser or Node.js, but many other options exist too.</p>
<div><div><img alt="Figure 10.1 – Portability in WASM with a WASM binary " src="img/Figure_10.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Portability in WASM with a WASM binary</p>
<p lang="en-GB">Like with machine languages, WASM has two formats – a text representation, which is great for seeing what’s going on, and a corresponding binary representation. The text representation looks quite close to programming languages <a id="_idIndexMarker364"/>such as <strong class="bold" lang="">Lisp</strong>, with lower-level fragments resembling actual processor instructions.</p>
<p lang="en-GB">Let’s see an example<a id="_idIndexMarker365"/> of a WASM text representation for a library <a id="_idIndexMarker366"/>exporting a <code>sum</code> function to add two numbers together:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">sum.wat</p>
<pre class="source-code" lang="en-GB">(module
(export "sum" (func $module/sum))
 (func $module/sum (param $0 i32) (param $1 i32)
   (result i32)
  local.get $0
  local.get $1
  i32.add
 )
)</pre>
<p lang="en-GB">Tools <a id="_idIndexMarker367"/>exist to translate the text representation into its binary counterpart. The most <a id="_idIndexMarker368"/>popular tool is <strong class="bold" lang="">wat2wasm</strong>, which has a <a id="_idIndexMarker369"/>powerful online demo, too. You can access it at <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">https://webassembly.github.io/wabt/demo/wat2wasm/</a>.</p>
<p lang="en-GB">Adding the preceding example, you’ll get a view as presented in <em class="italic" lang="">Figure 10</em><em class="italic" lang="">.2</em>. You’ll see that the online tool does a bit more than the text (upper left) to binary (upper right) translation. It also includes a small JavaScript playground (bottom left), which integrates the compiled WASM binary and runs it. The output of running code in the playground is then shown in the bottom-right corner.</p>
<div><div><img alt="Figure 10.2 – The wat2wasm online tool applied to our example " src="img/Figure_10.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The wat2wasm online tool applied to our example</p>
<p lang="en-GB">Now that we know what WASM is, how it works, and what advantages it offers, it’s time to see how we<a id="_idIndexMarker370"/> can run it and – of course – also integrate it with Node.js. This makes our scripts even more powerful than beforehand, allowing platform-independent, almost native code to be integrated in a reliable, well-performing, and secure way.</p>
<h1 id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor102"/>Running WASM in Node.js</h1>
<p lang="en-GB">Node.js <a id="_idIndexMarker371"/>has a <a id="_idIndexMarker372"/>direct integration of WASM via the <code>WASM</code> object. The API is exactly the same as in the browser, allowing us to potentially share the code between Node.js and browsers to integrate a compiled WASM file.</p>
<p lang="en-GB">There are three functions in the API of <code>WASM</code>. We can compile an existing binary, transforming it into a WASM runtime module. This module can then be activated using the <code>instantiate</code> method. We can also validate an existing binary – to check whether a given file is indeed a valid WASM binary. All methods are asynchronous and return <code>Promise</code>.</p>
<p lang="en-GB">Let’s see an example using a WASM binary, <code>sum.wasm</code>, which exports a single function (<code>sum</code>) and adds two numbers together:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.mjs</p>
<pre class="source-code" lang="en-GB">import{ readFile } from 'fs/promises';
const content = await readFile('./sum.wasm');
const wasm = await WebAssembly.compile(content);
const instance = await WebAssembly.instantiate(wasm);
const { sum } = instance.exports;
console.log(sum(2, 3)); // logs 5</pre>
<p lang="en-GB">Node.js makes<a id="_idIndexMarker373"/> the integration of WASM even more convenient by providing a <code>wasi</code> package out of the box. This package fulfills the WASI specification, allowing us to access system resources within WASM applications running in Node.js.</p>
<p lang="en-GB">To see what the integration of a WASM module that depends on WASI looks like, we’ll build a small application later, which<a id="_idIndexMarker374"/> will make use of <a id="_idIndexMarker375"/>WASI and be integrated into Node.js. The Node.js integration will look like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.mjs</p>
<pre class="source-code" lang="en-GB">import { readFile } from "fs/promises";
import { WASI } from "wasi";
import { argv, env } from "process";
const wasi = new WASI({
  args: argv,
  env,
});
const api = { wasi_snapshot_preview1: wasi.wasiImport };
const path = "./echo.wasm";
const content = await readFile(path);
const wasm = await WebAssembly.compile(content);
const instance = await WebAssembly.instantiate(wasm, api);
wasi.start(instance);</pre>
<p lang="en-GB">At least with Node.js version 18, the <code>wasi</code> package is not active. To actually run the preceding application, you’ll need to add the <code>--</code><code>experimental-wasi-unstable-preview1</code> flag:</p>
<pre class="console" lang="en-GB">
$ node --experimental-wasi-unstable-preview1 app.mjs</pre>
<p lang="en-GB">The specifics of running the preceding example are explored in the next section.</p>
<p lang="en-GB">While running WASM in Node.js is great, we might also want to write some code ourselves. Of course, if you have any knowledge of languages such as C or Rust, you can use<a id="_idIndexMarker376"/> those <a id="_idIndexMarker377"/>with WASM as a compilation target. In general, however, for developers with a JavaScript background, a nice alternative exists with AssemblyScript.</p>
<h1 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor103"/>Writing WASM with AssemblyScript</h1>
<p lang="en-GB">While <a id="_idIndexMarker378"/>there are many options to actually generate valid WASM, one of the most attractive ways is to use AssemblyScript. AssemblyScript is <a id="_idIndexMarker379"/>a language that looks and feels quite similar to TypeScript, making it rather easy to learn from a syntax perspective. Under the hood, however, there <a id="_idIndexMarker380"/>are still some concepts relating to WASM that need to be known in order to write mid-sized to larger AssemblyScript applications or libraries.</p>
<p lang="en-GB">One of the core concepts of AssemblyScript is to model the different data types used in WASM. For instance, using integers requires the use of the <code>i32</code> type.</p>
<p lang="en-GB">Let’s have a look at some example code. We’ll start with a small function that expects two parameters, adds them up, and returns the result:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">module.ts</p>
<pre class="source-code" lang="en-GB">export function sum(a: i32, b: i32): i32 {
  return a + b;
}</pre>
<p lang="en-GB">With the <a id="_idIndexMarker381"/>exception of the <code>i32</code> type, everything in the preceding example looks and feels just like TypeScript. Even the file extension indicates a TypeScript file.</p>
<p lang="en-GB">To actually compile the preceding code to WASM, you’ll need the <code>assemblyscript</code> package. Like <code>typescript</code>, you can either install this package globally or locally.</p>
<p lang="en-GB">Once AssemblyScript is installed, you can run the <code>asc</code> utility to compile the source code to a valid WASM binary:</p>
<pre class="console" lang="en-GB">
$ npx asc module.ts --outFile sum.wasm --optimize</pre>
<p lang="en-GB">AssemblyScript can also be very helpful to scaffold a project structure that works – not only to compile source code but also to run WASM in the browser. This provides a nice way of writing <a id="_idIndexMarker382"/>code that works on multiple <a id="_idIndexMarker383"/>platforms, including various operating systems, browsers, and devices:</p>
<pre class="console" lang="en-GB">
$ npx asinit .

Version: 0.21.6

[...]

  ./assembly

  Directory holding the AssemblyScript sources being compiled to WebAssembly.

  ./assembly/tsconfig.json

  TypeScript configuration inheriting recommended AssemblyScript settings.

  ./assembly/index.ts

  Example entry file being compiled to WebAssembly to get you

[...]

  ./index.html

  Starter HTML file that loads the module in a browser.

The command will try to update existing files to match the correct settings [...]

Do you want to proceed? [Y/n] Y</pre>
<p lang="en-GB">With the generated structure in place, we can go ahead and try to make our previous example work – for instance, in a web browser.</p>
<p lang="en-GB">For this, modify <code>index.ts</code> in the <code>assembly</code> directory of the scaffolded project folder. Replace its content with the preceding snippet containing the <code>sum</code> function. Now, open <code>index.html</code> in the project’s root. Change the import statement to obtain <code>sum</code> instead of <code>add</code>.</p>
<p lang="en-GB">The <a id="_idIndexMarker384"/>script part of the <code>index.html</code> file should now look like this:</p>
<pre class="source-code" lang="en-GB">import { sum } from "./build/release.js";
document.body.innerText = sum(1, 2);</pre>
<p lang="en-GB">Now, you <a id="_idIndexMarker385"/>can build and run everything using the <code>asbuild</code> script that was added during the scaffolding process:</p>
<pre class="console" lang="en-GB">
$ npm run asbuild

$ npm start</pre>
<p lang="en-GB">Now, a small web server should be running at port <code>3000</code>. Accessing <code>http://localhost:9000</code> brings you to an almost empty web page. What you should see is that <code>sum</code> function from our WASM library.</p>
<p class="callout-heading" lang="en-GB">Debugging WASM</p>
<p class="callout" lang="en-GB">A WASM module<a id="_idIndexMarker386"/> can be debugged in the same way as any other web application. The browser offers a visual debugger that can be used for inspection. By using source maps for WASM, the original code can actually be debugged instead of the not-so-easily readable WASM. AssemblyScript is also capable of producing WASM source maps. Here, the source map destination file has to be specified after the <code>--sourceMap</code> CLI flag.</p>
<p lang="en-GB">AssemblyScript can also be used to create WASM applications and libraries built on top of WASI. Let’s see how that would work. We start with a new project, where we add <code>assemblyscript</code> as well as <code>as-wasi</code> as dependencies, followed by scaffolding a new <code>AssemblyScript</code> project:</p>
<pre class="console" lang="en-GB">
$ npm init -y

$ npm install assemblyscript as-wasi --save-dev

$ npx asinit . -y</pre>
<p lang="en-GB">Now, we can <a id="_idIndexMarker387"/>modify the <code>assembly/index.ts</code> file with the following code, using the <code>wasi</code> package.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.ts</p>
<pre class="source-code" lang="en-GB">import "wasi";
import { Console, CommandLine } from "as-wasi/assembly";
const args = CommandLine.all;
const user = args[args.length - 1];
Console.log(`Hello ${user}!`);</pre>
<p lang="en-GB">By<a id="_idIndexMarker388"/> importing the <code>wasi</code> package, the <a id="_idIndexMarker389"/>whole module gets transformed into a WASI-compatible entry point. This allows us to use the abstractions from the <code>as-wasi</code> package, such as <code>Console</code> to access the console or <code>CommandLine</code> to obtain the provided command-line arguments.</p>
<p lang="en-GB">To build the code we invoke the <code>asc</code> utility with the following arguments:</p>
<pre class="console" lang="en-GB">
$ npx asc assembly/index.ts -o echo.wasm --use abort=wasi_abort --debug</pre>
<p lang="en-GB">This instructs AssemblyScript to build the application found in <code>assembly/index.ts</code>. The generated WASM will be stored in <code>echo.wasm</code>. Through the <code>--debug</code> flag, we instruct <code>asc</code> to create a debug build.</p>
<p lang="en-GB">A debug build can be done very fast, as the compiler does not need to invest in any optimizations. Besides a faster compilation time, the absence of further optimizations also can give us better error messages for critical failures later at runtime.</p>
<p lang="en-GB">Importantly, the binding for the <code>abort</code> command (usually taken from an implied <code>env</code> import to the WASM module) is set to use the <code>abort</code> method provided by WASI.</p>
<p lang="en-GB">Now, we can add the Node.js module, <code>app.mjs</code>, using the <code>wasi</code> package from the previous section. Don’t forget to add the necessary command-line argument. Since this will print a warning, we might want to add <code>--no-warnings</code> to suppress it:</p>
<pre class="console" lang="en-GB">
$ node --experimental-wasi-unstable-preview1 --no-warnings app.mjs Florian

Hello Florian!</pre>
<p lang="en-GB">Equipped <a id="_idIndexMarker390"/>with this knowledge, you <a id="_idIndexMarker391"/>can now go ahead and write simple programs compiling to WASM, too. Let’s recap what you learned in this chapter.</p>
<h1 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor104"/>Summary</h1>
<p lang="en-GB">In this chapter, you extended your knowledge of potential source code files running in Node.js. You are now familiar with running WASM – a lower-level portable binary-code language that can be used as a compilation target by many programming languages.</p>
<p lang="en-GB">WASM can help you to write functionality once and run it on multiple platforms. Since WASM can be sandboxed very well, it is a good contender for the next wave of containerized computing, where performance and security are valued highly. You now know how to write WASM using AssemblyScript. You are also empowered to integrate created WASM modules in Node.js.</p>
<p lang="en-GB">In the next and final chapter, we will take a look at the use of JavaScript beyond Node.js. We’ll see that other runtimes exist, which are partially compatible with the Node.js ecosystem – providing a great drop-in replacement that can be handy for multiple use cases.</p>
</div>
</body></html>