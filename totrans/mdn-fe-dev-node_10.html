<html><head></head><body>
<div id="_idContainer116">
<h1 class="chapter-number" id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.2.1">Integrating Native Code with WebAssembly</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">The whole point of actually using Node.js is convenience. </span><span class="koboSpan" id="kobo.3.2">Node.js never aspired to be the fastest runtime, the most complete one, or the most secure one. </span><span class="koboSpan" id="kobo.3.3">However, Node.js established a quick and powerful ecosystem that was capable of developing a set of tools and utilities to actually empower the web development standards that we are all used </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">to today.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.5.1">With the growth of Node.js, the demand for more specialized systems also increased. </span><span class="koboSpan" id="kobo.5.2">The rise of new runtimes that offered alternatives to Node.js actually resulted from this need. </span><span class="koboSpan" id="kobo.5.3">An interesting alternative can be found in the WebAssembly language. </span><span class="koboSpan" id="kobo.5.4">WebAssembly is a portable binary-code format like the </span><strong class="bold" lang=""><a id="_idIndexMarker354"/></strong><strong class="bold" lang=""><span class="koboSpan" id="kobo.6.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.8.1">JVM</span></strong><span class="koboSpan" id="kobo.9.1">) or the </span><a id="_idIndexMarker355"/><strong class="bold" lang=""><span class="koboSpan" id="kobo.10.1">Microsoft Intermediate Language</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.12.1">MSIL</span></strong><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">This makes it a potential compilation offering for any language – especially lower-level languages such as C </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.14.1">or Rust.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.15.1">In this chapter, you’ll learn what WebAssembly has to offer, how you can integrate existing WebAssembly code in your Node.js applications, and how you can generate WebAssembly code yourself. </span><span class="koboSpan" id="kobo.15.2">By the end, you will be prepared to take your scripts to the next level – whether it is with WebAssembly itself or with WebAssembly running </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.16.1">in Node.js.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.17.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.18.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="koboSpan" id="kobo.19.1">The advantages of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.20.1">using WebAssembly</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.21.1">Running WebAssembly </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.22.1">in Node.js</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.23.1">Writing WASM </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.24.1">with AssemblyScript</span></span></li>
</ul>
<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.26.1">The complete source code for this chapter is available </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter10</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.30.1">The CiA videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://bit.ly/3DPH53P"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.32.1">https://bit.ly/3DPH53P</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.34.1">Advantages of using WebAssembly</span></h1>
<p lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.35.1">WebAssembly</span></strong><span class="koboSpan" id="kobo.36.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.37.1">WASM</span></strong><span class="koboSpan" id="kobo.38.1">) is a</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.39.1"> language without any runtime. </span><span class="koboSpan" id="kobo.39.2">Any kind of functionality – from allocating some memory to making an HTTP request – needs to be integrated by the consuming application. </span><span class="koboSpan" id="kobo.39.3">There are, however, some emerging standards </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.40.1">such as the </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.41.1">WebAssembly System Interface</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold" lang=""><span class="koboSpan" id="kobo.43.1">WASI</span></strong><span class="koboSpan" id="kobo.44.1">) that aim to bring a set of standard functionalities to any platform. </span><span class="koboSpan" id="kobo.44.2">This way, we can write platform-independent applications using WASM, with a runner </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.45.1">integrating WASI.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.46.1">WASI specification</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.47.1">The WASI specification </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.48.1">covers everything that is needed to run WASM outside of a browser. </span><span class="koboSpan" id="kobo.48.2">Popular WASM runtimes </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.49.1">such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.50.1">Wasmtime</span></strong><span class="koboSpan" id="kobo.51.1"> or </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.52.1">Wasmer</span></strong><span class="koboSpan" id="kobo.53.1"> implement </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.54.1">WASI to actually run WASM applications. </span><span class="koboSpan" id="kobo.54.2">WASI specifies how system resources can be accessed by WASM. </span><span class="koboSpan" id="kobo.54.3">As a result, besides having WASI implemented in the runtime, the executed WASM code also needs to know (and use) the API provided by WASI. </span><span class="koboSpan" id="kobo.54.4">More details can be </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.55.1">found </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.56.1">at </span></span><a href="https://wasi.dev/"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.57.1">https://wasi.dev/</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.59.1">Consequently, one of the</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.60.1"> advantages of WASM is its portability and ability to run in a sandbox. </span><span class="koboSpan" id="kobo.60.2">After all, there is no linking and ability to run system commands or access critical </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.61.1">system resources.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.62.1">Even something as simple as logging to the console (i.e., the equivalent of using </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.63.1">console.log()</span></strong><span class="koboSpan" id="kobo.64.1"> in Node.js) needs to be provided by the WASI layer, which could leave the access decision for certain resources to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.65.1">the user.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.66.1">Another advantage of WASM is that it is not a language directly. </span><span class="koboSpan" id="kobo.66.2">Therefore, we can actually use any language that supports WASM as a compilation target. </span><span class="koboSpan" id="kobo.66.3">As of today, most system languages such as C/C++, Rust, Zig, and Go support WASM generation. </span><span class="koboSpan" id="kobo.66.4">Finally, the “write once, run everywhere” principle of Java seems to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.67.1">be fulfilled.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.68.1">Quite often, performance is considered another advantage of WASM. </span><span class="koboSpan" id="kobo.68.2">While WASM by itself can actually provide better performance than Node.js or similar runtimes, it will certainly still be slower than equivalent but very well-optimized native code. </span><span class="koboSpan" id="kobo.68.3">After all, this also just runs natively but with a bit less information, and in a more generic mode. </span><span class="koboSpan" id="kobo.68.4">Nevertheless, for some algorithms, the slowdown from WASM execution to native execution can be quite small, or </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.69.1">even unnoticeable.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.70.1">So, how is</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.71.1"> this all achieved? </span><span class="koboSpan" id="kobo.71.2">Well, first of all, the format of a WASM file is binary – that is, as efficient as possible. </span><span class="koboSpan" id="kobo.71.3">The structure in this binary is tailored to be parsed and executed really quickly. </span><span class="koboSpan" id="kobo.71.4">Instead of having high-level instructions such as loops, the language only offers labels and jump points – much like a true </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.72.1">machine language.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.73.1">In </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.74.1">Figure 10</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.75.1">.1</span></em><span class="koboSpan" id="kobo.76.1">, you can see the general flow and portability promise offered by WASM. </span><span class="koboSpan" id="kobo.76.2">As a developer, we only need to care about compiling to a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.77.1">.wasm</span></strong><span class="koboSpan" id="kobo.78.1"> file. </span><span class="koboSpan" id="kobo.78.2">If our tooling is capable of doing that, users are able to consume such files with the WASM runtime of their choice, which can be a browser or Node.js, but many other options </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.79.1">exist too.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 10.1 – Portability in WASM with a WASM binary " src="image/Figure_10.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 10.1 – Portability in WASM with a WASM binary</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.82.1">Like with machine languages, WASM has two formats – a text representation, which is great for seeing what’s going on, and a corresponding binary representation. </span><span class="koboSpan" id="kobo.82.2">The text representation looks quite close to programming languages </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.83.1">such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.84.1">Lisp</span></strong><span class="koboSpan" id="kobo.85.1">, with lower-level fragments resembling actual </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.86.1">processor instructions.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.87.1">Let’s see an example</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.88.1"> of a WASM text representation for a library </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.89.1">exporting a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.90.1">sum</span></strong><span class="koboSpan" id="kobo.91.1"> function to add two </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.92.1">numbers together:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.93.1">sum.wat</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.94.1">(module
(export "sum" (func $module/sum))
 (func $module/sum (param $0 i32) (param $1 i32)
   (result i32)
  local.get $0
  local.get $1
  i32.add
 )
)</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.95.1">Tools </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.96.1">exist to translate the text representation into its binary counterpart. </span><span class="koboSpan" id="kobo.96.2">The most </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.97.1">popular tool is </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.98.1">wat2wasm</span></strong><span class="koboSpan" id="kobo.99.1">, which has a </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.100.1">powerful online demo, too. </span><span class="koboSpan" id="kobo.100.2">You can access it </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.101.1">at </span></span><a href="https://webassembly.github.io/wabt/demo/wat2wasm/"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.102.1">https://webassembly.github.io/wabt/demo/wat2wasm/</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.103.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.104.1">Adding the preceding example, you’ll get a view as presented in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.105.1">Figure 10</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.106.1">.2</span></em><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">You’ll see that the online tool does a bit more than the text (upper left) to binary (upper right) translation. </span><span class="koboSpan" id="kobo.107.3">It also includes a small JavaScript playground (bottom left), which integrates the compiled WASM binary and runs it. </span><span class="koboSpan" id="kobo.107.4">The output of running code in the playground is then shown in the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.108.1">bottom-right corner.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.109.1"><img alt="Figure 10.2 – The wat2wasm online tool applied to our example " src="image/Figure_10.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Figure 10.2 – The wat2wasm online tool applied to our example</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.111.1">Now that we know what WASM is, how it works, and what advantages it offers, it’s time to see how we</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.112.1"> can run it and – of course – also integrate it with Node.js. </span><span class="koboSpan" id="kobo.112.2">This makes our scripts even more powerful than beforehand, allowing platform-independent, almost native code to be integrated in a reliable, well-performing, and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.113.1">secure way.</span></span></p>
<h1 id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.114.1">Running WASM in Node.js</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.115.1">Node.js </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.116.1">has a </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.117.1">direct integration of WASM via the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.118.1">WASM</span></strong><span class="koboSpan" id="kobo.119.1"> object. </span><span class="koboSpan" id="kobo.119.2">The API is exactly the same as in the browser, allowing us to potentially share the code between Node.js and browsers to integrate a compiled </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.120.1">WASM file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.121.1">There are three functions in the API of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.122.1">WASM</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">We can compile an existing binary, transforming it into a WASM runtime module. </span><span class="koboSpan" id="kobo.123.3">This module can then be activated using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.124.1">instantiate</span></strong><span class="koboSpan" id="kobo.125.1"> method. </span><span class="koboSpan" id="kobo.125.2">We can also validate an existing binary – to check whether a given file is indeed a valid WASM binary. </span><span class="koboSpan" id="kobo.125.3">All methods are asynchronous and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.126.1">return </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.127.1">Promise</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.129.1">Let’s see an example using a WASM binary, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.130.1">sum.wasm</span></strong><span class="koboSpan" id="kobo.131.1">, which exports a single function (</span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.132.1">sum</span></strong><span class="koboSpan" id="kobo.133.1">) and adds two </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.134.1">numbers together:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.135.1">app.mjs</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.136.1">import{ readFile } from 'fs/promises';
const content = await readFile('./sum.wasm');
const wasm = await WebAssembly.compile(content);
const instance = await WebAssembly.instantiate(wasm);
const { sum } = instance.exports;
console.log(sum(2, 3)); // logs 5</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.137.1">Node.js makes</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.138.1"> the integration of WASM even more convenient by providing a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.139.1">wasi</span></strong><span class="koboSpan" id="kobo.140.1"> package out of the box. </span><span class="koboSpan" id="kobo.140.2">This package fulfills the WASI specification, allowing us to access system resources within WASM applications running </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.141.1">in Node.js.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.142.1">To see what the integration of a WASM module that depends on WASI looks like, we’ll build a small application later, which</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.143.1"> will make use of </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.144.1">WASI and be integrated into Node.js. </span><span class="koboSpan" id="kobo.144.2">The Node.js integration will look </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.145.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">app.mjs</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.147.1">import { readFile } from "fs/promises";
import { WASI } from "wasi";
import { argv, env } from "process";
const wasi = new WASI({
  args: argv,
  env,
});
const api = { wasi_snapshot_preview1: wasi.wasiImport };
const path = "./echo.wasm";
const content = await readFile(path);
const wasm = await WebAssembly.compile(content);
const instance = await WebAssembly.instantiate(wasm, api);
wasi.start(instance);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.148.1">At least with Node.js version 18, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.149.1">wasi</span></strong><span class="koboSpan" id="kobo.150.1"> package is not active. </span><span class="koboSpan" id="kobo.150.2">To actually run the preceding application, you’ll need to add the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.151.1">--</span></strong><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.152.1">experimental-wasi-unstable-preview1</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.153.1"> flag:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.154.1">
$ node --experimental-wasi-unstable-preview1 app.mjs</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.155.1">The specifics of running the preceding example are explored in the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.156.1">next section.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.157.1">While running WASM in Node.js is great, we might also want to write some code ourselves. </span><span class="koboSpan" id="kobo.157.2">Of course, if you have any knowledge of languages such as C or Rust, you can use</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.158.1"> those </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.159.1">with WASM as a compilation target. </span><span class="koboSpan" id="kobo.159.2">In general, however, for developers with a JavaScript background, a nice alternative exists </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.160.1">with AssemblyScript.</span></span></p>
<h1 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.161.1">Writing WASM with AssemblyScript</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.162.1">While </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.163.1">there are many options to actually generate valid WASM, one of the most attractive ways is to use AssemblyScript. </span><span class="koboSpan" id="kobo.163.2">AssemblyScript is </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.164.1">a language that looks and feels quite similar to TypeScript, making it rather easy to learn from a syntax perspective. </span><span class="koboSpan" id="kobo.164.2">Under the hood, however, there </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.165.1">are still some concepts relating to WASM that need to be known in order to write mid-sized to larger AssemblyScript applications </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.166.1">or libraries.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.167.1">One of the core concepts of AssemblyScript is to model the different data types used in WASM. </span><span class="koboSpan" id="kobo.167.2">For instance, using integers requires the use of the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.168.1">i32</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.169.1"> type.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.170.1">Let’s have a look at some example code. </span><span class="koboSpan" id="kobo.170.2">We’ll start with a small function that expects two parameters, adds them up, and returns </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.171.1">the result:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">module.ts</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.173.1">export function sum(a: i32, b: i32): i32 {
  return a + b;
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.174.1">With the </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.175.1">exception of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.176.1">i32</span></strong><span class="koboSpan" id="kobo.177.1"> type, everything in the preceding example looks and feels just like TypeScript. </span><span class="koboSpan" id="kobo.177.2">Even the file extension indicates a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.178.1">TypeScript file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.179.1">To actually compile the preceding code to WASM, you’ll need the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.180.1">assemblyscript</span></strong><span class="koboSpan" id="kobo.181.1"> package. </span><span class="koboSpan" id="kobo.181.2">Like </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.182.1">typescript</span></strong><span class="koboSpan" id="kobo.183.1">, you can either install this package globally </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.184.1">or locally.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.185.1">Once AssemblyScript is installed, you can run the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.186.1">asc</span></strong><span class="koboSpan" id="kobo.187.1"> utility to compile the source code to a valid </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.188.1">WASM binary:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.189.1">
$ npx asc module.ts --outFile sum.wasm --optimize</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.190.1">AssemblyScript can also be very helpful to scaffold a project structure that works – not only to compile source code but also to run WASM in the browser. </span><span class="koboSpan" id="kobo.190.2">This provides a nice way of writing </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.191.1">code that works on multiple </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.192.1">platforms, including various operating systems, browsers, </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.193.1">and devices:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.194.1">
$ npx asinit .

</span><span class="koboSpan" id="kobo.194.2">Version: 0.21.6

[...]

  ./assembly

  Directory holding the AssemblyScript sources being compiled to WebAssembly.

</span><span class="koboSpan" id="kobo.194.3">  ./assembly/tsconfig.json

  TypeScript configuration inheriting recommended AssemblyScript settings.

</span><span class="koboSpan" id="kobo.194.4">  ./assembly/index.ts

  Example entry file being compiled to WebAssembly to get you

[...]

  ./index.html

  Starter HTML file that loads the module in a browser.

</span><span class="koboSpan" id="kobo.194.5">The command will try to update existing files to match the correct settings [...]

Do you want to proceed? </span><span class="koboSpan" id="kobo.194.6">[Y/n] Y</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.195.1">With the generated structure in place, we can go ahead and try to make our previous example work – for instance, in a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.196.1">web browser.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.197.1">For this, modify </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.198.1">index.ts</span></strong><span class="koboSpan" id="kobo.199.1"> in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.200.1">assembly</span></strong><span class="koboSpan" id="kobo.201.1"> directory of the scaffolded project folder. </span><span class="koboSpan" id="kobo.201.2">Replace its content with the preceding snippet containing the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.202.1">sum</span></strong><span class="koboSpan" id="kobo.203.1"> function. </span><span class="koboSpan" id="kobo.203.2">Now, open </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.204.1">index.html</span></strong><span class="koboSpan" id="kobo.205.1"> in the project’s root. </span><span class="koboSpan" id="kobo.205.2">Change the import statement to obtain </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.206.1">sum</span></strong><span class="koboSpan" id="kobo.207.1"> instead </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.208.1">of </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.209.1">add</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.210.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.211.1">The </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.212.1">script part of the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.213.1">index.html</span></strong><span class="koboSpan" id="kobo.214.1"> file should now look </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.215.1">like this:</span></span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.216.1">import { sum } from "./build/release.js";
document.body.innerText = sum(1, 2);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.217.1">Now, you </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.218.1">can build and run everything using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.219.1">asbuild</span></strong><span class="koboSpan" id="kobo.220.1"> script that was added during the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.221.1">scaffolding process:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.222.1">
$ npm run asbuild

$ npm start</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.223.1">Now, a small web server should be running at port </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.224.1">3000</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">Accessing </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.226.1">http://localhost:9000</span></strong><span class="koboSpan" id="kobo.227.1"> brings you to an almost empty web page. </span><span class="koboSpan" id="kobo.227.2">What you should see is that </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.228.1">3</span></strong><span class="koboSpan" id="kobo.229.1"> is written in the top-left corner of the page. </span><span class="koboSpan" id="kobo.229.2">This is the result of calling the exported </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.230.1">sum</span></strong><span class="koboSpan" id="kobo.231.1"> function from our </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.232.1">WASM library.</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.233.1">Debugging WASM</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.234.1">A WASM module</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.235.1"> can be debugged in the same way as any other web application. </span><span class="koboSpan" id="kobo.235.2">The browser offers a visual debugger that can be used for inspection. </span><span class="koboSpan" id="kobo.235.3">By using source maps for WASM, the original code can actually be debugged instead of the not-so-easily readable WASM. </span><span class="koboSpan" id="kobo.235.4">AssemblyScript is also capable of producing WASM source maps. </span><span class="koboSpan" id="kobo.235.5">Here, the source map destination file has to be specified after the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.236.1">--sourceMap</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.237.1">CLI flag.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.238.1">AssemblyScript can also be used to create WASM applications and libraries built on top of WASI. </span><span class="koboSpan" id="kobo.238.2">Let’s see how that would work. </span><span class="koboSpan" id="kobo.238.3">We start with a new project, where we add </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.239.1">assemblyscript</span></strong><span class="koboSpan" id="kobo.240.1"> as well as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.241.1">as-wasi</span></strong><span class="koboSpan" id="kobo.242.1"> as dependencies, followed by scaffolding a new </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.243.1">AssemblyScript</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.244.1"> project:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.245.1">
$ npm init -y

$ npm install assemblyscript as-wasi --save-dev

$ npx asinit . </span><span class="koboSpan" id="kobo.245.2">-y</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.246.1">Now, we can </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.247.1">modify the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.248.1">assembly/index.ts</span></strong><span class="koboSpan" id="kobo.249.1"> file with the following code, using the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.250.1">wasi</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.251.1"> package.</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">index.ts</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.253.1">import "wasi";
import { Console, CommandLine } from "as-wasi/assembly";
const args = CommandLine.all;
const user = args[args.length - 1];
Console.log(`Hello ${user}!`);</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.254.1">By</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.255.1"> importing the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.256.1">wasi</span></strong><span class="koboSpan" id="kobo.257.1"> package, the </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.258.1">whole module gets transformed into a WASI-compatible entry point. </span><span class="koboSpan" id="kobo.258.2">This allows us to use the abstractions from the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.259.1">as-wasi</span></strong><span class="koboSpan" id="kobo.260.1"> package, such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.261.1">Console</span></strong><span class="koboSpan" id="kobo.262.1"> to access the console or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.263.1">CommandLine</span></strong><span class="koboSpan" id="kobo.264.1"> to obtain the provided </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.265.1">command-line arguments.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.266.1">To build the code we invoke the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.267.1">asc</span></strong><span class="koboSpan" id="kobo.268.1"> utility with the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.269.1">following arguments:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.270.1">
$ npx asc assembly/index.ts -o echo.wasm --use abort=wasi_abort --debug</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.271.1">This instructs AssemblyScript to build the application found in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.272.1">assembly/index.ts</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">The generated WASM will be stored in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.274.1">echo.wasm</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">Through the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.276.1">--debug</span></strong><span class="koboSpan" id="kobo.277.1"> flag, we instruct </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.278.1">asc</span></strong><span class="koboSpan" id="kobo.279.1"> to create a </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.280.1">debug build.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.281.1">A debug build can be done very fast, as the compiler does not need to invest in any optimizations. </span><span class="koboSpan" id="kobo.281.2">Besides a faster compilation time, the absence of further optimizations also can give us better error messages for critical failures later </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.282.1">at runtime.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.283.1">Importantly, the binding for the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.284.1">abort</span></strong><span class="koboSpan" id="kobo.285.1"> command (usually taken from an implied </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.286.1">env</span></strong><span class="koboSpan" id="kobo.287.1"> import to the WASM module) is set to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.288.1">abort</span></strong><span class="koboSpan" id="kobo.289.1"> method provided </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.290.1">by WASI.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.291.1">Now, we can add the Node.js module, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.292.1">app.mjs</span></strong><span class="koboSpan" id="kobo.293.1">, using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.294.1">wasi</span></strong><span class="koboSpan" id="kobo.295.1"> package from the previous section. </span><span class="koboSpan" id="kobo.295.2">Don’t forget to add the necessary command-line argument. </span><span class="koboSpan" id="kobo.295.3">Since this will print a warning, we might want to add </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.296.1">--no-warnings</span></strong><span class="koboSpan" id="kobo.297.1"> to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.298.1">suppress it:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.299.1">
$ node --experimental-wasi-unstable-preview1 --no-warnings app.mjs Florian

Hello Florian!</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.300.1">Equipped </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.301.1">with this knowledge, you </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.302.1">can now go ahead and write simple programs compiling to WASM, too. </span><span class="koboSpan" id="kobo.302.2">Let’s recap what you learned in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.303.1">this chapter.</span></span></p>
<h1 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.304.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.305.1">In this chapter, you extended your knowledge of potential source code files running in Node.js. </span><span class="koboSpan" id="kobo.305.2">You are now familiar with running WASM – a lower-level portable binary-code language that can be used as a compilation target by many </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.306.1">programming languages.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.307.1">WASM can help you to write functionality once and run it on multiple platforms. </span><span class="koboSpan" id="kobo.307.2">Since WASM can be sandboxed very well, it is a good contender for the next wave of containerized computing, where performance and security are valued highly. </span><span class="koboSpan" id="kobo.307.3">You now know how to write WASM using AssemblyScript. </span><span class="koboSpan" id="kobo.307.4">You are also empowered to integrate created WASM modules </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.308.1">in Node.js.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.309.1">In the next and final chapter, we will take a look at the use of JavaScript beyond Node.js. </span><span class="koboSpan" id="kobo.309.2">We’ll see that other runtimes exist, which are partially compatible with the Node.js ecosystem – providing a great drop-in replacement that can be handy for multiple </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.310.1">use cases.</span></span></p>
</div>
</body></html>