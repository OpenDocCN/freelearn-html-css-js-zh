["```js` We have seen most used data types, but there are some other data types such as union, unknown, void, never, functions, and so on, which are used rarely. If you want to explore more about it, then click on this official reference **TypeScript Types** ([https://www.typescriptlang.org/docs/handbook/2/everyday-types.html](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)).    Now when we know about the data types offered, let us jump to Object Oriented Programming with TypeScript.    # [Class](toc.xhtml#s45a)    Class is a collection of objects which has some common properties that works as components which can be reusable. In simple terms, it is a blueprint of objects. JavaScript supports class after `**ES2015**`, so TypeScript is also allowed to use it. Class basically contains objects, constructors, and methods.    Let us take an example of a class as follows:    `export class Book {`    `private title: string;`    `private author: string;`    `private price: number;`    `constructor(title: string, author: string, price: number) {`    `this.title = title;`    `this.author = author;`    `this.price = price;`    `}`    `// Getter method for title`    `getTitle(): string {`    `return this.title;`    `}`    `// Setter method for title`    `setTitle(value: string) {`    `this.title = value;`    `}`    `// Getter method for author`    `getAuthor(): string {`    `return this.author;`    `}`    `// Setter method for author`    `setAuthor(value: string) {`    `this.author = value;`    `}`    `// Getter method for price`    `getPrice(): number {`    `return this.price;`    `}`    `// Setter method for price`    `setPrice(value: number) {`    `this.price = value;`    `}`    `displayInfo() {`    ``console.log(`Title: ${this.title}`);``    ``console.log(`Author: ${this.author}`);``    ``console.log(`Price: $${this.price}`);``    `}`    `}`    `// Create an instance of the Book class`    `const myBook = new Book('The Great Gatsby', 'F. Scott Fitzgerald', 15.99);`    `// Use getter and setter methods to update book information`    `myBook.title = 'To Kill a Mockingbird';`    `myBook.author = 'Harper Lee';`    `myBook.price = 1200.99;`    `// Display updated book information`    `myBook.displayInfo();`    Here, we have defined a class named Book. Keeping the first letter of class name as capital is a standard practice. We exported that class using keyword **export** so that it can be imported in other files. The class consists of a property called `**title**`, `**author**`, `**price**`, a `**constructor**`, and methods `**get**` and `**set**` respective properties.    A class object is created with a `**new**` keyword and followed by the class name as function and pass argument for required constructor defined. For example, `**new Book('The Great Gatsby', 'F. Scott Fitzgerald', 15.99)**`;.    In Class, `**constructor**` is called first automatically. In this case, `**constructor**` is setting the property `**name**` with the given values. We can access class properties using `**this**` keyword anywhere inside the class. In this example, each property (`**title**`, `**author**`, and `**price**`) has a corresponding getter and setter method. These methods provide controlled access to the private properties of the Book class.    The output of the preceding code would be:    `Output :`    `Title: To Kill a Mockingbird`    `Author: Harper Lee`    `Price: $1200.99`    # [Inheritance](toc.xhtml#s46a)    TypeScript supports inheritance in which one class can be extended by another class in which all its properties and methods are inherited from base class to derived class.    Consider the following example:    `import { Book } from './class';`    `export class EBook extends Book {`    `private format: string;`    `constructor(title: string, author: string, price: number, format: string) {`    `super(title, author, price);`    `this._format = format;`    `}`    `// Override displayInfo method to include format`    `displayInfo() {`    `super.displayInfo(); // Call base class method`    ``console.log(`Format: ${this._format}`);``    `}`    `}`    `// Create an instance of the EBook class`    `const myEBook = new EBook('The Great Gatsby', 'F. Scott Fitzgerald', 15.99, 'PDF');`    `// Display EBook information`    `myEBook.displayInfo();`    `The output would be as follows:`    `Title: To Kill a Mockingbird`    `Author: Harper Lee`    `Price: $1200.99`    `Title: The Great Gatsby`    `Author: F. Scott Fitzgerald`    `Price: $15.99`    `Format: PDF`    As per the preceding example, `**EBook**` is a child class of `**Book**` that extends all its properties and methods to derived (`**EBook**`) class. This means that `**EBook**` inherits all properties and methods from `**Book**`. The constructor of `**EBook**` takes additional parameters (`**title**`, `**author**`, `**price**`, and `**format**`) compared to the base class. It calls the constructor of the base class (`**super**`) with the title, author, and price, and initializes the `**_format**` property specific to `**EBook**`. The `**displayInfo**` method is overridden in `**EBook**` to include information about the e-book’s format. The `**super.displayInfo()**` call invokes the `**displayInfo**` method of the base class to display the book’s title, author, and price. Then, it logs the format of the e-book. This code demonstrates how to extend a base class (`**Book**`) to create a subclass (`**EBook**`) with additional properties and behavior, while also leveraging inheritance and method overriding to reuse and customize functionality from the base class.    # [Access Modifiers](toc.xhtml#s47a)    TypeScript has four different access modifiers for property(field) and method such as `**public**`, `**private**`, `**protected**`, and `**static**`:    *   `**Public**`: It is the default access modifier which can be used anywhere; as the name `**public**`, it can be accessed in the same class, child class, or to any other class.          `class Car {`                    `public brand: string;`                    `constructor(brand: string) {`                    `this.brand = brand;`                    `}`                    `public startEngine() {`                    ``console.log(`Starting the engine of ${this.brand} car.`);``                    `}`                    `}`                    `const myCar = new Car('Toyota');`                    `console.log(myCar.brand); // Accessing public property`                    `myCar.startEngine();      // Accessing public method`                    `Output:`                    `Toyota`                    `Starting the engine of Toyota car.`           *   `**Private**`: It is accessible only within the same class.          `class BankAccount {`                    `private balance: number;`                    `constructor(initialBalance: number) {`                    `this.balance = initialBalance;`                    `}`                    `public deposit(amount: number) {`                    `this.balance += amount;`                    `}`                    `public getBalance() {`                    `return this.balance; // Accessing private property`                    `}`                    `}`                    `const account = new BankAccount(1000);`                    `console.log(account.getBalance()); // Accessing public method`                    `account.deposit(500);             // Accessing public method`                    `console.log(account.balance);    // Error: Property 'balance' is private`           *   **Protected**: It can be accessible in the same class and all of the child classes only. In the example, the `**price**` is defined as protected, so it can be called from within the same and child class.          `class MyBook {`                    `// Public properties`                    `public title: string;`                    `public author: string;`                    `protected price: number; // Protected property`                    `constructor(title: string, author: string, price: number) {`                    `this.title = title;`                    `this.author = author;`                    `this.price = price;`                    `}`                    `}`                    `class EBook extends MyBook {`                    `private format: string;`                    `constructor(title: string, author: string, price: number, format: string) {`                    `super(title, author, price);`                    `this.format = format;`                    `}`                    `public displayInfo() {`                    ``console.log(`Price: ${this.price}`);``                    `}`                    `}`                    `// Create an instance of the Book class`                    `const myBook = new MyBook('The Great Gatsby',`                    `'F. Scott Fitzgerald', 15.99);`                    `// console.log(myBook.price); // Error: Property 'price' is protected and only accessible within the class and its subclasses`                    `// Create an instance of the EBook class`                    `const myEBook = new EBook('The Great Gatsby',`                    `'F. Scott Fitzgerald', 15.99, 'PDF');`                    `// Accessing public properties and method of EBook`                    `myEBook.displayInfo(); // Accessible`                    `Output:`                    `Price: 15.99`           *   `**Static**`: It can be used directly without creating an object of class. Properties and methods created using `**static**` belong to the class itself rather than to instances of the class.          `class User {`                    `static user_name: string = 'Jack';`                    `public static calculateWorkingHoursPerMonth(hrsPerDay: number) {`                    `return hrsPerDay * 30;`                    `}`                    `public static setUserName(name: string) {`                    `User.user_name = name;`                    `}`                    `}`                    `const user = User.user_name;`                    ``console.log(`Username = ${user}`);``                    `const totalHrs = User.calculateWorkingHoursPerMonth(8);`                    ``console.log(`Total hrs per month = ${totalHrs}`);``                    `User.setUserName(\"Panchal\");`                    ``console.log(`Modified Username = ${User.user_name}`);``                    `Output:`                    `Username = Jack`                    `Total hrs per month = 240`                    `Modified Username = Panchal`              # [Interface](toc.xhtml#s48a)    Interface is an `**abstract**` and `**static**` type that represents the behavior of a class which just describes the class and not the actual implementation. It is defined by the keyword `**interface**`. For example, an interface `**IUser**` is defined as follows:    `interface IUser {`    `first_name: string;`    `last_name: string;`    `email_id: string;`    `assigned_project_code: number;`    `assigned_project_name?: string;`    `working_hrs_per_day: number;`    `}`    `const userData: IUser = {`    `first_name: 'Jack',`    `last_name: 'Panchal',`    `email_id: 'yami@gmail.com',`    `assigned_project_code: 1,`    `working_hrs_per_day: 8`    `};`    **Note**: *Using* ***I*** *to start an interface name is a standard practice*.    An optional property can be declared with a question mark (?). In the preceding example, `**assigned_project_name**` is marked as optional. `**userData**` is assigned a value to the interface in which `**assigned_project_name**` is not specified and it is not giving error but if any other property, for example, `**email_id**` is missed, TS would throw an error as follows:    `Property 'email_id' is missing in type '{ first_name: string; last_name: string; assigned_project_code: number; working_hrs_per_day: number; }' but required in type 'IUser'.`    We just saw a way to use interfaces to define an object directly. Another way is to create a class and implement the interface as follows:    `class User implements IUser {`    `first_name: string;`    `last_name: string;`    `email_id: string;`    `assigned_project_code: number;`    `assigned_project_name?: string;`    `working_hrs_per_day: number;`    `constructor(first_name: string, last_name: string) {`    `this.first_name = first_name;`    `this.last_name = last_name;`    `}`    `}`    `const newUser = new User(\"Jack\", \"Panchal\");`    `newUser.email_id = 'yami@gmail.com';`    ``console.log(`User = ${JSON.stringify(newUser)}`);``    `Output:`    `User = {\"first_name\":\"Jack\",\"last_name\":\"Panchal\",\"email_id\":\"yami@gmail.com\"};`    In the preceding example, we are creating a class User by implementing the `**IUser**` interface. After defining the class, we are creating a user variable to create an object of the class `**user**`. This can be rewritten as:    `const user:IUser = new User(\"Jack\", \"Panchal\");`    Here, we are using interface `**IUser**` to let typescript know that the variable `**user**` is of type `**IUser**` and the `**user**` can contain only those properties which are declared by the interface `**IUser**`.    # [Abstraction](toc.xhtml#s49a)    Abstraction is a fundamental concept which allows us to define abstract classes and methods. The methods defined this way do not specify any implementation.    Consider the following example where a `**BaseClass**` is defined as abstract using the keyword `**abstract**`. A `**setName()**` method is also defined as abstract. We can see that there is no implementation provided for this method.    `**abstract** class Book {`    `protected title: string;`    `protected author: string;`    `protected price: number;`    `constructor(title: string, author: string, price: number) {`    `this.title = title;`    `this.author = author;`    `this.price = price;`    `}`    `// Abstract method to display book information`    `**abstract displayInfo()**: void;`    `}`    Implementation of the `**displayInfo**` method is the responsibility of the classes which will extend the `**Book**` class. Now, let us create another class which extends the `**Book**` class we just created:    `// Concrete class representing a PrintedBook, extending Book`    `class PrintedBook extends Book {`    `private format: string;`    `constructor(title: string, author: string, price: number, format: string) {`    `super(title, author, price);`    `this.format = format;`    `}`    `// Implementation of abstract method to display book information`    `displayInfo(): void {`    ``console.log(`Title: ${this.title}`);``    ``console.log(`Author: ${this.author}`);``    ``console.log(`Price: $${this.price}`);``    ``console.log(`Format: ${this.format}`);``    `}`    `}`    `// Create instances of books`    `const printedBook = new PrintedBook('The Great Gatsby', 'F. Scott Fitzgerald', 15.99, 'Hardcover');`    `// Display book information`    `printedBook.displayInfo();`    Output:    `Title: The Great Gatsby`    `Author: F. Scott Fitzgerald`    `Price: $15.99`    `Format: Hardcover`    The example of the class `**PrintedBook**` did its own implementation of the `**displayInfo()**` method. Any other class which extends `**Book**` class can choose their own implementation for the method.    # [Encapsulation](toc.xhtml#s50a)    Encapsulation is hiding internal data and making it available only through some other way such as creating a getter function. In simple terms, it restricts visibility of all actual details of code and displays only the outer layer of code through access modifiers.    **Example:**    `class BankAccountClass {`    `private accountNumber: string;`    `private balance: number;`    `constructor(accountNumber: string, initialBalance: number) {`    `this.accountNumber = accountNumber;`    `this.balance = initialBalance;`    `}`    `deposit(amount: number): void {`    `this.balance += amount;`    ``console.log(`Deposited ${amount} into account ${this.accountNumber}. New balance: ${this.balance}`);``    `}`    `withdraw(amount: number): void {`    `if (amount > this.balance) {`    `console.log(\"Insufficient funds.\");`    `} else {`    `this.balance -= amount;`    ``console.log(`Withdrawn ${amount} from account ${this.accountNumber}. New balance: ${this.balance}`);``    `}`    `}`    `getAccountInfo(): void {`    ``console.log(`Account Number: ${this.accountNumber}, Balance: ${this.balance}`);``    `}`    `}`    `// Create an instance of the BankAccount class`    `const myAccount = new BankAccountClass('123456789', 1000);`    `// Accessing properties and methods using encapsulation`    `myAccount.deposit(500); // Deposited 500 into account 123456789\\. New balance: 1500`    `myAccount.withdraw(200); // Withdrawn 200 from account 123456789\\. New balance: 1300`    `myAccount.getAccountInfo(); // Account Number: 123456789, Balance: 1300`    `// Attempting to access private members directly (will result in TypeScript compilation error)`    `// console.log(myAccount.accountNumber); // Error: Property 'accountNumber' is private and only accessible within class 'BankAccount'.`    `// console.log(myAccount.balance); // Error: Property 'balance' is private and only accessible within class 'BankAccount'.`    Output:    `Original customer details:`    `Name: John Doe, Email: john@example.com, Phone Number: 123-456-7890`    `Updated customer details:`    `Name: Jane Smith, Email: jane@example.com, Phone Number: 987-654-3210`    In the example, the `**accountNumber**` and balance properties are private, and they can only be accessed or modified within the `**BankAccount**` class itself. Encapsulation ensures that the internal state of the `**BankAccount**` object is protected, and external code cannot directly manipulate it. Instead, interactions with the object’s state are performed through well-defined methods like deposit, withdraw, and `**getAccountInfo**`, which encapsulate the underlying data and behavior.    In addition, `**accountNumber**` and balance are private members of class so that is not accessible outside of the class. If anyone tries to set value directly, then it gives an error of not being accessible; so sometimes it provides advantage of security using private members.    `// Attempting to access private members directly (will result in TypeScript compilation error)`    `console.log(myAccount.accountNumber); // Error: Property 'accountNumber' is private and only accessible within class 'BankAccount'.`    `console.log(myAccount.balance); // Error: Property 'balance' is private and only accessible within class 'BankAccount'.`    # [Polymorphism](toc.xhtml#s51a)    In *Polymorphism*, *Poly* means many and *morphism* means form. It is a concept that refers to the ability of objects to take on multiple forms depending on the context.    We can use polymorphism to create classes which implement the same interface or base class. Let us consider a simple example:    `// Define an interface for a printable item`    `interface IPrintable {`    `print(): void;`    `}`    Now let’s create two classes implementing the interface:    `// Implement the Printable interface for a Book class`    `class Books implements IPrintable {`    `constructor(private title: string, private author: string) { }`    `// Implement the print method from the Printable interface`    `print(): void {`    ``console.log(`Title: ${this.title}`);``    ``console.log(`Author: ${this.author}`);``    `}`    `}`    `// Implement the IPrintable interface for a Document class`    `class Documents implements IPrintable {`    `constructor(private name: string) { }`    `// Implement the print method from the Printable interface`    `print(): void {`    ``console.log(`Document Name: ${this.name}`);``    `console.log(\"This is a Printable document.\");`    `}`    `}`    `// Create instances of Book and Document`    `const book = new Books(\"The Great Gatsby\", \"F. Scott Fitzgerald\");`    `const doc = new Documents(\"Sample Document\");`    `// Call the printItem function with different Printable items`    `book.print();`    `doc.print();`    Output:    `Title: The Great Gatsby`    `Author: F. Scott Fitzgerald`    `Document Name: Sample Document`    `This is a printable document.`    In the preceding example, both the `**Books**` and `**Documents**` classes implement the `**IPrintable**` interface, which defines a `**print()**` method. By implementing the same method with different behavior in each class, we create objects of different types that can be used interchangeably wherever an `**IPrintable**` is expected.    The `**print()**` method in each class is specific to the type of `**book**`, and the actual behavior is determined at runtime based on the specific object being used. This is an example of runtime polymorphism, where the behavior of the method is determined at runtime based on the actual type of the object, rather than at compile-time.    So, when we call `**book.print()**`, the `**print()**` method in the Books class is executed, and when we call `**Document.print()**`, the `**print()**` method in the Documents class is executed. This demonstrates the ability of objects to take on multiple forms depending on their specific implementation, which is the essence of polymorphism.    # [ECMAScript Features](toc.xhtml#s52a)    ECMAScript is a standard of JavaScript that was first introduced in 2015; then onwards every year in the month of June, a new version is released. Currently, ES2022 is the latest version for ECMAScript. It is the 13th edition. The name ECMAScript comes from the fact that it was developed by Ecma International, a non-profit organization that was formerly known as the European Computer Manufacturers Association (ECMA).    Let us quickly jump into the features of ECMAScript.    # [Arrow Functions](toc.xhtml#s53a)    Arrow Function is an anonymous function with short syntax compared to vanilla JavaScript. It does not have self-binding so cannot be used as a method or constructor. In normal JavaScript function, `\"**this**\"` keyword refers to the function where it is called, whereas in arrow function, `\"**this**\"` keyword refers to a global object or its parent object. It is also not a binding of arguments.    Syntax of arrow function is as following:    `let arrowFunction = (arg1, arg2, …argN) => {`    `statement(s)`    `}`    Let us take an example of a simple function that just adds two numbers. The normal JavaScript function would be:    `function sum (num1, num2) {`    `return num1 + num2;`    `}`    The same function in form of arrow functions can be written as:    `((num1, num2) => {`    `return num1 + num2;`    `})`    # [Using this Keyword](toc.xhtml#s54a)    Consider the following example:    `let projectName = \"PMS\";`    `let project = {`    `projectName: \"Project Management System\",`    `normalFunction() {`    `console.log(this.projectName, this);`    `},`    `arrowFunction: () => {`    `console.log(this.projectName, this);`    `}`    `};`    In the preceding example, we have two functions available for the variable project. See that we have `**projectName**` as variable on global scope and `**projectName**` as a property inside the project object.    If we make a call to normal function, the output would be:    `project.normalFunction();`    `// output in browser`    `Project Management System, {projectName: 'Project Management System', normalFunction: ƒ, arrowFunction: ƒ}`    The `**'this'**` keyword here refers to the object project and prints the project object.    Now let us call the arrow function:    `project.arrowFunction();`    `// Output in browser`    `undefined, Window {window: Window, self: Window, document: document, name: '', location: Location, …}`    Here, in the arrow function, the binding does not happen and the `**'this'**` keyword refers to the Window object of the browser. In the window object, there is no `**projectName**` variable, hence we got undefined as the first value in the log.    The behavior would be different for the arrow function if we run the same function in the terminal. Since there is no window object in the terminal, it outputs a blank object.    `//In Terminal`    `undefined, {}`    # [Using the new Keyword](toc.xhtml#s55a)    In JavaScript, the new keyword is used to create a new instance of an object. In the case of arrow function, this behavior is different. If we try to use a new keyword to create an object of an arrow function, we would get a ``**TypeError**``. The arrow functions are designed to be used as expressions rather than constructors.    `// arrow function with new keyword`    `const Task = () => {};`    `const obj = new Task(); // TypeError: Task is not a constructor`   ```", "```js ```"]