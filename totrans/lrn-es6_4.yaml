- en: Chapter 4. Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 异步编程
- en: ES6 introduced a native support for the well-known programming patterns. One
    such pattern is the Promise pattern, which makes it easier to read and write the
    asynchronous code. In this chapter, we will learn to write asynchronous code using
    the ES6 Promise API. The new JavaScript and **HTML5** asynchronous APIs are now
    being implemented with Promises to facilitate writing less and cleaner code. Therefore,
    it's important to learn Promises in-depth. We will also see some example APIs
    that are exposed using Promises such as the **Web Cryptography API**, and the
    **Battery Status API**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了对知名编程模式的原生支持。其中一种模式是Promise模式，它使得异步代码的读写更加容易。在本章中，我们将学习如何使用ES6 Promise
    API编写异步代码。新的JavaScript和HTML5异步API现在正通过Promise实现，以简化代码的编写。因此，深入学习Promise非常重要。我们还将看到一些使用Promise公开的示例API，例如**Web
    Cryptography API**和**Battery Status API**。
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The JavaScript execution model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript执行模型
- en: The difficulties faced while writing the asynchronous code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步代码时遇到的困难
- en: Creating Promises and how Promises work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Promise及其工作原理
- en: How Promises make it easier to write the asynchronous code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise如何简化异步代码的编写
- en: The different states of a Promise
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise的不同状态
- en: Various methods of the Promise object.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise对象的各种方法。
- en: Various JavaScript and HTML5 APIs, which use Promises
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Promise的JavaScript和HTML5 API
- en: The JavaScript execution model
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript执行模型
- en: The JavaScript code is executed in a single thread, that is, two pieces of script
    cannot run at same time. Each website opened in browser gets a single thread for
    downloading, parsing, and executing the website called as the main thread.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码是在单线程中执行的，也就是说，两段脚本不能同时运行。浏览器中打开的每个网站都会获得一个用于下载、解析和执行网站的单独线程，称为主线程。
- en: The main thread also maintains a queue, which has asynchronous tasks queued
    to be executed one by one. These queued tasks can be event handlers, callbacks,
    or any other kind of task. The new tasks are added to the queue as **AJAX** requests/response
    happen, events occur, timers registered, and more. One long running queue task
    can stop the execution of all other queue tasks and the main script. The main
    thread executes the tasks of this queue whenever possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程还维护一个队列，该队列包含排队等待依次执行的任务。这些排队任务可以是事件处理器、回调函数或任何其他类型的任务。当发生AJAX请求/响应、事件发生、注册计时器等情况时，新任务会被添加到队列中。一个长时间运行的队列任务可能会停止所有其他队列任务和主脚本的执行。主线程会在可能的情况下执行队列中的任务。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: HTML5 introduced **web workers**, which are the actual threads running parallel
    to the main thread. When a web worker finishes executing or needs to notify the
    main thread, it simply adds a new event item to the queue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了**Web Workers**，它们是与主线程并行运行的线程。当Web Worker完成执行或需要通知主线程时，它只需将一个新的事件项添加到队列中。
- en: This queue is what makes it possible for executing the code asynchronously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个队列使得异步执行代码成为可能。
- en: Writing asynchronous code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: ES5 natively supports two patterns for writing the asynchronous code, that is,
    the event pattern and the callback pattern. While writing the asynchronous code,
    we usually start an asynchronous operation and register the event handlers or
    pass the callbacks, which will be executed once the operation is finished.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ES5原生支持两种编写异步代码的模式，即事件模式和回调模式。在编写异步代码时，我们通常启动一个异步操作并注册事件处理器或传递回调函数，这些函数将在操作完成后执行。
- en: The event handlers or the callbacks are used, depending on how the specific
    asynchronous API is designed. An API that is designed for an event pattern can
    be wrapped with some custom code to create the callback pattern for the API, and
    vice-versa. For example, AJAX is designed for the event pattern, but **jQuery**
    AJAX exposes it as a callback pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定的异步API设计，使用事件处理器或回调函数。为事件模式设计的API可以通过一些自定义代码包装成回调模式，反之亦然。例如，AJAX是为事件模式设计的，但**jQuery**
    AJAX将其暴露为回调模式。
- en: Let's consider some examples of writing asynchronous code involving events and
    callbacks and their difficulties.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些涉及事件和回调的异步代码编写示例及其困难。
- en: The asynchronous code involving events
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涉及事件的异步代码
- en: For asynchronous JavaScript APIs involving events, you need to register the
    success and error event handlers which will be executed depending on whether the
    operation was a success or failure respectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及事件的异步 JavaScript API，你需要注册成功和错误事件处理器，它们将根据操作是否成功而分别执行。
- en: 'For example, while making an AJAX request, we register the event handlers which
    will be executed depending on whether the AJAX request was made successfully or
    not. Consider this code snippet which makes and AJAX request and logs the retrieved
    information:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在发起 AJAX 请求时，我们注册的事件处理器将根据 AJAX 请求是否成功而执行。考虑以下发起 AJAX 请求并记录检索信息的代码片段：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we assume the `data.json` file to have this content:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设 `data.json` 文件包含以下内容：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `send()` method of the `XMLHttpRequest` object is executed asynchronously,
    which retrieves the `data.json` file and calls the `load` or `error` event handler,
    depending on whether the request was made successfully or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象的 `send()` 方法是异步执行的，它检索 `data.json` 文件并调用 `load` 或 `error`
    事件处理器，具体取决于请求是否成功。'
- en: 'There is absolutely no issue with how this AJAX works, but the issue is with
    how we write the code involving events. Here are the issues that we faced while
    writing the previous code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AJAX 的工作方式，绝对没有任何问题，但问题在于我们编写涉及事件处理的代码。以下是我们在编写前一段代码时遇到的问题：
- en: We had to add an exception handler for every block of code that will be executed
    asynchronously. We can't just wrap the whole code using a single `try…catch` statement.
    This makes it difficult to catch the exceptions.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不为每个将要异步执行的代码块添加异常处理器。我们不能只用一个 `try…catch` 语句来包裹整个代码。这使得捕获异常变得困难。
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可读性较差，因为嵌套的函数调用使得代码流程难以追踪。
- en: If another part of the program wants to know if the asynchronous operation is
    finished, pending, or being executed then we have to maintain the custom variables
    for that purpose. So we can say it is difficult to find the state of the asynchronous
    operation.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序的其他部分想要知道异步操作是否已完成、挂起或正在执行，那么我们必须维护用于此目的的自定义变量。因此，我们可以说找到异步操作的状态是困难的。
- en: 'This code can get even more complicated and harder to read if you are nesting
    multiple AJAX or any other asynchronous operations. For example, after displaying
    the data, you may want to ask the user to verify if the data is correct or not
    and then send the Boolean value back to the server. Here is the code example to
    demonstrate this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在嵌套多个 AJAX 或其他任何异步操作，这段代码可能会变得更加复杂和难以阅读。例如，在显示数据后，你可能希望让用户验证数据是否正确，然后将布尔值发送回服务器。以下是一个代码示例，演示了这一过程：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The asynchronous code involving callbacks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涉及回调的异步代码
- en: For asynchronous JavaScript APIs involving callbacks, you need to pass the success
    and error callbacks, which will be called depending on whether the operation was
    a success or failure respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及回调的异步 JavaScript API，你需要传递成功和错误回调，它们将根据操作是否成功或失败而分别被调用。
- en: 'For example, while making an AJAX request using jQuery, we need to pass the
    callbacks, which will be executed depending on whether the AJAX request was made
    successfully or not. Consider this code snippet that makes an AJAX request using
    jQuery and logs the retrieved information:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在使用 jQuery 进行 AJAX 请求时，我们需要传递回调函数，这些函数将根据 AJAX 请求是否成功而执行。考虑以下使用 jQuery 进行
    AJAX 请求并记录检索信息的代码片段：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Even here, there is absolutely no issue with how this jQuery AJAX works, but
    the issue is with how we write the code involving callbacks. Here are the issues
    that we faced while writing the preceding code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这里，jQuery AJAX 的工作方式绝对没有任何问题，但问题在于我们编写涉及回调的代码。以下是我们在编写前一段代码时遇到的问题：
- en: It is difficult to catch the exceptions, as we have to use multiple `try` and
    `catch` statements.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常很困难，因为我们不得不使用多个 `try` 和 `catch` 语句。
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可读性较差，因为嵌套的函数调用使得代码流程难以追踪。
- en: It's difficult to maintain the state of the asynchronous operation.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护异步操作的状态很困难。
- en: Even this code will get more complicated if we nest the multiple jQuery AJAX
    or any other asynchronous operations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样，如果我们在嵌套多个 jQuery AJAX 或其他任何异步操作，代码也会变得更加复杂。
- en: Promises to the rescue
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺拯救
- en: ES6 introduces a new native pattern for writing the asynchronous code called
    as Promise pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一种新的本地模式来编写异步代码，称为Promise模式。
- en: This new pattern removes the common code issues that the event and callback
    pattern had. It also makes the code look more like a synchronous code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的模式消除了事件和回调模式中常见的代码问题。它还使代码看起来更像同步代码。
- en: A Promise (or a Promise object) represents an asynchronous operation. The existing
    asynchronous JavaScript APIs are usually wrapped with Promises, and the new JavaScript
    APIs are being purely implemented using the Promises.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Promise（或Promise对象）表示一个异步操作。现有的异步JavaScript API通常用Promise包装，新的JavaScript API正在纯使用Promise实现。
- en: Promises are new in JavaScript but are already present in many other programming
    languages. Programming Languages such as C# 5, C++ 11, Swift, Scala, and more
    are some examples that support Promises.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Promise在JavaScript中是新的，但已经在许多其他编程语言中存在。例如，支持Promise的编程语言有C# 5、C++ 11、Swift、Scala等。
- en: ES6 provides the Promise API using which we can create Promises and use them.
    Let's explore the ES6 Promise API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ES6提供了Promise API，我们可以使用它创建Promise并使用它。让我们探索ES6的Promise API。
- en: The Promise constructor
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise构造函数
- en: The `Promise` constructor is used to create new Promise instances. A Promise
    object represents an asynchronous operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Promise`构造函数来创建新的Promise实例。Promise对象表示一个异步操作。
- en: We need to pass a callback to the `Promise` constructor, which executes the
    asynchronous operation. This callback is called as the **executor**. The executor
    should take two parameters, that is, the `resolve` and `reject` callbacks. The
    `resolve` callback should be executed if the asynchronous operation was successful,
    and the `reject` callback should be executed if the operation was unsuccessful.
    If the asynchronous operation was successful and has a result, then we can pass
    the result of the asynchronous operation to the `resolve` callback. If the asynchronous
    operation was unsuccessful, then we can pass the reason of failure to the `reject`
    callback.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一个回调函数传递给`Promise`构造函数，该函数执行异步操作。这个回调函数被称为**执行器**。执行器应该接受两个参数，即`resolve`和`reject`回调。如果异步操作成功，则应执行`resolve`回调，如果操作失败，则应执行`reject`回调。如果异步操作成功并且有一个结果，则我们可以将异步操作的结果传递给`resolve`回调。如果异步操作失败，则我们可以将失败原因传递给`reject`回调。
- en: 'Here is a code example, which demonstrates how to create a Promise and wrap
    an AJAX request using it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何创建一个Promise并使用它包装一个AJAX请求：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The executor is executed synchronously. But the executor is executing an asynchronous
    operation and therefore, the executor can return before the asynchronous operation
    is finished.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器是同步执行的。但是执行器正在执行一个异步操作，因此，执行器可以在异步操作完成之前返回。
- en: 'A Promise is always in one of these states:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Promise始终处于以下状态之一：
- en: '**Fulfilled**: If the `resolve` callback is invoked with a non-Promise object
    as argument or no argument, then we say that the Promise is fulfilled'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已履行**：如果`resolve`回调以非Promise对象作为参数调用或没有参数，那么我们说Promise已履行'
- en: '**Rejected**: If the `reject` callback is invoked or an exception occurs in
    the executor scope, then we say that the Promise is rejected'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已拒绝**：如果调用`reject`回调或执行器作用域中发生异常，那么我们说Promise已拒绝'
- en: '**Pending**: If the `resolve` or `reject` callback is yet to be invoked, then
    we say that the Promise is pending'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：如果`resolve`或`reject`回调尚未被调用，那么我们说Promise是挂起的'
- en: '**Settled**: A Promise is said to be settled if it''s either fulfilled or rejected,
    but not pending'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决**：如果Promise要么已履行要么已拒绝，但不是挂起，则称Promise已解决'
- en: Once a Promise is fulfilled or rejected, it cannot be transitioned back. An
    attempt to transition it will have no effect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Promise被履行或拒绝，它就不能再回退。尝试转换它将没有效果。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the `resolve` callback is invoked with a Promise object as an argument, then
    the Promise object is either fulfilled or rejected, depending on whether the passed
    Promise object is fulfilled or rejected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`resolve`回调以Promise对象作为参数调用，那么Promise对象要么已履行，要么已拒绝，具体取决于传递的Promise对象是已履行还是已拒绝。
- en: The fulfillment value
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 履行值
- en: The fulfillment value of a fulfilled Promise represents the result of a successful
    asynchronous operation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 已履行Promise的履行值表示成功异步操作的结果。
- en: If the argument that we passed to the `resolve` callback is anything other than
    another Promise object, then the argument itself is considered as a fulfillment
    value of the Promise object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递给`resolve`回调函数的参数不是另一个Promise对象，那么这个参数本身就被视为Promise对象的完成值。
- en: If we pass nothing to the `resolve` callback, then the fulfillment value is
    considered as `undefined,` and the Promise is considered to be fulfilled.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有向`resolve`回调函数传递任何内容，那么完成值被视为`undefined`，并且Promise被认为是完成的。
- en: To see what happens when we pass a Promise object as an argument to the `resolve`
    callback, consider this example—suppose we have a Promise named A. Promise A's
    `resolve` callback was called by passing Promise B as argument then Promise A
    is said to be fulfilled if Promise B is fulfilled and the fulfillment value of
    Promise A now is same as the fulfillment value of Promise B.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解当我们将Promise对象作为参数传递给`resolve`回调函数时会发生什么，请考虑以下示例——假设我们有一个名为A的Promise。当通过传递Promise
    B作为参数调用Promise A的`resolve`回调函数时，如果Promise B被完成，那么Promise A也被认为是完成的，并且Promise A的完成值现在与Promise
    B的完成值相同。
- en: 'Consider this code example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous example, as Promise B gets rejected, therefore Promise A also
    gets rejected. The reason for the rejection of both the Promises is the string
    called `"Reason"`. Similarly, C gets fulfilled if D gets fulfilled. The fulfillment
    value of C and D is the string called `"Result"`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由于Promise B被拒绝，因此Promise A也被拒绝。两个Promise拒绝的原因是字符串“Reason”。同样，如果D被完成，那么C也会被完成。C和D的完成值是字符串“Result”。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we say that "a Promise resolves with a value, or is resolved with a value,"
    it means that the executor of the Promise invokes or has invoked the `resolve`
    callback with the value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“Promise以某个值解决，或者被某个值解决”时，这意味着Promise的执行者调用了或已经调用了`resolve`回调函数，并传递了该值。
- en: The then(onFulfilled, onRejected) method
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`then(onFulfilled, onRejected)`方法'
- en: The `then()` method of a Promise object lets us do some task after a Promise
    has been fulfilled or rejected. The task can also be another event-driven or callback-based
    asynchronous operation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Promise对象的`then()`方法允许我们在Promise完成或拒绝后执行一些任务。这个任务也可以是另一个事件驱动或基于回调的异步操作。
- en: The `then()` method of a Promise object takes two arguments, that is, the `onFulfilled`
    and `onRejected` callbacks. The `onFulfilled` callback is executed if the Promise
    object was fulfilled, and the `onRejected` callback is executed if the Promise
    was rejected.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Promise对象的`then()`方法接受两个参数，即`onFulfilled`和`onRejected`回调函数。如果Promise对象被完成，则执行`onFulfilled`回调函数；如果Promise被拒绝，则执行`onRejected`回调函数。
- en: The `onRejected` callback is also executed if an exception is thrown in the
    scope of the executor. Therefore, it behaves like an exception handler, that is,
    it catches the exceptions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行者作用域中抛出异常，则也会执行`onRejected`回调函数。因此，它表现得像一个异常处理器，即它捕获异常。
- en: The `onFulfilled` callback takes a parameter, that is, the fulfillment value
    of the Promise. Similarly, the `onRejected` callback takes a parameter, that is,
    the reason of rejection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`onFulfilled`回调函数接受一个参数，即Promise的完成值。同样，`onRejected`回调函数接受一个参数，即拒绝的原因。'
- en: The callbacks passed to the `then()` method are executed asynchronously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`then()`方法的回调函数是异步执行的。
- en: 'Here is the code example to demonstrate the `then()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示`then()`方法的代码示例：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, if the AJAX request was successful (that is, the Promise was fulfilled),
    then the `onFulfilled` callback is executed by passing the response text as the
    argument. The `onFulfilled` callback converts the JSON string into the JavaScript
    object. The `onFulfilled` callback returns the JavaScript object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果AJAX请求成功（即Promise被完成），则通过传递响应文本作为参数执行`onFulfilled`回调函数。`onFulfilled`回调函数将JSON字符串转换为JavaScript对象。`onFulfilled`回调函数返回JavaScript对象。
- en: 'Many programmers remove the Promise object variable, and write the preceding
    code in this way:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员移除了Promise对象变量，并这样编写前面的代码：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This style makes the code even easier to read. All the new JavaScript APIs that
    are implemented using Promises come in this pattern.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格使代码更容易阅读。所有使用Promises实现的新的JavaScript API都采用这种模式。
- en: 'The `then()` method always returns a new `promise` object, which resolves the
    return value of the calling callback. Here is how a new `promise` object is returned
    by the `then()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`方法始终返回一个新的`promise`对象，该对象解决调用回调函数的返回值。以下是`then()`方法返回新的`promise`对象的方式：'
- en: If the `onFulfilled` callback is called and there is no return statement in
    it, then a new fulfilled Promise is created internally and returned.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onFulfilled`回调被调用，并且其中没有返回语句，那么内部会创建一个新的已解决的`Promise`并返回。
- en: If the `onFulfilled` callback is called and we return a custom Promise, then
    it internally creates and returns a new `promise` object. The new Promise object
    resolves the custom Promise object.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onFulfilled`回调被调用，并且我们返回一个自定义`Promise`，那么它会内部创建并返回一个新的`promise`对象。新`Promise`对象解析为自定义`Promise`对象。
- en: If the `onFulfilled` callback is called and we return something else other than
    a custom Promise, then also a new Promise object is created internally and returned.
    The new Promise object resolves the return value.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onFulfilled`回调被调用，并且我们返回的不是自定义`Promise`，那么也会内部创建一个新的`Promise`对象并返回。新`Promise`对象解析为返回值。
- en: If we pass `null` instead of the `onFulfilled` callback, then a callback is
    created internally and replaced with the `null`. The internally created `onFulfilled`
    returns a new fulfilled `promise` object. The fulfillment value of the new `promise`
    object is same as the fulfillment value of the parent Promise.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递`null`而不是`onFulfilled`回调，那么内部会创建一个回调并替换为`null`。内部创建的`onFulfilled`返回一个新的已解决的`promise`对象。新`promise`对象的解决值与父`Promise`的解决值相同。
- en: If the `onRejected` callback is called and there is no return statement in it,
    then a new rejected Promise is created internally and returned.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onRejected`回调被调用，并且其中没有返回语句，那么内部会创建一个新的被拒绝的`Promise`并返回。
- en: If `onRejected` callback is called and we return a custom Promise, then it internally
    creates and returns a new `promise` object. The new `promise` object resolves
    the custom `promise` object.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onRejected`回调被调用，并且我们返回一个自定义`Promise`，那么它会内部创建并返回一个新的`promise`对象。新`promise`对象解析为自定义`Promise`对象。
- en: If the `onRejected` callback is called and we return something else other than
    a custom Promise, then also a new `promise` object is created internally and returned.
    The new `promise` object resolves the returned value.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onRejected`回调被调用，并且我们返回的不是自定义`Promise`，那么内部也会创建一个新的`promise`对象并返回。新`promise`对象解析为返回的值。
- en: If we pass `null` instead of the `onRejected` callback, or omit it, then a callback
    is created internally and is used instead. The internally created `onRejected`
    callback returns a new rejected `promise` object. The reason of rejection of the
    new `promise` object is same as the reason of rejection of the parent Promise.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递`null`而不是`onRejected`回调，或者省略它，那么内部会创建一个回调并使用它。内部创建的`onRejected`回调返回一个新的被拒绝的`promise`对象。新`promise`对象被拒绝的原因与父`Promise`被拒绝的原因相同。
- en: 'In the previous code example, we haven''t yet logged the retrieved data to
    console. We can chain Promises to do this. And also in the previous code, we do
    not handle the exceptions that might occur in the `onFulfilled` callback. Here
    is how we can expand the code to log data and also handle exceptions of all the
    `onFulfilled` callbacks chained:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们还没有将检索到的数据记录到控制台。我们可以通过链式连接`Promise`来实现这一点。此外，在之前的代码中，我们没有处理`onFulfilled`回调中可能发生的异常。以下是我们可以如何扩展代码来记录数据和处理所有链式`onFulfilled`回调的异常：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code example, we chained multiple Promises using the `then()` method
    to parse and log the response received by the executor of the first Promise of
    the chain. Here, the last `then()` method is used as an exception or error handler
    for all the `onFulfilled` methods and executors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们使用`then()`方法链式连接多个`Promise`，以解析和记录链中第一个`Promise`的执行者接收到的响应。在这里，最后一个`then()`方法被用作所有`onFulfilled`方法和执行者的异常或错误处理器。
- en: 'Here is an image that shows how the execution of multiple chained Promises
    work:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张图展示了多个链式`Promise`的执行方式：
- en: '![The then(onFulfilled, onRejected) method](img/4197_04_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![then(onFulfilled, onRejected)方法](img/4197_04_01.jpg)'
- en: Image courtesy of MDN
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由MDN提供
- en: 'Let''s go ahead and add an event driven asynchronous operation to the chain,
    that is, to verify if the data displayed is correct or not. Here is how we can
    expand the code to do this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向链中添加一个事件驱动的异步操作，即验证显示的数据是否正确。以下是我们可以如何扩展代码来完成此操作：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can see how wrapping the AJAX operation with Promises made the code easier
    to read and write. Now the code is more understandable at first glance.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，将AJAX操作用`Promise`包装使代码更容易阅读和编写。现在代码一开始看起来就更容易理解。
- en: The catch(onRejected) method
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catch(onRejected)方法
- en: The `catch()` method of a `promise` object is used instead of the `then()` method,
    when we use the `then()` method only to handle errors and exceptions. There is
    nothing special about how the `catch()` method works. It's just that it makes
    the code much easier to read, as the word "catch" makes it more meaningful.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只使用`then()`方法来处理错误和异常时，使用`promise`对象的`catch()`方法代替`then()`方法。`catch()`方法的工作方式并没有什么特别之处。它只是使代码更容易阅读，因为“catch”这个词使其更有意义。
- en: The `catch()` method just takes one argument, that is, the `onRejected` callback.
    The `onRejected` callback of the `catch()` method is invoked in the same way as
    the `onRejected` callback of the `then()` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch()`方法只接受一个参数，即`onRejected`回调。`catch()`方法的`onRejected`回调以与`then()`方法的`onRejected`回调相同的方式被调用。'
- en: 'The `catch()` method always returns a Promise. Here is how a new `promise`
    object is returned by the `catch()` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch()`方法始终返回一个`Promise`。以下是`catch()`方法如何返回一个新的`promise`对象：'
- en: If there is no return statement in the `onRejected` callback, then a new fulfilled
    Promise is created internally and returned.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`onRejected`回调中没有返回语句，那么内部会创建一个新的实现`Promise`并返回。
- en: If we return a custom Promise, then it internally creates and returns a new
    `promise` object. The new `promise` object resolves the custom `promise` object.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们返回一个自定义`Promise`，那么它内部创建并返回一个新的`promise`对象。新`promise`对象解析自定义`promise`对象。
- en: If we return something else other than a custom Promise in the `onRejected`
    callback, then also a new `promise` object is created internally and returned.
    The new `promise` object resolves the returned value.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在`onRejected`回调中返回除自定义`Promise`之外的其他内容，那么也会内部创建一个新的`promise`对象并返回。新`promise`对象解析返回的值。
- en: If we pass `null` instead of the `onRejected` callback, or omit it, then a callback
    is created internally and used instead. The internally created `onRejected` callback
    returns a rejected `promise` object. The reason for the rejection of the new `promise`
    object is same as the reason for the rejection of a parent `promise` object.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递`null`而不是`onRejected`回调，或者省略它，那么内部会创建一个回调并使用它代替。内部创建的`onRejected`回调返回一个拒绝的`promise`对象。新`promise`对象拒绝的原因与父`promise`对象拒绝的原因相同。
- en: If the `promise` object to which `catch()` is called gets fulfilled, then the
    `catch()` method simply returns a new fulfilled `promise` object and ignores the
    `onRejected` callback. The fulfillment value of the new `promise` object is same
    as the fulfillment value of the parent Promise.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被`catch()`调用的`promise`对象得到实现，那么`catch()`方法简单地返回一个新的实现`promise`对象，并忽略`onRejected`回调。新`promise`对象的成功值与父`Promise`的成功值相同。
- en: 'To understand the `catch()` method, consider this code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`catch()`方法，考虑以下代码：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code can be rewritten in this way using the `catch()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以使用`catch()`方法重写为以下方式：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These two code snippets work exactly in the same way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段工作方式完全相同。
- en: 'Let''s rewrite the AJAX code example by replacing the last chained `then()`
    method with the `catch()` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过用`catch()`方法替换最后一个链式`then()`方法来重写AJAX代码示例：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now the code is even easier to read at first glance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码在第一眼看起来就更容易阅读了。
- en: The Promise.resolve(value) method
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Promise.resolve(value)`方法'
- en: The `resolve()` method of the `Promise` object takes a value and returns a `promise`
    object that resolves the passed value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`对象的`resolve()`方法接受一个值，并返回一个解析传递值的`promise`对象。'
- en: The `resolve()` method is basically used to convert a value to an `promise`
    object. It is useful when you find yourself with a value that may or may not be
    a Promise, but you want to use it as a Promise. For example, the jQuery Promises
    have different interfaces than the ES6 Promises. Therefore, you can use the `resolve()`
    method to convert the jQuery Promises into the ES6 Promises.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve()`方法基本上用于将一个值转换为`promise`对象。当你发现自己有一个可能或可能不是`Promise`的值，但你想将其用作`Promise`时，它很有用。例如，jQuery
    Promises与ES6 Promises有不同的接口。因此，你可以使用`resolve()`方法将jQuery Promises转换为ES6 Promises。'
- en: 'Here is code example that demonstrates how to use the `resolve()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，演示了如何使用`resolve()`方法：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Promise.reject(value) method
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Promise.reject(value)`方法'
- en: The `reject()` method of the `Promise` object takes a value and returns a rejected
    `promise` object with the passed value as the reason.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`对象的`reject()`方法接受一个值，并返回一个带有传递值的拒绝`promise`对象。'
- en: Unlike `Promise.resolve()` method, the `reject()` method is used for debugging
    purposes and not for converting values into Promises.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Promise.resolve()` 方法不同，`reject()` 方法用于调试目的，而不是将值转换为 Promises。
- en: 'Here is code example that demonstrates how to use the `reject()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示如何使用 `reject()` 方法：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Promise.all(iterable) method
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.all(iterable) 方法
- en: The `all()` method of the `Promise` object takes an iterable object as an argument
    and returns a Promise that fulfills when all of the Promises in the iterable object
    have been fulfilled.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `all()` 方法接受一个可迭代对象作为参数，并在可迭代对象中的所有 Promise 都被实现时返回一个实现的 Promise。'
- en: This can be useful when we want to execute some task after some asynchronous
    operations have finished.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们在一些异步操作完成后想要执行一些任务时非常有用。
- en: 'Here is code example which demonstrates how to use the `Promise.all()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示如何使用 `Promise.all()` 方法：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the iterable object contains a value that is not a `promise` object, then
    it's converted to the Promise object using the `Promise.resolve()` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可迭代对象包含一个不是 `promise` 对象的值，那么它将使用 `Promise.resolve()` 方法转换为 Promise 对象。
- en: 'In case any of the passed Promises get rejected, then the `Promise.all()` method
    immediately returns a new rejected Promise for the same reason as the rejected
    passed Promise. Here is an example to demonstrate this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的任何一个 Promise 被拒绝，那么 `Promise.all()` 方法会立即返回一个新的被拒绝的 Promise，其拒绝原因与被拒绝的传递的
    Promise 相同。以下是一个演示此功能的示例：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Promise.race(iterable) method
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.race(iterable) 方法
- en: The the `race()` method of the `Promise` object takes an iterable object as
    the argument and returns a Promise that fulfills or rejects as soon as one of
    the Promises in the iterable object is fulfilled or rejected, with the fulfillment
    value or reason from that Promise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `race()` 方法接受一个可迭代对象作为参数，并返回一个 Promise，该 Promise 在可迭代对象中的任何一个
    Promise 被实现或拒绝时立即实现或拒绝，其实现值或原因来自那个 Promise。'
- en: As the name suggests, the `race()` method is used to race between Promises and
    see which one finishes first.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`race()` 方法用于在多个 Promise 之间进行竞争，以查看哪个先完成。
- en: 'Here is code example that shows how to use the `race()` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，展示如何使用 `race()` 方法：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The JavaScript APIs based on Promises
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Promises 的 JavaScript API
- en: The new asynchronous JavaScript APIs are now based on the Promise pattern instead
    of events and callbacks. And the new versions of the old JavaScript APIs are now
    based on Promises.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新的异步 JavaScript API 现在基于 Promise 模式，而不是事件和回调。旧 JavaScript API 的新版本现在也基于 Promises。
- en: For example, the old version of the Battery status API and the Web Cryptography
    API were based on event, but the new versions of these APIs are purely implemented
    using Promises. Let's see an overview of these APIs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，旧版本的电池状态 API 和 Web 加密 API 基于事件，但这些 API 的新版本完全使用 Promises 实现。让我们看看这些 API 的概述。
- en: The Battery Status API
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电池状态 API
- en: 'The Battery Status API provides us the battery''s current charge level and
    charging status. Here is a code example of the new Battery Status API:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 电池状态 API 提供了电池的当前充电水平和充电状态。以下是一个新电池状态 API 的代码示例：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `getBattery()` method of the `navigator` object returns a fulfilled Promise
    if it has successfully retrieved the battery information. Otherwise, it returns
    a rejected Promise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator` 对象的 `getBattery()` 方法在成功检索电池信息时返回一个实现的 Promise。否则，它返回一个被拒绝的 Promise。'
- en: If the Promise is fulfilled, then the fulfillment value is an object holding
    the battery information. The `level` property of the fulfillment value represents
    the level of charge remaining.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Promise 被实现，那么实现值是一个包含电池信息的对象。实现值的 `level` 属性表示剩余的充电水平。
- en: The Web Cryptography API
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 加密 API
- en: The Web Cryptography API lets us do hashing, signature generation and verification,
    encryption and decryption.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Web 加密 API 允许我们进行哈希、签名生成和验证、加密和解密。
- en: 'Here is a code example of the new Web Cryptography API:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是新 Web 加密 API 的代码示例：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code example, we will find the SHA-256 hash value of a string.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们将找到一个字符串的 SHA-256 哈希值。
- en: The `window.crypto.subtle.digest` method takes an array buffer of a string and
    hash the algorithm name, and returns a Promise object. If it has successfully
    produced the hashes value, then it returns a fulfilled Promise and the fulfillment
    value is an array buffer representing the hash value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.crypto.subtle.digest` 方法接收一个字符串的数组缓冲区和哈希算法名称，并返回一个 Promise 对象。如果成功生成了哈希值，则返回一个已解决的
    Promise，其解决值是一个表示哈希值的数组缓冲区。'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how JavaScript executes the asynchronous code. We
    learned about the different patterns of writing asynchronous code. We saw how
    Promises make it easier to read and write the asynchronous code, and how to use
    the ES6 Promise API. We also saw some JavaScript APIs that are based on Promises.
    Overall, the chapter aimed at explaining Promises, their benefits, and how to
    use APIs that are based on them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 JavaScript 如何执行异步代码。我们了解了编写异步代码的不同模式。我们看到了 Promises 如何使异步代码的读写更加容易，以及如何使用
    ES6 Promise API。我们还看到了一些基于 Promises 的 JavaScript API。总的来说，本章旨在解释 Promises、它们的优点以及如何使用基于它们的
    API。
- en: In the next chapter, we will learn about ES6 Reflect API and its uses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 ES6 Reflect API 及其用法。
