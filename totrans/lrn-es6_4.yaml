- en: Chapter 4. Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduced a native support for the well-known programming patterns. One
    such pattern is the Promise pattern, which makes it easier to read and write the
    asynchronous code. In this chapter, we will learn to write asynchronous code using
    the ES6 Promise API. The new JavaScript and **HTML5** asynchronous APIs are now
    being implemented with Promises to facilitate writing less and cleaner code. Therefore,
    it's important to learn Promises in-depth. We will also see some example APIs
    that are exposed using Promises such as the **Web Cryptography API**, and the
    **Battery Status API**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript execution model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difficulties faced while writing the asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Promises and how Promises work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Promises make it easier to write the asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different states of a Promise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various methods of the Promise object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various JavaScript and HTML5 APIs, which use Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript execution model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript code is executed in a single thread, that is, two pieces of script
    cannot run at same time. Each website opened in browser gets a single thread for
    downloading, parsing, and executing the website called as the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: The main thread also maintains a queue, which has asynchronous tasks queued
    to be executed one by one. These queued tasks can be event handlers, callbacks,
    or any other kind of task. The new tasks are added to the queue as **AJAX** requests/response
    happen, events occur, timers registered, and more. One long running queue task
    can stop the execution of all other queue tasks and the main script. The main
    thread executes the tasks of this queue whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML5 introduced **web workers**, which are the actual threads running parallel
    to the main thread. When a web worker finishes executing or needs to notify the
    main thread, it simply adds a new event item to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: This queue is what makes it possible for executing the code asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES5 natively supports two patterns for writing the asynchronous code, that is,
    the event pattern and the callback pattern. While writing the asynchronous code,
    we usually start an asynchronous operation and register the event handlers or
    pass the callbacks, which will be executed once the operation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: The event handlers or the callbacks are used, depending on how the specific
    asynchronous API is designed. An API that is designed for an event pattern can
    be wrapped with some custom code to create the callback pattern for the API, and
    vice-versa. For example, AJAX is designed for the event pattern, but **jQuery**
    AJAX exposes it as a callback pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider some examples of writing asynchronous code involving events and
    callbacks and their difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous code involving events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For asynchronous JavaScript APIs involving events, you need to register the
    success and error event handlers which will be executed depending on whether the
    operation was a success or failure respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while making an AJAX request, we register the event handlers which
    will be executed depending on whether the AJAX request was made successfully or
    not. Consider this code snippet which makes and AJAX request and logs the retrieved
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assume the `data.json` file to have this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` method of the `XMLHttpRequest` object is executed asynchronously,
    which retrieves the `data.json` file and calls the `load` or `error` event handler,
    depending on whether the request was made successfully or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is absolutely no issue with how this AJAX works, but the issue is with
    how we write the code involving events. Here are the issues that we faced while
    writing the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We had to add an exception handler for every block of code that will be executed
    asynchronously. We can't just wrap the whole code using a single `try…catch` statement.
    This makes it difficult to catch the exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If another part of the program wants to know if the asynchronous operation is
    finished, pending, or being executed then we have to maintain the custom variables
    for that purpose. So we can say it is difficult to find the state of the asynchronous
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code can get even more complicated and harder to read if you are nesting
    multiple AJAX or any other asynchronous operations. For example, after displaying
    the data, you may want to ask the user to verify if the data is correct or not
    and then send the Boolean value back to the server. Here is the code example to
    demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The asynchronous code involving callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For asynchronous JavaScript APIs involving callbacks, you need to pass the success
    and error callbacks, which will be called depending on whether the operation was
    a success or failure respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while making an AJAX request using jQuery, we need to pass the
    callbacks, which will be executed depending on whether the AJAX request was made
    successfully or not. Consider this code snippet that makes an AJAX request using
    jQuery and logs the retrieved information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Even here, there is absolutely no issue with how this jQuery AJAX works, but
    the issue is with how we write the code involving callbacks. Here are the issues
    that we faced while writing the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to catch the exceptions, as we have to use multiple `try` and
    `catch` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to maintain the state of the asynchronous operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even this code will get more complicated if we nest the multiple jQuery AJAX
    or any other asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Promises to the rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 introduces a new native pattern for writing the asynchronous code called
    as Promise pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This new pattern removes the common code issues that the event and callback
    pattern had. It also makes the code look more like a synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: A Promise (or a Promise object) represents an asynchronous operation. The existing
    asynchronous JavaScript APIs are usually wrapped with Promises, and the new JavaScript
    APIs are being purely implemented using the Promises.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are new in JavaScript but are already present in many other programming
    languages. Programming Languages such as C# 5, C++ 11, Swift, Scala, and more
    are some examples that support Promises.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 provides the Promise API using which we can create Promises and use them.
    Let's explore the ES6 Promise API.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Promise` constructor is used to create new Promise instances. A Promise
    object represents an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: We need to pass a callback to the `Promise` constructor, which executes the
    asynchronous operation. This callback is called as the **executor**. The executor
    should take two parameters, that is, the `resolve` and `reject` callbacks. The
    `resolve` callback should be executed if the asynchronous operation was successful,
    and the `reject` callback should be executed if the operation was unsuccessful.
    If the asynchronous operation was successful and has a result, then we can pass
    the result of the asynchronous operation to the `resolve` callback. If the asynchronous
    operation was unsuccessful, then we can pass the reason of failure to the `reject`
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to create a Promise and wrap
    an AJAX request using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The executor is executed synchronously. But the executor is executing an asynchronous
    operation and therefore, the executor can return before the asynchronous operation
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Promise is always in one of these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fulfilled**: If the `resolve` callback is invoked with a non-Promise object
    as argument or no argument, then we say that the Promise is fulfilled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: If the `reject` callback is invoked or an exception occurs in
    the executor scope, then we say that the Promise is rejected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pending**: If the `resolve` or `reject` callback is yet to be invoked, then
    we say that the Promise is pending'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Settled**: A Promise is said to be settled if it''s either fulfilled or rejected,
    but not pending'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a Promise is fulfilled or rejected, it cannot be transitioned back. An
    attempt to transition it will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `resolve` callback is invoked with a Promise object as an argument, then
    the Promise object is either fulfilled or rejected, depending on whether the passed
    Promise object is fulfilled or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The fulfillment value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fulfillment value of a fulfilled Promise represents the result of a successful
    asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument that we passed to the `resolve` callback is anything other than
    another Promise object, then the argument itself is considered as a fulfillment
    value of the Promise object.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass nothing to the `resolve` callback, then the fulfillment value is
    considered as `undefined,` and the Promise is considered to be fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: To see what happens when we pass a Promise object as an argument to the `resolve`
    callback, consider this example—suppose we have a Promise named A. Promise A's
    `resolve` callback was called by passing Promise B as argument then Promise A
    is said to be fulfilled if Promise B is fulfilled and the fulfillment value of
    Promise A now is same as the fulfillment value of Promise B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, as Promise B gets rejected, therefore Promise A also
    gets rejected. The reason for the rejection of both the Promises is the string
    called `"Reason"`. Similarly, C gets fulfilled if D gets fulfilled. The fulfillment
    value of C and D is the string called `"Result"`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we say that "a Promise resolves with a value, or is resolved with a value,"
    it means that the executor of the Promise invokes or has invoked the `resolve`
    callback with the value.
  prefs: []
  type: TYPE_NORMAL
- en: The then(onFulfilled, onRejected) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `then()` method of a Promise object lets us do some task after a Promise
    has been fulfilled or rejected. The task can also be another event-driven or callback-based
    asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `then()` method of a Promise object takes two arguments, that is, the `onFulfilled`
    and `onRejected` callbacks. The `onFulfilled` callback is executed if the Promise
    object was fulfilled, and the `onRejected` callback is executed if the Promise
    was rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The `onRejected` callback is also executed if an exception is thrown in the
    scope of the executor. Therefore, it behaves like an exception handler, that is,
    it catches the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `onFulfilled` callback takes a parameter, that is, the fulfillment value
    of the Promise. Similarly, the `onRejected` callback takes a parameter, that is,
    the reason of rejection.
  prefs: []
  type: TYPE_NORMAL
- en: The callbacks passed to the `then()` method are executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code example to demonstrate the `then()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, if the AJAX request was successful (that is, the Promise was fulfilled),
    then the `onFulfilled` callback is executed by passing the response text as the
    argument. The `onFulfilled` callback converts the JSON string into the JavaScript
    object. The `onFulfilled` callback returns the JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programmers remove the Promise object variable, and write the preceding
    code in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This style makes the code even easier to read. All the new JavaScript APIs that
    are implemented using Promises come in this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `then()` method always returns a new `promise` object, which resolves the
    return value of the calling callback. Here is how a new `promise` object is returned
    by the `then()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `onFulfilled` callback is called and there is no return statement in
    it, then a new fulfilled Promise is created internally and returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `onFulfilled` callback is called and we return a custom Promise, then
    it internally creates and returns a new `promise` object. The new Promise object
    resolves the custom Promise object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `onFulfilled` callback is called and we return something else other than
    a custom Promise, then also a new Promise object is created internally and returned.
    The new Promise object resolves the return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we pass `null` instead of the `onFulfilled` callback, then a callback is
    created internally and replaced with the `null`. The internally created `onFulfilled`
    returns a new fulfilled `promise` object. The fulfillment value of the new `promise`
    object is same as the fulfillment value of the parent Promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `onRejected` callback is called and there is no return statement in it,
    then a new rejected Promise is created internally and returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `onRejected` callback is called and we return a custom Promise, then it internally
    creates and returns a new `promise` object. The new `promise` object resolves
    the custom `promise` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `onRejected` callback is called and we return something else other than
    a custom Promise, then also a new `promise` object is created internally and returned.
    The new `promise` object resolves the returned value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we pass `null` instead of the `onRejected` callback, or omit it, then a callback
    is created internally and is used instead. The internally created `onRejected`
    callback returns a new rejected `promise` object. The reason of rejection of the
    new `promise` object is same as the reason of rejection of the parent Promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous code example, we haven''t yet logged the retrieved data to
    console. We can chain Promises to do this. And also in the previous code, we do
    not handle the exceptions that might occur in the `onFulfilled` callback. Here
    is how we can expand the code to log data and also handle exceptions of all the
    `onFulfilled` callbacks chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we chained multiple Promises using the `then()` method
    to parse and log the response received by the executor of the first Promise of
    the chain. Here, the last `then()` method is used as an exception or error handler
    for all the `onFulfilled` methods and executors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an image that shows how the execution of multiple chained Promises
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The then(onFulfilled, onRejected) method](img/4197_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image courtesy of MDN
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add an event driven asynchronous operation to the chain,
    that is, to verify if the data displayed is correct or not. Here is how we can
    expand the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see how wrapping the AJAX operation with Promises made the code easier
    to read and write. Now the code is more understandable at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: The catch(onRejected) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `catch()` method of a `promise` object is used instead of the `then()` method,
    when we use the `then()` method only to handle errors and exceptions. There is
    nothing special about how the `catch()` method works. It's just that it makes
    the code much easier to read, as the word "catch" makes it more meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The `catch()` method just takes one argument, that is, the `onRejected` callback.
    The `onRejected` callback of the `catch()` method is invoked in the same way as
    the `onRejected` callback of the `then()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `catch()` method always returns a Promise. Here is how a new `promise`
    object is returned by the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no return statement in the `onRejected` callback, then a new fulfilled
    Promise is created internally and returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we return a custom Promise, then it internally creates and returns a new
    `promise` object. The new `promise` object resolves the custom `promise` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we return something else other than a custom Promise in the `onRejected`
    callback, then also a new `promise` object is created internally and returned.
    The new `promise` object resolves the returned value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we pass `null` instead of the `onRejected` callback, or omit it, then a callback
    is created internally and used instead. The internally created `onRejected` callback
    returns a rejected `promise` object. The reason for the rejection of the new `promise`
    object is same as the reason for the rejection of a parent `promise` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `promise` object to which `catch()` is called gets fulfilled, then the
    `catch()` method simply returns a new fulfilled `promise` object and ignores the
    `onRejected` callback. The fulfillment value of the new `promise` object is same
    as the fulfillment value of the parent Promise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the `catch()` method, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be rewritten in this way using the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These two code snippets work exactly in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the AJAX code example by replacing the last chained `then()`
    method with the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now the code is even easier to read at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise.resolve(value) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `resolve()` method of the `Promise` object takes a value and returns a `promise`
    object that resolves the passed value.
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve()` method is basically used to convert a value to an `promise`
    object. It is useful when you find yourself with a value that may or may not be
    a Promise, but you want to use it as a Promise. For example, the jQuery Promises
    have different interfaces than the ES6 Promises. Therefore, you can use the `resolve()`
    method to convert the jQuery Promises into the ES6 Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code example that demonstrates how to use the `resolve()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.reject(value) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reject()` method of the `Promise` object takes a value and returns a rejected
    `promise` object with the passed value as the reason.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `Promise.resolve()` method, the `reject()` method is used for debugging
    purposes and not for converting values into Promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code example that demonstrates how to use the `reject()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.all(iterable) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `all()` method of the `Promise` object takes an iterable object as an argument
    and returns a Promise that fulfills when all of the Promises in the iterable object
    have been fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful when we want to execute some task after some asynchronous
    operations have finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code example which demonstrates how to use the `Promise.all()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the iterable object contains a value that is not a `promise` object, then
    it's converted to the Promise object using the `Promise.resolve()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case any of the passed Promises get rejected, then the `Promise.all()` method
    immediately returns a new rejected Promise for the same reason as the rejected
    passed Promise. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Promise.race(iterable) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The the `race()` method of the `Promise` object takes an iterable object as
    the argument and returns a Promise that fulfills or rejects as soon as one of
    the Promises in the iterable object is fulfilled or rejected, with the fulfillment
    value or reason from that Promise.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, the `race()` method is used to race between Promises and
    see which one finishes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is code example that shows how to use the `race()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript APIs based on Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new asynchronous JavaScript APIs are now based on the Promise pattern instead
    of events and callbacks. And the new versions of the old JavaScript APIs are now
    based on Promises.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the old version of the Battery status API and the Web Cryptography
    API were based on event, but the new versions of these APIs are purely implemented
    using Promises. Let's see an overview of these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Battery Status API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Battery Status API provides us the battery''s current charge level and
    charging status. Here is a code example of the new Battery Status API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `getBattery()` method of the `navigator` object returns a fulfilled Promise
    if it has successfully retrieved the battery information. Otherwise, it returns
    a rejected Promise.
  prefs: []
  type: TYPE_NORMAL
- en: If the Promise is fulfilled, then the fulfillment value is an object holding
    the battery information. The `level` property of the fulfillment value represents
    the level of charge remaining.
  prefs: []
  type: TYPE_NORMAL
- en: The Web Cryptography API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Web Cryptography API lets us do hashing, signature generation and verification,
    encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example of the new Web Cryptography API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we will find the SHA-256 hash value of a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.crypto.subtle.digest` method takes an array buffer of a string and
    hash the algorithm name, and returns a Promise object. If it has successfully
    produced the hashes value, then it returns a fulfilled Promise and the fulfillment
    value is an array buffer representing the hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how JavaScript executes the asynchronous code. We
    learned about the different patterns of writing asynchronous code. We saw how
    Promises make it easier to read and write the asynchronous code, and how to use
    the ES6 Promise API. We also saw some JavaScript APIs that are based on Promises.
    Overall, the chapter aimed at explaining Promises, their benefits, and how to
    use APIs that are based on them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about ES6 Reflect API and its uses.
  prefs: []
  type: TYPE_NORMAL
