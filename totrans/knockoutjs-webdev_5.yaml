- en: Chapter 5. The Joy of Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 模板的乐趣
- en: 'A quick walk through history tells the story of how server-side code turned
    templates into magic. Data mixed with these templates and returned meaningful
    HTML for the client. These templates dynamically adapted to produce flexible and
    functional custom HTML pages. Along came AJAX and robbed the developer of this
    powerful approach to coding. But wait, templates are back again! Now they run
    at the client side. This chapter will teach you how to create the magic at the
    client side with Knockout. In this chapter, we will focus on:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾历史，讲述了服务器端代码如何将模板变成魔法。数据与这些模板混合，并为客户端返回有意义的HTML。这些模板动态适应，产生灵活且功能强大的自定义HTML页面。随着AJAX的到来，开发者失去了这种强大的编码方法。但是等等，模板又回来了！现在它们在客户端运行。本章将教你如何使用Knockout在客户端创建魔法。在本章中，我们将关注：
- en: Native templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生模板
- en: Enhanced collection handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的集合处理
- en: Render events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染事件
- en: Third-party templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方模板
- en: Awesome template options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊叹的模板选项
- en: Knockout is not just about two-way binding. Done right, it is about more elegant
    and sustainable code. We will learn how to come around for another layer of making
    our page creation simpler as we learn to use the power of templating in KnockoutJS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout不仅仅是关于双向绑定。如果做得正确，它关乎更优雅和可持续的代码。当我们学习如何利用KnockoutJS的模板功能时，我们将学习如何通过另一个层次使页面创建更加简单。
- en: Native templates
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生模板
- en: Templates are patterns for how we merge data and the stuff the data fits into.
    The most popular form of templates on computers in the early days was something
    we called a mail merge. Programs like Microsoft Word would use a mail merge document
    and a data file, and merge them together. The original purpose was for printing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是我们合并数据和数据适合放入的东西的模式。在计算机的早期，最流行的模板形式是我们称之为邮件合并的东西。像Microsoft Word这样的程序会使用邮件合并文档和数据文件，并将它们合并在一起。原始目的是用于打印。
- en: Over the time, we shifted to using this same type of technology to do web pages.
    When a user would go to a website and request a web page, the servers started
    getting smarter. The data was mixed into a template and the merged result was
    returned to the browser as HTML. This was an amazing game changer for shopping
    sites and other sites where the basic page was the same. This is why we call these
    pieces of code templates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们转向使用这种相同类型的技术来制作网页。当用户访问一个网站并请求一个网页时，服务器开始变得更聪明。数据被混合到模板中，合并后的结果以HTML的形式返回给浏览器。这对于购物网站和其他基本页面相同的网站来说是一个惊人的变革。这就是为什么我们把这些代码片段称为模板。
- en: One way to look at this is to think about when people decorate houses. We have
    things we call stencils. While the stencil defines how the shape of the result
    will look, it does not control what color you paint something with. If you have
    an apple stencil you can paint a red apple, a green Granny Smith style apple,
    a yellow Golden Delicious apple, or go off standard and have a purple and yellow
    striped apple. The stencil only controls the container the content will be placed
    in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一种看待这个问题的方法是可以想到人们装饰房子的时候。我们有东西叫做模板。虽然模板定义了结果形状的样式，但它并不控制你用什么颜色来画东西。如果你有一个苹果模板，你可以画一个红色的苹果，一个绿色的Granny
    Smith风格的苹果，一个黄色的Golden Delicious苹果，或者偏离标准，画一个紫色和黄色的条纹苹果。模板只控制内容将被放置在内的容器。
- en: In the same fashion, web templates frame the content. Well, mostly. You see,
    this is a program and it's a bit smarter than a wall painting stencil; so we can
    add in conditional logic and do things like repeat information or conditionally
    choose if we want to show any information at all. This is the power of a template.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，网页模板定义了内容。嗯，大多数情况下是这样的。你看，这是一个程序，它比墙画模板要聪明一些；因此，我们可以添加条件逻辑，做一些像重复信息或条件性地选择是否显示任何信息的事情。这就是模板的力量。
- en: 'We will have a bit more complex data set in this chapter because we want to
    get ourselves in touch with more real-life site pages, which we will be using
    outside this book. Here is the code section for this page. Not all the data will
    be used here. We will expand on the data as we progress through the chapter, so
    just focus on the stuff we actually use:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将拥有一个稍微复杂一些的数据集，因为我们想让自己接触更多现实生活中的网站页面，这些页面我们将在这本书之外使用。以下是本页面的代码部分。这里不会使用所有数据。随着我们通过本章的进展，我们将扩展数据，所以请只关注我们实际使用的内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You probably guessed, looking at our data, that we will be showing a pseudo,
    meaning fake in this case but pseudo sounds so much nicer, seminar page. One thing
    you should realize is that data will come in all kinds of forms. You may need
    to arrange data before it works best for your pages. Don't think there is any
    strict pattern here that you have to follow. If you need to rearrange your data
    that is part of any template approach to code, you can do it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，看着我们的数据，我们将展示一个伪的，在这个情况下意味着假的，但“伪”听起来要顺耳得多，研讨会页面。你应该意识到的是，数据将以各种形式出现。你可能需要调整数据，使其最适合你的页面。不要认为这里有任何严格的模式你必须遵循。如果你需要重新排列你的数据，这是任何模板方法的一部分，你可以做到。
- en: Now, I said this section was going to be about native templates. This means
    you are going to create these templates in, the standard Knockout way of creating
    templates. This is what you should do most of the time. We will show later how
    to integrate external template libraries; but let me say right up front that in
    the real world this is a very rare approach to how developers use templates on
    Knockout pages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我说这个部分将关于原生模板。这意味着你将按照Knockout创建模板的标准方式创建这些模板。这应该是你大多数时候应该做的事情。我们稍后会展示如何集成外部模板库；但让我一开始就明确说，在现实世界中，这是开发者如何在Knockout页面上使用模板的一种非常罕见的方法。
- en: Knockout follows the approach most browser-side templates are using. The actual
    template is nested inside a set of script tags. If you are new to this and are
    wondering why there is no JavaScript error when doing this, let me explain. In
    days past Microsoft Internet Explorer used a script called VBScript. Most other
    browsers used a script called JavaScript. Today we are seeing some other scripts
    come out on Internet Explorer again. TypeScript is an example, but it seems to
    require Visual Studio to function correctly and does not work as a native script;
    so staying with JavaScript for portability seems the way to go. These tags created
    a way to declare the type of content within them. If the content is not recognized,
    it is essentially ignored.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout遵循大多数浏览器端模板所采用的方法。实际的模板嵌套在一系列脚本标签内。如果你是新手，想知道为什么这样做时没有JavaScript错误，让我来解释一下。过去，微软的Internet
    Explorer使用一种名为VBScript的脚本。大多数其他浏览器使用一种名为JavaScript的脚本。今天，我们再次看到一些其他脚本出现在Internet
    Explorer上。TypeScript是一个例子，但它似乎需要Visual Studio才能正确运行，并且不能作为原生脚本运行；因此，为了便携性，继续使用JavaScript似乎是正确的选择。这些标签创建了一种声明它们内部内容类型的方法。如果内容不被识别，它基本上会被忽略。
- en: When the script is ignored, it means there is no DOM created from the markup
    code. JavaScript can still see this code though. So by declaring a different type
    attribute we are able to convert nested HTML into actionable code to use for our
    templates. This also allows us to actually use the familiar HTML scripting. Many
    people use something like jQuery to create content but it is nowhere near as elegant
    as a template approach. In fact, for a season, jQuery had its own templating.
    It pulled back with the reasoning that templates were not part of its solution
    focus.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本被忽略时，这意味着从标记代码中没有创建DOM。尽管如此，JavaScript仍然可以看到这段代码。因此，通过声明不同的类型属性，我们能够将嵌套HTML转换为可操作的代码，用于我们的模板。这也允许我们实际上使用熟悉的HTML脚本。许多人使用类似jQuery的东西来创建内容，但它远不如模板方法优雅。事实上，在一段时间内，jQuery有自己的模板。它撤回的理由是模板不是其解决方案重点的一部分。
- en: Here is the first template we will use for our page. We will need to include
    the Knockout and mapping library for the code example here. The mapping library
    is not needed to do the template code. We are using it just to make our examples
    simpler. This makes for a focused approach on the subject and less coding for
    you as you go through the book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将用于我们页面的第一个模板。我们需要在这里包含Knockout和映射库的代码示例。映射库不是做模板代码所必需的。我们只是用它来使我们的示例更简单。这使得对主题的关注更加集中，你在阅读本书时需要编写的代码也更少。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will notice that we put an `id` attribute on our template code segment.
    Each template will need a unique ID to work properly. Inside our template this
    looks pretty identical to the Knockout code we have been seeing all through this
    book. This is one of the great things about Knockout templating. It builds on
    what you already know and use with hardly any exceptions. An important consideration
    when doing templates is that the template should come before the actual call to
    binding the ViewModel. Following are the two external libraries we will include
    to make this page work. The `script` tag can come before or after them. It only
    needs to come before the binding call to prevent issues.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在模板代码段上放置了一个`id`属性。每个模板都需要一个唯一的ID才能正常工作。在我们的模板中，这看起来与我们在整本书中看到的Knockout代码非常相似。这是Knockout模板的一个优点。它建立在您已经知道并使用的知识上，几乎没有例外。在制作模板时，一个重要的考虑因素是模板应该在绑定ViewModel的实际调用之前。以下是我们将包含的两个外部库，以使这个页面工作。`script`标签可以在这之前或之后。它只需要在绑定调用之前，以防止问题。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last thing we need to do, to use template binding, is place a call to the
    template within the code. A template is similar to the wall stencil. You get to
    choose what you put inside the pattern. You get to choose what is merged into
    the template. This means you have to have data that matches the template. In this
    template, you need to pass in a ViewModel structure that contains structure items
    for name and seating. Here is a call to the template with the data declared:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事，为了使用模板绑定，是在代码中调用模板。模板类似于墙壁模板。你可以选择在图案中放置什么。你可以选择合并到模板中的内容。这意味着你必须有与模板匹配的数据。在这个模板中，你需要传递一个包含姓名和座位结构项的ViewModel结构。以下是带有声明数据的模板调用：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have a template you want to use that doesn''t have any data merges,
    you could reuse it on the page. I am not sure why you would want to do that but
    it is possible. Notice that with passing data to the template we are using the
    classic JSON format approach to what gets passed in. Let''s modify the preceding
    code just a bit farther and have two templates with different data passed in,
    and a little markup near the templates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个没有数据合并的模板想要使用，你可以在页面上重用它。我不确定你为什么要这样做，但这是可能的。注意，在将数据传递给模板时，我们使用的是经典的JSON格式方法来传递内容。让我们稍微修改一下前面的代码，并使用两个传递不同数据的模板，以及模板附近的一点点标记：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that we have used our template twice in a row with the only difference
    being they have a different ViewModel structure passed through to them. You should
    also notice that the template name is the value of the `id` attribute in our scripted
    template declaration. Here is the resulting screenshot for this template:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们连续两次使用了我们的模板，唯一的区别是它们传递给模板的ViewModel结构不同。你也应该注意到，模板名称是我们脚本模板声明中`id`属性的值。以下是该模板的结果截图：
- en: '![Native templates](img/1028OS_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![原生模板](img/1028OS_05_01.jpg)'
- en: Since name and seating are variables of the structure, the scope is automatically
    understood by the template merging. It is a common practice to call the merging
    of the data with the template rendering, if you hear the term.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于姓名和座位是结构中的变量，模板合并时会自动理解作用域。如果你听到这个术语，将数据与模板渲染合并是一种常见的做法。
- en: 'The actual data we merged to our template, before being inserted into the ViewModel,
    is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们合并到模板中的实际数据，在插入到ViewModel之前，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Well, we can now see our data being mixed with the template fast and easy.
    If we go to our browser developer tools to reach the console, we can input the
    following command. We want to modify the data inside our ViewModel to see if the
    binding has an instant effect on our View:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们现在可以快速轻松地看到我们的数据与模板混合在一起。如果我们进入浏览器开发者工具中的控制台，我们可以输入以下命令。我们想要修改ViewModel内的数据，看看绑定是否会对我们的视图产生即时影响：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we do this, notice the template smartly and immediately updates the content.
    So we see our data binding is locked into templates just like the binding outside
    of templates. There are different templates out in the open source market. What
    makes Knockout powerful is that it binds the rendered content to regenerate when
    the connected data changes. There have been a few comparisons of frameworks, and
    Knockout also performed better than others in terms of speed for this type of
    functionality. So, unless you are doing something incredibly large, having this
    run live should not greatly affect your user experience. With that said, don''t
    forget to test performance as that is always the best practice. Here is the updated
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，注意模板会智能且立即更新内容。因此，我们看到我们的数据绑定已经锁定在模板中，就像模板外的绑定一样。开源市场上有很多不同的模板。Knockout之所以强大，是因为它将渲染的内容绑定到当连接的数据发生变化时重新生成。已经有一些框架的比较，Knockout在这方面也表现优于其他框架。所以，除非你正在做非常庞大的事情，否则让这个运行实时不会对你的用户体验产生很大影响。话虽如此，别忘了测试性能，因为这始终是最佳实践。以下是更新的截图：
- en: '![Native templates](img/1028OS_05_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![原生模板](img/1028OS_05_02.jpg)'
- en: 'Well, where are Pete, or Peter at the moment, and Re-Pete guests? That is our
    next block of code. We already have the data but the part of the data we will
    be using is this segment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在皮特（Pete）或彼得（Peter）在哪里，还有Re-Pete的嘉宾们？这是我们接下来的代码块。我们已经有了数据，但我们将要使用的数据部分是这样的：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the code for the display and the template that binds to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是显示和绑定到它的模板的代码：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will need another template to demonstrate the merging of a different set
    of data. Here is the code for that template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个模板来演示合并不同数据集。以下是该模板的代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that our first template used a variable called `name`. In this template,
    we are also using a variable called `name`. Each template, when rendered, will
    look just at the data passed to it to merge the contents. Here is the screenshot
    from the template rendered to the page in this example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的第一个模板使用了一个名为`name`的变量。在这个模板中，我们也在使用一个名为`name`的变量。每个模板在渲染时，只会查看传递给它的数据以合并内容。以下是本例中模板渲染到页面上的截图：
- en: '![Native templates](img/1028OS_05_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![原生模板](img/1028OS_05_03.jpg)'
- en: There is no basic limit to the number of templates you can use on a page or
    the amount of data that can be merged. We are not going to assume that some developer
    or some client request could not go over the top. Yet, browsers and computers
    are so fast that these issues will rarely be something to focus on. The only time
    they may become an issue is if you are doing something complex with a variable
    that is in your ViewModel, and it is based on a computed value with complex logic.
    But I have not found a case so far where it is an issue in work, my company has
    produced for our clients.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上使用模板的数量或可以合并的数据量没有基本限制。我们不会假设某个开发者或客户端请求可能超过极限。然而，浏览器和计算机如此之快，这些问题很少会成为关注的焦点。唯一可能成为问题的情况是，如果你正在使用ViewModel中的变量进行复杂操作，而这个变量基于复杂的逻辑计算值。但到目前为止，我没有在我的公司为我们的客户制作的工作中找到这样的案例。
- en: Enhanced collection handling
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强型收集处理
- en: In our first segment, native templates, we focused on single sets of data. In
    JavaScript, we often have collections of data stored in arrays. We will be including
    an example here to show how to use templates stored in arrays.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个部分，原生模板中，我们关注单一数据集。在JavaScript中，我们经常将数据存储在数组中。我们在这里将包括一个示例，以展示如何使用存储在数组中的模板。
- en: 'We can copy the data from our last example page to this page. We will be using
    more of the structure this time around. We will start by focusing on the speakers.
    This array contains structured items for each speaker. The code section of our
    `script` tag should look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上一个示例页面复制数据到这个页面。这次我们将使用更多的结构。我们将首先关注演讲者。这个数组包含每个演讲者的结构化项。我们的`script`标签的代码部分应该看起来像这样：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you think this looks basically the same as the last example of code, you
    are right. It will change soon, but we are looking to make a point here. Arrays
    and non-arrays are not coded differently for routine binding functionality. Here
    is the segment of data that we will be using for this part of the exercise:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这看起来基本上和上一个代码示例相同，你是正确的。它很快就会改变，但我们在这里想要表达的是，数组和非数组在常规绑定功能上没有不同的编码。以下是我们将用于这部分练习的数据段：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will be mixing this data with the following template structure and it will
    be enhanced as we go:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个数据与以下模板结构混合，并且随着我们的进行，它将会得到增强：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we see the name and bio will be mixed into our page, pulling the name
    and bio from the data of each collection record. Here is the template call we
    will use on our page:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到名称和简介将会混合到我们的页面中，从每个集合记录的数据中提取名称和简介。这是我们页面上将要使用的模板调用：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time we are using foreach rather than data in our template code. When
    using data it will pass in the entire data structure once. Using foreach will
    pass in the data structure as one collection item at a time. The template actually
    has no awareness of how the data is being passed to it. This is controlled by
    how we call the template. Here is the result we will see when run the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在模板代码中使用foreach而不是data。当使用data时，它将一次传递整个数据结构。使用foreach将一次传递数据结构作为一个集合项。模板实际上对数据是如何传递给它的没有意识。这是由我们调用模板的方式控制的。以下是运行代码时我们将看到的结果：
- en: '![Enhanced collection handling](img/1028OS_05_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![增强型集合处理](img/1028OS_05_04.jpg)'
- en: Well, that was collection handling; but this section is called enhanced collection
    handling. We are going to go a little deeper and while using Knockout, we are
    still going to keep things pretty simple and the code very light.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那是对集合的处理；但这一节被称为增强型集合处理。我们将深入探讨，尽管使用Knockout，我们仍将保持事情简单，代码轻量。
- en: 'As you can see in the following code, nested inside each speaker record, there
    is another simple collection of speaker skills. Here is the first item in the
    collection for clarity:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，在每一个演讲者记录中嵌套的还有另一个简单的演讲者技能集合。为了清晰起见，以下是集合中的第一个项目：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We see that John Doe has skills in using jQuery, KnockoutJS, SammyJS, and NodeJS.
    This is a JavaScript dude! He probably has other talents that he didn''t list,
    but we can only show the ones he gave us, of course. How do we go about doing
    this? Well, one of the sweet powers of Knockout templates is the ability to nest
    other template calls inside templates. Here is the new template we will add to
    show the skills:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，John Doe在jQuery、KnockoutJS、SammyJS和NodeJS方面有技能。这是一个JavaScript高手！他可能还有其他未列出的才能，但我们只能展示他给出的那些，当然。我们如何做到这一点？嗯，Knockout模板的一个美妙功能是能够在模板中嵌套其他模板调用。以下是我们将添加以显示技能的新模板：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will obviously need to modify the primary template to have this work. We
    are using an HTML list to show the skills, so we will need to nest the list in
    a list wrapper tag. We are also going to want to add a heading to clarify what
    this list represents. Here is our modified template with the new code highlighted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要修改主模板以使其工作。我们使用HTML列表来显示技能，因此我们需要在列表包装标签中嵌套列表。我们还想添加一个标题来明确这个列表代表的内容。以下是我们的修改后的模板，其中新代码被突出显示：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that there is another foreach template binding, as the data being passed
    in is a collection. The last time it was a collection of structures and this time
    it is a collection of simple values. It does not matter to Knockout what type
    of items exist in the collection. It needs to be a collection or rather an array
    you designate when using the `foreach` passing of data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个foreach模板绑定，因为传入的数据是一个集合。上一次它是一个结构集合，这次它是一个简单值集合。Knockout对集合中存在什么类型的项并不关心。它需要是一个集合，或者更确切地说，当你使用`foreach`传递数据时，你指定的数组。
- en: The original call to the speaker template does need to be modified. Here is
    what our first speaker record looks like now. Of course, all the other records
    also have the added skills, but we wanted to conserve space; so please make sure
    you are doing all these examples in the browser, with code you entered by hand,
    to maximize your learning experience.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对演讲者模板的原始调用确实需要修改。现在我们的第一个演讲者记录看起来是这样的。当然，所有其他记录也都有添加的技能，但我们想节省空间；所以请确保你在浏览器中做所有这些示例，使用你亲手输入的代码，以最大限度地提高你的学习体验。
- en: '![Enhanced collection handling](img/1028OS_05_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![增强型集合处理](img/1028OS_05_05.jpg)'
- en: 'This is pretty good but it is not good enough. We promised to cover enhanced
    collection template techniques and there is one more thing we want to show you.
    Nesting is the simplest form of enhancing our collection templates. Now, we want
    to show you how to do some relational data handling with the session records.
    Here is the session records data segment we will be mixing in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经相当不错了，但还不够好。我们承诺要介绍增强的集合模板技术，还有一件事我们想展示给你。嵌套是增强我们的集合模板的最简单形式。现在，我们想展示如何使用会话记录进行一些关系数据处理。以下是我们将混合的会话记录数据段：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should have noted that the `speakerId` attribute is part of this data collection.
    This is how we will tie the records in. It will take a minor amount of code to
    tie this in correctly, but it truly is a minor amount of code. We will need to
    add the following highlighted code to make this work. We have added this code
    between our mapping and binding:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经注意到`speakerId`属性是数据收集的一部分。这就是我们将如何关联记录的方式。正确关联这些记录只需要少量代码，但这确实只是少量代码。我们需要添加以下高亮代码以使此功能正常工作。我们在映射和绑定之间添加了此代码：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time we are not using a collection to pass to the template; well, not a
    bound array collection. We will be calling the data by triggering a function that
    will filter and return an array collection. This means that as long as we are
    passing an array when the call is made, the template call does not care.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不是使用集合传递给模板；好吧，不是一个绑定数组集合。我们将通过触发一个函数来调用数据，该函数将过滤并返回一个数组集合。这意味着只要我们在调用时传递一个数组，模板调用就不关心。
- en: 'We are also using the `arrayMap` method of our Knockout utilities to filter
    data versus filter down. Notice that we call by designation the ViewModel as the
    first argument of the filter. It will then pass in each session item one at a
    time to see if the item should be placed in the filtered collection. Then, it
    will return the results. Pretty simple code. Oh, yes, it does receive the `speakerId`
    attribute as an argument when calling. That is key to making things work. Take
    a look at the following `script` code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Knockout工具的`arrayMap`方法来过滤数据与筛选。注意，我们通过指定将ViewModel作为筛选的第一个参数。然后，它将逐个传递每个会话项以查看该项是否应放置在筛选集合中。然后，它将返回结果。代码很简单。哦，是的，它在调用时确实接收了`speakerId`属性作为参数。这是使事情正常工作的关键。看看下面的`script`代码：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we have used the `$root` designation to call our method. This is
    because we wanted to remind you that because this is a nested template, we need
    to make sure our method call is at the right level. The `$root` designation allows
    you to address the actual root level of the ViewModel. The ID that is passed in
    matches the speaker data item. The `speakerSessions` code we added will then match
    that ID with the records that have the same ID. If there is more than one session,
    it will show them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`$root`指定来调用我们的方法。这是因为我们想要提醒你，由于这是一个嵌套模板，我们需要确保我们的方法调用处于正确的级别。`$root`指定允许你访问ViewModel的实际根级别。传入的ID与演讲者数据项匹配。我们添加的`speakerSessions`代码将然后与具有相同ID的记录匹配。如果有多个会话，它将显示它们。
- en: 'We will need to also include a nested call to the sessions in our primary template
    for this to work. Again, we will not need to modify the original call to the speakers.
    Here is the code with the new part highlighted:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此功能正常工作，我们还需要在我们的主模板中包含对会话的嵌套调用。同样，我们不需要修改对演讲者的原始调用。以下是带有新部分高亮的代码：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Take a moment and look at the code; discover the difference between the call
    to our additional nested template and the first nested template. You will see
    that in our additional method we did not pass in the data using the `foreach`
    designator. This time we used the data designator to pass in our collection. Both
    of these are valid approaches, but we wanted to give you examples of doing both
    for your experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空看看代码；发现我们调用额外嵌套模板和第一个嵌套模板之间的区别。你会看到在我们的额外方法中，我们没有使用`foreach`指定符传递数据。这次我们使用了数据指定符来传递我们的集合。这两种方法都是有效的，但我们想给你提供两种方法的示例，以供你参考。
- en: 'Here is the resulting first record (again, not showing everything to save space).
    Notice how this time the nested template is handling the `foreach` designator
    using classic binding for Knockout:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果的第一条记录（再次，为了节省空间，没有显示所有内容）。注意这次嵌套模板是如何使用Knockout的经典绑定来处理`foreach`指定符的：
- en: '![Enhanced collection handling](img/1028OS_05_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![增强集合处理](img/1028OS_05_06.jpg)'
- en: Render event handling
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染事件处理
- en: One of the things you grow to appreciate as your experience grows is the ability
    to do event handling. I have not needed this functionality yet with Knockout code
    in the live sites we have built; but it is awesome to know it is there if we do
    need it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着经验的增长，你越来越欣赏的是处理事件的能力。在我们构建的现场网站中，我还没有使用Knockout代码需要这个功能；但知道它在那里，如果需要的话，是非常棒的。
- en: 'We will be using the following code this time. We will use a different data
    set for this example to keep our code simpler and focus on just this section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将使用以下代码。我们将为这个例子使用不同的数据集，以使我们的代码更简单，并专注于这一部分：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This also tells us that we will not always consider the mapping to be the best
    method. It is usually best in the early prototyping of pages to use mapping as
    it speeds up the creation of the stuff we need. Then, we migrate, if needed, to
    a non-mapped ViewModel when appropriate, to maximize productivity. If your experience
    varies then follow your instinct and use the approach that works best in your
    group.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这也告诉我们，我们并不总是认为映射是最好的方法。在页面的早期原型设计阶段，通常最好使用映射，因为它可以加快所需内容的创建速度。然后，如果需要，我们可以迁移到一个非映射的ViewModel，以最大化生产力。如果你的经验有所不同，那么就跟随你的直觉，使用最适合你团队的方法。
- en: The data and binding are obvious by now. The function we added will use jQuery
    to perform a wrap of each designated item, rendered by Knockout with italics and
    in green. One pragmatic use I have thought of for this is a log of a unit test
    to make sure the output is what is expected. Regardless of what you use it for,
    it will show you a couple of things.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，数据和绑定都很明显。我们添加的函数将使用jQuery对每个指定的项目进行包装，这些项目由Knockout以斜体和绿色渲染。我想到的这种实用用途之一是单元测试日志，以确保输出符合预期。无论你用它做什么，它都会向你展示一些事情。
- en: First, we are not totally disconnected from jQuery while using Knockout. There
    is a way I like to describe this to people who are anxious that using Knockout
    will eliminate the use of jQuery. Yes, I remember how hard JavaScript was for
    most people before jQuery. They both have different strengths. Knockout shines
    at data binding and jQuery shines at AJAX communications between the client and
    the server, as well as at DOM manipulation. Together, they make a great team with
    each having areas and different challenges that they are best suited to meet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在使用Knockout时并没有完全与jQuery断绝联系。有一种我喜欢向那些担心使用Knockout会消除jQuery使用的人描述的方法。是的，我记得在jQuery出现之前，JavaScript对大多数人来说有多难。它们都有不同的优势。Knockout在数据绑定方面表现出色，而jQuery在客户端和服务器之间的AJAX通信以及DOM操作方面表现出色。它们一起组成了一支伟大的团队，每个成员都有各自的优势和不同的挑战，最适合解决。
- en: 'Here are the templates we will use in this example. We will be using nested
    templates again. This is the root template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将在本例中使用的模板。我们还将再次使用嵌套模板。这是根模板：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have called the months as nested template calls. While we could have just
    rendered all this with regular tags, it would not have shown us how the event
    handlers work. Look closely at the nested data binding in the template call and
    you will see a setting for `afterRender`. You will see it calls the function we
    added to our code. Since it is in the root template, it will not need to use the
    `$root` designator to correctly call the function method to handle the render
    event. Here is the nested template that it will call to render the month items:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将月份称为嵌套模板调用。虽然我们可以只用常规标签来渲染所有这些内容，但这不会显示给我们事件处理程序是如何工作的。仔细观察模板调用中的嵌套数据绑定，你会看到一个`afterRender`的设置。你会看到它调用了我们添加到代码中的函数。由于它位于根模板中，因此它不需要使用`$root`指示符来正确调用函数方法以处理渲染事件。以下是它将调用来渲染月份项的嵌套模板：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is something special I wanted you to see here also. Noticed that we use
    the variable `season.name` in this template. We were able to address the parent''s
    data structure from the nested template. The guys who wrote the Knockout library
    had many awesome moments putting things like this together. So, where is the season
    declared? Look at the actual call to the root template:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想要你注意这里的一些特别之处。注意我们在模板中使用了变量`season.name`。我们能够从嵌套模板中访问父级的数据结构。编写Knockout库的那些人将许多这样的东西组合在一起，真是令人印象深刻。那么，季节是在哪里声明的呢？看看对根模板的实际调用：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will see an `as` designator with the `season` string declared as the alias
    of the structure. So, we could use `$data` in the first level of the template,
    but it would not work right to use `$data` in the second level of the template.
    By declaring the alias `season`, we can use that in the nested child, and it will
    properly target the right data set. Awesome!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个 `as` 指示符，其中 `season` 字符串被声明为结构的别名。因此，我们可以在模板的第一级使用 `$data`，但在模板的第二级使用
    `$data` 就不会正确工作。通过声明别名 `season`，我们可以在嵌套子项中使用它，并且它将正确地针对正确的数据集。太棒了！
- en: Now, when we look at our results we get things properly handled and rendered.
    I admit that while I have used jQuery since just before Version 1.2, my history
    with Knockout was delayed more than that. If you are having issues with earlier
    versions that may not support every feature we are teaching here, jump into the
    online group. You will find it listed at the Knockout site. The community is awesome
    in how they support each other there.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们查看我们的结果时，我们得到了正确处理和渲染的内容。我承认，虽然我从 jQuery 1.2 版本之前就开始使用了，但我的 Knockout 历史比这还要晚。如果你在使用早期版本时遇到问题，可能不支持我们在这里教授的每个功能，请加入在线小组。你将在
    Knockout 网站上找到它。那里的社区在相互支持方面非常棒。
- en: 'Here is a screenshot of the results of this code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这段代码的结果截图：
- en: '![Render event handling](img/1028OS_05_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![渲染事件处理](img/1028OS_05_07.jpg)'
- en: Third-party template options
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方模板选项
- en: There was a time when jQuery was exploring creating its own templates, but that
    effort did not mature to a full release. So we will not cover that template here.
    The most popular template used with Knockout seems to have been **Underscore**
    as a result. Personally, before jumping into Knockout my template of choice was,
    well is, **Handlebars**. Yet, I have enjoyed Knockout templates so much that it
    has never compelled me to go as far as integrating Handlebars with Knockout yet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，jQuery 在探索创建自己的模板，但这项努力并没有成熟到完整发布的程度。因此，我们在这里不会介绍那个模板。结果是，与 Knockout
    一起使用最流行的模板似乎是 **Underscore**。就我个人而言，在接触 Knockout 之前，我选择的模板是，嗯，是 **Handlebars**。然而，我非常喜欢
    Knockout 模板，以至于它从未让我有动力将 Handlebars 与 Knockout 集成。
- en: I have played around with Underscore just to get a taste of why others use Underscore
    with Knockout; to see if I was missing something. It came down to a developer
    style difference that some developers like to use the Underscore style of template
    coding and others prefer to use native Knockout templates. In this section, we
    will be honoring the Underscore fans' approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是玩了一下 Underscore，只是为了尝尝为什么其他人会用 Underscore 与 Knockout 一起使用；看看我是否遗漏了什么。这归结为一个开发者风格差异，一些开发者喜欢使用
    Underscore 风格的模板编码，而其他人则更喜欢使用原生的 Knockout 模板。在本节中，我们将尊重 Underscore 粉丝的方法。
- en: We suggest some copy and paste from the `done` directory of the example code
    for this to prevent typos. If you are awesome enough, just go ahead and type this
    in though. Remember again, your examples should be going into the `do` folder
    for each chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议从示例代码的 `done` 目录中复制粘贴一些内容，以防止出现错误。如果你足够厉害，可以直接输入这些内容。再次提醒，你的示例应该放入每个章节的
    `do` 文件夹中。
- en: 'Here is our base code for this example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个示例的基础代码：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is our code for calling the template:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们调用模板的代码：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, here is our template. You should notice that the style of the template
    is different here. If you are accustomed to Underscore, this will work great.
    If you are not using Underscore you should not assume the code in this template
    will be an example of native Knockout templates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我们的模板。你应该注意到这里的模板风格不同。如果你习惯于 Underscore，这将工作得很好。如果你没有使用 Underscore，你不应该假设这个模板中的代码是原生
    Knockout 模板的示例。
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This screenshot shows that we will produce the following results. Wait! There
    is one piece missing, but we did want to show you the results first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了我们将产生的以下结果。等等！有一块缺失，但我们确实想先展示一下结果。
- en: '![Third-party template options](img/1028OS_05_08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![第三方模板选项](img/1028OS_05_08.jpg)'
- en: As far as the end user is concerned, there is no difference. Using third-party
    templates is for the benefit of the developers. Well, if you are doing a contract
    that requires the use of Underscore, that would be another benefit to this approach
    as it would let you do the job with Underscore and Knockout, if permitted otherwise.
    It might be good to verify that in advance just to make sure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户来说，没有任何区别。使用第三方模板是为了开发者的利益。嗯，如果你签订的合同需要使用 Underscore，那么这种方法将带来另一个好处，因为它将允许你在允许的情况下使用
    Underscore 和 Knockout 完成工作。提前验证这一点可能是个好主意，以确保一切顺利。
- en: Modified template handling with Underscore
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Underscore 修改模板处理
- en: 'Let me express my gratitude again and say thanks to the Knockout community
    on Google groups. This, in addition to several sites online, is where I learned
    how to do template handling. The technique allows us to manage the template engine
    and pass the results out to process through the Underscore engine. The key code
    is highlighted as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再表达一次我的感激之情，并向 Google 群组中的 Knockout 社区表示感谢。除了几个在线网站外，这里是我学习如何处理模板的地方。这项技术使我们能够管理模板引擎，并将结果传递给
    Underscore 引擎进行处理。关键代码如下所示：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first highlighted section passes the code and data into the Underscore template
    handler to be rendered by Underscore. Underscore does produce some results that
    need to be cleaned up to work right here, so the second highlighted section is
    there to clean up the rendered code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个突出显示的部分将代码和数据传递给 Underscore 模板处理器以由 Underscore 渲染。Underscore 确实产生了一些需要清理才能正确工作的结果，因此第二个突出显示的部分用于清理渲染的代码。
- en: Live updates and the subscribe method in Knockout
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knockout 中的实时更新和订阅方法
- en: 'We are going to create the ability to add items with an edit form on the screen.
    Here is the markup for the View that we will add for this functionality:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建在屏幕上添加带有编辑表单的项的能力。以下是我们将为此功能添加的视图的标记：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will need to also add the ViewModel structure and it will include these
    items:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加 ViewModel 结构，它将包括以下项目：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When adding items or removing them, Knockout gives us the ability to monitor
    these changes, and that is what we wanted to illustrate. This is the code we use
    to tell Knockout we want to subscribe, or listen, to events. The particular event
    we will be listening to will be the `arrayChange` event on the `people` array
    collection. Here is the code for it. Notice that we are also dumping the results
    into the console. We also will be pushing the results of the changes to another
    attribute for the people changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加或删除项时，Knockout 给我们监控这些变化的能力，这正是我们想要展示的。这是我们用来告诉 Knockout 我们想要订阅或监听事件的代码。我们将监听的事件将是
    `people` 数组集合上的 `arrayChange` 事件。以下是相应的代码。注意，我们还将结果输出到控制台。我们还将把更改的结果推送到另一个用于人员更改的属性。
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The results that we pass into `peopleChange`, we will handle by converting them
    to JSON using the binding on the View as follows. Anytime our value in `peopleChange`
    is updated, the results will be displayed as a JSON structure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递给 `peopleChange` 的结果，将通过在视图上使用绑定将它们转换为 JSON，如下所示。每当 `peopleChange` 中的值更新时，结果将以
    JSON 结构显示。
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, just in case that was confusing on the first pass or you don''t want to
    download the code, let me give you the markup View code here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以防第一次浏览时感到困惑或你不想下载代码，让我在这里提供标记视图代码：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It looks much simpler when all in one place; well, it does to me. There are
    more scripts included this time; here is the collection we need for this example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有内容都在一个地方时，看起来要简单得多；嗯，对我来说是这样的。这次包含的脚本更多；以下是本例所需的脚本集合：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Yes, these do work with the current version of jQuery also, if you have that
    question. We will now show the code for this example page:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这些代码也可以与当前版本的 jQuery 一起使用，如果你有这个问题的话。现在，我们将展示本例页面的代码：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we have code that will show us third-party templates, subscriptions, and
    dynamic modification of the data stored in our binding. Here is what the screen
    will look like. Well, in my `done` version of the code it is wrapped in Bootstrap,
    so this is what it looks like in Bootstrap:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有代码可以显示第三方模板、订阅以及我们绑定中存储数据的动态修改。以下是屏幕将呈现的样子。嗯，在我的 `done` 版本的代码中，它被 Bootstrap
    包裹起来，所以这就是它在 Bootstrap 中的样子：
- en: '![Live updates and the subscribe method in Knockout](img/1028OS_05_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Knockout 中的实时更新和订阅方法](img/1028OS_05_09.jpg)'
- en: 'We will go ahead and add `John` to the list and make him `40` years old. Here
    is what you will see in the screenshot with the results of `subscribe` put out
    as a JSON structure. If a record had been deleted it would show that as well;
    another reason why Knockout is so flexible to work with. You will have also noticed
    in our code that as soon as we added the items to the structure of our data via
    the binding, we also cleared the input boxes to keep a clean interface for the
    user. Here is the resultant screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续添加`John`到列表中，并让他`40`岁。这是你将在截图中所看到的，其中`subscribe`的结果以JSON结构显示。如果有一条记录被删除，它也会显示出来；这也是Knockout之所以如此灵活的原因之一。你也会在我们的代码中注意到，一旦我们通过绑定将项目添加到我们数据结构中，我们也清除了输入框，以保持用户界面的整洁。以下是结果截图：
- en: '![Live updates and the subscribe method in Knockout](img/1028OS_05_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Knockout中的实时更新和subscribe方法](img/1028OS_05_10.jpg)'
- en: Let me say again that most people do not use third-party templates as the native
    templates are very powerful. This doesn't mean to do so is wrong, but the need
    to do so could be just a need to learn how to use the abilities of the native
    template. If that is the case, we hope this chapter has been the answer to that
    need.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再重复一遍，大多数人并不使用第三方模板，因为原生模板已经非常强大。这并不意味着这样做是错误的，但这样做可能只是需要学习如何使用原生模板的能力。如果是这样的话，我们希望本章能够满足这一需求。
- en: Awesome template options
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出色的模板选项
- en: There is one more time someone may want to do something with templates different
    from the pure native style of using templates with Knockout. This is because you
    may like to use a slightly different kind of coding style. In this last section
    of the chapter, we will give you a few more options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能还想用与Knockout纯原生风格不同的模板来做一些事情。这可能是因为你可能喜欢使用稍微不同一点的编码风格。在本章的最后部分，我们将为您提供更多选项。
- en: 'We are back to native templates; I thought we should mention that in case someone
    had a question. Here are the templates that we will be using on this page:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了原生模板；我想我们应该提一下这一点，以防有人有疑问。以下是我们将在这个页面上使用的模板：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will be using the data that we used from the beginning of the chapter with
    this example. Other than that, we will also be adding one more plugin library
    to this example. It is clearly one of my favorite Knockout libraries, the **Punches**
    library. After all, what would Knockout be without punches? So we need to include
    jQuery, Knockout, Knockout-mapping, and Knockout punches, and that will work for
    now.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章开头使用的相同数据来演示这个例子。除此之外，我们还将添加一个插件库到这个例子中。这显然是我最喜欢的Knockout库之一，即**Punches**库。毕竟，没有Punches的Knockout会是什么样子？因此，我们需要包含jQuery、Knockout、Knockout-mapping和Knockout
    punches，这样现在就可以工作了。
- en: 'Here is the binding data for our traditional template included on this page:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含在本页上的传统模板的绑定数据：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output we get from this section of code on our page. If you took
    time to look at our templates, you may have noticed something different. The style
    of coding we used to tell our templates what variables we wanted to merge is now
    surrounded with double curly brackets. Yet, our output is just as we would expect
    without the need to dig in and use the `data-bind` attribute to deliver the results:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们从页面上的这一段代码中得到的输出。如果你花时间查看我们的模板，你可能已经注意到了一些不同之处。我们用来告诉模板我们想要合并哪些变量的编码风格现在被双大括号包围了。然而，我们的输出正如我们所预期的那样，无需深入挖掘并使用`data-bind`属性来传递结果：
- en: '![Awesome template options](img/1028OS_05_11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![出色的模板选项](img/1028OS_05_11.jpg)'
- en: 'Now, we will take a look at Punches template syntax. We are including the code
    for the standard bindings to make sure someone does not assume that this is the
    code that belongs in the `script` tags. This is HTML code and should be added
    right to the View code on our page as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看Punches模板语法。我们包括标准绑定的代码，以确保没有人会假设这是属于`script`标签的代码。这是HTML代码，应该直接添加到我们页面上的视图代码中，如下所示：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you run the code again you will see **Pete** and **Re-Pete** are putting
    out the same results twice. Some people, because of their personal style, may
    prefer the Punches style of coding. You may have remembered that I mentioned my
    former favorite style of coding was Handlebars. This is similar to Handlebars
    coding syntax, so it works best for me; if it''s not your style then just count
    it as a difference in developer personality. Here is the updated screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行代码时，您将看到**Pete**和**Re-Pete**两次输出相同的结果。有些人可能因为个人风格的原因，可能更喜欢Punches风格的编码。您可能还记得我提到过，我以前最喜欢的编码风格是Handlebars。这与Handlebars编码语法相似，因此对我来说效果最好；如果它不是您的风格，那么就把它当作开发者个性的差异吧。以下是更新后的截图：
- en: '![Awesome template options](img/1028OS_05_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![出色的模板选项](img/1028OS_05_12.jpg)'
- en: 'There is one other approach that I am using now to put templates on a page.
    I am using Knockout-powered custom tags. Well, sort of. They are modified with
    a library that, I call "KOmponents". You will learn more about Knockout custom
    tags in the next chapter, but it seemed fitting to show you one in action here.
    We will put the output on the page a third time. Here is the modified View markup:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在还使用另一种方法在页面上放置模板。我正在使用由Knockout驱动的自定义标签。好吧，有点像。它们被一个我称之为"KOmponents"的库修改过。您将在下一章中了解更多关于Knockout自定义标签的信息，但在这里展示一个实际操作似乎很合适。我们将第三次在页面上放置输出。以下是修改后的视图标记：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we go; run the code and you will see we get a third set of **Pete** and
    **Re-Pete** on the page. We will skip *repeating* another copy of **Pete** and
    **Re-Pete** in our screen images. The goal was to show you that they all put out
    the same content.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，运行代码后，您将看到页面上出现了第三组**Pete**和**Re-Pete**。在我们的屏幕图像中，我们将跳过再次复制**Pete**和**Re-Pete**。目标是向您展示它们都输出了相同的内容。
- en: 'We will complete this by adding this to the bottom of our View markup below
    all the `guest-template` sections:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在以下所有`guest-template`部分下方添加以下内容来完成此操作：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These will put out the content of the templates with the following results.
    You see, we have chosen to use the Punches with the Handlebars-style approach
    in one of them again.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将输出模板的内容，以下是一些结果。你看，我们选择在其中一个中使用Punches和Handlebars风格的组合。
- en: '![Awesome template options](img/1028OS_05_13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![出色的模板选项](img/1028OS_05_13.jpg)'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given you a well-rounded introduction to Knockout templates.
    If you have never used templates before, we hope you appreciate the concept of
    templates. If you have used them before, we hope you like the richer data-bound
    auto-updating ability of templates using Knockout.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了对Knockout模板的全面介绍。如果您以前从未使用过模板，我们希望您能欣赏模板的概念。如果您以前使用过，我们希望您喜欢Knockout模板提供的数据绑定自动更新能力的丰富性。
- en: In this chapter we have learned what templates do and how to use them with Knockout.
    We have learned how to nest templates with collections and non-collection structures.
    We have learned how to use event triggers and mixed a little jQuery in to modify
    template results. We have also learned how to mix in third-party template technology,
    the concept of subscribing to observables, and a couple of extra ways to merge
    templates onto our page. We also learned to use an alternative style of binding
    with the Punches library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了模板的作用以及如何使用Knockout来操作它们。我们学习了如何将模板嵌套在集合和非集合结构中。我们还学习了如何使用事件触发器，并在模板结果中混合一点jQuery来修改。此外，我们还学习了如何混合第三方模板技术，订阅观察者的概念，以及将模板合并到页面上的几种额外方法。我们还学习了如何使用Punches库的替代绑定风格。
- en: In our next chapter, we will dive into the wonder of building our own custom
    HTML tags. Has there ever been a time when you thought that standard HTML tags
    were limited? You actually wanted to have some programmable interactive features
    of HTML-style tags? Jump into the next chapter and you will find what you are
    looking for in both cases.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨构建自定义HTML标签的奇妙之处。有没有什么时候你觉得自己使用的标准HTML标签有限？你实际上想要一些具有可编程交互功能的HTML风格标签？跳到下一章，你将在这两种情况下找到你想要的东西。
