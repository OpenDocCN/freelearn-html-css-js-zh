- en: Chapter 5. The Joy of Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick walk through history tells the story of how server-side code turned
    templates into magic. Data mixed with these templates and returned meaningful
    HTML for the client. These templates dynamically adapted to produce flexible and
    functional custom HTML pages. Along came AJAX and robbed the developer of this
    powerful approach to coding. But wait, templates are back again! Now they run
    at the client side. This chapter will teach you how to create the magic at the
    client side with Knockout. In this chapter, we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Native templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced collection handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome template options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout is not just about two-way binding. Done right, it is about more elegant
    and sustainable code. We will learn how to come around for another layer of making
    our page creation simpler as we learn to use the power of templating in KnockoutJS.
  prefs: []
  type: TYPE_NORMAL
- en: Native templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are patterns for how we merge data and the stuff the data fits into.
    The most popular form of templates on computers in the early days was something
    we called a mail merge. Programs like Microsoft Word would use a mail merge document
    and a data file, and merge them together. The original purpose was for printing.
  prefs: []
  type: TYPE_NORMAL
- en: Over the time, we shifted to using this same type of technology to do web pages.
    When a user would go to a website and request a web page, the servers started
    getting smarter. The data was mixed into a template and the merged result was
    returned to the browser as HTML. This was an amazing game changer for shopping
    sites and other sites where the basic page was the same. This is why we call these
    pieces of code templates.
  prefs: []
  type: TYPE_NORMAL
- en: One way to look at this is to think about when people decorate houses. We have
    things we call stencils. While the stencil defines how the shape of the result
    will look, it does not control what color you paint something with. If you have
    an apple stencil you can paint a red apple, a green Granny Smith style apple,
    a yellow Golden Delicious apple, or go off standard and have a purple and yellow
    striped apple. The stencil only controls the container the content will be placed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: In the same fashion, web templates frame the content. Well, mostly. You see,
    this is a program and it's a bit smarter than a wall painting stencil; so we can
    add in conditional logic and do things like repeat information or conditionally
    choose if we want to show any information at all. This is the power of a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a bit more complex data set in this chapter because we want to
    get ourselves in touch with more real-life site pages, which we will be using
    outside this book. Here is the code section for this page. Not all the data will
    be used here. We will expand on the data as we progress through the chapter, so
    just focus on the stuff we actually use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You probably guessed, looking at our data, that we will be showing a pseudo,
    meaning fake in this case but pseudo sounds so much nicer, seminar page. One thing
    you should realize is that data will come in all kinds of forms. You may need
    to arrange data before it works best for your pages. Don't think there is any
    strict pattern here that you have to follow. If you need to rearrange your data
    that is part of any template approach to code, you can do it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I said this section was going to be about native templates. This means
    you are going to create these templates in, the standard Knockout way of creating
    templates. This is what you should do most of the time. We will show later how
    to integrate external template libraries; but let me say right up front that in
    the real world this is a very rare approach to how developers use templates on
    Knockout pages.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout follows the approach most browser-side templates are using. The actual
    template is nested inside a set of script tags. If you are new to this and are
    wondering why there is no JavaScript error when doing this, let me explain. In
    days past Microsoft Internet Explorer used a script called VBScript. Most other
    browsers used a script called JavaScript. Today we are seeing some other scripts
    come out on Internet Explorer again. TypeScript is an example, but it seems to
    require Visual Studio to function correctly and does not work as a native script;
    so staying with JavaScript for portability seems the way to go. These tags created
    a way to declare the type of content within them. If the content is not recognized,
    it is essentially ignored.
  prefs: []
  type: TYPE_NORMAL
- en: When the script is ignored, it means there is no DOM created from the markup
    code. JavaScript can still see this code though. So by declaring a different type
    attribute we are able to convert nested HTML into actionable code to use for our
    templates. This also allows us to actually use the familiar HTML scripting. Many
    people use something like jQuery to create content but it is nowhere near as elegant
    as a template approach. In fact, for a season, jQuery had its own templating.
    It pulled back with the reasoning that templates were not part of its solution
    focus.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the first template we will use for our page. We will need to include
    the Knockout and mapping library for the code example here. The mapping library
    is not needed to do the template code. We are using it just to make our examples
    simpler. This makes for a focused approach on the subject and less coding for
    you as you go through the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we put an `id` attribute on our template code segment.
    Each template will need a unique ID to work properly. Inside our template this
    looks pretty identical to the Knockout code we have been seeing all through this
    book. This is one of the great things about Knockout templating. It builds on
    what you already know and use with hardly any exceptions. An important consideration
    when doing templates is that the template should come before the actual call to
    binding the ViewModel. Following are the two external libraries we will include
    to make this page work. The `script` tag can come before or after them. It only
    needs to come before the binding call to prevent issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do, to use template binding, is place a call to the
    template within the code. A template is similar to the wall stencil. You get to
    choose what you put inside the pattern. You get to choose what is merged into
    the template. This means you have to have data that matches the template. In this
    template, you need to pass in a ViewModel structure that contains structure items
    for name and seating. Here is a call to the template with the data declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a template you want to use that doesn''t have any data merges,
    you could reuse it on the page. I am not sure why you would want to do that but
    it is possible. Notice that with passing data to the template we are using the
    classic JSON format approach to what gets passed in. Let''s modify the preceding
    code just a bit farther and have two templates with different data passed in,
    and a little markup near the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have used our template twice in a row with the only difference
    being they have a different ViewModel structure passed through to them. You should
    also notice that the template name is the value of the `id` attribute in our scripted
    template declaration. Here is the resulting screenshot for this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Native templates](img/1028OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since name and seating are variables of the structure, the scope is automatically
    understood by the template merging. It is a common practice to call the merging
    of the data with the template rendering, if you hear the term.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual data we merged to our template, before being inserted into the ViewModel,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we can now see our data being mixed with the template fast and easy.
    If we go to our browser developer tools to reach the console, we can input the
    following command. We want to modify the data inside our ViewModel to see if the
    binding has an instant effect on our View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this, notice the template smartly and immediately updates the content.
    So we see our data binding is locked into templates just like the binding outside
    of templates. There are different templates out in the open source market. What
    makes Knockout powerful is that it binds the rendered content to regenerate when
    the connected data changes. There have been a few comparisons of frameworks, and
    Knockout also performed better than others in terms of speed for this type of
    functionality. So, unless you are doing something incredibly large, having this
    run live should not greatly affect your user experience. With that said, don''t
    forget to test performance as that is always the best practice. Here is the updated
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Native templates](img/1028OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, where are Pete, or Peter at the moment, and Re-Pete guests? That is our
    next block of code. We already have the data but the part of the data we will
    be using is this segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the display and the template that binds to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need another template to demonstrate the merging of a different set
    of data. Here is the code for that template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our first template used a variable called `name`. In this template,
    we are also using a variable called `name`. Each template, when rendered, will
    look just at the data passed to it to merge the contents. Here is the screenshot
    from the template rendered to the page in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Native templates](img/1028OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is no basic limit to the number of templates you can use on a page or
    the amount of data that can be merged. We are not going to assume that some developer
    or some client request could not go over the top. Yet, browsers and computers
    are so fast that these issues will rarely be something to focus on. The only time
    they may become an issue is if you are doing something complex with a variable
    that is in your ViewModel, and it is based on a computed value with complex logic.
    But I have not found a case so far where it is an issue in work, my company has
    produced for our clients.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced collection handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first segment, native templates, we focused on single sets of data. In
    JavaScript, we often have collections of data stored in arrays. We will be including
    an example here to show how to use templates stored in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can copy the data from our last example page to this page. We will be using
    more of the structure this time around. We will start by focusing on the speakers.
    This array contains structured items for each speaker. The code section of our
    `script` tag should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think this looks basically the same as the last example of code, you
    are right. It will change soon, but we are looking to make a point here. Arrays
    and non-arrays are not coded differently for routine binding functionality. Here
    is the segment of data that we will be using for this part of the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be mixing this data with the following template structure and it will
    be enhanced as we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the name and bio will be mixed into our page, pulling the name
    and bio from the data of each collection record. Here is the template call we
    will use on our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we are using foreach rather than data in our template code. When
    using data it will pass in the entire data structure once. Using foreach will
    pass in the data structure as one collection item at a time. The template actually
    has no awareness of how the data is being passed to it. This is controlled by
    how we call the template. Here is the result we will see when run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced collection handling](img/1028OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, that was collection handling; but this section is called enhanced collection
    handling. We are going to go a little deeper and while using Knockout, we are
    still going to keep things pretty simple and the code very light.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code, nested inside each speaker record, there
    is another simple collection of speaker skills. Here is the first item in the
    collection for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that John Doe has skills in using jQuery, KnockoutJS, SammyJS, and NodeJS.
    This is a JavaScript dude! He probably has other talents that he didn''t list,
    but we can only show the ones he gave us, of course. How do we go about doing
    this? Well, one of the sweet powers of Knockout templates is the ability to nest
    other template calls inside templates. Here is the new template we will add to
    show the skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will obviously need to modify the primary template to have this work. We
    are using an HTML list to show the skills, so we will need to nest the list in
    a list wrapper tag. We are also going to want to add a heading to clarify what
    this list represents. Here is our modified template with the new code highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there is another foreach template binding, as the data being passed
    in is a collection. The last time it was a collection of structures and this time
    it is a collection of simple values. It does not matter to Knockout what type
    of items exist in the collection. It needs to be a collection or rather an array
    you designate when using the `foreach` passing of data.
  prefs: []
  type: TYPE_NORMAL
- en: The original call to the speaker template does need to be modified. Here is
    what our first speaker record looks like now. Of course, all the other records
    also have the added skills, but we wanted to conserve space; so please make sure
    you are doing all these examples in the browser, with code you entered by hand,
    to maximize your learning experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced collection handling](img/1028OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is pretty good but it is not good enough. We promised to cover enhanced
    collection template techniques and there is one more thing we want to show you.
    Nesting is the simplest form of enhancing our collection templates. Now, we want
    to show you how to do some relational data handling with the session records.
    Here is the session records data segment we will be mixing in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have noted that the `speakerId` attribute is part of this data collection.
    This is how we will tie the records in. It will take a minor amount of code to
    tie this in correctly, but it truly is a minor amount of code. We will need to
    add the following highlighted code to make this work. We have added this code
    between our mapping and binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time we are not using a collection to pass to the template; well, not a
    bound array collection. We will be calling the data by triggering a function that
    will filter and return an array collection. This means that as long as we are
    passing an array when the call is made, the template call does not care.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using the `arrayMap` method of our Knockout utilities to filter
    data versus filter down. Notice that we call by designation the ViewModel as the
    first argument of the filter. It will then pass in each session item one at a
    time to see if the item should be placed in the filtered collection. Then, it
    will return the results. Pretty simple code. Oh, yes, it does receive the `speakerId`
    attribute as an argument when calling. That is key to making things work. Take
    a look at the following `script` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have used the `$root` designation to call our method. This is
    because we wanted to remind you that because this is a nested template, we need
    to make sure our method call is at the right level. The `$root` designation allows
    you to address the actual root level of the ViewModel. The ID that is passed in
    matches the speaker data item. The `speakerSessions` code we added will then match
    that ID with the records that have the same ID. If there is more than one session,
    it will show them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to also include a nested call to the sessions in our primary template
    for this to work. Again, we will not need to modify the original call to the speakers.
    Here is the code with the new part highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment and look at the code; discover the difference between the call
    to our additional nested template and the first nested template. You will see
    that in our additional method we did not pass in the data using the `foreach`
    designator. This time we used the data designator to pass in our collection. Both
    of these are valid approaches, but we wanted to give you examples of doing both
    for your experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the resulting first record (again, not showing everything to save space).
    Notice how this time the nested template is handling the `foreach` designator
    using classic binding for Knockout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced collection handling](img/1028OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Render event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things you grow to appreciate as your experience grows is the ability
    to do event handling. I have not needed this functionality yet with Knockout code
    in the live sites we have built; but it is awesome to know it is there if we do
    need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following code this time. We will use a different data
    set for this example to keep our code simpler and focus on just this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This also tells us that we will not always consider the mapping to be the best
    method. It is usually best in the early prototyping of pages to use mapping as
    it speeds up the creation of the stuff we need. Then, we migrate, if needed, to
    a non-mapped ViewModel when appropriate, to maximize productivity. If your experience
    varies then follow your instinct and use the approach that works best in your
    group.
  prefs: []
  type: TYPE_NORMAL
- en: The data and binding are obvious by now. The function we added will use jQuery
    to perform a wrap of each designated item, rendered by Knockout with italics and
    in green. One pragmatic use I have thought of for this is a log of a unit test
    to make sure the output is what is expected. Regardless of what you use it for,
    it will show you a couple of things.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are not totally disconnected from jQuery while using Knockout. There
    is a way I like to describe this to people who are anxious that using Knockout
    will eliminate the use of jQuery. Yes, I remember how hard JavaScript was for
    most people before jQuery. They both have different strengths. Knockout shines
    at data binding and jQuery shines at AJAX communications between the client and
    the server, as well as at DOM manipulation. Together, they make a great team with
    each having areas and different challenges that they are best suited to meet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the templates we will use in this example. We will be using nested
    templates again. This is the root template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have called the months as nested template calls. While we could have just
    rendered all this with regular tags, it would not have shown us how the event
    handlers work. Look closely at the nested data binding in the template call and
    you will see a setting for `afterRender`. You will see it calls the function we
    added to our code. Since it is in the root template, it will not need to use the
    `$root` designator to correctly call the function method to handle the render
    event. Here is the nested template that it will call to render the month items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something special I wanted you to see here also. Noticed that we use
    the variable `season.name` in this template. We were able to address the parent''s
    data structure from the nested template. The guys who wrote the Knockout library
    had many awesome moments putting things like this together. So, where is the season
    declared? Look at the actual call to the root template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will see an `as` designator with the `season` string declared as the alias
    of the structure. So, we could use `$data` in the first level of the template,
    but it would not work right to use `$data` in the second level of the template.
    By declaring the alias `season`, we can use that in the nested child, and it will
    properly target the right data set. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we look at our results we get things properly handled and rendered.
    I admit that while I have used jQuery since just before Version 1.2, my history
    with Knockout was delayed more than that. If you are having issues with earlier
    versions that may not support every feature we are teaching here, jump into the
    online group. You will find it listed at the Knockout site. The community is awesome
    in how they support each other there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the results of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Render event handling](img/1028OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Third-party template options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when jQuery was exploring creating its own templates, but that
    effort did not mature to a full release. So we will not cover that template here.
    The most popular template used with Knockout seems to have been **Underscore**
    as a result. Personally, before jumping into Knockout my template of choice was,
    well is, **Handlebars**. Yet, I have enjoyed Knockout templates so much that it
    has never compelled me to go as far as integrating Handlebars with Knockout yet.
  prefs: []
  type: TYPE_NORMAL
- en: I have played around with Underscore just to get a taste of why others use Underscore
    with Knockout; to see if I was missing something. It came down to a developer
    style difference that some developers like to use the Underscore style of template
    coding and others prefer to use native Knockout templates. In this section, we
    will be honoring the Underscore fans' approach.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest some copy and paste from the `done` directory of the example code
    for this to prevent typos. If you are awesome enough, just go ahead and type this
    in though. Remember again, your examples should be going into the `do` folder
    for each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our base code for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our code for calling the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, here is our template. You should notice that the style of the template
    is different here. If you are accustomed to Underscore, this will work great.
    If you are not using Underscore you should not assume the code in this template
    will be an example of native Knockout templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This screenshot shows that we will produce the following results. Wait! There
    is one piece missing, but we did want to show you the results first.
  prefs: []
  type: TYPE_NORMAL
- en: '![Third-party template options](img/1028OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As far as the end user is concerned, there is no difference. Using third-party
    templates is for the benefit of the developers. Well, if you are doing a contract
    that requires the use of Underscore, that would be another benefit to this approach
    as it would let you do the job with Underscore and Knockout, if permitted otherwise.
    It might be good to verify that in advance just to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: Modified template handling with Underscore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let me express my gratitude again and say thanks to the Knockout community
    on Google groups. This, in addition to several sites online, is where I learned
    how to do template handling. The technique allows us to manage the template engine
    and pass the results out to process through the Underscore engine. The key code
    is highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first highlighted section passes the code and data into the Underscore template
    handler to be rendered by Underscore. Underscore does produce some results that
    need to be cleaned up to work right here, so the second highlighted section is
    there to clean up the rendered code.
  prefs: []
  type: TYPE_NORMAL
- en: Live updates and the subscribe method in Knockout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create the ability to add items with an edit form on the screen.
    Here is the markup for the View that we will add for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to also add the ViewModel structure and it will include these
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When adding items or removing them, Knockout gives us the ability to monitor
    these changes, and that is what we wanted to illustrate. This is the code we use
    to tell Knockout we want to subscribe, or listen, to events. The particular event
    we will be listening to will be the `arrayChange` event on the `people` array
    collection. Here is the code for it. Notice that we are also dumping the results
    into the console. We also will be pushing the results of the changes to another
    attribute for the people changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The results that we pass into `peopleChange`, we will handle by converting them
    to JSON using the binding on the View as follows. Anytime our value in `peopleChange`
    is updated, the results will be displayed as a JSON structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just in case that was confusing on the first pass or you don''t want to
    download the code, let me give you the markup View code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks much simpler when all in one place; well, it does to me. There are
    more scripts included this time; here is the collection we need for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, these do work with the current version of jQuery also, if you have that
    question. We will now show the code for this example page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have code that will show us third-party templates, subscriptions, and
    dynamic modification of the data stored in our binding. Here is what the screen
    will look like. Well, in my `done` version of the code it is wrapped in Bootstrap,
    so this is what it looks like in Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live updates and the subscribe method in Knockout](img/1028OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will go ahead and add `John` to the list and make him `40` years old. Here
    is what you will see in the screenshot with the results of `subscribe` put out
    as a JSON structure. If a record had been deleted it would show that as well;
    another reason why Knockout is so flexible to work with. You will have also noticed
    in our code that as soon as we added the items to the structure of our data via
    the binding, we also cleared the input boxes to keep a clean interface for the
    user. Here is the resultant screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live updates and the subscribe method in Knockout](img/1028OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let me say again that most people do not use third-party templates as the native
    templates are very powerful. This doesn't mean to do so is wrong, but the need
    to do so could be just a need to learn how to use the abilities of the native
    template. If that is the case, we hope this chapter has been the answer to that
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome template options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one more time someone may want to do something with templates different
    from the pure native style of using templates with Knockout. This is because you
    may like to use a slightly different kind of coding style. In this last section
    of the chapter, we will give you a few more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are back to native templates; I thought we should mention that in case someone
    had a question. Here are the templates that we will be using on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the data that we used from the beginning of the chapter with
    this example. Other than that, we will also be adding one more plugin library
    to this example. It is clearly one of my favorite Knockout libraries, the **Punches**
    library. After all, what would Knockout be without punches? So we need to include
    jQuery, Knockout, Knockout-mapping, and Knockout punches, and that will work for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the binding data for our traditional template included on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output we get from this section of code on our page. If you took
    time to look at our templates, you may have noticed something different. The style
    of coding we used to tell our templates what variables we wanted to merge is now
    surrounded with double curly brackets. Yet, our output is just as we would expect
    without the need to dig in and use the `data-bind` attribute to deliver the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Awesome template options](img/1028OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will take a look at Punches template syntax. We are including the code
    for the standard bindings to make sure someone does not assume that this is the
    code that belongs in the `script` tags. This is HTML code and should be added
    right to the View code on our page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code again you will see **Pete** and **Re-Pete** are putting
    out the same results twice. Some people, because of their personal style, may
    prefer the Punches style of coding. You may have remembered that I mentioned my
    former favorite style of coding was Handlebars. This is similar to Handlebars
    coding syntax, so it works best for me; if it''s not your style then just count
    it as a difference in developer personality. Here is the updated screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Awesome template options](img/1028OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one other approach that I am using now to put templates on a page.
    I am using Knockout-powered custom tags. Well, sort of. They are modified with
    a library that, I call "KOmponents". You will learn more about Knockout custom
    tags in the next chapter, but it seemed fitting to show you one in action here.
    We will put the output on the page a third time. Here is the modified View markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we go; run the code and you will see we get a third set of **Pete** and
    **Re-Pete** on the page. We will skip *repeating* another copy of **Pete** and
    **Re-Pete** in our screen images. The goal was to show you that they all put out
    the same content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will complete this by adding this to the bottom of our View markup below
    all the `guest-template` sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These will put out the content of the templates with the following results.
    You see, we have chosen to use the Punches with the Handlebars-style approach
    in one of them again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Awesome template options](img/1028OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given you a well-rounded introduction to Knockout templates.
    If you have never used templates before, we hope you appreciate the concept of
    templates. If you have used them before, we hope you like the richer data-bound
    auto-updating ability of templates using Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we have learned what templates do and how to use them with Knockout.
    We have learned how to nest templates with collections and non-collection structures.
    We have learned how to use event triggers and mixed a little jQuery in to modify
    template results. We have also learned how to mix in third-party template technology,
    the concept of subscribing to observables, and a couple of extra ways to merge
    templates onto our page. We also learned to use an alternative style of binding
    with the Punches library.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will dive into the wonder of building our own custom
    HTML tags. Has there ever been a time when you thought that standard HTML tags
    were limited? You actually wanted to have some programmable interactive features
    of HTML-style tags? Jump into the next chapter and you will find what you are
    looking for in both cases.
  prefs: []
  type: TYPE_NORMAL
