<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Setting Up a Test Infrastructure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Setting Up a Test Infrastructure</h1></div></div></div><p>Modern web development is witnessing a JavaScript renaissance, with the expanding popularity of frontend-driven, single-page, and real-time web applications. Leading and facilitating the charge are a number of JavaScript web frameworks that enable developers to sensibly organize frontend web applications into modular and convention-driven components. As more logic and functionality is pushed from the server to the browser, these frameworks are increasingly critical in maintaining single-page application state, avoiding unstructured and ad hoc "spaghetti" code, and providing abstractions and functionality for commonly encountered development situations.</p><p>This book will focus on one such <a id="id0" class="indexterm"/>framework—<span class="strong"><strong>Backbone.js</strong></span> (<a class="ulink" href="http://backbonejs.org/">http://backbonejs.org/</a>)—that <a id="id1" class="indexterm"/>stands out from the crowd with a well-balanced feature set including small footprint size, solid core abstractions, and significant community support. Backbone.js provides a minimum set of useful interfaces (for example, models, collections, routers, and views) for application development while maintaining an enormous amount of flexibility with pluggable template engines, extensible events for cross-component communication, and a generally agnostic approach to code interaction and patterns. The framework is used at scale in applications for organizations such as <a id="id2" class="indexterm"/>USA Today,<a id="id3" class="indexterm"/> LinkedIn, <a id="id4" class="indexterm"/>Hulu, <a id="id5" class="indexterm"/>Foursquare, <a id="id6" class="indexterm"/>Disqus, and many others. Essentially, Backbone.js provides practical tools for data-driven, client-heavy web application development without getting too much in the way.</p><p>However, this evolving world of frontend development is scattered with many potential stumbling blocks. More specifically, while the theoretical application possibilities with modern JavaScript frameworks such as Backbone.js are endless, one of the most critical issues looming over rapid application development in this sphere is software quality and reliability.</p><p>JavaScript web applications are already notoriously difficult to verify and test: asynchronous DOM events and data requests are subject to timing issues and spurious failures, display behavior is difficult to isolate from application logic, and test suites depend on/interact with a specific browser. Frontend frameworks such as Backbone.js add another level of complexity with additional interfaces that need to be isolated and tested, large numbers of various small components interacting concurrently, and event logic propagating throughout application layers. Moreover, the implementation agnostic paradigm of <a id="id7" class="indexterm"/>Backbone.js produces wildly varying application code bases, making test guidelines and heuristics something of a moving target.</p><p>In this book, we will tackle the challenge of testing Backbone.js applications by identifying the parts of an application to be tested, asserting correct behavior of various components, and verifying that the program works as intended as an integrated whole. Kicking things off in this chapter, we will introduce a basic test infrastructure in the following parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing a repository structure in which to develop Backbone.js applications and tests</li><li class="listitem" style="list-style-type: disc">Getting the Mocha, Chai, and Sinon.JS test libraries</li><li class="listitem" style="list-style-type: disc">Setting up and writing our first tests</li><li class="listitem" style="list-style-type: disc">Running and assessing test results with the Mocha test reporter</li></ul></div><p>We assume that the reader is already comfortable with JavaScript web application development and familiar with Backbone.js and its usual complements—<span class="strong"><strong>Underscore.js</strong></span>
<a id="id8" class="indexterm"/> (<a class="ulink" href="http://underscorejs.org/">http://underscorejs.org/</a>) <a id="id9" class="indexterm"/>and <a id="id10" class="indexterm"/>
<span class="strong"><strong>jQuery</strong></span> <a id="id11" class="indexterm"/>(<a class="ulink" href="http://jquery.com/">http://jquery.com/</a>). All other libraries and technologies will be properly introduced as they are used throughout this book.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Although this book focuses on Backbone.js applications, the test techniques and technologies we introduce should easily carry over to other frontend JavaScript frameworks and web applications. There are a lot of great frameworks in the frontend ecosystem besides Backbone.js—try one of them!</p></div></div><div class="section" title="Designing an application and test repository structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Designing an application and test repository structure</h1></div></div></div><p>Setting up a test infrastructure<a id="id12" class="indexterm"/> first requires a plan as to where all the parts and pieces will go. We <a id="id13" class="indexterm"/>will start with a simple directory structure for a code repository as follows:</p><div class="informalexample"><pre class="programlisting">app/
  index.html
  css/
  js/
    app/
    lib/

test/
  test.html
  js/
    lib/
    spec/</pre></div><p>The <code class="literal">app/index.html</code> file contains the web application, while <code class="literal">test/test.html</code> provides the test driver page. Application and test libraries are respectively contained in the <code class="literal">app/js/</code> and <code class="literal">test/js/</code> directories.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>This is just one way to organize a Backbone.js application and tests. Other directory layouts may be more appropriate, and you should feel free to follow your own conventions and preferences in light of the specific development project at hand.</p></div></div><p>The Backbone.js application and component files (models, views, routers, and so on) are placed in <code class="literal">app/js/app/</code>, which may look something like the following:</p><div class="informalexample"><pre class="programlisting">app/js/app/
  app.js
  models/
    model-a.js
    ...
  views/
    view-a.js
    ...
  ...</pre></div><p>The core application libraries are stored in <code class="literal">app/js/lib/</code>, which should include the libraries needed to drive the actual application:</p><div class="informalexample"><pre class="programlisting">app/js/lib/
  backbone.js
  jquery.js
  underscore.js
  ...</pre></div><p>The test libraries and suites get a separate directory, <code class="literal">test/js/</code>, which isolates the test code from the application to avoid inadvertently introducing application dependencies on test functions or libraries:</p><div class="informalexample"><pre class="programlisting">test/js/
  lib/
    mocha.js
    mocha.css
    chai.js
    sinon.js
  spec/
    first.spec.js
    second.spec.js
    ...</pre></div><p>Now that we have <a id="id14" class="indexterm"/>an abstract application and a test layout, we need to fill in all the pieces and populate<a id="id15" class="indexterm"/> directories with libraries, web pages, and test files.</p></div></div>
<div class="section" title="Getting the test libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Getting the test libraries</h1></div></div></div><p>The ecosystem of <a id="id16" class="indexterm"/>frontend JavaScript test frameworks is quite rich, with libraries supporting different paradigms, features, and functionality. Choosing tools from this collection is a difficult task, without clear <span class="emphasis"><em>correct</em></span> answers. In this book, we have settled on three complementary libraries, <a id="id17" class="indexterm"/>
<span class="strong"><strong>Mocha</strong></span>, <span class="strong"><strong>Chai</strong></span><a id="id18" class="indexterm"/>, and<a id="id19" class="indexterm"/> <span class="strong"><strong>Sinon.JS</strong></span>, that provide an aggregate set of features particularly well suited for testing Backbone.js applications. In addition to these libraries, we will use the <span class="strong"><strong>PhantomJS</strong></span>
<a id="id20" class="indexterm"/> headless web browser to automate our test infrastructure and run tests from the command line.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>
<span class="strong"><strong>Server-side JavaScript testing with Mocha, Chai, and Sinon.JS</strong></span>
</p><p>Beyond the browser, JavaScript has seen a meteoric rise as a server technology via the immensely popular Node.js framework, supplanting traditional server-side languages and providing developers with a single-language web application stack. Although we will only discuss frontend testing in this book, the three core testing libraries we use are all available as server-side testing modules for Node.js. There are some non-trivial differences in integration and use (for example, Mocha reports are run from the command line and not a browser), but many of the general testing and application design concepts we will cover in this book equally apply to Node.js server applications, and you can conveniently use exactly the same test libraries in your frontend and backend development.</p></div></div><p>Following the repository structure discussed previously, we will download each of the test library files to the <code class="literal">test/js/lib/</code> directory. After this, we will be ready to write and run a test web page against the libraries. Note that although we pick specific library versions in this book to correspond with the downloadable examples code, we generally recommend using the most recent versions of these libraries.</p><div class="section" title="Mocha"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Mocha</h2></div></div></div><p>The Mocha<a id="id21" class="indexterm"/> (<a class="ulink" href="http://visionmedia.github.io/mocha/">http://visionmedia.github.io/mocha/</a>) framework supports test<a id="id22" class="indexterm"/> suites, specs, and multiple <a id="id23" class="indexterm"/>test paradigms. Some of the nifty features offered by Mocha include frontend and backend integration, versatile timeouts, slow test identification, and many different test reporters.</p><p>To run Mocha tests in a browser, we just need two files—<code class="literal">mocha.js</code> and <code class="literal">mocha.css</code>. For version 1.9.0, both these files are available from GitHub at the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://raw.github.com/visionmedia/mocha/1.9.0/mocha.js">https://raw.github.com/visionmedia/mocha/1.9.0/mocha.js</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://raw.github.com/visionmedia/mocha/1.9.0/mocha.css">https://raw.github.com/visionmedia/mocha/1.9.0/mocha.css</a></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>At the time this book went to press, the most current versions of Mocha (1.10.0 and above) have introduced an incompatibility with the Mocha-PhantomJS automation tool that we will use later in this book. You can watch the Mocha (<a class="ulink" href="https://github.com/visionmedia/mocha/issues/770">https://github.com/visionmedia/mocha/issues/770</a>) and Mocha-PhantomJS (<a class="ulink" href="https://github.com/metaskills/mocha-phantomjs/issues/58">https://github.com/metaskills/mocha-phantomjs/issues/58</a>) tickets for status updates and possible future fixes.</p></div></div><p>The JavaScript (<code class="literal">mocha.js</code>) file contains the library code and the CSS (<code class="literal">mocha.css</code>) file provides the styles for the HTML reporter page. With these files in place, we can organize our tests into suites and specs, run our tests, and get a usable report of test results.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>
<span class="strong"><strong>Why Mocha?</strong></span>
</p><p>Mocha is <a id="id24" class="indexterm"/>just one framework from an overall collection of great test libraries. Some of the strengths of the Mocha framework include solid asynchronous test support, server-side compatibility, alternative test interfaces, and flexible configurability. But, we could just as easily go with another test library.</p><p>As an example of an alternate framework, <span class="strong"><strong>Jasmine</strong></span>
<a id="id25" class="indexterm"/> (<a class="ulink" href="http://pivotal.github.io/jasmine/">http://pivotal.github.io/jasmine/</a>) from Pivotal Labs is another enormously popular JavaScript testing framework. It provides test suite and spec support, a built-in assertion library, and many more features (including test spies)—it is essentially an all-in-one framework. By contrast, Mocha is quite flexible, but you have to add additional components. For example, we leverage Chai for assertions and Sinon.JS for mocks and stubs in the test infrastructure of this book.</p></div></div></div><div class="section" title="Chai"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Chai</h2></div></div></div><p>Chai<a id="id26" class="indexterm"/> (<a class="ulink" href="http://chaijs.com/">http://chaijs.com/</a>) <a id="id27" class="indexterm"/>is a test assertion library that <a id="id28" class="indexterm"/>offers an extensive API, support for <span class="strong"><strong>Behavior-Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>)<a id="id29" class="indexterm"/> and <span class="strong"><strong>Test-Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>) <a id="id30" class="indexterm"/>test styles, and a growing plugin ecosystem. BDD and TDD will be introduced in more detail in <a class="link" href="ch02.html" title="Chapter 2. Creating a Backbone.js Application Test Plan">Chapter 2</a>, <span class="emphasis"><em>Creating a Backbone.js Application Test Plan</em></span>. In particular, we will use Chai's chainable test functions to<a id="id31" class="indexterm"/> write assertions that read very closely to natural language, allowing tests to maximize comprehensibility while minimizing the need for explanatory code comments.</p><p>For integration, we need to download a single library file—<code class="literal">chai.js</code>. The version (1.7.1) that we want is available at <a class="ulink" href="https://raw.github.com/chaijs/chai/1.7.1/chai.js">https://raw.github.com/chaijs/chai/1.7.1/chai.js</a>.</p><p>Alternatively, the current stable version of Chai can be found at <a class="ulink" href="http://chaijs.com/chai.js">http://chaijs.com/chai.js</a>.</p></div><div class="section" title="Sinon.JS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Sinon.JS</h2></div></div></div><p>The <a id="id32" class="indexterm"/>Sinon.JS library (<a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a>) provides<a id="id33" class="indexterm"/> a powerful suite of test spies, stubs, <a id="id34" class="indexterm"/>and mocks. <span class="strong"><strong>Spies</strong></span> <a id="id35" class="indexterm"/>are functions that analyze and store information about an underlying function and can be used to verify historical behavior of the function under test. <span class="strong"><strong>Stubs</strong></span> <a id="id36" class="indexterm"/>are spies that can replace a function with a different behavior more amenable to testing. <span class="strong"><strong>Mocks</strong></span> <a id="id37" class="indexterm"/>spy on and stub functions as well as verify that certain behavior has occurred during test execution. We will explain these tools in more detail throughout this book.</p><p>In practice, Backbone.js applications comprise many different and constantly interacting parts, making our goal of testing isolated program components difficult. A mocking library such as Sinon.JS will allow us to separate testable application behaviors and focus on one thing (for example, a single view or a model) at a time.</p><p>Like Chai, we just need a single JavaScript file to use Sinon.JS in our tests. Versioned releases—we will use version 1.7.3—are available at either of the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://sinonjs.org/releases/sinon-1.7.3.js">http://sinonjs.org/releases/sinon-1.7.3.js</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://raw.github.com/cjohansen/Sinon.JS/v1.7.3/lib/sinon.js">https://raw.github.com/cjohansen/Sinon.JS/v1.7.3/lib/sinon.js</a></li></ul></div><p>Installation of <a id="id38" class="indexterm"/>Sinon.JS, along <a id="id39" class="indexterm"/>with Mocha and Chai, completes the acquisition phase of our test infrastructure<a id="id40" class="indexterm"/> creation.</p></div></div>
<div class="section" title="Setting up and writing our first tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up and writing our first tests</h1></div></div></div><p>Now that we have <a id="id41" class="indexterm"/>the base test libraries, we can create a test driver web page that includes the <a id="id42" class="indexterm"/>application and test libraries, sets up and executes the tests, and displays a test report.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>The source code for all snippets and code examples in this book is available online. Files and tests for each chapter can be found by number in the <code class="literal">chapters</code> directory. See the <span class="emphasis"><em>Preface</em></span> for download locations and installation instructions.</p><p>The examples are best used as a helpful check on your own progress <span class="emphasis"><em>after</em></span> a chapter has been finished and you have applied the lessons and exercises to your own code and applications. As a gentle admonition, we encourage you to resist the temptation to copy and paste code or files from the examples. The experience of writing and adapting the code on your own will allow you to better internalize and understand the testing concepts needed to become an adept Backbone.js tester.</p></div></div><div class="section" title="The test driver page"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The test driver page</h2></div></div></div><p>A single web page is<a id="id43" class="indexterm"/> typically used to include the test and application code and drive all frontend tests. Accordingly, we can create a web page named <code class="literal">test.html</code> in the <code class="literal">chapters/01/test</code> directory of our repository starting with just a bit of HTML boilerplate—a title and <code class="literal">meta</code> attributes:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Backbone.js Tests&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;</pre></div><p>Then, we include the Mocha stylesheet for test reports and the Mocha, Chai, and Sinon.JS JavaScript libraries:</p><div class="informalexample"><pre class="programlisting">    &lt;link rel="stylesheet" href="js/lib/mocha.css" /&gt;
    &lt;script src="js/lib/mocha.js"&gt;&lt;/script&gt;
    &lt;script src="js/lib/chai.js"&gt;&lt;/script &gt;
    &lt;script src="js/lib/sinon.js"&gt;&lt;/script&gt;</pre></div><p>Next, we prepare Mocha and Chai. Chai is configured to globally export the <code class="literal">expect</code> assertion function. Mocha is set up to use the <code class="literal">bdd</code> test interface and start tests on the <code class="literal">window.onload</code> event:</p><div class="informalexample"><pre class="programlisting">    &lt;script&gt;
      // Setup.
      var expect = chai.expect;
      mocha.setup("bdd");

      // Run tests on window load event.
      window.onload = function () {
        mocha.run();
      };
    &lt;/script&gt;</pre></div><p>After the library<a id="id44" class="indexterm"/> configurations, we add in the test specs. Here we include a single test file (that we will create later) for the initial test run:</p><div class="informalexample"><pre class="programlisting">    &lt;script src="js/spec/hello.spec.js"&gt;&lt;/script&gt;
  &lt;/head&gt;</pre></div><p>Finally, we include a <code class="literal">div</code> element that Mocha uses to generate the full HTML test report. Note that a common alternative practice is to place all the <code class="literal">script</code> include statements before the close <code class="literal">body</code> tag instead of within the <code class="literal">head</code> tag:</p><div class="informalexample"><pre class="programlisting">  &lt;body&gt;
    &lt;div id="mocha"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>And with that, we are ready to create some tests. Now, you could even open <code class="literal">chapters/01/test/test.html</code> in a browser to see what the test report looks like with an empty test suite.</p></div><div class="section" title="Adding some tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Adding some tests</h2></div></div></div><p>While test<a id="id45" class="indexterm"/> design and implementation is discussed in far more detail in subsequent chapters, it is sufficient to say that test development generally entails writing JavaScript test files, each containing some organized collection of test functions. Let's start with a single test file to preview the testing technology stack and give us some tests to run.</p><p>The test file <code class="literal">chapters/01/test/js/spec/hello.spec.js</code> creates a simple function (<code class="literal">hello()</code>) to test and implements a nested set of suites introducing a few Chai and Sinon.JS features. The function under test is about as simple as you can get:</p><div class="informalexample"><pre class="programlisting">window.hello = function () {
  return "Hello World";
};</pre></div><p>The <code class="literal">hello</code> function should be contained in its own library file (perhaps <code class="literal">hello.js</code>) for inclusion in applications and tests. The code samples simply include it in the spec file for convenience.</p><p>The test code <a id="id46" class="indexterm"/>uses nested Mocha <code class="literal">describe</code> statements to create a test suite hierarchy. The test in the <code class="literal">Chai</code> suite uses <code class="literal">expect</code> to illustrate a simple assertion. The <code class="literal">Sinon.JS</code> suite's single test shows a test spy in action:</p><div class="informalexample"><pre class="programlisting">describe("Trying out the test libraries", function () {
  describe("Chai", function () {
    it("should be equal using 'expect'", function () {
      expect(hello()).to.equal("Hello World");
    });
  });

  describe("Sinon.JS", function () {
    it("should report spy called", function () {
      var helloSpy = sinon.spy(window, 'hello');

      expect(helloSpy.called).to.be.false;
      hello();
      expect(helloSpy.called).to.be.true;
      hello.restore();
    });
  });
});</pre></div><p>Not to worry if you do not fully understand the specifics of these tests and assertions at this point, as we will shortly cover everything in detail. The takeaway is that we now have a small collection of test suites with a set of specifications ready to be run.</p></div></div>
<div class="section" title="Running and assessing test results"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Running and assessing test results</h1></div></div></div><p>Now that all the necessary pieces are in place, it is time to run the tests and review the test report.</p><div class="section" title="The first test report"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The first test report</h2></div></div></div><p>Opening <a id="id47" class="indexterm"/>up the <code class="literal">chapters/01/test/test.html</code> file in any web browser will cause Mocha to<a id="id48" class="indexterm"/> run all of<a id="id49" class="indexterm"/> the included tests and produce a test report:</p><div class="mediaobject"><img src="graphics/5248OS_01_01.jpg" alt="The first test report"/><div class="caption"><p>Test report</p></div></div><p>This report provides a useful summary of the test run. The top-right column shows that two tests passed, none failed, and the tests collectively took 0.01 seconds to run. The test suites declared in our <code class="literal">describe</code> statements are present as nested headings. Each test specification has a green checkmark next to the specification text, indicating that the test has passed.</p></div><div class="section" title="Test report actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Test report actions</h2></div></div></div><p>The report page<a id="id50" class="indexterm"/> also provides tools for analyzing subsets of the entire test collection. Clicking on a suite heading such as <span class="strong"><strong>Trying out the test libraries</strong></span> or <span class="strong"><strong>Chai</strong></span> will re-run only the specifications under that heading.</p><p>Clicking on a specification text (for example, <span class="strong"><strong>should be equal using 'expect'</strong></span>) will show the JavaScript code of the test. A filter button designated by a right triangle is located to the right of the specification text (it is somewhat difficult to see). Clicking the button re-runs the single test specification.</p><div class="mediaobject"><img src="graphics/5248OS_01_02.jpg" alt="Test report actions"/><div class="caption"><p>The test specification code and filter</p></div></div><p>The previous figure<a id="id51" class="indexterm"/> illustrates a report in which the filter button has been clicked. The test <a id="id52" class="indexterm"/>specification text in the figure has also been clicked, showing the<a id="id53" class="indexterm"/> JavaScript specification code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Advanced test suite and specification filtering</strong></span>
</p><p>The report suite and specification filters rely on Mocha's <a id="id54" class="indexterm"/>
<span class="strong"><strong>grep</strong></span> feature, which is exposed as a URL parameter in the test web page. Assuming that the report web page URL ends with something such as <code class="literal">chapters/01/test/test.html</code>, we can manually add a <code class="literal">grep</code> filter parameter accompanied with the text to match suite or specification names.</p><p>For example, if we want to filter on the term <code class="literal">spy</code>, we would navigate a browser to a comparable URL containing <code class="literal">chapters/01/test/test.html?grep=spy</code>, causing Mocha to run only the <code class="literal">should report spy called</code> specification from the <code class="literal">Sinon.JS</code> suite. It is worth playing around with various <code class="literal">grep</code> values to get the hang of matching just the suites or specifications that you want.</p></div></div></div><div class="section" title="Test timing and slow tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Test timing and slow tests</h2></div></div></div><p>All of our tests so far have succeeded and run quickly, but real-world development necessarily involves a certain amount of failures and inefficiencies on the road to creating robust web applications. To this end, the Mocha reporter helps identify slow tests and analyze failures.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Why is test speed important?</strong></span>
</p><p>Slow tests <a id="id55" class="indexterm"/>can indicate <a id="id56" class="indexterm"/>inefficient or even incorrect application code, which should be fixed to speed up the overall web application. Further, if a large collection of tests run too slow, developers will have implicit incentives to skip tests in development, leading to costly defect discovery later down the deployment pipeline.</p><p>Accordingly, it is a good testing practice to routinely diagnose and speed up the execution time of the entire test collection. Slow application code may be left up to the developer to fix, but most slow tests can be readily fixed with a combination of tools such as stubs and mocks as well as better test planning and isolation.</p></div></div><p>Let's explore some timing variations in action by creating <code class="literal">chapters/01/test/js/spec/timing.spec.js</code> with the following code:</p><div class="informalexample"><pre class="programlisting">describe("Test timing", function () {
  it("should be a fast test", function (done) {
    expect("hi").to.equal("hi");
    done();
  });

  it("should be a medium test", function (done) {
    setTimeout(function () {
      expect("hi").to.equal("hi");
      done();
    }, 40);
  });

  it("should be a slow test", function (done) {
    setTimeout(function () {
      expect("hi").to.equal("hi");
      done();
    }, 100);
  });

  it("should be a timeout failure", function (done) {
    setTimeout(function () {
      expect("hi").to.equal("hi");
      done();
    }, 2001);
  });
});</pre></div><p>We use the native JavaScript <code class="literal">setTimeout()</code> function<a id="id57" class="indexterm"/> to simulate slow tests. To make the tests run asynchronously, we use the <code class="literal">done</code> test function parameter, which delays test completion until <code class="literal">done()</code> is called. Asynchronous tests will be explored in more detail in <a class="link" href="ch03.html" title="Chapter 3. Test Assertions, Specs, and Suites">Chapter 3</a>, <span class="emphasis"><em>Test Assertions, Specs, and Suites</em></span>.</p><p>The first test has no <a id="id58" class="indexterm"/>delay before the test assertion and <code class="literal">done()</code> callback, the second adds 40 milliseconds of latency, the third adds 100 milliseconds, and the final test adds 2001 milliseconds. These delays will expose different timing results under the Mocha default configuration that reports a slow test at 75 milliseconds, a medium test at one half the slow threshold, and a failure for tests taking longer than 2 seconds.</p><p>Next, include the file in your test driver page (<code class="literal">chapters/01/test/test-timing.html</code> in the example code):</p><div class="informalexample"><pre class="programlisting">    &lt;script src="js/spec/timing.spec.js"&gt;&lt;/script&gt;</pre></div><p>Now, on running the driver page, we get the following report:</p><div class="mediaobject"><img src="graphics/5248OS_01_03.jpg" alt="Test timing and slow tests"/><div class="caption"><p>Test report timings and failures</p></div></div><p>This figure<a id="id59" class="indexterm"/> illustrates timing annotation boxes for our medium (orange) and slow (red) tests and a test failure/stack trace for the 2001-millisecond test. With these report features, we can easily identify the slow parts of our test infrastructure and use more advanced test techniques and application refactoring to execute the test collection efficiently and correctly.</p></div><div class="section" title="Test failures"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Test failures</h2></div></div></div><p>A test timeout is <a id="id60" class="indexterm"/>one type of test failure we can encounter in Mocha. Two other failures that merit a quick demonstration are assertion and exception failures. Let's try out both in a new file named <code class="literal">chapters/01/test/js/spec/failure.spec.js</code>:</p><div class="informalexample"><pre class="programlisting">// Configure Mocha to continue after first error to show
// both failure examples.
mocha.bail(false);

describe("Test failures", function () {
  it("should fail on assertion", function () {
    expect("hi").to.equal("goodbye");
  });

  it("should fail on unexpected exception", function () {
    throw new Error();
  });
});</pre></div><p>The first test, <code class="literal">should fail on assertion</code>, is a Chai assertion failure, which Mocha neatly wraps<a id="id61" class="indexterm"/> up with the message <code class="literal">expected 'hi' to equal 'goodbye'</code>. The second test, <code class="literal">should fail on unexpected exception</code>, throws an unchecked exception that Mocha displays with a full stack trace.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Stack traces on Chai assertion failures vary based on the browser. For example, in Chrome, no stack trace is displayed for the first assertion while one is shown in Safari. See the Chai documentation for configuration options that offer more control over stack traces.</p></div></div><div class="mediaobject"><img src="graphics/5248OS_01_04.jpg" alt="Test failures"/><div class="caption"><p>Test failures</p></div></div><p>Mocha's failure reporting neatly illustrates what went wrong and where. Most importantly, <a id="id62" class="indexterm"/>Chai and Mocha report the most common case—a test assertion failure—in a very readable natural language format.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, we introduced an application and test structure suitable for development, gathered the Mocha, Chai, and Sinon.JS libraries, and created some basic tests to get things started. Then, we reviewed some facets of the Mocha test reporter and watched various tests in action—passing, slow, timeouts, and failures.</p><p>In the next chapter, we will integrate a Backbone.js application as the target of our test framework and learn how to test, isolate, and verify program behavior throughout the course of application development.</p></div></body></html>