- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Cybernetic Enhancements – WebdriverIO Config and Debug Tips
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制论增强 – WebdriverIO 配置和调试技巧
- en: In this chapter, we are going to cover the techniques for creating and debugging
    a custom WebdriverIO framework. This will take us through the services that help
    keep the project up to date. A lot of files get used and interact with each other
    in the project. Helpers and other features will be added to help enhance the framework
    as well as make debugging easier. We will cover the node files of the framework
    and demonstrate the differences between launching tests on Mac and Windows operating
    systems. We will also create our first hook customization for debugging on a single
    monitor. Lastly, we will write our first log wrapper to take more control over
    the output in the console window to improve debugging efficiency by customizing
    logging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍创建和调试自定义 WebdriverIO 框架的技术。这将带我们了解帮助项目保持更新的服务。在项目中，许多文件被使用并相互交互。我们将添加辅助工具和其他功能来增强框架，并使调试更容易。我们将涵盖框架的节点文件，并演示在
    Mac 和 Windows 操作系统上启动测试之间的差异。我们还将为单显示器调试创建我们的第一个钩子自定义。最后，我们将编写我们的第一个日志包装器，以在控制台窗口中获取更多控制权，通过自定义日志来提高调试效率。
- en: 'Specifically, these are our main topics for this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这是我们本章的主要话题：
- en: Main files of WebdriverIO node project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebdriverIO 节点项目的主要文件
- en: Letting Yarn help keep files up to date
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 Yarn 帮助保持文件更新
- en: Dynamic configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态配置
- en: The `global.log()` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global.log()` 方法'
- en: Rules to enforce the coding standard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行编码标准的规则
- en: The three main files of a WebdriverIO node project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebdriverIO 节点项目的三个主要文件
- en: 'A lot of files are added while following the WDIO configuration. This is a
    good time to walk through the project roadmap to get familiar with the features
    of and relationships between these files, beginning with these three:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循 WDIO 配置的过程中，会添加很多文件。这是熟悉这些文件的功能和它们之间关系的好时机，从以下这三个开始：
- en: '`package.json`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`'
- en: '`yarn.lock`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn.lock`'
- en: '`wdio.config.ts`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wdio.config.ts`'
- en: Let’s look at each one in order of execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按执行顺序逐一查看。
- en: The package.json file
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`package.json` 文件'
- en: 'The first configuration file we will discuss is the `package.json` file. It
    helps manage the project’s dependencies and provides a way to run scripts and
    access other information about the project. This file serves several purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个配置文件是 `package.json` 文件。它有助于管理项目的依赖关系，并提供了一种运行脚本和访问项目其他信息的方式。此文件具有几个用途：
- en: It can specify scripts that can be run from the command line. For example, a
    WebdriverIO project might include a `wdio` script that starts the Webdriver server
    and a `wdio-docker` script configured specifically to run on a Docker container
    instance.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以指定可以从命令行运行的脚本。例如，一个 WebdriverIO 项目可能包括一个启动 Webdriver 服务器的 `wdio` 脚本和一个专门配置为在
    Docker 容器实例上运行的 `wdio-docker` 脚本。
- en: It specifies the project’s dependencies, which are packages that the project
    needs to function properly. For example, a Webdriver project will depend on the
    `expect-wdio` package for validations. We won’t have to worry about dependency
    conflicts of all these packages. Yarn provides an interactive upgrade mode when
    you use the upgrade command with the --interactive or -i flag. The interactive
    upgrade mode allows you to select which packages to upgrade. When running >yarn
    upgrade-interactive, Yarn will display a list of outdated packages and prompt
    to choose which ones to upgrade. Yarn respects the version ranges specified in
    your package.json file when determining the versions to be upgraded.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它指定了项目的依赖关系，即项目需要正常工作所需的包。例如，一个 Webdriver 项目将依赖于 `expect-wdio` 包进行验证。我们不必担心所有这些包的依赖冲突。当使用带有
    --interactive 或 -i 标志的升级命令时，Yarn 提供了一个交互式升级模式。交互式升级模式允许您选择要升级的包。当运行 >yarn upgrade-interactive
    时，Yarn 将显示一个过时包的列表，并提示选择要升级的包。Yarn 在确定要升级的版本时，会尊重您在 package.json 文件中指定的版本范围。
- en: It can specify `devDependencies`, which are packages that are needed for developers,
    but not necessarily for execution. For example, a WebdriverIO project will depend
    on the `@wdio/cli` package. Again, the `node-check-version` utility will keep
    the versions in sync.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以指定 `devDependencies`，这些是开发者需要的，但并非一定用于执行。例如，一个 WebdriverIO 项目将依赖于 `@wdio/cli`
    包。同样，`node-check-version` 工具将保持版本同步。
- en: 'It can include metadata about the project, such as the project’s name, version,
    and authors:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含有关项目的元数据，例如项目的名称、版本和作者：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `package.json` file also contains the `"scripts"` schema. This is where
    we can create custom-run configuration shortcuts. For example, to run a test at
    the command prompt, we can use `npx`) with the `wdio`) package and provide the
    path to the WebdriverIO configuration file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件还包含`"scripts"`模式。这是我们创建自定义运行配置快捷方式的地方。例如，要在命令提示符下运行测试，我们可以使用`npx`与`wdio`包一起提供WebdriverIO配置文件的路径：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At installation, WebdriverIO includes a `wdio run` configuration in the `scripts`
    package schema:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装时，WebdriverIO在`scripts`包模式中包含一个`wdio run`配置：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can implicitly run the node executor from the package manager with the `wdio`
    shortcut:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`wdio`快捷方式从包管理器隐式运行节点执行器：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now add a shortcut for running the `A``llure` report from the previous
    chapter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为从上一章运行`Allure`报告添加一个快捷方式：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The command line to run the test and generate the report is now reduced to
    the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试和生成报告的命令行现在简化为以下内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In [*Chapter 13*](B19395_13.xhtml#_idTextAnchor247), this will come into play
    again as we run tests on multiple browsers. For now, let’s take a look brief look
    at all the different packages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B19395_13.xhtml#_idTextAnchor247)中，当我们对多个浏览器进行测试时，这将会再次发挥作用。现在，让我们简要地看一下所有不同的包。
- en: The yarn.lock file
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: yarn.lock文件
- en: This file tracks all the external supporting packages brought in by the `package.json`
    file that are stored in the `node_modules` folder. If the same version of a package
    has already been detected as downloaded, the node will skip it for efficiency.
    This file is extensive and since it is rebuilt each time `yarn add` is executed,
    it never needs to be modified manually.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件跟踪由`package.json`文件引入的所有外部支持包，这些包存储在`node_modules`文件夹中。如果已经检测到相同版本的包已被下载，则节点将跳过它以提高效率。此文件内容丰富，并且由于每次执行`yarn
    add`时都会重建它，因此无需手动修改。
- en: Next, we’ll cover the heart of WebdriverIO.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍WebdriverIO的核心。
- en: The wdio.conf.ts file and webhooks
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wdio.conf.ts文件和webhooks
- en: 'This file is where all the WDIO package features are configured. It includes
    webhooks – code that executes automatically at certain points of the framework.
    This saves us from rewriting code repeatedly. This code can be injected before
    or after every session, suite, test, WebdriverIO command, or even every hook.
    All the default features are documented inside each hook, ready to be modified.
    Let’s take, for example, the `beforeTest` code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是配置所有WDIO包功能的地方。它包括webhooks – 在框架的某些点上自动执行的代码。这使我们免于反复重写代码。此代码可以在每个会话、套件、测试、WebdriverIO命令之前或之后注入，甚至可以在每个钩子之前或之后注入。所有默认功能都在每个钩子内部有文档说明，可供修改。以`beforeTest`代码为例：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By uncommenting the `beforeTest` hook function, we can customize the functionality
    of WebdriverIO. This is just for running on the local machine where there is limited
    space on a small monitor. For example, we can maximize the browser’s full screen
    before each test:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消注释`beforeTest`钩子函数，我们可以自定义WebdriverIO的功能。这只是为了在本地机器上运行，那里在小显示器上有有限的空间。例如，我们可以在每次测试之前最大化浏览器全屏：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rule of thumb – match your developer’s hardware
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经验法则 – 匹配你的开发者的硬件
- en: Here is a good reason to request a second monitor. We just expanded our browser
    at runtime to full screen. If we only have a single monitor, this will completely
    block our **Visual Studio Code** (**VS Code**) window from view. To be efficient,
    we need to see the Terminal window in VS Code on an external monitor while the
    test executes in full screen mode on the primary monitor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个请求第二个显示器的好理由。我们刚刚在运行时将浏览器扩展到全屏。如果我们只有一个显示器，这将完全遮挡我们的**Visual Studio Code**（**VS
    Code**）窗口。为了提高效率，我们需要在主显示器上以全屏模式执行测试时，在外部显示器上看到VS Code中的终端窗口。
- en: 'But if you only have a single monitor, this is a simple trick you can implement
    in the webhooks of the `wdio.config.ts` file: set the browser height to three-quarters
    of the display resolution. First, get the current display’s height and width by
    going to **Settings** and then **Display** on Windows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只有一个显示器，你可以在`wdio.config.ts`文件的webhooks中实施一个简单的技巧：将浏览器高度设置为显示分辨率的四分之三。首先，通过访问**设置**然后是**显示**来获取当前显示的高度和宽度（在Windows上）：
- en: '![Figure 3.1 – Primary display resolution on Windows](img/B19395_Figure_3.1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Windows上的主显示分辨率](img/B19395_Figure_3.1.jpg)'
- en: Figure 3.1 – Primary display resolution on Windows
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Windows上的主显示分辨率
- en: 'On Mac, go to the **Apple** menu and select **About this Mac** > **Displays**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，转到**苹果**菜单并选择**关于本机** > **显示**：
- en: '![Figure 3.2 – Primary display resolution on Mac](img/B19395_Figure_3.2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Mac 的主要显示分辨率](img/B19395_Figure_3.2.jpg)'
- en: Figure 3.2 – Primary display resolution on Mac
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Mac 的主要显示分辨率
- en: 'Multiply the height of the display by 0.75\. In the `wdio.conf.ts` file, uncomment
    the `beforeTest()` method. Enter the width and reduced height values (in this
    example, `970`) in the `browser.setWindow` method, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示高度乘以 0.75。在 `wdio.conf.ts` 文件中，取消注释 `beforeTest()` 方法。在 `browser.setWindow`
    方法中输入宽度和减小后的高度值（在这个例子中，`970`），如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This way, you can have the best of both worlds on a single monitor, as shown
    in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以在单显示器上同时获得两者的最佳效果，如下面的截图所示：
- en: '![Figure 3.3 – Running a custom-sized browser with the Terminal log below on
    a single monitor](img/B19395_Figure_3.3.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 在单显示器上运行自定义尺寸的浏览器，并在下方终端日志中运行](img/B19395_Figure_3.3.jpg)'
- en: Figure 3.3 – Running a custom-sized browser with the Terminal log below on a
    single monitor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 在单显示器上运行自定义尺寸的浏览器，并在下方终端日志中运行
- en: You can read more about the hooks of WebdriverIO in the online documentation
    at [https://webdriver.io/docs/options/#hooks](https://webdriver.io/docs/options/#hooks).
    Since this is a TypeScript project, it requires some configuration as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://webdriver.io/docs/options/#hooks](https://webdriver.io/docs/options/#hooks)在线文档中了解更多关于
    WebdriverIO 插件的信息。由于这是一个 TypeScript 项目，因此也需要一些配置。
- en: 'The `tsconfig.json` file configures TypeScript compiler options for the node.
    It includes the framework that will be used and includes the WebdriverIO `expect`
    library for assertions. This is where we can change the ECMAScript target version
    so that it matches the node version:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsconfig.json` 文件配置了 TypeScript 编译器的节点选项。它包括将要使用的框架，并包含用于断言的 WebdriverIO `expect`
    库。这就是我们可以更改 ECMAScript 目标版本以匹配节点版本的地方：'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `es2022` target is ECMAScript version 10\. The correlation of ECMAScript
    version names and features can be found at [https://en.wikipedia.org/wiki/ECMAScript](https://en.wikipedia.org/wiki/ECMAScript)
    and the correlation of `node` to ECMAScript versions is found at [https://node.green/](https://node.green/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`es2022` 目标是 ECMAScript 10 版本。ECMAScript 版本名称与功能的相关性可以在[https://en.wikipedia.org/wiki/ECMAScript](https://en.wikipedia.org/wiki/ECMAScript)中找到，而
    `node` 与 ECMAScript 版本的相关性可以在[https://node.green/](https://node.green/)中找到。'
- en: The `test/spec` folder is the location of the test scripts to execute. Subfolders
    can help divide tests into categories. It is recommended not to get too deep with
    these folder structures as it makes relative paths difficult to keep track of.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/spec` 文件夹是执行测试脚本的存放位置。子文件夹可以帮助将测试分类。建议不要将这些文件夹结构做得太深，因为这会使相对路径难以跟踪。'
- en: The `test/pageObjects` folder holds the page object module that’s used to find
    and populate elements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`test/pageObjects` 文件夹包含用于查找和填充元素的页面对象模块。'
- en: Finally, the `node_modules` folder keeps all the supporting packages that are
    downloaded to support the node project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`node_modules` 文件夹包含了为支持节点项目而下载的所有支持包。
- en: The Chrome browser is always getting updated. Next, we need to ensure the project
    resources stay current. WebdriverIO has a service to do just that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 浏览器总是在更新。接下来，我们需要确保项目资源保持最新。WebdriverIO 提供了一个服务来完成这项工作。
- en: Letting Yarn help keep files up to date
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让 Yarn 帮助保持文件更新
- en: 'Just as the Yarn upgrade-interactive tool has to keep all the supporting packages
    current, WebdriverIO provides the ChromeDriver service to keep up with constant
    Chrome updates. We can install the service from the console by running this command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Yarn 升级交互式工具必须保持所有支持包的当前状态一样，WebdriverIO 提供了 ChromeDriver 服务以跟上 Chrome 的持续更新。我们可以通过在控制台中运行以下命令来安装此服务：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, it must be configured in the `wdio.config.ts` file. To do so, find the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它必须在 `wdio.config.ts` 文件中进行配置。为此，找到以下内容：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace it with this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, the `all-logs` folder should be added to the `.gitignore` file. Now,
    let’s cover some debugging tips.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应将 `all-logs` 文件夹添加到 `.gitignore` 文件中。现在，让我们来讨论一些调试技巧。
- en: Configuring debugging with VS Code
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VS Code 配置调试
- en: 'VS Code supplies four command prompt shells to launch scripts. Which one you
    use depends on your operating system. For Windows, there is PowerShell, Git Bash,
    Command Prompt, and the JavaScript debug terminal. Mac includes the ZSH shell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 提供了四个命令提示符外壳来启动脚本。你使用哪个取决于你的操作系统。对于 Windows，有 PowerShell、Git Bash、命令提示符和
    JavaScript 调试终端。Mac 包括 ZSH 壳：
- en: '![Figure 3.4 – VS Code debugging controls and shell terminals on Windows](img/B19395_Figure_3.4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Windows 上的 VS Code 调试控件和壳终端](img/B19395_Figure_3.4.jpg)'
- en: Figure 3.4 – VS Code debugging controls and shell terminals on Windows
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Windows 上的 VS Code 调试控件和 shell 终端
- en: 'Here’s how it looks on Mac:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上看起来是这样的：
- en: '![Figure 3.5 – VS Code debugging controls and shell Terminals on Mac](img/B19395_Figure_3.5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – Mac 上的 VS Code 调试控件和 shell 终端](img/B19395_Figure_3.5.jpg)'
- en: Figure 3.5 – VS Code debugging controls and shell Terminals on Mac
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – Mac 上的 VS Code 调试控件和 shell 终端
- en: Script execution stops when a breakpoint is entered in the code by clicking
    in the gutter to the left of a line number, as seen on line 9\. This will attach
    a debugger and a control panel. From the panel, the code execution can continue,
    step over a method call, step into the method, step out back up to the calling
    code, or restart or disconnect the debugging session.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行停止时，在代码中输入断点（如第 9 行左侧的空白处单击），这将附加调试器和控制面板。从面板中，可以继续代码执行，跳过方法调用，进入方法，或从调用代码返回，或重新启动或断开调试会话。
- en: 'The JavaScript debug terminal always attaches the debugger. Debug mode slows
    the execution. So, for Mac, a practical choice would be to have two shells open:
    the JavaScript debug terminal and ZSH for faster non-debug execution. Any shell
    can have debugging activated with auto attach:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 调试终端始终附加调试器。调试模式会减慢执行速度。因此，对于 Mac，一个实际的选择是打开两个 shell：JavaScript 调试终端和
    ZSH 以实现更快的非调试执行。任何 shell 都可以通过自动附加激活调试：
- en: '![Figure 3.6 – Command palette options to auto attach the debugger](img/B19395_Figure_3.6.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 自动附加调试器的命令面板选项](img/B19395_Figure_3.6.jpg)'
- en: Figure 3.6 – Command palette options to auto attach the debugger
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 自动附加调试器的命令面板选项
- en: 'PowerShell, Git Bash, ZSH, and Command Prompt must have the debugging configuration
    enabled by setting **Auto Attach** to **Always** from the Command Palette. It
    can be disabled temporarily from the VS Code status bar:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell、Git Bash、ZSH 和命令提示符必须通过将命令面板中的 **自动附加** 设置为 **始终** 来启用调试配置。它可以从 VS
    Code 的状态栏临时禁用：
- en: '![Figure 3.7 – Auto Attach mode can be temporarily disabled from the status
    bar at the bottom of VS Code](img/B19395_Figure_3.7.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 可以从 VS Code 底部的状态栏临时禁用自动附加模式](img/B19395_Figure_3.7.jpg)'
- en: Figure 3.7 – Auto Attach mode can be temporarily disabled from the status bar
    at the bottom of VS Code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 可以从 VS Code 底部的状态栏临时禁用自动附加模式
- en: 'At this point, we can further customize our framework by passing **environment
    variables**. In Mac, this is easy with any Terminal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以通过传递 **环境变量** 来进一步自定义我们的框架。在 Mac 上，任何终端都很容易做到：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Windows makes this tricky. To add a variable such as `DEBUG`, each shell has
    a separate syntax for multiple-line execution. Here’s the list:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 使得这一点变得复杂。要添加一个如 `DEBUG` 这样的变量，每个 shell 都有用于多行执行的单独语法。以下是列表：
- en: 'Git Bash:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Bash：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'PowerShell and JavaScript debug terminal:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 和 JavaScript 调试终端：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Command Prompt and ZSH (Mac):'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令提示符和 ZSH（Mac）：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Furthermore, the syntax for this is different in package shortcuts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，包快捷方式的语法在此处不同：
- en: 'Mac:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Windows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you have a mix of Mac and Windows team members, the situation may look dire.
    But superheroes have sidekicks and Node is no exception.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个混合使用 Mac 和 Windows 的团队，情况可能看起来很糟糕。但超级英雄有助手，Node 也不例外。
- en: Rule of thumb – the cross-env node package
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则 – cross-env 节点包
- en: 'To resolve all this, we will install the `cross-env` package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，我们将安装 `cross-env` 包：
- en: '`yarn` `add cross-env`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn` `add cross-env`'
- en: 'By adding the `cross-env` package, we now can create a new debug shortcut that
    runs with a common syntax on both Mac and Windows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `cross-env` 包，我们现在可以创建一个新的调试快捷方式，它在 Mac 和 Windows 上都使用相同的语法：
- en: '`debug: cross-env DEBUG=true` `wdio wdio.conf.ts`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug: cross-env DEBUG=true` `wdio wdio.conf.ts`'
- en: browser.debug()
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: browser.debug()
- en: 'Another way to debug our code is to add the `browser.debug()` statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试我们代码的方法是添加 `browser.debug()` 语句：
- en: '![Figure 3.8 – Pausing execution in VS Code with browser.debug()](img/B19395_Figure_3.8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 使用 browser.debug() 在 VS Code 中暂停执行](img/B19395_Figure_3.8.jpg)'
- en: Figure 3.8 – Pausing execution in VS Code with browser.debug()
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 使用 browser.debug() 在 VS Code 中暂停执行
- en: 'By default, WebdriverIO will pause the execution, but it is limited by the
    default timeout interval of our framework. For Jasmine, the default is about 1
    minute. However, we need more time for debugging when an error occurs. By setting
    `defaultTimeoutInterval` to 15,000,000 milliseconds (about 4 hours), the script
    will have more time to debug any issues:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WebdriverIO会暂停执行，但它受限于我们框架的默认超时间隔。对于Jasmine，默认值大约是1分钟。然而，当发生错误时，我们需要更多的时间进行调试。通过将`defaultTimeoutInterval`设置为15,000,000毫秒（大约4小时），脚本将会有更多的时间来调试任何问题：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, we do not want to change this value back and forth manually, particularly
    if we’re running in a cloud environment. This can be handled with our next superpower.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不希望手动反复更改这个值，尤其是如果我们正在云环境中运行。这可以通过我们的下一个超级功能来处理。
- en: Dynamic configuration
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置
- en: 'Dynamic configuration means we can change the way the framework behaves by
    assigning system variables and passing them to our framework. These variables
    follow the `ALL_CAPS` naming convention of a constant. Let’s begin by assigning
    a timeout based on the value of a `DEBUG` environment variable. At the top of
    the `config` file, we will capture the value of the `DEBUG` environment variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置意味着我们可以通过分配系统变量并将它们传递给我们的框架来改变框架的行为方式。这些变量遵循常量的`ALL_CAPS`命名约定。让我们首先根据`DEBUG`环境变量的值分配一个超时。在`config`文件的顶部，我们将捕获`DEBUG`环境变量的值：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This sets a default of `false` if `DEBUG` is not explicitly defined. Now, we
    can have a variable that extends the framework timeout when we explicitly execute
    a debug shortcut:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确定义`DEBUG`，则默认设置为`false`。现在，当我们明确执行调试快捷方式时，我们可以有一个扩展框架超时的变量：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Rule of thumb
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则
- en: Make your code readable with numeric separators. TypeScript supports underscores
    in place of commas with both integer and floating-point numbers. This makes `16_000_000`
    a valid integer while making the code more readable to humans.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字分隔符使你的代码更易读。TypeScript支持在整数和浮点数中使用下划线代替逗号。这使得`16_000_000`成为一个有效的整数，同时使代码对人类更易读。
- en: 'We can find the timeout under `jasmineOpts`. Let’s reference this new timeout
    variable. Find the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`jasmineOpts`下找到超时。让我们引用这个新的超时变量。找到以下代码：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Change it to the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 改成以下内容：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You may consider setting the `DEBUG` default to `True` when it’s omitted in
    a shortcut, then explicitly turning it off when run in a CI/CD environment such
    as Docker from Jenkins:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑在快捷方式省略时将`DEBUG`默认设置为`True`，然后在从Jenkins等CI/CD环境（如Docker）运行时明确将其关闭：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The reason is that we spend most of our time writing and debugging our code
    is spent running the test. This means we spend less time typing this over and
    over to launch a test:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是我们大部分时间都花在编写和调试代码上，这意味着我们花费较少的时间重复输入来启动测试：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This just extend timeouts when run locally:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在本地运行时扩展超时：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can have the `debug` switch implicit in the shortcut and explicit
    for CI/CD:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在快捷方式中隐式地设置`debug`开关，在CI/CD中明确设置：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In future chapters, we will execute tests in Docker. In those cases, we do
    not want our tests to wait several hours while we debug an error. In this script,
    we will change `DEBUG` to `false`; the test will use a short timeout specifically
    with that in mind:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将执行在Docker中的测试。在这种情况下，我们不希望我们的测试在调试错误时等待几个小时。在这个脚本中，我们将`DEBUG`改为`false`；测试将使用一个短超时，具体考虑这一点：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Question: who is the customer of the automation framework? You might think
    it is the stakeholders, but not really. The stakeholders are the beneficiaries
    with pretty alluring graphs. Your team is the one who works with the framework
    every day. This means you are the customer. Prioritize your framework features
    with standards that help you to be efficient in your day-to-day work, not the
    whims of your benefactors.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：自动化框架的客户是谁？你可能认为它是利益相关者，但实际上并非如此。利益相关者是那些拥有非常吸引人的图表的受益者。你的团队是每天与框架一起工作的团队。这意味着你是客户。优先考虑框架功能，以帮助你日常工作中更高效的标准，而不是你资助者的心血来潮。
- en: 'You can read more about dynamic configurations here: [https://webdriver.io/docs/debugging/#dynamic-configuration](https://webdriver.io/docs/debugging/#dynamic-configuration).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于动态配置的信息：[https://webdriver.io/docs/debugging/#dynamic-configuration](https://webdriver.io/docs/debugging/#dynamic-configuration)。
- en: 'While we are looking at the Jasmine options, we might consider automatically
    adding screen captures to the results if the test fails. These can be added to
    the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看Jasmine选项时，我们可能会考虑在测试失败时自动将屏幕截图添加到结果中。这些可以添加到以下代码中：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will create a screen capture at the root of our project. Screen captures
    do not need to take up space in the Git repo. So, we will add them inside the
    `.gitIgnore` `*.``png` file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们项目的根目录下创建一个屏幕截图。屏幕截图不需要占用Git仓库的空间。因此，我们将它们添加到`.gitIgnore`的`*.png`文件中。
- en: A note about template strings
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于模板字符串的注意事项
- en: You may have noticed that template `'strings'` with accent marks are being extensively
    used in these code examples. While TypeScript supports `'single'` quotes and `"double"`
    quotes for strings, template strings make more sense in a test automation project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这些代码示例中广泛使用了带重音符号的模板字符串 `'strings'`。虽然TypeScript支持字符串的单引号和双引号，但在测试自动化项目中，模板字符串更有意义。
- en: 'Let’s say, for example, we wish to write this string to our console log:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我们希望将此字符串写入我们的控制台日志：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we use quotes, we need to double escape the quotes in the string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用引号，我们需要在字符串中双重转义引号：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we used single quotes, the apostrophe would need to be escaped with a backslash:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用单引号，则需要用反斜杠转义撇号：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But with an accent template string, no escape is necessary:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用带重音的模板字符串时，不需要转义：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Templated strings can also pass `${variables}` to make reporting far more flexible
    and descriptive:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串还可以传递`${variables}`，使报告更加灵活和描述性：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can output a templated string to the console that is much easier to
    read than one with single or double quotes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以输出一个模板字符串到控制台，它比使用单引号或双引号的字符串更容易阅读：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Much of the purpose of custom reporting functions is to reduce noise during
    debugging.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义报告函数的大部分目的是在调试期间减少噪音。
- en: Reducing the signal-to-noise ratio
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低信噪比
- en: 'Now, we need to do some negative testing. Change the `ch3.ts` script so that
    it generates an error by adding `.not` to the `expect` validation chain:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进行一些负面测试。将`ch3.ts`脚本修改为通过在`expect`验证链中添加`.not`来生成错误：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, when we run the code, we’ll get a lot of message details:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行代码时，我们会得到大量的消息细节：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A lot of information is produced that is not all that insightful. Inside the
    `wdio.config.ts` file, we can control how much detail is displayed in the console
    with `logLevel` settings:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 产生了大量并非所有都很有洞察力的信息。在`wdio.config.ts`文件中，我们可以通过`logLevel`设置来控制控制台显示的详细程度：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The order of options is listed in order of verbosity. The default of `'info'`
    can be overwhelming. Reducing it to `'warn'` is more adequate for our purposes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选项的顺序是按照详细程度列出的。默认的`'info'`级别可能会显得过于冗长。将其降低到`'warn'`级别更适合我们的需求。
- en: Our final debugging technique is to enhance the `console.log()` command with
    a wrapper.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的调试技术是使用包装器增强`console.log()`命令。
- en: Our first custom wrapper method – global.log()
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个自定义包装方法 – global.log()
- en: 'Question: what is a wrapper?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：什么是包装器？
- en: A wrapper is a bespoke method or function that is almost identical in signature
    to an intrinsic method but with added functionality. In our first example, we
    will create a global wrapper for `console.log()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器是一种定制方法或函数，其签名几乎与内置方法相同，但增加了额外的功能。在我们的第一个例子中，我们将创建一个全局包装器`console.log()`。
- en: 'While the `console.log()` method is good for outputting information to the
    console window, it can be enhanced and shortened. Let’s build our first `log()`
    wrapper at the end of the `wdio.config.ts` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`console.log()`方法适用于将信息输出到控制台窗口，但它可以增强并缩短。让我们在`wdio.config.ts`文件的末尾构建我们的第一个`log()`包装器：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This `global.log()` wrapper is almost identical to `console.log` except it
    has some text formatting that stands out. Let’s look at this by adding some examples
    to the test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`global.log()`包装器几乎与`console.log`相同，但它有一些突出显示的文本格式。让我们通过添加一些示例到测试中来看一下：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way, we can separate the custom messages being added to the framework from
    what is being generated by the Jasmine and node reporting output.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以将添加到框架中的自定义消息与Jasmine和node报告输出生成的消息区分开来。
- en: Rule of thumb
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则
- en: Even when a function has only one line, use curly brackets. There are two reasons
    for this. First, it makes logic branch issues easier to spot. Second, when adding
    brackets, there is a good chance you will soon add more lines of code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个函数只有一行，也要使用花括号。有两个原因。首先，它使得逻辑分支问题更容易被发现。其次，当添加括号时，你很快就会添加更多代码行。
- en: 'Let’s say we want to ignore empty strings and nulls passed to the log. When
    written as a single line of code, the intention is not very clear:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想忽略传递给日志的空字符串和null。当写成单行代码时，意图不是很清楚：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But with the brackets in place, the logic looks much clearer:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但有了括号，逻辑看起来更清晰：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This follows the lines of the second reason we mentioned in the *Rule of thumb*
    box – you will soon add more lines of code. The preceding code would be better
    if we knew when an unresolved promise was passed to the log and what line had
    the issue. So, we will add an exception for `Promise` objects and display the
    console trace to show the line:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了我们之前在*经验法则*框中提到的第二个原因——你很快就会添加更多的代码行。如果我们知道未解决的承诺传递给日志的时间和出现问题的行，前面的代码会更好。因此，我们将为`Promise`对象添加一个异常，并显示控制台跟踪以显示该行：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Question: why is the text assigned a type of `any` and not `string`?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：为什么文本被分配为`any`类型而不是`string`类型？
- en: 'In most cases, we will declare the type of the argument in TypeScript. That’s
    the whole point of using it over JavaScript. But in this case, we want to have
    our debugging be a little more robust. We will add six log examples to the `ch3.ts`
    script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将在TypeScript中声明参数的类型。这就是使用它的全部意义所在。但在这个案例中，我们希望我们的调试更加稳健。我们将在`ch3.ts`脚本中添加六个日志示例：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With that, we have added our own level of detail that stands out. It skips
    empty and null strings. It also gives line numbers of where issues such as unresolved
    `Promise` originated:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们添加了自己的详细程度，使其脱颖而出。它跳过了空字符串和null字符串。它还提供了问题起源的行号，例如未解决的`Promise`：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running this code gives us more flexibility in logging what our framework is
    doing. We have one last topic to discuss to ensure we write good code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码使我们能够更灵活地记录我们的框架正在做什么。我们还有一个最后的话题要讨论，以确保我们编写出良好的代码。
- en: Rules to enforce coding standards
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行编码标准的规则
- en: Every coding project should have a document that states what coding rules will
    be enforced during a code review. Tools called “linters” are good at detecting
    these rules. They need to be activated at the start of a project to ensure everyone
    is on the same page. Several rules can be activated in a TypeScript project. The
    first is called **strict mode**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编码项目都应该有一个文档，说明在代码审查期间将执行哪些编码规则。被称为“linters”的工具擅长检测这些规则。它们需要在项目开始时激活，以确保每个人都处于同一页面上。TypeScript项目中可以激活多个规则。第一个被称为**严格模式**。
- en: Strict mode
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: JavaScript has a strict mode feature. Adding `"use strict"` as the first line
    of a JavaScript source file enables extra rules to ensure good coding practices
    are followed that avoid subtle code errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一个严格模式功能。将`"use strict"`作为JavaScript源文件的第一个行启用，可以启用额外的规则以确保遵循良好的编码实践，从而避免微小的代码错误。
- en: 'This includes forcing variables to be explicitly declared with a `let`, `var`,
    or `const` keyword. TypeScript has a similar strict mode that can further force
    all variables to be assigned a type, such as `string`, `number`, or `boolean`.
    This is to avoid implicitly assigning a variable to the `any` type, which can
    lead to type coercion issues:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括强制使用`let`、`var`或`const`关键字显式声明变量。TypeScript有一个类似的严格模式，可以进一步强制所有变量都分配一个类型，例如`string`、`number`或`boolean`。这是为了避免隐式地将变量分配给`any`类型，这可能导致类型强制问题：
- en: '![](img/B19395_Figure_3.9.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9](img/B19395_Figure_3.9.jpg)'
- en: Figure 3.9 – A strict mode warning where text is implicitly declared to be of
    the any type
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 一个严格模式警告，其中文本被隐式声明为`any`类型
- en: 'In the preceding example, the `text` variable is implicitly assumed to be of
    the `any` type because no type assignment was provided for the `text` variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`text`变量被隐式地假定为`any`类型，因为没有为`text`变量提供类型分配：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With strict mode enabled, three dots appear under the `text` argument. Hovering
    the mouse over these dots reveals the issue description. It also includes the
    possibility for VS Code to suggest a quick fix that will infer the parameter type
    from usage:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 启用严格模式后，`text`参数下面出现三个点。将鼠标悬停在这些点上会显示问题描述。它还包括VS Code建议快速修复的可能性，该修复将从使用中推断参数类型：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In a new TypeScript project, strict rules should be enabled from the start.
    These rules are enabled by adding them under the `"compiler options"` section
    of the `tsconfig.json` file. This rule enables all subset rules listed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的TypeScript项目中，应该从一开始就启用严格规则。这些规则通过在`tsconfig.json`文件的`"compiler options"`部分下添加它们来启用。此规则启用了列出的所有子集规则：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, turning on all rules in an existing project will likely create so much
    code to refactor that it causes significant delays in test creation. In that case,
    subsets of strict rules can be enabled and refactored over time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现有项目中启用所有规则可能会创建大量的代码需要重构，这可能会导致测试创建的重大延迟。在这种情况下，可以逐步启用严格规则的子集并进行重构。
- en: Turning on individual TypeScript subset rule checks
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用单个 TypeScript 子集规则检查
- en: Here is a list of the rules that can be enabled or disabled under the strict
    mode coding standards umbrella.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式编码标准之下，可以启用或禁用以下规则列表。
- en: '“noImplicitAny”: true'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“noImplicitAny”: true'
- en: 'This rule raises an error on expressions and declarations with an implied `any`
    type. In the following example, the `x` and `y` variables are implicitly set to
    the `any` type. Thus, if a string is passed, the code will coerce the number into
    a string and concatenate values rather than adding them:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则会在具有隐含 `any` 类型的表达式和声明上引发错误。在以下示例中，`x` 和 `y` 变量被隐式设置为 `any` 类型。因此，如果传递了一个字符串，代码将强制将数字转换为字符串并连接值，而不是相加：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following code resolves this issue by explicitly assigning the type of
    `x` and `y` to a `number` type. The only types of variables to be passed now are
    numbers, not strings:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过显式地将 `x` 和 `y` 的类型赋值为 `number` 类型来解决这个问题。现在要传递的变量类型只能是数字，而不是字符串：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '“strictNullChecks”: true'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“strictNullChecks”: true'
- en: This rule raises an error when variables are implicitly assigned a `null` value.
    This can cause issues when an empty string is a valid variable but a `Null` value
    is passed, throwing an error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则会在变量隐式赋值为 `null` 值时引发错误。当空字符串是有效变量但传递了 `Null` 值时，这可能会导致问题，抛出错误。
- en: '“strictFunctionTypes”: true'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“strictFunctionTypes”: true'
- en: 'This rule will enable strict checking of function parameter types. Take this
    code as an example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则将启用对函数参数类型的严格检查。以下代码是一个例子：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To fix this error, you would need to annotate the type of the `multiply` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，你需要对 `multiply` 函数的类型进行注解：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '“strictBindCallApply”: true'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“strictBindCallApply”: true'
- en: This rule forces strict `bind`, `call`, and `apply` methods on functions. This
    is beyond the scope of the techniques that will be covered in this book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则强制对函数上的 `bind`、`call` 和 `apply` 方法进行严格检查。这超出了本书将要介绍的技术范围。
- en: bind()
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: bind()
- en: 'The `bind()` function creates a new function with a specific value for this.
    It takes the value you want to use for this as the first argument; any additional
    arguments are passed to the original function when it is called. Here’s an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 函数创建一个新的函数，并为其指定一个特定的 `this` 值。它将用作 `this` 的值作为第一个参数；任何额外的参数在调用原始函数时传递。以下是一个例子：'
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding example, the `someMethod()` method contains an anonymous function
    that uses the `this` keyword to access a property on the current object. However,
    the `this` keyword is not properly bound to the object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`someMethod()` 方法包含一个匿名函数，该函数使用 `this` 关键字访问当前对象上的属性。然而，`this` 关键字并没有正确地绑定到对象上：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, the error has been resolved by binding the `this` keyword
    to the current object using the `bind()` function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，错误已经通过使用 `bind()` 函数将 `this` 关键字绑定到当前对象上得到解决。
- en: call()
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: call()
- en: 'The `call()` function is similar to `bind()`, but it calls the original function
    immediately, rather than creating a new function. It takes the value you want
    to use for `this` as the first argument; any additional arguments are passed to
    the original function when it is called:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()` 函数与 `bind()` 类似，但它立即调用原始函数，而不是创建一个新的函数。它将用作 `this` 的值作为第一个参数；任何额外的参数在调用原始函数时传递：'
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, the `someMethod()` method calls the `call()` function on a
    string value (greeting). However, the `call()` function can only be called on
    functions, so this will cause an error when the code is executed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`someMethod()` 方法在字符串值（greeting）上调用 `call()` 函数。然而，`call()` 函数只能用于函数，所以当代码执行时这将会导致错误。
- en: 'If you have the `strictBindCallApply` rule enabled, ESLint will catch this
    error and alert you to the issue. To fix the error, call the `call()` function
    on a function, rather than a string:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了 `strictBindCallApply` 规则，ESLint 将捕获此错误并提醒你问题。为了修复错误，请在函数上调用 `call()`
    函数，而不是字符串：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: apply()
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: apply()
- en: 'The `apply()` function is similar to `call()`, but it takes the arguments to
    pass to the original function as an array rather than a list of separate arguments.
    It takes the value you want to use for `this` as the first argument, and the array
    of arguments as the second argument:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()` 函数与 `call()` 函数类似，但它将传递给原始函数的参数作为一个数组而不是单独的参数列表。它将用作 `this` 的值作为第一个参数，将参数数组作为第二个参数：'
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding example, the `someMethod()` method calls the `apply()` function
    on a ``(`greeting`)`` string value. However, the `apply()` function can only be
    called on functions, so this will cause an error when the code is executed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`someMethod()` 方法在 `(`greeting`)` 字符串值上调用 `apply()` 函数。然而，`apply()`
    函数只能用于函数，所以当代码执行时这将会导致错误：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code shows how to fix the error by calling the `apply()` function
    on a function, rather than a string:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何通过在函数上调用 `apply()` 函数而不是字符串来修复错误：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This ESLint rule checks for properties that are declared in classes but are
    not initialized in the constructor. This rule can be used to enforce that all
    properties in a class are properly initialized before they are used:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ESLint 规则检查在类中声明但未在构造函数中初始化的属性。此规则可以用来强制在类使用之前正确初始化类中的所有属性：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'ESLint will throw an error when you try to lint the code because `myProperty`
    is not initialized in the constructor. To resolve this, assign `myProperty` to
    a string:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用 ESLint 检查代码时，它会抛出一个错误，因为 `myProperty` 在构造函数中未初始化。为了解决这个问题，将 `myProperty`
    赋值为一个字符串：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '“noImplicitThis”: true'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“noImplicitThis”: true'
- en: 'This raises an error on expressions with an implied `any` type. In TypeScript,
    the `this` keyword refers to the current instance of a class, and it is often
    used inside class methods to access properties or methods on the current object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在具有隐含 `any` 类型的表达式中引发错误。在 TypeScript 中，`this` 关键字指的是类的当前实例，它通常在类方法内部用于访问当前对象的属性或方法：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'ESLint will throw an error because the `this` keyword inside the anonymous
    function is not properly bound to an object. To fix this error, use an arrow function
    to bind the function to an object:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 会抛出一个错误，因为匿名函数内的 `this` 关键字没有正确绑定到对象上。为了修复这个错误，使用箭头函数将函数绑定到对象上：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '“alwaysStrict”: true'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '“alwaysStrict”: true'
- en: This final rule ensures the TypeScript files add `use strict` to the first line.
    In truth, this instructs the compiler to create TypeScript in strict mode, even
    if the command is missing from the TypeScript file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这条最终规则确保 TypeScript 文件在第一行添加 `use strict`。实际上，这是指导编译器以严格模式创建 TypeScript，即使 TypeScript
    文件中缺少该命令。
- en: '@ts-ignore directive'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ts-ignore 指令'
- en: 'At the end of the day, you may need to tell the compiler to ignore a warning.
    For example, the custom `log()` function intentionally has the message assigned
    to the `any` type instead of `string`. This is to ignore null strings and catch
    unwrapped promises that are passed that can be traced back to a specific line
    of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可能需要告诉编译器忽略一个警告。例如，自定义的 `log()` 函数故意将消息分配给 `any` 类型而不是 `string` 类型。这是为了忽略空字符串并捕获传递的未包装的承诺，这些承诺可以追溯到特定的代码行：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It’s important to note that the `@ts-ignore` directive is only meant to be used
    as a temporary measure to help get past an error or warning while you’re working
    on your code. It’s not a good idea to use this directive to suppress errors or
    warnings extensively as it can lead to unsafe or unreliable code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`@ts-ignore` 指令仅应作为临时措施使用，以帮助你在编写代码时绕过错误或警告。使用此指令广泛抑制错误或警告不是一个好主意，因为它可能导致不安全或不可靠的代码。
- en: The next question is, when will we ever have the time to refactor and document
    our framework when we are spending all our time writing test scripts?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是我们什么时候会有时间重构和记录我们的框架，当我们把所有时间都花在编写测试脚本上时？
- en: Tip – “get it done” Friday
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - “完成它”周五
- en: The best way is to plan for refactoring as part of sprint activities. Agile
    projects have a daily standup meeting. Some teams choose to eliminate the Friday
    standup and specifically dedicate additional time to code cleanup, refactoring,
    and documentation. The idea is that our weekends should be our own with our families
    and not dedicated to working.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方式是将重构计划作为冲刺活动的一部分。敏捷项目有一个每日站立会议。一些团队选择取消周五的站立会议，并专门花额外的时间进行代码清理、重构和文档编写。我们的想法是，我们的周末应该属于我们自己和我们的家人，而不是专门用于工作。
- en: Leverage artificial intelligence
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 利用人工智能
- en: '**GitHub Copilot**: Developed by GitHub and OpenAI, it provides AI-powered
    code suggestions right in the editor. It’s like a pair programmer that helps you
    write code faster and learn new APIs and languages along the way.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Copilot**：由GitHub和OpenAI开发，它直接在编辑器中提供AI代码建议。它就像一个配对程序员，帮助你更快地编写代码，并在过程中学习新的API和语言。'
- en: '**Tabnine**: An AI code-completion tool that works with popular IDEs. It predicts
    and suggests the next chunk of code you might write and supports multiple programming
    languages.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tabnine**：一个与流行IDE一起工作的AI代码补全工具。它预测并建议你可能要编写的下一块代码，并支持多种编程语言。'
- en: '**CodeGPT**: A powerful and innovative AI-driven coding assistant developed
    by OpenAI. It builds upon the foundation of GPT-3, a state-of-the-art language
    model, and is specifically tailored to assist developers and programmers in their
    coding tasks.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodeGPT**：由OpenAI开发的一个强大且创新的AI驱动编码助手。它建立在GPT-3这一最先进语言模型的基础上，并专门针对帮助开发者和程序员在编码任务中提供支持。'
- en: CodeGPT
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CodeGPT
- en: CodeGPT is a revolutionary AI-powered code generation tool developed by OpenAI.
    It leverages the GPT-3.5 architecture to assist developers in creating code snippets,
    functions, and even entire programs in various programming languages, including
    TypeScript. This technology is a game-changer for developers as it can accelerate
    the coding process, enhance code quality, and help with debugging and problem-solving.
    With CodeGPT, you can quickly generate code examples, write unit tests, or even
    get suggestions on how to implement specific features, making it an invaluable
    addition to any developer’s toolkit.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: CodeGPT是由OpenAI开发的一个革命性的AI代码生成工具。它利用GPT-3.5架构来帮助开发者在各种编程语言中创建代码片段、函数，甚至整个程序，包括TypeScript。这项技术是开发者的游戏改变者，因为它可以加速编码过程，提高代码质量，并帮助调试和解决问题。有了CodeGPT，你可以快速生成代码示例，编写单元测试，甚至获得如何实现特定功能的建议，使其成为任何开发者工具箱中的宝贵补充。
- en: 'Here’s an example of how CodeGPT can assist with TypeScript code generation.
    Suppose you want to create a TypeScript function that calculates the factorial
    of a number. With CodeGPT, you can request a code snippet like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个CodeGPT如何帮助生成TypeScript代码的例子。假设你想创建一个计算数字阶乘的TypeScript函数。使用CodeGPT，你可以请求如下代码片段：
- en: '[PRE65]typescript'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE65]typescript'
- en: 'function factorial(n: number): number {'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'function factorial(n: number): number {'
- en: if (n <= 1) {
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: if (n <= 1) {
- en: return 1;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: return 1;
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return n * factorial(n - 1);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: return n * factorial(n - 1);
- en: '}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: CodeGPT generates the TypeScript code for the factorial function, which takes
    an input number, `n`, and recursively calculates its factorial. This is just one
    example of how CodeGPT can simplify coding tasks by providing accurate and efficient
    code snippets.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: CodeGPT生成了计算阶乘的TypeScript代码，该函数接受一个输入数字`n`，并递归地计算其阶乘。这只是CodeGPT如何通过提供准确和高效的代码片段来简化编码任务的一个例子。
- en: 'Here is a real-life example that I encountered while writing this book. We
    asked for an advanced function that parses values from a string in the `key=value`
    format that could be transposed into a dictionary object with some examples. GitHub
    Copilot already knew of the SwitchboardFactory SBF object and came up with this
    function with a header:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的过程中，我遇到了一个真实生活中的例子。我们要求一个高级函数，该函数可以从`key=value`格式的字符串中解析值，并将其转换为具有一些示例的字典对象。GitHub
    Copilot已经知道SwitchboardFactory SBF对象，并提出了以下带有头部的函数：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Artificial intelligence is the way of the future. We are at a point in time
    similar to when sledgehammers were used to break up concrete at the moment that
    Charles Brady King invented the jackhammer. This is our jackhammer!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能是未来的道路。我们正处于一个时刻，类似于查尔斯·布拉迪·金发明冲击钻时，用大锤砸碎混凝土的时刻。这是我们的大锤！
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the node files of the Webdriver node framework.
    We showed you how to make launching tests common between Mac and Windows team
    members. We also showed you how to set up the environment to enable debugging
    and writing better code in TypeScript. Finally, we wrote our first custom log
    wrapper, which optimized the output to the console window.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Webdriver节点框架的节点文件。我们向您展示了如何使测试启动在Mac和Windows团队成员之间变得通用。我们还向您展示了如何设置环境以启用TypeScript中的调试和编写更好的代码。最后，我们编写了我们第一个自定义日志包装器，它优化了输出到控制台窗口。
- en: By taking control of logging, we can make our debugging process more productive
    by deciding how it’s formatted and what is sent to the Allure report. In upcoming
    chapters, we will even add color for visibility and apply this same wrapper concept
    to the most common WebdriverIO browser methods to make supercharged robust tests.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制日志记录，我们可以通过决定其格式和发送到Allure报告的内容来使我们的调试过程更加高效。在接下来的章节中，我们甚至将为可见性添加颜色，并将这个相同的包装概念应用到最常用的WebdriverIO浏览器方法上，以创建超级强大的稳健测试。
- en: But we do not want to get ahead of ourselves, Doc! Next, we will talk about
    the effects of time travel because TypeScript is a bit of a speedster!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想过于急躁，医生！接下来，我们将讨论时间旅行的影响，因为TypeScript有点像速度选手！
