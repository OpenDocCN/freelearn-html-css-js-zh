- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has classes that provide a much simpler and clearer syntax for creating
    constructors and dealing with inheritance. Until now, JavaScript never had the
    concept of classes, although it's an object-oriented programming language. Programmers
    from other programming language backgrounds often found it difficult to understand
    JavaScript's object-oriented model and inheritance due to the lack of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about object-oriented JavaScript using classes:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects the classical way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructors of the primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are classes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects using classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance in classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding object-oriented JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with ES6 classes, let's refresh our knowledge of JavaScript
    data types, constructors, and inheritance. While learning classes, we will be
    comparing the syntax of  constructors and prototype-based inheritance with the
    syntax of classes. Therefore, it is important to have a good grasp of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript variables hold (or store) data (or values). The type of data variables
    that they hold is called the data type. In JavaScript, there are seven different
    data types: number, string, Boolean, null, undefined, symbol, and object.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to holding objects, variables hold the object reference (that
    is, the memory address) instead of the object itself. If you're coming from a
    C/C++ background, you can relate them to pointers, but not exactly.
  prefs: []
  type: TYPE_NORMAL
- en: All data types other than objects are called primitive data types.
  prefs: []
  type: TYPE_NORMAL
- en: The arrays and functions are actually the JavaScript objects. A lot of things
    are objects under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of creating an object in JavaScript: using the `object`
    literal, or using a `constructor`. The `object` literal is used when we want to
    create fixed objects, whereas a `constructor` is used when we want to create objects
    dynamically at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a case where we may need to use the `constructor` instead of
    the `object` literal. Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `student` object using the `object` literal, that is, the
    `{}` notation. This works well when you just want to create a single `student`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: But the problem arises when you want to create multiple `student` objects. Obviously,
    you don't want to write the previous code multiple times to create multiple `student`
    objects. This is where `constructor` comes into use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `function` acts like a `constructor` when invoked using the `new` keyword.
    A `constructor` creates and returns an object. The `this` keyword inside a `function`,
    when invoked as a `constructor`, points to the new object instance, and once the
    `constructor` execution is finished, the new object is automatically returned.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, to create multiple `student` objects, we invoked the `constructor` multiple
    times instead of creating multiple `student` objects using the `object` literals.
  prefs: []
  type: TYPE_NORMAL
- en: To add methods to the instances of the `constructor`, we didn't use the `this`
    keyword; instead, we used the `prototype` property of `constructor`. We will learn
    more about why we did it this way, and what the `prototype` property is, in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, every object must belong to a `constructor`. Every object has an
    inherited property named `constructor`, pointing to the object''s `constructor`.
    When we create objects using the `object` literal, the `constructor` property
    points to the global `Object` of the `constructor`. Consider this example to understand
    this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the prototypal inheritance model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each JavaScript object has an internal `[[prototype]]` property pointing to
    another object called its prototype. This prototype object has a prototype of
    its own, and so on, until an object is reached with null as its prototype. null
    has no prototype, and it acts as a final link in the prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to access a property of an object, and if the property is not found
    in the object, then the property is searched for in the object's prototype. If
    still not found, then it's searched for in the prototype of the prototype object.
    It keeps on going until null is encountered in the prototype chain. This is how
    inheritance works in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As a JavaScript object can have only one prototype, JavaScript supports only
    a single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: While creating objects using the `object` literal, we can use the special `__proto__`
    property or the `Object.setPrototypeOf()` method to assign a prototype of an object.
    JavaScript also provides an `Object.create()` method, with which we can create
    a new object with a specified prototype, as `__proto__` lacks browser support,
    and the `Object.setPrototypeOf()` method seems a little odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that demonstrates different ways to set the prototype
    of an object while creating that particular object using the O`bject` literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `{age:24}` object is referred to as a base object, super object, or
    parent object as it's being inherited. And the `{name:"Eden"}` object is referred
    to as the derived object, subobject, or the child object, as it inherits another
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t assign a prototype to an object while creating it using the `object`
    literal, then the prototype points to the `Object.prototype` property. The prototype
    of `Object.prototype` is null, therefore leading to the end of the prototype chain.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While creating objects using a `constructor`, the prototype of the new objects
    always points to a property named prototype of the `function` object. By default,
    the `prototype` property is an object with one property named the `constructor`.
    The `constructor` property points to the `function` itself. Consider this example
    to understand this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To add new methods to the instances of a `constructor`, we should add them to
    the `prototype` property of the `constructor`, as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we didn''t add the methods to the `constructor` using `this` previously
    is that every instance of the `constructor` will have a copy of the methods, and
    this isn''t very memory-efficient. By attaching methods to the `prototype` property
    of a `constructor`, there is only one copy of each function that all the instances
    share. To understand this, consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` and `s2` share the same `printName` function that reduces the use
    of memory, whereas `s3` and `s4` contain two different functions called `printName`
    that make the program use more memory. This is unnecessary, as both the functions
    do the same thing. Therefore, we add methods for the instances to the `prototype`
    property of the `constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the inheritance hierarchy in the `constructor` is not as straightforward
    as for `object` literals. This is because the child `constructor` needs to invoke
    the parent `constructor` for the parent constructor's initialization logic to
    take place, and we need to add the methods of the `prototype` property of the
    parent `constructor` to the `prototype` property of the child `constructor` so
    that we can use them with the objects of the child `constructor`. There is no
    predefined way to do all this. Developers and JavaScript libraries have their
    own ways of doing this. I will show you the most common way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to implement inheritance while creating
    objects using the constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we invoked the parent `constructor` using the `call` method of the `function`
    object. To inherit the methods, we created an instance of the parent `constructor`
    and assigned it to the child constructor's `prototype` property.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a foolproof way of implementing inheritance in the constructors,
    as there are lots of potential problems. For example, if the parent `constructor`
    does something other than just initialize properties, such as DOM manipulation,
    then assigning a new instance of the parent `constructor` to the `prototype` property
    of the child `constructor` can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, classes provide a better and easier way to inherit existing constructors
    and classes. We will see more on this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The constructors of primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primitive data types, such as Boolean, string, and number, have their constructor
    counterparts. These counterpart constructors behave like wrappers for these primitive
    types. For example, the `String` constructor is used to create a string object
    that contains an internal `[[PrimitiveValue]]` property that holds the actual
    primitive value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, wherever necessary, the primitive values are wrapped with their
    `constructor` counterparts, and the counterpart objects are treated as primitive
    values so that the code works as expected. Consider this example code to understand
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` is a primitive type, and `s2` is an object although applying the
    `==` operator on them gives us a true result. s1 is a primitive type but still
    we are able to access the length property even though primitive types shouldn't
    have any properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this is happening because the previous code was converted into this at
    run-time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how the primitive value was wrapped with its `constructor`
    counterpart, and how the object counterpart was treated as a primitive value where
    necessary. Therefore, the code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types introduced from ES6 onwards won't allow their counterpart functions
    to be invoked as constructors, that is, we can't explicitly wrap them using their
    object counterparts. We saw this behavior while learning symbols.
  prefs: []
  type: TYPE_NORMAL
- en: The null and undefined primitive types don't have any counterpart constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that JavaScript's object-oriented model is based on constructors and
    prototype-based inheritance. Well, ES6 classes are just a new syntax for the existing
    model. Classes do not introduce a new object-oriented model to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 classes aim to provide a much simpler and clearer syntax for dealing with
    the constructors and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, classes are functions. Classes are just a new syntax for creating functions
    that are used as constructors. Creating functions using classes that aren't used
    as constructors doesn't make any sense, and offers no benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, it makes your code difficult to read, as it becomes confusing. Therefore,
    use classes only if you want to use them to construct objects. Let's have a look
    at classes in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as there are two ways of defining functions, function declarations and
    function expressions, there are two ways to define a class: using the class declaration
    and the class expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The class declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a class using the `class` declaration, you need to use the `class`
    keyword and a name for the `class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to define a class using the `class`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `class` named `Student`. Then, we defined a `constructor`
    method in it. Finally, we created a new instance of the class—an object, and logged
    the name property of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The body of a `class` is in the curly brackets, that is, `{}`. This is where
    we need to define methods. Methods are defined without the `function` keyword,
    and a comma is not used in between the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are treated as functions; internally the class name is treated as the
    function name, and the body of the `constructor` method is treated as the body
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one `constructor` method in a `class`. Defining more than
    one `constructor` will throw the `SyntaxError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: All the code inside a class body is executed in strict mode, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using a `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that a `class` is a `function`, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that a `class` is a `function`. It's just a new syntax for
    creating a function.
  prefs: []
  type: TYPE_NORMAL
- en: The class expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class expression has a similar syntax to a `class` declaration. However, with
    `class` expressions, you are able to omit the class name. The body and behavior
    remain the same both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to define a `class` using a `class`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we stored a reference of the `class` in a variable and used it to construct
    the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using a `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The prototype methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the methods in the body of the `class` are added to the `prototype` property
    of the class. The `prototype` property is the prototype of the objects created
    using `class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to add methods to the `prototype` property
    of a `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `printProfile` method was added to the `prototype`
    property of the `class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using a `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, to add accessor properties to objects we had to use the `Object. defineProperty()`
    method. From ES6 onwards, there are get and set prefixes for methods. These methods
    can be added to `object` literals and classes to define the get and set attributes
    of the accessor properties.
  prefs: []
  type: TYPE_NORMAL
- en: When get and `set` methods are used in a `class` body, they are added to the
    `prototype` property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define the `get` and `set` methods
    in a `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created an accessor property to encapsulate the `_name_` property.
    We also logged some other information to prove that `name` is an accessor property that
    is added to the `prototype` property of the `class`.
  prefs: []
  type: TYPE_NORMAL
- en: The generator method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To treat a concise method of an `object` literal as the `generator` method,
    or to treat a method of a `class` as the `generator` method, we can simply prefix
    it with the `*` character.
  prefs: []
  type: TYPE_NORMAL
- en: The `generator` method of a class is added to the `prototype` property of the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define a `generator` method in the
    `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods that are added to the body of the `class` with the `static` prefix
    are called `static` methods. The `static` methods are the class' own methods; that
    is, they are added to the class itself rather than the `prototype` property of
    the `class`. For example, the `String.fromCharCode()` method is a `static` method
    of the string `constructor`, that is, `fromCharCode` is the property of the `String`
    function itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` methods are often used to create utility functions for an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define and use a `static` method in
    a `class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Implementing inheritance in classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw how difficult it was to implement inheritance
    hierarchies in functions. Therefore, ES6 aims to make it easy by introducing the
    `extends` clause and the `super` keyword for classes.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `extends` clause, a `class` can inherit static and non-static properties
    from another `constructor` (which may or may not be defined using a class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The super keyword is used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It's used in a class `constructor` method to call the parent `constructor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used inside the methods of a `class`, it references the static and non-static
    methods of the parent `constructor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to implement an inheritance hierarchy
    in constructors using the `extends` clause, and the `super` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `A` is a function `constructor`; `B` is a `class` that inherits `A`; `C`
    is a `class` that inherits `B`; and as `B` inherits `A`, therefore `C` also inherits
    `A`.
  prefs: []
  type: TYPE_NORMAL
- en: As a class can inherit a function `constructor`, we can also inherit prebuilt
    function constructors, such as string and array, and also custom function constructors
    using the classes instead of the alternative hacky ways that we used to use.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example also shows how and where to use the `super` keyword. Remember
    that, inside the `constructor` method, you need to use the `super` keyword before
    using the `this` keyword. Otherwise, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: If a child class doesn't have a `constructor` method, then the default behavior
    will invoke the `constructor` method of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Computed method names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also decide the name of static and non-static methods of a `class`
    and concise methods of an `object` literal at run-time; that is, you can define
    method name via expressions. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Computed property names also allow you to use symbols as keys for the methods.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The attributes of properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using a class, the attributes of the static and non-static properties
    of the `constructor` are different from when declared using a function:'
  prefs: []
  type: TYPE_NORMAL
- en: The `static` methods are writable and configurable, but not enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prototype` property and the `prototype.constructor` property of a `class`
    are not writable, enumerable, or configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties of the `prototype` property are writable and configurable, but
    not enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are not hoisted!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can call a function before it's defined; that is, function calls can be
    made before the function definition. But, you cannot use a `class` before it's
    defined. Trying to do so in classes will throw the `ReferenceError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the result of the constructor method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `constructor` method, by default, returns the new instance if there is no
    return statement in it. If there is a return statement, then any value in the
    return statement is returned. This might seem a little weird if you're coming
    from a language like C++ as you cannot usually return any value from the `constructor` there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Symbol.species static accessor property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@@species` static accessor property is optionally added to a child `constructor` in
    order to notify the methods of the parent `constructor` about what the `constructor`
    should use if the parent constructor's methods are returning new instances. If
    the `@@species` static accessor property is not defined on a child `constructor`,
    then the methods of the parent `constructor` can use the default `constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this example to understand the use of `@@species`—the `map()` method
    of the array objects returns a new Array instance. If we call the `map()` method
    of an object that inherits an `Array` object, then the `map()` method returns
    a new instance of the child `constructor` instead of the `Array` constructor,
    which is not what we always want. The `@@species` property, which provides a way
    to signal such kinds of functions, uses a different `constructor` instead of the
    default `constructor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to use the `@@species` static accessor
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended that, if you are creating a JavaScript library, then the
    methods of the constructors in your library should always look for the `@@species`
    property while returning new instances. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to define a default `@@species` property in parent constructors,
    then you can use the `if…else` conditional to check whether the `@@species` property
    is defined or not, but the previous pattern is preferred. The built-in `map()`
    method also uses the previous pattern.
  prefs: []
  type: TYPE_NORMAL
- en: All the built-in methods of the JavaScript constructors from ES6 look for a
    `@@species` property if they return a new instance. For example, the methods of
    `Array`, `Map`, `ArrayBuffer`, `Promise`, and other such constructors look for
    the `@@species` property if they return new instances.
  prefs: []
  type: TYPE_NORMAL
- en: The new.target implicit parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default value of new.target is undefined, but when a function is invoked
    as a constructor, the value of the new.target parameter depends on the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If a constructor is invoked using a new operator, then new.target points to
    this constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a constructor is invoked via the super keyword, then the value of new.target
    in it is the same as the value of new.target of the constructor that is called
    super.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside an arrow function, the value of new.target is the same as the value for
    the `new.target` of the surrounding non-arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is example code to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Using super in object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The super keyword can also be used in concise methods of object literals. The
    super keyword in concise methods of the object literals has the same value as
    the `[[prototype]]` property of the object defined by the object literal.
  prefs: []
  type: TYPE_NORMAL
- en: In object literals, super is used to access overridden properties by the child
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to use super in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'ES.next proposal includes adding support for truly private properties in classes
    using the hash (#) symbol. #myProp inside a class will be private to that class.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first learned the basics of Object-Oriented Programming
    using a traditional function approach. Then, we jumped to classes and learned
    how they make it easy for us to read and write object-oriented JavaScript code.
    We also learned about some miscellaneous features such as the `new.target` and
    accessor methods. Let us now move on to the web, a place where we can implement
    what we've learned so far!
  prefs: []
  type: TYPE_NORMAL
