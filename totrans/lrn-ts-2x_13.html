<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application Performance</h1>
                </header>
            
            <article>
                
<p>In computer science, a system resource, or simply a resource, is any physical or virtual component of limited availability within a computer system. Every device connected to a computer system is a resource. Every internal system component is also a resource.</p>
<p>In this chapter, we are going to learn how we can manage the available resources of a system efficiently to achieve great application performance. We will learn about the different kinds of resources, performance factors, and performance profiling techniques.</p>
<p>The chapter starts by introducing some core performance concepts, such as latency or bandwidth, and continues showcasing how to measure and monitor performance as part of the continuous integration process.</p>
<p>As we have already learned in previous chapters, we can use TypeScript to generate JavaScript code that can be executed in many different environments. In this chapter, we are going to learn about performance profiling and optimization techniques, which are mainly applicable to the development of web applications. We are going to cover the following topics:</p>
<ul>
<li>Performance and resources</li>
<li>Aspects of performance</li>
<li>Memory profiling</li>
<li>Network profiling</li>
<li>CPU and GPU profiling</li>
<li>Performance testing</li>
<li>Performance recommendations</li>
<li>Performance automation</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prerequisites</h1>
                </header>
            
            <article>
                
<p>We are about to learn how to perform some performance analysis tasks; however, before that, we need to install a few tools in our development environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Google Chrome</h1>
                </header>
            
            <article>
                
<p>Before we get started, we need to install Google Chrome. We can download it at <a href="https://www.google.com/chrome/browser/desktop/index.html"><span class="URLPACKT">https://www.google.com/chrome/browser/desktop/index.html</span></a>. We are going to learn how to use the Google Chrome developer tools to perform some performance analysis tasks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Node.js</h1>
                </header>
            
            <article>
                
<p>If you didn't install Node.js in the previous chapters, you can visit <a href="https://nodejs.org/en/download/"><span class="URLPACKT">https://nodejs.org/en/download/</span></a> to download the installer for your operating system. There are two main versions of Node.js available: <strong>Long Term Support</strong> (<strong>LTS</strong>) and <strong>Current</strong>. We recommend using the LTS version.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance and resources</h1>
                </header>
            
            <article>
                
<p>Before we get our hands dirty doing some performance analysis, we must first spend some time understanding some core concepts and aspects of performance.</p>
<p>A good application is one that has a set of desirable characteristics, which includes:</p>
<ul>
<li>Functionality</li>
<li>Reliability</li>
<li>Usability</li>
<li>Reusability</li>
<li>Efficiency</li>
<li>Maintainability</li>
<li>Portability</li>
</ul>
<p>Over the course of this book so far, we have learned a lot about maintainability and reusability. In this chapter, we will focus on performance, which is closely related to reliability and maintainability.</p>
<p>The term performance refers to the amount of useful work accomplished compared with the time and resources used. A resource is a physical (such as CPU, RAM, GPU HDD, and so on) or virtual (such as CPU times, RAM regions, files, and so on) component with limited availability. Because the availability of a resource is limited, each resource is shared between processes. When a process finishes using a resource, it must release it before any other process can use it. Managing available resources in an efficient manner will help reduce the time other processes spend waiting for the resources to become available.</p>
<p>When we work on a web application, we need to keep in mind that the following resources will have limited availability:</p>
<ul>
<li><strong>Central Processing Unit</strong> (<strong>CPU</strong>): This carries out the instructions of a computer program by performing the basic arithmetic, logical, control, and input/output (I/O) operations specified by the instructions.</li>
<li><strong>Graphics Processor Unit</strong> (<strong>GPU</strong>): This is a specialized processor used in the manipulation and alteration of memory to accelerate the creation of images in a frame buffer. A frame buffer is an area of the RAM used to hold the frame of data that is continuously being sent to the screen. The GPU is used when we create applications that use the WebGL API or when we use CSS animations.</li>
<li><strong>Random Access Memory</strong> (<strong>RAM</strong>): This allows data items to be read and written in approximately the same amount of time, regardless of the order in which data items are accessed. When we declare a variable, it will be stored in RAM; when the variable is out of the scope, it will be removed from RAM by the garbage collector.</li>
<li><strong>Hard Disk Drive</strong> (<strong>HDD</strong>) and <strong>Solid-State Drive</strong> (<strong>SSD</strong>): Both of these resources are data storage devices used to store and retrieve data. Frontend web applications don't usually use persistent data storage extensively. However, we should keep in mind that whenever we store an object in a persistent manner (such as cookies, local storage, IndexedDB and so on), the performance of our application will be affected by the availability of the HDD or SSD.</li>
<li><strong>Network throughput</strong>: This determines how much actual data can be sent per unit of time across a network. The network throughput is determined by factors such as the network latency or bandwidth (we will discover more about these factors later in this chapter).</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Common performance metrics</h1>
                </header>
            
            <article>
                
<p>Performance can be affected by the availability of multiple types of physical and virtual devices. This explains the existence of multiple performance metrics (factors to measure performance). Some popular performance metrics include availability, response time, processing speed, latency, bandwidth, and scalability. These measurement mechanisms are usually directly related to one of the general resources (such as CPU, network throughput and so on) that were listed in the preceding section. We will now look at each of these performance metrics in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Availability</h1>
                </header>
            
            <article>
                
<p>If a system is not available at some stage, even if it is only partially unavailable, we will perceive it as bad performance. The availability of a system can be improved by improving its reliability, maintainability, and testability. If the system is easy to test and maintain, it will also be easy to increase its reliability.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Response time</h1>
                </header>
            
            <article>
                
<p>The response time is the amount of time that it takes to respond to a request for a service. A service here does not refer to a web service; a service can be any unit of work. The response time is influenced by the network throughput can be divided into three parts:</p>
<ul>
<li><strong>Wait time</strong>: The amount of time that the requests will spend waiting for other requests that took place earlier to be completed.</li>
<li><strong>Service time</strong>: The amount of time that it takes for the service (unit of work) to be completed.</li>
<li><strong>Transmission time</strong>: Once the unit of work has been completed, the response will be sent back to the requester. The time that it takes for the response to be transmitted is known as the transmission time.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Processing speed</h1>
                </header>
            
            <article>
                
<p>Processing speed (also known as clock rate) refers to the frequency at which a processing unit (CPU or GPU) runs. An application contains many units of work. Each unit of work is composed of instructions for the processor; usually, the processors can perform an instruction in each clock tick. Since a few clock ticks are required for an operation to be completed, the higher the clock rate (processing speed), the more instructions that will be completed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bandwidth</h1>
                </header>
            
            <article>
                
<p>Whenever we mention bandwidth in this chapter, we will be referring to the network bandwidth. The bandwidth, or data transfer rate, is the amount of data that can be carried from one point to another in a given time. The network bandwidth is usually expressed in bits per second.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Latency</h1>
                </header>
            
            <article>
                
<p>Latency is a term we can apply to many elements in a system; however, when working on web applications, we will use this term to refer to network latency. Network latency indicates any delay that occurs in data communication over the network.</p>
<p>High latency creates bottlenecks in the communication bandwidth. The impact of latency on network bandwidth can be temporary or persistent, based on the cause of the delays. High latency can be caused by problems in the medium (cables or wireless signals), problems with routers and gateways, and anti-virus, among others.</p>
<div class="packt_infobox">Network performance can be affected by many factors. Some of these factors can degrade the network throughput. For example, a high packet loss, latency, and jitter will reduce the network throughput, while a high bandwidth will increase it.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scalability</h1>
                </header>
            
            <article>
                
<p>Scalability is the ability of a system to handle a growing amount of work. A system with good scalability will be able to pass some performance tests, such as spike or stress testing. We will learn more about performance tests (such as spike and stress) later in this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance analysis</h1>
                </header>
            
            <article>
                
<p>Performance analysis (also known as performance profiling) is the observation and study of the usage of the available system resources by an application. We will perform profiling to identify performance issues in our applications. A different performance profiling process with specific tools will be carried out for each type of resource. For example, CPU profiling can be performed using the system monitor of our OS.</p>
<p>We will now learn how to use the Google Chrome's developer tools to perform some network profiling tasks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network performance analysis</h1>
                </header>
            
            <article>
                
<p>We are going to start by analyzing network performance. Not so long ago, to be able to analyze the network performance of an application, we would have to write a small network logging application from scratch. Fortunately, today, things are much easier thanks to the arrival of the performance timing API.</p>
<div class="packt_infobox">The performance timing API allows us to access detailed network timing data for each loaded resource. You can learn more about it at <a href="http://www.w3.org/TR/resource-timing/">http://www.w3.org/TR/resource-timing/</a>.</div>
<p>The following diagram illustrates the network timing data points that the API provides:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-289 image-border" src="Images/ff3aa358-6f64-411c-a247-470e819248c2.png" style="width:39.08em;height:19.00em;" width="760" height="369"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">network timing data points</div>
<p>We can access the performance timing API via the <kbd>window</kbd> object:</p>
<pre>window.performance </pre>
<p>The performance attribute in the <kbd>window</kbd> object has some properties (<kbd>memory</kbd>, <kbd>navigation</kbd>, and <kbd>timing</kbd>) and methods (<kbd>clearMarks</kbd>, <kbd>clearMeasures</kbd>, and <kbd>getEntries</kbd>). We can use the <kbd>getEntries</kbd> function to access an array which contains the taming data points of each request:</p>
<pre>window.performance.getEntries() </pre>
<p>Each entity in the array is an instance of <kbd>PerformanceResourceTiming</kbd>, which contains the following information:</p>
<pre>{ 
  connectEnd: 1354.525000002468 
  connectStart: 1354.525000002468 
  domainLookupEnd: 1354.525000002468 
  domainLookupStart: 1354.525000002468 
  duration: 179.89400000078604 
  entryType: "resource" 
  fetchStart: 1354.525000002468 
  initiatorType: "link" 
  name: "https://developer.chrome.com/static/css/out/site.css" 
  redirectEnd: 0 
  redirectStart: 0 
  requestStart: 1380.8379999827594 
  responseEnd: 1534.419000003254 
  responseStart: 1533.6550000065472 
  secureConnectionStart: 0 
  startTime: 1354.525000002468 
} </pre>
<p>Unfortunately, the timing data points in the preceding format may not be useful if they are not presented in a visual way. Fortunately, there are some tools that can help us to analyze it with ease. We will now learn about some of these tools.</p>
<p>The first tool is a browser extension called <strong>performance-bookmarklet</strong>. This extension is open source and is available for Chrome and Firefox. The extension download links can be found at <a href="https://github.com/micmro/performance-bookmarklet"><span class="URLPACKT">https://github.com/micmro/performance-bookmarklet</span></a>.</p>
<p>In the following screenshot, we can see one of the graphs generated by the extension. The graphs display the performance typing API information visually, allowing us to spot performance issues with ease:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-290 image-border" src="Images/246869e0-dffa-4839-95be-4a472ef40d8c.png" style="width:150.00em;height:52.83em;" width="1800" height="634"/></div>
<p>Alternatively, we can use the network panel in the Chrome developer tools to perform network performance profiling. To access the network panel, open Google Chrome, navigate to <span class="packt_screen">View</span> | <span class="packt_screen">Developer</span>, and then navigate to <span class="packt_screen">Developer Tools</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-291 image-border" src="Images/8aa43eaa-4586-49d1-a68d-9f55838aa5e7.png" style="width:29.50em;height:16.83em;" width="1026" height="585"/></div>
<div class="packt_infobox">Windows and Linux users can access the developer tools by pressing the <em><span class="KeyPACKT">F12</span></em> key. OS X users can access it using the <em><span class="KeyPACKT">Alt</span></em> + <em><span class="KeyPACKT">Cmd</span></em> + <em><span class="KeyPACKT">I</span></em> shortcut.</div>
<p>Once the developer tools are visible, we can access the <span class="packt_screen">Network</span> tab by clicking on it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-292 image-border" src="Images/3374dcfe-1dbd-4321-b75e-1086358fb8e2.png" style="width:108.08em;height:5.58em;" width="1297" height="67"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Network tab</div>
<p>Clicking on the <span class="packt_screen">Network</span> tab will lead us to a screen like the one seen here:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-293 image-border" src="Images/69fcde60-1409-4553-b926-ad0a26b4bbef.png" style="width:90.00em;height:50.67em;" width="1080" height="608"/></div>
<p>As we can observe, the information is presented in a table in which each file loaded is displayed as a row. On the right-hand side, we can see the timeline column. The timeline displays the performance timing API in a visual way, just like the performance-bookmarklet extension.</p>
<p>Two very important elements in the timeline column are the red and blue vertical lines. These lines let us know when the <kbd>DOMContentLoaded</kbd> event is triggered (blue line), after which the <kbd>onLoad</kbd> event is triggered (red line):</p>
<ul>
<li>The blue line indicates when the <kbd>DOMContentLoaded</kbd> event was fired. The <kbd>DOMContentLoaded</kbd> event is fired when the engine has completed parsing of the main document.</li>
<li>The red line indicates when the <kbd>onLoad</kbd> event was fired. The <kbd>onLoad</kbd> event is fired when all the page's resources have been loaded:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-294 image-border" src="Images/adb6b47f-9afb-4587-8ada-c6bcb938a946.png" style="width:29.00em;height:20.75em;" width="605" height="434"/></div>
<p>We can examine which requests were completed when these events were fired to get an idea of the overall page responsiveness and loading times.</p>
<p>If we hover over one of the cells of the timing column, we will be able to see each of the performance timing API data points:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-295 image-border" src="Images/ebc2a7b9-1ddc-47a4-bf0c-9d6c4747703c.png" style="width:31.83em;height:21.08em;" width="834" height="551"/></div>
<p>It is interesting to know that this developer tool reads this information using the performance timing API. We will now learn more about the meaning of each of the data points:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Performance timing API data point</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Stalled/Blocking</p>
</td>
<td>
<p>The amount of time spent waiting by the request before it can be sent; there is a maximum number of open TCP connections for an origin. When the limit is reached, some requests will display blocking time, rather than stalled time. There is a maximum of 6 TCP connections to the same origin (domain address).</p>
</td>
</tr>
<tr>
<td>
<p>Proxy negotiation</p>
</td>
<td>
<p>The amount of time spent negotiating a connection with a proxy server.</p>
</td>
</tr>
<tr>
<td>
<p>DNS lookup</p>
</td>
<td>
<p>The amount of time spent resolving a DNS address; resolving a DNS requires a full round-trip to do the DNS server for each domain on the page.</p>
</td>
</tr>
<tr>
<td>
<p>Initial connection / connecting</p>
</td>
<td>
<p>The amount of time spent establishing a connection.</p>
</td>
</tr>
<tr>
<td>
<p>SSL</p>
</td>
<td>
<p>The amount of time spent establishing an SSL connection.</p>
</td>
</tr>
<tr>
<td>
<p>Request sent / sending</p>
</td>
<td>
<p>The amount of time spent issuing the network request; typically, a fraction of a millisecond.</p>
</td>
</tr>
<tr>
<td>
<p>Waiting (TTFB)</p>
</td>
<td>
<p>The amount of time spent waiting for the initial byte to be received—<strong>time to first byte</strong> (<strong>TTFB</strong>); the TTFB can be used to find out the latency of a round trip to the server in addition to the time spent waiting for the server to deliver the response.</p>
</td>
</tr>
<tr>
<td>
<p>Content download / downloading</p>
</td>
<td>
<p>The amount of time spent waiting for the response data to be received.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">Please refer to the official Google Chrome documentation at <a href="https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation"><span class="URLPACKT">https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation</span></a> to learn more about the timing API.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network performance and user experience</h1>
                </header>
            
            <article>
                
<p>Now that we know how we can analyze network performance, it is time to identify the performance goals we should aim for. Numerous studies have proved that it is important to keep loading times as low as possible to achieve a great <strong>user experience</strong> (<strong>UX</strong>). The Akamai study, published in September 2009, interviewed 1,048 online shoppers and found that:</p>
<ul>
<li>47 percent of people expect a web page to load in two seconds or less</li>
<li>40 percent of people will abandon a web page if it takes more than three seconds to load</li>
<li>52 percent of online shoppers claim that quick page loads are important for their loyalty to a site</li>
<li>14 percent of people will start shopping at a different site if page loads are slow</li>
<li>23 percent of people will stop shopping or even walk away from their computer if page loads are slow</li>
<li>64 percent of shoppers who are dissatisfied with their site visit will go somewhere else to shop next time</li>
</ul>
<div class="packt_infobox">You can read the full Akamai study at <a href="https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp"><span class="URLPACKT">https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp</span></a>.</div>
<p>From the preceding study conclusions, we should assume that network performance matters. Our priority should be to try to improve the loading speed of our applications.</p>
<p>If we try to improve the performance of a site to ensure that it loads in less than two seconds, we might make a common mistake: trying to get the <kbd>onLoad</kbd> event to be triggered in under two seconds.</p>
<p>While triggering the <kbd>onLoad</kbd> event as early as possible will probably improve the network performance of an application, it doesn't mean that the user experience will be equally improved. The <kbd>onLoad</kbd> event is insufficient in determining performance. We can demonstrate this by comparing the loading performance of the Twitter and Amazon websites. As we can see in the following screenshot, users can engage with Amazon much sooner than with Twitter. Even though the <kbd>onLoad</kbd> event is the same on both sites, the user experience is drastically different:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-296 image-border" src="Images/be19ba8b-7883-49bc-81ac-7ef457d1a54a.png" style="width:76.25em;height:29.75em;" width="915" height="357"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Twitter and Amazon websites</div>
<p>The preceding example demonstrates why it is important to try to load the web contents in such a way that the user engagement can begin as early as possible. One way to achieve this is by ensuring that we only load the minimum necessary assets on initial page load. We can then asynchronously load all the secondary assets.</p>
<div class="packt_infobox">Refer to <a href="82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Working with Functions,</em> to learn more about asynchronous programming with TypeScript.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network performance best practices and rules</h1>
                </header>
            
            <article>
                
<p>Another way to analyze the performance of a web application is by using a best practices tool for network performance, such as the <strong>Google PageSpeed Insights</strong> application or the <strong>Yahoo YSlow</strong> application.</p>
<p>Google PageSpeed Insights can be used online or as a Google Chrome extension. To try this tool, we can visit the online version at <a href="https://developers.google.com/speed/pagespeed/insights/"><span class="URLPACKT">https://developers.google.com/speed/pagespeed/insights/</span></a> and insert the URL of the web application that we want to analyze. In just a few seconds, we will get a report like the one in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-297 image-border" src="Images/a8f32bde-7fba-4fd7-8d95-86ab32bf222c.png" style="width:39.42em;height:37.67em;" width="1375" height="1315"/></div>
<p>The report contains some effective recommendations that will help us to improve network performance and overall user experience of our web applications. Google PageSpeed Insights uses the following rules to rate the speed of a web application:</p>
<ul>
<li>Avoid landing page redirects</li>
<li>Enable compression</li>
<li>Improve server response time</li>
<li>Leverage browser caching</li>
<li>Minify resources</li>
<li>Optimize images</li>
<li>Optimize CSS delivery</li>
<li>Prioritize visible content</li>
<li>Remove render-blocking JavaScript</li>
<li>Use asynchronous scripts</li>
</ul>
<p>If we click on the score of one of the rules, we will be able to see recommendations and details that will help us to understand what is wrong and what we need to do to increase the score achieved.</p>
<p>On the other hand, Yahoo YSlow is available as a browser extension, a Node.js module, and a PhantomJS plugin, among other options. We can find the right version for our needs at <a href="http://yslow.org/"><span class="URLPACKT">http://yslow.org/</span></a>. YSlow generates a report that will provide us with a general score and a detailed score of the website, like the one in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-298 image-border" src="Images/e0155934-8539-4b7b-92e2-a0c6b6e99541.png" style="width:50.83em;height:28.25em;" width="1519" height="845"/></div>
<p>YSlow uses the following set of rules to rate the speed of a web application:</p>
<ul>
<li>Minimize HTTP requests</li>
<li>Use a content delivery network</li>
<li>Avoid empty <kbd>src</kbd> or <kbd>href</kbd></li>
<li>Add an expires or a cache-control header</li>
<li>GZIP components</li>
<li>Put stylesheets at the top</li>
<li>Put scripts at the bottom</li>
<li>Avoid CSS expressions</li>
<li>Make JavaScript and CSS external</li>
<li>Reduce DNS lookups</li>
<li>Minify JavaScript and CSS</li>
<li>Avoid redirects</li>
<li>Remove duplicate scripts</li>
<li>Configure ETags</li>
<li>Make Ajax cacheable</li>
<li>Use GET for Ajax requests</li>
<li>Reduce the number of DOM elements</li>
<li>Prevent 404 errors</li>
<li>Reduce cookie size</li>
<li>Use cookie-free domains for components</li>
<li>Avoid filters</li>
<li>Do not scale images in HTML</li>
<li>Make <kbd>favicon.ico</kbd> small and cacheable</li>
</ul>
<p>If we click on the score of one of the rules, we will see some recommendations and details that will help us to understand what is wrong and what we need to do to increase the score achieved for one particular rule.</p>
<div class="packt_infobox">If you want to learn more about network performance optimization, please look at the book <em>High Performance Browser Networking</em> by <em>Ilya Grigorik</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GPU performance analysis</h1>
                </header>
            
            <article>
                
<p>Rendering elements in a web application is sometimes accelerated by the GPU. The GPU is specialized in the processing of graphics-related instructions and can, therefore, deliver a much better performance than the CPU when it comes to graphics. For example, CSS3 animations in modern web browsers are accelerated by the GPU, while the CPU performs JavaScript animations. In the past, the only way to achieve some animations was via JavaScript. But today, we should avoid its usage when possible and use CSS3 instead.</p>
<p>In recent years, direct access to the GPU from a web browser has become possible thanks to the WebGL API. This API allows web developers to create 3D games and other highly visual 3D applications powered by the GPU.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Frames per second (FPS)</h1>
                </header>
            
            <article>
                
<p>We will not go into much detail about the performance of 3D applications, because it is an extensive field and we could write an entire book about it. However, we will learn about an important concept that can be applied to any web application: <strong>frames per second</strong> (<strong>FPS</strong>), or frame rate. When the web application is displayed on the screen, it is done at several images (frames) per second. A low frame rate can be detrimental to the overall user experience when perceived by the users. A lot of research has been carried out on this topic, and 60 frames per second seem to be the optimum frame rate for great user experience. It is also worth mentioning that maintaining a constant frame rate, even if it is a low one like 30 FPS, is considered better than an inestable frame rate.</p>
<p>Whenever we develop a web application, we should look at the frame rate and try to prevent it from dropping below 40 FPS, which is especially important for animations and user actions.</p>
<p>We can use Google Chrome to monitor the FPS in our web applications. We need to open the development tools (<em>Ctrl</em> + <em>Shift</em> + <em>I</em>), click on the upper-right icon next to the <em>X</em> icon with the tooltip <em>Customize and control devtools</em>. We can then select <span class="packt_screen">More tools</span> | <span class="packt_screen">Rendering</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f53648c6-4db3-45e8-a298-cae3f78393cc.png" style="width:40.08em;height:34.08em;" width="705" height="600"/></div>
<p>The preceding instructions will display a new panel with the title <span class="packt_screen">Rendering</span>. We must then enable the FPS meter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/3b0a2407-5332-4366-89f1-beb3791046cf.png" width="1238" height="454"/></div>
<p>The FPS meter should be displayed in the upper-right corner of the screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c826d45d-00fb-4ac2-9075-7197592357e5.jpg" style="width:17.92em;height:18.17em;" width="500" height="507"/></div>
<p>The FPS counter allows us to see the number of frames per second and the GPU memory being consumed.</p>
<div class="packt_figure"/>
<div class="packt_infobox">Some advanced WebGL applications may require an in-depth performance analysis. For such cases, Chrome provides the Trace Event Profiling Tool. If you wish to learn more about this tool, visit the official page at <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool"><span class="URLPACKT">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</span></a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CPU performance analysis</h1>
                </header>
            
            <article>
                
<p>To analyze the usage of the processing time, we will examine the call stack of our application. We will examine each of the functions invoked and how long it takes to complete their execution. We can access all this information by opening the <span class="packt_screen">Profiles</span> tab in the Google Chrome developer tools:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-299 image-border" src="Images/ad3e72f1-efae-46b7-956e-b1a6ed0b2d4a.png" style="width:161.00em;height:50.42em;" width="1932" height="605"/></div>
<p>In this tab, we can select <span class="packt_screen">Collect JavaScript CPU Profile</span> and then click on the <span class="packt_screen">Start</span> button to start recording the CPU usage. Being able to select when we want to start and stop recording the CPU usage helps us select the specific functions that we want to analyze. If, for example, we want to analyze a function named <kbd>foo</kbd>, all we need to do is start recording the CPU usage, invoke the <kbd>foo</kbd> function, and stop recording. A timeline like the one in the following screenshot will then be displayed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-300 image-border" src="Images/d3aec896-894c-4cad-bf08-92bde38c6d32.png" style="width:150.00em;height:57.25em;" width="1800" height="687"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Timeline</div>
<p>The timeline displays the functions invoked in chronological order (horizontal axis). The timeline also displays the call stack of these functions (vertical axis). When we hover over one of these functions, we will be able to see its details in the lower-left corner of the timeline:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-301 image-border" src="Images/762a4b61-4079-4882-99a2-678adad39ee5.png" style="width:31.25em;height:25.33em;" width="795" height="645"/></div>
<p>The details include the following information:</p>
<ul>
<li><span class="packt_screen">Name</span>: The name of the function</li>
<li><span class="packt_screen">Self-time</span>: The time spent on the completion of the current invocation of the function; we will consider the time spent in the execution of the statements within the function, not including any functions that it called</li>
<li><span class="packt_screen">Total time</span>: The total time spent on the completion of the current invocation of the function; we will consider the time spent in the execution of the statements within the function, including functions that it called</li>
<li><span class="packt_screen">Aggregated self-time</span>: The time for all invocations of the function across the recording, not including functions called by this function</li>
<li><span class="packt_screen">Aggregated total time</span>: The time for all invocations of the function across the recording, including functions called by this function</li>
</ul>
<p>As we have learned in the previous chapters, all the JavaScript code is executed in one single thread at runtime; for this reason, when a function is executed, no other function can be executed. When the execution of a function takes too long to be completed, the application becomes unresponsive.</p>
<p>We can solve this problem by reducing the amount of time required by the long-running function. We can use the CPU profile report to identify which functions are consuming too much processing time. Once we have identified these functions, we can refactor them to try to improve the application responsiveness. Some common improvements include using an asynchronous execution flow when possible, and reducing the size of the functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memory performance analysis</h1>
                </header>
            
            <article>
                
<p>When we declare a variable, it is allocated in the RAM. Sometime after, the variable is out of the scope; it is cleared from memory by the garbage collector. Sometimes, we can generate a scenario in which a variable never goes out of scope. If the variable never goes out of scope, it will never be cleared from the memory. This can eventually lead to some serious memory leaking issues. A <strong>memory leak</strong> is the continuous loss of available memory.</p>
<p>When dealing with memory leaks, we can take advantage of the Google Chrome developer tools to identify the cause of the problem with ease.</p>
<p>The first thing that we might wonder is whether our application has memory leaks. We can find out by visiting the timeline and clicking on the upper-left icon to start recording the resource usage. Once we stop recording, a timeline graph like the one in the following screenshot will be displayed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-302 image-border" src="Images/60105d50-7848-450b-b035-9809e999a5a3.png" style="width:150.00em;height:36.33em;" width="1800" height="436"/></div>
<p>In the timeline, we can select <span class="packt_screen">Memory</span> to see the memory usage (<span class="packt_screen">Used JS Heap</span>) over time (blue line in the screenshot). In the preceding example, we can see a notable drop towards the end of the line. That is a good sign because it indicates that most of the used memory has been cleared when the page has finished loading.</p>
<p>The memory leaks can also take place after loading; in that case, we can use the application for a while and observe how the memory usage varies in the graph to identify the cause of the leak.</p>
<p>An alternative way to detect memory leaks is by observing the memory allocations. We can access this information by recording the heap allocations in the <span class="packt_screen">Memory</span> tab<span class="MsoCommentReference">:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/7c5511ce-333a-4a34-a810-275a1916df3a.png" width="1311" height="522"/></div>
<p>The report will be displayed after we have recorded some usage of the resources. We can do this by selecting <span class="packt_screen">Record allocation timeline</span> and clicking on the <span class="packt_screen">Stake snapshot</span> button. We then need to stop recording by clicking on the red dot displayed on the upper-left side of the development tools.</p>
<p>The memory allocation report will display a timeline like the one in the following screenshot. Each of the blue lines is a memory allocation that took place during the recorded period. The height of the line represents the amount of memory used. As we can see, the memory is almost cleared completely around the eighth second:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/e9ebd42f-221a-4b8d-8fbb-d97dc4182f41.png" style="width:43.33em;height:30.83em;" width="968" height="690"/></div>
<p>If we click on one of the blue lines, we will be able to navigate through all the variables that were stored in memory when the allocation took place and examine their values. It is also possible to take a memory snapshot at any given point from the <span class="packt_screen">Profiles</span> tab:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/66c927aa-c944-4602-9031-03aac884446a.png" width="1517" height="102"/></div>
<p>This feature is particularly useful when we are debugging and we want to see the memory usage at a breakpoint. The memory snapshot works like the details view in the previously explained allocations view:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/439f929c-a983-4265-a3e7-2aae4a9729f3.png" style="width:35.83em;height:34.58em;" width="916" height="884"/></div>
<p>As we can see in the preceding screenshot, the memory snapshot allows us to navigate through all the variables that were stored in memory when the snapshot was taken and examine their values.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The garbage collector</h1>
                </header>
            
            <article>
                
<p>Programming languages with a low level of abstraction have low-level memory management mechanisms. On the other hand, in languages with a higher level of abstraction, such as C# or JavaScript, the memory is automatically allocated and freed by a process known as the garbage collector.</p>
<p>The JavaScript garbage collector does a great job when it comes to memory management, but it doesn't mean that we don't need to care about memory management.</p>
<p>Independent of which programming language we are working with, the memory life cycle pretty much follows the same pattern:</p>
<ul>
<li>Allocate the memory you need</li>
<li>Use the memory (read/write)</li>
<li>Release the allocated memory when it is not needed anymore</li>
</ul>
<p>The garbage collector will try to release the allocated memory when is not needed anymore, using a variation of an algorithm known as the <strong>mark-and-sweep algorithm</strong>. The garbage collector performs periodical scans to identify objects that are out of the scope and can be freed from the memory. The scan is divided into two phases: the first one is known as a <strong>mark,</strong> because the garbage collector will flag or mark the items that can be freed from memory. During the second phase, known as a <strong>sweep</strong>, the garbage collector will free the memory consumed by the items marked in the previous phase.</p>
<p>The garbage collector is usually able to identify when an item can be cleared from the memory; but we, as developers, must try to ensure that objects get out of scope when we don't need them anymore. If a variable never gets out of the scope, it will be allocated in memory forever, potentially leading to a severe memory leak issue.</p>
<p>The number of references pointing to an item in memory will prevent it from being freed from memory. For this reason, most cases of memory leaks can be fixed by ensuring that there are no permanent references to variables. Here are a few rules that can help us to prevent potential memory leak issues:</p>
<ul>
<li>Remember to clear intervals when you don't need them anymore</li>
<li>Remember to clear event listeners when you don't need them anymore</li>
<li>Remember that when you create a closure, the inner function will remember the context in which it was declared, which means that there will be some extra items allocated in memory</li>
<li>Remember that when using object composition, if circular references are created, you can end up having some variables that will never be cleared from memory</li>
</ul>
<p>It is important to mention that Node.js processes assume that there will be at least 1.5 GB of RAM available, which can cause some problems when the system has less than 1.5 GB of RAM available because the garbage collector will not try to free any unused memory until the process has consumed almost 1.5 GB of RAM. If only 1 GB is available, the process will crash, because we will run out of memory before the garbage collector tries to clean the unused memory. We can solve this problem using the <kbd>max_old_space_size</kbd> flag:</p>
<pre><strong>node --max_old_space_size=1024 server.js --production</strong> </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance analysis in Node.js applications</h1>
                </header>
            
            <article>
                
<p>We have learned how to use the Google Chrome development tools to analyze frontend application. However, the same tools can also be used to analyze backend applications powered by Node.js.</p>
<p>To use the Google Chrome development tools to analyze a Node.js application, we need to start the Node.js application using the <kbd>--inspect</kbd> flag:</p>
<pre><strong>ts-node --inspect main.ts </strong> </pre>
<p>Then we need to visit the <kbd>chrome://inspect</kbd> URL using Google Chrome.</p>
<p>If everything went well, we should be able to see the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f0badd2f-5691-485a-9243-42c56c9458ca.png" style="width:36.33em;height:18.75em;" width="1096" height="566"/></div>
<p>We then need to click on the <span class="packt_screen">inspect</span> link, which should be available under the <span class="packt_screen">Remote Target</span> section. A new window should be opened then. The window will display the Google Chrome developer tools, ready to analyze the Node.js application.</p>
<div class="packt_infobox">Alternatively, we can use the <strong>Node.js V8 --inspector Manager</strong> (<strong>NiM</strong>) extension for Google Chrome, which allows us to access the Node.js inspector more easily. You can download the extension by visiting <span class="URLPACKT"><a href="https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj">https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj</a>.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance automation</h1>
                </header>
            
            <article>
                
<p>In this section, we will understand how we can automate many of the performance optimization tasks, from concatenation and compression of contents to the automation of the performance monitoring and performance testing processes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance optimization automation</h1>
                </header>
            
            <article>
                
<p>After analyzing the performance of our application, we will start working on some performance optimizations. Many of these optimizations involve the concatenation and compression of some of the application's components.</p>
<p>We will also have to create a new version of the concatenated and compressed contents every time one of the original components (not concatenated and not compressed) changes. Because these include many highly repetitive tasks, we can use tools like Gulp or Webpack to perform many of these tasks for us.</p>
<p>We can use these tools to concatenate and compress components, optimize images, generate a cache manifest file, and perform many other performance optimization tasks.</p>
<div class="packt_infobox">If you would like to learn more about Gulp and Webpack, refer to <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Automating Your Development Workflow</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance monitoring automation</h1>
                </header>
            
            <article>
                
<p>We have seen that we can automate many of the performance optimization tasks using the Gulp task runner. Similarly, we can also automate the performance monitoring process.</p>
<p>To monitor the performance of an existing application, we will need to collect some data that will allow us to compare the application performance over time. Depending on how we collect the data, we can identify three different types of performance monitoring:</p>
<ul>
<li><strong>Real user monitoring</strong> (<strong>RUM</strong>): This is a type of solution used to capture performance data from real user visits. The collection of data is performed by a small JavaScript code snippet loaded in the browser. This type of solution can help us to collect data and discover performance trends and patterns.</li>
<li><strong>Simulated browsers</strong>: This type of solution is used to capture performance data from simulated browsers, which is the cheaper option, but it is limited, because simulated browsers cannot offer as accurate a representation of the real user experience.</li>
<li><strong>Real-browser monitoring</strong>: This is used to capture performance data of real browsers. This information provides a more accurate representation of the real user experience, as the data is collected using exactly what a user would see if he or she visited the site with the given environment (browser, geographic location, and network throughput).</li>
</ul>
<p>Web browsers can be configured to generate <strong>HTTP Archive</strong> (<strong>HAR</strong>) files. A HAR file uses a common format for recording HTTP tracing information. This file contains a variety of information, but, for our purposes, it has a record of each object being loaded by a browser.</p>
<p>There are multiple scripts available online that showcase how to collect the data. One of the examples, <kbd>netsniff.js</kbd>, exports the network traffic in HAR format. The <kbd>netsniff.js</kbd> file (and other examples) can be found at <a href="https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js"><span class="URLPACKT">https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js</span></a>.</p>
<p>Once we have generated the HAR files, we can use another application to see the collected performance information in a visual timeline. This application is called HAR Viewer and can be found at <a href="https://github.com/janodvarko/harviewer"><span class="URLPACKT">https://github.com/janodvarko/harviewer</span></a>.</p>
<p>Alternatively, we could write a custom script or Gulp task to read the HAR files and break the automated build if the application performance doesn't meet our needs.</p>
<p>It is also possible to run the YSlow performance analysis report and integrate it with the automated build.</p>
<div class="packt_infobox">If you are considering using RUM, look at the New Relic solutions at <a href="http://newrelic.com/"><span class="URLPACKT">http://newrelic.com/</span></a> or Google Analytics at <a href="http://www.google.com/analytics/"><span class="URLPACKT">http://www.google.com/analytics/</span></a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Performance testing automation</h1>
                </header>
            
            <article>
                
<p>Another way to improve the performance of an application is to write automated performance tests. These tests can be used to guarantee that the system meets a set of performance goals. There are multiple types of performance testing, but some of the most common ones include the following:</p>
<ul>
<li><strong>Load testing</strong>: This is the most basic form of performance testing. We can use a load test to understand the behavior of the system under a specific expected load (number of concurrent users, number of transactions, and duration).</li>
<li><strong>Stress testing</strong>: This is normally used to understand the maximum capacity limits of an application. This kind of test determines if an application can handle an extreme number of requests. Stress testing is not useful when working on a client-side application. However, it can be helpful when working on a Node.js application, since Node.js applications can have many simultaneous users.</li>
<li><strong>Soak testing</strong>: Also known as endurance testing. This kind of test is like the stress test, but instead of using an extreme load, it uses the expected load for a continued period. It is a common practice to collect memory usage data during this kind of test to detect potential memory leaks. This kind of test helps us to tell if the performance suffers degradation after a continued period.</li>
<li><strong>Spike testing</strong>: This is also like the stress test, but instead of using an extreme time load during a continued period, it uses sudden intervals of the extreme and expected load. This kind of test helps us to determine if an application can handle dramatic changes in load.</li>
<li><strong>Configuration testing</strong>: This is used to determine the effects of configuration changes to the performance and behavior of an application. A common example would be experimenting with different methods of load balancing.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exception handling</h1>
                </header>
            
            <article>
                
<p>Understanding how to use the available resources efficiently will help us to create better applications. Similarly, understanding how to handle runtime errors will help us to improve the overall quality of our applications. Exception handling in TypeScript involves three main language elements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Error class</h1>
                </header>
            
            <article>
                
<p>When a runtime error takes place, an instance of the <kbd>Error</kbd> class is thrown:</p>
<pre>throw new Error(); </pre>
<p>We can create custom errors in a couple of different ways. The easiest way to achieve it is by passing a string as an argument to the <kbd>Error</kbd> class constructor:</p>
<pre>throw new Error("My basic custom error"); </pre>
<p>If we need more customizable and advanced control over custom exceptions, we can use inheritance to achieve it:</p>
<pre>export class Exception extends Error { 
 
    public constructor(public message: string) { 
        super(message); 
        // Set the prototype explicitly. 
        Object.setPrototypeOf(this, Exception.prototype); 
    } 
    public sayHello() { 
        return `hello ${this.message}`; 
    } 
} </pre>
<p>In the preceding code snippet, we have declared a class named <kbd>Exception</kbd>, which inherits from the <kbd>Error</kbd> class. In the class constructor, we have set the prototype explicitly. This is a requirement since TypeScript 2.1, caused by some limitations. You can learn more details about this limitation at <a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work"><span class="URLPACKT">https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work</span></a><span class="URLPACKT">.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The try...catch statements and throw statements</h1>
                </header>
            
            <article>
                
<p>A <kbd>catch</kbd> clause contains statements that specify what to do if an exception is thrown in the <kbd>try</kbd> block. We should perform some operations in the <kbd>try</kbd> block and, if they fail, the program execution flow will move from the <kbd>try</kbd> block to the <kbd>catch</kbd> block. Additionally, there is an optional block known as <kbd>finally</kbd>, which is executed after both the <kbd>try</kbd> and <kbd>catch</kbd> (if there was an <kbd>exception</kbd> in the <kbd>catch</kbd>) blocks:</p>
<pre>try { 
    // code that we want to work 
    throw new Error("Oops!"); 
} 
catch (e) { 
    // code executed if expected to work fails 
    console.log(e); 
} 
finally { 
    // code always executed after try or try and catch (when <br/>     errors) 
    console.log("finally!"); 
} </pre>
<p>It is also important to mention that in the majority of programming languages, including TypeScript, throwing and catching exceptions is an expensive operation regarding resource consumption. We should use these statements if we need them, but sometimes it is necessary to avoid them because they can potentially negatively affect the performance of our applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned what performance is and how the availability of resources can influence it.</p>
<p>We have also learned how to use some tools to analyze the way a TypeScript application uses available resources. These tools allow us to spot some possible issues, such as a low frame rate, memory leaks, and high loading times. We have also discovered that we can automate many kinds of the performance optimization tasks as well as the performance monitoring and testing processes.</p>
<p>In the following chapter, we are going to learn how we can automate the testing process of our TypeScript applications to achieve great application maintainability and reliability.</p>


            </article>

            
        </section>
    </div>



  </body></html>