<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-211" class="chapter-number"><a id="_idTextAnchor218"/>8</h1>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor219"/>Testing in Node.js</h1>
			<p>Testing is one of the most relevant practices these days; it has become much more popular in the last couple of decades than in the past. Today, we build complex software with many dependencies and requirements that evolve over time. I strongly believe that testing is key when you are learning a new language or tool because it will provide you with a security net that will allow you to take more risks and move faster without breaking the <span class="No-Break">previous code.</span></p>
			<p>In this chapter, we will dive into the importance of testing and how to choose the right type of testing for your application. You will write your first test, and then we will learn about creating test suites by grouping related tests, demonstrating both Node.js core testing and the <span class="No-Break">Jest library.</span></p>
			<p>Writing good tests is not easy, but by the end of this chapter, you will have a clear idea of what principles to follow every time and how you can use a testing coverage tool to extend and refactor your tests <span class="No-Break">over time.</span></p>
			<p>Finally, we will introduce <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) by solving some <span class="No-Break">edge cases.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Why is <span class="No-Break">testing important?</span></li>
				<li>Test approach <span class="No-Break">and philosophy</span></li>
				<li>How should I test <span class="No-Break">my code?</span></li>
				<li>Writing our first <span class="No-Break">test suite</span></li>
				<li>Mastering code <span class="No-Break">coverage tooling</span></li>
				<li>TDD <span class="No-Break">in action</span></li>
			</ul>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor220"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/aK572sFboEM"><span class="No-Break">https://youtu.be/aK572sFboEM</span></a></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor221"/>Why is testing important?</h1>
			<p>As we saw in the previous <a id="_idIndexMarker405"/>chapters, modern applications are complex, have many moving parts, and will <span class="No-Break">have dependencies.</span></p>
			<p>Overall, we can say that testing is important because it helps us to ensure that our code is working as expected and that we are not introducing bugs when we are adding new features or <span class="No-Break">fixing bugs.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor222"/>Testing is a complex culture</h2>
			<p>Testing is much more than just writing some code to validate your application. It’s a culture that has many ideas, principles, practices, and tools... Have you heard of TDD? BDD? Unit tests? Integration tests? End-to-end tests? Mocks? Stubs? Spies? There are many concepts to learn and understand, and we will explore some of them in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor223"/>Testing has to be a team activity</h2>
			<p>Testing will help you to onboard new developers to your team easily. You can join other teams to help them build new features or fix bugs even if you don’t know the code base <span class="No-Break">in depth.</span></p>
			<p>I love to see tests as documentation for the application, or even better, as the agreement to the world of how your application should behave in <span class="No-Break">certain scenarios.</span></p>
			<p>But testing is a team effort. It’s not just the developer’s responsibility to write tests, the same way that it’s not just the developer’s responsibility to write secure code. The whole team should be involved in the process, and the team should have a culture of testing and stick to it <span class="No-Break">over time.</span></p>
			<p>Automating your tests is essential. Without automation, we would need to test our applications manually. It means that we will do a lot of repetitive tasks that are prone to errors, and we will need to spend a lot of time ensuring that our application is working <span class="No-Break">as expected.</span></p>
			<p>With tests, we can automate<a id="_idIndexMarker406"/> the process and ensure that our application is working as expected. We can run the tests on our local machine, or on a remote machine before a pull request is merged or we deploy the software. We can run the tests in different environments, and we can run them in parallel to speed up <span class="No-Break">the process.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor224"/>Take advantage now</h2>
			<p>I am used to doing tests in my day-to-day work, and I can say that they’re a great tool that has helped me to build better software. But overall, they have helped me to learn new things and improve <span class="No-Break">my skills.</span></p>
			<p>When you must use a new language or tool, you can use tests to learn how it works and explore the features. You can use tests to learn how this new thing works and do your own experiments <span class="No-Break">while learning.</span></p>
			<p>But if you are not used to doing tests, it can be a little bit hard to learn Node.js and testing at the same time. So, I recommend you learn Node.js first and then take a more in-depth look <span class="No-Break">at testing.</span></p>
			<p>In the next chapters, we will build a web application and use tests to ensure that our application is working <span class="No-Break">as expected.</span></p>
			<p>You will face many challenges while adopting the testing culture. As with any cultural change, it’s not easy to start doing tests. It’s a challenge that you will need to overcome, and you will need to invest time to learn how to do it. But I can say that it’s <span class="No-Break">worth it.</span></p>
			<p>If you work with a team, you will need to convince your team to start doing tests and consolidate the culture over time. It’s not easy, but <span class="No-Break">it’s possible.</span></p>
			<p>You can always start doing tests in your own code and show the benefits to your team. You can start with a pet project or a proof-of-concept test and convince the <span class="No-Break">whole team.</span></p>
			<p>Note that you will need to invest time to learn how to do it, and even when you know how to do it, you will need to invest time to write the tests. That time will always be bigger in comparison with the time that you will need to just write the code. But you will save time in the long term when you need to fix bugs or add new features and in preventing bugs in the <span class="No-Break">first place.</span></p>
			<p>Now that we are clear on the <a id="_idIndexMarker407"/>motivations behind the adoption of testing, it is time to learn, in the next section, about the different types of tests that are available for our applications and how other industries have built solid products using different <span class="No-Break">testing frameworks.</span></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor225"/>Testing approach and philosophy</h1>
			<p>One of the things that we don’t realize when we are starting to learn about testing is that there are many different kinds of tests, and each one has a <span class="No-Break">different purpose.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor226"/>Testing is wildly used in the world</h2>
			<p>In the real world, testing<a id="_idIndexMarker408"/> is used in many industries. For example, if we want to test the quality of a car being manufactured in a factory, we can do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Test the engine <span class="No-Break">in isolation</span></li>
				<li>Test the car in a controlled environment to ensure that it’s working <span class="No-Break">as expected</span></li>
				<li>Test the car in a real environment to ensure that it’s working <span class="No-Break">as expected</span></li>
				<li>Test the individual components of the car to ensure certain <span class="No-Break">quality standards</span></li>
				<li>Test the car against a wall or other objects to ensure that <span class="No-Break">it’s safe</span></li>
				<li>The automobile industry has one of the most interesting testing frameworks in terms of engineering in the world. Most cars that are manufactured today, for the vast majority of end users, were previously tested in many ways, including crash simulations to evaluate the potential damages. In the following figure, you can see how one of <span class="No-Break">these tests</span></li>
			</ul>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B21678_08_01.jpg" alt="Figure 8.1 – Image by Wikimedia https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Image by Wikimedia <a href="https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg">https://en.wikipedia.org/wiki/Crash_test#/media/File:Honda_Fit-Impact_Still.jpg</a></p>
			<p>Software products are no different. Just to give<a id="_idIndexMarker409"/> you an idea, we can test the web application components in isolation, or we can test the whole application from the perspective of the end user. There’s also the option to just test the performance of our application by making a lot of requests with different structures to our application and detecting any bottlenecks and inefficiencies. We can even test the security of our application by doing penetration tests and trying to hack <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor227"/>The test pyramid</h2>
			<p>So, we can say that there<a id="_idIndexMarker410"/> are many different types of tests and each one has a different purpose. Let’s have a look at the <span class="No-Break">test pyramid:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B21678_08_02.jpg" alt="Figure 8.2 – Image by Martin Fowler in “The practical test pyramid” https://martinfowler.com/articles/practical-test-pyramid.html"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Image by Martin Fowler in “The practical test pyramid” <a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a></p>
			<p>As we can see, the base of the pyramid is unit tests, which are more isolated and faster to run. At the top of the pyramid, we have UI tests, which are more expensive (as they require more integration) and are slower <span class="No-Break">to run.</span></p>
			<p>Using the car example, we can say that unit tests are like testing the engine in isolation, and UI tests are like testing the car in a <span class="No-Break">real environment.</span></p>
			<p>We can easily understand that testing the engine in isolation is faster and cheaper than testing the car in a real environment because we don’t need to build the whole car to test the engine, prepare paperwork, coordinate with the insurance companies, or bring on more staff such as drivers and mechanics. Also, testing the car in a real environment can lead to impacts by external factors such as the weather, traffic, and <span class="No-Break">road conditions.</span></p>
			<p>In comparison, we can just build the engine and test it in isolation inside the factory with the tools and necessary people. We can do it faster and cheaper, but this test won’t be able to detect some issues that we can have when we are testing the car in a <span class="No-Break">real environment.</span></p>
			<p>So, in the same way, we can say that unit tests are faster and cheaper to run than UI tests, but UI tests will be able to detect some issues that we can’t detect with <span class="No-Break">unit tests.</span></p>
			<p>In this chapter, we will focus on unit tests, but we will have a look at other types of tests as well in the following chapters when we will build the <span class="No-Break">web application.</span></p>
			<p>Now that we are clear on the different<a id="_idIndexMarker411"/> types of tests, it is time to be pragmatic and explore how to build our first test case using different libraries together in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor228"/>How should I test my code?</h1>
			<p>Due to the history of JavaScript, most<a id="_idIndexMarker412"/> developers didn’t have the culture of testing their code while JavaScript was limited to the browser and used almost exclusively to build relatively <span class="No-Break">simple scripts.</span></p>
			<p>However, with the evolution of the language and the community, we now have a lot of tools and frameworks to help us <span class="No-Break">build tests.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor229"/>Frameworks and libraries</h2>
			<p>When you have a clear idea<a id="_idIndexMarker413"/> of how to test<a id="_idIndexMarker414"/> your code, you can easily<a id="_idIndexMarker415"/> migrate from one tool<a id="_idIndexMarker416"/> to another until you find the one that fits your <span class="No-Break">needs best.</span></p>
			<p>In this chapter, we will explore the promising Node.js test core library and the most popular test framework for web <span class="No-Break">development, Jest.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">We are living in a transitional period where the Node.js core library is evolving to provide a better experience to developers. So, probably in the future, it will be the default tool to use. But for now, if you are new to testing, I recommend you use Jest because there are more tutorials and blog posts and the API is <span class="No-Break">more stable.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor230"/>Our first test</h2>
			<p>Let’s have a look<a id="_idIndexMarker417"/> at a simple test, and then we’ll explore the different parts <span class="No-Break">of it:</span></p>
			<pre class="source-code">
import { describe, it } from 'node:test';
import assert from 'node:assert';
const sum = (a, b) =&gt; a + b;
describe('Utils Test Suite', () =&gt; {
  it('Should sum two numbers', () =&gt; {
    assert.strictEqual(sum(1, 2), 3);
  });
});</pre>			<p>In this example, we are testing the sum function. First, we import the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> functions from the <strong class="source-inline">node:test</strong> module. Then, we import the <strong class="source-inline">assert</strong> function from the <span class="No-Break"><strong class="source-inline">node:assert</strong></span><span class="No-Break"> module.</span></p>
			<p>The <strong class="source-inline">describe</strong> function is used to group tests. In this case, we are grouping all the tests related to the <span class="No-Break"><strong class="source-inline">utils</strong></span><span class="No-Break"> module.</span></p>
			<p>The <strong class="source-inline">it</strong> function is used to define a test. In this case, we are defining a test that should sum <span class="No-Break">two numbers.</span></p>
			<p>Finally, we are using the <strong class="source-inline">assert</strong> function to check that the result of the <strong class="source-inline">sum</strong> function is the <span class="No-Break">expected</span><span class="No-Break"><a id="_idIndexMarker418"/></span><span class="No-Break"> one.</span></p>
			<p>So, we can say that a test is composed of <span class="No-Break">three parts:</span></p>
			<ul>
				<li><strong class="bold">Arrange</strong>: Where we define the data<a id="_idIndexMarker419"/> that we need to run <span class="No-Break">the test</span></li>
				<li><strong class="bold">Act</strong>: Where we run the code<a id="_idIndexMarker420"/> that we want <span class="No-Break">to test</span></li>
				<li><strong class="bold">Assert</strong>: Where we check that the result<a id="_idIndexMarker421"/> of the code is the <span class="No-Break">expected one</span></li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor231"/>Testing principles and goals</h2>
			<p>There are some principles that we should<a id="_idIndexMarker422"/> follow when we are building tests. For me, these principles can be summarized into three goals, which are fast, trustable, <span class="No-Break">and maintainable.</span></p>
			<h3>Fast</h3>
			<p>The tests should be fast<a id="_idIndexMarker423"/> to run and write. We will run this test many times, so if the test is slow to run, we will lose a lot of time waiting for it to finish. But the worst part is that we will be tempted to run the test less frequently or write <span class="No-Break">fewer tests.</span></p>
			<p>Then, testing will be a frustrating experience for you and your team. In small projects, you will have a few dozen tests, but in big projects, you can have thousands <span class="No-Break">of tests.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you have a test that on average takes one second to run, you will lose one second every time you run the test. If you have 1,000 tests, you will lose 1,000 seconds, which is more than 16 minutes! In most cases, you will have the option to use concurrency and run the tests in parallel, so the total time will be much lower. But it requires<a id="_idIndexMarker424"/> an extra step to set <span class="No-Break">up (</span><a href="https://nodejs.org/api/test.html#runoptions"><span class="No-Break">https://nodejs.org/api/test.html#runoptions</span></a><span class="No-Break">).</span></p>
			<p>You will need to dedicate time and resources to refactor and improve your tests in big projects<a id="_idIndexMarker425"/> to keep <span class="No-Break">them fast.</span></p>
			<h3>Trustable</h3>
			<p>The tests should be trustable. If you have<a id="_idIndexMarker426"/> flaky tests (that is, tests that fail randomly), your team will be very frustrated and will lose confidence in <span class="No-Break">the tests.</span></p>
			<p>In order to avoid this situation, we should follow <span class="No-Break">these principles:</span></p>
			<ul>
				<li><strong class="bold">Isolated</strong>: We need to isolate the tests from external factors such as the network, filesystem, database, <span class="No-Break">and time</span></li>
				<li><strong class="bold">Repeatable and deterministic</strong>: We need to be able to run the tests many times and get the <span class="No-Break">same results</span></li>
				<li><strong class="bold">Self-contained and independent</strong>: We need to be able to run any tests in isolation and get the <span class="No-Break">same results</span></li>
			</ul>
			<h3>Maintainable</h3>
			<p>Tests are code as well, so we need to maintain<a id="_idIndexMarker427"/> them in the same way as we maintain our production code. We should follow <span class="No-Break">these principles:</span></p>
			<ul>
				<li><strong class="bold">Readable and explicit</strong>: Tests should be easy to read and understand. They have to be flexible in order to evolve with the code that we <span class="No-Break">are testing.</span></li>
				<li><strong class="bold">Focused</strong>: A single test should test a single thing. If we have a test that is testing more than one thing, we won’t be able to know exactly what <span class="No-Break">is failing.</span></li>
				<li><strong class="bold">Small and simple</strong>: It is better to have many small and simple tests than a few big and <span class="No-Break">complex tests.</span></li>
			</ul>
			<p>Congratulations! You wrote your first test and now the mechanics should be clearer. In the next section, we will learn how we can build a full test suite to cover multiple cases and how to automate <span class="No-Break">some steps.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor232"/>Writing our first test suite</h1>
			<p>In this section, we will build our first <a id="_idIndexMarker428"/>test suite. We will build a test suite for the <strong class="source-inline">utils</strong> module that we created and published in the <span class="No-Break">previous chapter.</span></p>
			<p>We will use the <strong class="source-inline">node:test</strong> and <strong class="source-inline">node:assert</strong> modules to build our test suite, and then we will build the same tests using the J<strong class="source-inline">est</strong> framework, so we can compare both approaches and see <span class="No-Break">the differences.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor233"/>Utils module</h2>
			<p>Let’s start by creating a new folder<a id="_idIndexMarker429"/> and then initialize a new Node.js project with <strong class="source-inline">npm init</strong>. Then we will create a <strong class="source-inline">utils.js</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
export const sum = (a, b) =&gt; a + b
export const multiply = (a, b) =&gt; a * b</pre>			<p>The code is very simple. The <strong class="source-inline">sum</strong> function will sum two numbers and the <strong class="source-inline">multiply</strong> function will multiply two numbers. Then the tests should be very simple <span class="No-Break">as well.</span></p>
			<p>Basically, we need to test that the <strong class="source-inline">sum</strong> function is summing two numbers and the <strong class="source-inline">multiply</strong> function is multiplying <span class="No-Break">two numbers.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor234"/>Test core library</h2>
			<p>Recently, Node.js has introduced<a id="_idIndexMarker430"/> a new core library to help us to build tests. This library is called <strong class="source-inline">assert</strong> and it’s a core library, so we don’t need to install it. We can just import it and <span class="No-Break">use it.</span></p>
			<h3>Adding the npm scripts</h3>
			<p>Let’s add the following NPM scripts<a id="_idIndexMarker431"/> to our <strong class="source-inline">package.json</strong> file and add <strong class="source-inline">type:"module"</strong> <span class="No-Break">as well:</span></p>
			<pre class="source-code">
{
  "type": "module",
  "scripts": {
    "node-test": "node --test node_test/"
  }
}</pre>			<p>In this case, we have chosen <strong class="source-inline">type: "module"</strong> to enable the ESM syntax by default, so we can use the import<a id="_idIndexMarker432"/> keyword in the files directly. You can find more information about<a id="_idIndexMarker433"/> how to import modules in <a href="B21678_06.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break"><em class="italic">.</em></span></p>
			<h3>Adding the test suite</h3>
			<p>Let’s create<a id="_idIndexMarker434"/> a new folder, <strong class="source-inline">node_test</strong>, and include a new file, <strong class="source-inline">utils.test.js</strong>, inside it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { describe, it } from "node:test";
import assert from "node:assert";
import { sum, multiply } from "../utils.js";
describe("Utils Test Suite: sum", () =&gt; {
  it("Should sum two numbers", () =&gt; {
    assert.strictEqual(sum(1, 2), 3);
  });
});
describe("Utils Test Suite: multiply", () =&gt; {
  it("Should multiply two numbers", () =&gt; {
    assert.strictEqual(multiply(5, 3), 15);
  });
});</pre>			<p>It is important to notice that we are using <strong class="source-inline">../</strong> to refer to parent directories from the current file. That way, we can import<a id="_idIndexMarker435"/> files from anywhere on the computer. It is also possible to use the absolute path to a specific resource. You can find more details<a id="_idIndexMarker436"/> about the differences <span class="No-Break">at </span><a href="https://www.redhat.com/sysadmin/linux-path-absolute-relative"><span class="No-Break">https://www.redhat.com/sysadmin/linux-path-absolute-relative</span></a><span class="No-Break">.</span></p>
			<h3>Running the tests</h3>
			<p>Now, we can run the tests <a id="_idIndexMarker437"/>with the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm run node-test</pre>			<p>We should see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B21678_08_03.jpg" alt="Figure 8.3 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Terminal output</p>
			<p>Notice that the terminal uses distinct colors to show us the results of the tests. In this case, we have two tests and both are passing. As you can see, the output is very simple and is using the texts that we defined in the <strong class="source-inline">describe</strong> and <span class="No-Break"><strong class="source-inline">it</strong></span><span class="No-Break"> functions.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor235"/>Using the Jest library</h2>
			<p>Jest is a JavaScript testing<a id="_idIndexMarker438"/> framework that is very popular in the JavaScript community. It’s very easy to use and has a lot of features that will help us to build and maintain our test suite, especially if you are doing frontend development using modern frameworks as libraries, such as Angular, React, <span class="No-Break">or Vue.</span></p>
			<h3>Installing Jest</h3>
			<p>The first step is to install <strong class="source-inline">Jest</strong> in our project<a id="_idIndexMarker439"/> as a development dependency. We can do it with the <span class="No-Break">following command:</span></p>
			<pre class="console">
npm install --save-dev jest@29</pre>			<h3>Configuring Jest</h3>
			<p>As we had the test previously<a id="_idIndexMarker440"/> set up for the Node.js core library, we will need to use a custom configuration for Jest. In a real project, we will use only one testing framework, and in that case, we can configure Jest using <strong class="source-inline">npx </strong><span class="No-Break"><strong class="source-inline">jest@29 --init</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">npx</strong> command will execute the <strong class="source-inline">Jest</strong> command that we have installed in our project. The <strong class="source-inline">--init</strong> flag will create a configuration file <span class="No-Break">for us.</span></p>
			<p>We will create a new file, <strong class="source-inline">jest.config.js</strong>, with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
export default {
    modulePathIgnorePatterns: ['&lt;rootDir&gt;/node_test/' ]
}</pre>			<p><strong class="source-inline">modulePathIgnorePatterns</strong> will ignore the <strong class="source-inline">node_test</strong> folder, so we can ignore the tests that we have created with the Node.js core library. <strong class="source-inline">&lt;rootDir&gt;</strong> is a reference to the folder where <strong class="source-inline">jest.confg.js </strong>is in this case, so it is easier to reference <span class="No-Break">other resources.</span></p>
			<p>As Jest does not support ESM modules yet, we<a id="_idIndexMarker441"/> will use Babel (<a href="https://babeljs.io/">https://babeljs.io/</a>) to transpile the code. We will create a new file, <strong class="source-inline">.babelrc</strong>, with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
{
  "presets": ["@babel/preset-env"]
}</pre>			<p>We will install the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker442"/></span><span class="No-Break"> dependencies:</span></p>
			<pre class="console">
npm i -D @babel/preset-env@7</pre>			<h3>Adding the npm scripts</h3>
			<p>Let’s add the following <a id="_idIndexMarker443"/>npm scripts to our <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
  "scripts": {
    "node-test": "node --test node_test/",
    "jest-test": "jest"
  }
}</pre>			<h3>Adding the test suite</h3>
			<p>Let’s create a new <a id="_idIndexMarker444"/>folder, <strong class="source-inline">jest_test</strong>, and include a new file, <strong class="source-inline">utils.test.js</strong>, inside it with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { sum, multiply } from "../utils.js";
describe("Utils Test Suite: sum", () =&gt; {
  it("Should sum two numbers", () =&gt; {
    expect(sum(1, 2)).toBe(3);
  });
});
describe("Utils Test Suite: multiply", () =&gt; {
  it("Should multiply two numbers", () =&gt; {
    expect(multiply(5, 3)).toBe(15);
  });
});</pre>			<p>As you can see, the code is very similar to the code that we created for the Node.js core library. The only difference<a id="_idIndexMarker445"/> is in how we manage <span class="No-Break">the assertions.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note also that we are not importing the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> functions. This is because Jest provides these functions for us and we don’t need to <span class="No-Break">import them.</span></p>
			<h3>Running the tests</h3>
			<p>Now, we can run the tests<a id="_idIndexMarker446"/> with the following command: <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run jest-test</strong></span><span class="No-Break">.</span></p>
			<p>We should see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21678_08_04.jpg" alt="Figure 8.4 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Terminal output</p>
			<p>As you can see, the output is very similar to the output that we saw with the Node.js core library. The only difference is that the output is using different colors, and the text is slightly different. But the most important thing is that we have the <span class="No-Break">same information.</span></p>
			<p>Now we are quite confident about<a id="_idIndexMarker447"/> our tests, but when the source code is growing every day, you need an additional tool that helps you know what code has been covered by tests or not. So, in the next section, we will learn in detail how we can use the test coverage to generate reports that will help us to improve the tests in <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor236"/>Mastering code coverage tooling</h1>
			<p>When we are building a test<a id="_idIndexMarker448"/> suite, we need to make sure that we are covering all the code that is critical in scenarios that make sense for our purpose. This is called <strong class="bold">code coverage</strong> and it’s a very important metric to measure the quality of our <span class="No-Break">test suite.</span></p>
			<p>Some people say that we need to have 100% code coverage, but this is not always true or practical. In my opinion, code coverage is a metric that helps us to detect the code that is not covered by our tests or code that has <span class="No-Break">been over-tested.</span></p>
			<p>Overall, it is a metric that can help us to skim the code and detect potential tests that we need to add <span class="No-Break">or remove.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor237"/>Configuration</h2>
			<p>Historically, code coverage<a id="_idIndexMarker449"/> was a feature that was provided by third-party libraries<a id="_idIndexMarker450"/> such as Istanbul (<a href="https://istanbul.js.org/">https://istanbul.js.org/</a>). But now, Node.js and Jest provide this feature out of the box, so we don’t need to install any <span class="No-Break">third-party library.</span></p>
			<h3>Jest library</h3>
			<p>Let’s add the<a id="_idIndexMarker451"/> following<a id="_idIndexMarker452"/> npm script to our <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
  "scripts": {
    "node-test": "node --test node_test/",
    "jest-test": "jest",
    "jest-test:coverage": "jest --coverage"
  }
}</pre>			<h3>Node.js</h3>
			<p>Node.js has an<a id="_idIndexMarker453"/> experimental feature<a id="_idIndexMarker454"/> that we can use to generate code coverage. We need to use the <strong class="source-inline">--experimental-test-coverage</strong> flag to enable <span class="No-Break">this feature:</span></p>
			<pre class="source-code">
{
  "scripts": {
    "node-test": "node --test node_test/",
    "jest-test": "jest",
    "jest-test:coverage": "jest --coverage",
    "node-test:coverage": "node --test --experimental-test-coverage node_test/"
  }
}</pre>			<h2 id="_idParaDest-231"><a id="_idTextAnchor238"/>Running the tests</h2>
			<p>Let’s add a new <a id="_idIndexMarker455"/>function, <strong class="source-inline">substract</strong>, to our <span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
export const sum = (a, b) =&gt; a + b
export const multiply = (a, b) =&gt; a * b
export const subtract  = (a, b) =&gt; a - b</pre>			<p>Now, let’s run the code coverage for both Node.js and Jest to see <span class="No-Break">the results.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor239"/>Node.js report</h2>
			<p>By default, Node.js will <a id="_idIndexMarker456"/>generate a <strong class="source-inline">coverage</strong> folder with<a id="_idIndexMarker457"/> the results. We can open the <strong class="source-inline">index.html</strong> file in our browser to see <span class="No-Break">the results:</span></p>
			<pre class="console">
npm run node-test:coverage</pre>			<p>The output should be similar to the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B21678_08_05.jpg" alt="Figure 8.5 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Terminal output</p>
			<p>As you can see, we have 66.67% code coverage for the functions, as we don’t have any coverage for the <span class="No-Break"><strong class="source-inline">subtract</strong></span><span class="No-Break"> function.</span></p>
			<h3>Jest report</h3>
			<p>Running the code coverage<a id="_idIndexMarker458"/> with Jest<a id="_idIndexMarker459"/> is very similar to running <span class="No-Break">the tests:</span></p>
			<pre class="console">
npm run jest-test:coverage</pre>			<p>The output should be similar to the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21678_08_06.jpg" alt="Figure 8.6 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Terminal output</p>
			<p>As you can see, we have the same<a id="_idIndexMarker460"/> code coverage<a id="_idIndexMarker461"/> as with Node.js. This is because both tools are used in the same way to calculate the <span class="No-Break">code coverage.</span></p>
			<h3>Coverage UI report</h3>
			<p>In both cases, we have generated<a id="_idIndexMarker462"/> a <strong class="source-inline">coverage</strong> folder with<a id="_idIndexMarker463"/> the results. We can open the <strong class="source-inline">index.html</strong> file located in <strong class="source-inline">coverage/lcov-report</strong> in our browser to see <span class="No-Break">the results.</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21678_08_07.jpg" alt="Figure 8.7 Web browser report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 Web browser report</p>
			<p>We can explore in detail what is and is not covered <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21678_08_08.jpg" alt="Figure 8.8 – Web browser report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Web browser report</p>
			<p>As you can see, the <strong class="source-inline">subtract</strong> function is not covered by our tests. So, here we have the opportunity to improve <span class="No-Break">our tests.</span></p>
			<p>The code coverage report is a great way to understand your tests, especially when you are working with a large code base. So, I encourage you to use it as much <span class="No-Break">as possible.</span></p>
			<p>In the next section, we will change<a id="_idIndexMarker464"/> the approach. We are going<a id="_idIndexMarker465"/> to learn about the additional value that we receive when we define the tests before we write the code. While that might sound complicated, it will help you a lot to clarify what you need to build next and how to do it in a way where you can test it. You will be amazed at how much time you can save when you follow this approach. It is called <span class="No-Break">test-driven development.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor240"/>TDD in action</h1>
			<p>There are some edge cases<a id="_idIndexMarker466"/> that we are not covering in our <strong class="source-inline">utils</strong> module. For example, what happens if we pass a string to the <span class="No-Break"><strong class="source-inline">sum</strong></span><span class="No-Break"> function?</span></p>
			<pre class="source-code">
import { sum } from "../utils.js";
const result = sum("1", 2); // 12</pre>			<p>This is not the expected behavior when we use the <strong class="source-inline">sum</strong> function, so we need to <span class="No-Break">fix it.</span></p>
			<p>Let’s add some tests to cover these edge cases in our <span class="No-Break"><strong class="source-inline">jest-tests/utils.test.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
describe("Utils Test Suite: sum", () =&gt; {
  it("Should sum two numbers", () =&gt; {
    expect(sum(1, 2)).toBe(3);
  });
  it("Should throw an error if we don't provide a valid number", () =&gt; {
    expect(() =&gt; sum("1", 2)).toThrow("Please provide a valid number");
  });
});</pre>			<p>As you can see, we are using<a id="_idIndexMarker467"/> the <strong class="source-inline">toThrow</strong> matcher to test that the function is throwing an error. Now, let’s run the test coverage with <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run jest-test</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B21678_08_09.jpg" alt="Figure 8.9 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Terminal output</p>
			<p>Our new test is failing because our code didn’t meet our requirements, so let’s make some changes <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">utils.js</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export const sum = (a, b) =&gt; {
    if(typeof(a) !== 'number' || typeof(b) !== 'number') {
        throw new Error('Please provide a valid number')
    }
    return a + b
}
export const multiply = (a, b) =&gt; a * b
export const subtract  = (a, b) =&gt; a - b</pre>			<p>Now, let’s run the <span class="No-Break">tests again.</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B21678_08_10.jpg" alt="Figure 8.10 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Terminal output</p>
			<p>Our tests are passing again, so we can say that our code is working as expected. This interactive process of writing the tests first and then writing the code to make the tests pass is called test-driven development, <span class="No-Break">or TDD.</span></p>
			<p>While TDD is a vast topic, we can take<a id="_idIndexMarker468"/> this simple example as an exploratory introduction to the benefits of TDD without following it strictly. For example, we can test edge cases and then use them to improve <span class="No-Break">our code.</span></p>
			<p>I personally find TDD a great approach in Node.js, as it helps me a lot with dividing complex tasks into smaller pieces that have their own well-defined and tested functionality. While this may seem obvious to more senior developers, due to the nature of JavaScript, it is very easy to build overengineering solutions. Testing will help us a lot in <span class="No-Break">this matter.</span></p>
			<p>Also, testing can be a great ally when you are working in isolation, for example, when you need to build an HTTP API for a web application, but the frontend team is not planning to start until the API is ready. So, testing is a great way to validate the implementation with the frontend team. Also, tests are a great way to onboard new members to a team, as they can easily follow what is expected to happen in the application just by running and reading <span class="No-Break">the tests.</span></p>
			<p>For more advanced cases, it is also a great way<a id="_idIndexMarker469"/> to debug applications and recreate bugs reported by clients or team members. Overall, I think that the return on investment is very high, especially in dynamic languages such <span class="No-Break">as JavaScript.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor241"/>Summary</h1>
			<p>In this chapter, we learned about the testing principles and how we can combine different types of tests to build a robust test suite. We also explored how the test pyramid can help us to build a test suite that is easy to maintain <span class="No-Break">and understand.</span></p>
			<p>Additionally, we discussed the differences between unit tests and integration tests and how we can use them to test our code. We also explored strategies to evangelize testing in <span class="No-Break">our teams.</span></p>
			<p>After that, we explored how to add unit tests to our code using Node.js core modules <span class="No-Break">and Jest.</span></p>
			<p>Finally, we learned how to use code coverage as an interactive tool to help us refine our tests and keep our code base robust. Then, we did a little exercise using TDD to fix a bug in <span class="No-Break">our library.</span></p>
			<p>In the next chapter, we will explore how the HTTP protocol works in detail and how we can build RESTful APIs <span class="No-Break">with Node.js.</span></p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor242"/>Further reading</h1>
			<ul>
				<li><em class="italic">The Practical Test Pyramid by Martin </em><span class="No-Break"><em class="italic">Fowler</em></span><span class="No-Break">: </span><a href="https://martinfowler.com/articles/practical-test-pyramid.html"><span class="No-Break">https://martinfowler.com/articles/practical-test-pyramid.html</span></a></li>
				<li><em class="italic">Test-Driven Development // Fun TDD Introduction with </em><span class="No-Break"><em class="italic">JavaScript</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=Jv2uxzhPFl4"><span class="No-Break">https://www.youtube.com/watch?v=Jv2uxzhPFl4</span></a></li>
				<li><em class="italic">Delightful JavaScript Testing with </em><span class="No-Break"><em class="italic">Jest</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=cAKYQpTC7MA"><span class="No-Break">https://www.youtube.com/watch?v=cAKYQpTC7MA</span></a></li>
				<li><em class="italic">Migrating from Jest to Node.js Native Test Runner by Erick </em><span class="No-Break"><em class="italic">Wendel</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=2YfIB4gia60"><span class="No-Break">https://www.youtube.com/watch?v=2YfIB4gia60</span></a></li>
				<li><em class="italic">TDD, Where Did It All Go Wrong (Ian </em><span class="No-Break"><em class="italic">Cooper)</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=EZ05e7EMOLM"><span class="No-Break">https://www.youtube.com/watch?v=EZ05e7EMOLM</span></a></li>
				<li><em class="italic">Unit testing in JavaScript Part 1 - Why unit </em><span class="No-Break"><em class="italic">testing?</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=Eu35xM76kKY&amp;list=PL0zVEGEvSaeF_zoW9o66wa_UCNE3a7BEr"><span class="No-Break">https://www.youtube.com/watch?v=Eu35xM76kKY&amp;list=PL0zVEGEvSaeF_zoW9o66wa_UCNE3a7BEr</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer045" class="Content">
			<h1 id="_idParaDest-236" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor243"/>Part 3: Web Application Fundamentals</h1>
			<p>In <em class="italic">Part 3</em>, you will learn how web applications are built by using modern patterns and techniques that are adopted by most companies. You will also learn how to build solid <span class="No-Break">RESTful APIs.</span></p>
			<p>This part includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, <em class="italic">Handling HTTP and REST API</em></li>
				<li><a href="B21678_10.xhtml#_idTextAnchor267"><em class="italic">Chapter 10</em></a><em class="italic">, Building Web Applications with Express</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer046" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>