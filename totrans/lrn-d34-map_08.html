<html><head></head><body>
        

                            
                    <h1 class="header-title">Drawing with Canvas and D3</h1>
                
            
            
                
<p>So far you have used D3 to render your visualizations with mostly SVG, and sometimes HTML, elements. In this section, you will learn how to use HTML5 Canvas to draw and animate your visualizations. Canvas can be used as an alternative to SVG, especially if you want to render more elements on screen. You will get an overview of what Canvas is and how it compares with SVG. You will learn how to draw and animate with Canvas and how you can use D3 with it.</p>
<p>After covering the foundations, we will visualize flight paths first with SVG and then with Canvas to contrast and compare the two rendering approaches hands on. First and foremost, this will give you a practical understanding of how Canvas works as an alternative to SVG. Secondly, it will showcase how Canvas can solve problems you might have when animating thousands of points at once with SVG, as browsers are significantly faster in drawing a single picture of thousands of elements than in building, storing, and maintaining a tree of thousands of elements in memory.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Overview of Canvas and its tools: the Canvas context </li>
<li>How to use the tools to draw with Canvas</li>
<li>How to animate a drawing with Canvas</li>
<li>How to apply the D3 life cycle to individual parts of the Canvas drawing</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Canvas</h1>
                
            
            
                
<p>Before you start to draw with Canvas, let's have a brief look at its concept – the mental model that will help you approach, plan, and write your applications. Canvas in its material form is a single HTML5 element. It is literally a blank canvas that you can draw on. For the actual drawing, you use the <strong>Canvas context</strong> – the Canvas API. The context can be thought of as your toolbox that can be manipulated with JavaScript.</p>
<p>You can compare the Canvas element with the root SVG element, as both contain all parts of the drawing. However, the key difference is that SVG (like HTML) operates in <strong>retained mode</strong>. The browser retains a list of all objects drawn onto the SVG (or HTML) canvas within the <strong>Document Object Model</strong> (<strong>DOM</strong>) – the scene-graph of your web application. This makes your drawing almost material. You produce a list of objects, change styles and properties through code, and you can refer to these elements any time you desire. You can change their position, move them up or down the DOM and – very important for interaction – you can attach and remove event listeners to them easily.</p>
<p>Canvas, in contrast, operates in <strong>immediate mode</strong>. Anything you draw using Canvas occurs at once and remains on the canvas as an image. Images in Canvas are bitmaps, digital images composed of a matrix or grid of pixels. When you draw with Canvas you prepare the properties of each pixel (or rather specified regions of pixels) with your tools and then draw them on the canvas. If you want to change the color of one, a few, or all pixels on your image, you remove the whole image and produce a new image. Unlike SVG, you can't go back to the pixel you want to change, as it is not represented in memory in the form of a document tree or the like, but <em>burned</em> just once onto the screen. But fear not, you still have the Canvas context that represents the state of your tools, which indirectly represents the drawing itself.</p>
<p>You can think of Canvas as a painting and SVG or HTML as a Lego structure. The former is static in its representation. If you paint a man standing on a bridge screaming, you can't just turn his head around. You would have to draw a second painting to express this precisely. If you built the same scene with Lego, you could grab the head and turn it around, like so:</p>
<div><img height="362" width="488" src="img/18ca93ab-fcee-496c-9982-eddcfde75bdd.png"/></div>
<p>A dramatization of the immediate Canvas and the retained SVG  (SVG Image courtesy of Marco Pece www.udronotto.it)</p>
<p>This might sound cumbersome, considering the potential work that has to go into animating with Canvas. Not just the mental strain of having to paint so many pictures, but the computational powers required to redraw everything in quick succession. But, as you will see in the coming sections, there are simple patterns that make Canvas animated and interactive.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing with Canvas</h1>
                
            
            
                
<p>Before we come back to a more thorough comparison of SVG and Canvas and see concrete scenarios of when to use what, let's learn to draw with Canvas. We will start with a very simple example to understand the three main steps involved when drawing with Canvas. Then you will draw a set of shapes to get used to its toolbox.</p>
<p>As a side note, when working along and viewing the code examples, I highly recommend you use a recent Chrome browser. All code is tested across modern browsers but has been written with Chrome in mind, which therefore will be the safest browser to work with. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">The three drawing steps of every Canvas visual</h1>
                
            
            
                
<p>We can deconstruct a Canvas drawing into three simple steps:</p>
<ol>
<li><strong>Create</strong> the canvas and its context.</li>
<li><strong>Configure</strong> the context.</li>
<li><strong>Render</strong> the resulting bitmap.</li>
</ol>
<p>To mount the canvas within your DOM you create a <kbd>&lt;canvas&gt;</kbd> element in HTML:</p>
<pre>&lt;canvas id=”main-canvas” width = “600” height=”400”&gt;&lt;/canvas&gt;</pre>
<p>It will look empty, as expected:</p>
<div><img src="img/6fbdd403-bb07-4971-9b23-ae025dadf1e0.png"/></div>
<p>An empty Canvas element</p>
<p>This will be all the DOM you will see of your canvas. All other operations will happen via the Canvas context in JavaScript.</p>
<p>If you wanted to draw a rectangle in, say, <kbd>royalblue</kbd>, you would move onto JavaScript without looking back to the HTML and write:</p>
<pre class="mce-root">var canvas = d3.select('#main-canvas').node();<br/>var context = canvas.getContext('2d');<br/><br/>context.fillStyle = 'royalblue';<br/>context.fillRect(50, 50, 200, 100);</pre>
<p>You can find all code to this chapter at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a></p>
<p>Let's go through our first steps one by one:</p>
<ol>
<li>First, you reference the canvas in a variable. We'll use <kbd>d3.select()</kbd> to do so. As you will need a reference to the canvas element itself, not a selection, you should use D3's <kbd>selection.node()</kbd> method to grab the element itself. The next line references the drawing context to this specific canvas element. The context includes all the tools you can use to draw. You can <kbd>console.log(‘context')</kbd> to have a look at the context object:</li>
</ol>
<div><img height="251" width="760" src="img/25d94e62-a290-404d-9f71-8eadfc083561.png"/></div>
<p>The context object showing all properties</p>
<div><p style="padding-left: 90px">The context is called <kbd>CanvasRenderingContext2D</kbd> internally, but we will refer to it just as <kbd>context</kbd>. It holds all the properties you can manipulate to draw your visual. If you feel inclined you can also expand the <kbd>__proto__</kbd> object, which will show all methods available to you. We'll explain the key properties and methods as we go without diving into each individually. The important point of the context object is to understand that there's an object helping you to build your drawing. It stays at your side all along allowing you to use its methods and change its properties.</p>
</div>
<div><p style="padding-left: 30px">A great place to learn more about the context API, its properties, and methods is the documentation on the Mozilla Developer Network at <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.</a></p>
</div>
<p style="padding-left: 90px" class="NormalPACKT">At this point, you have the canvas to draw on and the drawing tools, but you still haven't drawn anything.</p>
<ol start="2">
<li>In the second step you prepare the drawing. You configure the context to produce the desired drawing. The example is purposefully simple in that the only configuration is to set the fill of our yet non-existent object to <kbd>royalblue</kbd>. Note that <kbd>context.fillStyle</kbd> is a property, not a method, of the Canvas context. It's like you are a painter telling your brush box what color you want to use for the object you paint next.</li>
</ol>
<ol start="3">
<li>This third step produces the following image. <kbd>context.fillRect()</kbd> takes four arguments: the <em>x</em> and the <em>y</em> position of the rectangle's starting point as well as the <kbd>width</kbd> and the <kbd>height</kbd>. Canvas – like SVG – uses a Cartesian co-ordinate system with the origin 0, 0 at the top-left corner increasing to the right and to the bottom. All values are given in pixels:</li>
</ol>
<div><img height="206" width="546" src="img/d2a012ff-fec0-4d76-8143-815ef901f406.png"/></div>
<p>A very royal blue Canvas rectangle</p>
<p style="padding-left: 60px">This rectangle is not present in the DOM. You can see its configuration in JavaSript and the canvas its drawn to in the DOM, but there's no <kbd>&lt;rect&gt;</kbd> element or the like we could refer to. Again, don't grow worry lines; we will get clever about how to re-address it in the next two chapters.</p>
<p>View this step in the browser: <a href="https://larsvers.github.io/learning-d3-mapping-8-1">https://larsvers.github.io/learning-d3-mapping-8-1</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_01.html">08_01.html</a>.</p>
<div><p>At the conclusion of each step you will find two links in an info box close to the the relevant image. The first link brings you to a working implementation of this step that you can view in the browser. The second <em>code example</em> link brings you to the full code. If you're reading the print version, you can find all code examples at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a> in their relevant chapter.</p>
</div>
<p>You have seen the basic steps to follow when producing pretty much any drawing with Canvas. These key conceptual steps will help you to approach any Canvas drawing. Now let's draw more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing various shapes with Canvas</h1>
                
            
            
                
<p>Let's add some other basic geometric shapes or <strong>graphical primitives</strong> to our canvas. As they are the building blocks of all the visuals you draw, some exercise will do us good. Here's what we will draw:</p>
<div><img height="581" width="859" src="img/81bb3ffd-9c3a-4763-9265-ea6a6909eb7e.png"/></div>
<p>A house and a tree. Or three rectangles under a triangle next to a path and a circle. </p>
<p>View this step in the browser: <a href="https://larsvers.github.io/learning-d3-mapping-8-2">https://larsvers.github.io/learning-d3-mapping-8-2</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_02.html">08_02.html</a>.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">You can see the code to the right in the JavaScript console, and before we step through it, let's note some general observations. First, every line starts with <kbd>context</kbd>. The Canvas context is really where our drawing comes to life. Second, Canvas code is written in a procedural style. This can be a benefit for beginners, as it is linear. No callbacks, no nested element structure, just a straight line of execution. This linearity will also extend to time, once you start animating the canvas. You write the first frame first, then you change the scene, then you write the second frame. Flip-book simple. Let's step through the code and see how to create these elements in detail. The first thing I suggest is giving the canvas a border. As the canvas element is an HTML element, you can style it with CSS, but we use JavaScript here to show off two properties of the canvas itself: <kbd>width</kbd> and <kbd>height</kbd>:</p>
<pre>context.strokeStyle = '#CCCCCC';<br/>context.strokeRect(0, 0, canvas.width, canvas.height);</pre>
<p class="mce-root">The <kbd>width</kbd> and <kbd>height</kbd> are the only properties the canvas element has. We use them here to read the values of the element, however, they are readable and writable. This is nice, as you can change the canvas size programmatically when you want to resize your canvas during animation for example. Next, we build our flat-roofed blue house:</p>
<pre>context.fillStyle = 'royalblue';<br/>context.fillRect(50, 150, 200, 100);</pre>
<p class="mce-root">Not much to see here, we've done that previously. The door won't make you sweat either, as it's the same as the house with a different color:</p>
<pre>context.fillStyle = 'rgba(255, 255, 255, 0.9)';<br/>context.fillRect(60, 190, 40, 60);</pre>
<p class="mce-root">However, we use a different method to describe the color. You can use all CSS color concepts like named color values and hex color values, as well as the <kbd>rgb()</kbd>, <kbd>rgba()</kbd>, <kbd>hsl()</kbd> and <kbd>hsla()</kbd> color methods. The window is placed a little differently with <kbd>context.translate()</kbd>:</p>
<pre>context.save();<br/>context.translate(140, 190);<br/>context.fillRect(0, 0, 60, 30);<br/>context.restore();</pre>
<p class="mce-root">In this case, we don't move the rectangle, we move the entire coordinate system! The <kbd>translate()</kbd> method takes two arguments: the <em>x</em> and the <em>y</em> position you want to move the coordinate system by. You know this concept already from the use of <kbd>transform, translate(x,y)</kbd> which is often used to move <kbd>svg:g</kbd> elements in D3 and create their own coordinate systems. However, when applied to an <kbd>svg:g</kbd> element the transformed coordinate system applies to all objects nested within the g element. As said above, the <kbd>g</kbd> element, as well as its children, is retained as a scene-graph representation in the DOM, including its coordinate system. In Canvas, we can't move this information off to a representation of our drawing – there is no such thing. It's up to you to make sure only elements you want to manifest on a different coordinate system will do so. Remember above when we talked about the procedural style of writing Canvas code? This is exactly what we have to keep in mind here. When we change something in the <kbd>context</kbd> it will persist through our code until we change it again. To change the coordinate system back we could alternatively move it to our desired position and move it back afterwards like:</p>
<pre>context.translate(140, 190);<br/>context.fillRect(0, 0, 60, 30);<br/>context.translate(-140, -190);</pre>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft">But we rather use the generally applicable <kbd>context.save()</kbd> and <kbd>context.restore()</kbd> methods. The <kbd>context.save()</kbd> saves the state at this point of the code and pushes it onto a <strong>stack</strong>, and  <kbd>context.restore()</kbd> pops the last saved state off the stack and restores the previous state of the context.  If you haven't come across stacks so far, here's an image explaining what it does: </p>
<div><img height="210" width="395" src="img/55c9677b-a0a1-480e-aa9c-44ba291f5745.png"/></div>
<p>The stacked tower of data.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">In short, a stack is a datatype like an array or an object. However, a stack is limited to two operations: adding elements on top of the stack (push) and removing elements from the top of the stack (pop). It's like a brick tower. This care-taking of our application's state is a defining aspect of Canvas and a key difference to SVG.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Next, we give the house a triangular roof. There's no <kbd>triangle()</kbd> function in Canvas, so you draw a path:</p>
<pre>context.beginPath();<br/>context.moveTo(50, 150);<br/>context.lineTo(250, 150);<br/>context.lineTo(50+200/2, 100); // you can use calculations as inputs!<br/>context.closePath();<br/>context.fillStyle = '#A52A2A';<br/>context.fill();</pre>
<p class="mce-root">Finally, we draw the tree. A tree has a brown stem, which you implement as a straight path, and a green treetop, which you draw as a green circle:</p>
<pre>context.beginPath();<br/>context.lineWidth = 10;<br/>context.strokeStyle = 'brown'<br/>context.moveTo(300, 250);<br/>context.lineTo(300, 200);<br/>context.stroke();<br/><br/>context.beginPath();<br/>context.fillStyle = 'green';<br/>context.arc(300, 175, 25, 0, Math.PI * 2);<br/>context.fill();</pre>
<p class="mce-root">There are two things to note here. First, all path code blocks are bracketed by <kbd>beginPath()</kbd> and either <kbd>stroke()</kbd> (the stem) or <kbd>fill()</kbd> (the roof and treetop):</p>
<pre>context.beginPath();<br/>// configure your path here<br/>context.stroke();<br/><br/>context.beginPath();<br/>// configure your path here<br/>context.fill();</pre>
<p class="mce-root"><kbd>beginPath()</kbd> signifies the intent to draw a new path and removes all current path (or sub-path) implementations. <kbd>stroke()</kbd> and <kbd>fill()</kbd> signify the end of the path and will produce the path on the screen. <kbd>fill()</kbd> will fill the path body with the set <kbd>fillStyle</kbd> color, and <kbd>stroke()</kbd> will only draw the path contour in with the set <kbd>strokeStyle()</kbd> method. Whenever you draw a path, you will need these start and end methods. In fact, whenever you draw anything you will need them. <kbd>fillRect()</kbd> or <kbd>strokeRect()</kbd>, as used previously, are just wrappers for beginning a path, drawing a path, and filling or stroking a path.<em> </em>You might have noticed that we only drew two sides of the triangular roof and then used <kbd>closePath()</kbd> which connects the current endpoint of the path with the starting point. The <kbd>fill()</kbd> method will also close the path for you, but making this explicit is more thorough, more performant and a service to the reader of your code (including yourself). The second thing to note is that even a circle is a path. In fact, the only primitive shape beyond a path offered by the Canvas API is the rectangle. SVG facilitates the use of <kbd>&lt;rect&gt;</kbd>, <kbd>&lt;circle&gt;</kbd>, <kbd>&lt;ellipse&gt;</kbd>, <kbd>&lt;line&gt;</kbd>, <kbd>&lt;polyline&gt;</kbd>, <kbd>&lt;polygon&gt;</kbd>, and <kbd>&lt;path&gt;</kbd>, while Canvas only offers paths and rectangles. However, drawing shapes with paths quickly becomes routine. While there is no pre-defined circle, there's the <kbd>arc()</kbd> and <kbd>arcTo()</kbd> methods, which pretty much do the circle drawing for you. You just need to add color to it and wrap it into the path start and end methods. <kbd>arc()</kbd> takes five arguments, the <em>x</em> and the <em>y</em> position, the <em>radius</em>, the <em>start</em> and the <em>end angle</em> of our arc. Both angles are being measured in radians.</p>
<p class="mce-root">A radian? One <strong>radian</strong> equals <em>57.3</em> degrees. Radians are an alternative unit of measurement for angles. They are beloved by mathematicians as they make a lot of sense in geometric calculations. To get a radian, you take the radius of a circle and wrap it around that circle – if you can imagine that the radius line is bendable:</p>
<div><img height="201" width="381" src="img/53c20cea-49e6-4796-a838-b1b48daf4bd3.png"/></div>
<p>How to get a radian</p>
<p class="mce-root CDPAlignLeft CDPAlign">Their mathematical advantage is that they can be derived directly from the radius of a circle. The further beauty is that half a circle (as in 180 degrees) is exactly one <em>PI</em> radians. Hence, a full circle equals <em>2 * PI</em> radians.</p>
<p>Degrees probably make more sense to you. That's fine. They also make more sense if you want to move objects around on the screen. You can easily convert between radians and degrees by using the following formula: <em>(</em><em>PI / 180) * degrees</em>. <em>PI</em> is half a circle in radians and 180 is half a circle in degrees. By dividing one by the other, you express one degree in radians, which equals 0.0175. Multiply any degree number you desire with 0.0175 and use the result as radians.</p>
<p>OK! We've drawn a landscape with a house – that's great. There is certainly more to Canvas, but by following these simple steps you have learned a lot. You have learned about the concept of drawing with Canvas and what it means to write your code procedurally. You have seen how to draw individual shapes with Canvas, how you can move individual objects around with a translate transformation, and how the atomic unit of each Canvas shape is the path. Now, let's step it up and animate our landscape the Canvas way before we do it the D3 way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating the Canvas</h1>
                
            
            
                
<div><p>One of Canvas's key advantages is animation. While the browser must work hard to re-calculate and re-render many elements retained in a DOM, it is relatively unstressed re-drawing a bitmapped image. In the following section, you will learn how to animate with Canvas. Let's first look at how you do it in a pure, vanilla Canvas way. After that, let's see if we can use D3's transition and life cycle Enter-Update-Exit pattern to help us animate. Both ways will be immensely helpful when building visualizations with D3 and Canvas as you will be able to choose the right technique for your own ideas or complement the two.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating the Canvas way</h1>
                
            
            
                
<p>Let's go back to our house and test its roof with rain:</p>
<div><img height="368" width="548" src="img/340c42b9-f372-4ebb-9e18-70752f326cf3.png"/></div>
<p>It's really raining.</p>
<p>View this step in the browser: <a href="https://larsvers.github.io/learning-d3-mapping-8-3">https://larsvers.github.io/learning-d3-mapping-8-3</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_03.html">08_03.html</a>.</p>
<p>It's hard to see in a static image, but the blue dots are in fact moving down when viewed in the browser. They are also moving at different speeds, which makes the rain look a little more realistic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting a general overview</h1>
                
            
            
                
<p>On the abstracted top level our code looks as follows:</p>
<pre>var canvas = d3.select('#main-canvas').node();  // set up<br/>var context = canvas.getContext('2d');<br/><br/>var rain = { }                                  // produce data<br/>d3.interval(function() {<br/>    update();                                   // update/process the data<br/>    animate();                                  // re-draw the canvas<br/>}, 10);                                         </pre>
<p>After setting up the canvas, you will produce some data – the raindrops. Then you will enter a loop within which you will update the data for the next scene and then draw it. In our case, <kbd>update()</kbd> changes the raindrops' positions and <kbd>animate()</kbd> will clear the current image and draw a new image with the updated raindrop positions.</p>
<p>This loop (or at least a very similar incarnation) is called the <strong>game loop</strong>, as it is used in game programming with Canvas. You process the gamer's input, update the game data accordingly, and draw the new scene. We will get used to this pattern quickly. Now, let's look at the details.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing the rain data</h1>
                
            
            
                
<p>The elements you're dealing with are raindrops. Before we update or animate a single raindrop, we produce them. We're building out a so called <em>object literal module</em> called <kbd>rain</kbd>  (it's an <em>object literal</em>) that knows how to produce raindrops and that keeps the individual drops save in an array called <kbd>items</kbd>. It will look like so: </p>
<pre>var rain = {<br/>    items: [],<br/>    maxDrops: 200,<br/>    getDrop: function() {<br/>      var obj = {};<br/>      obj.xStart = Math.floor(Math.random() * canvas.width);<br/>      obj.yStart = Math.floor(Math.random() * -canvas.height);<br/>      obj.x = null;<br/>      obj.y = null;<br/>      obj.speed = Math.round(Math.random() * 2) + 5;<br/><br/>      return obj;<br/>    },<br/>    updateDrop: // see below<br/>    }</pre>
<p>The <kbd>rain</kbd> object consists of this as yet empty array <kbd>items</kbd> that will hold all the raindrop objects we produce and a variable called <kbd>maxDrops</kbd>, confining the number of raindrops (the length of <kbd>items</kbd>) to 200 in this case. This can be considered light rain. Crank this up to a higher number if you want to drown the tree or test the app's performance. As we like the tree and shall test performance in an example to come, 200 will do for now.</p>
<p>Two functions will help to produce and update the drops. <kbd>getDrop()</kbd> assigns start positions out of sight above the canvas, as well as empty <kbd>x</kbd> and <kbd>y</kbd> positions which will be filled on update. You also define the speed of the drop, which can take on values between five and seven. The speed will be the number of pixels the raindrop will move forward on each update. A low number will produce slow rain and a higher number will produce fast rain.</p>
<p>The <kbd>updateDrop()</kbd> function can be called in case we, well, want to update a drop's position. Let's do this now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating each drop</h1>
                
            
            
                
<p>The site loads and things will kick off with the <kbd>d3.interval</kbd> function, which calls all functions it embraces every 10 milliseconds. First, it will call <kbd>update()</kbd> which returns an array of objects. Each object is a drop most notably characterized by an arbitrary <kbd>x</kbd> and <kbd>y</kbd> position. This is how it looks:</p>
<pre>function update() {<br/>  if (!rain.items.length) {<br/>    d3.range(rain.maxDrops).forEach(function(el) {<br/>      var drop = rain.getDrop(el);<br/>      rain.updateDrop(drop);<br/>      rain.items.push(drop);<br/>    });<br/>  } else {<br/>    rain.items.forEach(function(el) {<br/>      rain.updateDrop(el);<br/>    });<br/>  }<br/>}</pre>
<p>The first time <kbd>update()</kbd> is called it produces a drop, updates its position, and pushes it into the rain items array. Any other time, it just updates the drop's position. We use <kbd>d3.range</kbd> as a convenient method for this loop. It takes an integer as input and returns an array of integers starting at 0, and the length of the number you pass in. Here it helps create as many rain drops as we specified in <kbd>maxDrops</kbd>.</p>
<p>We then update the drop's position with the <kbd>updateDrop()</kbd> function we started to describe previously:</p>
<pre>updateDrop: function(drop) {<br/>  drop.x = drop.x === null ? drop.xStart : drop.x;<br/>  drop.y = drop.y === null ? drop.yStart : drop.y + drop.speed;<br/>  drop.y = drop.y &gt; canvas.height ? drop.yStart : drop.y;<br/>}</pre>
<p>If the drop's <kbd>x</kbd> and <kbd>y</kbd> positions don't exist yet (if they are <kbd>null</kbd>) we assign the <kbd>xStart</kbd> or <kbd>yStart</kbd> values to it. If not, we leave the <kbd>x</kbd> position where it is as no drop will move to any side, and we move the <kbd>y</kbd> position downwards by speed. This will make the drop move down between five and seven pixels every 10 milliseconds. The last line recycles each drop. Once it has reached the final border of the bottom canvas, we just set its <kbd>y</kbd> value to the initial <kbd>yStart</kbd> value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing frame by frame</h1>
                
            
            
                
<p>Back in our <kbd>d3.interval</kbd> loop, <kbd>update()</kbd> has run and we have the positions of all our raindrops. Next, we will deal with drawing them. If we had a DOM, we would interact with our omnipresent 200 SVG circles and ask them kindly to move down a little. But we produce a static image and we can only draw and not change. So, we draw. Like in a flip book we dispose of the old image and draw a new one. Let's repeat this. Each time we want to move something on the canvas we <strong>remove</strong> <strong>the old image</strong> and <strong>draw a new image</strong> with changed positions.</p>
<p>It's straightforward:</p>
<pre>function animate() {<br/>  context.clearRect(0, 0, canvas.width, canvas.height);     <br/>  drawScene();<br/>  rain.items.forEach(function(el) {<br/>    circle(context, el.x, el.y, 1.5, 'blue');<br/>  });<br/>}</pre>
<p><kbd>animate()</kbd> uses the context's own <kbd>clearRect()</kbd> function, which does what it says on the tin. You pass it the area you want to clear – in our case the entire canvas – and it will clear it. You can also fill a white rectangle or change the <kbd>canvas.width</kbd> and <kbd>canvas.height</kbd> values, but <kbd>clearRect()</kbd> is faster than the first and clearer than the second method.</p>
<p>Next, you run the <kbd>drawScene()</kbd> function, which draws our scene: the house and the tree. It's what you built in the previous section, just wrapped up in an aptly-named function.</p>
<p>Finally, we draw each drop to the canvas. What is <kbd>circle()</kbd> you ask? It's a helper function to build visual primitives – in our case a circle. It has been added at the top of the code:</p>
<pre>function circle(ctx, x, y, r, color) {<br/>  ctx.beginPath();<br/>  ctx.fillStyle = color;<br/>  ctx.arc(x, y, r, 0, 2 * Math.PI);<br/>  ctx.fill();<br/>}</pre>
<p>The two main functions <kbd>update()</kbd> and <kbd>animate()</kbd> are being run repeatedly until the end of your browser tab's session; which could mean bad weather for some time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Canvas and D3</h1>
                
            
            
                
<p>D3 offers unmatched functionality for producing data visualizations on the web. You might be aware of this, reading this very book. One important part of what D3 offers is its model for how data-infused elements evolve on the screen. It has a certain way of thinking about the life cycle of each element.</p>
<p>In practice, you inject data into a yet non-existent DOM, and D3 creates new elements of your choice as per the data you inject, usually one element per data point. If you want to inject new data into the DOM you can do so and D3 identifies which elements have to be newly created, which elements are allowed to stay, and which elements should pack up and leave the screen. This way you can represent three distinct states of a common data-flow: <strong>entering</strong> data, <strong>updating</strong> data, and <strong>exiting</strong> data. You can then grab these selections, manipulate their visual properties as well as transition between them with D3's built-in interpolators, leveraged by <kbd>d3.transition()</kbd>.</p>
<p>This plays well with the retained SVG elements that are manifested in the DOM. However, we have no DOM elements in the canvas and must, therefore, be a little clever about producing them. Let's see how we can follow D3's life cycle model as well as using D3's transitions to interpolate between these three states.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting an overview of our experiment</h1>
                
            
            
                
<p>We will still let it rain over our little house and its tree, but now the rain will follow its natural course – the rain's life cycle, as it were. It will <strong>Enter</strong> in the form of a cloud, it will <strong>Update</strong> as the rain moving into a big puddle on the ground, and it will <strong>Exit</strong> turning the puddle into a lush patch of grass:</p>
<div><strong><img src="img/b3ca6039-2d84-45f6-bd58-393a6cb80d34.png"/></strong></div>
<p>Enter, Update and Exit the rain </p>
<p>View this step in the browser: <a href="https://larsvers.github.io/learning-d3-mapping-8-4b">https://larsvers.github.io/learning-d3-mapping-8-4b</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04b.html">08_04b.html</a>.</p>
<p>As you can see, there are buttons to the right allowing you to control the three state changes.</p>
<p>The structure of the code will be similar to the previous pure Canvas animation. Conceptually, you calculate the elements' (the raindrops') positions first and then draw. However, the way we achieve this interaction is entirely via D3. To lift the lid in advance, you will bind the data to virtual DOM elements. These DOM elements are ‘virtual'. As Canvas has no DOM, you create a basic DOM structure in memory, with which we can use D3's selections, the data join, and consequently the Enter-Update-Exit API. Additionally, the app will have button interactions to change the elements' state according to the changed data. We have discussed the Canvas setup as well as data preparation already, so let's focus on the core novelty of this section, the databind and the draw!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The data</h1>
                
            
            
                
<p>Having said that, we should have a brief look at the data we will produce with a function called <kbd>getRainData()</kbd>. It will give us 2,500 raindrops (heavy rain this time) that look a little different to our previous example:</p>
<div><img height="280" width="435" src="img/f4cc465b-c0ab-408e-8d50-5d1e0aee1ea2.png"/></div>
<p>A raindrop the Vanilla Canvas way versus a raindrop the D3-and-Canvas way</p>
<p>The key differences are that you don't need the speed for the D3 raindrop version, as we plan for D3's transition to implement the animation. Further, the <strong>D3 and Canvas</strong> raindrop has properties for a set of states included, while the <strong>Vanilla Canvas</strong> raindrop only has start and current positions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Updating each drop</h1>
                
            
            
                
<p>With the data in place, it's now time to make it move. In the pure Canvas example, you drew each point on the canvas, then calculated new points adding five pixels to the previous point's position, removed the old image, and drew the new one with the advanced drops. You transitioned the points yourself.</p>
<p>Employing D3's transition methods differs in that we won't calculate the new position, but D3 will do it for us. You will bind the data to selections, ask D3 to transition the values, and while it transitions you will redraw the canvas for as long as the transition runs. On a top level, you only need two functions to do this:</p>
<pre>databind(data) {<br/>  // Bind data to custom elements.<br/>}<br/>draw() {<br/>  // Draw the elements on the canvas.<br/>}</pre>
<p>It's pretty straightforward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding the data</h1>
                
            
            
                
<p>However, D3 implements transitions on selections, and we don't have selections yet. A single D3 selection is an element with bound data. With D3 you select a DOM element, usually SVG, join data to it, and you have a selection with all its wondrous methods: the explicit <kbd>enter()</kbd> and <kbd>exit()</kbd> methods, the implicit <kbd>update()</kbd> method triggered by <kbd>data()</kbd>, as well as <kbd>transition()</kbd> and their helpers <kbd>duration()</kbd> and <kbd>delay()</kbd> that control the transition.</p>
<p>To create selections, you just create DOM-like elements, and the great thing is, you don't need the incarnated DOM to do so. You can create them in memory. Here's how:</p>
<pre>var customBase = document.createElement('custom')<br/>var custom = d3.select(customBase);</pre>
<p>You can imagine <kbd>customBase</kbd> as a replacement of a root SVG element and <kbd>custom</kbd> to be a fully-fledged D3 selection. With your foundation in place you can go about the usual D3 business of binding data to your custom elements with the <kbd>databind()</kbd> function:</p>
<pre>function databind(data) { }</pre>
<p class="mce-root">First, we join the data passed into the <kbd>databind()</kbd> function:</p>
<pre>    var join = custom.selectAll('custom.drop')<br/>        .data(data, function(d) { return d.currentIndex; });</pre>
<p>The key function passed in as the second argument to <kbd>data</kbd> isn't strictly necessary in this case, but is good practice as it makes the join unambiguous and can have performance benefits.</p>
<p>Now you create your selection states. The <kbd>enter</kbd> selection is first:</p>
<pre>var enter = join<br/>  .enter().append('custom')<br/>    .attr('class', 'drop')<br/>    .attr('cx', function(d) { return d.xCloud; })<br/>    .attr('cy', function(d) { return d.yCloud; })<br/>    .attr('r', function(d) { return d.radiusCloud; })<br/>    .attr('fillStyle', 'rgba(0, 0, 255, 0')<br/>  .transition().delay(function(d, i) { return i * 2; })<br/>    .attr('fillStyle', 'rgba(0, 0, 255, 0.2');</pre>
<p>There are two things of note about the two bottom lines setting the <kbd>fillStyle</kbd> attribute. When you work with SVG the last line would be:</p>
<pre>.style('color', 'rgba(0, 0, 255, 0.2')</pre>
<p>But with Canvas you use <kbd>.attr()</kbd>. Why? Your main interest here is to find a pain-free way to transfer some element-specific information. Here you want to transfer a color string from the <kbd>databind()</kbd> to the <kbd>draw()</kbd> function. You use the element simply as a vessel to transport your data over to where it is being rendered to the canvas.</p>
<p>That's a very important distinction: when working with SVG or HTML you can bind data to elements and draw or apply styles to the elements in one step. In Canvas, you need two steps. First, you bind the data then you draw the data. You can't style the elements while binding. They only exist in memory and Canvas can't be styled via CSS style properties, which is exactly what you access when using <kbd>.style()</kbd>.</p>
<p>Let's have a quick look at how the <kbd>customBase</kbd> element looks after we've created and appended the <kbd>enter</kbd> selection to it:</p>
<div><img src="img/090c66aa-0950-42d4-bdb3-be14185c7b10.png"/></div>
<p>Our custom root element showing 30 of our raindrops in enter-state</p>
<p>Looks familiar in structure, doesn't it?</p>
<p>Next, you define the <kbd>update</kbd> selection, and finally the <kbd>exit</kbd> selection:</p>
<pre>var update = join<br/>  .transition()<br/>    .duration(function() { return Math.random() * 1000 + 900; })<br/>    .delay(function(d,i) { return (i / data.length) * dur; })<br/>    .ease(d3.easeLinear)<br/>    .attr('cx', function(d) { return d.xPuddle; })<br/>    .attr('cy', function(d) { return d.yPuddle; })<br/>    .attr('r', function(d) { return d.radiusPuddle; })<br/>    .attr('fillStyle', '#0000ff');<br/><br/>var exit = join<br/>  .exit().transition()<br/>    .duration(dur)<br/>    .delay(function(d,i) { return i ; })<br/>    .attr('r', function(d) { return d.radiusGrass; })<br/>    .attr('fillStyle', '#01A611');</pre>
<p>That's all that goes into <kbd>databind()</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the data</h1>
                
            
            
                
<p>Now you need to write the <kbd>draw()</kbd> function to get the elements on screen. Let's just note here that nothing has happened yet. You haven't called <kbd>databind()</kbd> yet because you need to find a way to draw it to the canvas first. So, off we go.</p>
<p>The <kbd>draw()</kbd> function takes the context you want to draw on as an argument:</p>
<pre>function draw(ctx) {<br/>  ctx.clearRect(0, 0, canvas.width, canvas.height);<br/><br/>  drawRainScene();<br/>  drawScene();<br/><br/>  var elements = custom.selectAll('custom.drop');<br/>  elements.each(function(d, i) {<br/>    var node = d3.select(this);<br/>    ctx.save();<br/>    ctx.beginPath();<br/>    ctx.globalCompositeOperation = 'source-atop'<br/>    ctx.fillStyle = node.attr('fillStyle');<br/>    ctx.arc(node.attr('cx'), node.attr('cy'), node.attr('r'), 0, 2 *<br/>    Math.PI);<br/>    ctx.fill();<br/>    ctx.restore();<br/>  });</pre>
<p>Then it does the following:</p>
<ol>
<li>It clears the canvas.</li>
<li>It draws the background scene, including the house and tree, as well as a cloud and a puddle drawn in <kbd>drawRainScene()</kbd>.</li>
<li>It loops through each of our virtual elements to draw it according to the attributes we specified in <kbd>databind()</kbd>.</li>
</ol>
<p>That's it! You can close the <kbd>draw()</kbd> function.</p>
<p>See the line <kbd>ctx.globalCompositeOperation = 'source-atop'</kbd>? The <kbd>globalCompositeOperation</kbd> allows us to fuse or blend-in shapes. It operates on a source shape, the shape we are about to draw, and a destination, the Canvas content <em>underneath</em> the source shape. You can apply a number of compositing effects, but we use <kbd>source-atop</kbd> here.</p>
<p>Check <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation</a> for all composite options.</p>
<p>As a result, the new shape is only drawn where it overlaps the existing canvas content. The shape will not be visible in canvas regions without any drawings. This is why we need all objects in <kbd>drawRainScene()</kbd>. They form the background to our raindrops which they can't escape. By the way, if you don't want to draw all complex shapes by hand, you can draw them with vector graphics software such as Illustrator, save them as SVG, and use apps such as the <em>SVG to HTML5 Canvas converter</em> at <a href="http://www.professorcloud.com/svg-to-canvas/">http://www.professorcloud.com/svg-to-canvas/</a> to convert SVG paths into Canvas commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running the app</h1>
                
            
            
                
<p>So far, no raindrop has shown itself, but you have the background scene in place:</p>
<div><img height="372" width="613" src="img/14a09a8a-eb4b-4e99-a3ea-2a0aafece9ba.png"/></div>
<p>The initial scene</p>
<p>You have the means to animate the life cycle with the <kbd>databind()</kbd> and the <kbd>draw()</kbd> functions. You just call them in a sequence and wire this call-up with the buttons. Let's play this through for the Enter case. The cloud is empty and we want raindrops to transition into play from 0 to 0.2 opacity, that's how we specified it in the <kbd>databind()</kbd> function. We could just run:</p>
<pre>databind(raindata);<br/>draw(context);</pre>
<p>This will join the data to the custom elements and, as all elements are joined with new data, draw the enter selection – once! But we need to display the transition, so we need to draw repeatedly while the transition is happening. You achieve this with a continuous loop:</p>
<pre>databind(data);<br/>var t = d3.timer(function(elapsed) {<br/>  draw(context);<br/>   if (elapsed &gt; dur * 2) t.stop();<br/>});</pre>
<p>First, we bind the incoming data to our custom elements. Then we draw repeatedly. <kbd>d3.timer()</kbd> calls its callback repeatedly until you tell it to stop. The callback takes an argument we call <kbd>elapsed</kbd> here, which is the time in milliseconds the timer is running. The <kbd>draw()</kbd> function will be run many times drawing the background scene as well as each raindrop. At the same time a transition is running within <kbd>databind()</kbd>, changing each raindrop's position slightly. The <kbd>draw()</kbd> function will pick up these slight position changes as it loops through each raindrop every time it's called, drawing the raindrop at the very position the transition in <kbd>databind()</kbd> sets it to at this given moment. You can think of it as two processes happening at the same time: the transition in <kbd>databind()</kbd> delivering new raindrop positions and the repeated canvas drawing in <kbd>draw()</kbd> removing the previous canvas and drawing these new raindrop positions.</p>
<p>After the transition is done, we want to stop the timer. Work done. The transition in <kbd>databind()</kbd> runs for 2000 milliseconds, as we set it in the <kbd>dur</kbd> variable. We shall use <kbd>dur</kbd> now to clear up after us. We can stop any timer from within calling the timer's <kbd>.stop()</kbd>-method. To be safe we call <kbd>t.stop()</kbd> after we're passed double our duration <kbd>dur</kbd> (<em>4000</em> milliseconds) to cater for delayed transitions. </p>
<p>This is how a D3 transition works in Canvas. You call the drawing function more or less parallel to the binding function repeatedly Whatever style or position properties your D3 elements are set up to transition (<em>x</em>, <em>y</em>, <em>color</em>, <em>width</em>, <em>height</em>, for example.), they will be re-drawn many times with small incremental changes for each draw.</p>
<p>Wiring it up to the buttons is a formality. Just wrap the <kbd>databind()</kbd> and <kbd>draw()</kbd> functions into a function (we shall call it <kbd>rainAnimation()</kbd>) that passes in the <kbd>raindata</kbd> when the enter or update button is pressed and an empty array when the exit button is pressed.</p>
<p>That's it!</p>
<p>The rain cloud will appear on the screen upon hitting the Enter button:</p>
<div><img height="366" width="619" src="img/8fa57f3c-d8cf-4b3b-8c49-f520e046a311.png"/></div>
<p>Enter rain into cloud</p>
<p>The Update button will update the rain's position from the cloud to a puddle:</p>
<div><img height="355" width="605" src="img/b81b6df5-fb62-4bf2-a7c9-a47934e6fc74.png"/></div>
<div><p>Update rain to the ground</p>
</div>
<p>The Exit button will finally turn the rain into grass:</p>
<div><img height="388" width="660" src="img/2ba74abc-fe1f-4eb9-a36d-3a9c06b8a475.png"/></div>
<div><p>Exit the rain to become grass </p>
<p>View this step in the browser: <a href="https://larsvers.github.io/learning-d3-mapping-8-4a">https://larsvers.github.io/learning-d3-mapping-8-4a</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04a.html">08_04a.html</a>.</p>
</div>
<p>A natural D3 life cycle demonstration!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="NormalPACKT">You've come a long way. You've learned how to draw with Canvas, how to animate the canvas in a pure Canvas way, as well as how to use D3 transitions and the Enter-Update-Exit pattern with Canvas. While the Vanilla Canvas way is perfectly reasonable for a great many applications, D3 offers seasoned functionality for data visualization you don't have to abandon. It requires a shift in thinking when building your application, but it can pay out specifically for drawing and animating a large number of points. It will expand your toolbox in a valuable way, especially at times where abundant data might require element-heavy representations.</p>
<p class="NormalPACKT">In the next chapter, we will review a map visualization in SVG and then build one in Canvas. By doing so, you will not only be able to apply the learnings from this chapter, but you will also learn more about the differences and similarities between the two approaches, how Canvas can help with performance bottlenecks, and how D3 can help with some heavy lifting.</p>
<p class="NormalPACKT">Let's get to it!</p>


            

            
        
    </body></html>