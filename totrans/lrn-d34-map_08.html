<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing with Canvas and D3</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far you have used D3 to render your visualizations with mostly SVG, and sometimes HTML, elements. </span><span class="koboSpan" id="kobo.2.2">In this section, you will learn how to use HTML5 Canvas to draw and animate your visualizations. </span><span class="koboSpan" id="kobo.2.3">Canvas can be used as an alternative to SVG, especially if you want to render more elements on screen. </span><span class="koboSpan" id="kobo.2.4">You will get an overview of what Canvas is and how it compares with SVG. </span><span class="koboSpan" id="kobo.2.5">You will learn how to draw and animate with Canvas and how you can use D3 with it.</span></p>
<p><span class="koboSpan" id="kobo.3.1">After covering the foundations, we will visualize flight paths first with SVG and then with Canvas to contrast and compare the two rendering approaches hands on. </span><span class="koboSpan" id="kobo.3.2">First and foremost, this will give you a practical understanding of how Canvas works as an alternative to SVG. </span><span class="koboSpan" id="kobo.3.3">Secondly, it will showcase how Canvas can solve problems you might have when animating thousands of points at once with SVG, as browsers are significantly faster in drawing a single picture of thousands of elements than in building, storing, and maintaining a tree of thousands of elements in memory.</span></p>
<p><span class="koboSpan" id="kobo.4.1">We will cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Overview of Canvas and its tools: the Canvas context </span></li>
<li><span class="koboSpan" id="kobo.6.1">How to use the tools to draw with Canvas</span></li>
<li><span class="koboSpan" id="kobo.7.1">How to animate a drawing with Canvas</span></li>
<li><span class="koboSpan" id="kobo.8.1">How to apply the D3 life cycle to individual parts of the Canvas drawing</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Introducing Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before you start to draw with Canvas, let's have a brief look at its concept – the mental model that will help you approach, plan, and write your applications. </span><span class="koboSpan" id="kobo.2.2">Canvas in its material form is a single HTML5 element. </span><span class="koboSpan" id="kobo.2.3">It is literally a blank canvas that you can draw on. </span><span class="koboSpan" id="kobo.2.4">For the actual drawing, you use the </span><strong><span class="koboSpan" id="kobo.3.1">Canvas context</span></strong><span class="koboSpan" id="kobo.4.1"> – the Canvas API. </span><span class="koboSpan" id="kobo.4.2">The context can be thought of as your toolbox that can be manipulated with JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.5.1">You can compare the Canvas element with the root SVG element, as both contain all parts of the drawing. </span><span class="koboSpan" id="kobo.5.2">However, the key difference is that SVG (like HTML) operates in </span><strong><span class="koboSpan" id="kobo.6.1">retained mode</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">The browser retains a list of all objects drawn onto the SVG (or HTML) canvas within the </span><strong><span class="koboSpan" id="kobo.8.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong><span class="koboSpan" id="kobo.10.1">DOM</span></strong><span class="koboSpan" id="kobo.11.1">) – the scene-graph of your web application. </span><span class="koboSpan" id="kobo.11.2">This makes your drawing almost material. </span><span class="koboSpan" id="kobo.11.3">You produce a list of objects, change styles and properties through code, and you can refer to these elements any time you desire. </span><span class="koboSpan" id="kobo.11.4">You can change their position, move them up or down the DOM and – very important for interaction – you can attach and remove event listeners to them easily.</span></p>
<p><span class="koboSpan" id="kobo.12.1">Canvas, in contrast, operates in </span><strong><span class="koboSpan" id="kobo.13.1">immediate mode</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">Anything you draw using Canvas occurs at once and remains on the canvas as an image. </span><span class="koboSpan" id="kobo.14.3">Images in Canvas are bitmaps, digital images composed of a matrix or grid of pixels. </span><span class="koboSpan" id="kobo.14.4">When you draw with Canvas you prepare the properties of each pixel (or rather specified regions of pixels) with your tools and then draw them on the canvas. </span><span class="koboSpan" id="kobo.14.5">If you want to change the color of one, a few, or all pixels on your image, you remove the whole image and produce a new image. </span><span class="koboSpan" id="kobo.14.6">Unlike SVG, you can't go back to the pixel you want to change, as it is not represented in memory in the form of a document tree or the like, but </span><em><span class="koboSpan" id="kobo.15.1">burned</span></em><span class="koboSpan" id="kobo.16.1"> just once onto the screen. </span><span class="koboSpan" id="kobo.16.2">But fear not, you still have the Canvas context that represents the state of your tools, which indirectly represents the drawing itself.</span></p>
<p><span class="koboSpan" id="kobo.17.1">You can think of Canvas as a painting and SVG or HTML as a Lego structure. </span><span class="koboSpan" id="kobo.17.2">The former is static in its representation. </span><span class="koboSpan" id="kobo.17.3">If you paint a man standing on a bridge screaming, you can't just turn his head around. </span><span class="koboSpan" id="kobo.17.4">You would have to draw a second painting to express this precisely. </span><span class="koboSpan" id="kobo.17.5">If you built the same scene with Lego, you could grab the head and turn it around, like so:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img height="362" width="488" src="assets/18ca93ab-fcee-496c-9982-eddcfde75bdd.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1">A dramatization of the immediate Canvas and the retained SVG  </span><span class="fontstyle0"><span class="koboSpan" id="kobo.20.1">(SVG</span></span><span class="koboSpan" id="kobo.21.1"> </span><span class="fontstyle2"><span class="koboSpan" id="kobo.22.1">Image courtesy of Marco Pece</span></span> <span class="fontstyle3"><span class="koboSpan" id="kobo.23.1">www.udronotto.it</span></span><span class="fontstyle2"><span class="koboSpan" id="kobo.24.1">)</span></span></div>
<p><span class="koboSpan" id="kobo.25.1">This might sound cumbersome, considering the potential work that has to go into animating with Canvas. </span><span class="koboSpan" id="kobo.25.2">Not just the mental strain of having to paint so many pictures, but the computational powers required to redraw everything in quick succession. </span><span class="koboSpan" id="kobo.25.3">But, as you will see in the coming sections, there are simple patterns that make Canvas animated and interactive.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing with Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before we come back to a more thorough comparison of SVG and Canvas and see concrete scenarios of when to use what, let's learn to draw with Canvas. </span><span class="koboSpan" id="kobo.2.2">We will start with a very simple example to understand the three main steps involved when drawing with Canvas. </span><span class="koboSpan" id="kobo.2.3">Then you will draw a set of shapes to get used to its toolbox.</span></p>
<p><span class="koboSpan" id="kobo.3.1">As a side note, when working along and viewing the code examples, I highly recommend you use a recent Chrome browser. </span><span class="koboSpan" id="kobo.3.2">All code is tested across modern browsers but has been written with Chrome in mind, which therefore will be the safest browser to work with. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The three drawing steps of every Canvas visual</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can deconstruct a Canvas drawing into three simple steps:</span></p>
<ol>
<li><strong><span class="koboSpan" id="kobo.3.1">Create</span></strong><span class="koboSpan" id="kobo.4.1"> the canvas and its context.</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Configure</span></strong><span class="koboSpan" id="kobo.6.1"> the context.</span></li>
<li><strong><span class="koboSpan" id="kobo.7.1">Render</span></strong><span class="koboSpan" id="kobo.8.1"> the resulting bitmap.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.9.1">To mount the canvas within your DOM you create a </span><kbd><span class="koboSpan" id="kobo.10.1">&lt;canvas&gt;</span></kbd><span class="koboSpan" id="kobo.11.1"> element in HTML:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">&lt;canvas id=”main-canvas” width = “600” height=”400”&gt;&lt;/canvas&gt;</span></pre>
<p><span class="koboSpan" id="kobo.13.1">It will look empty, as expected:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img src="assets/6fbdd403-bb07-4971-9b23-ae025dadf1e0.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1">An empty Canvas element</span></div>
<p><span class="koboSpan" id="kobo.16.1">This will be all the DOM you will see of your canvas. </span><span class="koboSpan" id="kobo.16.2">All other operations will happen via the Canvas context in JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.17.1">If you wanted to draw a rectangle in, say, </span><kbd><span class="koboSpan" id="kobo.18.1">royalblue</span></kbd><span class="koboSpan" id="kobo.19.1">, you would move onto JavaScript without looking back to the HTML and write:</span></p>
<pre class="mce-root"><span class="koboSpan" id="kobo.20.1">var canvas = d3.select('#main-canvas').node();</span><br/><span class="koboSpan" id="kobo.21.1">var context = canvas.getContext('2d');</span><br/><br/><span class="koboSpan" id="kobo.22.1">context.fillStyle = 'royalblue';</span><br/><span class="koboSpan" id="kobo.23.1">context.fillRect(50, 50, 200, 100);</span></pre>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.24.1">You can find all code to this chapter at </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.25.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a></div>
<p><span class="koboSpan" id="kobo.26.1">Let's go through our first steps one by one:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.27.1">First, you reference the canvas in a variable. </span><span class="koboSpan" id="kobo.27.2">We'll use </span><kbd><span class="koboSpan" id="kobo.28.1">d3.select()</span></kbd><span class="koboSpan" id="kobo.29.1"> to do so. </span><span class="koboSpan" id="kobo.29.2">As you will need a reference to the canvas element itself, not a selection, you should use D3's </span><kbd><span class="koboSpan" id="kobo.30.1">selection.node()</span></kbd><span class="koboSpan" id="kobo.31.1"> method to grab the element itself. </span><span class="koboSpan" id="kobo.31.2">The next line references the drawing context to this specific canvas element. </span><span class="koboSpan" id="kobo.31.3">The context includes all the tools you can use to draw. </span><span class="koboSpan" id="kobo.31.4">You can </span><kbd><span class="koboSpan" id="kobo.32.1">console.log(‘context')</span></kbd><span class="koboSpan" id="kobo.33.1"> to have a look at the context object:</span></li>
</ol>
<div style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.34.1"><img height="251" width="760" src="assets/25d94e62-a290-404d-9f71-8eadfc083561.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.35.1">The context object showing all properties</span></div>
<div>
<p style="padding-left: 90px"><span class="koboSpan" id="kobo.36.1">The context is called </span><kbd><span class="koboSpan" id="kobo.37.1">CanvasRenderingContext2D</span></kbd><span class="koboSpan" id="kobo.38.1"> internally, but we will refer to it just as </span><kbd><span class="koboSpan" id="kobo.39.1">context</span></kbd><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">It holds all the properties you can manipulate to draw your visual. </span><span class="koboSpan" id="kobo.40.3">If you feel inclined you can also expand the </span><kbd><span class="koboSpan" id="kobo.41.1">__proto__</span></kbd><span class="koboSpan" id="kobo.42.1"> object, which will show all methods available to you. </span><span class="koboSpan" id="kobo.42.2">We'll explain the key properties and methods as we go without diving into each individually. </span><span class="koboSpan" id="kobo.42.3">The important point of the context object is to understand that there's an object helping you to build your drawing. </span><span class="koboSpan" id="kobo.42.4">It stays at your side all along allowing you to use its methods and change its properties.</span></p>
</div>
<div class="packt_infobox">
<p style="padding-left: 30px"><span class="koboSpan" id="kobo.43.1">A great place to learn more about the context API, its properties, and methods is the documentation on the Mozilla Developer Network at </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"><span class="koboSpan" id="kobo.44.1">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.</span></a></p>
</div>
<p style="padding-left: 90px" class="NormalPACKT"><span><span class="koboSpan" id="kobo.45.1">At this point, you have the canvas to draw on and the drawing tools, but you still haven't drawn anything.</span></span></p>
<ol start="2">
<li><span class="koboSpan" id="kobo.46.1">In the second step you prepare the drawing. </span><span class="koboSpan" id="kobo.46.2">You configure the context to produce the desired drawing. </span><span class="koboSpan" id="kobo.46.3">The example is purposefully simple in that the only configuration is to set the fill of our yet non-existent object to </span><kbd><span class="koboSpan" id="kobo.47.1">royalblue</span></kbd><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">Note that </span><kbd><span class="koboSpan" id="kobo.49.1">context.fillStyle</span></kbd><span class="koboSpan" id="kobo.50.1"> is a property, not a method, of the Canvas context. </span><span class="koboSpan" id="kobo.50.2">It's like you are a painter telling your brush box what color you want to use for the object you paint next.</span></li>
</ol>
<ol start="3">
<li><span class="koboSpan" id="kobo.51.1">This third step produces the following image. </span><kbd><span class="koboSpan" id="kobo.52.1">context.fillRect()</span></kbd> <span><span class="koboSpan" id="kobo.53.1">takes four arguments: the</span></span> <em><span class="koboSpan" id="kobo.54.1">x</span></em> <span><span class="koboSpan" id="kobo.55.1">and the</span></span> <em><span class="koboSpan" id="kobo.56.1">y</span></em> <span><span class="koboSpan" id="kobo.57.1">position of the rectangle's starting point as well as the</span></span> <kbd><span class="koboSpan" id="kobo.58.1">width</span></kbd> <span><span class="koboSpan" id="kobo.59.1">and the</span></span> <kbd><span class="koboSpan" id="kobo.60.1">height</span></kbd><span><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">Canvas – like SVG – uses a Cartesian co-ordinate system with the origin 0, 0 at the top-left corner increasing to the right and to the bottom. </span><span class="koboSpan" id="kobo.61.3">All values are given in pixels:</span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.62.1"><img height="206" width="546" src="assets/d2a012ff-fec0-4d76-8143-815ef901f406.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.63.1"> A very royal blue Canvas rectangle</span></div>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.64.1">This rectangle is not present in the DOM. </span><span class="koboSpan" id="kobo.64.2">You can see its configuration in JavaSript and the canvas its drawn to in the DOM, but there's no </span><kbd><span class="koboSpan" id="kobo.65.1">&lt;rect&gt;</span></kbd><span class="koboSpan" id="kobo.66.1"> element or the like we could refer to. </span><span class="koboSpan" id="kobo.66.2">Again, don't grow worry lines; we will get clever about how to re-address it in the next two chapters.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.67.1">View this step in the browser: </span><a href="https://larsvers.github.io/learning-d3-mapping-8-1"><span class="koboSpan" id="kobo.68.1">https://larsvers.github.io/learning-d3-mapping-8-1</span></a><span class="koboSpan" id="kobo.69.1">.</span><span><span class="koboSpan" id="kobo.70.1"> Code example </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_01.html"><span class="koboSpan" id="kobo.71.1">08_01.html</span></a><span class="koboSpan" id="kobo.72.1">.</span></div>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.73.1">At </span><span><span class="koboSpan" id="kobo.74.1">the conclusion of each step you will find two links in an info box close to the the relevant image</span></span><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">The first link brings you to a working implementation of this step that you can view in the browser. </span><span class="koboSpan" id="kobo.75.3">The second</span><span><span class="koboSpan" id="kobo.76.1"> </span></span><em><span class="koboSpan" id="kobo.77.1">code example</span></em><span><span class="koboSpan" id="kobo.78.1"> </span></span><span class="koboSpan" id="kobo.79.1">link brings you to the full code. </span><span class="koboSpan" id="kobo.79.2">If you're reading the print version, you can find all code examples at</span><span><span class="koboSpan" id="kobo.80.1"> </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.81.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span><span class="koboSpan" id="kobo.82.1"> </span></span><span class="koboSpan" id="kobo.83.1">in their relevant chapter.</span></p>
</div>
<p><span class="koboSpan" id="kobo.84.1">You have seen the basic steps to follow when producing pretty much any drawing with Canvas. </span><span class="koboSpan" id="kobo.84.2">These key conceptual steps will help you to approach any Canvas drawing. </span><span class="koboSpan" id="kobo.84.3">Now let's draw more.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing various shapes with Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's add some other basic geometric shapes or </span><strong><span class="koboSpan" id="kobo.3.1">graphical primitives</span></strong><span class="koboSpan" id="kobo.4.1"> to our canvas. </span><span class="koboSpan" id="kobo.4.2">As they are the building blocks of all the visuals you draw, some exercise will do us good. </span><span class="koboSpan" id="kobo.4.3">Here's what we will draw:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="581" width="859" src="assets/81bb3ffd-9c3a-4763-9265-ea6a6909eb7e.png"/></span></div>
<div class="packt_figref CDPAlignCenter"><span class="koboSpan" id="kobo.6.1">A house and a tree. </span><span class="koboSpan" id="kobo.6.2">Or three rectangles under a triangle next to a path and a circle. </span></div>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.7.1">View this step in the browser: </span></span><a href="https://larsvers.github.io/learning-d3-mapping-8-2"><span class="koboSpan" id="kobo.8.1">https://larsvers.github.io/learning-d3-mapping-8-2</span></a><span><span class="koboSpan" id="kobo.9.1">.</span></span><span><span class="koboSpan" id="kobo.10.1"> Code example </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_02.html"><span class="koboSpan" id="kobo.11.1">08_02.html</span></a><span><span class="koboSpan" id="kobo.12.1">.</span></span></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft"><span class="koboSpan" id="kobo.13.1">You can see the code to the right in the JavaScript console, and before we step through it, let's note some general observations. </span><span class="koboSpan" id="kobo.13.2">First, every line starts with </span><kbd><span class="koboSpan" id="kobo.14.1">context</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">The Canvas context is really where our drawing comes to life. </span><span class="koboSpan" id="kobo.15.3">Second, Canvas code is written in a procedural style. </span><span class="koboSpan" id="kobo.15.4">This can be a benefit for beginners, as it is linear. </span><span class="koboSpan" id="kobo.15.5">No callbacks, no nested element structure, just a straight line of execution. </span><span class="koboSpan" id="kobo.15.6">This linearity will also extend to time, once you start animating the canvas. </span><span class="koboSpan" id="kobo.15.7">You write the first frame first, then you change the scene, then you write the second frame. </span><span class="koboSpan" id="kobo.15.8">Flip-book simple. </span><span class="koboSpan" id="kobo.15.9">Let's step through the code and see how to create these elements in detail. </span><span class="koboSpan" id="kobo.15.10">The first thing I suggest is giving the canvas a border. </span><span class="koboSpan" id="kobo.15.11">As the canvas element is an HTML element, you can style it with CSS, but we use JavaScript here to show off two properties of the canvas itself: </span><kbd><span class="koboSpan" id="kobo.16.1">width</span></kbd><span class="koboSpan" id="kobo.17.1"> and </span><kbd><span class="koboSpan" id="kobo.18.1">height</span></kbd><span class="koboSpan" id="kobo.19.1">:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">context.strokeStyle = '#CCCCCC';</span><br/><span class="koboSpan" id="kobo.21.1">context.strokeRect(0, 0, canvas.width, canvas.height);</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.22.1">The </span><kbd><span class="koboSpan" id="kobo.23.1">width</span></kbd><span class="koboSpan" id="kobo.24.1"> and </span><kbd><span class="koboSpan" id="kobo.25.1">height</span></kbd><span class="koboSpan" id="kobo.26.1"> are the only properties the canvas element has. </span><span class="koboSpan" id="kobo.26.2">We use them here to read the values of the element, however, they are readable and writable. </span><span class="koboSpan" id="kobo.26.3">This is nice, as you can change the canvas size programmatically when you want to resize your canvas during animation for example. </span><span class="koboSpan" id="kobo.26.4">Next, we build our flat-roofed blue house:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">context.fillStyle = 'royalblue';</span><br/><span class="koboSpan" id="kobo.28.1">context.fillRect(50, 150, 200, 100);</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.29.1">Not much to see here, we've done that previously. </span><span class="koboSpan" id="kobo.29.2">The door won't make you sweat either, as it's the same as the house with a different color:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">context.fillStyle = 'rgba(255, 255, 255, 0.9)';</span><br/><span class="koboSpan" id="kobo.31.1">context.fillRect(60, 190, 40, 60);</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.32.1">However, we use a different method to describe the color. </span><span class="koboSpan" id="kobo.32.2">You can use all CSS color concepts like named color values and hex color values, as well as the </span><kbd><span class="koboSpan" id="kobo.33.1">rgb()</span></kbd><span class="koboSpan" id="kobo.34.1">, </span><kbd><span class="koboSpan" id="kobo.35.1">rgba()</span></kbd><span class="koboSpan" id="kobo.36.1">, </span><kbd><span class="koboSpan" id="kobo.37.1">hsl()</span></kbd><span class="koboSpan" id="kobo.38.1"> and </span><kbd><span class="koboSpan" id="kobo.39.1">hsla()</span></kbd><span class="koboSpan" id="kobo.40.1"> color methods. </span><span class="koboSpan" id="kobo.40.2">The window is placed a little differently with </span><kbd><span class="koboSpan" id="kobo.41.1">context.translate()</span></kbd><span class="koboSpan" id="kobo.42.1">:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">context.save();</span><br/><span class="koboSpan" id="kobo.44.1">context.translate(140, 190);</span><br/><span class="koboSpan" id="kobo.45.1">context.fillRect(0, 0, 60, 30);</span><br/><span class="koboSpan" id="kobo.46.1">context.restore();</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.47.1">In this case, we don't move the rectangle, we move the entire coordinate system! </span><span class="koboSpan" id="kobo.47.2">The </span><kbd><span class="koboSpan" id="kobo.48.1">translate()</span></kbd><span class="koboSpan" id="kobo.49.1"> method takes two arguments: the </span><em><span class="koboSpan" id="kobo.50.1">x</span></em><span class="koboSpan" id="kobo.51.1"> and the </span><em><span class="koboSpan" id="kobo.52.1">y</span></em><span class="koboSpan" id="kobo.53.1"> position you want to move the coordinate system by. </span><span class="koboSpan" id="kobo.53.2">You know this concept already from the use of </span><kbd><span class="koboSpan" id="kobo.54.1">transform, translate(x,y)</span></kbd><span class="koboSpan" id="kobo.55.1"> which is often used to move </span><kbd><span class="koboSpan" id="kobo.56.1">svg:g</span></kbd><span class="koboSpan" id="kobo.57.1"> elements in D3 and create their own coordinate systems. </span><span class="koboSpan" id="kobo.57.2">However, when applied to an </span><kbd><span class="koboSpan" id="kobo.58.1">svg:g</span></kbd><span class="koboSpan" id="kobo.59.1"> element the transformed coordinate system applies to all objects nested within the g element. </span><span class="koboSpan" id="kobo.59.2">As said above, the </span><kbd><span class="koboSpan" id="kobo.60.1">g</span></kbd><span class="koboSpan" id="kobo.61.1"> element, as well as its children, is retained as a scene-graph representation in the DOM, including its coordinate system. </span><span class="koboSpan" id="kobo.61.2">In Canvas, we can't move this information off to a representation of our drawing – there is no such thing. </span><span class="koboSpan" id="kobo.61.3">It's up to you to make sure only elements you want to manifest on a different coordinate system will do so. </span><span class="koboSpan" id="kobo.61.4">Remember above when we talked about the procedural style of writing Canvas code? </span><span class="koboSpan" id="kobo.61.5">This is exactly what we have to keep in mind here. </span><span class="koboSpan" id="kobo.61.6">When we change something in the </span><kbd><span class="koboSpan" id="kobo.62.1">context</span></kbd><span class="koboSpan" id="kobo.63.1"> it will persist through our code until we change it again. </span><span class="koboSpan" id="kobo.63.2">To change the coordinate system back we could alternatively move it to our desired position and move it back afterwards like:</span></p>
<pre><span class="koboSpan" id="kobo.64.1">context.translate(140, 190);</span><br/><span class="koboSpan" id="kobo.65.1">context.fillRect(0, 0, 60, 30);</span><br/><span class="koboSpan" id="kobo.66.1">context.translate(-140, -190);</span></pre>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft"><span class="koboSpan" id="kobo.67.1">But we rather use the generally applicable </span><kbd><span class="koboSpan" id="kobo.68.1">context.save()</span></kbd><span class="koboSpan" id="kobo.69.1"> and </span><kbd><span class="koboSpan" id="kobo.70.1">context.restore()</span></kbd><span class="koboSpan" id="kobo.71.1"> methods. </span><span class="koboSpan" id="kobo.71.2">The </span><kbd><span class="koboSpan" id="kobo.72.1">context.save()</span></kbd><span class="koboSpan" id="kobo.73.1"> saves the state at this point of the code and pushes it onto a </span><strong><span class="koboSpan" id="kobo.74.1">stack</span></strong><span class="koboSpan" id="kobo.75.1">, and  </span><kbd><span class="koboSpan" id="kobo.76.1">context.restore()</span></kbd><span class="koboSpan" id="kobo.77.1"> pops the last saved state off the stack and restores the previous state of the context.  If you haven't come across stacks so far, here's an image explaining what it does: </span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.78.1"><img height="210" width="395" src="assets/55c9677b-a0a1-480e-aa9c-44ba291f5745.png"/></span></div>
<div class="CDPAlignCenter packt_figref CDPAlign"><span class="koboSpan" id="kobo.79.1">The stacked tower of data.</span></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft"><span class="koboSpan" id="kobo.80.1">In short, a</span><span><span class="koboSpan" id="kobo.81.1"> stack is a datatype like an array or an object. </span><span class="koboSpan" id="kobo.81.2">However, a stack is limited to two operations: adding elements on top of the stack (push) and removing elements from the top of the stack (pop). </span><span class="koboSpan" id="kobo.81.3">It's like a brick tower. </span></span><span class="koboSpan" id="kobo.82.1">This care-taking of our application's state is a defining aspect of Canvas and a key difference to SVG.</span></p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft"><span class="koboSpan" id="kobo.83.1">Next, we give the house a triangular roof. </span><span class="koboSpan" id="kobo.83.2">There's no </span><kbd><span class="koboSpan" id="kobo.84.1">triangle()</span></kbd><span class="koboSpan" id="kobo.85.1"> function in Canvas, so you draw a path:</span></p>
<pre><span class="koboSpan" id="kobo.86.1">context.beginPath();</span><br/><span class="koboSpan" id="kobo.87.1">context.moveTo(50, 150);</span><br/><span class="koboSpan" id="kobo.88.1">context.lineTo(250, 150);</span><br/><span class="koboSpan" id="kobo.89.1">context.lineTo(50+200/2, 100); // you can use calculations as inputs!</span><br/><span class="koboSpan" id="kobo.90.1">context.closePath();</span><br/><span class="koboSpan" id="kobo.91.1">context.fillStyle = '#A52A2A';</span><br/><span class="koboSpan" id="kobo.92.1">context.fill();</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.93.1">Finally, we draw the tree. </span><span class="koboSpan" id="kobo.93.2">A tree has a brown stem, which you implement as a straight path, and a green treetop, which you draw as a green circle:</span></p>
<pre><span class="koboSpan" id="kobo.94.1">context.beginPath();</span><br/><span class="koboSpan" id="kobo.95.1">context.lineWidth = 10;</span><br/><span class="koboSpan" id="kobo.96.1">context.strokeStyle = 'brown'</span><br/><span class="koboSpan" id="kobo.97.1">context.moveTo(300, 250);</span><br/><span class="koboSpan" id="kobo.98.1">context.lineTo(300, 200);</span><br/><span class="koboSpan" id="kobo.99.1">context.stroke();</span><br/><br/><span class="koboSpan" id="kobo.100.1">context.beginPath();</span><br/><span class="koboSpan" id="kobo.101.1">context.fillStyle = 'green';</span><br/><span class="koboSpan" id="kobo.102.1">context.arc(300, 175, 25, 0, Math.PI * 2);</span><br/><span class="koboSpan" id="kobo.103.1">context.fill();</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.104.1">There are two things to note here. </span><span class="koboSpan" id="kobo.104.2">First, all path code blocks are bracketed by </span><kbd><span class="koboSpan" id="kobo.105.1">beginPath()</span></kbd><span class="koboSpan" id="kobo.106.1"> and either </span><kbd><span class="koboSpan" id="kobo.107.1">stroke()</span></kbd><span class="koboSpan" id="kobo.108.1"> (the stem) or </span><kbd><span class="koboSpan" id="kobo.109.1">fill()</span></kbd><span class="koboSpan" id="kobo.110.1"> (the roof and treetop):</span></p>
<pre><span class="koboSpan" id="kobo.111.1">context.beginPath();</span><br/><span class="koboSpan" id="kobo.112.1">// configure your path here</span><br/><span class="koboSpan" id="kobo.113.1">context.stroke();</span><br/><br/><span class="koboSpan" id="kobo.114.1">context.beginPath();</span><br/><span class="koboSpan" id="kobo.115.1">// configure your path here</span><br/><span class="koboSpan" id="kobo.116.1">context.fill();</span></pre>
<p class="mce-root"><kbd><span class="koboSpan" id="kobo.117.1">beginPath()</span></kbd><span class="koboSpan" id="kobo.118.1"> signifies the intent to draw a new path and removes all current path (or sub-path) implementations. </span><kbd><span class="koboSpan" id="kobo.119.1">stroke()</span></kbd><span class="koboSpan" id="kobo.120.1"> and </span><kbd><span class="koboSpan" id="kobo.121.1">fill()</span></kbd><span class="koboSpan" id="kobo.122.1"> signify the end of the path and will produce the path on the screen. </span><kbd><span class="koboSpan" id="kobo.123.1">fill()</span></kbd><span class="koboSpan" id="kobo.124.1"> will fill the path body with the set </span><kbd><span class="koboSpan" id="kobo.125.1">fillStyle</span></kbd><span class="koboSpan" id="kobo.126.1"> color, and </span><kbd><span class="koboSpan" id="kobo.127.1">stroke()</span></kbd><span class="koboSpan" id="kobo.128.1"> will only draw the path contour in with the set </span><kbd><span class="koboSpan" id="kobo.129.1">strokeStyle()</span></kbd><span class="koboSpan" id="kobo.130.1"> method. </span><span class="koboSpan" id="kobo.130.2">Whenever you draw a path, you will need these start and end methods. </span><span class="koboSpan" id="kobo.130.3">In fact, whenever you draw anything you will need them. </span><kbd><span class="koboSpan" id="kobo.131.1">fillRect()</span></kbd><span class="koboSpan" id="kobo.132.1"> or </span><kbd><span class="koboSpan" id="kobo.133.1">strokeRect()</span></kbd><span class="koboSpan" id="kobo.134.1">, as used previously, are just wrappers for beginning a path, drawing a path, and filling or stroking a path.</span><em><span class="koboSpan" id="kobo.135.1"> </span></em><span class="koboSpan" id="kobo.136.1">You might have noticed that we only drew two sides of the triangular roof and then used </span><kbd><span class="koboSpan" id="kobo.137.1">closePath()</span></kbd><span class="koboSpan" id="kobo.138.1"> which connects the current endpoint of the path with the starting point. </span><span class="koboSpan" id="kobo.138.2">The </span><kbd><span class="koboSpan" id="kobo.139.1">fill()</span></kbd><span class="koboSpan" id="kobo.140.1"> method will also close the path for you, but making this explicit is more thorough, more performant and a service to the reader of your code (including yourself). </span><span class="koboSpan" id="kobo.140.2">The second thing to note is that even a circle is a path. </span><span class="koboSpan" id="kobo.140.3">In fact, the only primitive shape beyond a path offered by the Canvas API is the rectangle. </span><span class="koboSpan" id="kobo.140.4">SVG facilitates the use of </span><kbd><span class="koboSpan" id="kobo.141.1">&lt;rect&gt;</span></kbd><span class="koboSpan" id="kobo.142.1">, </span><kbd><span class="koboSpan" id="kobo.143.1">&lt;circle&gt;</span></kbd><span class="koboSpan" id="kobo.144.1">, </span><kbd><span class="koboSpan" id="kobo.145.1">&lt;ellipse&gt;</span></kbd><span class="koboSpan" id="kobo.146.1">, </span><kbd><span class="koboSpan" id="kobo.147.1">&lt;line&gt;</span></kbd><span class="koboSpan" id="kobo.148.1">, </span><kbd><span class="koboSpan" id="kobo.149.1">&lt;polyline&gt;</span></kbd><span class="koboSpan" id="kobo.150.1">, </span><kbd><span class="koboSpan" id="kobo.151.1">&lt;polygon&gt;</span></kbd><span class="koboSpan" id="kobo.152.1">, and </span><kbd><span class="koboSpan" id="kobo.153.1">&lt;path&gt;</span></kbd><span class="koboSpan" id="kobo.154.1">, while Canvas only offers paths and rectangles. </span><span class="koboSpan" id="kobo.154.2">However, drawing shapes with paths quickly becomes routine. </span><span class="koboSpan" id="kobo.154.3">While there is no pre-defined circle, there's the </span><kbd><span class="koboSpan" id="kobo.155.1">arc()</span></kbd><span class="koboSpan" id="kobo.156.1"> and </span><kbd><span class="koboSpan" id="kobo.157.1">arcTo()</span></kbd><span class="koboSpan" id="kobo.158.1"> methods, which pretty much do the circle drawing for you. </span><span class="koboSpan" id="kobo.158.2">You just need to add color to it and wrap it into the path start and end methods. </span><kbd><span class="koboSpan" id="kobo.159.1">arc()</span></kbd><span class="koboSpan" id="kobo.160.1"> takes five arguments, the </span><em><span class="koboSpan" id="kobo.161.1">x</span></em><span class="koboSpan" id="kobo.162.1"> and the </span><em><span class="koboSpan" id="kobo.163.1">y</span></em><span class="koboSpan" id="kobo.164.1"> position, the </span><em><span class="koboSpan" id="kobo.165.1">radius</span></em><span class="koboSpan" id="kobo.166.1">, the </span><em><span class="koboSpan" id="kobo.167.1">start</span></em><span class="koboSpan" id="kobo.168.1"> and the </span><em><span class="koboSpan" id="kobo.169.1">end angle</span></em><span class="koboSpan" id="kobo.170.1"> of our arc. Both angles are being measured in radians.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.171.1">A radian? </span><span class="koboSpan" id="kobo.171.2">One </span><strong><span class="koboSpan" id="kobo.172.1">radian</span></strong><span class="koboSpan" id="kobo.173.1"> equals </span><em><span class="koboSpan" id="kobo.174.1">57.3</span></em><span class="koboSpan" id="kobo.175.1"> degrees. </span><span class="koboSpan" id="kobo.175.2">Radians are an alternative unit of measurement for angles. </span><span class="koboSpan" id="kobo.175.3">They are beloved by mathematicians as they make a lot of sense in geometric calculations. </span><span class="koboSpan" id="kobo.175.4">To get a radian, you take the radius of a circle and wrap it around that circle – if you can imagine that the </span><span><span class="koboSpan" id="kobo.176.1">radius line is bendable</span></span><span class="koboSpan" id="kobo.177.1">:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.178.1"><img height="201" width="381" src="assets/53c20cea-49e6-4796-a838-b1b48daf4bd3.png"/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.179.1">How to get a radian</span></div>
<p class="mce-root CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.180.1">Their mathematical advantage is that they can be derived directly from the radius of a circle. </span><span class="koboSpan" id="kobo.180.2">The further beauty is that half a circle (as in 180 degrees) is exactly one </span><em><span class="koboSpan" id="kobo.181.1">PI</span></em><span class="koboSpan" id="kobo.182.1"> radians. </span><span class="koboSpan" id="kobo.182.2">Hence, a full circle equals </span><em><span class="koboSpan" id="kobo.183.1">2 * PI</span></em><span class="koboSpan" id="kobo.184.1"> radians.</span></p>
<p><span class="koboSpan" id="kobo.185.1">Degrees probably make more sense to you. </span><span class="koboSpan" id="kobo.185.2">That's fine. </span><span class="koboSpan" id="kobo.185.3">They also make more sense if you want to move objects around on the screen. </span><span class="koboSpan" id="kobo.185.4">You can easily convert between radians and degrees by using the following formula: </span><em><span class="koboSpan" id="kobo.186.1">(</span></em><em><span class="koboSpan" id="kobo.187.1">PI / 180) * degrees</span></em><span class="koboSpan" id="kobo.188.1">. </span><em><span class="koboSpan" id="kobo.189.1">PI</span></em><span class="koboSpan" id="kobo.190.1"> is half a circle in radians and 180 is half a circle in degrees. </span><span class="koboSpan" id="kobo.190.2">By dividing one by the other, you express one degree in radians, which equals 0.0175. </span><span class="koboSpan" id="kobo.190.3">Multiply any degree number you desire with 0.0175 and use the result as radians.</span></p>
<p><span class="koboSpan" id="kobo.191.1">OK! </span><span class="koboSpan" id="kobo.191.2">We've drawn a landscape with a house – that's great. </span><span class="koboSpan" id="kobo.191.3">There is certainly more to Canvas, but by following these simple steps you have learned a lot. </span><span class="koboSpan" id="kobo.191.4">You have learned about the concept of drawing with Canvas and what it means to write your code procedurally. </span><span class="koboSpan" id="kobo.191.5">You have seen how to draw individual shapes with Canvas, how you can move individual objects around with a translate transformation, and how the atomic unit of each Canvas shape is the path. </span><span class="koboSpan" id="kobo.191.6">Now, let's step it up and animate our landscape the Canvas way before we do it the D3 way.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Animating the Canvas</span></h1>
                </header>
            
            <article>
                
<div class="CDPAlignCenter CDPAlign CDPAlignLeft">
<p><span class="koboSpan" id="kobo.2.1">One of Canvas's key advantages is animation. </span><span class="koboSpan" id="kobo.2.2">While the browser must work hard to re-calculate and re-render many elements retained in a DOM, it is relatively unstressed re-drawing a bitmapped image. </span><span class="koboSpan" id="kobo.2.3">In the following section, you will learn how to animate with Canvas. </span><span class="koboSpan" id="kobo.2.4">Let's first look at how you do it in a pure, vanilla Canvas way. </span><span class="koboSpan" id="kobo.2.5">After that, let's see if we can use D3's transition and life cycle Enter-Update-Exit pattern to help us animate. </span><span class="koboSpan" id="kobo.2.6">Both ways will be immensely helpful when building visualizations with D3 and Canvas as you will be able to choose the right technique for your own ideas or complement the two.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Animating the Canvas way</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's go back to our house and test its roof with rain:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="368" width="548" src="assets/340c42b9-f372-4ebb-9e18-70752f326cf3.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">It's really raining.</span></div>
<div class="FigurePACKT packt_figref packt_infobox CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.5.1">View this step in the browser: </span><a href="https://larsvers.github.io/learning-d3-mapping-8-3"><span class="koboSpan" id="kobo.6.1">https://larsvers.github.io/learning-d3-mapping-8-3</span></a><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">Code example </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_03.html"><span class="koboSpan" id="kobo.8.1">08_03.html</span></a><span class="koboSpan" id="kobo.9.1">.</span></div>
<p><span class="koboSpan" id="kobo.10.1">It's hard to see in a static image, but the blue dots are in fact moving down when viewed in the browser. </span><span class="koboSpan" id="kobo.10.2">They are also moving at different speeds, which makes the rain look a little more realistic.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting a general overview</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">On the abstracted top level our code looks as follows:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">var canvas = d3.select('#main-canvas').node();  // set up</span><br/><span class="koboSpan" id="kobo.4.1">var context = canvas.getContext('2d');</span><br/><br/><span class="koboSpan" id="kobo.5.1">var rain = { }                                  // produce data</span><br/><span class="koboSpan" id="kobo.6.1">d3.interval(function() {</span><br/><span class="koboSpan" id="kobo.7.1">    update();                                   // update/process the data</span><br/><span class="koboSpan" id="kobo.8.1">    animate();                                  // re-draw the canvas</span><br/><span class="koboSpan" id="kobo.9.1">}, 10);                                         </span></pre>
<p><span class="koboSpan" id="kobo.10.1">After setting up the canvas, you will produce some data – the raindrops. </span><span class="koboSpan" id="kobo.10.2">Then you will enter a loop within which you will update the data for the next scene and then draw it. </span><span class="koboSpan" id="kobo.10.3">In our case, </span><kbd><span class="koboSpan" id="kobo.11.1">update()</span></kbd><span class="koboSpan" id="kobo.12.1"> changes the raindrops' positions and </span><kbd><span class="koboSpan" id="kobo.13.1">animate()</span></kbd><span class="koboSpan" id="kobo.14.1"> will clear the current image and draw a new image with the updated raindrop positions.</span></p>
<p><span class="koboSpan" id="kobo.15.1">This loop (or at least a very similar incarnation) is called the </span><strong><span class="koboSpan" id="kobo.16.1">game loop</span></strong><span class="koboSpan" id="kobo.17.1">, as it is used in game programming with Canvas. </span><span class="koboSpan" id="kobo.17.2">You process the gamer's input, update the game data accordingly, and draw the new scene. </span><span class="koboSpan" id="kobo.17.3">We will get used to this pattern quickly. </span><span class="koboSpan" id="kobo.17.4">Now, let's look at the details.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Preparing the rain data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The elements you're dealing with are raindrops. </span><span class="koboSpan" id="kobo.2.2">Before we update or animate a single raindrop, we produce them. </span><span class="koboSpan" id="kobo.2.3">We're building out a so called </span><em><span class="koboSpan" id="kobo.3.1">object literal module</span></em><span class="koboSpan" id="kobo.4.1"> called </span><kbd><span class="koboSpan" id="kobo.5.1">rain</span></kbd><span class="koboSpan" id="kobo.6.1">  (it's an </span><em><span class="koboSpan" id="kobo.7.1">object literal</span></em><span class="koboSpan" id="kobo.8.1">) that knows how to produce raindrops and that keeps the </span><span><span class="koboSpan" id="kobo.9.1">i</span></span><span class="koboSpan" id="kobo.10.1">ndividual drops save in an array called </span><kbd><span class="koboSpan" id="kobo.11.1">items</span></kbd><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">It will look like so: </span></p>
<pre><span class="koboSpan" id="kobo.13.1">var rain = {</span><br/><span class="koboSpan" id="kobo.14.1">    items: [],</span><br/><span class="koboSpan" id="kobo.15.1">    maxDrops: 200,</span><br/><span class="koboSpan" id="kobo.16.1">    getDrop: function() {</span><br/><span class="koboSpan" id="kobo.17.1">      var obj = {};</span><br/><span class="koboSpan" id="kobo.18.1">      obj.xStart = Math.floor(Math.random() * canvas.width);</span><br/><span class="koboSpan" id="kobo.19.1">      obj.yStart = Math.floor(Math.random() * -canvas.height);</span><br/><span class="koboSpan" id="kobo.20.1">      obj.x = null;</span><br/><span class="koboSpan" id="kobo.21.1">      obj.y = null;</span><br/><span class="koboSpan" id="kobo.22.1">      obj.speed = Math.round(Math.random() * 2) + 5;</span><br/><br/><span class="koboSpan" id="kobo.23.1">      return obj;</span><br/><span class="koboSpan" id="kobo.24.1">    },</span><br/><span class="koboSpan" id="kobo.25.1">    updateDrop: // see below</span><br/><span class="koboSpan" id="kobo.26.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.27.1">The </span><kbd><span class="koboSpan" id="kobo.28.1">rain</span></kbd><span class="koboSpan" id="kobo.29.1"> object consists of this as yet empty array </span><kbd><span class="koboSpan" id="kobo.30.1">items</span></kbd><span class="koboSpan" id="kobo.31.1"> that will hold all the raindrop objects we produce and a variable called </span><kbd><span class="koboSpan" id="kobo.32.1">maxDrops</span></kbd><span class="koboSpan" id="kobo.33.1">, confining the number of raindrops (the length of </span><kbd><span class="koboSpan" id="kobo.34.1">items</span></kbd><span class="koboSpan" id="kobo.35.1">) to 200 in this case. </span><span class="koboSpan" id="kobo.35.2">This can be considered light rain. </span><span class="koboSpan" id="kobo.35.3">Crank this up to a higher number if you want to drown the tree or test the app's performance. </span><span class="koboSpan" id="kobo.35.4">As we like the tree and shall test performance in an example to come, 200 will do for now.</span></p>
<p><span class="koboSpan" id="kobo.36.1">Two functions will help to produce and update the drops. </span><kbd><span class="koboSpan" id="kobo.37.1">getDrop()</span></kbd><span class="koboSpan" id="kobo.38.1"> assigns start positions out of sight above the canvas, as well as empty </span><kbd><span class="koboSpan" id="kobo.39.1">x</span></kbd><span class="koboSpan" id="kobo.40.1"> and </span><kbd><span class="koboSpan" id="kobo.41.1">y</span></kbd><span class="koboSpan" id="kobo.42.1"> positions which will be filled on update. </span><span class="koboSpan" id="kobo.42.2">You also define the speed of the drop, which can take on values between five and seven. </span><span class="koboSpan" id="kobo.42.3">The speed will be the number of pixels the raindrop will move forward on each update. </span><span class="koboSpan" id="kobo.42.4">A low number will produce slow rain and a higher number will produce fast rain.</span></p>
<p><span class="koboSpan" id="kobo.43.1">The </span><kbd><span class="koboSpan" id="kobo.44.1">updateDrop()</span></kbd><span class="koboSpan" id="kobo.45.1"> function can be called in case we, well, want to update a drop's position. </span><span class="koboSpan" id="kobo.45.2">Let's do this now.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Updating each drop</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The site loads and things will kick off with the </span><kbd><span class="koboSpan" id="kobo.3.1">d3.interval</span></kbd><span class="koboSpan" id="kobo.4.1"> function, which calls all functions it embraces every 10 milliseconds. </span><span class="koboSpan" id="kobo.4.2">First, it will call </span><kbd><span class="koboSpan" id="kobo.5.1">update()</span></kbd><span class="koboSpan" id="kobo.6.1"> which returns an array of objects. </span><span class="koboSpan" id="kobo.6.2">Each object is a drop most notably characterized by an arbitrary </span><kbd><span class="koboSpan" id="kobo.7.1">x</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">y</span></kbd><span class="koboSpan" id="kobo.10.1"> position. </span><span class="koboSpan" id="kobo.10.2">This is how it looks:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">function update() {</span><br/><span class="koboSpan" id="kobo.12.1">  if (!rain.items.length) {</span><br/><span class="koboSpan" id="kobo.13.1">    d3.range(rain.maxDrops).forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.14.1">      var drop = rain.getDrop(el);</span><br/><span class="koboSpan" id="kobo.15.1">      rain.updateDrop(drop);</span><br/><span class="koboSpan" id="kobo.16.1">      rain.items.push(drop);</span><br/><span class="koboSpan" id="kobo.17.1">    });</span><br/><span class="koboSpan" id="kobo.18.1">  } else {</span><br/><span class="koboSpan" id="kobo.19.1">    rain.items.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.20.1">      rain.updateDrop(el);</span><br/><span class="koboSpan" id="kobo.21.1">    });</span><br/><span class="koboSpan" id="kobo.22.1">  }</span><br/><span class="koboSpan" id="kobo.23.1">}</span></pre>
<p><span class="koboSpan" id="kobo.24.1">The first time </span><kbd><span class="koboSpan" id="kobo.25.1">update()</span></kbd><span class="koboSpan" id="kobo.26.1"> is called it produces a drop, updates its position, and pushes it into the rain items array. </span><span class="koboSpan" id="kobo.26.2">Any other time, it just updates the drop's position. </span><span class="koboSpan" id="kobo.26.3">We use </span><kbd><span class="koboSpan" id="kobo.27.1">d3.range</span></kbd><span class="koboSpan" id="kobo.28.1"> as a convenient method for this loop. </span><span class="koboSpan" id="kobo.28.2">It takes an integer as input and returns an array of integers starting at 0, and the length of the number you pass in. </span><span class="koboSpan" id="kobo.28.3">Here it helps create as many rain drops as we specified in </span><kbd><span class="koboSpan" id="kobo.29.1">maxDrops</span></kbd><span class="koboSpan" id="kobo.30.1">.</span></p>
<p><span class="koboSpan" id="kobo.31.1">We then update the drop's position with the </span><kbd><span class="koboSpan" id="kobo.32.1">updateDrop()</span></kbd><span class="koboSpan" id="kobo.33.1"> function we started to describe previously:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">updateDrop: function(drop) {</span><br/><span class="koboSpan" id="kobo.35.1">  drop.x = drop.x === null ? </span><span class="koboSpan" id="kobo.35.2">drop.xStart : drop.x;</span><br/><span class="koboSpan" id="kobo.36.1">  drop.y = drop.y === null ? </span><span class="koboSpan" id="kobo.36.2">drop.yStart : drop.y + drop.speed;</span><br/><span class="koboSpan" id="kobo.37.1">  drop.y = drop.y &gt; canvas.height ? </span><span class="koboSpan" id="kobo.37.2">drop.yStart : drop.y;</span><br/><span class="koboSpan" id="kobo.38.1">}</span></pre>
<p><span class="koboSpan" id="kobo.39.1">If the drop's </span><kbd><span class="koboSpan" id="kobo.40.1">x</span></kbd><span class="koboSpan" id="kobo.41.1"> and </span><kbd><span class="koboSpan" id="kobo.42.1">y</span></kbd><span class="koboSpan" id="kobo.43.1"> positions don't exist yet (if they are </span><kbd><span class="koboSpan" id="kobo.44.1">null</span></kbd><span class="koboSpan" id="kobo.45.1">) we assign the </span><kbd><span class="koboSpan" id="kobo.46.1">xStart</span></kbd><span class="koboSpan" id="kobo.47.1"> or </span><kbd><span class="koboSpan" id="kobo.48.1">yStart</span></kbd><span class="koboSpan" id="kobo.49.1"> values to it. </span><span class="koboSpan" id="kobo.49.2">If not, we leave the </span><kbd><span class="koboSpan" id="kobo.50.1">x</span></kbd><span class="koboSpan" id="kobo.51.1"> position where it is as no drop will move to any side, and we move the </span><kbd><span class="koboSpan" id="kobo.52.1">y</span></kbd><span class="koboSpan" id="kobo.53.1"> position downwards by speed. </span><span class="koboSpan" id="kobo.53.2">This will make the drop move down between five and seven pixels every 10 milliseconds. </span><span class="koboSpan" id="kobo.53.3">The last line recycles each drop. </span><span class="koboSpan" id="kobo.53.4">Once it has reached the final border of the bottom canvas, we just set its </span><kbd><span class="koboSpan" id="kobo.54.1">y</span></kbd><span class="koboSpan" id="kobo.55.1"> value to the initial </span><kbd><span class="koboSpan" id="kobo.56.1">yStart</span></kbd><span class="koboSpan" id="kobo.57.1"> value.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing frame by frame</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Back in our </span><kbd><span class="koboSpan" id="kobo.3.1">d3.interval</span></kbd><span class="koboSpan" id="kobo.4.1"> loop, </span><kbd><span class="koboSpan" id="kobo.5.1">update()</span></kbd><span class="koboSpan" id="kobo.6.1"> has run and we have the positions of all our raindrops. </span><span class="koboSpan" id="kobo.6.2">Next, we will deal with drawing them. </span><span class="koboSpan" id="kobo.6.3">If we had a DOM, we would interact with our omnipresent 200 SVG circles and ask them kindly to move down a little. </span><span class="koboSpan" id="kobo.6.4">But we produce a static image and we can only draw and not change. </span><span class="koboSpan" id="kobo.6.5">So, we draw. </span><span class="koboSpan" id="kobo.6.6">Like in a flip book we dispose of the old image and draw a new one. </span><span class="koboSpan" id="kobo.6.7">Let's repeat this. </span><span class="koboSpan" id="kobo.6.8">Each time we want to move something on the canvas we </span><strong><span class="koboSpan" id="kobo.7.1">remove</span></strong> <strong><span class="koboSpan" id="kobo.8.1">the old image</span></strong><span class="koboSpan" id="kobo.9.1"> and </span><strong><span class="koboSpan" id="kobo.10.1">draw a new image</span></strong><span class="koboSpan" id="kobo.11.1"> with changed positions.</span></p>
<p><span class="koboSpan" id="kobo.12.1">It's straightforward:</span></p>
<pre><span class="koboSpan" id="kobo.13.1">function animate() {</span><br/><span class="koboSpan" id="kobo.14.1">  context.clearRect(0, 0, canvas.width, canvas.height);     </span><br/><span class="koboSpan" id="kobo.15.1">  drawScene();</span><br/><span class="koboSpan" id="kobo.16.1">  rain.items.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.17.1">    circle(context, el.x, el.y, 1.5, 'blue');</span><br/><span class="koboSpan" id="kobo.18.1">  });</span><br/><span class="koboSpan" id="kobo.19.1">}</span></pre>
<p><kbd><span class="koboSpan" id="kobo.20.1">animate()</span></kbd><span class="koboSpan" id="kobo.21.1"> uses the context's own </span><kbd><span class="koboSpan" id="kobo.22.1">clearRect()</span></kbd><span class="koboSpan" id="kobo.23.1"> function, which does what it says on the tin. </span><span class="koboSpan" id="kobo.23.2">You pass it the area you want to clear – in our case the entire canvas – and it will clear it. </span><span class="koboSpan" id="kobo.23.3">You can also fill a white rectangle or change the </span><kbd><span class="koboSpan" id="kobo.24.1">canvas.width</span></kbd><span class="koboSpan" id="kobo.25.1"> and </span><kbd><span class="koboSpan" id="kobo.26.1">canvas.height</span></kbd><span class="koboSpan" id="kobo.27.1"> values, but </span><kbd><span class="koboSpan" id="kobo.28.1">clearRect()</span></kbd><span class="koboSpan" id="kobo.29.1"> is faster than the first and clearer than the second method.</span></p>
<p><span class="koboSpan" id="kobo.30.1">Next, you run the </span><kbd><span class="koboSpan" id="kobo.31.1">drawScene()</span></kbd><span class="koboSpan" id="kobo.32.1"> function, which draws our scene: the house and the tree. </span><span class="koboSpan" id="kobo.32.2">It's what you built in the previous section, just wrapped up in an aptly-named function.</span></p>
<p><span class="koboSpan" id="kobo.33.1">Finally, we draw each drop to the canvas. </span><span class="koboSpan" id="kobo.33.2">What is </span><kbd><span class="koboSpan" id="kobo.34.1">circle()</span></kbd><span class="koboSpan" id="kobo.35.1"> you ask? </span><span class="koboSpan" id="kobo.35.2">It's a helper function to build visual primitives – in our case a circle. </span><span class="koboSpan" id="kobo.35.3">It has been added at the top of the code:</span></p>
<pre><span class="koboSpan" id="kobo.36.1">function circle(ctx, x, y, r, color) {</span><br/><span class="koboSpan" id="kobo.37.1">  ctx.beginPath();</span><br/><span class="koboSpan" id="kobo.38.1">  ctx.fillStyle = color;</span><br/><span class="koboSpan" id="kobo.39.1">  ctx.arc(x, y, r, 0, 2 * Math.PI);</span><br/><span class="koboSpan" id="kobo.40.1">  ctx.fill();</span><br/><span class="koboSpan" id="kobo.41.1">}</span></pre>
<p><span class="koboSpan" id="kobo.42.1">The two main functions </span><kbd><span class="koboSpan" id="kobo.43.1">update()</span></kbd><span class="koboSpan" id="kobo.44.1"> and </span><kbd><span class="koboSpan" id="kobo.45.1">animate()</span></kbd><span class="koboSpan" id="kobo.46.1"> are being run repeatedly until the end of your browser tab's session; which could mean bad weather for some time.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Canvas and D3</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">D3 offers unmatched functionality for producing data visualizations on the web. </span><span class="koboSpan" id="kobo.2.2">You might be aware of this, reading this very book. </span><span class="koboSpan" id="kobo.2.3">One important part of what D3 offers is its model for how data-infused elements evolve on the screen. </span><span class="koboSpan" id="kobo.2.4">It has a certain way of thinking about the life cycle of each element.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In practice, you inject data into a yet non-existent DOM, and D3 creates new elements of your choice as per the data you inject, usually one element per data point. </span><span class="koboSpan" id="kobo.3.2">If you want to inject new data into the DOM you can do so and D3 identifies which elements have to be newly created, which elements are allowed to stay, and which elements should pack up and leave the screen. </span><span class="koboSpan" id="kobo.3.3">This way you can represent three distinct states of a common data-flow: </span><strong><span class="koboSpan" id="kobo.4.1">entering</span></strong><span class="koboSpan" id="kobo.5.1"> data, </span><strong><span class="koboSpan" id="kobo.6.1">updating</span></strong><span class="koboSpan" id="kobo.7.1"> data, and </span><strong><span class="koboSpan" id="kobo.8.1">exiting</span></strong><span class="koboSpan" id="kobo.9.1"> data. </span><span class="koboSpan" id="kobo.9.2">You can then grab these selections, manipulate their visual properties as well as transition between them with D3's built-in interpolators, leveraged by </span><kbd><span class="koboSpan" id="kobo.10.1">d3.transition()</span></kbd><span class="koboSpan" id="kobo.11.1">.</span></p>
<p><span class="koboSpan" id="kobo.12.1">This plays well with the retained SVG elements that are manifested in the DOM. </span><span class="koboSpan" id="kobo.12.2">However, we have no DOM elements in the canvas and must, therefore, be a little clever about producing them. </span><span class="koboSpan" id="kobo.12.3">Let's see how we can follow D3's life cycle model as well as using D3's transitions to interpolate between these three states.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting an overview of our experiment</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will still let it rain over our little house and its tree, but now the rain will follow its natural course – the rain's life cycle, as it were. </span><span class="koboSpan" id="kobo.2.2">It will </span><strong><span class="koboSpan" id="kobo.3.1">Enter</span></strong><span class="koboSpan" id="kobo.4.1"> in the form of a cloud, it will </span><strong><span class="koboSpan" id="kobo.5.1">Update</span></strong><span class="koboSpan" id="kobo.6.1"> as the rain moving into a big puddle on the ground, and it will </span><strong><span class="koboSpan" id="kobo.7.1">Exit</span></strong><span class="koboSpan" id="kobo.8.1"> turning the puddle into a lush patch of grass:</span></p>
<div class="CDPAlignCenter CDPAlign"><strong><span class="koboSpan" id="kobo.9.1"><img src="assets/b3ca6039-2d84-45f6-bd58-393a6cb80d34.png"/></span></strong></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1">Enter, Update and Exit the rain </span></div>
<div class="FigurePACKT packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.11.1">View this step in the browser: </span></span><a href="https://larsvers.github.io/learning-d3-mapping-8-4b"><span class="koboSpan" id="kobo.12.1">https://larsvers.github.io/learning-d3-mapping-8-4b</span></a><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Code example </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04b.html"><span class="koboSpan" id="kobo.14.1">08_04b.html</span></a><span class="koboSpan" id="kobo.15.1">.</span></div>
<p><span class="koboSpan" id="kobo.16.1">As you can see, there are buttons to the right allowing you to control the three state changes.</span></p>
<p><span class="koboSpan" id="kobo.17.1">The structure of the code will be similar to the previous pure Canvas animation. </span><span class="koboSpan" id="kobo.17.2">Conceptually, you calculate the elements' (the raindrops') positions first and then draw. </span><span class="koboSpan" id="kobo.17.3">However, the way we achieve this interaction is entirely via D3. </span><span class="koboSpan" id="kobo.17.4">To lift the lid in advance, you will bind the data to virtual DOM elements. </span><span class="koboSpan" id="kobo.17.5">These DOM elements are ‘virtual'. </span><span class="koboSpan" id="kobo.17.6">As Canvas has no DOM, you create a basic DOM structure in memory, with which we can use D3's selections, the data join, and consequently the Enter-Update-Exit API. </span><span class="koboSpan" id="kobo.17.7">Additionally, the app will have button interactions to change the elements' state according to the changed data. </span><span class="koboSpan" id="kobo.17.8">We have discussed the Canvas setup as well as data preparation already, so let's focus on the core novelty of this section, the databind and the draw!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Having said that, we should have a brief look at the data we will produce with a function called </span><kbd><span class="koboSpan" id="kobo.3.1">getRainData()</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">It will give us 2,500 raindrops (heavy rain this time) that look a little different to our previous example:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="280" width="435" src="assets/f4cc465b-c0ab-408e-8d50-5d1e0aee1ea2.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1">A raindrop the Vanilla Canvas way versus a raindrop the D3-and-Canvas way</span></div>
<p><span class="koboSpan" id="kobo.7.1">The key differences are that you don't need the speed for the D3 raindrop version, as we plan for D3's transition to implement the animation. </span><span class="koboSpan" id="kobo.7.2">Further, the </span><strong><span class="koboSpan" id="kobo.8.1">D3 and Canvas</span></strong><span class="koboSpan" id="kobo.9.1"> raindrop has properties for a set of states included, while the </span><strong><span class="koboSpan" id="kobo.10.1">Vanilla Canvas</span></strong><span class="koboSpan" id="kobo.11.1"> raindrop only has start and current positions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Updating each drop</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With the data in place, it's now time to make it move. </span><span class="koboSpan" id="kobo.2.2">In the pure Canvas example, you drew each point on the canvas, then calculated new points adding five pixels to the previous point's position, removed the old image, and drew the new one with the advanced drops. </span><span class="koboSpan" id="kobo.2.3">You transitioned the points yourself.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Employing D3's transition methods differs in that we won't calculate the new position, but D3 will do it for us. </span><span class="koboSpan" id="kobo.3.2">You will bind the data to selections, ask D3 to transition the values, and while it transitions you will redraw the canvas for as long as the transition runs. </span><span class="koboSpan" id="kobo.3.3">On a top level, you only need two functions to do this:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">databind(data) {</span><br/><span class="koboSpan" id="kobo.5.1">  // Bind data to custom elements.</span><br/><span class="koboSpan" id="kobo.6.1">}</span><br/><span class="koboSpan" id="kobo.7.1">draw() {</span><br/><span class="koboSpan" id="kobo.8.1">  // Draw the elements on the canvas.</span><br/><span class="koboSpan" id="kobo.9.1">}</span></pre>
<p><span class="koboSpan" id="kobo.10.1">It's pretty straightforward.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Binding the data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">However, D3 implements transitions on selections, and we don't have selections yet. </span><span class="koboSpan" id="kobo.2.2">A single D3 selection is an element with bound data. </span><span class="koboSpan" id="kobo.2.3">With D3 you select a DOM element, usually SVG, join data to it, and you have a selection with all its wondrous methods: the explicit </span><kbd><span class="koboSpan" id="kobo.3.1">enter()</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">exit()</span></kbd><span class="koboSpan" id="kobo.6.1"> methods, the implicit </span><kbd><span class="koboSpan" id="kobo.7.1">update()</span></kbd><span class="koboSpan" id="kobo.8.1"> method triggered by </span><kbd><span class="koboSpan" id="kobo.9.1">data()</span></kbd><span class="koboSpan" id="kobo.10.1">, as well as </span><kbd><span class="koboSpan" id="kobo.11.1">transition()</span></kbd><span class="koboSpan" id="kobo.12.1"> and their helpers </span><kbd><span class="koboSpan" id="kobo.13.1">duration()</span></kbd><span class="koboSpan" id="kobo.14.1"> and </span><kbd><span class="koboSpan" id="kobo.15.1">delay()</span></kbd><span class="koboSpan" id="kobo.16.1"> that control the transition.</span></p>
<p><span class="koboSpan" id="kobo.17.1">To create selections, you just create DOM-like elements, and the great thing is, you don't need the incarnated DOM to do so. </span><span class="koboSpan" id="kobo.17.2">You can create them in memory. </span><span class="koboSpan" id="kobo.17.3">Here's how:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">var customBase = document.createElement('custom')</span><br/><span class="koboSpan" id="kobo.19.1">var custom = d3.select(customBase);</span></pre>
<p><span class="koboSpan" id="kobo.20.1">You can imagine </span><kbd><span class="koboSpan" id="kobo.21.1">customBase</span></kbd><span class="koboSpan" id="kobo.22.1"> as a replacement of a root SVG element and </span><kbd><span class="koboSpan" id="kobo.23.1">custom</span></kbd><span class="koboSpan" id="kobo.24.1"> to be a fully-fledged D3 selection. </span><span class="koboSpan" id="kobo.24.2">With your foundation in place you can go about the usual D3 business of binding data to your custom elements with the </span><kbd><span class="koboSpan" id="kobo.25.1">databind()</span></kbd><span class="koboSpan" id="kobo.26.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">function databind(data) { }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.28.1">First, we join the data passed into the </span><kbd><span class="koboSpan" id="kobo.29.1">databind()</span></kbd><span class="koboSpan" id="kobo.30.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.31.1">    var join = custom.selectAll('custom.drop')</span><br/><span class="koboSpan" id="kobo.32.1">        .data(data, function(d) { return d.currentIndex; });</span></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.33.1">The key function passed in as the second argument to </span><kbd><span class="koboSpan" id="kobo.34.1">data</span></kbd><span class="koboSpan" id="kobo.35.1"> isn't strictly necessary in this case, but is good practice as it makes the join unambiguous and can have performance benefits.</span></div>
<p><span class="koboSpan" id="kobo.36.1">Now you create your selection states. </span><span class="koboSpan" id="kobo.36.2">The </span><kbd><span class="koboSpan" id="kobo.37.1">enter</span></kbd><span class="koboSpan" id="kobo.38.1"> selection is first:</span></p>
<pre><span class="koboSpan" id="kobo.39.1">var enter = join</span><br/><span class="koboSpan" id="kobo.40.1">  .enter().append('custom')</span><br/><span class="koboSpan" id="kobo.41.1">    .attr('class', 'drop')</span><br/><span class="koboSpan" id="kobo.42.1">    .attr('cx', function(d) { return d.xCloud; })</span><br/><span class="koboSpan" id="kobo.43.1">    .attr('cy', function(d) { return d.yCloud; })</span><br/><span class="koboSpan" id="kobo.44.1">    .attr('r', function(d) { return d.radiusCloud; })</span><br/><span class="koboSpan" id="kobo.45.1">    .attr('fillStyle', 'rgba(0, 0, 255, 0')</span><br/><span class="koboSpan" id="kobo.46.1">  .transition().delay(function(d, i) { return i * 2; })</span><br/><span class="koboSpan" id="kobo.47.1">    .attr('fillStyle', 'rgba(0, 0, 255, 0.2');</span></pre>
<p><span class="koboSpan" id="kobo.48.1">There are two things of note about the two bottom lines setting the </span><kbd><span class="koboSpan" id="kobo.49.1">fillStyle</span></kbd><span class="koboSpan" id="kobo.50.1"> attribute. </span><span class="koboSpan" id="kobo.50.2">When you work with SVG the last line would be:</span></p>
<pre><span class="koboSpan" id="kobo.51.1">.style('color', 'rgba(0, 0, 255, 0.2')</span></pre>
<p><span class="koboSpan" id="kobo.52.1">But with Canvas you use </span><kbd><span class="koboSpan" id="kobo.53.1">.attr()</span></kbd><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">Why? </span><span class="koboSpan" id="kobo.54.3">Your main interest here is to find a pain-free way to transfer some element-specific information. </span><span class="koboSpan" id="kobo.54.4">Here you want to transfer a color string from the </span><kbd><span class="koboSpan" id="kobo.55.1">databind()</span></kbd><span class="koboSpan" id="kobo.56.1"> to the </span><kbd><span class="koboSpan" id="kobo.57.1">draw()</span></kbd><span class="koboSpan" id="kobo.58.1"> function. </span><span class="koboSpan" id="kobo.58.2">You use the element simply as a vessel to transport your data over to where it is being rendered to the canvas.</span></p>
<p><span class="koboSpan" id="kobo.59.1">That's a very important distinction: when working with SVG or HTML you can bind data to elements and draw or apply styles to the elements in one step. </span><span class="koboSpan" id="kobo.59.2">In Canvas, you need two steps. </span><span class="koboSpan" id="kobo.59.3">First, you bind the data then you draw the data. </span><span class="koboSpan" id="kobo.59.4">You can't style the elements while binding. </span><span class="koboSpan" id="kobo.59.5">They only exist in memory and Canvas can't be styled via CSS style properties, which is exactly what you access when using </span><kbd><span class="koboSpan" id="kobo.60.1">.style()</span></kbd><span class="koboSpan" id="kobo.61.1">.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Let's have a quick look at how the </span><kbd><span class="koboSpan" id="kobo.63.1">customBase</span></kbd><span class="koboSpan" id="kobo.64.1"> element looks after we've created and appended the </span><kbd><span class="koboSpan" id="kobo.65.1">enter</span></kbd><span class="koboSpan" id="kobo.66.1"> selection to it:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.67.1"><img src="assets/090c66aa-0950-42d4-bdb3-be14185c7b10.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.68.1">Our custom root element showing 30 of our raindrops in enter-state</span></div>
<p><span class="koboSpan" id="kobo.69.1">Looks familiar in structure, doesn't it?</span></p>
<p><span class="koboSpan" id="kobo.70.1">Next, you define the </span><kbd><span class="koboSpan" id="kobo.71.1">update</span></kbd><span class="koboSpan" id="kobo.72.1"> selection, and finally the </span><kbd><span class="koboSpan" id="kobo.73.1">exit</span></kbd><span class="koboSpan" id="kobo.74.1"> selection:</span></p>
<pre><span class="koboSpan" id="kobo.75.1">var update = join</span><br/><span class="koboSpan" id="kobo.76.1">  .transition()</span><br/><span class="koboSpan" id="kobo.77.1">    .duration(function() { return Math.random() * 1000 + 900; })</span><br/><span class="koboSpan" id="kobo.78.1">    .delay(function(d,i) { return (i / data.length) * dur; })</span><br/><span class="koboSpan" id="kobo.79.1">    .ease(d3.easeLinear)</span><br/><span class="koboSpan" id="kobo.80.1">    .attr('cx', function(d) { return d.xPuddle; })</span><br/><span class="koboSpan" id="kobo.81.1">    .attr('cy', function(d) { return d.yPuddle; })</span><br/><span class="koboSpan" id="kobo.82.1">    .attr('r', function(d) { return d.radiusPuddle; })</span><br/><span class="koboSpan" id="kobo.83.1">    .attr('fillStyle', '#0000ff');</span><br/><br/><span class="koboSpan" id="kobo.84.1">var exit = join</span><br/><span class="koboSpan" id="kobo.85.1">  .exit().transition()</span><br/><span class="koboSpan" id="kobo.86.1">    .duration(dur)</span><br/><span class="koboSpan" id="kobo.87.1">    .delay(function(d,i) { return i ; })</span><br/><span class="koboSpan" id="kobo.88.1">    .attr('r', function(d) { return d.radiusGrass; })</span><br/><span class="koboSpan" id="kobo.89.1">    .attr('fillStyle', '#01A611');</span></pre>
<p><span class="koboSpan" id="kobo.90.1">That's all that goes into </span><kbd><span class="koboSpan" id="kobo.91.1">databind()</span></kbd><span class="koboSpan" id="kobo.92.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now you need to write the </span><kbd><span class="koboSpan" id="kobo.3.1">draw()</span></kbd><span class="koboSpan" id="kobo.4.1"> function to get the elements on screen. </span><span class="koboSpan" id="kobo.4.2">Let's just note here that nothing has happened yet. </span><span class="koboSpan" id="kobo.4.3">You haven't called </span><kbd><span class="koboSpan" id="kobo.5.1">databind()</span></kbd><span class="koboSpan" id="kobo.6.1"> yet because you need to find a way to draw it to the canvas first. </span><span class="koboSpan" id="kobo.6.2">So, off we go.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The </span><kbd><span class="koboSpan" id="kobo.8.1">draw()</span></kbd><span class="koboSpan" id="kobo.9.1"> function takes the context you want to draw on as an argument:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">function draw(ctx) {</span><br/><span class="koboSpan" id="kobo.11.1">  ctx.clearRect(0, 0, canvas.width, canvas.height);</span><br/><br/><span class="koboSpan" id="kobo.12.1">  drawRainScene();</span><br/><span class="koboSpan" id="kobo.13.1">  drawScene();</span><br/><br/><span class="koboSpan" id="kobo.14.1">  var elements = custom.selectAll('custom.drop');</span><br/><span class="koboSpan" id="kobo.15.1">  elements.each(function(d, i) {</span><br/><span class="koboSpan" id="kobo.16.1">    var node = d3.select(this);</span><br/><span class="koboSpan" id="kobo.17.1">    ctx.save();</span><br/><span class="koboSpan" id="kobo.18.1">    ctx.beginPath();</span><br/><span class="koboSpan" id="kobo.19.1">    ctx.globalCompositeOperation = 'source-atop'</span><br/><span class="koboSpan" id="kobo.20.1">    ctx.fillStyle = node.attr('fillStyle');</span><br/><span class="koboSpan" id="kobo.21.1">    ctx.arc(node.attr('cx'), node.attr('cy'), node.attr('r'), 0, 2 *</span><br/><span class="koboSpan" id="kobo.22.1">    Math.PI);</span><br/><span class="koboSpan" id="kobo.23.1">    ctx.fill();</span><br/><span class="koboSpan" id="kobo.24.1">    ctx.restore();</span><br/><span class="koboSpan" id="kobo.25.1">  });</span></pre>
<p><span class="koboSpan" id="kobo.26.1">Then it does the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.27.1">It clears the canvas.</span></li>
<li><span class="koboSpan" id="kobo.28.1">It draws the background scene, including the house and tree, as well as a cloud and a puddle drawn in </span><kbd><span class="koboSpan" id="kobo.29.1">drawRainScene()</span></kbd><span class="koboSpan" id="kobo.30.1">.</span></li>
<li><span class="koboSpan" id="kobo.31.1">It loops through each of our virtual elements to draw it according to the attributes we specified in </span><kbd><span class="koboSpan" id="kobo.32.1">databind()</span></kbd><span class="koboSpan" id="kobo.33.1">.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.34.1">That's it! </span><span class="koboSpan" id="kobo.34.2">You can close the </span><kbd><span class="koboSpan" id="kobo.35.1">draw()</span></kbd><span class="koboSpan" id="kobo.36.1"> function.</span></p>
<p><span class="koboSpan" id="kobo.37.1">See the line </span><kbd><span class="koboSpan" id="kobo.38.1">ctx.globalCompositeOperation = 'source-atop'</span></kbd><span class="koboSpan" id="kobo.39.1">? </span><span class="koboSpan" id="kobo.39.2">The </span><kbd><span class="koboSpan" id="kobo.40.1">globalCompositeOperation</span></kbd><span class="koboSpan" id="kobo.41.1"> allows us to fuse or blend-in shapes. </span><span class="koboSpan" id="kobo.41.2">It operates on a source shape, the shape we are about to draw, and a destination, the Canvas content </span><em><span class="koboSpan" id="kobo.42.1">underneath</span></em><span class="koboSpan" id="kobo.43.1"> the source shape. </span><span class="koboSpan" id="kobo.43.2">You can apply a number of compositing effects, but we use </span><kbd><span class="koboSpan" id="kobo.44.1">source-atop</span></kbd><span class="koboSpan" id="kobo.45.1"> here.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.46.1">Check </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation"><span class="koboSpan" id="kobo.47.1">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation</span></a><span class="koboSpan" id="kobo.48.1"> for all composite options.</span></div>
<p><span class="koboSpan" id="kobo.49.1">As a result, the new shape is only drawn where it overlaps the existing canvas content. </span><span class="koboSpan" id="kobo.49.2">The shape will not be visible in canvas regions without any drawings. </span><span class="koboSpan" id="kobo.49.3">This is why we need all objects in </span><kbd><span class="koboSpan" id="kobo.50.1">drawRainScene()</span></kbd><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">They form the background to our raindrops which they can't escape. </span><span class="koboSpan" id="kobo.51.3">By the way, if you don't want to draw all complex shapes by hand, you can draw them with vector graphics software such as Illustrator, save them as SVG, and use apps such as the </span><em><span class="koboSpan" id="kobo.52.1">SVG to HTML5 Canvas converter</span></em><span class="koboSpan" id="kobo.53.1"> at </span><a href="http://www.professorcloud.com/svg-to-canvas/"><span class="koboSpan" id="kobo.54.1">http://www.professorcloud.com/svg-to-canvas/</span></a><span class="koboSpan" id="kobo.55.1"> to convert SVG paths into Canvas commands.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Running the app</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far, no raindrop has shown itself, but you have the background scene in place:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="372" width="613" src="assets/14a09a8a-eb4b-4e99-a3ea-2a0aafece9ba.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">The initial scene</span></div>
<p><span class="koboSpan" id="kobo.5.1">You have the means to animate the life cycle with the </span><kbd><span class="koboSpan" id="kobo.6.1">databind()</span></kbd><span class="koboSpan" id="kobo.7.1"> and the </span><kbd><span class="koboSpan" id="kobo.8.1">draw()</span></kbd><span class="koboSpan" id="kobo.9.1"> functions. </span><span class="koboSpan" id="kobo.9.2">You just call them in a sequence and wire this call-up with the buttons. </span><span class="koboSpan" id="kobo.9.3">Let's play this through for the </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">Enter</span></span><span class="koboSpan" id="kobo.11.1"> case. </span><span class="koboSpan" id="kobo.11.2">The cloud is empty and we want raindrops to transition into play from 0 to 0.2 opacity, that's how we specified it in the </span><kbd><span class="koboSpan" id="kobo.12.1">databind()</span></kbd><span class="koboSpan" id="kobo.13.1"> function. </span><span class="koboSpan" id="kobo.13.2">We could just run:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">databind(raindata);</span><br/><span class="koboSpan" id="kobo.15.1">draw(context);</span></pre>
<p><span class="koboSpan" id="kobo.16.1">This will join the data to the custom elements and, as all elements are joined with new data, draw the enter selection – once! </span><span class="koboSpan" id="kobo.16.2">But we need to display the transition, so we need to draw repeatedly while the transition is happening. </span><span class="koboSpan" id="kobo.16.3">You achieve this with a continuous loop:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">databind(data);</span><br/><span class="koboSpan" id="kobo.18.1">var t = d3.timer(function(elapsed) {</span><br/><span class="koboSpan" id="kobo.19.1">  draw(context);</span><br/><span class="koboSpan" id="kobo.20.1">   if (elapsed &gt; dur * 2) t.stop();</span><br/><span class="koboSpan" id="kobo.21.1">});</span></pre>
<p><span class="koboSpan" id="kobo.22.1">First, we bind the incoming data to our custom elements. </span><span class="koboSpan" id="kobo.22.2">Then we draw repeatedly. </span><kbd><span class="koboSpan" id="kobo.23.1">d3.timer()</span></kbd><span class="koboSpan" id="kobo.24.1"> calls its callback repeatedly until you tell it to stop. </span><span class="koboSpan" id="kobo.24.2">The callback takes an argument we call </span><kbd><span class="koboSpan" id="kobo.25.1">elapsed</span></kbd><span class="koboSpan" id="kobo.26.1"> here, which is the time in milliseconds the timer is running. </span><span class="koboSpan" id="kobo.26.2">The </span><kbd><span class="koboSpan" id="kobo.27.1">draw()</span></kbd><span class="koboSpan" id="kobo.28.1"> function will be run many times drawing the background scene as well as each raindrop. </span><span class="koboSpan" id="kobo.28.2">At the same time a transition is running within </span><kbd><span class="koboSpan" id="kobo.29.1">databind()</span></kbd><span class="koboSpan" id="kobo.30.1">, changing each raindrop's position slightly. </span><span class="koboSpan" id="kobo.30.2">The </span><kbd><span class="koboSpan" id="kobo.31.1">draw()</span></kbd><span class="koboSpan" id="kobo.32.1"> function will pick up these slight position changes as it loops through each raindrop every time it's called, drawing the raindrop at the very position the transition in </span><kbd><span class="koboSpan" id="kobo.33.1">databind()</span></kbd><span class="koboSpan" id="kobo.34.1"> sets it to at this given moment. </span><span class="koboSpan" id="kobo.34.2">You can think of it as two processes happening at the same time: the transition in </span><kbd><span class="koboSpan" id="kobo.35.1">databind()</span></kbd><span class="koboSpan" id="kobo.36.1"> delivering new raindrop positions and the repeated canvas drawing in </span><kbd><span class="koboSpan" id="kobo.37.1">draw()</span></kbd><span class="koboSpan" id="kobo.38.1"> removing the previous canvas and drawing these new raindrop positions.</span></p>
<p><span class="koboSpan" id="kobo.39.1">After the transition is done, we want to stop the timer. </span><span class="koboSpan" id="kobo.39.2">Work done. </span><span class="koboSpan" id="kobo.39.3">The transition in </span><kbd><span class="koboSpan" id="kobo.40.1">databind()</span></kbd><span class="koboSpan" id="kobo.41.1"> runs for 2000 milliseconds, as we set it in the </span><kbd><span class="koboSpan" id="kobo.42.1">dur</span></kbd><span class="koboSpan" id="kobo.43.1"> variable. </span><span class="koboSpan" id="kobo.43.2">We shall use </span><kbd><span class="koboSpan" id="kobo.44.1">dur</span></kbd><span class="koboSpan" id="kobo.45.1"> now to clear up after us. </span><span class="koboSpan" id="kobo.45.2">We can stop any timer from within calling the timer's </span><kbd><span class="koboSpan" id="kobo.46.1">.stop()</span></kbd><span class="koboSpan" id="kobo.47.1">-method. </span><span class="koboSpan" id="kobo.47.2">To be safe we call </span><kbd><span class="koboSpan" id="kobo.48.1">t.stop()</span></kbd><span class="koboSpan" id="kobo.49.1"> after we're passed double our duration </span><kbd><span class="koboSpan" id="kobo.50.1">dur</span></kbd><span class="koboSpan" id="kobo.51.1"> (</span><em><span class="koboSpan" id="kobo.52.1">4000</span></em><span class="koboSpan" id="kobo.53.1"> milliseconds) to cater for delayed transitions. </span></p>
<p><span class="koboSpan" id="kobo.54.1">This is how a D3 transition works in Canvas. </span><span class="koboSpan" id="kobo.54.2">You call the drawing function more or less parallel to the binding function repeatedly Whatever style or position properties your D3 elements are set up to transition (</span><em><span class="koboSpan" id="kobo.55.1">x</span></em><span class="koboSpan" id="kobo.56.1">, </span><em><span class="koboSpan" id="kobo.57.1">y</span></em><span class="koboSpan" id="kobo.58.1">, </span><em><span class="koboSpan" id="kobo.59.1">color</span></em><span class="koboSpan" id="kobo.60.1">, </span><em><span class="koboSpan" id="kobo.61.1">width</span></em><span class="koboSpan" id="kobo.62.1">, </span><em><span class="koboSpan" id="kobo.63.1">height</span></em><span class="koboSpan" id="kobo.64.1">, for example.), they will be re-drawn many times with small incremental changes for each draw.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Wiring it up to the buttons is a formality. </span><span class="koboSpan" id="kobo.65.2">Just wrap the </span><kbd><span class="koboSpan" id="kobo.66.1">databind()</span></kbd><span class="koboSpan" id="kobo.67.1"> and </span><kbd><span class="koboSpan" id="kobo.68.1">draw()</span></kbd><span class="koboSpan" id="kobo.69.1"> functions into a function (we shall call it </span><kbd><span class="koboSpan" id="kobo.70.1">rainAnimation()</span></kbd><span class="koboSpan" id="kobo.71.1">) that passes in the </span><kbd><span class="koboSpan" id="kobo.72.1">raindata</span></kbd><span class="koboSpan" id="kobo.73.1"> when the enter or update button is pressed and an empty array when the exit button is pressed.</span></p>
<p><span class="koboSpan" id="kobo.74.1">That's it!</span></p>
<p><span class="koboSpan" id="kobo.75.1">The rain cloud will appear on the screen upon hitting the </span><span class="packt_screen"><span class="koboSpan" id="kobo.76.1">Enter</span></span><span class="koboSpan" id="kobo.77.1"> button:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.78.1"><img height="366" width="619" src="assets/8fa57f3c-d8cf-4b3b-8c49-f520e046a311.png"/></span></div>
<div class="FigurePACKT packt_figref CDPAlignCenter"><span class="koboSpan" id="kobo.79.1"> Enter rain into cloud</span></div>
<p><span class="koboSpan" id="kobo.80.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.81.1">Update</span></span><span class="koboSpan" id="kobo.82.1"> button will update the rain's position from the cloud to a puddle:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.83.1"><img height="355" width="605" src="assets/b81b6df5-fb62-4bf2-a7c9-a47934e6fc74.png"/></span></div>
<div>
<div class="FigurePACKT packt_figref CDPAlignCenter"><span class="koboSpan" id="kobo.84.1">Update rain to the ground</span></div>
</div>
<p><span class="koboSpan" id="kobo.85.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.86.1">Exit</span></span><span class="koboSpan" id="kobo.87.1"> button will finally turn the rain into grass:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.88.1"><img height="388" width="660" src="assets/2ba74abc-fe1f-4eb9-a36d-3a9c06b8a475.png"/></span></div>
<div>
<div class="FigurePACKT packt_figref CDPAlignCenter"><span class="koboSpan" id="kobo.89.1"> Exit the rain to become grass </span></div>
<div class="FigurePACKT packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.90.1">View this step in the browser: </span></span><a href="https://larsvers.github.io/learning-d3-mapping-8-4a"><span class="koboSpan" id="kobo.91.1">https://larsvers.github.io/learning-d3-mapping-8-4a</span></a><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">Code example </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2008%20-%20Drawing%20with%20D3%20and%20Canvas/08_04a.html"><span class="koboSpan" id="kobo.93.1">08_04a.html</span></a><span class="koboSpan" id="kobo.94.1">.</span></div>
</div>
<p><span class="koboSpan" id="kobo.95.1">A natural D3 life cycle demonstration!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.2.1">You've come a long way. </span><span class="koboSpan" id="kobo.2.2">You've learned how to draw with Canvas, how to animate the canvas in a pure Canvas way, as well as how to use D3 transitions and the Enter-Update-Exit pattern with Canvas. </span><span class="koboSpan" id="kobo.2.3">While the Vanilla Canvas way is perfectly reasonable for a great many applications, D3 offers seasoned functionality for data visualization you don't have to abandon. </span><span class="koboSpan" id="kobo.2.4">It requires a shift in thinking when building your application, but it can pay out specifically for drawing and animating a large number of points. </span><span class="koboSpan" id="kobo.2.5">It will expand your toolbox in a valuable way, especially at times where abundant data might require element-heavy representations.</span></span></p>
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.3.1">In the next chapter, we will review a map visualization in SVG and then build one in Canvas. </span><span class="koboSpan" id="kobo.3.2">By doing so, you will not only be able to apply the learnings from this chapter, but you will also learn more about the differences and similarities between the two approaches, how Canvas can help with performance bottlenecks, and how D3 can help with some heavy lifting.</span></span></p>
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.4.1">Let's get to it!</span></span></p>


            </article>

            
        </section>
    </body></html>