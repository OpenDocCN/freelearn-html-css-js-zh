<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Actions</h1></div></div></div><p>In the previous chapter, we worked on building a skeleton architecture for our Flux application. The actions were directly dispatched by the dispatcher. Now that we have a skeleton Flux architecture under our belts, it's time to look more deeply into actions, and in particular, how actions are created.</p><p>We'll start by talking about the names we give actions and the constants used to identify the available actions in our system. Then, we'll implement some action creator functions, and we'll think about how we can keep these modular. Even though we might be done with implementing our skeleton architecture, we may still have a need to mock some API data—we'll go over how this is done with action creator functions.</p><p>Typical action creator functions are stateless—data in, data out. We'll cover some scenarios where action creators actually depend on state, such as when long-running connections are involved. We'll wrap the chapter up with a look at parameterized action creators, allowing us to reuse them for different purposes.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Action names and constants</h1></div></div></div><p>Any large Flux application <a id="id121" class="indexterm"/>will have a lot of actions. This is why having action constants and sensible action names matter. The focus of this section is to discuss possible naming conventions for actions and to get organized with our actions. Constants help with reducing repetitive strings that are error-prone, but we'll also need to think about the best way to organize our constants. We'll also look at static action data—this will also help us reduce the amount of action dispatch code we have to write.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Action name conventions</h2></div></div></div><p>All actions in a Flux system <a id="id122" class="indexterm"/>have a name. The name is important because it tells whoever is looking at it a lot about what it does. An application where there are less than ten actions is unlikely to have a strong naming convention requirement, because we can easily figure out what these actions do. However, it's equally unlikely we'd use Flux to implement a small application—Flux is for systems that need to scale. This means that there's a strong likelihood of many actions.</p><p>Action names can be divided into two segments—the <em>subject</em> and the <em>operation</em>. For example, having an<a id="id123" class="indexterm"/> action named <code class="literal">ACTIVATE</code> wouldn't be terribly helpful—what are we activating? Adding a subject to the name is often all it takes to provide some much needed context. Here are some examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ACTIVATE_SETTING</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ACTIVATE_USER</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ACTIVATE_TAB</code></li></ul></div><p>The subject is just an abstract type of thing in our system—it doesn't even have to correspond to a concrete software entity. However, if there are a lot of subjects in our system with similar actions, we might want to change up the format of our action names, like this for example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SETTING_ACTIVATE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">USER_ACTIVATE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TAB_ACTIVATE</code></li></ul></div><p>At the end of the day, this is really a personal (or team) preference, just as long as the name is descriptive enough to provide meaning for someone who's looking at the code. What if the subject and the operation aren't enough? For example, there could be several subjects that are similar, and this could cause confusion. Then, we could add another layer of subject to the name—think of this as namespacing the action.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Try not to go beyond three segments in a Flux action name. If you feel the need to do this, there's probably somewhere else in your architecture that needs attention.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Static action data</h2></div></div></div><p>Some actions are very similar to other actions, similar in the sense, that the payload data that's sent to the stores has <a id="id124" class="indexterm"/>many of the same properties. If we were to directly dispatch these actions, using the dispatcher instance, then we'd usually have to repeat object literal code. Let's take a look at an action creator function:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';

// The action name.
export const SORT_USERS = 'SORT_USERS';

// This action creator function hard-codes
// the action payload.
export function sortUsers() {
  dispatcher.dispatch({
    type: SORT_USERS,
    payload: {
      direction: 'asc'
    }
  });
}</pre></div><p>The aim of this action is pretty straightforward—sort the list of users that are presumably UI components. The only payload data that's required is a sort direction, which is specified in the <code class="literal">direction</code> property. The problem with this action creator function is that this payload data is hard-coded. For example, the payload data in question here seems fairly generic, and other <a id="id125" class="indexterm"/>action creator functions that sort data should follow this pattern. But, this also means that they'll each have their own hard-coded values.</p><p>One thing we can do about this is to create a module within the <code class="literal">actions</code> directory that exports any default payload data that can be shared amongst several action creator functions. Carrying on with the sorting example, the module might start off looking something like this:</p><div><pre class="programlisting">// This object is used by several action
// creator functions as part of the action
// payload.
export const PAYLOAD_SORT = {
  direction: 'asc'
};</pre></div><p>This is easy to build on. We can extend <code class="literal">PAYLOAD_SORT</code>, as new properties are needed and when old defaults need to change. It's also easy to add new default payloads as they're needed. Let's take look at another action creator function that uses this default payload:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';
import { PAYLOAD_SORT } from './payload-defaults';

// The action name.
export const SORT_TASKS = 'SORT_TASKS';

// This action creator function is using
// the "PAYLOAD_SORT" default object as the
// payload.
export function sortTasks() {
  dispatcher.dispatch({
    type: SORT_TASKS,
    payload: PAYLOAD_SORT
  });
}</pre></div><p>As we can see, the <code class="literal">PAYLOAD_SORT</code> object is used by the <code class="literal">sortTasks()</code> function, rather than hard-coding the payload within the action creator. This reduces the amount of code we need to write, and it<a id="id126" class="indexterm"/> puts common payload data in a central place, making it easy for us to change the behavior of many action creator functions.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>You may have noticed that the default payload object is being passed to <code class="literal">dispatch()</code> as is. More often than not, we'll have part of the payload object that's common across several functions and part of the payload object that's dynamic. We'll build in the examples from this section in the last section of the chapter, when it's time to think about parameterized action creator functions.</p></div></div><p>Now, let's take a look at both of these action creator functions in use, to make sure we're getting what we expect. Rather than setting up stores for this, we'll just listen to the dispatcher directly:</p><div><pre class="programlisting">import dispatcher from './dispatcher';

// Gets the action constant and creator function
// for "SORT_USERS".
import {
  SORT_USERS,
  sortUsers
} from './actions/sort-users';

// Gets the action constant and creator function
// for "SORT_TASKS".
import {
  SORT_TASKS,
  sortTasks
} from './actions/sort-tasks';

// Listen for actions, and log some information
// depending on which action was dispatched.
// Note that we're using the action name constants
// here, so there's less chance of human error.
dispatcher.register((e) =&gt; {
  switch (e.type) {
    case SORT_USERS:
      console.log(`Sorting users "${e.payload.direction}"`);
      break;
    case SORT_TASKS:
      console.log(`Sorting tasks "${e.payload.direction}"`);
      break;
  }
});

sortUsers();
// → Sorting users "asc"

sortTasks();
// → Sorting tasks "asc"</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Organizing action constants</h2></div></div></div><p>You may have <a id="id127" class="indexterm"/>noticed that there's already a hint of organization with the action constants used in the previous example. For example, the <code class="literal">SORT_USERS</code> constant was defined in the same module as the <code class="literal">sortUsers()</code> action creator function. This is generally a good idea because these two things are closely related to one another. There is a downside to this though. Imagine a more complex store that needs to handle a lot of actions. If each individual action constant is declared in its own module, the store would have to perform a lot of imports just to get these constants. If there's a number of complex stores that each need access to lots of actions, the number of imports starts to really add up. This problem is illustrated here:</p><div><pre class="programlisting">import { ACTION_A } from '../actions/action-a';
import { ACTION_B } from '../actions/action-b';
import { ACTION_C } from '../actions/action-c';
// …</pre></div><p>If we find ourselves in a situation like this one, where several stores need access to several modules, maybe we need a <code class="literal">constants.js</code> module in the <code class="literal">actions</code> directory. This module would expose every action in the system. Here's an example of what this module might look like:</p><div><pre class="programlisting">export { ACTION_A } from './action-a';
export { ACTION_B } from './action-b';
export { ACTION_C } from './action-c';</pre></div><p>As our system grows and new actions are added, this is where we would centralize the action constants for easy access by stores that require many of them. They're not defined here; this is just a proxy that reduces the number of imports from stores, because the stores never need the action creator functions. Let's see if the situation has improved from the perspective of a store that requires action constants:</p><div><pre class="programlisting">import {
  ACTION_A,
  ACTION_B,
  ACTION_C
} from './actions/constants';

console.log(ACTION_A);
// → ACTION_A

console.log(ACTION_B);
// → ACTION_B

console.log(ACTION_C);
// → ACTION_C</pre></div><p>That's better. Only one <code class="literal">import</code> statement gets us everything we need, and it's still nice and legible. There are several ways we could spin this approach to better suit our needs. For example, maybe instead of <a id="id128" class="indexterm"/>one big constants module, we want to group our actions into logical modules that more closely resemble our features, and likewise for our action creator functions. We'll discuss action modularity as it relates to our application features in the next section.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Feature action creators</h1></div></div></div><p>Action creator functions need to<a id="id129" class="indexterm"/> be organized, just as action constants are. In the preceding code examples of this chapter, we've organized both our action constants and our action creator functions into modules. This keeps our action code clean and easy to traverse. In this section, we'll build on this idea from the feature point of view. We'll look at why this is worth thinking about in the first place, then we'll talk about how these ideas make the architecture as a whole more modular.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>When modularity is needed</h2></div></div></div><p>Do we need to think deeply <a id="id130" class="indexterm"/>about modular action creator functions at the beginning of our Flux project? While the project is still small in size, it's okay if all action creator functions are part of one monolithic action creator module—there's simply no meaningful impact on the architecture. It's when we have more than a dozen or so actions that we need to start thinking about modularity and, in particular, features.</p><p>We can split our action creator module into several smaller modules, each with their own action creator function. This is certainly a step in the right direction, but in essence, we're just moving the problem to the directory level. So instead of a monolithic module, we now have a monolithic directory with lots of files in it. This directory is illustrated here:</p><div><img src="img/B05419_04_01.jpg" alt="When modularity is needed"/></div><p>There's nothing<a id="id131" class="indexterm"/> inherently wrong with this layout—it's just that there's no indication of which feature a given action is part of. This may not even be necessary, but when the architecture grows to be a certain size, it's usually helpful to group action modules by features. This concept is illustrated here:</p><div><img src="img/B05419_04_02.jpg" alt="When modularity is needed"/></div><p>Once we're able to get the <a id="id132" class="indexterm"/>actions of the system organized in such a way that they reflect the behavior of any given feature, we can start thinking about other architectural challenges related to modularity. We'll discuss these next.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Modular architecture</h2></div></div></div><p>It's a good thing when the<a id="id133" class="indexterm"/> modules in a Flux architecture start taking the shape of the features our application provides. This has implications elsewhere in the architecture as well. For example, if we're organizing the actions by features, then should we not also organize the stores and the views by feature as well? Stores are easy—they're not exactly decomposable into smaller stores; they naturally represent the feature in its entirety. Views, on the other hand, could potentially have many JavaScript modules to organize within a feature. Here's a potential directory structure of a Flux feature:</p><div><img src="img/B05419_04_03.jpg" alt="Modular architecture"/></div><p>This is a cohesive structure—everything the views need to dispatch these actions are in the same parent directory. Likewise, the store that notifies the views about state changes is in the same place. We can get <a id="id134" class="indexterm"/>away with following a similar pattern for all of our features, which has the added benefit of promoting consistency.</p><p>We'll revisit structuring feature modules toward the end of the book. For now, our main concern is the dependencies that other features might have with a given set of actions. For example, our feature defines several actions that are dispatched by views. What should happen with other features that want to respond to these actions—do they need to depend on this feature for the action? There's also the matter of the action creators themselves, and whether or not other features can dispatch them. The answer is a resounding yes, and the reason is simple—actions are how things happen in Flux architectures. There's no event bus where modules publish events in a fire-and-forget way. Actions play a vital role in the modularity of our Flux architecture.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Mocking data</h1></div></div></div><p>The dispatcher in Flux architectures is <a id="id135" class="indexterm"/>the single point of entry for new data entering the system. This makes it easy to fabricate mock data to help us churn out features faster. In this section, we'll discuss mocking existing APIs, and whether or not this is worthwhile to build into the action creator functions that talk to them. Then, we'll go over implementing mocks for new APIs that doesn't yet exist, followed by a look at strategies to<a id="id136" class="indexterm"/> substitute mock action creators for the real deal.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Mocking existing APIs</h2></div></div></div><p>In order to mock data in a Flux system, the actions that are dispatched need to deliver this mock data to the stores. This is done by creating an alternative implementation of the action creator function that <a id="id137" class="indexterm"/>dispatches the action. When there's already an API that an action creator can target, we don't necessarily need to mock the data during the development of a given feature—the data is already there. However, the existence of an API that's used by an action creator shouldn't rule out the existence of a mocked version.</p><p>The main reason we would want to do this is because at any given point during the lifetime of our product, there's going to be a missing API that we need. As we'll see in the next section, we'll obviously want to mock the data returned by this API, so we can continue implementing the feature we're working on. But do we really want to mock some actions and not others? The idea is illustrated here:</p><div><img src="img/B05419_04_04.jpg" alt="Mocking existing APIs"/></div><p>The challenge with this approach—mocking some actions while actually implementing others—is consistency. When we're mocking data that enters the system, we have to be cognizant of the relationships between one set of data and another. Look at it from the perspective of our stores—they'll likely have dependencies on one another. Can we capture these dependencies using a mixture of mock data and actual data? Here is an illustration of actions that mock the entirety of the system:</p><div><img src="img/B05419_04_05.jpg" alt="Mocking existing APIs"/></div><p>It's better to have total control over the data that's used when we experiment with new functionality. This eliminates the possibility of errant behavior because of some inconsistency in our data. It takes more effort to construct mock data like this, but it pays off in the end when we're adding new features and we only have to mock one new action at a time, as it's added <a id="id138" class="indexterm"/>into the system. As we'll see later in this section, it's easy to substitute mock action creators for production action creators.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Mocking new APIs</h2></div></div></div><p>Once we reach the point during the implementation of a new feature where we're missing API functionality, we'll have<a id="id139" class="indexterm"/> to mock it. We can use this new mock with the other mocks we've created to support other features in the application. The advantage of doing this is that it allows us to create something without delay, something we can demonstrate to stakeholders. Another benefit of mocking APIs as action creator functions is that they can help steer the API in the right direction. Without a UI, the API has nothing to base its design on, so this is a good opportunity to solicit a design that works best with the application we're building.</p><p>Let's take a look at some action creator functions that mock the data that's dispatched as action payloads. We'll start with a basic loader function that bootstraps some data into the store for us:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const LOAD_TASKS = 'LOAD_TASKS';

// Immediately dispatches the action using an array
// of task objects as the mock data.
export function loadTasks() {
  dispatcher.dispatch({
    type: LOAD_TASKS,
    payload: [
      { id: 1, name: 'Task 1', state: 'running' },
      { id: 2, name: 'Task 2', state: 'queued' },
      { id: 3, name: 'Task 3', state: 'finished'}
    ]
  });
}</pre></div><p>This is quite simple. The data we want to mock is part of the function, as the action payload. Let's look at another mock action creator now, one that manipulates the state of a store after the data has already been bootstrapped:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';

// The action identifier...
export const RUN_TASK = 'RUN_TASK';

// Uses "setTimeout()" to simulate latency we'd
// likely see in a real network request.
export function runTask() {
  setTimeout(() =&gt; {
    dispatcher.dispatch({
      type: RUN_TASK,

      // Highly-specific mock payload data. This
      // mock data doesn't necessarily have to
      // be hard-coded like this, but it does make
      // experimentation easy.
      payload: {
        id: 2,
        state: 'running'
      }
    });
  }, 1000);
}</pre></div><p>Once again, we have very specific mock data we're using here, which is fine because it's directly coupled to the <a id="id140" class="indexterm"/>action creator function that's dispatching the action—this is the only way this data can enter the system too. Something else that's different about this function is that it's simulating latency by not dispatching the action until the <code class="literal">setTimeout()</code> callback triggers after one second.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>We'll take a more detailed look at asynchronous actions, including latency, promises, and multiple API endpoints in a later chapter.</p></div></div><p>At this point, we have two mock action creator functions available for use. But before we start using these functions, let's create a task store so that we can make sure the correct information is being stored:</p><div><pre class="programlisting">import EventEmitter from 'events';
import dispatcher from '../dispatcher';
import { LOAD_TASKS } from '../actions/load-tasks';
import { RUN_TASK } from '../actions/run-task';

// The store for tasks displayed in the application.
class TaskStore extends EventEmitter {
  constructor() {
    super();

    this.state = [];

    dispatcher.register((e) =&gt; {
      switch(e.type) {

        // In the case of "LOAD_TASKS", we can use the
        // "payload" as the new store state.
        case LOAD_TASKS:
          this.state = e.payload;
          this.emit('change', this.state);
          break;

        // In the case of "RUN_TASK", we need to look
        // up a specific task object and change it's state.
        case RUN_TASK:
          let task = this.state.find(
            x =&gt;x.id === e.payload.id);

          task.state = e.payload.state;

          this.emit('change', this.state);

          break;
      }
    });
  }
}

export default new TaskStore();</pre></div><p>Now that we have a store to<a id="id141" class="indexterm"/> handle both actions we've just implemented, let's put the store and the actions to use in the <code class="literal">main.js</code> module of the application:</p><div><pre class="programlisting">import taskStore from './stores/task';
import { loadTasks } from './actions/load-tasks';
import { runTask } from './actions/run-task';

// Logs the state of the store, as a mapped array
// of strings.
taskStore.on('change', (state) =&gt; {
  console.log('tasks',
    state.map(x =&gt; `${x.name} (${x.state})`));
});

loadTasks();
// →
// tasks [
//   "Task 1 (running)",
//   "Task 2 (queued)",
//   "Task 3 (finished)"
// ]

runTask();
// →
// tasks [
//   "Task 1 (running)",
//   "Task 2 (running)",
//   "Task 3 (finished)"
// ]</pre></div><p>As you can see, the tasks were<a id="id142" class="indexterm"/>  successfully bootstrapped into the store with the call to <code class="literal">loadTasks()</code>, and the state of the second task was updated when we called <code class="literal">runTask()</code>. This latter update isn't logged till one second has elapsed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Replacing action creators</h2></div></div></div><p>At this point, we have a <a id="id143" class="indexterm"/>working action creator function that dispatches actions with mock payload data into the system. Recall that we don't necessarily want to get rid of these action creator functions, because when it's time to implement something new, we'll want to use these mocks again.</p><p>What we really need is a global switch that toggles the mock mode of the system, and this would change the implementation of the action creator function that's used. Here's a diagram that shows how this might work:</p><div><img src="img/B05419_04_06.jpg" alt="Replacing action creators"/></div><p>The idea here is that there's a mock version and a production version of the same action creator function <a id="id144" class="indexterm"/>within the module. This is the easy part; the tricky part is going to be implementing a global mock switch so that the correct function is exported, depending on the mode of the application:</p><div><pre class="programlisting">import { MOCK } from '../settings';
import dispatcher from '../dispatcher';

// The action identifier...
export const LOAD_USERS = 'LOAD_USERS';

// The mock implementation of the action creator.
function mockLoadUsers() {
  dispatcher.dispatch({
    type: LOAD_USERS,
    payload: [
      { id: 1, name: 'Mock 1' },
      { id: 2, name: 'Mock 2' }
    ]
  });
}

// The production implementation of the action creator.
function prodLoadUsers() {
  dispatcher.dispatch({
    type: LOAD_USERS,
    payload: [
      { id: 1, name: 'Prod 1' },
      { id: 2, name: 'Prod 2' }
    ]
  });
}

// Here's where the "loadUsers" value is determined, based
// on the "MOCK" setting. It's always going to be exported
// as "loadUsers", meaning that no other code needs to change.
const loadUsers = MOCK ? mockLoadUsers : prodLoadUsers;
export { loadUsers as loadUsers };</pre></div><p>This is very handy during development, because the extent of our mocked functions is limited to the action creator <a id="id145" class="indexterm"/>modules and is controlled by one setting. Let's see how this action creator function is used, regardless of whether the mock or the production implementation is exported:</p><div><pre class="programlisting">import dispatcher from './dispatcher';

// This code never has to change, although the actual
// function that's exported will change, depending on
// the "MOCK" setting.
import { loadUsers } from './actions/load-users';

dispatcher.register((e) =&gt; {
  console.log('Users', e.payload.map(x =&gt;x.name));
});

loadUsers();
// → Users ["Mock 1", "Mock 2"]
// When the "MOCK" setting is set to true...
// → Users ["Prod 1", "Prod 2"]</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Stateful action creators</h1></div></div></div><p>The action creator <a id="id146" class="indexterm"/>functions we've looked at so far in this chapter have been relatively simple—they dispatch some action when called. But before that happens, these action creators will typically reach out to some API endpoint to retrieve some data, then dispatch the action, using the data as the payload. These are called stateless action creator functions because there's no intermediary state about them—no lifecycle in other words.</p><p>In this section, we'll think about things that are stateful and how we might go about integrating these into <a id="id147" class="indexterm"/>our Flux architecture. Another challenge we could face is integrating our Flux application into another architecture. First, we'll cover some basic ground on stateful action creators, then we'll look at a concrete example using web sockets.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Integrating with other systems</h2></div></div></div><p>Most of the time, Flux<a id="id148" class="indexterm"/> applications are standalone in the browser. That is, they're not a cog in a larger machine. We will, however, come up against cases where our Flux architecture needs to fit into something bigger. For example, if we need to interface with components that use a completely different framework, then we need to come up with a way to embed our software without compromising the Flux patterns. Or perhaps the coupling between our application and the one we're integrating with is a little looser, as when communicating with another browser tab. Whatever the case may be, we have to be able to send messages to this external system and we need to be able to consume messages from it, translating them into actions. Here is an illustration of this idea:</p><div><img src="img/B05419_04_07.jpg" alt="Integrating with other systems"/></div><p>As you can see, the Flux architecture depicted here isn't a closed system. The main implication is that the typical action creator functions that we're used to working with aren't necessarily called within the system. That is, they're handling a stream of external messages, using a stateful <a id="id149" class="indexterm"/>connection to the other system. This is just how web sockets work. We'll look at these stateful action creators next.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Web socket connectivity</h2></div></div></div><p>Web socket <a id="id150" class="indexterm"/>connectivity is growing to the point of pervasiveness in modern web applications, and if we're building a Flux architecture, there's a good chance we're going to need to build web socket support. When something changes state in the backend, web socket connections are a great way to notify clients about such a change. For example, imagine a Flux store is managing the state of some piece of backend data, and something causes its state to change—wouldn't we want the store to know about it?</p><p>The challenge is that we need a stateful connection in order to receive web socket messages and translate them into Flux actions. This is how web socket data enters the system. Let's take a look at some socket listener code:</p><div><pre class="programlisting">// Get the action constants and action functions
// that we need.
import { ONE, one } from './one';
import { TWO, two } from './two';
import { THREE, three } from './three';

var ws;
var actions = {};

// Create a mapping of constants to functions
// that the web socket handler can use to call
// the appropriate action creator.
actions[ONE] = one;
actions[TWO] = two;
actions[THREE] = three;

// Connects the web socket...
export default function connect() {
  ws = new WebSocket('ws://127.0.0.1:8000');

  ws.addEventListener('message', (e) =&gt; {

    // Parses the message data and uses the
    // "actions" map to call the corresponding
    // action creator function.
    let data = JSON.parse(e.data);
    actions[data.task](data.value);
  });
}</pre></div><p>All we're doing here is creating a simple <code class="literal">actions</code> map. This is how we call the correct action creator function based on the <code class="literal">task</code> property of the message that was received. What's nice about this approach is that there's very little additional functionality required to make this work; the <a id="id151" class="indexterm"/>preceding code is the extent of it. The actual action creator functions, constants, and so on, are just typical Flux items. Let's look at the server code that generates these web socket messages, so we have an idea of what's actually being passed to the socket listener code:</p><div><pre class="programlisting">// The HTTP server...
var server = require('http').createServer();

// The web socket server...
var ws = new require('ws').Server({
  server: server,
});

// Makes life worth living...
var express = require('express');
var app = express();

// So we can serve "index.html"...
app.use(express.static(__dirname));

// Handler for when a client connects via web socket.
ws.on('connection', function connection(ws) {
  let i = 0;
  const names = [ null, 'one', 'two', 'three' ];

  // Sends the client 3 messages, spaced by 1 second
  // intervals.
  function interval() {
    if (++i&lt; 4) {
      ws.send(JSON.stringify({
        value: i,
        task: names[i]
      }));

      setTimeout(interval, 1000);
    }
  }

  setTimeout(interval, 1000);
});

// Fire up the HTTP and web socket servers.
server.on('request', app);
server.listen(8000, () =&gt; {
  console.log('Listening on', server.address().port)
});</pre></div><p>Over the course of three seconds, we'll see three web socket messages delivered to the client. Each message has a<a id="id152" class="indexterm"/> <code class="literal">task</code> property, and this is the value we're using to determine which action is dispatched. Let's take a look at the <code class="literal">main.js</code> frontend module and make sure everything's working as expected:</p><div><pre class="programlisting">import dispatcher from './dispatcher';
import connect from './actions/socket-listener';
import { ONE } from './actions/one';
import { TWO } from './actions/two';
import { THREE } from './actions/three';

// Logs the web socket messages that have been
// dispatched as Flux actions.
dispatcher.register((e) =&gt; {
  switch (e.type) {
    case ONE:
      console.log('one', e.payload);
      break;
    case TWO:
      console.log('two', e.payload);
      break;
    case THREE:
      console.log('three', e.payload);
      break;
  }
});
// →
// one 1
// two 2
// three 3

// Establishes the web socket connection. Note
// that it's important to connect after everything
// with the Flux dispatcher is setup. 
connect();</pre></div><p>As you can see, the <code class="literal">connect()</code> function is responsible for establishing the web socket connection. This is a simple<a id="id153" class="indexterm"/> implementation, lacking several production-grade capabilities, such as reconnecting dropped connections. However, the important thing to note here is that this listener is actually located in the same directory as the other action modules. We actually want a tight coupling here because the main goal of the socket listener is to dispatch actions, by translating web socket messages.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Parameterized action creators</h1></div></div></div><p>The final section of this<a id="id154" class="indexterm"/> chapter focuses on parameterized action creators. All the action creator functions we've looked at so far in the chapter have been basic functions that don't accept any arguments. This is fine, except for when we start to accumulate several unique actions that are nearly identical. Without parameterized action creator functions, we'll soon have an endless proliferation of functions; this does not scale.</p><p>First, we'll establish the goals of passing arguments to action creator functions, followed by some example code that implements generic action creator functions. We'll then look into creating partial functions to further reduce repetitiveness by composing action creators.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Removing redundant actions</h2></div></div></div><p>Action creators are plain JavaScript functions. This means that they can accept zero or more arguments when <a id="id155" class="indexterm"/>called. The whole point of implementing a function, regardless of whether or not it's in the context of Flux, is to reduce the amount of code we have to write. Action creators in a Flux application are likely to accumulate because they drive the behavior of our application. If anything happens, it can be traced back to an action. So it's easy to introduce several new actions over the course of a day.</p><p>Once our application has several features implemented, we're bound to have a lot of actions. Some of these actions will serve a distinct purpose, while other actions will be very similar to each other. In other words, some actions will start to feel redundant. The goal is to remove redundant action creator functions by introducing parameters.</p><p>We should exercise caution in how we go about refactoring our action creator functions. There's a strong argument in favor of keeping a dedicated function for each type of action in the system. That is, one <a id="id156" class="indexterm"/>action creator function should only ever dispatch one type of action, not one of several options. Otherwise, the traceability of our code will be diminished. We should aim to reduce the total number of actions in the system altogether.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Keeping actions generic</h2></div></div></div><p>When actions are <a id="id157" class="indexterm"/>generic, the architecture requires less of them. This is a good thing because it means there's less knowledge to keep in our heads as we're writing code. Let's take a look at a couple of actions that do essentially the same thing; in other words, they're not generic at all. The first action is as follows:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';
import sortBy from 'lodash/sortBy';

// The action identifier...
export const FIRST = 'FIRST';

export function first() {

  // The payload data.
  let payload = [ 20, 10, 30 ];

  // Dispatches the "FIRST" action with
  // the payload sorted in ascending order.
  dispatcher.dispatch({
    type: FIRST,
    payload: sortBy(payload)
  });
}</pre></div><p>Simple enough—it's using the lodash <code class="literal">sortBy()</code> function to sort the payload before dispatching the action.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Note that we wouldn't actually sort payload data like this in the action creator function. Think of this as an API mock. The point is that action creator function is asking something outside of Flux for data.</p></div></div><p>Let's look at another similar but distinct action:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';
import sortBy from 'lodash/sortBy';

// The action identifier...
export const SECOND = 'SECOND';

export function second() {

  // The payload data.
  let payload = [ 20, 10, 30 ];

  // Dispatches the action, with the
  // payload sorted in descending order.
  dispatcher.dispatch({
    type: SECOND,
    payload: sortBy(payload, x =&gt; x * -1)
  });
}</pre></div><p>The only difference here is how we're sorting the data. If this were a production action creator function, we would tell the API to sort the data in descending order instead of using lodash to do it in the<a id="id158" class="indexterm"/> action creator. Do we need two distinct actions for these two sort directions? Or can we eliminate both of them in favor of a generic action that accepts a sort direction parameter? Here's a generic implementation of the action:</p><div><pre class="programlisting">import dispatcher from '../dispatcher';
import sortBy from 'lodash/sortBy';

// The action identifier...
export const THIRD = 'THIRD';

// Accepts a sort direction, but defaults
// to descending.
export function third(dir='desc') {

  // The payload data.
  let payload = [ 20, 10, 30 ];

  // The iteratee function that's passed
  // to "sortBy()".
  let iteratee;

  // Sets up the custom "iteratee" if we
  // want to sort in descending order.
  if (dir === 'desc') {
    iteratee = x =&gt; x * -1;
  }

  // Dispatches the action, sorting the payload
  // based on "dir".
  dispatcher.dispatch({
    type: THIRD,
    payload: sortBy(payload, iteratee)
  });
}</pre></div><p>Here are all three actions being used. Note that the third action covers both cases, and yet the fundamental sort action is the same no matter what arguments are passed. You can see in the dispatcher callback<a id="id159" class="indexterm"/> function that stores would have an easier time listening to one action instead of two or more:</p><div><pre class="programlisting">import dispatcher from './dispatcher';
import { FIRST, first } from './actions/first';
import { SECOND, second } from './actions/second';
import { THIRD, third } from './actions/third';

// Logs the specific action payloads as
// they're dispatched.
dispatcher.register((e) =&gt; {
  switch(e.type) {
    case FIRST:
      console.log('first', e.payload);
      break;
    case SECOND:
      console.log('second', e.payload);
      break;
    case THIRD:
      console.log('third', e.payload);
      break;
  }
});

first();
// → first [10, 20, 30]

second();
// → second [30, 20, 10]

third();
// → third [30, 20, 10]

third('asc');
// → third [10, 20, 30]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Creating action partials</h2></div></div></div><p>In some cases, function arguments are straightforward—as in there are one or two of them. In others, the argument lists can be daunting, especially when we're calling them repeatedly using the<a id="id160" class="indexterm"/> same handful of arguments. Action creators in Flux applications are no different. There will be cases where we have a generic function that supports the odd case where, instead of a new action creator function, we simply supply a different parameter. But in the most common case, where the same parameters have to be supplied all the time, this can get repetitive to the point where it defeats the purpose of having generic functions.</p><p>Let's look at a generic action creator function that accepts a variable number of arguments. Since the same arguments are passed to the function in the most common case, we'll also export a partial version of the function where these arguments have been partially applied.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Default parameters in ES2015 syntax are a good alternative to creating partial functions, but only when the number of arguments is fixed.</p></div></div><div><pre class="programlisting">import dispatcher from '../dispatcher';
import partial from 'lodash/partial';

// The action identifier...
export const FIRST = 'FIRST';

// The generic implementation of the action creator.
export function first(...values) {

  // The payload data.
  let defaults = [ 'a', 'b', 'c' ];

  // Dispatches the "FIRST" action with
  // the "values" array concatenated to
  // the "defaults" array.
  dispatcher.dispatch({
    type: FIRST,
    payload: defaults.concat(values)
  });
}

// Exports a common version of "first()" with
// the common arguments already applied.
export const firstCommon = partial(first, 'd', 'e', 'f');</pre></div><p>Now let's see how these two <a id="id161" class="indexterm"/>versions of the same action creator are used:</p><div><pre class="programlisting">import dispatcher from './dispatcher';
import { FIRST, first, firstCommon } from './actions/first';

// Logs the specific action payloads as
// they're dispatched.
dispatcher.register((e) =&gt; {
  switch(e.type) {
    case FIRST:
      console.log('first', e.payload);
      break;
  }
});

// Calls the action creator with a common set
// of arguments. This is the type of code we
// want to avoid repeating all over the place.
first('d', 'e', 'f');
// → first ["a", "b", "c", "d", "e", "f"]

// The exact same thing as the "fist()" call above.
// The common arguments have been partially-applied.
firstCommon();
// → first ["a", "b", "c", "d", "e", "f"]</pre></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>It's important to note that the <code class="literal">first()</code> and <code class="literal">firstCommon()</code> functions are the same action creator, and this is why they're defined in the same module. If we were to define <code class="literal">firstCommon()</code> in another action module, this would lead to confusion, because they both use the same action type—<code class="literal">FIRST</code>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, you learned about the action creator functions that Flux applications utilize in order to dispatch actions. Without action creator functions, we'd have to directly interface with the dispatcher in our code, which makes the architecture more difficult to reason about.</p><p>We started off by thinking about action naming conventions and the general organization of our action modules. Grouping action creators by feature has implications for modularity as well, especially in how this influences modularity in other areas of the architecture.</p><p>Next, we discussed mocking data using action creator functions. Mocking data in Flux applications is easy to do and encouraged. Actions are the only way for data to enter the system, making it easy for us to switch between mocked action data and our production implementations. We wrapped the chapter up with a look at stateful action creators that listen to things such as web socket connections, and a look at parameterized action creators that keep repetitive code to a minimum.</p><p>In the next chapter, we'll address another key aspect of action creator functions—asynchronicity.</p></div></body></html>