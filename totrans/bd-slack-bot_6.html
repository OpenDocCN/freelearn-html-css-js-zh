<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Webhooks and Slash Commands</h1></div></div></div><p>Every bot we've created so far shares the same two traits: they rely on commands issued by users and require a Slack API token. This has been very useful in our bots so far, but what if we want a bot to post messages to a Slack channel without needing an API token? Plus what if we want a bot that does not require an API token to interact with users? An example of this is the GitHub Slack integration, a service that posts GitHub activity on specific repositories to a Slack channel of your choice.</p><p>In this chapter, we will discuss how to use webhooks to get data in and out of Slack and how to create slash commands that users can interact with throughout Slack.</p><p>We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Webhooks</li><li class="listitem" style="list-style-type: disc">Incoming webhooks</li><li class="listitem" style="list-style-type: disc">Outgoing webhooks</li><li class="listitem" style="list-style-type: disc">Slash commands</li><li class="listitem" style="list-style-type: disc">In-channel and ephemeral responses</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Webhooks</h1></div></div></div><p>A webhook is a way of altering <a class="indexterm" id="id247"/>or augmenting a web application through HTTP methods. Previously, we used third-party APIs in our bots to get data into and out of Slack. However, this isn't the only way. Webhooks allow us to post message to and from Slack using regular HTTP requests with a JSON payload. What makes a webhook a bot is its ability to post messages to Slack as if they are a bot user.</p><p>These webhooks can be divided into incoming and outgoing webhooks, each with their own purposes and uses.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec29"/>Incoming webhooks</h2></div></div></div><p>An example of an <a class="indexterm" id="id248"/>incoming webhook would be a service that relays information <a class="indexterm" id="id249"/>from an external source to a Slack channel without being explicitly requested. An example of this is the aforementioned GitHub Slack integration:</p><div><img alt="Incoming webhooks" src="img/B05384_06_01.jpg"/><div><p>The GitHub integration posts messages about repositories we are interested in</p></div></div><p>In the preceding screenshot, we can see how a message was sent to Slack after a new branch was made on a repository this team is watching. This data wasn't explicitly requested by a team member, but it was automatically sent to the channel as a result of the incoming webhook.</p><p>Other popular examples include a Jenkins integration, where infrastructure changes can be monitored in Slack (for example, if a server watched by Jenkins goes down, a warning message can be posted immediately to a relevant Slack channel).</p><p>Let's start by setting up <a class="indexterm" id="id250"/>an incoming webhook that sends a <a class="indexterm" id="id251"/>simple <em>Hello world</em> message:</p><div><ol class="orderedlist arabic"><li class="listitem">First, navigate to the Custom Integration Slack team page (<a class="ulink" href="https://my.slack.com/apps/build/custom-integration">https://my.slack.com/apps/build/custom-integration</a>).<div><img alt="Incoming webhooks" src="img/B05384_06_02.jpg"/><div><p>The various flavors of custom integration</p></div></div></li><li class="listitem">Select <strong>Incoming WebHooks</strong> from the list, and then select the channel you'd like your <a class="indexterm" id="id252"/>webhook app to post messages to:<div><img alt="Incoming webhooks" src="img/B05384_06_03.jpg"/><div><p>Webhook apps will post to a channel of your choosing</p></div></div><p>Custom <a class="indexterm" id="id253"/>webhooks (that is, webhooks created for your team only) use the selected channel as a default channel to send message to. It is possible to use the same webhook to post to different channels, as we'll see in a moment.</p></li><li class="listitem">Once you've clicked on the <strong>Add Incoming WebHooks integration</strong> button, you will be presented with an options page that allows you to customize your integration a little further.<div><img alt="Incoming webhooks" src="img/B05384_06_04.jpg"/><div><p>Names, descriptions, and icons can be set from this menu</p></div></div></li><li class="listitem">Set a customized icon for your integration (for this example, the <code class="literal">wave</code> emoji was used) and copy down the webhook URL, which has the following format:<p>
<code class="literal">https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX</code>
</p></li></ol></div><p>This generated URL is <a class="indexterm" id="id254"/>unique to your team, meaning that any JSON <a class="indexterm" id="id255"/>payloads sent via this URL will only appear in your team's Slack channels.</p><p>Now, let's throw together a quick test of our incoming webhook in Node. Start a new Node project (remember you can use <code class="literal">npm init</code> to create your <code class="literal">package.json</code>) and install the familiar <code class="literal">superagent</code> AJAX library by running the following in your terminal:</p><div><pre class="programlisting">
<strong>npm install superagent –save</strong>
</pre></div><p>Create a file named <code class="literal">index.js</code> and paste the following JavaScript code within it:</p><div><pre class="programlisting">const WEBHOOK_URL = [YOUR_WEBHOOK_URL];

const request = require('superagent');

request
  .post(WEBHOOK_URL)
  .send({
    text: 'Hello! I am an incoming Webhook bot!'
  })
  .end((err, res) =&gt; {
    console.log(res);
  });</pre></div><p>Remember to replace <code class="literal">[YOUR_WEBHOOK_URL]</code> with your newly generated URL, and then run the program by executing the following command:</p><div><pre class="programlisting">
<strong>nodemon index.js</strong>
</pre></div><p>Two things should happen now: firstly a long response should be logged in your terminal and secondly you should <a class="indexterm" id="id256"/>see a message like the following in the <a class="indexterm" id="id257"/>Slack client:</p><div><img alt="Incoming webhooks" src="img/B05384_06_05.jpg"/><div><p>The incoming webhook equivalent of "hello world"</p></div></div><p>The <code class="literal">res</code> object that we logged in our terminal is the response from the AJAX request. Taking the form of a large JavaScript object, it displays information about the HTTP POST request we made to our webhook URL.</p><p>Looking at the message received in the Slack client, notice how the name and icon are the same as what we set in our integration setup in the team admin site. Remember that the default icon, name, and channel are used if none are provided, so let's see what happens when we change that around. Replace your <code class="literal">request</code> AJAX call in <code class="literal">index.js</code> with the following:</p><div><pre class="programlisting">request
  .post(WEBHOOK_URL)
  .send({
    username: "Incoming bot",
    channel: "#general",
    icon_emoji: ":+1:",
    text: 'Hello! I am different from the previous bot!'
  })
  .end((err, res) =&gt; {
    console.log(res);
  });</pre></div><p>Save the file and <code class="literal">nodemon</code> will automatically restart the program. Switch over to the Slack client and you <a class="indexterm" id="id258"/>should see a message like the following pop up in <a class="indexterm" id="id259"/>your <code class="literal">#general</code> channel:</p><div><img alt="Incoming webhooks" src="img/B05384_06_06.jpg"/><div><p>New name, icon, and message</p></div></div><div><div><h3 class="title"><a id="note30"/>Note</h3><p>In place of <code class="literal">icon_emoji</code>, you could also use <code class="literal">icon_url</code> to link to a specific image of your choosing.</p></div></div><p>If you wish your message to only be sent to one user, you can supply a username as the value for the <code class="literal">channel</code> property:</p><div><pre class="programlisting">channel: "@paul"</pre></div><p>This will cause the message to be sent from within the Slackbot direct message. The message's icon and username will match what you either configured in the setup or set in the body of the POST request.</p><p>Finally, let's look at sending links in our integration; replace the <code class="literal">text</code> property with the following and save <code class="literal">index.js</code>:</p><div><pre class="programlisting">text: 'Hello! Here is a fun link: &lt;http://www.github.com|Github is great!&gt;'</pre></div><p>Slack will automatically parse any links it finds, whether it's in the format <code class="literal">http://www.example.com</code> or <code class="literal">www.example.com</code>. By enclosing the URL in angled brackets and using the <code class="literal">|</code> character, we can specify what we would like the URL to be shown as:</p><div><img alt="Incoming webhooks" src="img/B05384_06_07.jpg"/><div><p>Formatted links are easier to read than long URLs</p></div></div><p>For more information on message formatting, visit <a class="ulink" href="https://api.slack.com/docs/formatting">https://api.slack.com/docs/formatting</a>.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Note that as this is a custom webhook integration, we can change the name, icon, and channel of the integration. If we were to package the integration as a Slack app (an app which is installable by other teams), then it is not possible to override the default channel, username, and icon set.</p></div></div><p>Incoming webhooks are <a class="indexterm" id="id260"/>triggered by external sources—an example would be if a new user signs up to your service or if a product is sold. The goal of the incoming webhook is to provide easy-to-reach and comprehensible information for your team. The opposite would be if you want users to get data out of Slack, which can be done via the medium of outgoing webhooks.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec30"/>Outgoing webhooks</h2></div></div></div><p>Outgoing webhooks differ <a class="indexterm" id="id261"/>from the incoming variety in that they <a class="indexterm" id="id262"/>send data out of Slack and to a service of your choosing, which in turn can respond with a message to the Slack channel.</p><p>To set up an outgoing <a class="indexterm" id="id263"/>webhook, visit the custom integration page of your Slack team's admin page again (<a class="ulink" href="https://my.slack.com/apps/build/custom-integration">https://my.slack.com/apps/build/custom-integration</a>). This time, select the <strong>Outgoing WebHooks</strong> option.</p><p>In the next screen, be sure to select a channel, a name, and an icon. Notice how there is a <code class="literal">target</code> URL field to be filled in; we will fill this out shortly.</p><p>When an outgoing webhook is triggered in Slack, an HTTP POST request is made to the URL (or URLs, as you can specify multiples) you provide. So first we need to build a server that can accept our webhook.</p><p>In <code class="literal">index.js</code>, paste the following code:</p><div><pre class="programlisting">'use strict';
const http = require('http');
// create a simple server with node's built in http module
http.createServer((req, res) =&gt; {
  res.writeHead(200, {'Content-Type': 'text/plain'});

  // get the data embedded in the POST request
  req.on('data', (chunk) =&gt; {
    // chunk is a buffer, so first convert it to 
    // a string and split it to make it more legible as an array
     console.log('Body:', chunk.toString().split('&amp;'));
  });

  // create a response
  let response = JSON.stringify({
    text: 'Outgoing webhook received!'
  });

  // send the response to Slack as a message
  res.end(response);
}).listen(8080, '0.0.0.0');

console.log('Server running at http://0.0.0.0:8080/');</pre></div><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Notice how we require the <code class="literal">http</code> module, despite not installing it with NPM. That is because the <code class="literal">http</code> module is a core Node dependency and is automatically included with your installation of Node.</p></div></div><p>In this block of code, we start a <a class="indexterm" id="id264"/>simple server on port 8080 and listen for <a class="indexterm" id="id265"/>incoming requests.</p><p>In this example, we set our server to run at 0.0.0.0 rather than <code class="literal">localhost</code>. This is important as Slack is sending a request to our server, so it needs to be accessible from the Internet. Setting the <a class="indexterm" id="id266"/>
<strong>Internet Protocol</strong> (<strong>IP</strong>) of our server to 0.0.0.0 tells Node to use your computer's network-assigned IP address. Therefore, by setting the IP of our server to 0.0.0.0, Slack can reach your server by hitting your IP on port 8080 (for example, <code class="literal">http://123.456.78.90:8080</code>).</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>If you are having trouble with Slack reaching your server, it is most likely because you are behind a router or firewall. To circumvent this issue, you can use a service such as <a class="indexterm" id="id267"/>
<code class="literal">ngrok</code> (<a class="ulink" href="https://ngrok.com/">https://ngrok.com/</a>). Alternatively, look into the <strong>Port Forwarding</strong> settings for your router or firewall.</p></div></div><p>Let's update our outgoing webhook settings accordingly:</p><div><img alt="Outgoing webhooks" src="img/B05384_06_08.jpg"/><div><p>The outgoing webhook settings, with destination URL</p></div></div><p>Save your settings and run <a class="indexterm" id="id268"/>your Node app; test that the outgoing webhook <a class="indexterm" id="id269"/>works by typing a message into the channel you specified in the webhook's settings. You should then see something like this in Slack:</p><div><img alt="Outgoing webhooks" src="img/B05384_06_09.jpg"/><div><p>We built a spam bot</p></div></div><p>Well the good news is that <a class="indexterm" id="id270"/>our server is receiving requests and returning a <a class="indexterm" id="id271"/>message to send to Slack. The issue here is that we skipped over the <strong>Trigger Word(s)</strong> field in the webhook settings page. Without a trigger word, any message sent to the specified channel will trigger the outgoing webhook. This causes our webhook to trigger on a message sent by the outgoing webhook in the first place, creating an infinite loop.</p><p>To fix this we could do one of two things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refrain from returning a message to the channel when listening to all the channel's messages</li><li class="listitem" style="list-style-type: disc">Specify a trigger word or trigger words to ensure we don't spam the channel</li></ul></div><p>Returning a message is optional, yet it is encouraged to ensure a better user experience. Even a confirmation message such as <strong>Message received!</strong> is better than no message, as it confirms to the user that their message was received and is being processed.</p><p>Let's presume we prefer <a class="indexterm" id="id272"/>the second option and add a <a class="indexterm" id="id273"/>trigger word:</p><div><img alt="Outgoing webhooks" src="img/B05384_06_10.jpg"/><div><p>Trigger words keep our webhooks organized</p></div></div><p>Now, let's try that again, this time sending a message with the trigger word at the beginning of the message. Restart your Node app and send a new message:</p><div><img alt="Outgoing webhooks" src="img/B05384_06_11.jpg"/><div><p>Our outgoing webhook app now functions a lot like our bots from earlier</p></div></div><p>Great, now switch over to your terminal and see what that message logged:</p><div><pre class="programlisting">Body: [ 'token=KJcfN8xakBegb5RReelRKJng',
  'team_id=T000001',
  'team_domain=buildingbots',
  'service_id=34210109492',
  'channel_id=C0J4E5SG6',
  'channel_name=bot-test',
  'timestamp=1460684994.000598',
  'user_id=U0HKKH1TR',
  'user_name=paul',
  'text=webhook+hi+bot%21',
  'trigger_word=webhook' ]</pre></div><p>This array contains the body of the HTTP POST request sent by Slack. In it, we have some useful data such as the user's name, the message sent, and the team ID. We can use this data to customize the response or to perform some validation to make sure the user is authorized to use this webhook.</p><p>In our response, we simply sent back a <strong>Message received</strong> string. However, like with incoming webhooks, we can set our own username and icon. The channel cannot be different from the channel specified in the webhook's settings. The same restrictions apply when the webhook is not a custom integration. This means that if the webhook was installed as a Slack app for another team, the webhook can only post messages as the username and icon specified in the setup screen. We will cover Slack apps in detail in <a class="link" href="ch07.html" title="Chapter 7. Publishing Your App">Chapter 7</a>, <em>Publishing Your App</em>.</p><p>An important thing to note is <a class="indexterm" id="id274"/>that webhooks, either incoming or outgoing, can only be set up in public channels. This is predominantly to discourage abuse and uphold <a class="indexterm" id="id275"/>privacy, as we've seen that it's trivial to set up a webhook that can record all the activity in a channel.</p><p>If you want similar functionality in private groups or DMs, we can use a slash command instead.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Slash commands</h1></div></div></div><p>Commands that begin <a class="indexterm" id="id276"/>with a slash (<code class="literal">/</code>) are commands that can be used from anywhere within the Slack client. You are probably already familiar with the more common ones implemented by Slack themselves. For instance, use the <code class="literal">topic</code> command:</p><div><pre class="programlisting">/topic Sloths are great</pre></div><p>This will set the channel's topic to "Sloths are great." Like with incoming and outgoing webhooks, Slack allows teams to configure their own custom slash commands. To demonstrate their use, we'll build a bot that uses the popular computational knowledge engine Wolfram <a class="indexterm" id="id277"/>Alpha (<a class="ulink" href="http://www.wolframalpha.com/">http://www.wolframalpha.com/</a>). The end goal is a bot that returns the results from the query submitted via the slash command.</p><p>Unlike webhooks, slash commands can only send data included with the command, so you are guaranteed to only receive data that was intentionally sent. Because of this nuance, we get an additional benefit to using slash commands. They are available to be used from any channel, DM, or private group.</p><p>First, let's set up the slash command integration and get a Wolfram Alpha API key. Although we don't specifically need a Slack token, we do require one to access Wolfram Alpha's services. Navigate to your <a class="indexterm" id="id278"/>team's integration settings (<a class="ulink" href="https://buildingbots.slack.com/apps/manage/custom-integrations">https://buildingbots.slack.com/apps/manage/custom-integrations</a>), select <strong>Slash Commands</strong>, and then select <strong>Add Configuration</strong>. We're going to use the <code class="literal">wolfram</code> string as our slash command, so let's fill that in and continue.</p><div><img alt="Slash commands" src="img/B05384_06_12.jpg"/><div><p>The slash command must be unique to your team</p></div></div><p>Now, specify a URL that <a class="indexterm" id="id279"/>the slash command will send a request to, similar to what we did earlier with webhooks.</p><div><img alt="Slash commands" src="img/B05384_06_13.jpg"/><div><p>The slash command can be customized in a different way to webhooks</p></div></div><p>We have the choice of which HTTP method to use when requesting the provided URL. If you wish to send data to a server, use the <strong>POST</strong> method. If you wish to retrieve data without sending anything, use the <strong>GET</strong> method. For our Wolfram Alpha bot, we will be using <strong>POST</strong>, as we're sending a query to the server we created earlier.</p><p>Take special note of the generated token. This is a unique identifier that you can use to ensure that all requests coming to your server are from this particular Slack slash command, allowing you to reject any unwanted requests. We'll get back to the token later.</p><p>Next, we will fill out the autocomplete details. Although optional, it is strongly recommended that you fill <a class="indexterm" id="id280"/>them out anyway, as they give clear instructions for your users on how to use your slash command.</p><div><img alt="Slash commands" src="img/B05384_06_14.jpg"/><div><p>Help text is incredibly helpful to users who have never used your command before</p></div></div><p>Similar to other third-party APIs we've used in this book, the Wolfram Alpha API requires an API token to access their computational services. To get one, navigate to the following URL and follow the on-screen sign up instructions: <a class="ulink" href="https://developer.wolframalpha.com/portal/apisignup.html">https://developer.wolframalpha.com/portal/apisignup.html</a>.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>Note that the Wolfram Alpha API is only free up to 2000 requests per month. If your slash command exceeds that amount, your requests will be denied unless you pay for a higher-tier service.</p></div></div><p>The Wolfram Alpha API sends responses in XML, which we'll need to convert to JSON for easier use. Luckily, there <a class="indexterm" id="id281"/>is an NPM package that can abstract this problem away for us: <code class="literal">node-wolfram</code> (<a class="ulink" href="https://www.npmjs.com/package/node-wolfram">https://www.npmjs.com/package/node-wolfram</a>). Install the <code class="literal">node-wolfram</code> package by running the following command:</p><div><pre class="programlisting">
<strong>npm install node-wolfram –save</strong>
</pre></div><p>Once you have your key and you've installed <code class="literal">node-wolfram</code>, paste the following code in <code class="literal">index.js</code>:</p><div><pre class="programlisting">'use strict';

const http = require('http');
const request = require('superagent');

const WOLFRAM_TOKEN = [YOUR_WOLFRAM_API_TOKEN];
const SLACK_TOKEN = [YOUR_SLACK_TOKEN];

const Client = require('node-wolfram');
const wolfram = new Client(WOLFRAM_TOKEN);

// create a simple server with node's built in http module
http.createServer((req, res) =&gt; {
    res.writeHead(200, {'Content-Type': 'text/plain'});

    // get the data embedded in the POST request
    req.on('data', (chunk) =&gt; {
      // chunk is a buffer, so first convert it 
      // to a string and split it to make it legible
      console.log('Body:', chunk.toString().split('&amp;'));

      let bodyArray = chunk.toString().split('&amp;');
      let bodyObject = {};

      // convert the data array to an object
      for (let i = 0; i &lt; bodyArray.length; i++) {
        // convert the strings into key value pairs
        let arr = bodyArray[i].split('=');
        bodyObject[arr[0]] = arr[1];
      }

      // if the token doesn't match ours, abort
      if (bodyObject.token !== SLACK_TOKEN) {
        return res.end('Invalid token');
      }

      queryWolfram(bodyObject.text.split('+').join(' '), (err, result) =&gt; {
        if (err) {
          console.log(err);
          return;
        }

        // send back the result to Slack
        res.end(result);
      });
    });
}).listen(8080, '0.0.0.0');

console.log('Server running at http://0.0.0.0:8080/');

// make sure to unescape the value so we don't get Unicode
let query = unescape(bodyObject.text.split('+').join(' '));

queryWolfram(query, (err, result) =&gt; {  wolfram.query(message, (err, result) =&gt; {
    if (err) {
      return done(err);
    }

    // if the query didn't fail, but the message wasn't understood 
    // then send a generic error message
    if (result.queryresult.$.success === 'false') {
      return done(null, 'Sorry, something went wrong, please try again');
    }
    let msg = '';

    for (let i = 0; i &lt; result.queryresult.pod.length; i++) {
      let pod = result.queryresult.pod[i];
      msg += pod.$.title + ': \n';

      for (let j = 0; j &lt; pod.subpod.length; j++) {
        let subpod = pod.subpod[j];

        for (let k = 0; k &lt;subpod.plaintext.length; k++) {
          let text = subpod.plaintext[k];
          msg += '\t' + text + '\n';
        }
      }
    }

    done(null, msg);
  });
}</pre></div><p>Simply put, this block of code <a class="indexterm" id="id282"/>listens for incoming requests at port 8080. Once data is received (via a POST request), we convert the data to a JavaScript object for easy use. If the token sent in the request matches the one hardcoded in our program, we send a request to Wolfram Alpha that includes the slash command's content. Luckily, Wolfram Alpha run their own <strong>natural language processing</strong> (<strong>NLP</strong>), so <a class="indexterm" id="id283"/>we can just send the user's input and let Wolfram Alpha do the heavy lifting. Once we receive a callback from the Wolfram Alpha API, we return the results to Slack, which posts it in the Slack channel. Run your server and type the following command into Slack to see it in action:</p><div><pre class="programlisting">/wolfram 2 x 2</pre></div><p>After a few moments, you should see the result:</p><div><img alt="Slash commands" src="img/B05384_06_15.jpg"/><div><p>Wolfram Alpha calculates a simple math problem</p></div></div><p>Success! Now let's try a more challenging query:</p><div><pre class="programlisting">/wolfram distance between earth and moon</pre></div><p>That request should result in something like this:</p><div><img alt="Slash commands" src="img/B05384_06_16.jpg"/><div><p>The query took too long</p></div></div><p>Oh dear, it looks like our query timed out. Were we to add some logging to our app, we'd see that although the Wolfram Alpha API does eventually return a result, it takes more than the maximum timeout period of Slack webhook integrations (3,000 milliseconds). This causes the slash command to fail and displays the preceding error message.</p><p>To solve this, let's look at the <a class="indexterm" id="id284"/>data received from Slack initially; the body from the previous slash command looks like this:</p><div><pre class="programlisting">Body: [ 'token=86oxKgPrkxrvPHpmleaP8Rbs',
  'team_id=T00000000',
  'team_domain=buildingbots',
  'channel_id=C0J4E5SG6',
  'channel_name=bot-test',
  'user_id=U0HKKH1TR',
  'user_name=paul',
  'command=%2Fwolfram',
  'text=distance+between+earth+and+moon',   'response_url=https%3A%2F%2Fhooks.slack.com%2Fcommands%2FT0HKKH1T9%2F35399194752%2Fm9mIVSHYjMdnwXWyCTYYTIZj' ]</pre></div><p>The last index of the <code class="literal">Body</code> array is what interests us—a response URL. Should your calculations take longer than the maximum timeout of 3000 milliseconds, Slack provides us with a URL which we can make a POST HTTP request to, much like how we sent webhook messages.</p><p>If your slash command does take longer than the maximum timeout and you're using the request URL, it is highly recommended that you return a message to Slack, letting the user know that their request is processing.</p><p>Replace the <code class="literal">http.createServer</code> block in your code with the following, noting the highlighted areas:</p><div><pre class="programlisting">// create a simple server with node's built in http module
http.createServer((req, res) =&gt; {
    res.writeHead(200, {'Content-Type': 'text/plain'});

    // get the data embedded in the POST request
    req.on('data', (chunk) =&gt; {
      // chunk is a buffer, so first convert it to a string 
      // and split it to make it legible
      console.log('Body:', chunk.toString().split('&amp;'));

      let bodyArray = chunk.toString().split('&amp;');
      let bodyObject = {};

      // convert the data array to an object
      for (let i = 0; i &lt; bodyArray.length; i++) {
        // convert the strings into key value pairs
        let arr = bodyArray[i].split('=');
        bodyObject[arr[0]] = arr[1];
      }

      // if the token doesn't match ours, abort
      if (bodyObject.token !== SLACK_TOKEN) {
        return res.end('Invalid token');
      }

<strong>      // send a message immediately to confirm that </strong>
<strong>      // the request was receive it's possible that the </strong>
<strong>      // query will take longer than the time Slack waits</strong>
<strong>      // for a response (3000ms), so we'll send a </strong>
<strong>      // preliminary response and then send the results later</strong>
<strong>      res.end('Calculating response, be with you shortly!');</strong>

      // make sure to unescape the value so we don't get Unicode
      let query = unescape(bodyObject.text.split('+').join(' '));

      queryWolfram(query, (err, result) =&gt; {  wolfram.query(message, (err, result) =&gt; {
        if (err) {
          console.log(err);
          return;
        }

<strong>        // send the result from the wolfram alpha request,</strong>
<strong>        // which probably took longer than 3000ms to calculate</strong>
<strong>        request</strong>
<strong>          .post(unescape(bodyObject.response_url))</strong>
<strong>          .send({</strong>
<strong>            text: result</strong>
<strong>          })</strong>
<strong>          .end((err, res) =&gt; {</strong>
<strong>            if (err) console.log(err);</strong>
<strong>          });</strong>
      });
    });
}).listen(8080, '0.0.0.0');</pre></div><p>After confirming that the slash command request came from our team, but before we even start the Wolfram Alpha API <a class="indexterm" id="id285"/>request, we return a confirmation message to the Slack channel letting the user know that their request is in the works.</p><p>Once Wolfram Alpha has returned our data, we send an HTTP POST request to the response URL provided to us in the slash command's initial request body. Let's try that last command again:</p><div><pre class="programlisting">/wolfram distance between earth and moon</pre></div><p>This should return a confirmation message:</p><div><img alt="Slash commands" src="img/B05384_06_17.jpg"/><div><p>A confirmation message lets the user know things are happening</p></div></div><p>A few seconds later, we should see the full result of the slash command query:</p><div><img alt="Slash commands" src="img/B05384_06_18.jpg"/><div><p>Our slash command returns an abundance of data</p></div></div><p>With our slash command <a class="indexterm" id="id286"/>working as expected, let's look at a quirk of the returned output.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>In-channel and ephemeral responses</h1></div></div></div><p>You might <a class="indexterm" id="id287"/>have noticed that when the Wolfram Alpha bot responds, it has the text <strong>Only you can see this message</strong> next to its name. As the text implies, the result of our bot is only visible to the user who initiated the slash command. This is an example of an ephemeral response. Note that the original slash command's text is also only viewable to the user that executed it. The opposite of ephemeral is an in-channel response, which can show both the slash command and result in the channel, for all to see.</p><p>By default, all slash command responses are set to ephemeral mode by the Slack API. Let's look at changing <a class="indexterm" id="id288"/>that and send in-channel messages instead. Once again, let's replace the contents of <code class="literal">http.createServer</code>. Go over the changes step by step:</p><div><pre class="programlisting">// create a simple server with node's built in http module
http.createServer((req, res) =&gt; {
    res.writeHead(200, {'Content-Type': 'application/json'});</pre></div><p>The main difference here is that we've changed the response's header content type to be <code class="literal">application/json</code>. This notifies Slack to expect a JSON package in string form.</p><p>The code is as follows:</p><div><pre class="programlisting">// get the data embedded in the POST request
req.on('data', (chunk) =&gt; {
     // chunk is a buffer, so first convert it to a string 
     // and split it to make it legible
  console.log('Body:', chunk.toString().split('&amp;'));

  let bodyArray = chunk.toString().split('&amp;');
  let bodyObject = {};

  // convert the data array to an object
  for (let i = 0; i &lt; bodyArray.length; i++) {
    // convert the strings into key value pairs
    let arr = bodyArray[i].split('=');
    bodyObject[arr[0]] = arr[1];
  }

  // if the token doesn't match ours, abort
  if (bodyObject.token !== SLACK_TOKEN) {
<strong>    return res.end(JSON.stringify({</strong>
<strong>    response_type: 'ephemeral',</strong>
<strong>    text: 'Invalid token'</strong>
<strong>  }));</strong>
}</pre></div><p>Our error response now requires that it be in stringified JSON format. Also, we add the response type <code class="literal">ephemeral</code>, which means that the error message will only be visible to the user who initiated the slash command:</p><div><pre class="programlisting">// send a message immediately to confirm that
// the request was receive it's possible that the
// query will take longer than the time Slack waits
// for a response (3000ms), so we'll send a
// preliminary response and then send the results later
res.end(JSON.stringify({
<strong>  response_type: 'in_channel',</strong>
<strong>  text: 'Calculating response, be with you shortly!'</strong>
}));</pre></div><p>Now, we specifically <a class="indexterm" id="id289"/>want an <code class="literal">in-channel</code> response. In this context, it means that both the slash command and the processing response will be visible to all in the channel:</p><div><img alt="In-channel and ephemeral responses" src="img/B05384_06_19.jpg"/><div><p>Both the original slash command and the interim response are visible</p></div></div><p>And finally we query <strong>Wolfram|Alpha</strong>:</p><div><pre class="programlisting">// make sure to unescape the value so we don't get Unicode
let query = unescape(bodyObject.text.split('+').join(' '));

queryWolfram(query, (err, result) =&gt; {
  if (err) {
    console.log(err);
    return;
  }

   // send the result from the wolfram alpha request,
   // which probably took longer than 3000ms to calculate
   request
     .post(unescape(bodyObject.response_url))
<strong>     .send({</strong>
<strong>       response_type: 'in_channel',</strong>
<strong>       text: result</strong>
<strong>     })</strong>
     .end((err, res) =&gt; {
       if (err) console.log(err);
     });
    });
  });
}).listen(8080, '0.0.0.0');</pre></div><p>Here, we again <a class="indexterm" id="id290"/>ensure that the Wolfram Alpha result is visible to the entire channel. Finally, let's make some improvements to the display of the data in our <code class="literal">queryWolfram</code> function:</p><div><pre class="programlisting">function queryWolfram(message, done) {
  wolfram.query(message, (err, result) =&gt; {
    if (err) {
      return done(err);
    }

    // if the query didn't fail, but the message wasn't understood
    // then send a generic error message
    if (result.queryresult.$.success === 'false') {
      return done(null, 'Sorry, something went wrong, please try again');
    }

<strong>    let msg = [];</strong>

    for (let i = 0; i &lt; result.queryresult.pod.length; i++) {
      let pod = result.queryresult.pod[i];

      // print the title in bold
<strong>      msg.push(`*${pod.$.title}:*\n`);</strong>

      for (let j = 0; j &lt; pod.subpod.length; j++) {
        let subpod = pod.subpod[j];

        for (let k = 0; k &lt;subpod.plaintext.length; k++) {
          let text = subpod.plaintext[k];
<strong>          if (text) {</strong>
<strong>            // add a tab to the beginning</strong>
<strong>            msg.push('\t' + text + '\n');</strong>
<strong>          } else {</strong>
<strong>            // text is empty, so get rid of the title as well</strong>
<strong>            msg.pop();</strong>
<strong>          }</strong>
        }
      }
    }

    // join the msg array together into a string
    done(null, msg.join(''));
  });
}</pre></div><p>Improvements here include bolding the title of a section and removing sections that have no text associated.</p><p>Now that we've <a class="indexterm" id="id291"/>put it all together, let's test it out:</p><div><img alt="In-channel and ephemeral responses" src="img/B05384_06_20.jpg"/><div><p>Wolfram Alpha can also be used to get definitions of popular algorithms</p></div></div><p>Bear in mind that slash commands are available universally in your Slack team. In our case, it means that the <strong>Wolfram|Alpha</strong> bot can be triggered from any channel, DM, or private group.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Using webhooks and slash commands</h1></div></div></div><p>Now that we <a class="indexterm" id="id292"/>have a firm grasp on what webhooks and slash commands are, we should establish when to use them. First, we should consider when we'd use a webhook or slash command over a bot user, which we've learnt to build in previous chapters.</p><p>A bot user generally operates on a one-to-one basis; every bot requires a Slack token unique to that bot, meaning that the bot can only interact with the team associated with that token. This also allows the bot to maintain a real-time messaging connection with Slack and to reconnect in case of connection failure. Webhooks and slash commands, on the other hand, exist as external services and can be reused by many teams. By removing the need for a Slack token, you open up your app to be used by many other teams.</p><p>Use this flowchart to <a class="indexterm" id="id293"/>decide whether a webhook or a slash <a class="indexterm" id="id294"/>command is best for your needs:</p><div><img alt="Using webhooks and slash commands" src="img/B05384_06_21.jpg"/><div><p>When to use webhooks or slash commands</p></div></div><p>In the preceding diagram, we mention the concepts of <strong>active</strong> and <strong>reactive</strong>. We covered these concepts back in <a class="link" href="ch03.html" title="Chapter 3. Adding Complexity">Chapter 3</a>, <em>Adding Complexity</em>, but the basic gist is that active apps and bots post <a class="indexterm" id="id295"/>messages without requiring input, whereas <a class="indexterm" id="id296"/>reactive bots respond to stimuli in the form of user input.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we saw what webhooks are and how to set them up to send data out of Slack and get data into Slack through a third-party server. We also discussed slash commands and how to implement them.</p><p>In the next chapter, we will cover how to publish your app so that other teams can make use of your bots, webhooks, and slash commands.</p></div></body></html>