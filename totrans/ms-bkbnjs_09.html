<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Deploying to Production"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Deploying to Production</h1></div></div></div><p>You have built a great project: it is modularized, has tests, has been automatized to do common tasks, and finally you have built a production version with Gulp; however, now how do you deploy to a production server?</p><p>This chapter examines what to do with the production version of your project. Here, you will see how to run your node server and frontend assets in a production environment.</p><p>There are many choices to run your project in production mode; you can deploy on a bare metal server, use a virtual machine, on a shared host such as DigitalOcean or RackSpace, or maybe just <a id="id373" class="indexterm"/>deploy it to a <span class="strong"><strong>PaaS</strong></span> (<span class="strong"><strong>Platform as a service</strong></span>) service such as Heroku.</p><p>In the following section, we will see how to deploy to an Heroku instance, this is the easiest way to make a deployment as you don't have to worry about the server details and you can manage all the configurations in a single configuration file.</p><p>If you already have your own infrastructure or simply prefer to work with server instances such as DigitalOcean or RackSpace virtual server, we will show you how to configure a production environment on a server, where you have access to a shell.</p><div class="section" title="Heroku"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Heroku</h1></div></div></div><p>Heroku is a PaaS, which means that you don't have to worry about the details of the server configuration where you are deploying your code, you only focus on your code; Heroku will do the <a id="id374" class="indexterm"/>difficult job with the infrastructure configuration.</p><p>Instead of using a shell to install, configure, and tune up your packages in order to run in production mode, you only have to edit a configuration file and publish your changes with the standard<a id="id375" class="indexterm"/> <code class="literal">git push</code> command.</p><div class="section" title="Dynos"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec51"/>Dynos</h2></div></div></div><p>Heroku uses lightweight Linux containers that run a single command in order to run your projects in the Heroku<a id="id376" class="indexterm"/> platform. Heroku calls these containers Dynos. A Dyno can host your code and run it as a single process in an isolated Linux environment.</p><p>If you don't have an<a id="id377" class="indexterm"/> experience in Linux containers such as Docker, you can imagine a container to be like a small virtual machine without hardware emulation; a Linux container uses the same kernel as the host machine, it means that you don't need to emulate hardware:</p><div class="mediaobject"><img src="graphics/B01962_09_01.jpg" alt="Dynos"/><div class="caption"><p>Figure 9.1 Difference between virtualization and containers</p></div></div><p>By default, Heroku will use Celadon Cedar stack to build Dynos; and Celadon Cedar stack is based on the Ubuntu distribution. With this is mind, you <a id="id378" class="indexterm"/>will get an Ubuntu-like distribution, where you<a id="id379" class="indexterm"/> can run your code written on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ruby on Rails</li><li class="listitem" style="list-style-type: disc">Node.js</li><li class="listitem" style="list-style-type: disc">Java or Spring</li><li class="listitem" style="list-style-type: disc">Python or Django</li><li class="listitem" style="list-style-type: disc">Clojure</li><li class="listitem" style="list-style-type: disc">Scala or Play</li><li class="listitem" style="list-style-type: disc">PHP</li><li class="listitem" style="list-style-type: disc">Go</li></ul></div><p>Dyno comes in three different types, as shown in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Web Dynos</strong></span>: They are<a id="id380" class="indexterm"/> used to run the server code and respond to HTTP requests.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Worker Dynos</strong></span>: They are<a id="id381" class="indexterm"/> useful for background jobs such as image processor.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One-off Dynos</strong></span>: Their purpose<a id="id382" class="indexterm"/> is to provide maintenance to the other two Dyno types.</li></ul></div><p>As you may have guessed that in this book, we will only use the Web Dynos with Node.js to run our <code class="literal">Contacts app</code>.</p></div><div class="section" title="Getting started with Heroku"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec52"/>Getting started with Heroku</h2></div></div></div><p>The first thing to <a id="id383" class="indexterm"/>do in order to start working with Heroku is to register with the service, as follows:</p><div class="mediaobject"><img src="graphics/B01962_09_02.jpg" alt="Getting started with Heroku"/><div class="caption"><p>Figure 9.2 Heroku registration form</p></div></div><p>Once you are registered in the platform, you will need to install the Heroku Toolbelt in your host; there are versions available for Linux, Mac OS X, and Windows. After the installation<a id="id384" class="indexterm"/> process, you can use the <code class="literal">heroku</code> command to authenticate the service:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$heroku login</strong></span>
<span class="strong"><strong>Enter your Heroku credentials.</strong></span>
<span class="strong"><strong>Email: your.email@example.com</strong></span>
<span class="strong"><strong>Password (typing will be hidden):</strong></span>
<span class="strong"><strong>Authentication successful.</strong></span>
</pre></div><p>After you have authenticated with the Heroku service, you can start creating Dynos using the create command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ heroku create</strong></span>
<span class="strong"><strong>Creating enigmatic-anchorage-3587... done, stack is cedar-14</strong></span>
<span class="strong"><strong>https://enigmatic-anchorage-3587.herokuapp.com/ | https://git.heroku.com/enigmatic-anchorage-3587.git</strong></span>
<span class="strong"><strong>Git remote heroku added</strong></span>
</pre></div><p>When you create a <a id="id385" class="indexterm"/>new Dyno on Heroku, it generates a random name for your Dyno. In the preceding example, the name is <code class="literal">enigmatic-anchorage-3587</code> and you can access to<a id="id386" class="indexterm"/> your Dyno at <a class="ulink" href="https://enigmatic-anchorage-3587.herokuapp.com">https://enigmatic-anchorage-3587.herokuapp.com</a>:</p><div class="mediaobject"><img src="graphics/B01962_09_03.jpg" alt="Getting started with Heroku"/><div class="caption"><p>Figure 9.3 Dyno default output</p></div></div><p>You can deploy<a id="id387" class="indexterm"/> your application by pushing your changes to the Git server located at <a class="ulink" href="https://git.heroku.com/enigmatic-anchorage-3587.git">https://git.heroku.com/enigmatic-anchorage-3587.git</a>. You will need to add this address as a remote server in your repo:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git remote add heroku https://git.heroku.com/enigmatic-anchorage-3587.git</strong></span>
</pre></div><p>If you make a push right now, the deployment will not work and that's because you need to tell Heroku how to run your project; this is done with a configuration file named <code class="literal">Procfile</code> that you should put in the application root:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>web: node server/index.js</strong></span>
</pre></div><p>The code is very simple, run the <code class="literal">server/index.js</code> script. You can test whether the configuration is working with the <code class="literal">local</code> command; this command is very useful in order to find bugs or issues before making a real deployment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ heroku local</strong></span>
<span class="strong"><strong>Installing Heroku Toolbelt v4... done</strong></span>
<span class="strong"><strong>Setting up iojs-v3.2.0... done</strong></span>
<span class="strong"><strong>Installing core plugins heroku-apps, heroku-fork, heroku-git, heroku-local, heroku-run, heroku-status... done</strong></span>
<span class="strong"><strong>Downloading forego-0.16.1 to /Users/abiee/.heroku... done</strong></span>
<span class="strong"><strong>forego | starting web.1 on port 5000</strong></span>
<span class="strong"><strong>web.1  | Server running</strong></span>

<span class="strong"><strong>You can access the server using the browser at the http://localhost:8000/ URL. If you don't get any issues, you can make a real deployment by pushing the code at the master branch:</strong></span>
<span class="strong"><strong>$ git checkout master</strong></span>
<span class="strong"><strong>$ gulp build</strong></span>
<span class="strong"><strong>$ git add .</strong></span>
<span class="strong"><strong>$ git commit "Deployment build"</strong></span>
<span class="strong"><strong>$ git push heroku master</strong></span>
<span class="strong"><strong>Counting objects: 63, done.</strong></span>
<span class="strong"><strong>Delta compression using up to 8 threads.</strong></span>
<span class="strong"><strong>Compressing objects: 100% (57/57), done.</strong></span>
<span class="strong"><strong>Writing objects: 100% (63/63), 380.85 KiB | 0 bytes/s, done.</strong></span>
<span class="strong"><strong>Total 63 (delta 3), reused 0 (delta 0)</strong></span>
<span class="strong"><strong>remote: Compressing source files... done.</strong></span>
<span class="strong"><strong>remote: Building source:</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Node.js app detected</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Creating runtime environment</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote:        NPM_CONFIG_LOGLEVEL=error</strong></span>
<span class="strong"><strong>remote:        NPM_CONFIG_PRODUCTION=true</strong></span>
<span class="strong"><strong>remote:        NODE_ENV=production</strong></span>
<span class="strong"><strong>remote:        NODE_MODULES_CACHE=true</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Installing binaries</strong></span>
<span class="strong"><strong>remote:        engines.node (package.json):  unspecified</strong></span>
<span class="strong"><strong>remote:        engines.npm (package.json):   unspecified (use default)</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote:        Resolving node version (latest stable) via semver.io...</strong></span>
<span class="strong"><strong>remote:        Downloading and installing node 0.12.7...</strong></span>
<span class="strong"><strong>remote:        Using default npm version: 2.11.3</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Restoring cache</strong></span>
<span class="strong"><strong>remote:        Skipping cache (new runtime signature)</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Building dependencies</strong></span>
<span class="strong"><strong>remote:        Pruning any extraneous modules</strong></span>
<span class="strong"><strong>remote:        Installing node modules (package.json)</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>remote: -----&gt; Caching build</strong></span>
<span class="strong"><strong>remote:        Clearing previous node cache</strong></span>
<span class="strong"><strong>remote:        Saving 1 cacheDirectories (default):</strong></span>
<span class="strong"><strong>remote:        - node_modules</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Build succeeded!</strong></span>
<span class="strong"><strong>remote:        ├── backbone@1.2.2</strong></span>
<span class="strong"><strong>remote:        ├── body-parser@1.13.3</strong></span>
<span class="strong"><strong>remote:        ├── browser-sync@2.8.2</strong></span>
<span class="strong"><strong>remote:        ├── express@4.13.3</strong></span>
<span class="strong"><strong>remote:        ├── http@0.0.0</strong></span>
<span class="strong"><strong>remote:        ├── http-proxy@1.11.2</strong></span>
<span class="strong"><strong>remote:        ├── jquery@2.1.4</strong></span>
<span class="strong"><strong>remote:        ├── lodash@3.10.1</strong></span>
<span class="strong"><strong>remote:        ├── morgan@1.6.1</strong></span>
<span class="strong"><strong>remote:        ├── multer@1.0.3</strong></span>
<span class="strong"><strong>remote:        └── underscore@1.8.3</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Discovering process types</strong></span>
<span class="strong"><strong>remote:        Procfile declares types -&gt; web</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: -----&gt; Compressing... done, 25.4MB</strong></span>
<span class="strong"><strong>remote: -----&gt; Launching... done, v3</strong></span>
<span class="strong"><strong>remote:        https://enigmatic-anchorage-3587.herokuapp.com/ deployed to Heroku</strong></span>
<span class="strong"><strong>remote:</strong></span>
<span class="strong"><strong>remote: Verifying deploy.... done.</strong></span>
<span class="strong"><strong>To https://git.heroku.com/enigmatic-anchorage-3587.git</strong></span>
</pre></div><p>In the output logs, you<a id="id388" class="indexterm"/> can see what Heroku is doing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Heroku detects what kind of project it is in order to know how to build the right environment. It could detect that it is a <code class="literal">Node</code> project due the presence of the <code class="literal">package.json</code> file.</li><li class="listitem" style="list-style-type: disc">Knowing that it is a Node project, it could set some useful environment variables in order to run the project in production mode. You can use the <code class="literal">NODE_ENV</code> environment variable in your code in order to use some special configuration for production environments.</li><li class="listitem" style="list-style-type: disc">Then, read<a id="id389" class="indexterm"/> the <code class="literal">package.json </code>file to see what version of node to install. You can specify a node version to install with the engines configuration, as follows:<div class="informalexample"><pre class="programlisting">"engines": {
  "node": "^0.12.21"
},</pre></div></li><li class="listitem" style="list-style-type: disc">After the right node version is installed in the Dyno, Heroku will install the project dependencies that are specified in the <code class="literal">package.json</code> file.</li><li class="listitem" style="list-style-type: disc">Then, it will look up for the configuration for the kind of Dyno that is launched and see how to run the project at <code class="literal">Procfile</code>.</li><li class="listitem" style="list-style-type: disc">Finally, it will compress the build and launche the project.</li></ul></div><p>Once the project is<a id="id390" class="indexterm"/> running in the Heroku infrastructure, you can see the result at <a class="ulink" href="https://enigmatic-anchorage-3587.herokuapp.com/">https://enigmatic-anchorage-3587.herokuapp.com/</a>:</p><div class="mediaobject"><img src="graphics/B01962_09_04.jpg" alt="Getting started with Heroku"/><div class="caption"><p>Figure 9.4 Application deployed on Heroku</p></div></div><p>As you can see, deploying to Heroku infrastructure is very straightforward, you don't have to worry about the server details such as the HTTP server or the process management so that you can focus on your application development and forget about the infrastructure.</p><p>If you have any<a id="id391" class="indexterm"/> issues with your application in production, you can see what's happening with the <code class="literal">logs</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ heroku logs –tail</strong></span>
</pre></div><p>This will show the last log messages in the Heroku server. Please consult the online documentation of the service for more details; here you can find information about how to scale your application, connect Dyno instances to databases, and so on.</p></div></div></div>
<div class="section" title="Production environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Production environment</h1></div></div></div><p>If you have a bare metal server or want to work with virtual servers, such as DigitalOcean or Rackspace, you can<a id="id392" class="indexterm"/> create your own production environment. In this section, you will see how to make it possible.</p><p>It doesn't matter what the case is as the way you configure a production environment on these kind of servers are the same. However, keep in mind that the production environment that you will see here is for simple web applications.</p><p>If you have an application with high traffic, you can start from here; however, the server architecture should have a sophisticated organization. The details on how to scale your deployments are out of the scope of this book.</p><p>For the server, I will use the Ubuntu server as it is the easiest and the most popular choice to deploy application. If you are familiar with other distributions such as CentOS, you can use it; however, the instructions are not the same.</p><p>The following diagram shows you a typical configuration for a <span class="strong"><strong>Node</strong></span> server in the production environment:</p><div class="mediaobject"><img src="graphics/B01962_09_05.jpg" alt="Production environment"/><div class="caption"><p>Figure 9.5 Deployment diagram</p></div></div><p>As Node was not built to be a full-featured and robust web server, you should put an HTTP server in front to answer the client requests instead of using Node directly. The HTTP server will forward the request to the Node process and return the response from the Node server to<a id="id393" class="indexterm"/> the user.</p><p>In the preceding diagram, you can see that we are using a <span class="strong"><strong>Process Manager</strong></span>, its work is to keep the Node process up and alive; if the Node process crashes for some reason, <span class="strong"><strong>PM2</strong></span> will take care of it and restart the process.</p><p>Also, you can monitor the memory and processor that your application is consuming in real time, manually restart and stop processes, check logs, and so on. Finally, the access to the database is made from the <span class="strong"><strong>Node</strong></span> server.</p><p>When a user makes a request from its browser, the server will process the request as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The client sends a request to the server host</li><li class="listitem" style="list-style-type: disc">An HTTP server takes the request</li><li class="listitem" style="list-style-type: disc">The HTTP server forwards the request to the Node server</li><li class="listitem" style="list-style-type: disc">The Node process makes its internal process of the request</li><li class="listitem" style="list-style-type: disc">The Node process returns an answer to the HTTP server</li><li class="listitem" style="list-style-type: disc">The HTTP server forwards the answer to the client</li><li class="listitem" style="list-style-type: disc">The client receives the request</li></ul></div><p>In the following sections, we will explore how to install and configure all the components in order to have a<a id="id394" class="indexterm"/> Node application running. We will use an <span class="strong"><strong>Ubuntu-14.04</strong></span> box to <a id="id395" class="indexterm"/>perform the installation process. If you have a different environment, the configuration content should still work; however, the instructions to install and the location of the configuration files may be different.</p></div>
<div class="section" title="The HTTP Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>The HTTP Server</h1></div></div></div><p>The HTTP server handles<a id="id396" class="indexterm"/> the connections with the client and forwards all the requests to the Node server. In some way, it is a kind of proxy. Currently, there are two main HTTP servers on the market that were used widely in production: Apache and Nginx, both can be used to server Node applications. However, in this book, we will cover Nginx. The main reason for this decision is its simplicity and performance and it is smaller than Apache.</p><p>To install Nginx, use <code class="literal">apt-get</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install nginx</strong></span>
<span class="strong"><strong>[sudo] password for abiee:</strong></span>
<span class="strong"><strong>Reading package lists... Done</strong></span>
<span class="strong"><strong>Building dependency tree</strong></span>
<span class="strong"><strong>Reading state information... Done</strong></span>
<span class="strong"><strong>The following extra packages will be installed:</strong></span>
<span class="strong"><strong>  nginx-common nginx-core</strong></span>
<span class="strong"><strong>Suggested packages:</strong></span>
<span class="strong"><strong>  fcgiwrap nginx-doc</strong></span>
<span class="strong"><strong>The following NEW packages will be installed:</strong></span>
<span class="strong"><strong>  nginx nginx-common nginx-core</strong></span>
<span class="strong"><strong>0 upgraded, 3 newly installed, 0 to remove and 30 not upgraded.</strong></span>
<span class="strong"><strong>Need to get 348 kB of archives.</strong></span>
<span class="strong"><strong>After this operation, 1297 kB of additional disk space will be used.</strong></span>
<span class="strong"><strong>Do you want to continue? [Y/n] Y</strong></span>
</pre></div><p>After the Nginx server is installed, Ubuntu will start the server automatically; however, you can manage the server daemon with the service command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#Start the nginx server</strong></span>
<span class="strong"><strong>$ sudo service nginx start</strong></span>
<span class="strong"><strong>#Stop the nginx server</strong></span>
<span class="strong"><strong>$ sudo service nginx stop</strong></span>
<span class="strong"><strong>#Restart the nginx server</strong></span>
<span class="strong"><strong>$ sudo service nginx restart</strong></span>
</pre></div><p>You can check <a id="id397" class="indexterm"/>whether the server is running by pointing your browser to the server IP, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B01962_09_06.jpg" alt="The HTTP Server"/><div class="caption"><p>Figure 9.6 Nginx fresh installation</p></div></div><p>The Nginx configuration files are located at <code class="literal">/etc/nginx</code>, in this path are two more paths, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>sites-available</strong></span>: Each file is a configuration of a single host (subdomain). Note that these files are not active until they are not in sites-enabled.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>sites-enabled</strong></span>: While the sites-available has a set of configuration files, the sites-enabled are a set of sites that are actually active.</li></ul></div><p>To create a new site, you need to create a new configuration file in the sites-available path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo editor /etc/nginx/sites-available/webapp</strong></span>
</pre></div><p>The configuration content is shown in the following:</p><div class="informalexample"><pre class="programlisting">upstream webapp {
  server 127.0.0.1:8000;
}

server {
  listen 80 default_server;

  # Configure logs
  access_log /var/log/nginx/webapp.access.log;
  error_log /var/log/nginx/webapp.error.log;

  # Make site accessible from http://www.example.com/
# server_name localhost;
  server_name www.example.com;

  location / {
    # Proxy headers
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarder-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_set_header X-NginX-Proxy true;

    # Proxy to Nodejs
    proxy_pass http://webapp;
    proxy_redirect off;
  }
}</pre></div><p>The upstream module <a id="id398" class="indexterm"/>of Nginx defines a server or a group of servers that can be referenced as <code class="literal">proxy_pass</code>, what it means is that the target to hit when a request is incoming at Nginx. Server configuration creates a new virtual host listening for requests to the <code class="literal">server_name</code> address. In this case, it is listening for <code class="literal">www.example.com</code>.</p><p>In the <code class="literal">location</code> block, it describes how to handle the requests; in the previous example, it will forward the request to the <code class="literal">webapp</code> upstream, which points to <code class="literal">127.0.0.1:8000</code>. To activate the site, you need to link the contents of this file to the <code class="literal">sites-enabled</code> path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo ln -s /etc/nginx/sites-available/webapp /etc/nginx/sites-enabled/</strong></span>
</pre></div><p>Maybe you will need to delete the previous default-enabled site:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rm /etc/nginx/sites-enabled/default</strong></span>
</pre></div><p>Then restart the <a id="id399" class="indexterm"/>Nginx server in order to load the new configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo service nginx restart</strong></span>
</pre></div><p>If everything is OK, the server will be up:</p><div class="mediaobject"><img src="graphics/B01962_09_07.jpg" alt="The HTTP Server"/><div class="caption"><p>Figure 9.7 Nginx running without node.js working</p></div></div><p>The preceding image shows a <code class="literal">502</code> error, that's because the Nginx server is pointing to the <code class="literal">proxy_pass</code> setting that has the <code class="literal">127.0.0.1:8000</code> address; however, nothing is running on that socket. You need to have something listening for requests on the <code class="literal">127.0.0.1:8000</code> socket, therefore, you should run the project in the same host and the <code class="literal">502</code> error will go away:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --production</strong></span>
<span class="strong"><strong>$ nodejs app.js</strong></span>
</pre></div><p>This should be enough to make the server work. However, we don't want to run the <code class="literal">app.js</code> script manually each time, there is a better way to launch the node process automatically.</p></div>
<div class="section" title="Do not run as root"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Do not run as root</h1></div></div></div><p>Running the server process as root can be dangerous. If someone discovers a vulnerability in node <a id="id400" class="indexterm"/>or in your application code, then they can cause serious damage to the system. It's always a good idea to create a user to run the application server only:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo useradd -m production</strong></span>
</pre></div><p>The <code class="literal">m</code> option will create a home path located at <code class="literal">/home/production</code>, where you can clone the project repo:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo su - production</strong></span>
<span class="strong"><strong>$ cd ~</strong></span>
<span class="strong"><strong>$ git clone https://example.com/path/to/the/project.git</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/B01962_09_07.jpg" alt="Do not run as root"/><div class="caption"><p>Figure 9.7 After running node.js process</p></div></div></div>
<div class="section" title="Process Management"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Process Management</h1></div></div></div><p>Anytime you run a <a id="id401" class="indexterm"/>program in your computer, it can fail for many reasons: maybe a<a id="id402" class="indexterm"/> server that it depends on is turned off or, even worst, an unhandled exception can tear down the running process. That's terrible for production applications as you leave your users without the server until you notice that it is not working.</p><p>This is where the process manager comes in, you can run your code behind a process manager and it will ensure that the process is always running. If something fails and crashes the program, the process manager will reset the entire application automatically.</p><p>There are two <a id="id403" class="indexterm"/>popular process managers for Node: <code class="literal">forever</code> and <code class="literal">pm2</code>, both work in a similar way; however, <code class="literal">pm2</code> seems to be more popular and provides more utility tools than ever. For this reason, we will use <code class="literal">pm2</code> for the stack.</p><p>Ubuntu comes with an integrated process manager known as Upstart. You can use the operative system process manager; however, <code class="literal">pm2</code> is focused on node applications, it allows you to run more than an instance of your process instead of running a single process.</p><p>You can install <code class="literal">pm2</code> with<a id="id404" class="indexterm"/> the <code class="literal">npm</code> tool, do not forget to install it as global package:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install -g pm2</strong></span>
</pre></div><p>After the installation is complete, you can run your process behind <code class="literal">pm2</code> with the <code class="literal">start</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 start app.js</strong></span>
<span class="strong"><strong>[PM2] Starting app in fork_mode (1 instance)</strong></span>
<span class="strong"><strong>[PM2] Done.</strong></span>
<span class="strong"><strong>┌──────────┬────┬──────┬───────┬────────┬─────────┬────────┬─────────────┬──────────┐</strong></span>
<span class="strong"><strong>│ App name │ id │ mode │ pid   │ status │ restart │ uptime │ memory      │ watching │</strong></span>
<span class="strong"><strong>├──────────┼────┼──────┼───────┼────────┼─────────┼────────┼─────────────┼──────────┤</strong></span>
<span class="strong"><strong>│ app      │ 0  │ fork │ 16427 │ online │ 0       │ 0s     │ 15.801 MB   │ disabled │</strong></span>
<span class="strong"><strong>└──────────┴────┴──────┴───────┴────────┴─────────┴────────┴─────────────┴──────────┘</strong></span>
<span class="strong"><strong> Use `pm2 show &lt;id|name&gt;` to get more details about an app</strong></span>
</pre></div><p>After you do this, the script is running and you can see the output of the process with the logs command and the application ID:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 logs 0</strong></span>
<span class="strong"><strong>[PM2] Tailing last 20 lines for [0] process</strong></span>

<span class="strong"><strong>app-0 (out): Server running</strong></span>
<span class="strong"><strong>app-0 (out): GET / 200 5.911 ms - 8908</strong></span>
<span class="strong"><strong>app-0 (out): GET /css/vendor.css 200 2.740 ms - 131</strong></span>
<span class="strong"><strong>app-0 (out): GET /js/app.js 200 3.821 ms - 396191</strong></span>
<span class="strong"><strong>app-0 (out): GET /api/contacts 200 2.528 ms - 55</strong></span>

<span class="strong"><strong>[PM2] Streaming realtime logs for [0] process</strong></span>
</pre></div><p>Instead of using the raw ID<a id="id405" class="indexterm"/> of the process, you can name your running processes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 start app.js --name app</strong></span>
</pre></div><p>You can also<a id="id406" class="indexterm"/> run more than one instance so that you can have two running instances of the same application and <code class="literal">pm2</code> will load and balance requests between them:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 start app.js --name app –i 2</strong></span>
</pre></div><p>It's a good idea to run more than one instance of a Node server as the Node blocks is making I/O operations. If you run more than one instance, then the other processes can continue serving the incoming requests while the other is blocked.</p><p>You can save the application parameters in a JSON file and use it instead of putting all the options in the command line:</p><div class="informalexample"><pre class="programlisting">{
  "apps": [{
    "name": "contacts-app",
    "script": "/path/to/the/application/app.js",
    "cwd": "/path/to/the/application",
    "watch": false,
    "instances": 2,
    "error_file": "/path/to/your/home/contacts-app/app-err.log",
    "out_file": "/path/to/your/home/app-out.log",
    "pid_file": "//path/to/your/home/app.pid"
    "env": {
      "NODE_ENV": "production"
    }
  }]
}</pre></div><p>With the JSON file, you have the advantage that you don't have to remember how to run the application as the file contains all the required configurations and the same environment is easily reproducible on different hosts.</p><p>If you are fine with your <a id="id407" class="indexterm"/>settings and everything is working as you expected, the next step is to persist the <code class="literal">pm2</code> process to run it as daemon each time that the server is restarted; this is always a good idea as if the server restarts for some reason such as maintenance, your processes will spawn automatically.</p><p>Fortunately, <code class="literal">pm2</code> provides <a id="id408" class="indexterm"/>an easy way to daemonize your configuration with the <code class="literal">startup</code> command for many operative systems, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 startup -h</strong></span>

<span class="strong"><strong>  Usage: startup [options] [platform]</strong></span>

<span class="strong"><strong>  auto resurrect process at startup. [platform] = ubuntu, centos, redhat, gentoo, systemd, darwin, amazon</strong></span>
<span class="strong"><strong>$ sudo env PATH=$PATH:/usr/local/bin pm2 startup ubuntu -u production</strong></span>
<span class="strong"><strong>[PM2] Generating system init script in /etc/init.d/pm2-init.sh</strong></span>
<span class="strong"><strong>[PM2] Making script booting at startup...</strong></span>
<span class="strong"><strong>[PM2] -ubuntu- Using the command:</strong></span>
<span class="strong"><strong>      su -c "chmod +x /etc/init.d/pm2-init.sh &amp;&amp; update-rc.d pm2-init.sh defaults"</strong></span>
<span class="strong"><strong> System start/stop links for /etc/init.d/pm2-init.sh already exist.</strong></span>
<span class="strong"><strong>[PM2] Done.</strong></span>
</pre></div><p>The first command shows the available operative systems. As the <code class="literal">startup</code> command writes on the <code class="literal">/etc/</code> path, we need to run this command as the root user and that's the reason why we are using sudo command.</p><p>To run the daemon, you need to run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ service pm2-init.sh start</strong></span>
</pre></div><p>However, before running this command, you will need to dump your current configuration in the daemon configuration and if you skip this step, the service will not start any process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pm2 start process.json</strong></span>
<span class="strong"><strong>$ pm2 save</strong></span>
<span class="strong"><strong>[PM2] Dumping processes</strong></span>
</pre></div><p>With this command, the current configuration of <code class="literal">pm2</code> will be used every time the server restarts or you manually restart the service.</p><p>That's how you can run your node application in a production environment; run a real HTTP server and run<a id="id409" class="indexterm"/> your node processes behind it with the help of a process manager such as <code class="literal">pm2</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we saw how to run a Node application in the Heroku platform and in a bare metal or virtual machine server with Linux. These two methods to deploy Node applications are simple; however, they are the base for more complex deployments. You can make deployments on Docker containers, for instance. With Docker, you will need to know how to install your application in a fresh Linux installation as we did, and then, manage containers as a process like Heroku does.</p><p>In this chapter, we don't see many things related to Backbone; however, if you have a Backbone application and it is backed by Node, you probably want to put your code in production. In this chapter, we have seen how to put the output of the distribution files in a production server.</p></div></body></html>