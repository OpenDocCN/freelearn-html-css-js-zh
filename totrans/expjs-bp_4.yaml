- en: Chapter 4. MMO Word Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 MMO单词游戏
- en: Word Chain Game is a real-time, massive multiplayer online game. Each player
    will be able to see the other online players when playing the game, along with
    a score leaderboard for score. In this chapter we will introduce the Promise pattern
    and explain how Promises simplify asynchronous operations. You will learn how
    to build a real-time application with Express and SocketIO, perform authentication
    over socket handshaking, and deal with race conditions using the atomic update
    of MongoDB. You will also learn how to build the game client to connect to the
    game server over socket, and how to debug WebSocket on the client side using Chrome
    Developer Tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单词链游戏是一个实时、大规模多人在线游戏。在玩游戏时，每位玩家都将能够看到其他在线玩家，以及一个分数排行榜。在本章中，我们将介绍Promise模式，并解释Promises如何简化异步操作。你将学习如何使用Express和SocketIO构建实时应用程序，在套接字握手期间进行身份验证，以及如何使用MongoDB的原子更新处理竞争条件。你还将学习如何构建游戏客户端以通过套接字连接到游戏服务器，以及如何使用Chrome开发者工具在客户端上调试WebSocket。
- en: Once you have mastered this, you can build similar games such as online quiz
    competitions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这个技巧，你就可以构建类似在线问答比赛的游戏。
- en: Gameplay
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: The game starts with a randomly selected English word and each player tries
    to submit a word where the first character of their submission matches the last
    character of the current word; we call this chaining with the current word. For
    example, if the game starts with the word `Today`, then players can send words
    such as `Yes` or `Yellow`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从随机选择的英语单词开始，每位玩家都尝试提交一个单词，其中提交的第一个字母与当前单词的最后一个字母匹配；我们称这为与当前单词的链式连接。例如，如果游戏从单词`Today`开始，那么玩家可以发送单词如`Yes`或`Yellow`。
- en: The first person to submit a valid word will have their word become the starting
    word for the next round and gets the points for that round. Once the new word
    is accepted, the server will broadcast the change to all online players. The players
    will see the new word and submit another word to chain with it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首位提交有效单词的人，其单词将成为下一轮的起始单词，并获得该轮的分数。一旦新单词被接受，服务器将向所有在线玩家广播这一变化。玩家将看到新单词，并提交另一个单词与它相连。
- en: For example, if player 1 sends `Yes` to chain with `Today`, the server will
    accept the word and broadcast the current word `Yes` to all other players. If
    a player submits a word that is invalid based on the dictionary we have or was
    submitted by another player earlier, the game server will ignore that request.
    If multiple players submit valid words simultaneously, the server will only accept
    the first submitted word.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果玩家1发送`Yes`来与`Today`相连，服务器将接受这个单词并将当前单词`Yes`广播给所有其他玩家。如果玩家提交的单词根据我们拥有的字典无效，或者之前已被其他玩家提交，游戏服务器将忽略该请求。如果多个玩家同时提交有效单词，服务器将只接受第一个提交的单词。
- en: '![Gameplay](img/0818_04_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![游戏玩法](img/0818_04_01.jpg)'
- en: Real-time application overview
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时应用程序概述
- en: In this game, we will introduce the Promise pattern and explain how Promise
    will simplify async operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将介绍Promise模式，并解释Promise如何简化异步操作。
- en: Despite this being a real-time game, we will not rush into implementing a real-time
    feature at the beginning. Instead, we will first build a game model, which contains
    all the game logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个实时游戏，但我们不会一开始就急于实现实时功能。相反，我们首先构建一个游戏模型，其中包含所有游戏逻辑。
- en: In the game logic, we first introduce how to keep track of active users and
    then explain how we verify users' input. After verifying the input, during the
    updating game state phase, we deal with race conditions by utilizing the atomic
    operation of MongoDB. We also look into how to cover the race conditions with
    test cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏逻辑中，我们首先介绍如何跟踪活跃用户，然后解释我们如何验证用户的输入。在更新游戏状态阶段，我们通过利用MongoDB的原子操作来处理竞争条件。我们还探讨了如何通过测试用例来覆盖竞争条件。
- en: After the game logic is done, we will introduce how to broadcast game state
    changes to all players using Socket.IO.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑完成后，我们将介绍如何使用Socket.IO向所有玩家广播游戏状态变化。
- en: In the end, we will create an Express app, a Socket.IO server, and a game client
    that can talk to our server using the `socket.io-client` libraries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个Express应用、一个Socket.IO服务器和一个游戏客户端，该客户端可以使用`socket.io-client`库与我们的服务器通信。
- en: Keeping track of active users
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪活跃用户
- en: Since the game is a multiplayer game, players can see the number of players
    and their usernames. To keep track of active users, we need to track when a player
    joins the game and when a player leaves the game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏是多人游戏，玩家可以看到玩家的数量和他们的用户名。为了跟踪活跃用户，我们需要跟踪玩家何时加入游戏以及何时离开游戏。
- en: Schema design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式设计
- en: 'Each player can simply be represented by a document with a single field for
    the name:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个玩家可以简单地用一个包含单个名称字段的文档来表示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: User schema
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户模式
- en: 'We will use Mongoose for our data modeling. Let''s start with designing our
    user schema. The schemas are placed in the `models` folder in the app. The following
    screenshot shows the folder structure. The schema will have one required field
    `name`, this is done by adding `required: true` to the name object in the schema.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用Mongoose进行数据建模。让我们从设计我们的用户模式开始。模式放在应用中的`models`文件夹中。下面的截图显示了文件夹结构。该模式将有一个必填字段`name`，这是通过在模式中的名称对象中添加`required:
    true`来实现的。'
- en: '![User schema](img/0818_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![用户模式](img/0818_04_02.jpg)'
- en: To make querying a user by name fast, we can add an index to `name`. By default,
    only the `_id` field that MongoDB generates will be indexed. This means, to perform
    a search by name, the database will need to iterate over all the documents in
    the collection to find a matching name. When you add an index to `name`, you can
    query by name as quickly as when you query by `_id`. Now, when a user leaves,
    we can find the user by name directly and remove that user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速通过名称查询用户，我们可以在`name`上添加索引。默认情况下，只有MongoDB生成的`_id`字段会被索引。这意味着，为了通过名称进行搜索，数据库需要遍历集合中的所有文档以找到匹配的名称。当你为`name`添加索引时，你可以像查询`_id`一样快速地通过名称进行查询。现在，当用户离开时，我们可以直接通过名称找到该用户并删除该用户。
- en: 'Also, we add the `unique : true` property to the index to avoid having multiple
    users with the same name, as shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们还在索引中添加了`unique : true`属性，以避免有多个用户拥有相同的名称，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: User join
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户加入
- en: 'When a user joins a game, we create a user with the key `name` and save this
    user to MongoDB, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户加入游戏时，我们创建一个具有`name`键的用户，并将此用户保存到MongoDB中，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `save()` method in the preceding code uses callback patterns, which is also
    known as callback hell. If an error occurs, we make a call to the callback function
    passing the error as a parameter; otherwise, the operation succeeds and it returns
    the updated document.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`save()`方法使用了回调模式，这也被称为回调地狱。如果发生错误，我们调用回调函数并将错误作为参数传递；否则，操作成功并返回更新后的文档。
- en: The preceding callback pattern involves a lot of logic and condition checks.
    The nested callback pattern of JavaScript can quickly turn into a spaghetti nightmare.
    A good alternative is to use Promises to simplify things.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的回调模式涉及大量的逻辑和条件检查。JavaScript的嵌套回调模式可以迅速变成意大利面般的噩梦。一个好的替代方案是使用Promises来简化问题。
- en: Mongoose's `model.create()` method ([http://mongoosejs.com/docs/api.html#model_Model.create](http://mongoosejs.com/docs/api.html#model_Model.create))
    can create and save a new document into the database if valid. Functions and documents
    such as objects and arrays are valid parameters for the `model.create()` method.
    The `create` method returns a Promise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose的`model.create()`方法([http://mongoosejs.com/docs/api.html#model_Model.create](http://mongoosejs.com/docs/api.html#model_Model.create))可以在数据库中创建并保存一个新的文档，如果有效。函数和文档，如对象和数组，是`model.create()`方法的有效参数。`create`方法返回一个Promise。
- en: 'With this Promise, the caller of the `join` method can define the success and
    fail callbacks, simplifying the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个Promise，`join`方法的调用者可以定义成功和失败的回调，从而简化代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Promises
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: 'A Promise is the eventual result of an asynchronous operation, just like giving
    someone a promise. Promises help handle errors, which results in writing cleaner
    code without callbacks. Instead of passing in an additional function that takes
    an error and result as parameters to every function, you can simply call your
    function with its parameter and get a Promise:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Promise是异步操作最终的结果，就像给人一个承诺一样。Promises帮助处理错误，这导致编写没有回调的更干净的代码。你不需要为每个函数传递一个额外的函数，该函数接受错误和结果作为参数，只需简单地调用你的函数并传递其参数即可获得一个Promise：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: versus
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相对的是
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The benefit of using Promises isn't obvious if there is only one async operation.
    If there are many async operations with one depending on another, the callback
    pattern will quickly turn into a deeply nested structure, while Promises can keep
    your code shallow and easier to read.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个异步操作，使用 Promise 的好处并不明显。如果有许多异步操作，其中一个依赖于另一个，回调模式会迅速变成一个深层嵌套的结构，而 Promise
    可以使你的代码更浅显，更容易阅读。
- en: Promises can centralize your error handling and when an exception happens, you
    will get stack traces that reference actual function names instead of anonymous
    ones.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 可以集中处理你的错误，当发生异常时，你会得到引用实际函数名称而不是匿名函数名称的堆栈跟踪。
- en: 'In our word game, you could use Promises to turn this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文字游戏中，你可以使用 Promise 将这个：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'into this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'or even simplier:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至更简单：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To understand the execution flow of the preceding, let''s create a complete
    example that calls the user model''s `join()` method, and then add some log statements
    to see the output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的执行流程，让我们创建一个完整的示例，调用用户模型的 `join()` 方法，然后添加一些日志语句来查看输出：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a user joins the game successfully, the Promise returned by the `User.join()`
    method will be resolved. A newly created user document object will be passed to
    the `onJoinSuccess` callback and the output result will be printed as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功加入游戏，`User.join()` 方法返回的 Promise 将被解决。一个新创建的用户文档对象将被传递给 `onJoinSuccess`
    回调，输出结果如下所示：
- en: '![Promises](img/0818_04_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Promise](img/0818_04_03.jpg)'
- en: If we run this script again, we will see that the user fails to join the game
    and the error is printed. It fails because the user model already has an index
    on name property because a user with the name `leo` was created when we ran the
    script the first time. When we run it again, we can't create another user with
    the same name `leo`, so the Promise fails and the error is passed into `onJoinFail`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行此脚本，我们会看到用户未能加入游戏，错误被打印出来。它失败是因为用户模型已经在名称属性上有一个索引，因为当我们第一次运行脚本时创建了一个名为
    `leo` 的用户。当我们再次运行它时，我们无法创建另一个具有相同名称 `leo` 的用户，因此 Promise 失败，错误传递到 `onJoinFail`。
- en: '![Promises](img/0818_04_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Promise](img/0818_04_04.jpg)'
- en: 'A Promise has three states: pending, fulfilled, or rejected; a Promise''s initial
    state is pending, then it Promises that it will either succeed (fulfilled) or
    fail (rejected). Once it is fulfilled or rejected, it cannot change again. A major
    benefit of this is that you can chain multiple Promises together and define one
    error handler to handle all the errors.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 有三种状态：挂起、已解决或被拒绝；Promise 的初始状态是挂起，然后它承诺它将要么成功（已解决）要么失败（被拒绝）。一旦它被解决或被拒绝，它就不能再改变。这个的主要好处是你可以将多个
    Promise 连接起来，并定义一个错误处理器来处理所有错误。
- en: As the `join()` method returns a Promise, we can define the success and fail
    callbacks as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `join()` 方法返回一个 Promise，我们可以定义成功和失败回调如下。
- en: The then and catch method
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`then` 和 `catch` 方法'
- en: The `then` and `catch` methods are used to define success and fail callbacks;
    you might wonder when they are actually being called. When the `User.create()`
    method is called, it will return a Promise object and at the same time send an
    async query to MongoDB. The success callback, `onJoinSuccess`, is then passed
    into the `then` method and will be called when the async query is successfully
    completed, resolving the Promise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`then` 和 `catch` 方法用于定义成功和失败回调；你可能想知道它们实际上何时被调用。当调用 `User.create()` 方法时，它将返回一个
    Promise 对象，并同时向 MongoDB 发送一个异步查询。成功回调 `onJoinSuccess` 然后被传递到 `then` 方法，并在异步查询成功完成时调用，解决
    Promise。'
- en: Once the Promise is resolved, it can't be resolved again, so `onJoinSuccess`
    won't be called again, it will only be called once at the most.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Promise 被解决，它就不能再次被解决，因此 `onJoinSuccess` 不会再次被调用，最多只会被调用一次。
- en: Chain multiple Promises
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接多个 Promise
- en: 'You can chain Promise operations by calling them on the Promise that is returned
    by the previous `then()` function. We use the `.then()` method when we want to
    do something with the result from the Promise (once *x* resolves, then do *y*)
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在先前的 `then()` 函数返回的 Promise 上调用它们来连接 Promise 操作。当我们想要对 Promise 的结果（一旦 *x*
    解决，然后做 *y*）做些什么时，我们使用 `.then()` 方法，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can centralize the error handling at the end. It''s much easier to deal
    with errors with Promise chains. If we run the code, we will get the following
    result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在最后集中处理错误。使用 Promise 链处理错误要容易得多。如果我们运行代码，我们会得到以下结果：
- en: '![Chain multiple Promises](img/0818_04_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![连接多个 Promise](img/0818_04_05.jpg)'
- en: Now that we've gone through all the logic and error handling of creating a new
    user, let's look into how we will ensure that multiple users with the same name
    can't join.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过了创建新用户的逻辑和错误处理，让我们看看我们将如何确保具有相同名称的多个用户不能加入。
- en: Prevent duplicates
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止重复
- en: 'Earlier, when we defined our user schema, we added `index` with a unique set
    to `true` on the name field:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义用户模式时，我们已经在名称字段上添加了 `index` 并将其唯一集设置为 `true`：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'MongoDB will issue a query to see whether there is another record with the
    same value for the unique property and, if that query comes back empty, it allows
    the save or update to proceed. If another user joins with the same name, Mongo
    throws the error: Duplicate Key Error. This prevents the user from being saved
    and the player must choose another name to join with.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 将发出一个查询以查看是否存在具有相同唯一属性值的另一个记录，如果该查询返回空，则允许保存或更新操作进行。如果另一个用户以相同的名称加入，Mongo
    将抛出错误：重复键错误。这阻止了用户被保存，玩家必须选择另一个名称加入。
- en: To make sure our code works as we want it to, we need to create tests; we will
    create a test case with Mocha. The test case will pass a username to the `User.join`
    method and expect that the username of the newly created user is valid. The `User.join`
    method returns a Promise. If it succeeds, the object returned from the Promise
    will be sent to the `then` method; otherwise it fails and the Promise will `.reject`
    with an error that will be caught by the `catch` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的代码按预期工作，我们需要创建测试；我们将使用 Mocha 创建一个测试用例。测试用例将向 `User.join` 方法传递一个用户名，并期望新创建的用户名是有效的。`User.join`
    方法返回一个 Promise。如果成功，Promise 返回的对象将被发送到 `then` 方法；否则它将失败，Promise 将通过 `.reject`
    方法返回一个错误，该错误将被 `catch` 方法捕获。
- en: In the case of the success callback, we have the newly created user, and we
    can check whether it's correct by expecting `user.name` to return `leo`, since
    `leo` was entered as the username (illustrated in the following code).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功回调的情况下，我们有新创建的用户，我们可以通过期望 `user.name` 返回 `leo` 来检查它是否正确，因为 `leo` 被输入为用户名（如下面的代码所示）。
- en: In the case of fail callback, we can pass the error object to Mocha, `done(error)`,
    to fail the test case. Since we created a user named `leo` for the first time,
    we expect this test to pass. Since Mocha tests are synchronous and Promises are
    async, we need to wait for the function to be done. When the code is successful,
    it will call the `done()` function and report success to Mocha; if it fails, the
    `catch` method will catch the error and return the error to the `done` method,
    which will tell Mocha to fail the test case.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败回调的情况下，我们可以将错误对象传递给 Mocha，`done(error)`，以失败测试用例。由于我们第一次创建了一个名为 `leo` 的用户，我们预计这个测试会通过。由于
    Mocha 测试是同步的，而 Promises 是异步的，我们需要等待函数执行完成。当代码成功时，它将调用 `done()` 函数并向 Mocha 报告成功；如果失败，`catch`
    方法将捕获错误并将错误返回给 `done` 方法，这将告诉 Mocha 测试用例失败。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Version 1.18.0 or above of Mocha allows you to return a Promise in a test case.
    Mocha will fail the test case if the Promise fails without needing to explicitly
    catch the error as given in the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 1.18.0 或更高版本允许你在测试用例中返回一个 Promise。如果 Promise 失败而不需要显式捕获错误，Mocha 将失败测试用例，如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we tested that submitting the first user with a unique name works,
    we want to test what happens when another user with the same name joins:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了提交具有唯一名称的第一个用户可以正常工作，我们想要测试当另一个具有相同名称的用户加入时会发生什么：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we submit `leo` again as a username, the Promise of `Game.join` comes back
    rejected and goes to the `.catch` method. The `return true` turns a failed Promise
    into a success, which tells us that it succeeded in rejecting the second `leo`
    and that we successfully caught the error; we basically swallow the error to tell
    Mocha that this is the correct behavior we expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次提交 `leo` 作为用户名时，`Game.join` 的 Promise 被拒绝并进入 `.catch` 方法。`return true`
    将失败的 Promise 转换为成功，这告诉我们它成功拒绝了第二个 `leo`，并且我们成功捕获了错误；我们基本上吞下了错误，告诉 Mocha 这是我们期望的正确行为。
- en: User leaves the game
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户离开游戏
- en: When a user leaves the game, we need to remove their entry in the database;
    this would also free up their user name so that a new user can take it. Mongoose
    has a `delete` method called `findOneAndRemove`, which can find that player by
    name, and then remove it as shown in the following code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户离开游戏时，我们需要从数据库中删除他们的记录；这也会释放他们的用户名，以便新用户可以取用。Mongoose 有一个名为 `findOneAndRemove`
    的 `delete` 方法，可以通过名称找到该玩家，然后将其删除，如下面的代码所示。
- en: 'For our Promises, we use Bluebird ([https://github.com/petkaantonov/bluebird](https://github.com/petkaantonov/bluebird))
    (spec: PromiseA) because of its better performance, utility, and popularity (support).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Promises，我们使用 Bluebird ([https://github.com/petkaantonov/bluebird](https://github.com/petkaantonov/bluebird))
    (规范：PromiseA)，因为它具有更好的性能、实用性和普及度（支持）。
- en: 'We call the `Promise.resolve` method, which creates a Promise that is resolved
    with the value inside: `Promise.resolve(value)`. Therefore, we can take a method
    that does not normally return a Promise and wrap it with the Bluebird `Promise.resolve`
    method to get a Promise back, which we can then chain with then if it succeeds
    or catch if it fails. Receiving Promises from our methods will ensure that we
    deal with successes and errors efficiently and also lets the callee deal with
    the error when it runs (.exec()).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `Promise.resolve` 方法，该方法创建一个已解析的 Promise，其值为内部值：`Promise.resolve(value)`。因此，我们可以将不通常返回
    Promise 的方法用 Bluebird 的 `Promise.resolve` 方法包装，以获取一个 Promise，然后如果成功则使用 then 链接，如果失败则使用
    catch。从我们的方法接收 Promises 将确保我们高效地处理成功和错误，并允许调用者在其运行时处理错误（.exec()）。
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Show all active users
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示所有活跃用户
- en: So far we demonstrated how to add and remove users, we will now dive into how
    we will display the game data to a user that's joined. To show the total active
    users, we could simply return all users, as offline users have already been removed.
    In order to return an array of just the user names, rather than an array of the
    entire user object, we could use the `Promise.map()` method to convert each user
    object in the array into a user name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经演示了如何添加和删除用户，现在我们将深入了解如何向已加入的用户展示游戏数据。为了显示总活跃用户数，我们可以简单地返回所有用户，因为离线用户已经被移除。为了返回仅包含用户名的数组，而不是整个用户对象的数组，我们可以使用
    `Promise.map()` 方法将数组中的每个用户对象转换为用户名。
- en: Since `User.find` returns an array of users, we use the `Promise.map()`method
    to return the values from the name key. This effectively turns the array of user
    objects into an array of user names. Again, notice that we use the `promise.resolve()`method
    to obtain a Promise from our input. This will allow us to display a list of the
    currently logged in users by their user name.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `User.find` 返回用户数组，我们使用 `Promise.map()` 方法从名称键返回值。这有效地将用户对象数组转换为用户名数组。再次注意，我们使用
    `promise.resolve()` 方法从我们的输入中获取一个 Promise。这将允许我们通过用户名显示当前登录用户列表。
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The words – Subdocuments
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词 - 子文档
- en: We have gone through the game logic involving creating, displaying, and deleting
    users but what about the meat of the game itself—the words?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了涉及创建、显示和删除用户的游戏逻辑，但关于游戏本身的实质——单词呢？
- en: In `app/models/stat.js`, we see how we model our word data. The `word` field
    shows the current word, and the `used` field saves the game's history.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app/models/stat.js` 文件中，我们可以看到我们如何对单词数据进行建模。`word` 字段显示当前单词，而 `used` 字段保存游戏的历史记录。
- en: We embedded the `used` list as subdocuments into the Stat document, so that
    we can update stats atomically. We will explain this later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `used` 列作为子文档嵌入到 Stat 文档中，这样我们就可以原子性地更新统计数据。我们将在稍后解释这一点。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code gives you an overview of what we will store in the database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码概述了我们将存储在数据库中的内容。
- en: We first create a model for our word inputs, new word (word) and used words
    (used), in a similar method to our user's model, by defining a type (string for
    new and array for old). The old words are stored in an array so that they can
    be accessed when we check whether or not a new word has been used before.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为单词输入创建一个模型，新单词（word）和已使用单词（used），与用户模型类似的方法，通过定义类型（新单词为字符串，旧单词为数组）。旧单词存储在数组中，以便在检查新单词是否已被使用之前可以访问。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Further logic about validating word inputs and scoring will be described after
    we create a new game.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新游戏之后，我们将描述有关验证单词输入和计分的进一步逻辑。
- en: 'When we create a new game, we want to make sure that no old game data exists
    and that all values in our database are reset, so we will first remove the existing
    game, and then create a new one, as shown in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新游戏时，我们想确保没有旧游戏数据存在，并且我们数据库中的所有值都被重置，因此我们将首先删除现有的游戏，然后创建一个新的，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we use `Stat.remove()` to remove all old game data
    and when the Promise is fulfilled, we create a new game using `Stat.create()`
    by passing a new word, `'what'`, to start off the new round and also submit both
    the word and the user who submitted the word into the used array. We want to submit
    the user in addition to the word so that other users can see who submitted the
    current word and also use that information to calculate scores.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `Stat.remove()` 删除所有旧的游戏数据，当 Promise 被满足时，我们通过传递一个新单词 `'what'`
    来使用 `Stat.create()` 创建一个新的游戏，以开始新的一轮，并将单词和提交单词的用户提交到 `used` 数组中。我们希望除了单词外还提交用户，这样其他用户可以看到谁提交了当前单词，并利用这些信息来计算分数。
- en: Validate input
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入
- en: We can't just accept any word a user might input; users might enter an invalid
    word (as determined by our internal dictionary), a word that can't chain with
    the current word or a word that has already been used before in this game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能接受用户可能输入的任何单词；用户可能输入一个无效的单词（根据我们的内部词典确定），一个不能与当前单词链式连接的单词，或者一个在此游戏中之前已经使用过的单词。
- en: Our internal dictionary model is found in `models/dictionary.js` and consists
    of the dictionary `json`. Requests with an invalid word should be ignored and
    should not change the game's state (see `app/controllers/game.js`); if the word
    is not in the dictionary, the Promise will be rejected and will not go to `Stat.chain()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内词典模型位于 `models/dictionary.js` 中，由词典 `json` 组成。对于包含无效单词的请求应被忽略，并且不应改变游戏状态（见
    `app/controllers/game.js`）；如果单词不在词典中，Promise 将被拒绝，并且不会进入 `Stat.chain()`。
- en: 'In the following code example, we illustrate how to check whether the submitted
    word chains with the current word:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们说明了如何检查提交的单词是否与当前单词链式连接：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first step is to query the `Stat` collection to get the current game state.
    From the game state, we know the current word that needs to be matched by calling
    `stat.word` and assigning it to the variable `currentWord`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是查询 `Stat` 集合以获取当前游戏状态。从游戏状态中，我们可以通过调用 `stat.word` 并将其分配给变量 `currentWord`
    来知道需要匹配的当前单词。
- en: We then compare the current word with the user's input. First we determine the
    first letter of the submitted word using `calling substr(0, 1)` and then we compare
    it to the last letter of the current word (`currentWord` ) by calling `substr(-1)`.
    If the first character of the user's input doesn't match with the last character
    of the current word of the game, we throw a `400` error. The Promise will catch
    this error, and call the `catch` callback to handle the error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们比较当前单词与用户的输入。首先，我们使用 `calling substr(0, 1)` 确定提交单词的第一个字母，然后通过调用 `substr(-1)`
    将其与当前单词的最后一个字母（`currentWord`）进行比较。如果用户输入的第一个字符与游戏当前单词的最后一个字符不匹配，我们将抛出一个 `400`
    错误。Promise 将捕获这个错误，并调用 `catch` 回调来处理错误。
- en: Here, in the model's method, we let the model object return a `Promise` object.
    Later on, we will introduce how to catch this error in the controller's method
    and return a `400` response to the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型的方法中，我们让模型对象返回一个 `Promise` 对象。稍后，我们将介绍如何在控制器的方法中捕获这个错误，并向用户返回一个 `400` 响应。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Helper.build400Error()` function is a utility function that returns a
    `400` Error with an error message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Helper.build400Error()` 函数是一个实用函数，它返回一个带有错误信息的 `400` 错误：'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the word can chain with the current word, it's a valid request. We will get
    back a successful Promise, which allows us to chain with the next then and save
    the word along with the player's username to the database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单词可以与当前单词链式连接，则这是一个有效的请求。我们将得到一个成功的 Promise，这允许我们使用下一个 `then` 链式连接并将单词以及玩家的用户名保存到数据库中。
- en: To save the data into the database, we use Mongoose's `findOneAndUpdate` method,
    which takes three arguments. The first is a query object to find the document
    to be updated. We find the stat document where the word is `currentWord` we get
    from `Stat.findOnequery`. The second argument is the `update` object. This defines
    what to update.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据保存到数据库中，我们使用 Mongoose 的 `findOneAndUpdate` 方法，它接受三个参数。第一个是一个查询对象，用于找到要更新的文档。我们找到
    `Stat.findOnequery` 获取的 `currentWord` 对应的 stat 文档。第二个参数是 `update` 对象。它定义了要更新什么。
- en: We use Mongo's modifier `$push` to push a word chain history into the `used`
    field, which is an array. The last argument is options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Mongo 的修饰符 `$push` 将单词链式历史记录推送到 `used` 字段，它是一个数组。最后一个参数是选项。
- en: 'We use the `{ upsert: false }` option, which means if we can''t find the document
    with the query defined in the first argument, we won''t update or insert a new
    document. This makes sure no other operation occurs in between the time it takes
    to find the document and update the document, that is, we don''t insert a new
    word if the current word cannot be found. Therefore, the game status doesn''t
    change because the current word is assigned to `word` and is still the same.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用`{ upsert: false }`选项，这意味着如果我们无法找到第一个参数中定义的查询的文档，我们不会更新或插入一个新文档。这确保在找到文档和更新文档之间没有其他操作发生，也就是说，如果当前单词找不到，我们不会插入一个新单词。因此，游戏状态不会改变，因为当前单词被分配给`word`并且仍然是相同的。'
- en: If we successfully find the word, we add a new used word object to the used
    word array consisting of the new valid word and the username that submitted it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功找到单词，我们将在使用单词数组中添加一个新的已使用单词对象，包括新的有效单词和提交它的用户名。
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Dealing with race conditions
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理竞态条件
- en: You might have questions about the preceding code. Finding a document and updating
    a document seem like two separate operations; what if two users send the same
    request? It may cause a race condition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对前面的代码有疑问。查找文档和更新文档看起来像是两个独立的操作；如果两个用户发送相同的请求怎么办？它可能会导致竞态条件。
- en: For example, if the current word is `Today`, Player 1 submits `yes`, and Player
    2 submits `yellow`; both players chain a valid word. While both these words are
    valid, we can't accept both of them for two reasons; only one player can win each
    round, and if we had two or more winning words, the words could end with different
    letters, which would affect the next word chain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果当前单词是`Today`，玩家1提交`yes`，玩家2提交`yellow`；两位玩家都链出了一个有效的单词。虽然这两个单词都是有效的，但我们不能接受它们，有两个原因；每个回合只有一个玩家可以获胜，而且如果有两个或更多获胜的单词，这些单词可能以不同的字母结尾，这会影响下一个单词链。
- en: If `yes` arrives at the server first and gets accepted, then the next word should
    start with an `s`, and `yellow` from Player 2 should become invalid and be rejected.
    This is called a race condition.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`yes`首先到达服务器并被接受，那么下一个单词应该以`s`开头，并且玩家2的`yellow`将变得无效并被拒绝。这被称为竞态条件。
- en: How do we solve this? We need to combine the two database operations, finding
    a document and updating a document, into one operation. We could use Mongoose
    model's `findOneAndUpdate` method. This method will actually call the `findAndModify`
    method of MongoDB, which is an isolated update and return operation. Since it
    becomes one database operation, MongoDB will update the document atomically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？我们需要将两个数据库操作，查找文档和更新文档，合并为一个操作。我们可以使用Mongoose模型的`findOneAndUpdate`方法。实际上，这个方法会调用MongoDB的`findAndModify`方法，这是一个隔离的更新和返回操作。由于它变成了一个数据库操作，MongoDB将原子性地更新文档。
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When a user submits a word, we first query the current game state, when the
    Promise is resolved and successful, and then check that the first letter of our
    submitted word (first) and last letter of the current word (currentWord) are the
    same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交一个单词时，我们首先查询当前游戏状态，当Promise解析并成功后，然后检查我们提交的单词的第一个字母（first）和当前单词的最后一个字母（currentWord）是否相同。
- en: 'If they are the same, we call `findOneAndUpdate()` to search for the submitted
    word and make sure that it is not present in the array of previously used words.
    `used.word: { $ne: word }` then returns a Promise object.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '如果它们相同，我们调用`findOneAndUpdate()`来搜索提交的单词并确保它不在先前使用的单词数组中。`used.word: { $ne:
    word }`然后返回一个Promise对象。'
- en: If the Promise comes back fulfilled, then we push the submitted word and user
    to the used words array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Promise得到满足，那么我们将提交的单词和用户推送到已使用单词数组中。
- en: 'If the Promise is rejected and/or the conditions are not satisfied, then no
    data will be pushed into the array (`upsert: false`).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '如果Promise被拒绝和/或条件不满足，则不会将任何数据推送到数组中（`upsert: false`）。'
- en: The last `then` statement returns the new result; if none was returned, then
    the `not found` error will be thrown.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`then`语句返回新的结果；如果没有返回，则抛出`not found`错误。
- en: Test case to test race conditions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例以测试竞态条件
- en: 'Now that we implemented the logic, we want to test it out. The test case is
    shown as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实现了逻辑，我们想要测试它。测试用例如下所示：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As the word by player 1 goes in first, the `hello` word by player 1 should increase
    the length of the used array to `4`, the current word position in the array should
    be equal to `hello`, and the successful user who submitted it should be updated
    to be `geoffrey`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家1的单词先进入，玩家1的`hello`单词应该增加使用数组的长度到`4`，当前单词在数组中的位置应该等于`hello`，并且成功提交的用户的名称应该更新为`geoffrey`。
- en: When marc submits a word beginning with `h`, it should return an error because
    the last letter of the current word, `hello`, is `o` and helium does not begin
    with `o`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当marc提交以`h`开头的单词时，应该返回一个错误，因为当前单词的最后一个字母是`o`，而氦气不以`o`开头。
- en: Socket.IO
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO
- en: 'We can send information to our servers when we submit user info or words but
    how do we get the server to update us without requesting updates manually? We
    use Socket.IO to enable real-time two-way event-based communication. Documentation
    for Socket.IO is available at `socket.io/docs`. We install it by executing the
    following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交用户信息或单词时，我们可以向服务器发送信息，但我们如何让服务器在不手动请求更新的情况下更新我们？我们使用Socket.IO来启用基于事件的实时双向通信。Socket.IO的文档可在`socket.io/docs`找到。我们通过执行以下代码来安装它：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Socket handshaking, user join
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字握手，用户加入
- en: 'First, we require `socket.io` and our game in `socket.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`socket.js`中引入`socket.io`和我们的游戏：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Authorization takes place during handshaking, which is when the socket connection
    is established. Without handshaking, we would not know which socket connection
    belongs to which Express session. As given in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 授权发生在握手过程中，这是套接字连接建立的时候。如果没有握手，我们就不知道哪个套接字连接属于哪个Express会话。如下面的代码所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `io.use()` method lets you give the Socket.IO server functions to run after
    a socket is created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.use()`方法允许你在套接字创建后运行Socket.IO服务器函数。'
- en: The request sent from the client (consisting of a URL and name) will be stored
    in `handshakeData`. The console will output the username and make sure that the
    sockets are handshaking.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的请求（由URL和名称组成）将被存储在`handshakeData`中。控制台将输出用户名并确保套接字正在握手。
- en: Next, it will assign the username to `socket.user` so that it can be passed
    in to the `join()` function. The socket will call the `Game.join()` function and
    if the user is able to join, a console message will be displayed with the message
    `game joined successfully` and the name of the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将用户名分配给`socket.user`，以便可以传递给`join()`函数。套接字将调用`Game.join()`函数，如果用户能够加入，控制台将显示一条消息，内容为`game
    joined successfully`以及用户的姓名。
- en: The `Socket.broadcast.emit` method sends the message to all other clients except
    the newly created connection telling them that a new user has joined.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket.broadcast.emit`方法将消息发送给所有其他客户端，除了新创建的连接，告诉他们有一个新用户加入了。'
- en: If the user was not successfully created (that is, there were two users with
    the same name) the error will be sent to the `catch` method and the console will
    log that the user was not able to join the game. Then, `next(err)` will send the
    error message back to the connecting client, so that on the client side we can
    show a pop-up message telling the user that the name is being used.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有成功创建（即，有两个用户具有相同的名称），错误将被发送到`catch`方法，控制台将记录用户无法加入游戏。然后，`next(err)`将错误消息发送回连接的客户端，这样在客户端我们就可以显示一个弹出消息，告诉用户该名称正在被使用。
- en: Adding and pushing updates to clients
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加并推送更新到客户端
- en: With Socket.IO, you can send and receive any events you want as well as any
    data you want in the JSON format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Socket.IO，你可以发送和接收任何你想要的任何事件以及任何你想要的JSON格式的数据。
- en: 'There are three additional socket events (after connecting) that we''re going
    to need for our game: disconnect, chain (chain new word to last), and game status.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏需要三个额外的套接字事件（在连接之后）：断开连接、链（将新单词添加到上一个单词），以及游戏状态。
- en: 'In `socket.js`, add these three socket events:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`socket.js`中添加这三个套接字事件：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first socket event `connection` we subscribe to will be triggered when a
    user establishes a socket connection with the server. Once a client is connected,
    we log that event and display their name on to the console so that we know who
    is connected.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅的第一个套接字事件`connection`将在用户与服务器建立套接字连接时触发。一旦客户端连接，我们记录该事件并在控制台上显示他们的名字，这样我们就知道谁连接了。
- en: The second event `disconnect` will be triggered when users are disconnected
    from the server. It happens when they leave the game or the network connection
    is broken. Once this event is triggered, we broadcast to all other sockets that
    the user has left (via `socket.broadcast.emit`) so that the other users can see
    that the disconnected user is no longer in the list of active players.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与服务器断开连接时，将触发第二个事件 `disconnect`。这发生在他们离开游戏或网络连接中断时。一旦此事件被触发，我们就通过 `socket.broadcast.emit`
    向所有其他套接字广播用户已离开的消息，这样其他用户就可以看到断开连接的用户不再在活跃玩家列表中。
- en: The last two socket events, chain and game, are game actions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个套接字事件，链和游戏，是游戏动作。
- en: The chain takes in the user's submitted word and calls the `Game.chain()` function;
    if it succeeds, then it logs that the chain was successful and broadcasts the
    status to all other users.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 链接接收用户的提交单词并调用 `Game.chain()` 函数；如果成功，则记录链接成功并将状态广播给所有其他用户。
- en: The `game` responds with the latest game status.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`game` 响应最新的游戏状态。'
- en: Launch Socket.IO applications
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Socket.IO 应用程序
- en: 'To launch our game, let''s create a launch script called `www`, and place it
    under the `bin` folder. This is our code for `./bin/www` as given in the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的游戏，让我们创建一个名为 `www` 的启动脚本，并将其放置在 `bin` 文件夹下。以下是我们 `./bin/www` 的代码，如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first line tells shell which interpreter should be used to execute this
    script. Here, we tell shell that the interpreter is node. Then, we can launch
    the server locally with the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉 shell 应使用哪个解释器来执行此脚本。在这里，我们告诉 shell 解释器是 node。然后，我们可以使用以下命令在本地启动服务器：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, in `bin/www`, we will set up an Express application listening on a port,
    which is defined in the environment variable or `3000` if nothing is there.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `bin/www` 中，我们将设置一个监听端口的 Express 应用程序，该端口由环境变量定义，如果没有则默认为 `3000`。
- en: We then bind socket to our HTTP server, which is created by our Express application.
    Since the Socket.IO server needs to be attached to an HTTP server, we pass the
    server object to the socket function, where we initialize the socket server.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将套接字绑定到我们的 HTTP 服务器，该服务器由我们的 Express 应用程序创建。由于 Socket.IO 服务器需要附加到 HTTP 服务器，我们将服务器对象传递给套接字函数，在那里我们初始化套接字服务器。
- en: 'So now we have the launch script in place. If we launch the server locally,
    we will see the following message printed to the console:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经设置了启动脚本。如果我们本地启动服务器，我们将在控制台看到以下消息打印出来：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Test Socket.IO applications with the Socket.IO client
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Socket.IO 客户端测试 Socket.IO 应用程序
- en: We will write the JavaScript for the client-side frontend application, which
    we will test our game with.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写客户端前端应用的 JavaScript 代码，我们将用这个游戏进行测试。
- en: You can find the JavaScript file under `public/javascripts/app.js` and the view
    in `app/views/index.jade`. We will not be covering frontend components such as
    `jade` and `stylus/css` in this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `public/javascripts/app.js` 下找到 JavaScript 文件，在 `app/views/index.jade`
    下找到视图。在这本书中，我们不会涵盖前端组件，如 `jade` 和 `stylus/css`。
- en: 'We begin by setting up our game with all our variables, which are classes in
    the `index.jade` file that we will refer to. We also initialize our game with
    the `init()` function, which will be described in the next code block:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置我们的游戏变量，这些变量是 `index.jade` 文件中的类，我们将引用它们。我们还使用 `init()` 函数初始化我们的游戏，该函数将在下一个代码块中描述：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Game.prototype` adds functions to our `Game` method in `app/controllers/game.js`.
    We will break this up into several smaller code blocks to show the client-side
    logic that we're working with.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game.prototype` 向 `app/controllers/game.js` 中的 `Game` 方法添加函数。我们将将其拆分为几个较小的代码块，以展示我们正在处理的客户端逻辑。'
- en: The `init()` function begins by bringing the username input box into focus,
    and then when the submit button is pressed, obtain the value of the user input
    and assign it to the variable `username`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 函数首先将用户名输入框置于焦点，然后当提交按钮被按下时，获取用户输入的值并将其分配给变量 `username`。'
- en: We then send the user name to the `join()` function listed as follows, in the
    next code block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将用户名发送到以下列出的 `join()` 函数，在下一个代码块中。
- en: We also set up a function that will take the input from the submit button for
    `chain` (which is where you input the word you would like to chain with the current
    word), store it in the chain variable, and then send it to the chain function
    (discussed later) and clear out the text input box.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一个函数，该函数将获取提交按钮的输入 `chain`（这是您输入要与前一个单词链接的单词的地方），将其存储在链变量中，然后将它发送到链函数（稍后讨论）并清除文本输入框。
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The login UI will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用户界面将看起来像这样：
- en: '![Test Socket.IO applications with the Socket.IO client](img/0818_04_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Socket.IO 客户端测试 Socket.IO 应用程序](img/0818_04_06.jpg)'
- en: When a user submits a user name, it is passed on to the `join` function, which
    first establishes a socket connection and then calls `User.join()` (covered earlier)
    on the server (`game.js`) and initializes a socket handshake (with the configuration
    to only use WebSocket as the transport) with the submitted username and a URL
    that consists of `/?username= + username`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交用户名时，它会被传递到 `join` 函数，该函数首先建立套接字连接，然后在服务器（`game.js`）上调用 `User.join()`（前面已介绍）并初始化套接字握手（配置为仅使用
    WebSocket 作为传输协议）与提交的用户名和一个由 `/?username= + username` 组成的 URL。
- en: When the connection is established, the socket emits the game status and users
    list (`updateStat()` and `updateUsers()` functions, which we will discuss later)
    and calls the `showGameView()` function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接建立时，套接字会发出游戏状态和用户列表（`updateStat()` 和 `updateUsers()` 函数，我们将在后面讨论）并调用 `showGameView()`
    函数。
- en: The `showGameView()` function (see the following code block) hides the login
    form, displays the view-game form where you can input a `word` to chain, and focuses
    on the chain input box.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`showGameView()` 函数（见以下代码块）隐藏登录表单，显示可以输入 `word` 进行链式反应的视图游戏表单，并聚焦于链式输入框。'
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a user joins or leaves the game, it's passed to the socket server (`game.js`)
    `join` or `leave` functions, and the client-side `updateUsers()` function is called.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户加入或离开游戏时，它会被传递到套接字服务器（`game.js`）的 `join` 或 `leave` 函数，并调用客户端的 `updateUsers()`
    函数。
- en: The `updateUsers()` function takes the array of users that was returned by the
    server and maps it to get the usernames that are displayed as a list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateUsers()` 函数将服务器返回的用户数组映射到以列表形式显示的用户名。'
- en: Similarly, when a stat call is made to the server, `updateStat()` method gets
    called, which receives the current word (`stat.word`) from the server and displays
    it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当对服务器进行状态调用时，`updateStat()` 方法被调用，它从服务器接收当前单词（`stat.word`）并显示它。
- en: Additionally, the input box will contain the last letter of that word as a placeholder
    and the user who submitted the current word will be displayed by accessing the
    user array and popping out the last user.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，输入框将包含该单词的最后一个字母作为占位符，并且可以通过访问用户数组并弹出最后一个用户来显示提交当前单词的用户。
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `chain` function given in the following alerts a user if they try to submit
    without entering a word; it then sends a call to the server's `chain` function,
    the input word, and the callback function, which will output the data received
    from the server (which is the response word and used array).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下警告中给出的 `chain` 函数会在用户尝试提交未输入单词时提醒用户；然后它向服务器的 `chain` 函数发送调用，输入的单词和回调函数，该回调函数将输出从服务器接收到的数据（即响应单词和使用的数组）。
- en: Looking in the server's socket code (socket.js line 47), if a callback is present,
    and the function was successful, then a status of `200` is sent back.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器的套接字代码（`socket.js` 第 47 行）中查看，如果存在回调，并且函数执行成功，则发送状态 `200`。
- en: If the client side receives a status of `200`, then it will call the `updateStat()`
    function with `data.resp`, which is the stat object containing the word and used
    words; otherwise, if no data was received from the server or the chain was unsuccessful
    and a status code that is not `200` is sent back, the user will see an alert telling
    them that their input word doesn't chain with the current word.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端收到状态 `200`，则将调用 `updateStat()` 函数，其中 `data.resp` 是包含单词和使用的单词的统计对象；否则，如果没有从服务器接收到数据或链式反应失败并且返回的状态码不是
    `200`，用户将看到一个警告，告诉他们他们的输入单词无法与当前单词链式反应。
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Test Socket.IO applications with the Socket.IO client](img/0818_04_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Socket.IO 客户端测试 Socket.IO 应用程序](img/0818_04_07.jpg)'
- en: Debug Socket.IO with Chrome Developer Tools
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Chrome 开发者工具调试 Socket.IO
- en: To debug Socket.IO, we want to know what socket request we send to our server,
    what the request arguments are, and what the broadcast messages look like. Chrome
    has a built-in powerful WebSocket debugging tool; let's see how to use it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试 Socket.IO，我们想知道我们向服务器发送了什么套接字请求，请求的参数是什么，以及广播消息看起来像什么。Chrome 内置了一个强大的 WebSocket
    调试工具；让我们看看如何使用它。
- en: To open Chrome Developer Tools, go to the menu, select **View** | **Developer**
    | **Developer Tools**. You can also right click on the page, and select **Inspect
    Element**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 Chrome 开发者工具，请转到菜单，选择 **查看** | **开发者** | **开发者工具**。您也可以右键单击页面，并选择 **检查元素**。
- en: From the Developer tools, select the **Network** panel.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者工具中选择 **网络** 面板。
- en: '![Debug Socket.IO with Chrome Developer Tools](img/0818_04_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Chrome 开发者工具调试 Socket.IO](img/0818_04_08.jpg)'
- en: Now when we go back to the page and join the game, we will see a Socket.IO request
    in the **Network** panel of the Chrome Developer Tools. The request URL is `ws://127.0.01:3000/socket.io/?username=marc&EIO=2&transport=websocket`
    and **Status Code is 101 Switching Protocols**, meaning we passed the handshaking
    and established a socket connection with the server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们回到页面并加入游戏时，我们将在 Chrome 开发者工具的 **Network** 面板中看到一个 Socket.IO 请求。请求 URL
    是 `ws://127.0.01:3000/socket.io/?username=marc&EIO=2&transport=websocket`，**状态码是
    101 Switching Protocols**，这意味着我们通过了握手并与服务器的套接字连接建立。
- en: Now, click on the **Frames** tab on the right-hand side panel. We will see some
    messages there in the table. The white rows are the messages our client sent to
    the server and the green rows are the messages that the server sent to the client.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击右侧面板上的 **Frames** 选项卡。我们将在表格中看到一些消息。白色行是我们客户端发送给服务器的消息，绿色行是服务器发送给客户端的消息。
- en: '![Debug Socket.IO with Chrome Developer Tools](img/0818_04_09.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Chrome 开发者工具调试 Socket.IO](img/0818_04_09.jpg)'
- en: Let's take a look at each row and understand what happened in the game.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看并了解游戏中发生了什么。
- en: '**0{"sid":"XNhi9CiZ-rbgbS5VAAAC","upgrades":[],"pingInterval":25000,"pingTimeout":60000}:**.
    After the connection is established, the server returned some configuration to
    the client such as the socket session id (sid), pingInterval, and pingTimeout.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**0{"sid":"XNhi9CiZ-rbgbS5VAAAC","upgrades":[],"pingInterval":25000,"pingTimeout":60000}:**
    连接建立后，服务器向客户端返回了一些配置，例如套接字会话 ID (sid)、pingInterval 和 pingTimeout。'
- en: '**420["game",null]:** The client sent a socket request to get the latest game
    status.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**420["game",null]:** 客户发送了一个套接字请求，以获取最新的游戏状态。'
- en: '**430[{"users":["leo"],"stat":{"word":"what","_id":"54cec37c0ffeb2cca1778ae6","__v":0,"used":[{"word":"what","user":"admin"}]}}]**:
    The server responded with the latest game status, which shows that the current
    word is **what**.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**430[{"users":["leo"],"stat":{"word":"what","_id":"54cec37c0ffeb2cca1778ae6","__v":0,"used":[{"word":"what","user":"admin"}]}}]**:
    服务器响应了最新的游戏状态，显示当前单词是 **what**。'
- en: '**421["chain","tomorrow"]:** The client sent a request to chain the current
    word **what** with **tomorrow**.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**421["chain","tomorrow"]:** 客户发送了一个请求，要将当前单词 **what** 与 **tomorrow** 链接起来。'
- en: '**431[{"status":200,"resp":{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"tomorrow","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"}]}}]**:
    The server accepted the request and returned the updated game status. So now,
    the current word is **tomorrow**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**431[{"status":200,"resp":{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"tomorrow","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"}]}}]**:
    服务器接受了请求并返回了更新后的游戏状态。因此，现在的当前单词是 **tomorrow**'
- en: '**42["join",["leo","marc"]]**: marc joined the game. Now we have leo and marc
    in the game.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**42["join",["leo","marc"]]**: marc 加入游戏。现在游戏中我们有 leo 和 marc。'
- en: '**42["stat",{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"we","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"},{"user":"marc","word":"we"}]}]**:
    Here **marc** chained the current word **tomorrow** with **we**. So the server
    pushed the game status to the client.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**42["stat",{"__v":0,"_id":"54cec37c0ffeb2cca1778ae6","word":"we","used":[{"word":"what","user":"admin"},{"user":"leo","word":"tomorrow"},{"user":"marc","word":"we"}]}]**:
    **marc** 将当前单词 **tomorrow** 与 **we** 链接起来。因此，服务器将游戏状态推送给客户端。'
- en: '**42["join",["leo","marc","geoffrey"]]:** **geoffrey** joined the game. Now
    we have three players in the game: **leo**, **marc**, and **geoffrey**.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**42["join",["leo","marc","geoffrey"]]:** **geoffrey** 加入游戏。现在游戏中我们有三位玩家：**leo**、**marc**
    和 **geoffrey**。'
- en: '**42["leave",["leo","geoffrey"]]:** **marc** left the game, **leo** and **geoffrey**
    are still in the game.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**42["leave",["leo","geoffrey"]]:** **marc** 离开了游戏，**leo** 和 **geoffrey** 仍然在游戏中。'
- en: Now you've had a chance to actually test the game developed for this app and
    can see how the different aspects intertwine.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有机会实际测试为这个应用开发的游戏，并可以看到不同方面是如何交织在一起的。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We created an Express app, a Socket.IO server, and a game client that can talk
    to our server using the `socket.io-client` library, and receive the push updates
    from our server. We've also gone through the user creation and word chaining logic
    so that we can validate new users and words to be chained. In this process, we
    dived into the world of Promises; hopefully, illustrating their versatility and
    how they can simplify your code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 Express 应用程序、一个 Socket.IO 服务器和一个可以与我们的服务器通过 `socket.io-client` 库通信的游戏客户端，并接收来自服务器的推送更新。我们还经历了用户创建和单词链接逻辑，以便我们可以验证新用户和要链接的单词。在这个过程中，我们深入了解了
    Promises 的世界；希望这能说明它们的通用性和如何简化你的代码。
- en: In the next chapter, we will introduce how to build a user matching system,
    and make it a service. You will also learn how to set up periodical tasks with
    node-cron.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何构建一个用户匹配系统，并将其打造成一个服务。你还将学习如何使用node-cron设置周期性任务。
