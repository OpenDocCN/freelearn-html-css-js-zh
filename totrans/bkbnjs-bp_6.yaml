- en: Chapter 6. Building a Podcast Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, there will be an interesting twist. All the applications we
    have built so far have been pretty heavy on the client code, but rather light
    on the server. The truth is, the web applications you're going to build aren't
    always going to be this way. Often, you'll have to perform a lot of heavy lifting
    on the backend as well as on the frontend; and the application we're going to
    build here will be this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we''ll focus on the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an application that is both server- and client-intensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating some of Marionette's functionality, without using Marionette
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing and simplifying a data file before storing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are we building?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be building a podcast-listening application. As you
    probably know, a podcast feed is very similar to a regular blog''s RSS feed. The
    primary difference is what the fields are; so, even though we''re building a basic
    podcast **catcher**, a lot of it could go towards building a regular RSS reader.
    So, here''s what we will have: people can make accounts for our application, and
    then subscribe to podcast feeds. We''ll load in all existing episodes, and users
    can listen to them and see the show notes and links right in our app. Each time
    a user opens the application, each of the podcasts they subscribe to will be checked
    for new episodes. They''ll be able to listen to episodes, or just mark them as
    listened to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a look at the completed project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are we building?](img/6997OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It doesn't sound or look like a lot, maybe, but there's a lot to do, so let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Building user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with user accounts. You''ll remember that in [Chapter 2](ch02.html
    "Chapter 2. Building a Photo-sharing Application"), *Building a Photo-sharing
    Application*, when we built the photo sharing application, we created a `signin.js`
    file; we''ll want to use that here. We can set this up by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the template directory to create a new project, and then copy the `signin.js`
    file into the new directory. You''ll want to add the following line to the top
    of the `server.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, as you might recall, this requires a few more Node.js packages. Go ahead
    and install `passport`, `passport-local`, and `bcrypt` by using the following
    command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `bcrypt` and `passport-local` packages are used in the `sigin.js` file,
    but we require `passport` in the `server.js` file; we''ll also create the `users`
    database, as you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to make sure our express application is configured for this.
    Here''s the complete `configure` block that we saw in our photo sharing application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we configure `passport` to use the methods that we have in our `signin.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create the routes for logging in, logging out, and making user accounts.
    If the user is getting the `/login` route, we''ll render the `login.ejs` (coming
    soon) file. Once they enter a username and password, the results will be saved
    to the `/login` route with the help of the POST request, where authentication
    will occur. Then, to log out at `/logout`, we''ll call the `logout` method that
    `passport` has added to the request object, and redirect back to the root. So,
    here are the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last route related to user accounts is the `/create` route; this is the
    route that will be used to create new accounts. It''s a lot of code, but it''s
    pretty basic. We create an attributes object with the username and hashed password.
    Then, we check to see if the user exists. If they do, we go back to the root route.
    Otherwise, we''ll create the user account and redirect to the root route, the
    difference being that we are now logged in. The following is the code for the
    `/create` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final flare for this portion is the `login.ejs` file, in the `views` directory.
    As you'll see, from all the extra classes and wrapping elements, we will use Twitter
    Bootstrap again. However, this time, we'll not use the default version. You can
    go to Bootswatch ([http://bootswatch.com](http://bootswatch.com)) to find other
    themes based on Bootstrap; all the same classes, but different styling. This way,
    you can choose any theme from Bootswatch that you'd like and get a different skin
    to your application, but you don't need to change the HTML code at all. I'm going
    to choose the Simplex theme ([http://bootswatch.com/simplex](http://bootswatch.com/simplex)),
    but you can choose a different one if you prefer. Download the CSS file and add
    it to the `public` directory. As you can see from the following template, we'll
    also have our own style sheet, `style.css` of the `public` directory, for a few
    customizations. We'll add to this file later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s what should go inside the `login.ejs` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is the root/catch-all route. If a user is logged in, we''ll render
    the `index.ejs` file; otherwise, we''ll have to redirect to `/login`. This is
    a good first version of the root route; if the `req.user` value is not set, we''ll
    redirect to the login page. Otherwise, we''ll render the index template. Here''s
    the code for this route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Subscribing to and storing podcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application is a little different from our previous applications in terms
    of the data that we need to store. Before, we've always stored only data that
    we get from the user. This time, a user is only going to give us a URL—the path
    to a podcast feed—and we have to get all the data from that. Then, later, we need
    to check that same source for updates. This requires a lot more work on our part.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking about how we''re going to get this podcast data. Of course,
    there are only two places from which we can pull in this data: the client and
    the server. Both are possible; however, things will go a lot more smoothly if
    we choose to get this data on the server side. Here''s why: to prepare the data
    on the client side would require us to first get the feed (which is a little more
    than simple, because it''s a cross-domain request); then, we have to parse that
    to get the podcast and episode data we need, before sending the data back to the
    server for storage. This could take a rather long time, especially if the podcast
    has many episodes. If the user closes the application during this process, all
    or part of the data will be lost, and things could get messy. It''s much better
    to do all that work on the server side, where the processing can continue even
    if the user closes their browser tab. So, we will focus on data processing next.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, there's going to be a fair bit of code involved in getting the podcast
    data, so we're going to create a custom Node.js module especially to work with
    podcasts. So, create a `podcasts.js` file in the project directory, and let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, there are two other Node.js packages that we are going to use in
    this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xml2js** ([https://www.npmjs.org/package/xml2js](https://www.npmjs.org/package/xml2js))
    will allow us to convert the podcast feed XML into JSON; it really won''t be pretty
    JSON, but it will be usable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**q** ([https://www.npmjs.org/package/q](https://www.npmjs.org/package/q))
    is an asynchronous promises library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, install these two packages by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you haven''t worked with promises before, you can think about them like
    this: often in JavaScript, you''ll pass a callback to a function call so that
    the function can be run after some data is ready; a **promise** is an object that
    encapsulates that expected data. You can pass that promise object around and add
    multiple callbacks to it, all of which will be run when the data is ready. You
    can even add callbacks after the data is ready (of course, those will be run right
    away). For a really good introduction and explanation of promises, I recommend
    you check out the great article *JavaScript Promises ... In Wicked Detail* by
    Matt Greer ([http://mattgreer.org/articles/promises-in-wicked-detail/](http://mattgreer.org/articles/promises-in-wicked-detail/)).
    It will explain their benefits and how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `podcasts.js` file, we''ll require the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We require the native-to-Node.js `http` library so that we can make a request
    for the podcast feed file. Also, we will create two Bourne databases here: one
    for podcasts, and the other for episodes. We won''t even need to access these
    databases from the `server.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the first method we''ll write for getting the actual feed
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes a URL and passes it to the `http.get` method. The callback
    we give to that method gets a response object. We can listen for the `data` event
    on that object and concatenate the data into a string, which we''ll name `xml`.
    Then, when the request is finished (signaled by the `end` event), we use the XML
    string to resolve the `deferred` object we create at the top of the method. At
    the end of the method, we return the `promise` object for our `deferred` object.
    Now, we can use this method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `promise` object we return has a `then` method. The value that we pass
    to the `deferred` object''s `resolve` method will be passed as a parameter to
    the function we pass to the `then` method when the request is complete. So this
    is how we get the XML data for a podcast. Now, we need to convert it to JSON and
    get the values that we want. The `parse` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `parse` function takes the XML input. We pass the XML input to the `parseString`
    function from `xml2js` to convert it to JSON. Then, we can start pulling the data
    we want out of the result. Unfortunately, `xml2js` doesn't give us a very clean
    JSON structure to work with; almost every value is an array, but most only have
    a single value in them. That's why we get the first element of an array in every
    case. Where the element has attributes instead of child elements, `xml2js` uses
    a property named `$`. Once we get the general information about the podcast and
    the data for each episode, we put them into an object that goes to resolving another
    promise.
  prefs: []
  type: TYPE_NORMAL
- en: With these two methods in place, we can now create a `Podcast` constructor function
    as a handy wrapper that is used to manage an individual podcast. This constructor
    function will need to work in two ways to be most useful in our `server.js` file.
    If we pass it a URL, it will assume we're creating a new podcast record, and will
    get and store the data. However, if we pass it a number, if will assume that the
    number is the ID of an already-stored podcast, and get that out of the database.
    Since storing and fetching this data will be asynchronous operations, we'll use
    promises to wait for the right time to act.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `Podcast` constructor is a rather large function; we''ll take it piece
    by piece. We will start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `feed` parameter will be either the URL or the ID, as we discussed earlier.
    The `userId` parameter will be the ID of the user who is subscribing to this podcast.
    Then, we''ll create two deferred objects called `info` and `episodes`. We assign
    their promises as properties of the object we will create with this function so
    that we can use them when they are ready. We''ll also create a `ready` property;
    this is another promise object that will resolve when all the promises we pass
    it in an array are resolved. This makes for a nice convenient way to do something
    when both the `info` and `episodes` promises are ready. You can see this in the
    following code, which is the next part of the `Podcast` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the type of the parameter `feed` is a string, we know that we're creating
    a new podcast record. We'll get and parse the feed, using the methods we created
    earlier. Then, we add the feed URL and the `userId` parameter to the `info` property
    of the data we get back. This `info` property is now ready to be stored in the
    database. We'll store it in `pcdb`, the podcasts' database. In the callback for
    that, we'll resolve the `info` deferred object, because the `info` property has
    now been stored (this means our podcast record has an ID in our database).
  prefs: []
  type: TYPE_NORMAL
- en: One of the beautiful things about promises is that we can have multiple `then`
    calls to them. So, even though we created the `this.info` promise to be used outside
    the podcast object, we can wait for its resolution inside as well. That's the
    next step. When the `info` promise resolves, we need to store the episodes. You
    can see why it's important to wait until the podcast record is stored; we need
    to add the podcast's ID as the `podcastID` property to each episode object.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have done that, we can insert all the records into the `episodes` database,
    and then use them to resolve the `episodes` promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we do if the `feed` parameter isn''t a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If the `feed` parameter is not a string, then we have created this podcast record
    previously, and we need to find it. We start by finding the podcast by that ID,
    and resolve the `info` promise. Then, we find all the episodes with that `podcastID`
    property and use them to resolve the `episodes` promise. Believe it or not, that's
    all we need to do for our `Podcast` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to be able to check the feed for new episodes. So for this,
    we''ll need an `update` method. This method is a little long and involved, and
    it actually doesn''t do anything too complex. Here''s the outer shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We wait for our `this.ready` promise to be resolved; as you'll recall, this
    means that we're waiting for both `info` and `episodes` to be resolved. This promise
    has a `spread` method, which will spread the resolved values for these promises
    out so that each one is received as an individual parameter. As you can see, these
    are the `info` and `oldEpisodes` parameters. Then, we create the `resolve` function,
    which we'll use in several places inside this method. This function will simply
    find all the episodes for this podcast and resolve the deferred with them. So,
    the promise for the `update` method will return all the episodes for this podcast,
    not just the new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll call this `update` method every time a user loads the applications.
    However, most podcasts update about once a week, so there's no need to check for
    new episodes every time they load the page. So, we'll check once a day. When we
    subscribe to a podcast, we set the `lastUpdated` property to the current date
    and time as a Unix timestamp, using the unary plus operator (the single plus sign
    at the beginning, which is a shortcut for converting a `Date` object to a timestamp.
    Here, we get the current timestamp subtract to get the difference. If there is
    a difference of more than 86,400,000 (that's the number of milliseconds in a day),
    it means that we haven't updated this podcast in the last day, so we'll proceed
    with the update. Otherwise, we'll call resolve, which will just use the current
    episodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what if we want to do the update? The following code goes in place of the
    `// update the podcast` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we begin by getting and parsing the XML feed. Then, we check
    to see whether the list of retrieved episodes is greater than the list of current
    episodes. If it is so, we know we have new episodes to store. The next part is
    to figure out what episodes these are. We start by getting just the titles from
    the currently stored episodes, and put that in `oldTitles`. The next step is to
    find all the episodes with titles that aren't in this array; we just use the array's
    `filter` method. Then, we can insert all the remaining ones into the episodes
    database, and call the `resolve` method. If there aren't any new episodes, we'll
    call the `resolve` method anyway. The last step is to update the `lastUpdated`
    property on the podcast record.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all we need for the `Podcast` class. However, since we expect users
    to subscribe to more than one podcast, let''s make a simple `Podcasts` class to
    contain that behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we create a `Podcasts` instance, we'll pass it the ID of the user. Then,
    the `all` method will return a promise for all of that user's podcasts, and the
    `get` method will return a single podcast instance. The `updateEpisode` method
    is just a quick way to update a single episode; we'll only be using this to mark
    an episode as listened to. Finally, in a true Node.js module form, we end by exporting
    the `Podcasts` class. That's all we'll need to be able to access from the `server.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the `server.js` file, let''s go back there for a moment. First,
    pull in your `podcasts.js` file using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the catch-all route, we want to get the podcasts for the current user.
    Here''s the completed version of that route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the user is logged in, we can create a property on the user object `podcasts`.
    This is a new `Podcasts` object, which receives the user ID as the parameter.
    Then, we get the users' podcasts and send these records to the `index.ejs` file,
    along with the username we were sending previously.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing index.ejs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already created the `login.ejs` template, which will be displayed before
    a user is logged in. Once the user is logged in, we''ll render the `index.ejs`
    file. Here''s what we''ll start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve done in previous applications, we''ll be putting all our content
    inside the `<div id=''#main''>` element. This time, however, we''ll give it a
    Bootstrap class: `container-fluid`. It''s pretty amazing how, just by applying
    the right Bootstrap classes, our application becomes reasonably responsive; we
    don''t have to do any extra work. This time, we start with a bit of content in
    the main `<div>` element. There will be three columns in our application: the
    first will list the podcasts, the second will list the episodes for a selected
    podcast, and the third will show the details of an individual episode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom, we''ll pull in all our script tags; besides the defaults (jQuery,
    Underscore, and Backbone), we''ve got the JavaScript components of Bootstrap.
    This is necessary for the navigation we add later. Then, we have our own three
    files: `models.js`, `views.js`, and `router.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our models and collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with the `models.js` file. There are two types of data we''re
    going to be displaying here: podcasts and episodes. So, we''ll have a model and
    collection for each of these. Let''s start with episodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our model class is called `Episode`; we give it a root URL and a `listen` method.
    The `listen` method will mark the episode as listened to, by setting the `listened`
    property to true and saving the update to the server. You'll recall that, by default,
    we set `listened` to `false` for every episode when subscribing to the podcast.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the collection class is called `Episodes`. A collection of episodes will
    need to be associated with a podcast, so we'll get that `podcast` instance from
    the `options` object passed to the `initialize` method. Also, notice that we're
    setting a `url` method on the collection. Often, you'll set a `url` method on
    either the model class or the collection class, but not both. However, we'll need
    two different URLs here. The collection URL will be used to get all the episodes
    of a podcast. The model URL will be used when we mark an episode as listened to.
    The final portion of the collection class is the `comparator`. We want our episodes
    to show up in the right order, with the newest episodes at the top of the list,
    so we'll use the publishing dates as our comparison. Normally, we'd subtract value
    A from value B, but by reversing that, we can get the most recent episode at the
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'The podcast classes are even simpler, as you can see from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Podcast` model class's `episodes` method is rather interesting. As we already
    saw, each `Podcast` instance will have a related `Episodes` collection. This method
    will return that collection. What we're doing in this one-line method is returning
    the `this.episodes` property if it exists. If it doesn't, we'll create it, assign
    it, and return it, all in one.
  prefs: []
  type: TYPE_NORMAL
- en: Building the navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''re ready to start building our user interface; we can do this by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `views.js` file from the public directory. We''ll start with some
    helper code. You''re familiar with the first part, but the `tmpl` function is
    new. It''s just a small helper function that we''ll use to get our templates.
    We''ll use this method for almost every view. Here''s the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Funnily enough, we''re not going to use the `tmpl` function for the first view;
    the first view is the navigation view. Instead of creating a `template` property
    and choosing a `tagName` property, we''re setting the `el` property. We make this
    property a selector for an element that already exists on the page, and that element
    will become the element for this view. When we click on the **Add Podcast** link,
    we''ll want to display a form. To display this form, we''ll navigate to the `/podcasts/new`
    route. This is the whole class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create the element with the ID `navbar`, as this view is expecting.
    A lot of this is just for Bootstrap, but you can see that we have the **Add Podcast**
    and **Log Out** links. Its code is given as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is already on the page, we don''t have to insert it at any point;
    we''ll just instantiate the router in the class. We''ll do this soon, but the
    screenshot is a sneak peek to what it will look like when we do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the navigation](img/6997OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One more thing: this navigation bar will be fixed to the top of the screen,
    so we need to push everything else down a bit so that none of the content is hidden
    behind it before the user scrolls. It''s very simple; open your `style.css` file
    from the `public` directory, and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Displaying podcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step will be to display the list of podcasts that the user is subscribed
    to. We start with the `PodcastListView` class, which will display the collection.
    Here''s that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For Bootstrap, we''ll add the `list-group` class to the view''s element. In
    the `initialize` method, we''ll check the `options` object for a `current` value.
    If the user has clicked on one of the podcasts in the list to display the episodes,
    we''ll want to highlight that podcast, so `current` will be the ID of the selected
    podcast (if one is selected). Then, we''ll also listen to for new additions to
    the collection we''re displaying. If one is added, we''ll call the `render` method
    again. The `render` method looks for a few different scenarios. If the collection
    is empty (which it will be, at first), we''ll just display **No Podcasts**. Otherwise,
    we''ll clear the element and render each model using the `renderItem` method.
    The `renderItem` method sets a `current` property on each model; if this model
    is the current one, it will be `true`; otherwise, it will be `false`. Then, we''ll
    create a new `PodcastListItemView` instance, render it, and append it to the element.
    Now, we''re ready for this view; this is its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The element for this view is an anchor tag with the `list-group-item` class.
    We get the `podcastItem` template, which is fairly simple. Add the following code
    to the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `initialize` method, we''ll get the episodes collection for this podcast
    model and listen for the `count` event; when it occurs, we''ll call the `displayCount`
    method. But before we write that method, we''ll render the view. First, we''ll
    render the template. Then, we''ll set the `href` property on this element (remember,
    it''s an anchor); this will be the URL for the podcast instance. If this is the
    current podcast, we''ll add the active class to the element. Finally, we''ll call
    the `displayCount` method. Here''s that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we get the episodes collection for the podcast and fetch the
    data from the server. When it arrives, we pluck the value of the `listened` property
    from each episode model; this will be an array of Boolean values. Then, we filter
    out all the `true` values, so we only have the `false` values left. The length
    of the resulting array is the number of podcasts that have not been listened to.
    Then, we put that number into the badge element of our template.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing; if you haven't seen the `.bind(this)` trick before, this just
    keeps the value of `this` inside the function the same as it is outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, have a look at the `events` property. When this view''s element is
    clicked on, we''ll redirect to the model''s URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating a layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these views in place, we''re almost ready to start the router. Open the
    `router.js` file from the `public` directory. Now, in the previous chapter, we
    were using Marionette, and it gave us regions and layouts to manage where our
    views went. We don''t have them now, but since they were so useful, why don''t
    we make them ourselves? We can create it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When we create a region, we'll pass it a selector. Then, the `show` method will
    take one or more views. If we pass only a single view, we'll wrap it in an array.
    Then, we'll loop and append each view to the element. Notice that we're calling
    the `render` method and getting the element for the views here, so we only have
    to pass the view instance to this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If duplicating regions was easy, creating your own layout will be a piece of
    cake; we will create our layout by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Beginning the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to start the router. The following is our `Router` code for
    the `router.js` file; we can start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When the router is created, we'll accept a `podcasts` collection. We'll also
    create our `NavView` instance; remember, since the elements for this are already
    on the page, we don't have to append them. We're ready to take the root route
    with the `index` method; when that happens, we'll use our `layout.podcasts` region
    to show a `PodcastListView` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this router, let''s add another script tag to the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to new podcasts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have all the functionality we need to display podcasts; now, let''s create
    a form to be used when subscribing to new podcasts. As we determined earlier,
    in our `Podcast` module, all we need to get from the user is the podcast feed
    URL. So, let''s create our `NewPodcastView` class. First, here''s the template
    for this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s a simple form with a text input and a button. With this
    in place, we can now write the actual view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We'll give the element a `list-group-item` class and get the template. The rendering
    is very simple, and we're listening for a click on the button. When that happens,
    we'll get the feed from the field and replace the form with the text **Loading**.
    Then, we create a new podcast in the collection of podcasts that we'll associate
    with this view. The only property we need is the feed. Now, remember that our
    `PodcastListView` class will be listening for new models added to this collection.
    However, we need it to wait until the data has been stored in the server, so it
    has an ID and episodes to count. So, we'll add the `wait` option to this create
    call. Also, upon the successful completion of this request, we'll call this view's
    `remove` method to remove it from the UI. Finally, we'll navigate back to the
    home route (not triggering it, notice, because there's no need; we've just removed
    the form).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re adding the `loading` class to the view''s element while the data is
    being fetched on the server. Open the `style.css` file from the `public` directory,
    and add the following styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use a bit of CSS3 here; the element will pulse from red to white while the
    server is doing its work. Note that I'm using the standard CSS3 syntax here. At
    the time of writing this book, however, some browsers still require proprietary
    prefixes, so you'll have to add the code for the browsers you want to support.
    Of course, there are plenty of tools to assist you with this; Compass ([http://compass-style.org/](http://compass-style.org/))
    is a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll update the router with the route for adding a podcast. First, add
    the route to the route objects using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to write the `newPodcast` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty simple; like we do in the `index` method, we'll create and render
    a new `PodcastListView` instance. However, we keep a reference to the view and
    append our form to it; this way, the form will be displayed like another item
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in subscribing to podcasts is the server code. We need to manage
    the POST request that will occur when the user saves a new feed. In the `server.js`
    file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the user''s `podcasts` object to get the new podcast by its feed.
    We wait until the `info` promise is ready, and send the data back to the client.
    Now, we can successfully subscribe to podcast. Give it a try; start up the application,
    create a user account, and subscribe to a few podcasts. The result should be similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subscribing to new podcasts](img/6997OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the list of episodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can subscribe to podcasts, let''s work on displaying the list of
    them. We have the `Episode` model and the `Episodes` collection. We''ll start
    with the collection view `EpisodesView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this element will have the class `list-group`. You'll notice that
    in the `initialize` method, we expect `region` as one of the `options` object's
    properties. Keep this in mind, and we'll use it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `render` method, we loop over the collection and display an `EpisodeListItemView`
    instance. Notice that we pass `region` along; that''s where we''ll need it. Let''s
    create this class next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we've done with our previous list item view, we'll give this one the class
    `list-group-item`. There's no template here; we'll just set the title of this
    model as the text for the element. Then, if this episode has not been listened
    to, we'll add a class to highlight it, marking it as such. In the `initialize`
    method, notice that we're listening for a change to the `listened` property. When
    that change occurs, we'll call the `markAsListened` method, which will remove
    that class so that the view is no longer highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: The last method is `displayEpisode`, which will call the region's `show` method,
    passing it an `EpisodeView` instance for the model that this view is displaying.
    This won't just be a title, as we're showing here; it will be the entire model.
    This is why we're passing the region along. Since we're not changing the URL,
    we have to change the content of the page right here. So, that's what we do.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more piece for the list of episodes: a toolbar above it. There''s
    only one tool: **Mark All As Listened**, which is a simple button. Its code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, we start with the `className` property; the `render` method is very simple.
    In the `events` property, we wait for a click on the `#mark` button. When that
    happens, we call the `mark` function, which will loop over the collection and
    mark them all as listened to. Then, we trigger the `count` event on the collection;
    we listen for this event to occur in the `PodcastListItemView` class, where we'll
    update the podcast count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that one of the classes we''re using is the `btn-tools` class. This
    is one of our own creations, and it''s very simple; it just gives our tool bar
    a little more breathing room on the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step for this is the server component for marking an episode as listened
    to. Here''s the route to add to the `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to show our list of episodes. In the router of the `router.js`
    file, add the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for that `podcast` method, here''s its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We first render the podcast list, because it's possible that this page will
    be loaded directly. Notice that this time we're setting the `current` option so
    that it will be highlighted in the list. Then, we get the episodes for that podcast
    from the server. Next, in the `episodes` region, we show the views `EpisodesToolsView`
    and `EpisodesView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the episodes from the server, via `episodes.fetch()`, we need another
    server route, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We'll get the `Podcast` object, and then call the `update` method to check for
    new episodes. When that returns, we'll send them to the client as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can now view a list of episodes, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the list of episodes](img/6997OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, all that's left is displaying individual podcast episodes.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying episodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Individual episodes will be displayed in the `EpisodeView` class. Let''s start
    with the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with some tools at the top: a **Mark As Listened** button. Then, we
    show the details for the episode: title, duration, and date. Next comes the `audio`
    element; this makes it really easy for users to listen to the podcast right in
    our application. In our case, we only have a single audio source; however, you''ll
    often want to add multiple sources in different formats (MP3, OGG, and so on)
    when using the `audio` element, for maximum browser and OS coverage. Underneath
    the `audio` element, we''ll display the description, which will be the show notes
    for that episode. Here''s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Most of this view is the standard view code; we get the template, and we render
    the template with the model data. We also have a `listen` method, which will be
    called when the user clicks on the **Mark As Listened** button. The one difference
    is that we can't use the `events` property to listen for the `play` event on the
    `audio` element because of the way the `audio` element events works with Backbone.
    So, we get the element and use the `addEventListener` method to listen for that
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the last piece. Now, you should be able to view and play episodes of
    the podcast. It looks like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying episodes](img/6997OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter. A lot of what we did in this chapter
    was already familiar to you from previous applications, but there were a few nuggets
    that you shouldn't ignore. The main aspect is the strong server component. It
    is easy to forget that a Backbone application will always have the server code
    behind it, and often that code will be much more than a main template being rendered
    and a bunch of routes that shuttle JSON back and forth. There's often significant
    logic, data handling, and other details that will be taken care of on the server.
    As we saw, it's often possible to perform this logic on either the client or the
    server—we could have captured the RSS feed and processed it in either position.
    When building your own applications, it's important to make good decisions about
    where processes take place. It's often much quicker to do something on the client
    (no request/response to wait for), but you'll probably have more power and ability
    on the server, so the time delay might be negligible. The decision will be different
    for every situation, and there often won't be a single right choice.
  prefs: []
  type: TYPE_NORMAL
- en: The other interesting thing we did was recreate some of Marionette's behavior.
    This serves as another reminder that Backbone is just JavaScript, and there's
    no reason you can't write your own code to make it easier for you. There's no
    need to do anything fancy; as we saw, something as simple as our regions and layout
    can really clean up your router.
  prefs: []
  type: TYPE_NORMAL
- en: Only one chapter left, and that's where we'll have some fun and build a game.
  prefs: []
  type: TYPE_NORMAL
