<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Components</h1></div></div></div><p class="calibre7">Up until this chapter, we learned the basic Ember.js concepts that equipped us with the necessary tools that enabled us to create full-fledged applications. From this chapter onwards, we will be guided through creating all sorts of sophisticated applications as we explore more advanced Ember.js features. This chapter will introduce us to Ember.js components, which enable us to create custom reusable elements, and will cover the following topics in this regard:</p><div><ul class="itemizedlist"><li class="listitem">Understanding components</li><li class="listitem">Defining components</li><li class="listitem">Customizing components</li><li class="listitem">Using components as template layouts</li><li class="listitem">Defining actions inside a component</li><li class="listitem">Interfacing a component with the rest of the application</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec76" class="calibre1"/>Understanding components</h1></div></div></div><p class="calibre7">A web <a id="id337" class="calibre1"/>component is <a id="id338" class="calibre1"/>a reusable custom HTML tag. The World Wide Web Consortium is already working on custom web element (web components) specifications (<a class="calibre1" href="http://www.w3.org/TR/components-intro/">http://www.w3.org/TR/components-intro/</a>) that will allow developers to create these custom HTML elements with custom behaviors as opposed to always relying on the provided standard HTML elements. This specification is still being worked on, but there are a number of JavaScript open source projects (shims) that can get you started before this specification is complete:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">Polymer</strong>, available <a id="id339" class="calibre1"/>at <a class="calibre1" href="http://www.polymer-project.org/">http://www.polymer-project.org/</a></li><li class="listitem"><strong class="calibre8">Facebook React</strong>, available<a id="id340" class="calibre1"/> at <a class="calibre1" href="http://facebook.github.io/react/docs/component-api.html">http://facebook.github.io/react/docs/component-api.html</a></li><li class="listitem"><strong class="calibre8">Ember.js components</strong></li></ul></div><p class="calibre7">Ember.js provides mechanisms that will allow developers to create and complete these components <a id="id341" class="calibre1"/>in the near future of web technology. Once web components<a id="id342" class="calibre1"/> are standardized, Ember.js will continue enabling the easy creation of these custom elements. It's therefore an added advantage to start utilizing the Ember.js component APIs.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec77" class="calibre1"/>Defining a component</h1></div></div></div><p class="calibre7">Components <a id="id343" class="calibre1"/>are a higher-level construct of Ember.js views, and therefore, to define one, we'll need to define either or both of the following two Ember.js objects:</p><div><ul class="itemizedlist"><li class="listitem">The component's class</li><li class="listitem">The component's template</li></ul></div><p class="calibre7">The class is usually extended from the <code class="email">Ember.Component</code> class in the following signature:</p><div><pre class="programlisting">MyAppNamespace.ComponentNameComponent = Ember.Component.extend();</pre></div><p class="calibre7">The <code class="email">component</code> template is then defined and named using Ember.js conventions. For example, the template for the preceding component will be named as:</p><div><pre class="programlisting">components/component-name</pre></div><p class="calibre7">The bundled sample of this chapter includes a simple application that utilizes several components. This application allows users to upload and rate photos as shown in the following screenshot:</p><div><img src="img/00011.jpeg" alt="Defining a component" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The application<a id="id344" class="calibre1"/> defines the following components:</p><div><ul class="itemizedlist"><li class="listitem">Post input <a id="id345" class="calibre1"/>component</li><li class="listitem">Post date<a id="id346" class="calibre1"/> component</li><li class="listitem">Post rating<a id="id347" class="calibre1"/> component</li><li class="listitem">User post<a id="id348" class="calibre1"/> component</li><li class="listitem">Post photo<a id="id349" class="calibre1"/> component</li></ul></div><p class="calibre7">We already noticed that some of these components were defined by either a class or a template. For example, the <code class="email">user-post</code> component did not define a class. Also, the template names were namespaced using a hyphen, while the class names were camelized. Therefore, it would have been incorrect to register the <code class="email">user-post</code> component template as <code class="email">userpost</code>. This rule corresponds to one of the following component attributes described by W3C:</p><div><ul class="itemizedlist"><li class="listitem">Component custom elements must be namespaced by a hyphen.</li><li class="listitem">Components are sandboxed but can communicate through events. Therefore, the component and the host DOM JavaScript cannot manipulate each other.</li></ul></div><p class="calibre7">Hence, the <code class="email">post-input</code> component class and template, for example, were defined as:</p><div><pre class="programlisting">// class
App.PostInputComponent = Ember.Component.extend({
});

{{! template}}
&lt;script type="text/x-handlebars" id="components/post-input"&gt;
add
&lt;/script&gt;</pre></div><p class="calibre7">Once <a id="id350" class="calibre1"/>defined, a component can be included into any application template using the Handlebars expressions. For example, the first component is a button that is used to prompt the user to select an image from the disk:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/post-input"&gt;
add
&lt;/script&gt;</pre></div><p class="calibre7">Now, our router defines the <code class="email">photos</code> route that handled requests at the home path as:</p><div><pre class="programlisting">App.Router.map(function() {
  this.resource('photos', {path: '/'})
});</pre></div><p class="calibre7">Therefore, all we need to do is include the component in the corresponding <code class="email">photos</code> template as:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="photos"&gt;

  ...
  {{post-input posts=model}}

  ...
&lt;/script&gt;</pre></div><p class="calibre7">This will result in the <code class="email">components</code> template being swapped, resulting in:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="photos"&gt;
  ...
  &lt;button&gt;add&lt;/button&gt;
  ...
&lt;/script&gt;</pre></div><p class="calibre7">Do not worry about how the resulting element is a button. The important thing to note is that we just defined and used a custom HTML element without worrying about its underlying implementation.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec78" class="calibre1"/>Differentiating components from views</h1></div></div></div><p class="calibre7">Before<a id="id351" class="calibre1"/> we proceed, you might be wondering<a id="id352" class="calibre1"/> why components and views are different since both wrap templates. Well, components are indeed a subclass of views, but their controller context is isolated from the rest of the application. While application controllers can be assigned to any view, the defined component classes cannot be assigned to other components or views. Components define an interface the desired context must implement, and they are therefore more reusable and modular, as we will see in the next sections.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec79" class="calibre1"/>Passing properties to components</h1></div></div></div><p class="calibre7">While we<a id="id353" class="calibre1"/> just mentioned that components are isolated from <a id="id354" class="calibre1"/>the rest of the application, there is room for them to communicate with the host application in several ways. First, they're able to bind to proprieties in the host template context. For example, we just mentioned that the preceding button component is used to prompt the user to upload images. The component requires that an enumerable property, which will act as the photo store, be bound to its <code class="email">posts</code> property:</p><div><pre class="programlisting">{{post-input posts=model}}</pre></div><p class="calibre7">This way, the component will be able to store the provided photos, as we will discuss in a later section. These selected photos will then be displayed to the user in the same template as:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="photos"&gt;
...
&lt;div class='posts'&gt;
  &lt;ul&gt;
    {{#each model}}
      &lt;li&gt;{{user-post post=this}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/div&gt;
...
&lt;/script&gt;</pre></div><p class="calibre7">Here, we used yet another component, <code class="email">user-post</code>, which rendered a given photo into the included page portion. Again, we did not need to worry about the underlying implementation of the component. We only needed to satisfy its interface's requirement of binding a photo to its <code class="email">post</code> property.</p><p class="calibre7">To understand how these components used the bound properties, let's consider the <code class="email">post-date</code> component that was used by the just discussed <code class="email">user-post</code> component to display a humanized format of the post's date. This component contains a single expression that displays the formatted date as:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/post-date"&gt;
  {{formatedDate}}
&lt;/script&gt;</pre></div><p class="calibre7">The <a id="id355" class="calibre1"/>expression is a computed property that uses the <a id="id356" class="calibre1"/>Moment.js library (<a class="calibre1" href="http://momentjs.com">http://momentjs.com</a>) to<a id="id357" class="calibre1"/> format the date and is defined in the<a id="id358" class="calibre1"/> corresponding class as:</p><div><pre class="programlisting">App.PostDateComponent = Ember.Component.extend({
  formatedDate: function(){
    return moment(this.get('date')).fromNow();
  }.property('date')
});</pre></div><p class="calibre7">The dependent date property is then bound in the <code class="email">user-post</code> component as:</p><div><pre class="programlisting">{{post-date date=post.date}}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec80" class="calibre1"/>Customizing a component's element tag</h1></div></div></div><p class="calibre7">Since the <a id="id359" class="calibre1"/>W3C component specification is still being <a id="id360" class="calibre1"/>worked on, Ember.js components utilize the existing standard HTML elements. In <a class="calibre1" title="Chapter 3. Routing and State Management" href="part0029_split_000.html#page">Chapter 3</a>, <em class="calibre9">Routing and State Management</em>, we learned that a view's template is wrapped around an element, which by default is <code class="email">div</code>. This element can then be customized using the view's <code class="email">tagName</code> property. A component's template is also wrapped in the same way in a customizable element. For example, we promised to discuss how the <code class="email">post-input</code> component mentioned previously was rendered into DOM.</p><p class="calibre7">All we need to do is define the property in the corresponding class as:</p><div><pre class="programlisting">App.PostInputComponent = Ember.Component.extend({
  ...
  tagName: 'button',
  ...
});</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec81" class="calibre1"/>Customizing a component's element class</h1></div></div></div><p class="calibre7">Since<a id="id361" class="calibre1"/> components are views, their element's<a id="id362" class="calibre1"/> class can be specified statically or dynamically using the <code class="email">classNames</code> and <code class="email">classNameBindings</code> array properties on the component's class. For example, the <code class="email">post-input</code> component defines a static class as:</p><div><pre class="programlisting">App.PostInputComponent = Ember.Component.extend({
  classNames: ['post-input'],
});</pre></div><p class="calibre7">This results in the component being rendered as:</p><div><pre class="programlisting">&lt;button class='post-input'&gt;add&lt;/button&gt;</pre></div><p class="calibre7">In the sample application, we mentioned that users are able to rate uploaded photos. The <code class="email">user-post</code> component uses the <code class="email">post-rating</code> component that serves as the rating widget:</p><div><pre class="programlisting">{{post-rating content=post}}</pre></div><p class="calibre7">Each of the stars in the latter part is also a component (<code class="email">post-rating-item</code>) and is listed horizontally to compose the widget as:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/post-rating"&gt;
  &lt;ul&gt;
    {{#each rating in ratings}}
      &lt;li&gt;{{post-rating-item controller=post content=rating}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;</pre></div><p class="calibre7">As expected, the colored stars represent the range of the rating, and so, we use the <code class="email">active</code> class in this case to style them:</p><div><pre class="programlisting">App.PostRatingItemComponent = Ember.Component.extend({
  classNameBindings: ['active'],
  active: function() {
   ...
  }.property('parentView.selected'),
});</pre></div><p class="calibre7">This is an example of a dynamic class where the component will only acquire the class if the defined computed <code class="email">active</code> class evaluates to <code class="email">True</code>. We will discuss how this rating works in a later section, but one last thing to note is that in the case of dynamic classes, we can specify the class name to use. For example, we can implement the preceding case as:</p><div><pre class="programlisting">App.PostRatingItemComponent = Ember.Component.extend({
  classNameBindings: ['isActive:active'],
  isActive: function() {
   ...
  }.property('parentView.selected'),
});</pre></div><p class="calibre7">We<a id="id363" class="calibre1"/> can also implement it as:</p><div><pre class="programlisting">App.PostRatingItemComponent = Ember.Component.extend({
  classNameBindings: ['isActive:active:not-active'],
  isActive: function() {
   ...
  }.property('parentView.selected'),
});</pre></div><pre>not-active</code> class will be acquired by nonactive stars.</pre></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec82" class="calibre1"/>Customizing a component's element attributes</h1></div></div></div><p class="calibre7">A component's<a id="id365" class="calibre1"/> element attribute values can <a id="id366" class="calibre1"/>also be bound to properties using the <code class="email">attributeBindings</code> property. For example, consider our <code class="email">post-photo</code> component that displays the images as:</p><div><pre class="programlisting">App.PostPhotoComponent = Ember.Component.extend({
  tagName: 'img',
  classNames: ['avatar'], 
  attributeBindings: ['src'],
  src: Ember.computed.oneWay('photo')
});</pre></div><p class="calibre7">First, we use the <code class="email">tagName</code> property<a id="id367" class="calibre1"/> to specify that its element is an image tag. We also specify that this element will have an <code class="email">src</code> attribute that will be aliased to the bound <code class="email">photo</code> property. The <code class="email">user-post</code> component then uses this component to display the images as:</p><div><pre class="programlisting">{{post-photo photo=post.photo}}</pre></div><p class="calibre7">Be sure to compare how the following element concepts are customized across views, components, and even templates:</p><div><ul class="itemizedlist"><li class="listitem">Tag names</li><li class="listitem">Class attributes</li><li class="listitem">Attributes</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec83" class="calibre1"/>Managing events in components</h1></div></div></div><p class="calibre7">Just like <a id="id368" class="calibre1"/>views, components can catch user-generated <a id="id369" class="calibre1"/>events such as those from the keyboard, mouse, and touch devices.</p><p class="calibre7">There are two ways in which the handlers to these events can be defined, the first of which is to attach the <code class="email">.on</code> function to the event-subscriber method. For example, the <code class="email">post-input</code> component uses this function to define two handlers. This button component<a id="id370" class="calibre1"/> implements a file-picker dialog that can be opened from an invisible file input, as described at <a class="calibre1" href="https://github.com/component/file-picker">https://github.com/component/file-picker</a>. As soon as the component gets rendered, the event is fired, which results in the hidden form element containing a single input file to be appended into DOM as:</p><div><pre class="programlisting">createHiddenForm: function(){
  var tmpl = [
    '&lt;form class="post-input-form"&gt;',
    '&lt;input type="file" style="top: -1000px; position: absolute" aria-hidden="true"&gt;',
    '&lt;/form&gt;'
  ].join('');

  Em.$('body').append(Em.$(tmpl));
}.on('didInsertElement'),</pre></div><p class="calibre7">This form will be used later to upload the images. Next, we define the handler that will initiate the file dialog to open. Note that we use the <code class="email">.on</code> method to subscribe to the button's click event:</p><div><pre class="programlisting">upload: function(){
  ...
}.on('click')</pre></div><p class="calibre7">Inside this handler, we set up a listener that will get invoked when the user selects an image file, as shown:</p><div><pre class="programlisting">var input = Em.$('.post-input-form input');
input.one('change', upload);</pre></div><p class="calibre7">Here is the handler which does the upload:</p><div><pre class="programlisting">function upload(event){

  var file = input[0].files[0];
  var reader = new FileReader;
  reader.onload = post.bind(this, reader);
  reader.readAsDataURL(file);

};</pre></div><pre>FileReader</code> instance and pass the uploaded image to it. We then read the <code class="email">dataUrl</code> representation of the image, which then gets sent to the final bound handler:</pre><div><pre class="programlisting">    function post(reader){

      var data = {
        photo: reader.result,
        date: new Date
      }
      self.get('posts').pushObject(data);

    }</pre></div><p class="calibre7">This<a id="id371" class="calibre1"/> last handler adds the image to the photo controller <a id="id372" class="calibre1"/>as a new post. Note that we don't check the mime type of the uploads, so the user might upload other media types, such as videos. This check is left out as an implementation exercise to the reader.</p><p class="calibre7">Secondly, we subscribe to these events to implement a method whose name corresponds to the target event, as shown by the rating widget component previously discussed. This component keeps count of the following two properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">selected</code>: This is the selected/hovered star position</li><li class="listitem"><code class="email">_selected</code>: This is the cached position of the last clicked star</li></ul></div><p class="calibre7">We mentioned that the widget is composed of the <code class="email">post-rating-item</code> components that represent each of the stars. When the user hovers over any of them, we updated the <code class="email">selected</code> property of the parent component as:</p><div><pre class="programlisting">  mouseEnter: function(e) {
    var selected = this.get('content');
    this.set('parentView.selected', selected);
  }</pre></div><p class="calibre7">As shown, we defined a method that corresponded to the <code class="email">mouseEnter</code> event. This handler sets the <code class="email">active</code> property of all the rating item components to the left to <code class="email">True</code>, since the trick here is to apply the style, as expected, to all stars to the left-hand side of the currently selected one:</p><div><pre class="programlisting">  classNameBindings: ['active'],

  active: (function() {
    var content = this.get('content');
    var selected = this.get('parentView.selected');
    return ~~content &lt;= ~~selected;
  }).property('parentView.selected'),</pre></div><p class="calibre7">On the other hand, those to the right-hand side lose the <code class="email">active</code> class because their <code class="email">active</code> property gets recalculated to <code class="email">False</code>.</p><p class="calibre7">If the <a id="id373" class="calibre1"/>user doesn't click on any of the stars, they expect the <a id="id374" class="calibre1"/>earlier rating to be restored. Therefore, leaving the currently focused component uses the cached <code class="email">_selected</code> property to reset the <code class="email">selected</code> property, as shown in the following code:</p><div><pre class="programlisting">  mouseLeave: function(e) {
    var selected = this.get('parentView._selected');
    this.set('parentView.selected', selected);
  }</pre></div><p class="calibre7">Again, we only need to implement the <code class="email">mouseLeave</code> event hook. Lastly, clicking on any of the components gives us the actual rating:</p><div><pre class="programlisting">  click: function(e){
    var content = this.get('content');
    this.set('parentView.selected', content);
    this.set('parentView._selected', content);
  }</pre></div><p class="calibre7">Note that we cache the <code class="email">_selected</code> property of the parent component since this will be used in the preceding checks. The <code class="email">active</code> class updates the components state appropriately as:</p><div><pre class="programlisting">.rating:before{
  content: "☆"
}

.rating.active:before{
  content:"★"
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec84" class="calibre1"/>Defining component actions</h1></div></div></div><p class="calibre7">We <a id="id375" class="calibre1"/>mentioned that components define classes that act as their controllers that are isolated from the rest of the application. For example, an application controller cannot define a component class as a dependency in its <code class="email">needs</code> property. However, since they are considered as controllers, they can define handlers to action expressions defined in their corresponding templates in an <code class="email">actions</code> object property. For example, let's define a message box component that can be used in any application that needs to implement the chat functionality:</p><div><pre class="programlisting">{{! template }}]
&lt;form {{action 'save' on='submit'}}&gt;

  {{input value=message}}
&lt;/form&gt;
 
// component classApp.MessageBoxComponent = Ember.Component.extend({
  message: '',
  classNames: ['message-box'],
  actions: {
    save: function(){
      var message = this.get('message').trim();
      if (message === '') return;
      var content = this.get('content');
      content.pushObject(message);
      this.set('message', '');
    }
  }
});</pre></div><p class="calibre7">To use<a id="id376" class="calibre1"/> this component, one simply needs to provide the <code class="email">Messages</code> container in which new messages will be stored. Here's a possible example:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="messages"&gt;
  &lt;h1&gt;Messages&lt;/h1&gt;
  &lt;ul&gt;
    {{#each model}}
      &lt;li&gt;{{this}}&lt;/li&gt;
   {{/each}}
  &lt;/ul&gt;
  &lt;div&gt;{{message-box content=model}}&lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">The component form defines an action that binds the <code class="email">save</code> action handler of the component class to the form's <code class="email">submit</code> event. When the user submits the form by hitting the <em class="calibre9">Enter</em> key, the handler sanitizes the message before pushing it to the provided container. You'll realize that these actions are similar to the ones we learned earlier in <a class="calibre1" title="Chapter 4. Writing Application Templates" href="part0044_split_000.html#page">Chapter 4</a>, <em class="calibre9">Writing Application Templates</em>. However, there's no event bubbling in components. A failure to locate the handler in the class will lead to an appropriate error being thrown.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec85" class="calibre1"/>Interfacing a component with the rest of the application</h1></div></div></div><p class="calibre7">Components, as mentioned earlier, are not completely sandboxed, but they can interact with the rest of the application in the following ways:</p><div><ul class="itemizedlist"><li class="listitem">Bind to properties</li><li class="listitem">Send actions</li></ul></div><p class="calibre7">We have <a id="id377" class="calibre1"/>already seen how components are able to bind to other application properties by passing the properties in the template expressions:</p><div><pre class="programlisting">  {{post-input posts=model}}</pre></div><p class="calibre7">Components also have the ability to send their actions to controllers in an application. To demonstrate this, let's create a simple checkout button for an e-commerce site:</p><div><pre class="programlisting">{{! template}}
&lt;script type="text/x-handlebars" id="components/checkout-button"&gt;
add to cart
&lt;/script&gt;

// add to cart component
App.CheckoutButtonComponent = Ember.Component.extend({
  tagName: 'button',
  click: function(){
    this.sendAction();
  }
}); 

{{! cart template}}
&lt;ul&gt;
{{#each products}}
&lt;li&gt;
  {{name}}
  {{price}}
  {{checkout-button}}
&lt;/li&gt;
&lt;/ul&gt;

// cart controller
App.CartController = Ember.ArrayController.extend({
  actions: {
    click: function(product){
      this.pushObjects(product);
    }
  }
});</pre></div><p class="calibre7">In the preceding example, we intend to add a product to cart whenever its corresponding checkout<a id="id378" class="calibre1"/> button is clicked via an event handler. We utilize the component's <code class="email">sendAction</code> method to bubble this action to the parent controller. However, there are two things we need to fix in order to realize this. First, we need to rename our event handler in the controller to something descriptive. Moreover, the same <code class="email">click</code> event handler can catch events from other elements as:</p><div><pre class="programlisting">// cart controller
App.CartController = Ember.ArrayController.extend({
  actions: {
    addToCart: function(product){
      this.pushObjects(product);
    }
  }
});</pre></div><p class="calibre7">Next, we need to send the selected product to the <code class="email">addToCart</code> handler with a little modification of the template:</p><div><pre class="programlisting">{{! cart template}}
&lt;ul&gt;
{{#each products}}
&lt;li&gt;
  {{name}}
  {{price}}
  {{checkout-button product=this action='addToCart'}}
&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre7">This just lets the component be able to access the product. Finally, we send the product to the controller event handler as:</p><div><pre class="programlisting">// add to cart component
App.CheckoutButtonComponent = Ember.Component.extend({
  tagName: 'button',
  template: Ember.Handlebars.compile('add to cart'),
  click: function(){
    this.sendAction('action', this.get('product'));
  }
});</pre></div><p class="calibre7">Note that the first argument to <code class="email">sendAction</code> is always <code class="email">action</code> followed by the object(s) we wish to send.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec86" class="calibre1"/>Components as layouts</h1></div></div></div><p class="calibre7">A<a id="id379" class="calibre1"/> component's template can act as a layout for <a id="id380" class="calibre1"/>other application templates. These layouts are not specified in the view layer; they use block expressions instead. Additional content can then be inserted inside these templates without losing scope. For example, imagine we wish to create a component that will use the <code class="email">content-editable</code> element. This kind of component will need to wrap a section of some HTML content as:</p><div><pre class="programlisting">{{#content-editable}}
&lt;p&gt;Tweet content&lt;/p&gt;
{{/content-editable}}</pre></div><p class="calibre7">As shown, the component uses custom Handlebars tags that match its namespaced template name. The content inside and outside the component will still enjoy the same scope. Can you guess how this component will be implemented? One implementation will be to turn the wrapped content into <code class="email">content-editable</code> when double-clicked or focused, and back to <code class="email">div</code> when the mouse leaves the element as:</p><div><pre class="programlisting">App.ContentEditableComponent = Ember.Component.extend({
  attributeBindings: ['isEditing:contenteditable'],
  doubleClick: function(){
    this.set('isEditing', true);
  }
  focusOut: function(){
    this.set('isEditing', false);
  }
});</pre></div><p class="calibre7">The two event-defined handlers toggle the <code class="email">isEditing</code> property, which then results in the <code class="email">content-editable</code> attribute to be added or removed from the element accordingly.</p><p class="calibre7">To make things a little interesting, imagine we want to upgrade our <code class="email">content-editable</code> component into a WYSIWYG editor. We will need to define a template that is used to host the different controls to manipulate the content, as shown in the following example:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="components/content-editable"&gt;
  &lt;div class="controls-toolbar"&gt;
    &lt;button&gt;bold&lt;/button&gt;
    &lt;button&gt;italic&lt;/button&gt;
    &lt;button&gt;underline&lt;/button&gt;
    &lt;button&gt;strike-through&lt;/button&gt;
  &lt;/div&gt;
  &lt;div class="content"&gt;
    {{yield}}
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">First, we define a toolbar that will house standard editor controls. We can bind action handlers, as <a id="id381" class="calibre1"/>discussed in the previous sections, to<a id="id382" class="calibre1"/> perform the manipulations; this will be a worthy attempt by the reader. In the content section, we use the <code class="email">yield</code> expression we discussed in the previous chapter to tell the component to render the wrapped content in this portion of the template. With this powerful feature, both the component and the wrapped content can define expressions that bind to isolated contexts.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec87" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">You'll find components useful when you want to modularize your application. There are various open source tools that will enable you to ship these components to your application. In the last chapter of this book, we will learn how to ship these components and mixins into your application using the component's (<a class="calibre1" href="http://github.com/component">http://github.com/component</a>) asset manager and build. Therefore, it's best practice to abstract modular objects in your application into either mixins or components. The following are some of the things we learned about components:</p><div><ul class="itemizedlist"><li class="listitem">Defining components</li><li class="listitem">Customizing component elements and attributes</li><li class="listitem">Managing actions inside components</li><li class="listitem">Interfacing components with the rest of the application</li></ul></div><p class="calibre7">In the next chapter, we will learn how to sync data between Ember.js applications and REST backends. We will particularly learn how to use Ember.js data to simplify this need.</p></div></body></html>