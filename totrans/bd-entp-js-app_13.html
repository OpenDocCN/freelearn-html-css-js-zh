<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Documenting Our API</h1>
                </header>
            
            <article>
                
<p>So far, we have followed a test-driven approach to developing our User Directory application. We started by writing <strong>End-to-End</strong> (<strong>E2E</strong>) tests and using them to drive the development of our implementation code, and then added unit tests to catch regressions. We have also discussed that writing tests is the best form of documentation, since it provides actual examples of how to interact with our API.</p>
<p>While our test suite is the most accurate and best form of documentation, providers of all major APIs also maintain browser-based API documentation that your end users can access as a web page/site. This is because:</p>
<ul>
<li>Not all APIs are open-sourced, so developers may not always have access to the tests.</li>
<li>It may require a lot of time and effort to understand the test suite.</li>
<li>Tests lack <em>context</em>—you know how to call an endpoint, but you will have to figure out for yourself how it fits into the workflow of an application.</li>
<li><span>It is language- and framework-specific—the browser-based documentation describes the interface of the API, not the implementation. It doesn't matter if our API is implemented in Express, Restify, Hapi, or in Python or Go. The end user does not need to understand JavaScript in order to understand this form of documentation.</span></li>
</ul>
<p>If we simply provided the test suite for our end users without further guidance, they are likely to be deterred by the steep learning curve and decide to use an alternative service. Therefore, we must provide more user-friendly API documentation.</p>
<p>An API documentation describes, with examples, the functionality of each endpoint, and the constraints when calling them. Good API documentation usually:</p>
<ul>
<li>Provides a high-level overview of our API, including:
<ul>
<li>A brief overview of the platform</li>
<li>Example use cases</li>
<li>Where to find more resources and/or receive support</li>
</ul>
</li>
</ul>
<ul>
<li>Includes a <span>concise step-by-step guide</span>d tour on how to perform common scenarios (e.g. create a user, and then log in); that is, which API calls needs to be made, and in what order.</li>
<li>Includes an API Specification, which provides technical references of each endpoint—what parameters are allowed and in which format.</li>
</ul>
<p>Authoring of the high-level overview and the guided tour falls under the scope of a Technical Writer. But what makes a good piece of technical writing is beyond the scope of this book; i<span>nstead, we will focus on how to write a good API specification. </span>Specifically, we will be using the OpenAPI API specification language to write our API specification, and then use a set of tools called Swagger to generate an interactive browser-based API reference.</p>
<p>By following this chapter, you will:</p>
<ul>
<li>Learn about the <strong>OpenAPI Specification</strong> (<strong>OAS</strong>)</li>
<li>Write your own OpenAPI specification in <strong>YAML</strong></li>
<li>Use <strong>Swagger UI</strong> to generate web-based API documentation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of OpenAPI and Swagger</h1>
                </header>
            
            <article>
                
<p class="mce-root">An <strong>API description language</strong> (or <strong>API description format</strong>) is a standard format for describing APIs. For example, the snippet below informs the consumers of our API that they need to provide a JSON payload with an <kbd>email</kbd> and <kbd>digest</kbd> field when calling the <kbd>POST /login</kbd> endpoint. In return, they can expect our API to respond with one of the four listed status codes:</p>
<pre>paths:<br/>  /login:<br/>    post:<br/>      requestBody:<br/>        description: User Credentials<br/>        required: true<br/>        content:<br/>          application/json:<br/>            schema:<br/>              properties:<br/>                email:<br/>                  type: string<br/>                  format: email<br/>                digest:<br/>                  type: string<br/>                  pattern: ^\\$2[aby]?\\$\\d{1,2}\\$[.\\/A-Za-z0-9]{53}$<br/>      responses:<br/>        '200':<br/>          $ref: '#/components/responses/LoginSuccess'<br/>        '400':<br/>          $ref: '#/components/responses/ErrorBadRequest'<br/>        '401':<br/>          $ref: '#/components/responses/ErrorUnauthorized'<br/>        '500':<br/>          $ref: '#/components/responses/ErrorInternalServer'</pre>
<p class="mce-root">There are several benefits to writing an API specification:</p>
<ul>
<li>The specification acts as a contract between our platform and the end consumers, which may not be limited to just developers, but also other internal APIs as well. Having a contract means consumers of our API are able to develop their integrations before our API is complete—because we have agreed, through the specification, how our API should behave—as long as everyone stays faithful to the API specification, the integration will be successful.</li>
<li>It forces us to design the interface.</li>
<li>We can create mock servers. These mock servers mimic the behavior of the real API server, but responds with canned responses instead. We can provide this mock server for end consumers before our API is complete, so they'll know how our API should respond.</li>
<li><span>Using </span>open source tools (such as Dredd—<a href="http://dredd.org/en/latest/">dredd.org</a>), we can automatically test our API server to see if it complies with the specification.</li>
<li>Using tools that integrate with our API server, we can use the specification to validate requests and responses automatically, without having to write extra validation code.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Picking an API specification language</h1>
                </header>
            
            <article>
                
<p><span>The preceding example uses a standard called </span><strong>OpenAPI</strong><span> (formerly </span><strong>Swagger</strong><span>). At the time of writing, there are two other popular API specification languages out there, namely </span><strong>RAML</strong><span> and </span><strong>API Blueprint</strong><span>. Before we go any further, it's important to note that each language has its own set of limitations in terms of how accurately it can describe an existing API, or the comprehensiveness of the tooling surrounding it. Out of the three, however, OpenAPI is the most mature and has the best community support, and it's what we will be using in this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger vs OpenAPI</h1>
                </header>
            
            <article>
                
<p>When reading articles online, you'll often hear the terms Swagger and OpenAPI used interchangeably. So, before we continue, let's clarify these terms.<span> </span><em>Swagger</em><span> </span>began in 2011 as a set of tools that allow developers to represent API as code, in order to automatically generate documentation and client SDKs. Swagger has since undergone two major versions (1.0 and 2.0). After the release of Swagger 2.0, the rights to Swagger were bought by SmartBear Software, who decided to donate the rights of the specification format to the Linux Foundation, under the OpenAPI Initiative.</p>
<p>On 1 January 2016, the Swagger specification was renamed to the<span> </span><em>OpenAPI Specification</em><span> </span>(OAS). Since then, a newer version, 3.0.0 of OAS, has been released.</p>
<div class="packt_infobox"><span>OAS 2.0 is identical to Swagger 2.0 apart from the name.</span></div>
<p>However, although the specification has been renamed to OAS, the tooling around the specification is still developed and maintained by SmartBear Software; therefore, you may hear developers talk about both Swagger and OpenAPI at the same time.</p>
<p>In short, OpenAPI is the specification language itself, while Swagger is a set of tools that work with and around an OpenAPI specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger Toolchain</h1>
                </header>
            
            <article>
                
<p>So let's examine the Swagger Toolchain in more detail. Swagger<span> </span>is a set of developer tools that are useful across the entire API lifecycle, and includes the following:</p>
<ul>
<li><strong>Swagger Editor</strong>: A split-screen editor that allows you to write your specification on one side, and provide real-time feedback on the other</li>
<li><strong>Swagger UI</strong>: Generates documentation in HTML format from your specification file</li>
<li><strong>Swagger Codegen</strong>: Generates Client SDKs in multiple languages, allowing developers to easily interact with your API without calling the endpoints directly</li>
<li><strong>Swagger Inspector</strong>: Allows you to test your endpoints</li>
</ul>
<p>Apart<span> </span>from the official tools developed and maintained by SmartBear Software, there are also numerous community-contributed packages and frameworks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger Editor</h1>
                </header>
            
            <article>
                
<p>Swagger Editor is like your code editor for specification. It provides real-time validation, code auto-completion, code highlighting and a preview of the output documentation. Here's a screenshot of Uber's API:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59c03172-1803-4689-841c-78b741f59840.png" style="width:31.75em;height:47.83em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger UI</h1>
                </header>
            
            <article>
                
<p>Swagger UI is a self-contained, frontend application that renders an interactive documentation from your specification. All you have to do is provide a public URL to the OpenAPI specification, and Swagger UI will do the rest. Following is a screenshot of the sample Swagger Petstore documentation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a22b63f8-7aeb-40c1-b92d-2c044084b3aa.png" style="width:31.42em;height:47.33em;"/></div>
<p>The interactive documentation also has a<span> </span><span><span class="packt_screen">Try it now</span> button, which</span> allows you to send real requests to the server and view the results, all without leaving the documentation page. This streamlines the workflow of our end users as they don’t have to open external tools like Postman and/or Paw:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/509f74aa-7a7b-456c-a82a-6a0bd614bac9.png" style="width:49.33em;height:47.50em;"/></div>
<p>You<span> </span>can try out a live demo at<span> </span><a href="http://petstore.swagger.io/">petstore.swagger.io</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger Inspector</h1>
                </header>
            
            <article>
                
<p>Swagger Inspector is like Postman for Swagger—it allows you to call and validate REST, GraphQL, and SOAP APIs. Like Postman, it saves a history of your past queries. Furthermore, it can automatically generate a specification from the results returned from the inspection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger codegen</h1>
                </header>
            
            <article>
                
<p>Swagger is able to use your API specification to generate server stubs and client SDKs. There are many languages/frameworks supported by Swagger Codegen. You may use the server stubs as <span>boilerplate for the API you are about to build, or as</span><span> a mock server to showcase how the API should behave. You may also use the generated </span>client SDKs as the foundation and build upon it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining an API specification with OpenAPI</h1>
                </header>
            
            <article>
                
<p>Now that we understand what an API specification and the OpenAPI standard are, as well as the tooling provided by Swagger, let's begin the documentation process by writing the specification for our API. We'll start by creating a file new at <kbd>src/spec/openapi/hobnob.yaml</kbd>:</p>
<pre><strong>$ mkdir -p spec/openapi</strong><br/><strong>$ touch spec/openapi/hobnob.yaml</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning YAML</h1>
                </header>
            
            <article>
                
<p>The first thing to know is that an OpenAPI specification must be a valid JSON document. The specification also explicitly allows YAML, which is a superset of JSON and can be converted to JSON. We will be using YAML because it is more readable (and thus writable) by humans, even for non-developers. Furthermore, you can add comments inside YAML files, something that's not possible with JSON.</p>
<p>Let's start by learning the basics of YAML. We only need to learn a few basic pieces of syntax to write our OpenAPI specification.</p>
<p>Like JSON, getting started with the basic syntax for YAML is very simple. All YAML documents start with three dashes (<kbd>---</kbd>) to indicate the start of the file, and three periods (<kbd>...</kbd>) to indicate the end of the file.</p>
<p>Typically, the most common data structures you need to represent in a configuration file are key-value pairs and lists. To represent a set of key-value pairs, simply write each one on a new line, separated by a colon and space:</p>
<pre># YAML<br/>title: Hobnob<br/>description: Simple publishing platform<br/><br/># JSON<br/>{<br/>  "title": "Hobnob",<br/>  "description": "Simple publishing platform"<br/>}</pre>
<div class="packt_infobox">Generally, you do not need to use quotes unless you use a special character, or need to be explicit about the data type (for example,<span> </span><kbd>10</kbd> may be interpreted as a number, and<span> </span><kbd>yes</kbd><span> </span>may be interpreted as<span> </span><kbd>true</kbd>). For simplicity's and consistency's sake, you may want to use double quotes for all your strings, but we won't do that here.</div>
<p>To represent nested objects, simply indent the child object by two spaces:</p>
<pre># YAML<br/>info:<br/>  title: Hobnob<br/>  description: Professional publishing platform<br/><br/># JSON<br/>{<br/>  "info": {<br/>    "title": "Hobnob",<br/>    "description": "Professional publishing platform"<br/>  }<br/>}</pre>
<p>To represent a list, place each item on a new line, preceded by a dash and a space:</p>
<pre># YAML<br/>produces:<br/>- application/json<br/>- text/html<br/><br/># JSON<br/>{<br/>  "produces": [<br/>    "application/json",<br/>    "text/html"<br/>  ]<br/>}</pre>
<p>To conserve newline characters, use the pipe (<kbd>|</kbd>) character:</p>
<pre># YAML<br/>info:<br/>  title: Hobnob<br/>  description: |<br/>    The professional user directory.<br/><br/>    Find like-mind professionals on Hobnob!<br/><br/># JSON<br/>{<br/>  "info": {<br/>    "title": "Hobnob",<br/>    "description": "The professional user directory.\n\nFind like-mind professionals on Hobnob!\n"<br/>  }<br/>}</pre>
<p>Or to break a line of text over multiple lines (to make it easier to read), which shouldn't preserve newlines, use the greater-than character (<kbd>&gt;</kbd>):</p>
<pre># YAML<br/>contact:<br/>  name: &gt;<br/>    Barnaby Marmaduke Aloysius Benjy Cobweb Dartagnan Egbert Felix Gaspar <br/>    Humbert Ignatius Jayden Kasper Leroy Maximilian Neddy Obiajulu Pepin <br/>    Quilliam Rosencrantz Sexton Teddy Upwood Vivatma Wayland Xylon Yardley <br/>    Zachary Usansky<br/><br/># JSON<br/>{<br/>  "contact": {<br/>    "name": "Barnaby Marmaduke Aloysius Benjy Cobweb Dartagnan Egbert Felix Gaspar Humbert Ignatius Jayden Kasper Leroy Maximilian Neddy Obiajulu Pepin Quilliam Rosencrantz Sexton Teddy Upwood Vivatma Wayland</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre> Xylon Yardley Zachary Usansky\n"<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the root fields</h1>
                </header>
            
            <article>
                
<p>Now that we understand the basics of YAML, we're ready to write our specification.</p>
<p><span>There are a few versions of the OpenAPI Specification available. At the time of writing this book, the OpenAPI Specification is at version</span><span> </span><kbd>3.0.0</kbd><span> and was officially released on 26 July 2017. You may also find many OpenAPI 2.0 specifications in the wild as tooling support for 3.0.0 is lacking in many areas.</span></p>
<p>We will use OAS 3.0.0 as it is the latest version. Here, you'll find an overview of all the possible root properties in OAS 3.0.0. Not all fields are covered, and required fields are marked with an asterisk (<kbd>*</kbd>):</p>
<ul>
<li><kbd>openapi*</kbd><span> </span>(string): This specifies the OpenAPI specification version in use. We should specify the semver version; for us, we will use <kbd>"3.0.0"</kbd>.</li>
<li><kbd>info*</kbd> (object): Metadata about the API.
<ul>
<li><kbd>version*</kbd> (string): The version of the API this specification is written for.<span> </span><strong>Please note that this is the version of the API itself, not the OpenAPI Specification.</strong></li>
<li><kbd>title*</kbd> (string): The name of your API.</li>
<li><kbd>description</kbd> (string): A short description of your API.</li>
<li><kbd>contact</kbd> (object): Information regarding whom to contact for support.
<ul>
<li><kbd>name</kbd> (string): The name of the person/department/organization to contact.</li>
<li><kbd>url</kbd><span> (string): A valid URL pointing to a page with contact information.</span></li>
<li><kbd>email</kbd><span> (string): A valid email address where inquiries can be sent.</span></li>
</ul>
</li>
<li><kbd>termsOfService</kbd> (string): A valid URL pointing to the Terms of Service notice for the API.</li>
<li><kbd>license</kbd> (object): License information of the API.
<ul>
<li><kbd>name*</kbd> (string): Name of the license.</li>
<li><kbd>url</kbd> (string): A valid URL pointing to the license.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><kbd>servers</kbd> (array of objects) A list of servers that are serving the API. This is an improvement on the OAS 2.0 root fields <kbd>host</kbd> and <kbd>basePath</kbd>, as it allows for multiple hosts to be specified.
<ul>
<li><kbd>url*</kbd> (string): A valid URL to the target host. This may be a relative URL, relative from the location at which the OpenAPI specification is being served.</li>
<li><kbd>description</kbd> (string): A short description of the host. This is useful for distinguishing between different hosts if multiple are specified.</li>
</ul>
</li>
<li class="mce-root"><kbd>paths*</kbd><span> (object): All paths and operations (such as endpoints) are exposed by the API. The paths object is a dictionary of paths (for example,</span><span> </span><kbd>/users</kbd><span>) and</span> <em>Path Item Objects</em><span>. A Path Item Object is a dictionary of (mostly) HTTP verbs (for example,</span><span> </span><kbd>post</kbd><span>) and</span> <em>Operation Objects</em><span>. The Operation Object is the one that defines the behavior of the endpoint, such as what parameters it accepts and the type of responses it emits:</span></li>
</ul>
<pre style="color: black;padding-left: 90px">paths:<br/>  /users:  # Path<br/>    post:  # Operation<br/>      ...  # Operation Object</pre>
<ul>
<li><kbd>components</kbd> (object): This holds a set of reusable objects to be reused. The purpose of components is to minimize duplication within the specification. For example, if <em>multiple</em> endpoints may return a <kbd>401 Unauthorized</kbd> error with the message <kbd>"The Authorization header must be set"</kbd>, we can define a component called <kbd>NoAuthHeaderSet</kbd>, and reuse this object in place of the response definition. Components can be referenced from other parts of the specification later using JSON references (<kbd>$ref</kbd>).<br/>
<br/>
<span>In OAS 2.0, the components root field did not exist; instead, the <kbd>definitions</kbd>, <kbd>parameters</kbd>, and <kbd>responses</kbd> root fields were used. In OAS 3.0.0, components are not limited to data types (or schema), parameters and responses, but also examples, request bodies, headers, security schemes, links, and callbacks.</span></li>
<li><kbd>security</kbd> (array of objects): A list of <em>Security Requirement Objects</em> that are acceptable across the whole API. A Security Requirement Object is <span>a dictionary of security schemes that are common across different operations. For example, we require that the client provides a valid token on many endpoints; therefore, we can define that requirement here, and apply it in a DRY manner within each definition. For endpoints that do not require a token, we can override this requirement on an individual basis.</span></li>
</ul>
<ul>
<li><kbd>tags</kbd> (array of strings): You can group operations using tags by specifying a list of strings inside the Operation Object. Tools, such as Swagger UI, may use these tags to group related endpoints together. The root<span> </span><kbd>tags</kbd><span> </span>property provides metadata (e.g. long description) on those tags.</li>
<li><kbd>externalDocs</kbd> (object): Additional external documentation.</li>
</ul>
<p>Now that you have a brief overview of the root fields, let's begin composing our specification. To ease ourselves into it, we will start by defining the simpler fields like <kbd>info</kbd>, then moving on to endpoints that do not require authentication. Once we are more comfortable, we will define security schemes and security requirements and add the specification for endpoints that require authentication.</p>
<p>To get started, add the following metadata to <kbd>spec/openapi/hobnob.yaml</kbd>.</p>
<pre>openapi: "3.0.0"<br/>info:<br/>  title: Hobnob User Directory<br/>  version: "1.0.0"<br/>  contact:<br/>    name: Support<br/>    email: dan@danyll.com<br/>servers:<br/>  - url: http://localhost:8080/<br/>    description: Local Development Server<br/>tags:<br/>  - name: Authentication<br/>    description: Authentication-related endpoints<br/>  - name: Users<br/>    description: User-related endpoints<br/>  - name: Profile<br/>    description: Profile-related endpoints</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the GET /salt endpoint</h1>
                </header>
            
            <article>
                
<p>To ease our way into composing the full API specification, let's start with the simplest endpoint—<kbd>GET /salt</kbd>. To start off, we will add the <kbd>paths</kbd> root property, specify the path we are defining (<kbd>/salt</kbd>), and then the operation (<kbd>get</kbd>):</p>
<pre>paths:<br/>  /salt:<br/>    get:</pre>
<p>Under the <kbd>get</kbd> property, we will define an <em>operation object</em>. The full specification for the Operation Object can be found at <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object">github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#operation-object</a>. For our use cases, we are concerned with the following properties:</p>
<ul>
<li><kbd>tags</kbd>: This is used to logically group operations when displayed with Swagger UI.</li>
<li><kbd>summary</kbd>: A short summary of what the operation does.</li>
<li><kbd>description</kbd>: A more verbose description of the operation, which may include nuances that a developer might need to be aware of.</li>
<li><kbd>parameters</kbd>: A <em>parameter object</em> that describes what parameters are allowed/required, and how these parameters should be provided (such as URL parameters, query strings, headers, or cookies).</li>
<li><kbd>requestBody</kbd>: A <em>request body object</em> that describes the body of the request, if any. It describes what types of payloads are allowed (for example, <kbd>application/json</kbd>, <kbd>text/plain</kbd>), and, if it is an object, <span>what data type and formats each property should be.</span></li>
<li><kbd>responses</kbd>: A <em>Responses Object</em> that describes all possible responses this endpoint can produce.</li>
</ul>
<p>So, let's start with the simpler fields: <kbd>tags</kbd>, <kbd>summary</kbd>, and <kbd>description</kbd>:</p>
<pre>paths:<br/>  /salt:<br/>    get:<br/>      tags:<br/>        - Authentication<br/>      summary: Returns the salt of a user based on the user's email<br/>      description: Even if there are no users with the specified email, this endpoint will still return with a salt. This is to prevent the API leaking information about which email addresses are used to register on the platform.</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying parameters</h1>
                </header>
            
            <article>
                
<p>Our Get Salt endpoint does not accept any request bodies, but it does require a query string parameter called <kbd>email</kbd>, which must be set to a valid email address. Therefore, we must define a <kbd>parameters</kbd> property, containing a list of <em>parameter objects</em>. Each Parameter Object can contain the following properties:</p>
<ul>
<li><kbd>name*</kbd> (string): The name of the parameter</li>
<li><kbd>in*</kbd> (string): Where the parameter is specified. Possible values are <kbd>query</kbd>, <kbd>header</kbd>, <kbd>path</kbd>, or <kbd>cookie</kbd>.</li>
<li><kbd>required</kbd> (boolean): Whether the parameter is required.</li>
<li><kbd>schema</kbd> (object): This describes the structure of the parameter:</li>
</ul>
<pre>paths:<br/>  /salt:<br/>    get:<br/>      ...<br/>      parameters:<br/>      - name: email<br/>        in: query<br/>        description: The email of the user to retrieve the salt for<br/>        required: true<br/>        schema:<br/>          type: string<br/>          format: email</pre>
<div class="packt_infobox"><span>You might have noticed that the OpenAPI syntax for defining schema looks a lot like JSON Schema. This is because OpenAPI Specification is actually based on the first drafts of the JSON Schema specification.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying responses</h1>
                </header>
            
            <article>
                
<p>Next, we need to specify what our endpoint can potentially respond with. This is a required field for all operation objects. The responses Object is a map of numeric HTTP status codes and a <em>response object</em>, which should contain two fields:</p>
<ul>
<li><kbd>description</kbd><span>:</span> A short description of the payload</li>
<li><kbd>content</kbd> (object): This specifies the valid MIME types <span>(for example, </span><kbd>application/json</kbd><span>, </span><kbd>text/plain</kbd><span>) </span>that are acceptable for this endpoint, as well as the expected structure of the payload:</li>
</ul>
<pre>paths:<br/>  /salt:<br/>    get:<br/>      ...<br/>      responses:<br/>        '200':<br/>          description: Salt Retrieved<br/>          content:<br/>            text/plain:<br/>              schema:<br/>                type: string<br/>        '400':<br/>          description: Email query parameter not specified<br/>          content:<br/>            application/json:<br/>              schema:<br/>                properties:<br/>                  message:<br/>                    description: Error message<br/>                    type: string<br/>        '500':<br/>          description: Internal Server Error<br/>          content:<br/>            application/json:<br/>              schema:<br/>                properties:<br/>                  message:<br/>                    description: Error message<br/>                    type: string</pre>
<p><span>To make sure that we haven't forgotten any responses, we can check our request handler (</span><kbd>src/handlers/auth/salt/retrieve/index.js</kbd><span>), our middleware, as well as our E2E tests.</span></p>
<p>We have now defined the Get Salt endpoint with the OpenAPI specification language. Let's move on to a slightly more complicated endpoint—Create User—and see how we can specify payload bodies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the Create User endpoint</h1>
                </header>
            
            <article>
                
<p>Using what you've just learned, specify a new path, operation, and operation object for the Create User endpoint, filling in the <kbd>tags</kbd>, <kbd>summary</kbd>, <kbd>description,</kbd> and <kbd>responses</kbd> properties. You should end up with something like this:</p>
<pre>paths:<br/>  /users:<br/>    post:<br/>      tags:<br/>        - Users<br/>      summary: Creates a New User<br/>      responses:<br/>        '201':<br/>          description: Created<br/>          content:<br/>            text/plain:<br/>              schema:<br/>                type: string<br/>        '400':<br/>          description: Bad Request<br/>          content:<br/>            application/json:<br/>              schema:<br/>                properties:<br/>                  message:<br/>                    description: Error message<br/>                    type: string<br/>        '415':<br/>          description: Unsupported Media Type<br/>          content:<br/>            application/json:<br/>              schema:<br/>                properties:<br/>                  message:<br/>                    description: Error message<br/>                    type: string<br/>        '500':<br/>          description: Internal Server Error<br/>          content:<br/>            application/json:<br/>              schema:<br/>                properties:<br/>                  message:<br/>                    description: Error message<br/>                    type: string</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the request body</h1>
                </header>
            
            <article>
                
<p>Our Create User endpoint does not accept any parameters, but it does require a JSON payload that conforms to our User schema. Therefore, we should add a new<span> </span><kbd>requestBody</kbd><span> </span>field inside our Operation Object to define this requirement.</p>
<p>The value of the<span> </span><kbd>requestBody</kbd><span> </span>field should contain three fields:</p>
<ul>
<li><kbd>description</kbd>: A short description of the payload.</li>
<li><kbd>content</kbd>(object): This specifies the valid MIME types <span>(for example, </span><kbd>application/json</kbd><span>, </span><kbd>text/plain</kbd><span>) </span>that are acceptable for this endpoint, as well as the expected structure of the payload. This structure is defined under the MIME type property, under a sub-property called <kbd>schema</kbd>, and is very similar to the JSON schema syntax, represented as YAML.</li>
<li><kbd>required</kbd> (boolean): This specifies whether the request payload is required:</li>
</ul>
<pre>paths:<br/>  /users:<br/>    post:<br/>      ...<br/>      requestBody:<br/>        description: The New User object<br/>        required: true<br/>        content:<br/>          application/json:<br/>            schema:<br/>              properties:<br/>                email:<br/>                  type: string<br/>                  format: email<br/>                digest:<br/>                  type: string<br/>                  pattern: ^\\$2[aby]?\\$\\d{1,2}\\$[.\\/A-Za-z0-9]{53}$<br/>                profile:<br/>                  type: object<br/>                  properties:<br/>                    bio:<br/>                      type: string<br/>                    summary:<br/>                      type: string<br/>                    name:<br/>                      type: object<br/>                      properties:<br/>                        first:<br/>                          type: string<br/>                        last:<br/>                          type: string<br/>                        middle:<br/>                          type: string<br/>                  additionalProperties: false<br/>              additionalProperties: false<br/>              required:<br/>               - email<br/>               - digest<br/>            example:<br/>              email: e@ma.il<br/>              digest: $2a$10$enCaroMp4gMvEmvCe4EuP.0d5FZ6yc0yUuSJ0pQTt4EO5MXvonUTm<br/>              profile:<br/>                bio: Daniel is a species of JavaScript developer that is commonly found in Hong Kong and London. In 2015, Daniel opened his own digital agency called Brew, which specialized in the Meteor framework.<br/>                summary: JavaScript Developer<br/>                name:<br/>                  first: Daniel<br/>                  last: Li</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining common components</h1>
                </header>
            
            <article>
                
<p>You might have noticed that our specification is not very DRY <span>–</span> we are repeatedly specifying common responses like the 500 Internal Error. Therefore, before we learn how to specify URL parameters and our security schemes, let's first see how we can use the <kbd>components</kbd> root property to define common entities in a single location, and reference it throughout the OpenAPI specification. We will do this for our Create User object, as well as all our responses.</p>
<p>Let's start by adding the following<span> </span><kbd>components</kbd><span> </span>section as a root property to our specification:</p>
<pre>components:<br/>  schemas:<br/>    Profile:<br/>      title: User Profile<br/>      type: object<br/>      properties:<br/>        bio:<br/>          type: string<br/>        summary:<br/>          type: string<br/>        name:<br/>          type: object<br/>          properties:<br/>            first:<br/>              type: string<br/>            middle:<br/>              type: string<br/>            last:<br/>              type: string<br/>      additionalProperties: false</pre>
<p>We can now refer to this Profile schema component anywhere in our specification using the reference <kbd>'#/components/schemas/Profile'</kbd>. In other words, we can shorten our definition for the <kbd>requestBody</kbd> property of our Create User endpoint to the following:</p>
<pre>requestBody:<br/>  description: The New User object<br/>  required: true<br/>  content:<br/>    application/json:<br/>      schema:<br/>        properties:<br/>          email:<br/>            type: string<br/>            format: email<br/>          digest:<br/>            type: string<br/>            pattern: ^\\$2[aby]?\\$\\d{1,2}\\$[.\\/A-Za-z0-9]{53}$<br/>          <strong>profile:</strong><br/><strong>            $ref: '#/components/schemas/Profile'</strong><br/>        additionalProperties: false<br/>        required:<br/>          - email<br/>          - digest</pre>
<p>Let's go through another example. Currently, our <kbd>GET /salt</kbd> endpoint can respond with a 200 response:</p>
<pre>paths:<br/>  /salt:<br/>    get:<br/>      summary: ...<br/>      description: ...<br/>      parameters: ...<br/>      responses:<br/>        '200':<br/>          description: Salt Retrieved<br/>          content:<br/>            text/plain:<br/>              schema:<br/>                type: string<br/>        ...</pre>
<p>We can pull this response out and define it as a component:</p>
<pre>components:<br/>  schemas:<br/>    Profile:<br/>      title: User Profile<br/>      ...<br/>  <strong>responses:</strong><br/><strong>    SaltRetrieved:</strong><br/><strong>      description: Salt Retrieved</strong><br/><strong>      content:</strong><br/><strong>        text/plain:</strong><br/><strong>          schema:</strong><br/><strong>            type: string</strong></pre>
<p>And just like before, we can reference the <kbd>SaltRetrieved</kbd> response component by reference:</p>
<pre>paths:<br/>  /salt:<br/>    get:<br/>      summary: ...<br/>      description: ...<br/>      parameters: ...<br/>      responses:<br/>        '200':<br/>          <strong>$ref: '#/components/responses/SaltRetrieved'</strong><br/>        ...</pre>
<p>Having gone through two examples, you should now try to pull out as many common components as you can. Once you're done, check the code bundle to see our implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the Retrieve User endpoint</h1>
                </header>
            
            <article>
                
<p>Now that we have learned how to use Components to reduce code duplication, let's carry on with specifying the Get User endpoint, and learn how to represent URL parameters in OpenAPI.</p>
<p>It turns out that it's very simple—it's just another parameter, just like query parameters. The only difference is that we need to use path templating to specify where this parameter resides in our URL. For instance, the path would be specified as <kbd>/users/{userId}</kbd> for our Retrieve User endpoint.</p>
<p>We also need to define a new Schema object called <kbd>UserLimited</kbd>, which describes a complete User object but without the <kbd>digest</kbd> field. This is the shape of the object we will return in our Retrieve User endpoint. Lastly, we also added a new <kbd>ErrorNotFound</kbd> response to cater for when a user with that ID does not exist.</p>
<p>The additions made to the schema should resemble the following:</p>
<pre>...<br/>components:<br/>  schemas:<br/>    ...<br/>    <strong>UserLimited:</strong><br/><strong>      title: Retrieve User Response Payload Schema</strong><br/><strong>      description: An User object with the digest field removed</strong><br/><strong>      properties:</strong><br/><strong>        email:</strong><br/><strong>          type: string</strong><br/><strong>          format: email</strong><br/><strong>        profile:</strong><br/><strong>          $ref: '#/components/schemas/Profile'</strong><br/><strong>      additionalProperties: false</strong><br/><strong>      required:</strong><br/><strong>        - email</strong><br/><strong>        - profile</strong><br/>      ...<br/>  responses:<br/>    ...<br/>    <strong>UserRetrieved:</strong><br/><strong>      description: User Retrieved</strong><br/><strong>      content:</strong><br/><strong>        application/json:</strong><br/><strong>          schema:</strong><br/><strong>            $ref: '#/components/schemas/UserLimited'</strong><br/>    ...<br/>    <strong>ErrorNotFound:</strong><br/><strong>      description: Not Found</strong><br/><strong>      content:</strong><br/><strong>        application/json:</strong><br/><strong>          schema:</strong><br/><strong>            $ref: '#/components/schemas/Error'</strong><br/>paths:<br/>  ...<br/>  <strong>/users/{userId}:</strong><br/><strong>    get:</strong><br/><strong>      tags:</strong><br/><strong>        - Users</strong><br/><strong>      summary: Retrieves details of a single User</strong><br/><strong>      parameters:</strong><br/><strong>        - name: userId</strong><br/><strong>          in: path</strong><br/><strong>          description: ID of the User to retrieve</strong><br/><strong>          required: true</strong><br/><strong>          schema:</strong><br/><strong>            type: string</strong><br/><strong>      responses:</strong><br/><strong>        '200':</strong><br/><strong>          $ref: '#/components/responses/UserRetrieved'</strong><br/><strong>        '400':</strong><br/><strong>          $ref: '#/components/responses/ErrorBadRequest'</strong><br/><strong>        '404':</strong><br/><strong>          $ref: '#/components/responses/ErrorNotFound'</strong><br/><strong>        '500':</strong><br/><strong>          $ref: '#/components/responses/ErrorInternalServer'</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the Replace Profile endpoint</h1>
                </header>
            
            <article>
                
<p>The last thing we will demonstrate is describing the Replace Profile endpoint. This endpoint requires the user to be logged in and provides the token in the request.</p>
<p>But first, let's use everything we have learned so far to define the parameters, request bodies, and responses for the Replace Profile endpoint:</p>
<pre>...<br/>components:<br/> ...<br/> responses:<br/>    <strong>Success:</strong><br/><strong>      description: Success</strong><br/>    ...<br/>    <strong>ErrorUnauthorized:</strong><br/><strong>      description: Unauthorized</strong><br/><strong>      content:</strong><br/><strong>        application/json:</strong><br/><strong>          schema:</strong><br/><strong>            $ref: '#/components/schemas/Error'</strong><br/>    ...<br/>  <strong>securitySchemes:</strong><br/><strong>    token:</strong><br/><strong>      type: http</strong><br/><strong>      scheme: bearer</strong><br/><strong>      bearerFormat: JWT</strong><br/>paths:<br/>  <strong>/users/{userId}/profile:</strong><br/><strong>    put:</strong><br/><strong>      tags:</strong><br/><strong>        - Profile</strong><br/><strong>      summary: Replaces the Profile of the User with a new Profile</strong><br/><strong>      security:</strong><br/><strong>        - token: []</strong><br/><strong>      parameters:</strong><br/><strong>        - name: userId</strong><br/><strong>          in: path</strong><br/><strong>          description: ID of the User</strong><br/><strong>          required: true</strong><br/><strong>          schema:</strong><br/><strong>            type: string</strong><br/><strong>      requestBody:</strong><br/><strong>        description: The New Profile object</strong><br/><strong>        required: true</strong><br/><strong>        content:</strong><br/><strong>          application/json:</strong><br/><strong>            schema:</strong><br/><strong>              $ref: "#/components/schemas/Profile"</strong><br/><strong>      responses:</strong><br/><strong>        '200':</strong><br/><strong>          $ref: '#/components/responses/Success'</strong><br/><strong>        '400':</strong><br/><strong>          $ref: '#/components/responses/ErrorBadRequest'</strong><br/><strong>        '401':</strong><br/><strong>          $ref: '#/components/responses/ErrorUnauthorized'</strong><br/><strong>        '404':</strong><br/><strong>          $ref: '#/components/responses/ErrorNotFound'</strong><br/><strong>        '415':</strong><br/><strong>          $ref: '#/components/responses/ErrorUnsupportedMediaType'</strong><br/><strong>        '500':</strong><br/><strong>          $ref: '#/components/responses/ErrorInternalServer'</strong></pre>
<p>Here, we have defined two new response:</p>
<ul>
<li> <kbd>Success</kbd>, which is simply a <kbd>200 Success</kbd> response with no payload</li>
<li><kbd>ErrorUnauthorized</kbd>, which should be returned if the <kbd>Authorization</kbd> header (containing our JSON Web Token) is not present</li>
</ul>
<p>What's new is the <kbd>securitySchemes</kbd> we've defined under <kbd>components</kbd> at the root of the OpenAPI object. In OAS, a <em>security scheme</em> is a method for our client to authenticate themselves. Supported schemes are HTTP authentication, API key, OAuth2, and OpenID Connect Discovery. Since we are using the Bearer scheme in our HTTP Authorization header to authenticate, we have defined it as such.</p>
<p>In our Operation Object, we have also included a <kbd>security</kbd> property that states that this endpoint needs to be authenticated using the security scheme we've defined called <kbd>token</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying the rest of the endpoints</h1>
                </header>
            
            <article>
                
<p>What we've covered so far should have provided enough information for you to complete the OpenAPI specification for the rest of the endpoints. Do attempt to complete it and refer back to the code bundle to check it against our implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating documentation with Swagger UI</h1>
                </header>
            
            <article>
                
<p>We now have a valid OpenAPI specification, which we can use to generate web-based API documentation using Swagger UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the Swagger UI to our repository</h1>
                </header>
            
            <article>
                
<p>The Swagger UI source files are located in the <kbd>dist/</kbd> directory of the official repository. <span>The official way of generating documentation UI for our own specification is to download the Swagger UI source files from <a href="https://github.com/swagger-api/swagger-ui/releases">github.com/swagger-api/swagger-ui/releases</a> and statically serve the page at</span><span> </span><kbd>dist/index.html</kbd><span>.</span></p>
<p>However, it'll more preferable to have the source code of the web UI in the same repository as our API. A naive approach would be to download the latest source files for Swagger UI from <a href="https://github.com/swagger-api/swagger-ui/releases">github.com/swagger-api/swagger-ui/releases</a>, unpack the contents, and copy the contents of the <kbd>dist/</kbd> directory into a <kbd>docs/</kbd> directory inside our repository. <span>However, this requires us to manually update the contents of the <kbd>docs/</kbd> directory each time there's an update on Swagger UI; obviously, that's not ideal. L</span><span>uckily, there's a cleaner way of achieving the same thing using</span><span> </span><strong>Git submodules</strong><span>. Run the following at our project's root directory:</span></p>
<pre><strong>$ git submodule add https://github.com/swagger-api/swagger-ui docs</strong></pre>
<p>Locally, this will download the entire contents of the Swagger UI repository and save it into the <kbd>docs/</kbd> directory at the root of your project. However, in Git, only the<span> </span><kbd>.gitmodules</kbd><span> </span>file and a small<span> </span><kbd>docs</kbd><span> </span>file is tracked:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3b2c2b0f-50b4-4982-95a8-837bcf9f2f52.png"/></div>
<p>This keeps our Git repository clean, and tracks only code which is our own (and not third-party code). When we want to update to the latest version of Swagger UI, all we have to do is update the Git <kbd>submodule</kbd>:</p>
<pre><strong>$ git submodule update --init --recursive</strong></pre>
<p>We can add the update script as an npm script to make it easier to remember:</p>
<pre>"docs:update": "git submodule update --init --recursive"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using our specification in the Swagger UI</h1>
                </header>
            
            <article>
                
<p>Now that we have added the Swagger UI into our repository, the next task is to write a script to serve it on a web server. Since these are simply static files with no backend involvement, any web server would be sufficient. Here, we will use the <kbd>http-server</kbd> package.</p>
<pre><strong>$ yarn add http-server --dev</strong></pre>
<p class="mce-root"/>
<p>By default, the <kbd>http-server</kbd> package uses the port 8080, which we are already using for our API. Therefore, we must use the <kbd>-p</kbd> flag to specify an alternate port. However, we don't want to hard-code this value into our NPM script; instead, we want to take it from our environment variable <kbd>SWAGGER_UI_PORT</kbd>. To achieve this, we need to create a new Bash script at <kbd>scripts/swagger-ui/serve.sh</kbd> with the following content:</p>
<pre>#!/usr/bin/env bash<br/><br/>source &lt;(dotenv-export | sed 's/\\n/\n/g')<br/>yarn run docs:update<br/>http-server docs/dist/ -p $SWAGGER_UI_PORT</pre>
<div class="packt_tip">Remember to make the script executable by running <kbd>chmod +x scripts/swagger-ui/serve.sh</kbd>.</div>
<p>Then, inside <kbd>.env</kbd><span> </span>and<span> </span><kbd>.env.example</kbd>, define the following environment variables:</p>
<pre>SWAGGER_UI_PROTOCOL=http<br/>SWAGGER_UI_HOSTNAME=127.0.0.1<br/>SWAGGER_UI_PORT=8000</pre>
<p>And add a new NPM script to serve our docs:</p>
<pre>"docs:serve": "dotenv -e envs/.env ./scripts/swagger-ui/serve.sh",</pre>
<p>This will download or update the Swagger UI source code and serve the site from the <kbd>docs/dist/</kbd> directory. Now, navigate to <kbd>http://127.0.0.1:8000</kbd> from your browser and you should see a page like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cf7609d2-d2e7-4d03-91c0-d2c354186686.png" style="width:45.25em;height:43.33em;"/></div>
<p>By default,<span> </span><kbd>dist/index.html</kbd><span> </span>uses a demo specification available at<span> </span><a href="http://petstore.swagger.io/v2/swagger.json">petstore.swagger.io/v2/swagger.json</a>, which is what is shown here. To make Swagger UI display documentation for our own API, we need to do the following:</p>
<ol>
<li>Expose the<span> </span><kbd>hobnob.yaml</kbd><span> </span>file in a publicly-accessible location.</li>
<li>Write a script to replace the demo URL with our own.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing swagger.yaml from our API</h1>
                </header>
            
            <article>
                
<p>Exposing the<span> </span><kbd>hobnob.yaml</kbd><span> </span>file is as simple as adding a new endpoint to our API. However, the specification file is located at <kbd>spec/openapi/hobnob.yaml</kbd>, which is outside the <kbd>dist/</kbd> directory of our application. Therefore, first, we should modify our serve script to also copy the OpenAPI specification to the root of the <kbd>dist/</kbd> directory after the application has been built:</p>
<pre>"dev:serve": "yarn run build &amp;&amp; cp spec/openapi/hobnob.yaml dist/openapi.yaml &amp;&amp; dotenv -e envs/.env node dist/index.js",<br/>"serve": "yarn run build &amp;&amp; cp spec/openapi/hobnob.yaml dist/openapi.yaml &amp;&amp; dotenv -e envs/.env pm2 start dist/index.js",</pre>
<p>Now, inside<span> </span><kbd>src/index.js</kbd>, we need to add a new endpoint to retrieve and serve that same <kbd>openapi.yaml</kbd>. Add the following to <kbd>src/index.js</kbd>.</p>
<pre>import fs from 'fs';<br/><br/>...<br/><br/>app.get('/openapi.yaml', (req, res, next) =&gt; {<br/>  fs.readFile(`${__dirname}/openapi.yaml`, (err, file) =&gt; {<br/>    if (err) {<br/>      res.status(500);<br/>      res.end();<br/>      return next();<br/>    }<br/>    res.write(file);<br/>    res.end();<br/>    return next();<br/>  });<br/>});</pre>
<p>Now, whilst running the <kbd>dev:serve</kbd> script, open your browser to <kbd>http://127.0.0.1:8080/openapi.yaml</kbd>. You should see the OpenAPI specification displayed on the screen!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling CORS</h1>
                </header>
            
            <article>
                
<p>In theory, if we go back to our Swagger UI page (at <kbd>127.0.0.1:8000</kbd>) and paste the URL <kbd>http://localhost:8000/openapi.yaml</kbd> into the input bar, it should load the page with our own API specification. However, the page shows an error about <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>).</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5d4fa4d-b533-4bc5-b9e9-7a4fdcaa65aa.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Same-origin policy</h1>
                </header>
            
            <article>
                
<p>For security reasons and in order to protect end users, most browsers enforce the <strong>same-origin policy</strong>, which means that the browser will prevent scripts loaded from one origin (for example, <kbd>http://127.0.0.1:8000</kbd>) from making calls to a server of a different origin (for example, <kbd>http://localhost:8080</kbd>). To demonstrate why the same-origin policy is important, take a look at the following example.</p>
<p>Let's suppose you are logged in to your online banking site, <kbd>personal.bank.io</kbd>. Then, you open a malicious site, <kbd>malicious.io</kbd>, which runs the following script inside <kbd>malicious.io</kbd>:</p>
<pre>fetch('personal.bank.io/api/transfer', {<br/>  method : "POST",<br/>  body : JSON.stringify({<br/>    amount : '999999',<br/>    to: 'malicious.io'<br/>  })<br/>})</pre>
<p><span>If the same-origin policy was not in place and this request was allowed to proceed, then you would have lost a lot of money. </span>Note that this is a variation on the <strong>Cross-Site Request Forgery</strong> (<strong>CSRF</strong>) attack we analyzed earlier. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-Origin Resource Sharing (CORS)</h1>
                </header>
            
            <article>
                
<p>However, the same-origin policy also limits legitimate use cases just like our own. Therefore, the <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) came up with the <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) specification to deal with this. The CORS specification outlines the mechanism whereby browsers and servers can communicate with each other, through a set of HTTP headers, in order to determine which cross-origin requests are allowed.</p>
<p class="mce-root"/>
<div class="packt_tip">You can find the full specification at <a href="https://www.w3.org/TR/cors/">w3.org/TR/cors/</a>.</div>
<p>CORS requires support from both the client (the browser) and the server. Almost all modern browsers support CORS:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bbb0dc7a-2570-4165-885e-b33bfe989ecf.png"/></div>
<div class="packt_tip">You can explore more detailed browser support for CORS at <a href="https://caniuse.com/#feat=cors">caniuse.com/#feat=cors</a>.</div>
<p>Therefore, the only thing we need to do is set up our Express server to enable CORS. To make things easy, there's a really handy site, <a href="https://enable-cors.org/">enable-cors.org</a>, that provides sample code of how to enable CORS for your specific server. We can find the instruction for Express at <a href="https://enable-cors.org/server_expressjs.html">enable-cors.org/server_expressjs.html</a>. All we need to do is add the following middleware before our other middlewares:</p>
<pre>app.use((req, res, next) =&gt; {<br/>  res.header('Access-Control-Allow-Origin', '*');<br/>  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');<br/>  next();<br/>});</pre>
<p>The <kbd>Access-Control-Allow-Origin</kbd> header specifies requests from which origins are allowed to make cross-site requests. Here, we are using the glob wildcard <kbd>'*'</kbd> to allow cross-site requests from all origins.</p>
<p>If we paste in their sample code into <kbd>src/index.js</kbd>, reload our server, and also reload the Swagger UI documentation page, the CORS issue should be resolved and we should see details about our API displayed on-screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d3a65e2-5c57-4e80-b64f-ba1303cf1a34.png" style="width:39.42em;height:44.75em;"/></div>
<p>However, allowing CORS requests for all origins is the same as disregarding the same-origin policy set by browsers, which, as we've demonstrated, is an important policy to keep. Therefore, if possible, we should specify a whitelist of origins that are allowed to make CORS requests. At the moment, this is only the Swagger UI documentation site.</p>
<p>Therefore, we can update our code to whitelist the documentation site's origin:</p>
<pre>res.header("Access-Control-Allow-Origin", "http://127.0.0.1:8000");</pre>
<p>However, when we deploy our application and make our documentation publically available, we know that the docs would be served as a publicly-accessible URL, and not at <kbd>127.0.0.1:8000</kbd>. Therefore, it makes little sense for us to hard-code the origin into the code. Instead, consistent with our approach so far, we should define the origin as a set of environment variables, use those variables within our code, a<span>nd update our code to use these variables.</span></p>
<pre>res.header('Access-Control-Allow-Origin', <strong>`${process.env.SWAGGER_UI_PROTOCOL}://${process.env.SWAGGER_UI_HOSTNAME}:${process.env.SWAGGER_UI_PORT}`</strong>);</pre>
<p>Save and restart your API server, and our Swagger UI documentation should still work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final touches</h1>
                </header>
            
            <article>
                
<p>One last issue remains—when the documentation page first loads, it still defaults to using the demo <a href="http://petstore.swagger.io/v2/swagger.json">petstore.swagger.io/v2/swagger.json</a> URL. This is not good for user experience as the user must manually paste in the URL of the specification they are interested in.</p>
<p>Ideally, our page should load the correct specification on the first load, and there should be no top bar for our visitors to load another API's specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replacing the specification URL</h1>
                </header>
            
            <article>
                
<p>To replace the demo URL, we are going to use a Bash script that will use <span>environment</span> variables to compose the URL of our<span> </span><kbd>openapi.yaml</kbd>, and then substitute it in using<span> </span><kbd>sed</kbd>. However, the <kbd>SERVER_*</kbd> environment variables we have set are internal, and won't be valid for our clients. Therefore, we need to add three more environment variables to hold the external URL of our API server.</p>
<p class="mce-root"/>
<p>In <span><kbd>envs/.env</kbd> and <kbd>envs/.env.example</kbd>, add the following three environment variables:</span></p>
<pre>SERVER_EXTERNAL_PROTOCOL=http<br/>SERVER_EXTERNAL_HOSTNAME=api.hobnob.jenkins<br/>SERVER_EXTERNAL_PORT=80</pre>
<p>Then, create a new file at<span> </span><kbd>scripts/swagger-ui/format.sh</kbd><span> with execute permissions </span>and paste in the following script:</p>
<pre>#!/usr/bin/env bash<br/><br/>sed -i "s!https://petstore.swagger.io/v2/swagger.json!<strong>$SERVER_EXTERNAL_PROTOCOL</strong>://<strong>$SERVER_EXTERNAL_HOSTNAME</strong>:<strong>$SERVER_EXTERNAL_PORT</strong>/openapi.yaml!g" docs/dist/index.html</pre>
<p>Then, also add a new NPM script to call our the <kbd>format.sh</kbd> script:</p>
<pre>"docs:format": "dotenv -e envs/.env ./scripts/swagger-ui/format.sh",</pre>
<p>We must also update our <kbd>docs:update</kbd> script in order to:</p>
<ol>
<li>Reset any changes made in the Git submodules.</li>
<li>Pull the latest Swagger UI repository.</li>
<li>Run <kbd>docs:format</kbd> to replace the URL:</li>
</ol>
<pre>"docs:update": "git submodule foreach --recursive git reset --hard &amp;&amp; git submodule update --init --recursive &amp;&amp; yarn run docs:format",</pre>
<div>
<p>Now, run <kbd>yarn run docs:update</kbd> and then reload our Swagger UI page, it'll default to using our API specification instead of the demo specification.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing the header</h1>
                </header>
            
            <article>
                
<p><span>Last but not least, we need to remove the header from Swagger UI. The header has a CSS class of <kbd>topbar</kbd>. Therefore, to remove the header from our page, we can simply inject the following CSS into the header of our page.</span></p>
<pre>&lt;style&gt;.topbar { display: none; }&lt;/style&gt;</pre>
<p>To do that, we will search for the <kbd>&lt;/head&gt;</kbd> closing tag within <kbd>docs/dist/index.html</kbd>, and insert a newline above it with our own style tag. These steps can be achieved with one simple <kbd>sed</kbd> script. Add it at the end of <kbd>scripts/swagger-ui/format.sh</kbd>:</p>
<pre>sed -i '/&lt;\/head&gt;/i \<br/>&lt;style&gt;.topbar { display: none; }&lt;\/style&gt;' docs/dist/index.html</pre>
<p>Run <kbd>yarn run docs:update &amp;&amp; docs:serve</kbd> once more. Now, our page will not display the header any more!</p>
<p>Once you're happy with the changes, commit them and merge it back to the <kbd>dev</kbd> and <kbd>master</kbd> branch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>Lastly, let's go into our remote server and deploy our documentation site. We do this by pulling in our changes and installing the dependencies.</p>
<pre><strong>$ ssh hobnob@142.93.241.63</strong><br/><strong>hobnob@hobnob:$ cd projects/hobnob/</strong><br/><strong>hobnob@hobnob:$ git fetch --all</strong><br/><strong>hobnob@hobnob:$ git reset --hard origin/master</strong><br/><strong>hobnob@hobnob:$ yarn</strong></pre>
<p>Next, we'll also need to generate a new set of keys and set the<span> </span><kbd>SWAGGER_UI_*</kbd><span> </span>environment variables inside the<span> </span><kbd>.env</kbd><span> </span>file:</p>
<pre>SWAGGER_UI_PROTOCOL=http<br/>SWAGGER_UI_HOSTNAME=docs.hobnob.social<br/>SWAGGER_UI_PORT=80<br/>PRIVATE_KEY="..."<br/>PUBLIC_KEY="..."</pre>
<p>Then, run the <kbd>docs:update</kbd> script to <span>generate the static files which would be served by NGINX. To give NGINX access to these files, we should also update the owner and group of the <kbd>docs</kbd> directory to <kbd>nginx</kbd>:</span></p>
<pre>hobnob@hobnob:$ yarn run docs:update<br/>hobnob@hobnob:$ sudo chown -R nginx:nginx ./docs/*</pre>
<p><span>Then, restart the API server:</span></p>
<pre>hobnob@hobnob:$ npx pm2 delete 0<br/>hobnob@hobnob:$ yarn run serve</pre>
<p>After this, add a new virtual host definition at <kbd>/etc/nginx/sites-available/docs.hobnob.social</kbd>:</p>
<pre>server {<br/>    listen 80;<br/>    server_name docs.hobnob.social;<br/>    root /home/hobnob/projects/hobnob/docs/dist;<br/>    location / {<br/>        index index.html;<br/>    }<br/>}</pre>
<p>This will simply ask NGINX to serve the static files at <kbd>/home/hobnob/projects/hobnob/docs/dist</kbd>. Then, to enable this <kbd>server</kbd> block, link it to the <kbd>/etc/nginx/sites-enabled/</kbd> directory and restart NGINX.</p>
<pre>hobnob@hobnob:$ sudo ln -s /etc/nginx/sites-available/docs.hobnob.social /etc/nginx/sites-enabled/<br/>hobnob@hobnob:$ sudo systemctl restart nginx.service</pre>
<p>Lastly, go to the DigitalOcean administrative panel and add an <kbd>A</kbd> record for <kbd>docs.hobnob.social</kbd>, pointing to our server:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ba0bf50c-e7e7-466c-8931-8269717ef08f.png"/></p>
<p>Now, you should be able to see our documentation at <kbd>docs.hobnob.social</kbd>!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we used the OpenAPI specification format to document our API and used Swagger UI to transfer that specification into a user-friendly web page.</p>
<p>This concludes the work we need to do for our back-end code. In the next chapter, we will build the front-end user interface that will interact with our API.</p>


            </article>

            
        </section>
    </body></html>