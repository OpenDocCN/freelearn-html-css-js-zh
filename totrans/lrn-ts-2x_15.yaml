- en: Working with the TypeScript Compiler and the Language Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about the internals of the TypeScript
    compiler and the TypeScript language services.
  prefs: []
  type: TYPE_NORMAL
- en: These topics may seem very advanced and not something that everybody will find
    useful. While it is true that it is a topic for advanced users, the truth is that
    everybody can benefit from understanding the TypeScript language services. Understanding
    the compiler API of the TypeScript compiler can help us to develop many kinds
    of development tools and to automate certain aspects of our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is not to make you an expert in the compiler''s internals
    or the development of TypeScript tools, but to gently introduce you to this very
    extensive topic. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The internal architecture of the TypeScript compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the compiler API programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `ts-simple-ast`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom code-analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript compiler's internal architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn what the main components in the TypeScript
    compiler are. We are going to learn the main responsibility of each of the components,
    as well as what their expected inputs and outputs are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the main components of the TypeScript architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e3e592e-d2b7-4083-8613-dbd668e1dfd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Components of the TypeScript architecture
  prefs: []
  type: TYPE_NORMAL
- en: The core TypeScript API is the foundation of everything, and is composed of
    elements such as the scanner, parser, binder, type checker, and emitter.
  prefs: []
  type: TYPE_NORMAL
- en: The language services and the standalone compiler (the `tsc` command-line tool)
    sit on top of the core compiler APIs. Finally, the Visual Studio shim and the
    TypeScript standalone server (`tsserver`) are designed to facilitate the integration
    of TypeScript with Visual Studio and other source code editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official TypeScript documentation defines the TypeScript standalone server
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The TypeScript standalone server (aka tsserver) is a node executable that
    encapsulates the TypeScript compiler and language services and exposes them through
    a JSON protocol. tsserver is well suited for editors and IDE support."'
  prefs: []
  type: TYPE_NORMAL
- en: Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scanner transforms the source code files into streams of tokens. The scanner
    is also known as the **lexer** in other resources about compilers. The scanner
    is used by the parser.
  prefs: []
  type: TYPE_NORMAL
- en: Lexemes and tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lexeme is a sequence of characters in the source program that matches the
    pattern for a token. We can say that a token has a pattern and a pattern can be
    matched by many lexemes, in some cases. As a result, in a programming language,
    there are an infinite number of potential lexemes and a limited number of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to understand the difference between a lexeme and a token is
    to take a look at an example, such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will be parsed into the following lexemes and tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lexeme** | **Token** |'
  prefs: []
  type: TYPE_TB
- en: '| `while` | `WhileKeyword` |'
  prefs: []
  type: TYPE_TB
- en: '| `(` | `OpenParenToken` |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | `Identifier` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `GreaterThanEqualsToken` |'
  prefs: []
  type: TYPE_TB
- en: '| `t` | `Identifier` |'
  prefs: []
  type: TYPE_TB
- en: '| `)` | `CloseParenToken` |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | `Identifier` |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | `EqualsToken` |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | `Identifier` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `MinusToken` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `NumericLiteral` |'
  prefs: []
  type: TYPE_TB
- en: '| `;` | `SemicolonToken` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `EndOfFileToken` |'
  prefs: []
  type: TYPE_TB
- en: 'In TypeScript, the tokens are defined in the `SyntaxKind` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `SyntaxtKind` enumeration is defined in the [/src/compiler/types.ts](https://github.com/Microsoft/TypeScript/blob/b31aa4e012fc4c2afc9c2200f18b9e79edac160b/src/compiler/types.ts#L80)
    file in the TypeScript source code.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official TypeScript repository on GitHub at [https://github.com/Microsoft/TypeScript](https://github.com/Microsoft/TypeScript)
    if you wish to explore the entire source code of the TypeScript project.
  prefs: []
  type: TYPE_NORMAL
- en: Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TypeScript parser uses the scanner to traverse our source code files and
    transform them into a stream of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript parser then transforms the stream of tokens into a tree-like
    data structure known as an abstract syntax tree (AST). Each of the elements in
    this tree-like data structure is known as a node. A node is the basic building
    block of the AST.
  prefs: []
  type: TYPE_NORMAL
- en: AST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **abstract syntax tree** (**AST**) is a tree-like data structure created
    by the parser. This data structure allows the TypeScript compiler to traverse
    our source code to perform many core tasks, such as emitting the output JavaScript
    code. We are going to learn more about the AST later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript textbook by Basarat Ali Syed describes symbols as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Symbols connect declaration nodes in the AST to other declarations contributing
    to the same entity. Symbols are the basic building block of the Semantic system."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The symbol class is defined in the TypeScript source code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A symbol contains a reference to the declarations of a type and some flags that
    help us to identify some of its characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Binder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript textbook by Basarat Ali Syed describes the binder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The binder is used to connect the various parts of the source code into a
    coherent type system that can then be used by the checker. The main responsibility
    of the binder is to create the Symbols."'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript supports a feature known as *declaration merging*, which allows
    us to merge two separate declarations declared with the same name into a single
    definition. For example, the following code snippet declares two interfaces named
    `Person` and a variable named `person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The type of the variable is `Person`, and as we can see, the type contains the
    properties declared in both previously declared interfaces. This is the case because
    the declaration merging mechanism merges both declarations into one unique type.
    This is directly related to the behavior of the binder.
  prefs: []
  type: TYPE_NORMAL
- en: Type checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type checker is probably the most important component in the TypeScript
    compiler. The type checker uses the abstract syntax trees (one per file) and the
    symbols as inputs, and it oversees the identification of type errors in our source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The emitter is the component responsible for the generation of the output code.
    The output is usually JavaScript that adheres to one of the supported specifications
    (ES3, ES5, or ES6), but it can also be type definitions or source map files.
  prefs: []
  type: TYPE_NORMAL
- en: Language service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript compiler includes an additional component that has been specifically
    designed to provide developers with a great developer experience. The following
    paragraph has been extracted from the official TypeScript documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The "Language Service" exposes an additional layer around the core compiler
    pipeline that is best suiting editor-like applications. The language service supports
    the common set of a typical editor operations like statement completions, signature
    help, code formatting and outlining, colorization, etc... Basic re-factoring like
    rename, Debugging interface helpers like validating breakpoints as well as TypeScript-specific
    features like support of incremental compilation (--watch equivalent on the command-line).
    The language service is designed to efficiently handle scenarios with files changing
    over time within a long-lived compilation context; in that sense, the language
    service provides a slightly different perspective about working with programs
    and source files from that of the other compiler interfaces."'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the abstract syntax tree (AST)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already learned, an **abstract syntax tree**, or **AST**, is a tree-like
    data structure used to represent the abstract syntactic structure of source code
    written in a programming language. Each node of the AST represents a construct
    that occurs in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to look at a small TypeScript code snippet to understand the
    AST in detail. There is nothing very special about the following code snippet—it
    simply declares an interface named `Weapon` and a couple of classes, named `Katana`
    and `Ninja`. It then creates an instance of the `Ninja` class and invokes one
    of its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The AST for the preceding code snippet generated by the TypeScript compiler
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8adc6f41-2ece-476d-a243-f9c76f3ada99.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the nodes of the preceding AST have been removed for ease of understanding.
    We can see how the AST starts with a `SourceFile` node and ends with an `EndOfFileToken`
    node. Between these two nodes, we have a node for the interface declaration (`InterfaceDeclaration`),
    two nodes for the class declarations (`ClassDeclaration`), one node for the variable
    declaration (`VariableStatement`), and, finally, a node for the method invocation
    (`ExpressionStatement`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to focus on one of these nodes: the node that represents the
    interface declaration (`InterfaceDeclaration`). As we saw earlier, the interface
    declaration looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InterfaceDeclaration` node in the AST for the preceding code snippet looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e8467e2-a31c-4eb8-a0b8-c0a7a6629136.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding representation of the AST, we can see the names of each of
    the nodes that compose the AST of an interface declaration with a unique method
    signature. For example, we can see that the declaration starts with a node that
    represents the `interface` keyword (`InterfaceKeyword`), and that it is followed
    by the name of the interface (`Identifier`). We can also see that the `tryHit`
    method takes a number (`NumberKeyword`) as an argument and returns a boolean (`BooleanKeyword`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The AST nodes have certain properties. For example, the `NumberKeyword` in
    the preceding example has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These properties allow us to identify the kind of the node (the `kind` property)
    and its position within the source code (the `pos` and `end` properties). The
    `kind` is a reference to a `Token`. The value `133` is the value of the `NumberKeyword`
    property in the `SyntaxKind` enum.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know what the TypeScript AST is and what it looks like. In the following
    section, we are going to learn about a tool that can help us to visualize the
    AST.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript AST Viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript AST Viewer is an open source application that allows us to explore
    the AST for a given TypeScript code snippet. This application is available online
    at [http://ts-ast-viewer.com](http://ts-ast-viewer.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/911252a4-64b9-4ba0-94a6-c81040af7333.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The companion source code includes a very small application that we are going
    to use throughout the rest of this chapter. The following subsections describe
    each of the components in the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: interfaces.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `interfaces.ts` file declares and exports a couple of interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: katana.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `katana.ts` file declares a base class named `BaseWeapon` and a derived
    class named `Katana`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ninja.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ninja.ts` file declares a class named `Ninja`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: main.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main.ts` file is the application''s entry point. It creates an instance
    of `Katana` and an instance of `Ninja` and then invokes one of the methods of
    the `Ninja` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: broken.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The companion source code also includes a file named `broken.ts`. This file
    contains some compilation errors on purpose because it is used to demonstrate
    how to perform error diagnostics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Traversing the TypeScript AST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to visualize the TypeScript AST using the TypeScript AST
    viewer online. At this point, it is normal to ask ourselves where all this information
    is coming from. In this section, we are going to demonstrate how to use the TypeScript
    compiler APIs to access the AST.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a `package.json` file and installing TypeScript using `npm`,
    the first thing that we need to do is to create a new TypeScript file and import
    TypeScript as a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to declare the configuration of the TypeScript compiler using
    an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a new program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A program is a collection of source files and a set of compilation options that
    represent a compilation unit. The program is the main entry point to the type
    system and code generation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to create an instance of the TypeScript type checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can write some code to iterate through the source files in
    the program. The following code snippet traverses the AST of the given source
    files and returns a list of the classes and interfaces declared in each file.
  prefs: []
  type: TYPE_NORMAL
- en: It uses the `getSourceFiles` method of the program instance to access the source
    files in the program. The `lib.d.ts` file and the files under the `node_modules`
    directory are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet uses a recursive function named `visit` to traverse the nodes
    in the AST. The recursive function compares each of the nodes with the tokens
    that we are looking for (`ClassDeclaration` and `InterfaceDeclaration`) to identify
    the classes and interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the token found is a module declaration, we will invoke the recursive function
    `visit` once more. Once we have managed to find all the classes and interfaces
    in our source code, we can display them in the console using a simple `forEach`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `chalk` module can be installed via `npm`, and is used to display
    colored text in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how we can access and traverse the TypeScript AST. As we can see,
    the process required to create this kind of task is quite tedious. However, there
    is an open source tool that can help us to traverse the TypeScript AST with ease:
    `ts-simple-ast`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with ts-simple-ast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the preceding section, when it comes to working with the TypeScript,
    AST is not very complicated. However, there is an open source npm module named
    `ts-simple-ast` that makes working with the TypeScript AST even easier! In this
    section, we are going to take a look at multiple examples to learn how to use
    `ts-simple-ast`.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the AST with ts-simple-ast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet implements an application that is almost identical
    to the application that we implemented in the preceding section. The most notable
    difference is that, instead of using the core TypeScript compiler APIs, we are
    going to use the `ts-simple-ast` helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used in many of the examples in this chapter, and
    it is used to get an instance of the TypeScript AST, given certain files and the
    desired compiler settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `getAst` function to access the `ts-simple-ast` AST and then
    the `getSourceFiles` method to access the source files in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can use `getFilePath` to get the path of a source file and
    the `getClasses` and `getInterfaces` methods to access the class and interface
    declarations in a source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `ts-simple-ast` helpers can greatly simplify traversing the
    TypeScript AST or searching for a certain kind of entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can display the name of the classes on the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Diagnostics with ts-simple-ast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet implements a very small application that uses `ts-simple-ast`
    to find errors in a TypeScript file using the error diagnostic APIs. The application
    uses the `chalk` npm module to display errors using a red font in the command-line
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is the same `getAst` function that we used in the preceding
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The AST provided by `ts-simple-ast` includes a method named `getDiagnostics`,
    which allows us to access the detected compilation errors. The `getErrors` function
    showcases how to traverse each of the diagnostics and how to access the underlying
    `DiagnosticMessageChain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `diagnostic.getMessageText` returns a string or a `DiagnosticMessageChain`.
    The `DiagnosticMessageChain` implements the iterator pattern, which explains why
    we use the `DiagnosticMessageChain.getNext` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Accessing class details with ts-simple-ast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code snippet demonstrates how we can use the `ts-simple-ast` APIs
    to access and manipulate class declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding example is not meant to be executed. It is a showcase
    of the available methods in the `ts-simple-ast` API, but it is not an executable
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the preceding examples, we are going to use the `getAst`, `getSourceFiles`,
    and `getClasses` methods to find all the class declarations in our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then use some tools to access the details of the class declaration,
    including methods, derived classes, and properties, among others. We will also
    demonstrate how we can modify the class declaration by performing operations such
    as adding a base class or a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Accessing module details with ts-simple-ast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code snippet demonstrates how we can use the `ts-simple-ast` APIs
    to access and manipulate module `import` and `export` declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding example is not meant to be executed. It is a showcase
    of the available methods in the `ts-simple-ast` API, but it is not an executable
    demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the preceding examples, we are going to use the `getAst` and `getSourceFiles` methods
    to access the source code''s objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then use some methods to access the details of the module `import`
    and `export` declarations. We also demonstrate how we can add and remove module
    `import` and `export` declarations by performing operations such as adding a default
    `export`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the language services API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The language services API is built on top of the core compiler APIs, and it
    was designed to provide software engineers with a great developer experience independent
    of their IDE or code editor of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use `ts-simple-ast` to access the language services API. We
    can access the language services API using the `getLanguageService` method in
    an AST instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The language services API implements methods that allow us to perform a common
    editing task, such as renaming a variable or automatically implementing an interface.
    The following screenshot shows some of the available methods in the language services
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c1f8e17-a5e4-4f43-8214-350fed0df449.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now going to create a very small application that uses the language
    services API to find interfaces in the sample application included in the companion
    source code. The application will display the name of each of the interfaces and
    the name of each of their implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We then need to find the name of each of the interface declarations using the
    `getName` method.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to try to find each of their implementations using the `getImplementations`
    method, which is part of the language services API. The method expects us to pass
    the node that declares the interface. The node can be accessed using the `interfaceDeclaration.getNameNode`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have found the implementations, we need to find their names. We do
    this by searching for the name of the nodes of the kind called `Identifier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we display the results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the application, we should be able to see the following displayed
    in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since TypeScript 2.2, it is possible to write language services plugins to extend
    the language services API. Custom language services can help to provide developers
    with a better developing experience. For example, there is a language service
    that provides developers with autocomplete and error diagnostic features while
    working with GraphQL queries. Before this, GraphQL queries were just text, and
    as a result, they were somewhat tedious to implement. Implementing our language
    services plugins is out of the scope of this book, but if you wish to learn more,
    you will be able to do so at [https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a yUML compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to put together everything that we have learned
    so far during this chapter to create a custom developer tool. We are going to
    write a tool that takes TypeScript source code as input and generates a **unified
    modeling language** (**UML**) class diagram. A class diagram describes the structure
    of a system by showing the system's classes, their attributes, methods, and the
    relationships among the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class diagram looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/794d7e60-33ed-4437-af11-ae46afdd8b1c.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to use the TypeScript compiler API and `ts-simple-ast` to traverse
    the AST generated by the sample application included in the companion source code.
    We will then emit some code in a **domain-specific language** (**DSL**) known
    as yUML. Finally, we will post the yUML DSL to an online service to generate the
    diagram as an image. We are going to translate from TypeScript to yUML, which
    means that we can think about this as creating a yUML compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by importing some required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `fs` and `path` modules are native core Node.js modules and don't need to
    be installed. However, we are going to need the type definitions for Node.js (`@types/node`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `flatten` function is part of the `lodash` npm module. This function
    allows us to transform a multidimensional array (for example, an array of arrays)
    into an array with only one dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then going to declare two interfaces that are used to represent the
    relevant details about a class, method, or property. In this example, we are going
    to only use the name of the method or property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a constant variable named `templates`.
    Templates are functions that take names and return strings that contain yUML DSL
    snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used to get the AST for the given source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function emits the yUML DSL for the class declarations. We traverse
    the AST, searching for properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function emits the yUML DSL for interface declarations. We traverse
    through the AST, searching for properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function emits the yUML DSL for heritage clauses. This includes
    relationships defined in our source code by the use of the `extends` and `implements`
    keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The following function renders the UML diagram into a `.png` file using the
    yUML web service. We invoke the web service using the `request` npm module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `request` module is used to download the rendered image. The image is then
    saved into the current directory using the code''s Node.js FileSystem API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function generates the yUML DSL for the given TypeScript files.
    This function delegates work to the previously defined `getAst`, `emitClass`,
    `emitInterface`, and `emitInheritanceRelationships` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have implemented the entire application and we can invoke
    the yUML function to generate the yUML DSL for the given files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can invoke the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the official `ts-simple-ast` documentation at [https://dsherret.github.io/ts-simple-ast/](https://dsherret.github.io/ts-simple-ast/)
    to learn more about the available APIs.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing Visual Studio extensions is out of the scope of this book. However,
    it is worth mentioning that VS Code extensions can be developed using TypeScript.
    This means that it is possible to transform our custom command-line TypeScript
    tools, such as the UML diagram generator, into VS Code extensions without too
    many complications.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the official VS Code documentation about the development of extensions
    at [https://code.visualstudio.com/docs/extensions/overview](https://code.visualstudio.com/docs/extensions/overview)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the internal components of the TypeScript
    compiler. We have also learned how to use the compiler APIs and how we can take
    advantage of these features to develop our TypeScript development tools.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this chapter will foster your curiosity of the TypeScript compiler
    internals and the development of software development tools powered by TypeScript.
    Their potential and growing popularity will take the JavaScript ecosystem to the
    next level.
  prefs: []
  type: TYPE_NORMAL
