<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-174"><a id="_idTextAnchor173"/>10</h1>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/>Best Practices</h1>
<p>Within this final chapter of the book, it is time to wrap up our journey, with several vital topics around general JavaScript framework development, and take a glimpse into the future of frameworks in this ecosystem. Over the preceding chapters, we have dissected real-world examples and built a robust knowledge base centered on project maintenance and organization. Harnessing that practical knowledge, in this chapter, we will focus on the current status quo of frameworks and examine several predictions to see where innovation in this space is heading in the future. The overall goal is to understand the best practices of JavaScript framework development that are prevalent today, as well as to explore some of the future patterns as they emerge.</p>
<p>The essential takeaways from this chapter will be around bridging the gap between where we are today in the framework development space and what kind of solutions framework authors will build in the near to long-term future. This in-depth exploration will cover the following topics:</p>
<ul>
<li><strong class="bold">The common themes of frameworks</strong>: The first part discusses several architectural patterns and common choices across many of the framework projects we have seen in this book. Elements such as modularity, approaches to code bases, standardization of best practices, and performance-based design are cornerstones of effective and robust frameworks. With these elements, we will be better equipped to anticipate innovation in this sphere of software development.</li>
<li><strong class="bold">Future of frameworks</strong>: We will see what factors will affect how frameworks evolve as time passes, focusing on themes dealing with developer experience, addressing full-stack complexity, and highlighting potential new approaches to development. This section highlights the potential paradigm shifts in development approaches poised to redefine the industry’s trajectory. Considering and researching new trends and techniques is important as you start building new software for the public.</li>
<li><strong class="bold">Additional development considerations</strong>: Finally, to wrap up our adventure, the section on additional considerations turns the spotlight on important factors such as time investment, financial backing, and overall software support. These factors, often overlooked as projects progress, significantly shape the process and outcome of framework projects. These additional considerations are important for any type of framework developer.</li>
</ul>
<p>Following these topics on <em class="italic">best practices</em>, this chapter highlights the enduring principles of JavaScript framework development – taking common themes into account, looking into the factors that will shape the future of similar projects, and looking at the auxiliary considerations that must be taken into account. Understanding these <em class="italic">best practices</em> is the key to unlocking your potential to comprehend and influence the development trajectory of your own JavaScript frameworks. These skills will remain future-proof, regardless of the changing tech landscape, as you further dive into the development of your project. The first section on common themes in development looks at several examples of concepts reused in framework development today. Let’s begin.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Technical requirements</h1>
<p>Similar to <a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, the <code>chapter10</code> directory consists of several sample projects that showcase tools related to framework best practices. Refer to the <code>chapter10/README.md</code> files for a guide that documents the contents of the child directories of those chapters. The technical requirements are similar to the other chapters, such as the use of Node.js 20 or higher.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Common themes</h1>
<p>Looking at the current <a id="_idIndexMarker677"/>state of framework projects in the JavaScript ecosystem, we can see stability, vibrancy, and chaos in the JavaScript framework field. For instance, we have seen many projects utilizing an approach to build on existing primitives, such as many of the frameworks using the React component library as the foundation for component architecture and rendering in the browser. At the other end of the spectrum, projects are created from the ground up, reinventing the approach to rendering in the browser or solving particular challenges of software development with JavaScript. This section explores similar common themes that occur across many projects. Knowing these particular commonalities helps framework developers stay in touch with the rest of the ecosystem and develop more cohesive projects.</p>
<p>When we take a zoomed-out view of the current state of all these projects, at one end of the spectrum, we find large, established frameworks that underpin numerous high-traffic applications and sophisticated tooling. With every release, these frameworks augment their maturity and stability. For instance, Electron sits on the throne as the most popular framework for utilizing web technologies for application development. Each new version steadily improves its design and addresses its performance metrics. Conversely, a set of evolving <a id="_idIndexMarker678"/>projects generates fresh, new ideas in the JavaScript community. These newcomers, whether introduced as public resources or crafted for internal business needs, inject a dose of novelty and versatility into the ecosystem. For example, <em class="italic">Svelte</em> and <em class="italic">SvelteKit</em> challenge some of the established paradigms and sway certain developer mindsets toward a different approach. As the approach to web application architecture changes and evolves, this whole spectrum entices excitement, opportunities, and new technological advancements for all JavaScript developers.</p>
<p>In the <em class="italic">Framework showcase</em> section in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we charted the evolution of framework development across an expansive timeline. From their beginnings as specialized solutions for specific tasks, such as their initial focus on single-page apps, frameworks have evolved to become all-encompassing development platforms. A modern-day framework’s functionality is exponentially broader and richer, including solutions for full stack needs and beyond. In the practical example of the development of the <em class="italic">Componium</em> framework in <em class="italic">Chapters 6</em>, <em class="italic">7</em>, and <em class="italic">8</em>, we saw a reliance on the diverse set of packages and abstractions to construct this comprehensive framework to form a fully fledged full stack system.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Modularity</h2>
<p>Modularity is one <a id="_idIndexMarker679"/>of the common themes we can devise from many of the projects mentioned in this book. The modularity concepts apply to JavaScript projects in many ways, and they are also specific to JavaScript projects, compared to projects in other programming ecosystems. The modular approach to development has been fueled by the structure of web applications and the package structure in registries such as <code>npm</code>, backed by the <code>package.json</code> format. In comparison, when looking at programming languages such as Python, they depend on external project dependencies but lack a standardized method to effectively handle these dependencies. JavaScript is in a unique situation, where the frameworks use many internal and external modules. This approach is both beneficial to development velocity and burdensome from a maintenance point of view.</p>
<div><div><img alt="Figure 10.1: The modularity of AdonisJS" src="img/Figure_10.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The modularity of AdonisJS</p>
<p><em class="italic">Figure 10</em><em class="italic">.1</em> depicts an example of modularity in <em class="italic">AdonisJS</em>. The figure presents the outline structure <a id="_idIndexMarker680"/>of the first-party packages of that framework. The AdonisJS framework packages are well-organized and decoupled for the sake of developers, who can choose what fits their use cases better. Most of the packages are installed from the Adonis namespace – <code>npm install @adonisjs/ally</code>. They are later configured using the framework’s command line tool, called <strong class="bold">Ace</strong>. In the <a id="_idIndexMarker681"/>AdonisJS core, the code base also relies on several modules for development and end user features: <a href="https://github.com/adonisjs/core/blob/develop/package.json">github.com/adonisjs/core/blob/develop/package.json</a>. This is just another example of a common theme we see across all of the projects in the ecosystem; this approach will likely not change any time soon as new projects become more popular in the community. As a framework developer, you would embrace the available existing code and structure your projects to consist of modules as well.</p>
<p class="callout-heading">Testing out the modularity</p>
<p class="callout">The <code>chapter10/adonisjs</code> directory consists of a sample AdonisJS project. In the project directory, you can run <code>npm install</code> and then <code>npm </code><code>run dev</code>.</p>
<p class="callout">Once the project is running, you can open the following address in your browser: <code>http://127.0.0.1:3333/</code>. With the example app running, you can install and use additional modules, such as the one listed earlier in this section, via <code>npm install @adonisjs/ally</code>. You can find more modules and packages at <a href="https://adonisjs.com">adonisjs.com</a>.</p>
<p>The increased complexity of architectures contrasts with the benefits of modularity. For instance, the more isolated the modules that a framework consumes or exposes are, the more you have to <a id="_idIndexMarker682"/>think about coupling and how all those modules fit together. More recent challenges deal with keeping dependencies up to date or tagging new releases of a framework’s separated modules. Framework developers have to invest a lot more time in managing the dependencies they consume and produce, which is not something that is going to change in JavaScript platforms any time soon.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Evolving design</h2>
<p>Another common theme among many JavaScript frameworks is the concept of evolving design. Similar to <a id="_idIndexMarker683"/>systems in other languages, the frameworks that are built in JavaScript need to evolve over time in response to the changing environment. The changing factors could include technological changes or advancement, new industry trends, or catching up with competing frameworks. In the case of JavaScript, these factors are advancements to web browsers, Node.js APIs, runtime improvements, and so on. Well-defined abstractions and thoughtful architecture can help you to adapt to these changes, without having to do drastic refactoring in framework projects. Several examples come to mind that show evidence of such drastic changes in environments in which JavaScript frameworks exist, such as the introduction of web components and related modern APIs for frontend frameworks. Some of the frameworks chose to embrace the new standards or integrate with them to be more compatible with the evolving web.</p>
<p>Another example <a id="_idIndexMarker684"/>is migration to the <strong class="bold">ECMAScript module</strong> (<strong class="bold">ESM</strong>) format. First, projects had to adapt to a third-party module system, such as CommonJS or AMD, or implement their own system. Then, as the official JavaScript module definition was created, it was up to the projects to embrace the new ways of structuring code bases. With all the benefits of ESM, such as the static module structure and improved syntax across all JavaScript environments, there were still <a id="_idIndexMarker685"/>intricate incompatibilities across some of the use cases. It is up to framework authors to determine and evaluate the ESM support for their projects. For example, since version 16, the Angular project started off supporting ESM modules as a developer preview and offering it as an option. This enabled the project to expand the feature set with dynamic import expressions and lazy module loading. In addition, the change improved the build-time performance for application builds. It also allowed the framework to use more modern tools such as <em class="italic">esbuild</em>, which was also used in the Componium framework.</p>
<div><div><img alt="Figure 10.2: Partial release notes for Electron.js" src="img/Figure_10.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: Partial release notes for Electron.js</p>
<p>For an application framework such as Electron, the framework feature offers changes on every major release. This is because the major releases often track changes to the underlying Chromium, Node.js, and V8 changes, as seen in the release notes in <em class="italic">Figure 10</em><em class="italic">.2</em>. With new fixes and features in those components, what the framework offers evolves as new releases get shipped to the public. This is a compelling example of how a project leverages continuously evolving improvements from external dependencies.</p>
<p>New features such as server-side rendering have been added to many frameworks as new ways of hydrating and producing views on the server side became available. Existing projects add new capabilities to allow features such as server-side rendering to fit into the existing API <a id="_idIndexMarker686"/>surface and architecture. Across the board, we can see these similar changing trends in projects of all kinds. Thoughtfully adapting to the latest trends avoids project stagnation and allows us to keep up with the latest JavaScript advancements.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Minimalistic approach</h2>
<p>Another common theme is the minimalistic approach to framework design. Some frameworks may choose to focus on simplicity and minimal architectural churn. In these instances, the number of dependencies and complexity are greatly reduced. The more simplistic frameworks can be effective in low-resource environments and for projects that do not <a id="_idIndexMarker687"/>require large framework overhead. In JavaScript projects, these frameworks usually aim to be a simple API with a tiny file size footprint and primarily focus on a specific isolated feature set. If the feature set fits the requirements, choosing this type of approach can reduce the amount of resources for framework development and produce a much cleaner, simpler interface for stakeholders.</p>
<p>To highlight some of the examples, from the frontend perspective, <em class="italic">Preact</em> (<a href="https://preactjs.com">preactjs.com</a>), as a library, takes a minimalistic approach, offering a 3 kilobyte alternative to the React library. It can be used in a minimalistic framework for frontend rendering. A backend example would be the <em class="italic">Hapi.js</em> project from <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. It focuses on the features of building API endpoints really well; if you look at the source of the framework, you will find fewer than 20 files within its core.</p>
<p>It is important to remember that you can build minimalistic frameworks for your needs and don’t always need complex tooling and a large feature set. This type of approach is not always about the final framework size or the number of files in a project, and it can also be used as the guiding principle as you make decisions during framework development. In many senses, when these types of projects are used for real-world projects, they are just as capable of achieving great results.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/>Build tooling</h2>
<p>In <a href="B19014_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, the <em class="italic">Framework compilers and bundlers</em> section showed examples of build tools. These are commonly shipped together with a framework to enable optimized application bundle outputs. Some frameworks also utilize different build tooling types <a id="_idIndexMarker688"/>or have flexible options to allow stakeholders to choose their build tools. Nowadays, the trend is for build tools that make it easier to produce outputs for many JavaScript environments, with a focus on speed. The other principal aspect around the combination of frameworks and build tools is the cooperation of many developers on improving build tooling workflows, enabling more use cases that fit different project requirements.</p>
<p>The additional benefit <a id="_idIndexMarker689"/>of build tools found in popular tools such as <strong class="bold">webpack</strong> is the enforcement of sound patterns and warning developers when application output is not suitable for a client or server environment. For instance, packaging tools can warn developers when a packaged bundle is too big for browsers to load or when it might not conform to the client environment that it targets.</p>
<p>The build tooling drives constant refinements in frameworks, through optimizations and advancements, and contributes to performance improvements for JavaScript applications, which is the next common theme that we will highlight.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Performance improvements</h2>
<p>The emphasis on continuous performance improvements and benchmarking is another theme that is <a id="_idIndexMarker690"/>quite typical among JavaScript frameworks. Depending on the framework environment, the optimizations focus on consuming fewer computer resources, improving load or response times, promoting slicker user interaction, expanding rendering capabilities, and so on. These types of optimizations require greater knowledge of the JavaScript language and the ability to optimize the existing code. The process of optimizations also gets more and more complex for larger projects.</p>
<p>In the many years since the early JavaScript frameworks, there have been quite a few established benchmarks and benchmarking tools. However, in many cases, these types of benchmarks cannot truly benchmark real user behaviors or real-world application use cases. Just like other types of software benchmarking, these performance testing systems establish a standard test to compare implementations in different scenarios. Even though, in many cases, the results can be flawed, they can offer some insight for stakeholders trying to find a framework useful for their use cases. In addition, even after many years of benchmarking battles, frameworks still want to showcase that they are ahead in certain feature sets compared to the competition.</p>
<div><div><img alt="Figure 10.3: An open source js-framework-benchmark" src="img/Figure_10.3_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: An open source js-framework-benchmark</p>
<p><em class="italic">Figure 10</em><em class="italic">.3</em> previews a <a id="_idIndexMarker691"/>filtered example of results from the <strong class="bold">js-framework-benchmark</strong>, which is a benchmark focused on common list operations. It can be found at <a href="https://krausest.github.io/js-framework-benchmark">krausest.github.io/js-framework-benchmark</a>. This particular benchmark focuses on frontend solutions. If you develop a frontend framework, you can <a id="_idIndexMarker692"/>add your code base to the list of existing frameworks to see how it compares. These types of tests can showcase how the framework will work for applications that include complex lists of data, including updates to the rows of data. This benchmark also dives deep to take into account memory usage, load time, and framework size.</p>
<p>Other types <a id="_idIndexMarker693"/>of frameworks require different types of benchmarks. For example, there is a comprehensive comparison at <a href="https://techempower.com/benchmarks">techempower.com/benchmarks</a> for backend web frameworks. These tests outline a particular load test for a server-side framework and include projects from other programming languages. These types of frameworks focus more on the latency of requests, throughput, interaction with database queries, and so on. Aspects of the framework, such as the throughput of requests, demonstrate how a server running a particular framework will act under heavy load.</p>
<p>Different types of frameworks can utilize similar tests that exist in their framework space. If there are no existing types of tests for your kind of framework, then you can establish your <a id="_idIndexMarker694"/>own benchmarks and keep track of the results from release to release, focusing on improving the numbers that are relevant to the performance of the most relevant feature sets.</p>
<p>The common themes of today’s frameworks can vastly influence your framework project, but to create innovation in the systems you build, there is more to learn from upcoming trends. In the following section, we will take a look at future types of trends that influence new JavaScript projects.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/>Future of frameworks</h1>
<p>The JavaScript ecosystem is still one of the most vibrant among other programming languages, and it is bound to grow and expand into new areas. As this happens, we will start seeing future <a id="_idIndexMarker695"/>innovations that will affect how frameworks are built and how they are utilized. The patterns used by the developers we see today will also change as time progresses. Keeping up with the industry tendencies and looking at what is ahead will help you build better systems and incorporate the latest trends into what you build. In this part, we take a look at some potential areas that framework evolution and improvements can potentially head toward.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>Developer experience</h2>
<p>We have seen <a id="_idIndexMarker696"/>how important the <strong class="bold">developer experience</strong> (<strong class="bold">DX</strong>) can be in a framework. In the future, the DX factor will even further differentiate <a id="_idIndexMarker697"/>good frameworks from great ones. Providing additional tooling and finding ways to reduce complexity makes it much easier to start building with a framework. In recent years, we have seen tactics to enable an end-to-end framework DX, helping stakeholders with each step of the process of building applications. In company-backed projects, such as Next.js, those who use the framework experience a fully encompassed workflow from the beginning of development, all the way up to the deployment of applications. The concepts of amazing DX fits really well with the concepts of reducing the overall <a id="_idIndexMarker698"/>complexity of using a framework. Here are a few themes that will be the focus of DX improvements in the future:</p>
<ul>
<li><strong class="bold">Reducing the learning curve</strong>: Framework authors will continue investing in making interfaces more approachable, especially for new developers. In both server and frontend environments, this could mean further aligning with the structure of web APIs, which helps avoid introducing new types of abstractions that have unique interfaces. A tip to a future framework developer would be to contemplate how a learning curve could be simplified for your projects.</li>
<li><strong class="bold">Simplified configuration</strong>: Frameworks will take further steps to simplify out-of-the-box configuration, and picking options that are the best fit will help with development. These will include more sensible defaults, which we saw in <a href="B19014_07.xhtml#_idTextAnchor108"><em class="italic">Chapter 7</em></a>, where certain parts of the framework focus on a simpler configuration. For your own projects, you should take care of every configuration option you introduce and avoid overwhelming users with the necessary configuration steps.</li>
<li><strong class="bold">Improved testing</strong>: Projects will continue to make writing and executing tests easier, further focusing on simplifying the testing of hard-to-test components. For example, as new end-to-end testing frameworks have been developed, these projects have addressed the common developer annoyances of flakiness in tests and lack of debugging tools in CI environments. An emphasis on simplifying testing in your frameworks can help the day-to-day experience of your users, as writing tests is a big time sink.</li>
<li><code>package.json</code> source code. Future projects will likely abstract away some of the tools they use in the background, allowing for more control over the DX. Furthermore, projects will also build more of their own tooling, using the existing primitives available in the ecosystem.</li>
<li><strong class="bold">Focus on performance</strong>: Similar to the performance improvements described in the <em class="italic">Common themes</em> section, projects will continue pushing the limits of the JavaScript language and runtimes to find ways to deliver improvements on aspects such as rendering, latency, and other relevant metrics. With the recent emphasis on performance in the frontend space, developers adhere to indications of quality  that can improve the experience of web applications. These metrics and concepts can be found at <a href="https://web.dev/learn-core-web-vitals">web.dev/learn-core-web-vitals</a>.</li>
<li><strong class="bold">Additional flexibility</strong>: Frameworks will continue adding more options to support different environments. For instance, backend solutions will expand integrations <a id="_idIndexMarker699"/>with more databases. Application frameworks, such as Electron, will take advantage of the latest APIs available to them in the browser runtime and within the operating system. For the frameworks you build, you should aim to strike a balance between flexibility and the number of use cases you support. You should only add additional support for use cases if you have enough resources to maintain this large set of features.</li>
<li><strong class="bold">Packaging and bundling improvements</strong>: There have been significant changes in how frameworks package their application code. This focus on improved packaging techniques will only continue with a priority on speed and enabling more options to bundle code in different ways. For framework developers like yourself, it is important to keep up with the latest improvements to these types of bundling tools, as they can benefit how you approach the packaging of the system you build.</li>
</ul>
<p>This list does not cover all the potential directions of what JavaScript systems will head towards in the future. However, following the established trajectory of the existing projects helps to highlight where you, as a framework developer, can deliver significant impact and make a difference for your users.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>Embracing new technologies</h2>
<p>Besides the developer experience improvements, new technologies are made available in places where JavaScript applications execute. As highlighted in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, web assembly will <a id="_idIndexMarker700"/>play an important role in enabling the next generation of solutions for computation-heavy tasks. This has the potential to expand the code base of the existing frameworks to include lower-level languages. It will also require maintainers to expand their domain knowledge beyond just JavaScript code. On the theme of other languages, the usage of TypeScript will continue to grow, as its benefits are very worthwhile to framework authors. However, consumers of frameworks will still be able to use the <em class="italic">built</em> versions of frameworks that were originally transpiled from TypeScript.</p>
<p>Additional improvements to browser engines will also drive performance boosts and new capabilities in places where a framework relies on web browser engine behavior. One outlet to get inspiration from is the <code>blink-dev</code> mailing list at <a href="https://groups.google.com/a/chromium.org/g/blink-dev">groups.google.com/a/chromium.org/g/blink-dev</a>, which highlights the upcoming changes that will end up in Chromium and Chrome browsers.</p>
<p>Package management is also an area where a lot of new technological changes will occur. Almost every project relies on package management tooling, such as <code>npm</code>, to resolve and build its code base. Package managers are so heavily involved in the development workflow that any improvement will impact JavaScript development drastically. The future will bring better versioning, dependency resolution, enhanced security of projects, and so on. The evolution of package managers should also make framework organization and development easier, allowing authors to lay out their projects in more developer-friendly ways.</p>
<p>Another big new instrument is the use of AI-powered models for the benefit of all the framework aspects, explored in the following section.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>The use of large language models</h2>
<p>In recent <a id="_idIndexMarker701"/>years, the advancement <a id="_idIndexMarker702"/>of <strong class="bold">large language models</strong> (<strong class="bold">LLMs</strong>) powered by different neural networks has affected software workflows and tools. As a step in framework development, the use of artificial intelligence tooling will likely become more prevalent. Similar to the importance of including documentation for project releases, developers will bundle a trained model specifically for their framework. This model can be aware of the project’s public APIs, internals, and documentation. The intertwined models can be involved at different stages of the development process. For instance, as you refactor code, an AI assistant powered by the trained model can provide you with suggestions for potential changes. As these model integrations become increasingly refined, they could also take over some of the more repetitive or redundant tasks involved in project maintenance.</p>
<div><div><img alt="Figure 10.4: An example of the Astro AI framework assistant" src="img/Figure_10.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: An example of the Astro AI framework assistant</p>
<p>Using a <a id="_idIndexMarker703"/>real-world example, as shown in <em class="italic">Figure 10</em><em class="italic">.4</em>, the all-in-one framework <strong class="bold">Astro</strong> specifically trained a model to answer questions about a project. This developer tool is made available for public use, solving potential support and integration hurdles by allowing users to ask questions about the project. The tool is available at <a href="https://houston.astro.build">houston.astro.build</a>. This type of tooling can accept a query about certain features of the project, such as creating API routes and endpoints. The response consists of a text response gathered from a mix of documentation and the conversation model. The final resources link directs a user to <a href="https://docs.astro.build/en/core-concepts/endpoints">docs.astro.build/en/core-concepts/endpoints</a>, which has information about configuring the endpoints for applications that utilize this framework.</p>
<p>Connecting these similar ideas of using trained AI models for the sake of better developer experience, trained LLMs can be used for scaffolding purposes and within the framework tooling itself. In <a href="B19014_08.xhtml#_idTextAnchor138"><em class="italic">Chapter 8</em></a>, we have seen examples of generating code within the Componium framework; a potential future enhancement can be prompted for a query from an application developer about the component they are trying to build. The later <a id="_idIndexMarker704"/>generated code can save a lot of time for developers, reducing the amount of documentation they have to read and the amount of code they have to write. Creating and understanding these LLM-powered integrations would be an additional step to the full stack developer paradigm. Integrating these types of LLMs at different stages of framework development and maintenance will change where framework authors spend most of their time within a project.</p>
<p>With the current and future themes covered, let's explore what other aspects we should consider that fit into the development of new framework projects.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Additional considerations</h1>
<p>In <a href="B19014_05.xhtml#_idTextAnchor073"><em class="italic">Chapter 5</em></a>, we explored a wide range of framework considerations, specifically affecting the technical architecture. As creating a new framework project, even with a totally unique <a id="_idIndexMarker705"/>technical feature set, is a big decision, let's examine a few additional considerations. Outside of the technical challenges, this examination will help us decide whether starting a project from scratch and maintaining it for a long time is worth an investment. Successfully producing a framework project with a lot of stakeholders and targeted users will require both time investment and financial backing.</p>
<p>Besides the technical hurdles and architectural challenges, framework developers need to consider the probable return on investment when embarking on a new project. Looking at some of the established projects in the JavaScript space, many of them have been multi-year investments, with a huge number of developers contributing paid or open source time to enable the feature set. Let’s focus on the particular three pillars of time investment, user support, and financial backing in the following sections.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Time investment</h2>
<p>Framework <a id="_idIndexMarker706"/>developers need to consider a new project’s time investment and lifespan. It’s not simply about the development phase but also the life cycle commitment it entails, which could affect multiple teams within an organization or the company’s larger goals. Open source developers have similar commitments to consider but with lesser responsibility, especially at the early stages of the project. Unlike typical JavaScript application projects, framework development typically doesn’t have a linear timeline or a designated end milestone where a deliverable is considered complete. Instead, the process is iterative, with development cycles, testing, refinement, and updating. These themes link back to the chapters on maintenance and the development life cycle of new features.</p>
<p>A framework <a id="_idIndexMarker707"/>project will demand more than a sizable initial coding investment created by one developer or a whole team. The ongoing updates necessary to adapt to ever-evolving requirements and technological conventions will require equally weighty commitments. Considering the tasks we saw in <a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, the maintenance time investment encompasses the need for a comprehensive workflow, involving many developers. When choosing to build a new solution, consider how much time you are willing to invest and what size framework you can successfully execute on. Making a considerate decision will determine whether your framework effort will succeed.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>User support</h2>
<p>As important as time investment is user support, which often determines the success of a project. Besides producing readable and well-organized documentation, a deep understanding <a id="_idIndexMarker708"/>of the challenges and needs of users spans beyond the code base. For all types of framework projects, as a developer, you will find yourself or your team acting as support and troubleshooting framework integration aspects. To give a public example, the Vue.js project has a discussion forum where users publish their technical and architectural questions: <a href="https://github.com/vuejs/core/discussions">github.com/vuejs/core/discussions</a>. It is up to the team to respond to these queries and maintain a good community posture. In projects that are internal to the company, framework authors often set up a similar platform to interact with consumers. For smaller companies, this support interaction is much more hands-on and direct. However, in all of these scenarios, the support aspects take up important development time.</p>
<p>The best strategy to reduce this type of churn is to constantly work on improving support workflows. Improvements can include organizing frequently asked questions for later use, creating guides for complicated framework integrations, and making the framework knowledge base as discoverable as possible. Just like the cyclical development process seen in <a href="B19014_09.xhtml#_idTextAnchor156"><em class="italic">Chapter 9</em></a>, as a maintainer, you will find yourself in an ongoing commitment to support new and older users of your project. For a project to be successful, you have <a id="_idIndexMarker709"/>to put your users first and be able to address their needs in an acceptable manner.</p>
<p>All this time investment in additional aspects of framework building requires a monetary budget, which we will highlight in the following section.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>Financial backing</h2>
<p>Among the complex technical challenges, time investment, and logistics of supporting a project, there is another <a id="_idIndexMarker710"/>factor to consider for a framework – that is, the presence of financial backing. Funding a new project will require enduring the ongoing expenses for feature development and infrastructure costs. Additional costs could arise, depending on the environment of your project – for example, if you are trying to promote an enterprise framework to potential customers. In a company setting, where the framework powers the foundational services and products indirectly, the funding can trickle down from the profits of the products.</p>
<p>Most open source projects are often not fully funded but could be sponsored by a larger organization with a big enough budget for projects, which also indirectly help development efforts or advance the agenda of the organization. For instance, the Cypress open source testing framework has a paid Cypress Cloud service that enables a dedicated environment. Conversely, some of the open source developers utilize platforms such as Patreon or GitHub Sponsors to fund projects, getting direct financial contributions from companies and individual users.</p>
<p>These additional considerations can play an important role in planning and executing your project. Depending on your development goals, some of these factors can make or break the framework project you are trying to establish.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Summary</h1>
<p>This chapter has brought to attention the three final topics that can help framework developers better understand the efforts of creating new frameworks, under the common themes of JavaScript development. A look at the future of projects also helps developers understand and prepare for what is to come in this particular technological space. By exploring the common themes, you gain knowledge of how modular projects can be and how their design evolves as time goes on, making it easier to make decisions about self-created projects. Similarly, learning about approaches to performance optimizations and unique architectural patterns can be beneficial to prospective framework authors.</p>
<p>In the second section, the chapter highlighted upcoming trends and looked at the future potential of frameworks, offering us a glimpse of what is to come in this space. The next generation of framework authors and maintainers gets to experience the new challenges of the JavaScript environment and refactor existing solutions to make them more capable in new ways. The expectations of a better developer experience and the still unknown possibilities of LLMs keep the framework space super exciting for both experienced and upcoming JavaScript developers.</p>
<p>Toward the end, the chapter highlighted additional considerations that can help developers make the right decisions in terms of starting new projects. These non-technical considerations are much less exciting to the developers, but they are crucial to the framework creation process. This final chapter aims to provide further insights to bolster your understanding of framework development and prepare you for success in your real-world projects.</p>
<p>In conclusion, the goal of this and all the chapters before it was to demystify the framework development methods and make the process of building your own JavaScript frameworks much more approachable to all. With this acquired knowledge, you now have the skills to make better decisions and drive more complex framework-related projects to success. We began this book with our journey, looking at existing projects, then identified crucial parts of framework development, and later concluded by building a full-stack framework from scratch. This includes an exploration of architectural patterns and project considerations.</p>
<p>Let's summarize the topics that we learned about in all these chapters:</p>
<ul>
<li><strong class="bold">Knowledge of other projects in the JavaScript space</strong>: The initial chapter showcased how different types of frameworks have emerged and what problems they solve for a larger developer user base. The collection of projects gave us a peek into existing solutions that help solve software challenges.</li>
<li><strong class="bold">Framework organization and building blocks</strong>: This taught us the basics around abstractions in frameworks and the basics of the building blocks applied to backend, frontend, and other types of initiatives.</li>
<li><strong class="bold">Architectures and patterns</strong>: This showed us examples of concepts and structures behind the existing projects, such as Angular and Vue.js. This included mentions of additional tooling that helps put frameworks together for consumption.</li>
<li><strong class="bold">Ensuring framework quality</strong>: This taught us ideas of how frameworks can provide a quality experience through creating documentation, ensuring well-tested components, and how development tooling can help ensure the delivery of good software to its users.</li>
<li><strong class="bold">Overview of project considerations</strong>: This helped create a plan for development, with aspects to consider before starting work on technical problems.</li>
<li><strong class="bold">Creating a new testing framework</strong>: This gave us practical experience in creating a practical framework project. This introduced the technical architecture behind a testing system with detailed features.</li>
<li><strong class="bold">Developing backend components</strong>: This continued the practical approach with a focus on backend development. We outlined an approach to server-side solutions and developer experience of Componium.</li>
<li><strong class="bold">Crafting frontend components</strong>: This was the final part of the practical approach that specializes in frontend components. It included architectural design, with concepts of reactivity, server-side rendering, and so on.</li>
<li><strong class="bold">The effort it takes to maintain a project</strong>: This taught us about the tasks that framework developers have to perform daily and cyclically as new features and fixes get added to a project.</li>
<li><strong class="bold">Learning about common themes of today and the future</strong>: Finally, this part summarized the typical things we see in JavaScript projects today, with additional considerations for new projects and the future.</li>
</ul>
<p>All this newly gathered knowledge will unlock more possibilities for you in the JavaScript ecosystem, enabling you to be a more effective and acquainted engineer, greatly benefiting your career and the projects you are responsible for. The web application development field is constantly evolving in many ways, which powers this exciting ecosystem of JavaScript frameworks. Even with the availability of flexible building blocks and fully fledged solutions, there is still room for further expansion and improvement – it has never been a better time to develop a JavaScript framework or contribute to one!</p>
</div>
</body></html>