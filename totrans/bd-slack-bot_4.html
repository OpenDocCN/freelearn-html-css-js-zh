<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Data</h1></div></div></div><p>Now that we've seen how to process keywords, commands, and API calls, we will look at the next logical step in bot building: persistent data storage and retrieval. References to data can be kept in JavaScript by assigning said data to a variable; however, its use is limited to when the program is running. If the program is stopped or restarted, we lose the data. Hence, persistent data storage is required for certain tasks.</p><p>This allows us to build bots that can, for instance, keep track of a leaderboard or store a to-do list.</p><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to Redis</li><li class="listitem" style="list-style-type: disc">Connecting to Redis</li><li class="listitem" style="list-style-type: disc">Saving and retrieving data</li><li class="listitem" style="list-style-type: disc">Best practices</li><li class="listitem" style="list-style-type: disc">Error handling</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Introduction to Redis</h1></div></div></div><p>In the previous <a class="indexterm" id="id145"/>chapter, we discovered how to create a competitive roll bot that allows users to play a "Who can roll the highest" game. Although it worked admirably, the feature sorely missing is a leaderboard of sorts, where each user's wins and losses are stored and an overall winners list is kept.</p><p>Such a feature wouldn't be difficult to produce; however, the largest problem comes in storing the data. Any data stored in JavaScript variables would be lost once the program ends or crashes. A better solution would then be to maintain a persistent database, which our bot can write to and read from.</p><p>There is a wide variety of database services to choose from; you might already be familiar with MySQL or MongoDB. For the example bots in this chapter, we will pick a service that is easy to set up and simple to use.</p><p>The database service we will use is <a class="indexterm" id="id146"/>Redis: <a class="ulink" href="http://redis.io/">http://redis.io/</a>.</p><p>The Redis website describes the technology as follows:</p><div><blockquote class="blockquote"><p><em>"Redis is an open source (BSD licensed), in-memory data structure store, used as database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster."</em></p></blockquote></div><p>A simpler explanation is that Redis is an efficient in-memory key-value store. Keys can be simple strings, hashes, lists (an ordered collection), sets (unordered collection of non-repeating values), or sorted sets (ordered or ranked collection of non-repeating values). Despite the complex official description, setting up and using Redis is a quick and painless process.</p><p>Redis' advantages are its <a class="indexterm" id="id147"/>impressive speed, cross-platform communication, and simplicity.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Getting started with Redis is simple, but we will only be exploring the tip of the Redis iceberg. For more information on advanced uses of Redis, visit the Redis website.</p></div></div><p>There are many <a class="indexterm" id="id148"/>Redis client implementations written in a wide variety of languages (<a class="ulink" href="http://redis.io/clients">http://redis.io/clients</a>), but we will use a Node-based Redis client.</p><p>Bear in mind that Redis is but one solution to the persistent data problem. Other solutions might include the use of a MySQL relational or a MongoDB non-relational database.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Installing Redis</h2></div></div></div><p>To connect to Redis, we <a class="indexterm" id="id149"/>will use the Node Redis package. First, we must install and run our Redis server so Node will have something to connect to. Follow the instructions for your operating system of choice.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Mac OS X</h3></div></div></div><p>The simplest way to <a class="indexterm" id="id150"/>install Redis is through the <code class="literal">homebrew</code> package manager. <code class="literal">homebrew</code> makes it easy to install applications and services through the command line.</p><p>If you are unable to use <a class="indexterm" id="id151"/>
<code class="literal">homebrew</code>, visit the Redis quick start guide to install Redis manually: (<a class="ulink" href="http://redis.io/topics/quickstart">http://redis.io/topics/quickstart</a>).</p><p>If you are unsure whether you have Homebrew installed, open a terminal and run the following:</p><div><pre class="programlisting">
<strong>which brew</strong>
</pre></div><p>If nothing returns, run the following in your terminal:</p><div><pre class="programlisting">
<strong>/usr/bin/ruby -e "$(curl –fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</strong>
</pre></div><p>Follow the onscreen <a class="indexterm" id="id152"/>prompts until <code class="literal">homebrew</code> is successfully installed. To install Redis, run the following:</p><div><pre class="programlisting">
<strong>brew install redis</strong>
</pre></div><p>Once the installation has completed, you can start a Redis server by using the following command in your terminal:</p><div><pre class="programlisting">
<strong>redis-server</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Windows</h3></div></div></div><p>Visit the official Microsoft <a class="indexterm" id="id153"/>GitHub project for Redis and grab the latest release here: <a class="ulink" href="https://github.com/MSOpenTech/redis/releases">https://github.com/MSOpenTech/redis/releases</a>. Once unzipped, you can run <code class="literal">redis-server.exe</code> to start the service and <code class="literal">redis-cli.exe</code> to connect to the server through the shell.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Unix</h3></div></div></div><p>Refer to the Redis <a class="indexterm" id="id154"/>quickstart page for instructions on how to install on Linux/Unix systems: <a class="ulink" href="http://redis.io/topics/quickstart">http://redis.io/topics/quickstart</a>.</p><p>Once installed, you can start the server with the <code class="literal">redis-server</code> command and connect to the server via <code class="literal">redis-cli</code>. These commands function in the exact same way on OS X.</p><p>Now that Redis is installed, start the service and you should see something like this:</p><div><img alt="Unix" src="img/B05384_04_01.jpg"/><div><p>Redis successfully starting a server</p></div></div><p>Redis is now up and ready to be used on the default port 6379. Other ports may be used instead, but the default <a class="indexterm" id="id155"/>port is sufficient for our purposes.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Connecting to Redis</h1></div></div></div><p>To demonstrate how to <a class="indexterm" id="id156"/>connect to Redis, we will create a new bot project (including the <code class="literal">Bot</code> class defined in <a class="link" href="ch03.html" title="Chapter 3. Adding Complexity">Chapter 3</a>, <em>Adding Complexity</em>). We'll start by installing the Redis Node client, executing the following:</p><div><pre class="programlisting">
<strong>npm install redis</strong>
</pre></div><p>Now, create a new <code class="literal">index.js</code> file and paste in the following code:</p><div><pre class="programlisting">'use strict';

const redis = require('redis');
const Bot = require('./Bot');

const client = redis.createClient();

const bot = new Bot({
  token: process.env.SLACK_TOKEN,
  autoReconnect: true,
  autoMark: true
});

client.on('error', (err) =&gt; {
    console.log('Error ' + err);
});

client.on('connect', () =&gt; {
  console.log('Connected to Redis!');
});</pre></div><p>This snippet will import the Redis client and connect to the local instance running via the <code class="literal">createClient()</code> method. When not supplied with any arguments, the aforementioned method will assume the service is running locally on the default port of 6379. If you wish to connect to a different <a class="indexterm" id="id157"/>host and port combination, then you can supply them with following:</p><div><pre class="programlisting">let client = redis.createClient(port, host);</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>For the purposes of this book, we will be using an unsecure Redis server. Without authentication or other security measures, your data could be accessed and edited by anyone who connects to your data service. If you intend to use Redis in a production environment, it is strongly recommended you read up on Redis security.</p></div></div><p>Next, ensure that you have the Redis client running in a different terminal window and start up our bot in the usual way:</p><div><pre class="programlisting">
<strong>SLACK_TOKEN=[your_token_here] node index.js</strong>
</pre></div><p>If all goes well, you should be greeted by this happy message:</p><div><img alt="Connecting to Redis" src="img/B05384_04_02.jpg"/><div><p>Our Node app has successfully connected to the local Redis server</p></div></div><p>As promised, setting up and connecting to Redis was an easy and quick endeavor. Next, we will look at actually <a class="indexterm" id="id158"/>setting and getting data from our server.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Saving and retrieving data</h1></div></div></div><p>First, let's look <a class="indexterm" id="id159"/>at what the Redis client has to offer us. Add the following <a class="indexterm" id="id160"/>lines to <code class="literal">index.js</code>:</p><div><pre class="programlisting">client.set('hello', 'Hello World!');

client.get('hello', (err, reply) =&gt; {
  if (err) {
    console.log(err);
    return;
  }

  console.log(`Retrieved: ${reply}`);
});</pre></div><p>In this example, we will set the value "Hello world!" in Redis with the key <code class="literal">hello</code>. In the <code class="literal">get</code> command, we specify the key we wish to use to retrieve a value.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>The Node Redis client <a class="indexterm" id="id161"/>is entirely <strong>asynchronous</strong>. This means that you have to supply a callback function with each command if you wish to process data.</p></div></div><p>A common mistake is to use the Node Redis client in a synchronous way. Here's an example:</p><div><pre class="programlisting">let val = client.get('hello');
console.log('val:', val);</pre></div><p>This, perhaps confusingly, results in:</p><div><pre class="programlisting">
<strong>val: false</strong>
</pre></div><p>This is because the <code class="literal">get</code> function will have returned the Boolean <code class="literal">false</code> before the request to the Redis server has been made.</p><p>Run the correct code and you should see the successful retrieval of the <strong>Hello world!</strong> data:</p><div><img alt="Saving and retrieving data" src="img/B05384_04_03.jpg"/><div><p>Our stored value is successfully retrieved</p></div></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The maximum file size of a Redis string is 512 megabytes. If you need to store something larger than this, consider using multiple key/value pairings.</p></div></div><p>When developing <a class="indexterm" id="id162"/>Redis functionality, a good tip is to use the Redis client's built-in <code class="literal">print</code> <a class="indexterm" id="id163"/>command for easy debugging and testing:</p><div><pre class="programlisting">client.set('hello', 'Hello World!', redis.print);

client.get('hello', redis.print);</pre></div><p>This will print the following in the terminal:</p><div><pre class="programlisting">
<strong>Reply: OK</strong>
<strong>Reply: Hello World!</strong>
</pre></div><p>As we progress through the chapter, we will introduce more useful functions and methods provided by the Redis <a class="indexterm" id="id164"/>client. For a complete list and documentation, visit <a class="ulink" href="https://github.com/NodeRedis/node_redis">https://github.com/NodeRedis/node_redis</a>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Connecting bots</h2></div></div></div><p>With our Redis <a class="indexterm" id="id165"/>server set up and the basic commands covered, let's apply what we've learned to a simple bot. In this example, we will code a bot that instructs the bot to <em>remember</em> a phrase based on a given key value.</p><p>Add the following code to your <code class="literal">index.js</code> file:</p><div><pre class="programlisting">bot.respondTo('store', (message, channel, user) =&gt; {
  let msg = getArgs(message.text);

  client.set(user.name, msg, (err) =&gt; {
    if (err) {
      channel.send('Oops! I tried to store that but something went wrong :(');
    } else {
      channel.send(`Okay ${user.name}, I will remember that for you.`);
    }
  });
}, true);

bot.respondTo('retrieve', (message, channel, user) =&gt; {
  bot.setTypingIndicator(message.channel);

  client.get(user.name, (err, reply) =&gt; {
    if (err) {
     console.log(err);
     return;
    }

    channel.send('Here\'s what I remember: ' + reply);
  });
});</pre></div><p>Using the familiar <code class="literal">respondTo</code> command introduced in the <code class="literal">Bot</code> class of the previous chapter, we set up our bot to <a class="indexterm" id="id166"/>listen for the keyword <code class="literal">store</code> and then set that value in the Redis data store, using the message sender's name as a key. Let's see this in action:</p><div><img alt="Connecting bots" src="img/B05384_04_04.jpg"/><div><p>Our bot remembers what we told it to</p></div></div><p>Notice how we use the callback function of the set method to ensure that the data was saved correctly, and informing the user if it was not.</p><p>While not terribly impressive behavior, the important thing to realize is that our bot has successfully stored values in the <a class="indexterm" id="id167"/>Redis data store. Redis will store the key value pairing on the local disk, which means that even if the bot and/or Redis server are stopped and started again the data will persist.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Dynamic storage</h2></div></div></div><p>Once again, let's <a class="indexterm" id="id168"/>increase the complexity a bit. In the previous example, the key used to store data is always the command giver's name. In reality, this is impractical as it means a user could only store one thing at a time, overwriting the value each time they issued the command. In this next section, we will be augmenting our bot to allow the user to specify the key of the value to be stored, allowing for the storage of multiple values.</p><p>Delete the previous <a class="indexterm" id="id169"/>
<code class="literal">respondsTo</code> commands and paste in the following snippets, noting the highlighted code:</p><div><pre class="programlisting">bot.respondTo('store', (message, channel, user) =&gt; {
  let args = getArgs(message.text);

<strong>  let key = args.shift();</strong>
<strong>  let value = args.join(' ');</strong>

<strong>  client.set(key, value, (err) =&gt; {</strong>
<strong>    if (err) {</strong>
<strong>      channel.send('Oops! I tried to store something but something went wrong :(');</strong>
<strong>    } else {</strong>
<strong>      channel.send(`Okay ${user.name}, I will remember that for you.`);</strong>
<strong>    }</strong>
<strong>  });</strong>
}, true);

bot.respondTo('retrieve', (message, channel, user) =&gt; {
  bot.setTypingIndicator(message.channel);

  let key = getArgs(message.text).shift();

  client.get(key, (err, reply) =&gt; {
    if (err) {
     console.log(err);
     channel.send('Oops! I tried to retrieve something but something went wrong :(');
     return;
    }

    channel.send('Here\'s what I remember: ' + reply);
  });
});</pre></div><p>In this interpretation, we expect the user to provide a command in the following format:</p><div><pre class="programlisting">
<strong>store [key] [value]</strong>
</pre></div><p>To extract the key and value from the command, we first use JavaScript's <code class="literal">Array.shift</code> to remove and return the value at index 0 of the <code class="literal">args</code> array. Then, it's a simple case of collecting the rest of the arguments as the value by using <code class="literal">Array.join</code>. Now, we apply what we learned in the previous section to store the user-defined key and value in the Redis instance.</p><p>When the <code class="literal">retrieve</code> command is given, we use the same <code class="literal">Array.shift</code> technique to extract the key requested. We <a class="indexterm" id="id170"/>will then use it to retrieve the stored data. Let's see it is in action:</p><div><img alt="Dynamic storage" src="img/B05384_04_05.jpg"/><div><p>Storing and retrieving multiple entities</p></div></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Emojis within a message's text are converted into their basic text components. For instance, the thumbs up emoji is translated to <code class="literal">:+1</code>. This conversion works both ways, which means that <a class="indexterm" id="id171"/>Slack will automatically render any emoji text the bot sends.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Hashes, lists, and sets</h2></div></div></div><p>So far, we've used a single data type for our keys and values: strings. While keys are limited to string values, Redis allows for the value to be a variety of different data types. The different types are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">String</li><li class="listitem" style="list-style-type: disc">Hash</li><li class="listitem" style="list-style-type: disc">List</li><li class="listitem" style="list-style-type: disc">Set</li><li class="listitem" style="list-style-type: disc">Sorted set</li></ul></div><p>We are already familiar with strings, so let's work down the list and explain the different data types.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Hashes</h3></div></div></div><p>Hashes are <a class="indexterm" id="id172"/>similar to JavaScript objects. However, they differ in that Redis hashes do not support nested objects. All the property values of a hash will be cast to strings. Take the following JavaScript object:</p><div><pre class="programlisting">let obj = {
  foo: 'bar',
  baz: {
    foobar: 'bazfoo'
  }
};</pre></div><p>The <code class="literal">baz</code> property contains an object, and we can store the <code class="literal">obj</code> object in Redis by using the <code class="literal">hmset</code> function:</p><div><pre class="programlisting">client.hmset('obj', obj);</pre></div><p>Then, we retrieve the data with <code class="literal">hgetall</code>:</p><div><pre class="programlisting">client.hgetall('obj', (err, object) =&gt; {
  console.log(object);
});</pre></div><p>This will log the following line in our terminal:</p><div><pre class="programlisting">{ foo: 'bar', baz: '[object Object]' }</pre></div><p>Redis has stored the nested <code class="literal">baz</code> object by first calling the <code class="literal">Object.toString()</code> function on it, which means that the string value is returned when we perform our <code class="literal">hgetall</code> function.</p><p>A workaround is to leverage JavaScript's <code class="literal">JSON</code> object to stringify our nested object before storing and then parsing <a class="indexterm" id="id173"/>the object returned from Redis. Observe the following example:</p><div><pre class="programlisting">let obj = {
  foo: 'bar',
  baz: {
    foobar: 'bazfoo'
  }
};

function stringifyNestedObjects(obj) {
  for (let k in obj) {
    if (obj[k] instanceof Object) {
      obj[k] = JSON.stringify(obj[k]);  
    }
  }

  return obj;
}

function parseNestedObjects(obj) {
  for (let k in obj) {
    if (typeof obj[k] === 'string' || obj[k] instanceof String) {
      try {
        obj[k] = JSON.parse(obj[k]);
      } catch(e) {
        // string wasn't a stringified object, so fail silently
      }      
    }
  }

  return obj;
}

client.hmset('obj', stringifyNestedObjects(obj));

client.hgetall('obj', (err, object) =&gt; {
  console.log(parseNestedObjects(object));
});</pre></div><p>When executed, we <a class="indexterm" id="id174"/>see the logged result:</p><div><pre class="programlisting">{ foo: 'bar', baz: { foobar: 'bazfoo' } }</pre></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>The examples given here only stringify and parse objects nested one level deep. In order to stringify and parse an object of <em>N</em> depth, look into the recursion programming technique. A good example can be found at <a class="ulink" href="https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx">https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Lists</h3></div></div></div><p>Redis lists are <a class="indexterm" id="id175"/>functionally the same as JavaScript arrays. Like with objects, the value of every index is converted into a string when storing. When dealing with a multidimensional array (for example, an array containing a subset of arrays) the <code class="literal">toString</code> function will be called before storing in Redis. A simple <code class="literal">Array.join(',')</code> can be used to convert this string value back to an array.</p><p>The <code class="literal">lpush</code> and <code class="literal">rpush</code> commands can be used to store our list:</p><div><pre class="programlisting">client.rpush('heroes', ['batman', 'superman', 'spider-man']);</pre></div><p>In the preceding snippet, we are pushing our array of heroes to the right of the list. This works exactly the same as JavaScript's <code class="literal">Array.push</code>, where the new values are appended to the existing array. In this case, it means that previously empty list now contains our <code class="literal">heroes</code> array.</p><p>We can push to the left of the array to prepend to the list:</p><div><pre class="programlisting">client.lpush('heroes', 'iron-man');</pre></div><p>This will result in our list looking like so:</p><div><pre class="programlisting">[ 'iron-man', 'batman', 'superman', 'spider-man' ]</pre></div><p>Finally, to access our Redis list we can use the <code class="literal">lrange</code> method:</p><div><pre class="programlisting">client.lrange('heroes', 0, -1, (err, list) =&gt; {
  console.log(list);
});</pre></div><p>The second and third arguments provided to <code class="literal">lrange</code> are the selection start and end position. To return all the <a class="indexterm" id="id176"/>elements in the list rather than a subset, we can provide -1 as an end position.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Sets</h3></div></div></div><p>Sets are similar to <a class="indexterm" id="id177"/>Redis lists with one very useful difference: sets do not allow duplicates. Consider the following example:</p><div><pre class="programlisting">client.sadd('fruits', ['apples', 'bananas', 'oranges']);
client.sadd('fruits', 'bananas');

client.smembers('fruits', (err, set) =&gt; {
  console.log(set);
});</pre></div><p>Here, we use the Redis client's <code class="literal">sadd</code> to store the set and <code class="literal">smembers</code> to retrieve it. In the second line, we attempt to add the fruit <code class="literal">'bananas'</code> to the <code class="literal">'fruits'</code> list, but since the value already exists, the <code class="literal">sadd</code> call silently fails. The retrieved set is as expected:</p><div><pre class="programlisting">[ 'oranges', 'apples', 'bananas' ]</pre></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>You might notice that the ordering of the retrieved 'fruits' set is different from the order that it was stored in. This is because a set is built using <code class="literal">HashTable</code>, which means there are no guarantees to the order of the elements. If you want to store your elements in a particular order, you must use a list or a sorted set.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Sorted sets</h3></div></div></div><p>Functioning as a sort of <a class="indexterm" id="id178"/>hybrid between lists and sets, sorted sets have a specific order and cannot contain duplicates. See the following example:</p><div><pre class="programlisting">client.zadd('scores', [3, 'paul', 2, 'caitlin', 1, 'alex']);

client.zrange('scores', 0, -1, (err, set) =&gt; {
  console.log(set);
});

client.zrevrange('scores', 0, -1, 'withscores', (err, set) =&gt; {
  console.log(set);
});</pre></div><p>Using the <code class="literal">zadd</code> method, we specify the key for our sorted set and an array of values. The array indicates the order of the stored set by following this format:</p><div><pre class="programlisting">[ score, value, score, value ... ]</pre></div><p>The <code class="literal">zrange</code> method uses similar arguments to <code class="literal">lrange</code>, we specify the start and end positions of the set to be returned. This method will return the set in ascending order:</p><div><pre class="programlisting">[ 'alex', 'caitlin', 'paul' ]</pre></div><p>We can reverse this by using <code class="literal">zrevrange</code>. Note how we also provide the <code class="literal">withscores</code> string as an argument. This argument will return the scores of each element:</p><div><pre class="programlisting">[ 'paul', '3', 'caitlin', '2', 'alex', '1' ]</pre></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>The <code class="literal">withscores</code> argument can be used for all sorted set retrieval methods.</p></div></div><p>As you might have realized already, sorted sets especially shine when used to keep track of game scores or leaderboards. With that in mind, let's revisit our "roll" bot from <a class="link" href="ch03.html" title="Chapter 3. Adding Complexity">Chapter 3</a>, <em>Adding Complexity</em>, and add a leaderboard of winners.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Best practices</h1></div></div></div><p>Any user should be able to <a class="indexterm" id="id179"/>store data in Redis via bot commands; it is however recommended you ensure that the data storage methods cannot be easily abused. Accidental abuse might happen in the form of many different Redis calls in a short amount of time. For more information on Slack channel spam and remedies, revisit <a class="link" href="ch02.html" title="Chapter 2. Your First Bot">Chapter 2</a>, <em>Your First Bot</em>.</p><p>By restricting bot traffic, we can ensure that Redis does not receive an inordinate amount of write and retrieve actions. If you ever find that Redis latency is not as good as it should be, visit this webpage to help <a class="indexterm" id="id180"/>troubleshoot: <a class="ulink" href="http://redis.io/topics/latency">http://redis.io/topics/latency</a>.</p><p>Let's now look at how we can improve familiar bot behavior with the addition of Redis data storage.</p><p>First, here is our <code class="literal">roll</code> command, with the new Redis store code highlighted:</p><div><pre class="programlisting">bot.respondTo('roll', (message, channel, user) =&gt; {
  // get the members of the channel
  const members = bot.getMembersByChannel(channel);

  // make sure there actually members to interact with. If there
  // aren't then it usually means that the command was given in a  
  // direct message
  if (!members) {
    channel.send('You have to challenge someone in a channel, not a direct message!');
    return;
  }

  // get the arguments from the message body
  let args = getArgs(message.text);

  // if args is empty, return with a warning
  if (args.length &lt; 1) {
    channel.send('You have to provide the name of the person you wish to challenge!');
    return;
  }

  // the user shouldn't challenge themselves
  if (args.indexOf(user.name) &gt; -1) {
    channel.send(`Challenging yourself is probably not the best use of your or my time, ${user.name}`);
    return;
  }

  // does the opponent exist in this channel?
  if (members.indexOf(args[0]) &lt; 0) {
    channel.send(`Sorry ${user.name}, but I either can't find ${args[0]} in this channel, or they are a bot!`);
    return;
  }

  // Roll two random numbers between 0 and 100
  let firstRoll = Math.round(Math.random() * 100);
  let secondRoll = Math.round(Math.random() * 100);

  let challenger = user.name;
  let opponent = args[0];

  // reroll in the unlikely event that it's a tie
  while (firstRoll === secondRoll) {
    secondRoll = Math.round(Math.random() * 100);
  }

  let winner = firstRoll &gt; secondRoll ? challenger : opponent;

<strong>  client.zincrby('rollscores', 1, winner);</strong>

  // Using new line characters (\n) to format our response
  channel.send(
    `${challenger} fancies their changes against ${opponent}!\n
    ${challenger} rolls: ${firstRoll}\n
    ${opponent} rolls: ${secondRoll}\n\n
    *${winner} is the winner!*`
  );

}, true);</pre></div><p>To store the user's win, we <a class="indexterm" id="id181"/>use the Redis client's <code class="literal">zincrby</code> method, which will increment the winner's score by one. Note how we can specify how much to increment by in the second argument. If the key (the winner's name here) doesn't exist in the set, it is automatically created with the score 0 and then incremented by the specified amount.</p><p>To retrieve the scoreboard, lets add the following:</p><div><pre class="programlisting">bot.respondTo('scoreboard', (message, channel) =&gt; {
  client.zrevrange('rollscores', 0, -1, 'withscores', (err, set) =&gt; {
    if (err) {
      channel.send('Oops, something went wrong! Please try again later');
      return;
    }

    let scores = [];

    // format the set into something a bit easier to use
    for (let i = 0; i &lt; set.length; i++) {
      scores.push([set[i], set[i + 1]]);
      i++;
    }

    channel.send('The current scoreboard is:');
    scores.forEach((score, index) =&gt; {
      channel.send(`${index + 1}. ${score[0]} with ${score[1]} points.`);
    });
  });
}, true);</pre></div><p>Once the <code class="literal">scoreboard</code> command is given, we immediately look for the reverse range by using the <code class="literal">zrevrange</code> method. This will asynchronously return an array in the format:</p><div><pre class="programlisting">[ NAME, SCORE, NAME2, SCORE2, NAME3, SCORE3, …]</pre></div><p>Next, we transform that array into a two-dimensional array by splitting the names and scores into nested arrays, which looks like this:</p><div><pre class="programlisting">[ [NAME, SCORE], [NAME2, SCORE2], [NAME3, SCORE3], …]</pre></div><p>Formatting the data in this <a class="indexterm" id="id182"/>way makes it easy for us to send the name and score to the channel, preceded by the placing on the scoreboard (the index of the array plus one).</p><p>The final result in Slack shows us a working scoreboard:</p><div><img alt="Best practices" src="img/B05384_04_06.jpg"/><div><p>A scoreboard achieved through persistent data storage</p></div></div><p>Before moving on to another example, let's look at how to delete a Redis key/value pairing. Replace your <a class="indexterm" id="id183"/>
<code class="literal">scoreboard</code> command with the following, taking note of the highlighted code:</p><div><pre class="programlisting">bot.respondTo('scoreboard', (message, channel, user) =&gt; {
  let args = getArgs(message.text);

<strong>  if (args[0] === 'wipe') {</strong>
<strong>    client.del('rollscores');</strong>
<strong>    channel.send('The scoreboard has been wiped!');</strong>
<strong>    return;</strong>
<strong>  }</strong>

  client.zrevrange('rollscores', 0, -1, 'withscores', (err, set) =&gt; {
    if (err) {
      channel.send('Oops, something went wrong! Please try again later');
      return;
    }

<strong>    if (set.length &lt; 1) {</strong>
<strong>      channel.send('No scores yet! Challenge each other with the \`roll\` command!');</strong>
<strong>      return;</strong>
<strong>    }</strong>

    let scores = [];

    // format the set into something a bit easier to use
    for (let i = 0; i &lt; set.length; i++) {
      scores.push([set[i], set[i + 1]]);
      i++;
    }

    channel.send('The current scoreboard is:');
    scores.forEach((score, index) =&gt; {
      channel.send(`${index + 1}. ${score[0]} with ${score[1]} points.`);
    });
  });
}, true);</pre></div><p>Now if the command <code class="literal">scoreboard wipe</code> is given, we use the Redis client's <code class="literal">del</code> function to wipe the key/value pairing by specifying the key. </p><p>We also add in some error <a class="indexterm" id="id184"/>handling that sends an error message if there are no scores at all:</p><div><img alt="Best practices" src="img/B05384_04_07.jpg"/><div><p>Deleting data should be used with caution</p></div></div><div><div><h3 class="title"><a id="note25"/>Note</h3><p>In a real-world example, scoreboards and other sensitive data constructs should only be deleted by a user with admin rights. Remember that you can check whether the command issuer is an admin by checking the <code class="literal">user.is_admin</code> property.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Simple to-do example</h1></div></div></div><p>With the basics of Redis <a class="indexterm" id="id185"/>covered, we shall now move on to create a simple to-do Slack bot. The aim of this bot is to allow users to create a to-do list, allowing them to add, complete, and delete a task from this list as they go about their day.</p><p>This time, we will start with a skeleton of what we want and build each feature step by step. Start by adding this new command to your bot:</p><div><pre class="programlisting">bot.respondTo('todo', (message, channel, user) =&gt; {
  let args = getArgs(message.text);

  switch(args[0]) {
    case 'add':
      
      break;

    case 'complete':
      
      break;

    case 'delete':
      
      break;

    case 'help':
      channel.send('Create tasks with \`todo add [TASK]\`, complete them with \`todo complete [TASK_NUMBER]\` and remove them with \`todo delete [TASK_NUMBER]\` or \`todo delete all\`');
      break;

    default:
      showTodos(user.name, channel);
      break;
  }
}, true);

function showTodos(name, channel) {
  client.smembers(name, (err, set) =&gt; {
    if (err || set.length &lt; 1) {
      channel.send(`You don\'t have any tasks listed yet, ${name}!`);
      return;
    }

    channel.send(`${name}'s to-do list:`);

    set.forEach((task, index) =&gt; {
      channel.send(`${index + 1}. ${task}`);
    });
  });
}</pre></div><p>The bot's behavior will change depending on the second command given after the initial <code class="literal">todo</code> command. In this instance, a <code class="literal">switch</code> statement is ideal. We allow for five options: <code class="literal">add</code>, <code class="literal">complete</code>, <code class="literal">delete</code>, <code class="literal">help</code>, and a default option that is triggered when anything else is passed in.</p><p>The <code class="literal">help</code> and default behaviors have already been completed, as they are fairly straightforward. In the <a class="indexterm" id="id186"/>latter's case, we retrieve the Redis set, send out an error if it doesn't exist or has no items and otherwise send the total to-do list.</p><div><img alt="Simple to-do example" src="img/B05384_04_08.jpg"/><div><p>Display a message if there are no to-dos</p></div></div><p>Adding a to-do task is simple as well. We are using a Redis set, as we do not want to allow duplicates in our list. To add an item, we use the previously introduced <code class="literal">sadd</code> command. To make our <code class="literal">switch</code> statement less cluttered, all the code will be moved to a separate function:</p><div><pre class="programlisting">case 'add':
  addTask(user.name, args.slice(1).join(' '), channel);
     break;</pre></div><p>And the <code class="literal">addTask</code> function:</p><div><pre class="programlisting">function addTask(name, task, channel) {
  if (task === '') {
    channel.send('Usage: \`todo add [TASK]\`');
    return;
  }

  client.sadd(name, task);
  channel.send('You added a task!');
  showTodos(name, channel);
}</pre></div><p>All arguments after the first two (<code class="literal">todo add</code>) are joined into a single string and added to our set with the user's name as our key. Remember, duplicates are not allowed in a Redis set, so it's safe to store the task without doing any prior checking. We do check to make sure the task argument is <a class="indexterm" id="id187"/>not empty, sending a gentle reminder of how to use the "add" function if it is.</p><p>After the task is set, we display a confirmation and the entire to-do list. This is behavior that we will implement for every action, as it's a good practice to show the user what they've done and how it's impacted the data.</p><p>Here is an example of adding tasks to our to-do list:</p><div><img alt="Simple to-do example" src="img/B05384_04_09.jpg"/><div><p>Redis' set takes care of the index for us</p></div></div><p>Next up is the <code class="literal">complete</code> command, which takes the number of a task as an argument:</p><div><pre class="programlisting">case 'complete':
  completeTask(user.name, parseInt(args[1], 10), channel);
  break;</pre></div><p>Here's the accompanying <a class="indexterm" id="id188"/>
<code class="literal">completeTask</code> function:</p><div><pre class="programlisting">function completeTask(name, taskNum, channel) {
  if (Number.isNaN(taskNum)) {
    channel.send('Usage: \`todo complete [TASK_NUMBER]\`');
    return;
  }

  client.smembers(name, (err, set) =&gt; {
    if (err || set.length &lt; 1) {
      channel.send(`You don\'t have any tasks listed yet, ${user.name}!`);
      return;
    }

    // make sure no task numbers that are out of bounds are given
    if (taskNum &gt; set.length || taskNum &lt;= 0) {
      channel.send('Oops, that task doesn\'t exist!');
      return;
    }

    let task = set[taskNum - 1];

    if (/~/i.test(task)) {
      channel.send('That task has already been completed!');
      return;
    }

    // remove the task from the set
    client.srem(name, task);

    // re-add the task, but with a strikethrough effect
    client.sadd(name, `~${task}~`);

    channel.send('You completed a task!');
    showTodos(name, channel);
  });
}</pre></div><p>This action is a little more complicated, as we have to do a little more error handling to begin with. First, we make <a class="indexterm" id="id189"/>sure that the argument provided is a valid number by using the ES6 <code class="literal">Number.isNaN</code> method.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>Be careful when using ES5's <code class="literal">isNaN</code> method or ES6's <code class="literal">Number.isNaN</code> method, as they can be confusing. These methods answer the question <em>is the value equal to the type NaN? rather than is the value a number?</em> For more information, visit <a class="ulink" href="https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan">https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan</a>.</p></div></div><p>After retrieving the set from Redis, we ensure that tasks exist, that the number provided makes sense (for example, not less than 1 or more than the length of the set), and that the task hasn't already been completed. The latter is determined by whether the task has any tilde (<code class="literal">~</code>) operators contained within. Messages containing a tilde as the first and last character will render in strikethrough style within Slack.</p><p>To complete a task, we remove the task from the Redis set (using <code class="literal">srem</code>) after assigning it to the <code class="literal">task</code> variable, and then add it to Redis again with the strikethrough style.</p><div><img alt="Simple to-do example" src="img/B05384_04_10.jpg"/><div><p>Complete a task by referencing its task number</p></div></div><p>Finally, let's look at the delete function:</p><div><pre class="programlisting">case 'delete':
      removeTaskOrTodoList(user.name, args[1], channel);
      break;</pre></div><p>Here's the <a class="indexterm" id="id190"/>accompanying function:</p><div><pre class="programlisting">function removeTaskOrTodoList(name, target, channel) {
  if (typeof target === 'string' &amp;&amp; target === 'all') {
    client.del(name);
    channel.send('To-do list cleared!');
    return;
  }

  let taskNum = parseInt(target, 10);

  if (Number.isNaN(taskNum)) {
    channel.send('Usage: \`todo delete [TASK_NUMBER]\` or \`todo delete all\`');
    return;
  }

  // get the set and the exact task
  client.smembers(name, (err, set) =&gt; {
    if (err || set.length &lt; 1) {
      channel.send(`You don\'t have any tasks to delete, ${name}!`);
      return;
    }

    if (taskNum &gt; set.length || taskNum &lt;= 0) {
      channel.send('Oops, that task doesn\'t exist!');
      return;
    }

    client.srem(name, set[taskNum - 1]);
    channel.send('You deleted a task!');
    showTodos(name, channel);
  });
}</pre></div><p>The first thing to note in this function is how we use a type of function overloading to achieve two different outcomes, depending on the arguments passed in.</p><p>Because JavaScript is a loosely typed language, we can perform actions depending on whether the <code class="literal">target</code> <a class="indexterm" id="id191"/>argument is a string or a number. In the case of a string (and provided that that string equals <em>all</em>), we delete the entire set from Redis using the <code class="literal">del</code> command, clearing the whole to-do list.</p><p>In case of a number, we only delete the task specified, provided that the target is a valid number we can use (for example, not smaller than 1 and not greater than the length of the set).</p><p>Here's the multiple functionality of the <code class="literal">delete</code> command in action:</p><div><img alt="Simple to-do example" src="img/B05384_04_11.jpg"/><div><p>List the to-dos, delete a task, add another, and then delete the whole list</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, the reader has learned the basics of the persistent data storage Redis and how to use it through the Node Redis client. We outlined the reasons why Redis lends itself well for use with bots, particularly when keeping a score list or storing multiple small items.</p><p>In the next chapter, we <a class="indexterm" id="id192"/>will introduce the concept of <strong>natural language processing</strong> (<strong>NLP</strong>) and see how to evaluate and generate natural language for use in a bot.</p></div></body></html>