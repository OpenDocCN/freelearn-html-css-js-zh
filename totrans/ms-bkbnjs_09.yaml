- en: Chapter 9. Deploying to Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have built a great project: it is modularized, has tests, has been automatized
    to do common tasks, and finally you have built a production version with Gulp;
    however, now how do you deploy to a production server?'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter examines what to do with the production version of your project.
    Here, you will see how to run your node server and frontend assets in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are many choices to run your project in production mode; you can deploy
    on a bare metal server, use a virtual machine, on a shared host such as DigitalOcean
    or RackSpace, or maybe just deploy it to a **PaaS** (**Platform as a service**)
    service such as Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see how to deploy to an Heroku instance, this
    is the easiest way to make a deployment as you don't have to worry about the server
    details and you can manage all the configurations in a single configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have your own infrastructure or simply prefer to work with server
    instances such as DigitalOcean or RackSpace virtual server, we will show you how
    to configure a production environment on a server, where you have access to a
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku is a PaaS, which means that you don't have to worry about the details
    of the server configuration where you are deploying your code, you only focus
    on your code; Heroku will do the difficult job with the infrastructure configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a shell to install, configure, and tune up your packages in
    order to run in production mode, you only have to edit a configuration file and
    publish your changes with the standard `git push` command.
  prefs: []
  type: TYPE_NORMAL
- en: Dynos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku uses lightweight Linux containers that run a single command in order
    to run your projects in the Heroku platform. Heroku calls these containers Dynos.
    A Dyno can host your code and run it as a single process in an isolated Linux
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have an experience in Linux containers such as Docker, you can
    imagine a container to be like a small virtual machine without hardware emulation;
    a Linux container uses the same kernel as the host machine, it means that you
    don''t need to emulate hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynos](img/B01962_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 Difference between virtualization and containers
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Heroku will use Celadon Cedar stack to build Dynos; and Celadon
    Cedar stack is based on the Ubuntu distribution. With this is mind, you will get
    an Ubuntu-like distribution, where you can run your code written on:'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby on Rails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java or Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python or Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala or Play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dyno comes in three different types, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Dynos**: They are used to run the server code and respond to HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker Dynos**: They are useful for background jobs such as image processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-off Dynos**: Their purpose is to provide maintenance to the other two
    Dyno types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have guessed that in this book, we will only use the Web Dynos with
    Node.js to run our `Contacts app`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do in order to start working with Heroku is to register
    with the service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Heroku](img/B01962_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 Heroku registration form
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are registered in the platform, you will need to install the Heroku
    Toolbelt in your host; there are versions available for Linux, Mac OS X, and Windows.
    After the installation process, you can use the `heroku` command to authenticate
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have authenticated with the Heroku service, you can start creating
    Dynos using the create command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a new Dyno on Heroku, it generates a random name for your Dyno.
    In the preceding example, the name is `enigmatic-anchorage-3587` and you can access
    to your Dyno at [https://enigmatic-anchorage-3587.herokuapp.com](https://enigmatic-anchorage-3587.herokuapp.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Heroku](img/B01962_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 Dyno default output
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deploy your application by pushing your changes to the Git server located
    at [https://git.heroku.com/enigmatic-anchorage-3587.git](https://git.heroku.com/enigmatic-anchorage-3587.git).
    You will need to add this address as a remote server in your repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make a push right now, the deployment will not work and that''s because
    you need to tell Heroku how to run your project; this is done with a configuration
    file named `Procfile` that you should put in the application root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is very simple, run the `server/index.js` script. You can test whether
    the configuration is working with the `local` command; this command is very useful
    in order to find bugs or issues before making a real deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output logs, you can see what Heroku is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: Heroku detects what kind of project it is in order to know how to build the
    right environment. It could detect that it is a `Node` project due the presence
    of the `package.json` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing that it is a Node project, it could set some useful environment variables
    in order to run the project in production mode. You can use the `NODE_ENV` environment
    variable in your code in order to use some special configuration for production
    environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, read the `package.json` file to see what version of node to install.
    You can specify a node version to install with the engines configuration, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the right node version is installed in the Dyno, Heroku will install the
    project dependencies that are specified in the `package.json` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it will look up for the configuration for the kind of Dyno that is launched
    and see how to run the project at `Procfile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it will compress the build and launche the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the project is running in the Heroku infrastructure, you can see the result
    at [https://enigmatic-anchorage-3587.herokuapp.com/](https://enigmatic-anchorage-3587.herokuapp.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with Heroku](img/B01962_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 Application deployed on Heroku
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, deploying to Heroku infrastructure is very straightforward,
    you don't have to worry about the server details such as the HTTP server or the
    process management so that you can focus on your application development and forget
    about the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any issues with your application in production, you can see what''s
    happening with the `logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will show the last log messages in the Heroku server. Please consult the
    online documentation of the service for more details; here you can find information
    about how to scale your application, connect Dyno instances to databases, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Production environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a bare metal server or want to work with virtual servers, such as
    DigitalOcean or Rackspace, you can create your own production environment. In
    this section, you will see how to make it possible.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter what the case is as the way you configure a production environment
    on these kind of servers are the same. However, keep in mind that the production
    environment that you will see here is for simple web applications.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an application with high traffic, you can start from here; however,
    the server architecture should have a sophisticated organization. The details
    on how to scale your deployments are out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: For the server, I will use the Ubuntu server as it is the easiest and the most
    popular choice to deploy application. If you are familiar with other distributions
    such as CentOS, you can use it; however, the instructions are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows you a typical configuration for a **Node** server
    in the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Production environment](img/B01962_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 Deployment diagram
  prefs: []
  type: TYPE_NORMAL
- en: As Node was not built to be a full-featured and robust web server, you should
    put an HTTP server in front to answer the client requests instead of using Node
    directly. The HTTP server will forward the request to the Node process and return
    the response from the Node server to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see that we are using a **Process Manager**,
    its work is to keep the Node process up and alive; if the Node process crashes
    for some reason, **PM2** will take care of it and restart the process.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can monitor the memory and processor that your application is consuming
    in real time, manually restart and stop processes, check logs, and so on. Finally,
    the access to the database is made from the **Node** server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user makes a request from its browser, the server will process the request
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a request to the server host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP server takes the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP server forwards the request to the Node server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node process makes its internal process of the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node process returns an answer to the HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP server forwards the answer to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client receives the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will explore how to install and configure all
    the components in order to have a Node application running. We will use an **Ubuntu-14.04**
    box to perform the installation process. If you have a different environment,
    the configuration content should still work; however, the instructions to install
    and the location of the configuration files may be different.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTTP server handles the connections with the client and forwards all the
    requests to the Node server. In some way, it is a kind of proxy. Currently, there
    are two main HTTP servers on the market that were used widely in production: Apache
    and Nginx, both can be used to server Node applications. However, in this book,
    we will cover Nginx. The main reason for this decision is its simplicity and performance
    and it is smaller than Apache.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Nginx, use `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Nginx server is installed, Ubuntu will start the server automatically;
    however, you can manage the server daemon with the service command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether the server is running by pointing your browser to the
    server IP, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP Server](img/B01962_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 Nginx fresh installation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nginx configuration files are located at `/etc/nginx`, in this path are
    two more paths, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sites-available**: Each file is a configuration of a single host (subdomain).
    Note that these files are not active until they are not in sites-enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sites-enabled**: While the sites-available has a set of configuration files,
    the sites-enabled are a set of sites that are actually active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a new site, you need to create a new configuration file in the sites-available
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration content is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The upstream module of Nginx defines a server or a group of servers that can
    be referenced as `proxy_pass`, what it means is that the target to hit when a
    request is incoming at Nginx. Server configuration creates a new virtual host
    listening for requests to the `server_name` address. In this case, it is listening
    for `www.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `location` block, it describes how to handle the requests; in the previous
    example, it will forward the request to the `webapp` upstream, which points to
    `127.0.0.1:8000`. To activate the site, you need to link the contents of this
    file to the `sites-enabled` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe you will need to delete the previous default-enabled site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then restart the Nginx server in order to load the new configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, the server will be up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP Server](img/B01962_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 Nginx running without node.js working
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding image shows a `502` error, that''s because the Nginx server is
    pointing to the `proxy_pass` setting that has the `127.0.0.1:8000` address; however,
    nothing is running on that socket. You need to have something listening for requests
    on the `127.0.0.1:8000` socket, therefore, you should run the project in the same
    host and the `502` error will go away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough to make the server work. However, we don't want to run
    the `app.js` script manually each time, there is a better way to launch the node
    process automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Do not run as root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the server process as root can be dangerous. If someone discovers a
    vulnerability in node or in your application code, then they can cause serious
    damage to the system. It''s always a good idea to create a user to run the application
    server only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m` option will create a home path located at `/home/production`, where
    you can clone the project repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Do not run as root](img/B01962_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 After running node.js process
  prefs: []
  type: TYPE_NORMAL
- en: Process Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anytime you run a program in your computer, it can fail for many reasons: maybe
    a server that it depends on is turned off or, even worst, an unhandled exception
    can tear down the running process. That''s terrible for production applications
    as you leave your users without the server until you notice that it is not working.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the process manager comes in, you can run your code behind a process
    manager and it will ensure that the process is always running. If something fails
    and crashes the program, the process manager will reset the entire application
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two popular process managers for Node: `forever` and `pm2`, both
    work in a similar way; however, `pm2` seems to be more popular and provides more
    utility tools than ever. For this reason, we will use `pm2` for the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu comes with an integrated process manager known as Upstart. You can use
    the operative system process manager; however, `pm2` is focused on node applications,
    it allows you to run more than an instance of your process instead of running
    a single process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install `pm2` with the `npm` tool, do not forget to install it as global
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is complete, you can run your process behind `pm2` with
    the `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After you do this, the script is running and you can see the output of the
    process with the logs command and the application ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the raw ID of the process, you can name your running processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run more than one instance so that you can have two running instances
    of the same application and `pm2` will load and balance requests between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It's a good idea to run more than one instance of a Node server as the Node
    blocks is making I/O operations. If you run more than one instance, then the other
    processes can continue serving the incoming requests while the other is blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save the application parameters in a JSON file and use it instead of
    putting all the options in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the JSON file, you have the advantage that you don't have to remember how
    to run the application as the file contains all the required configurations and
    the same environment is easily reproducible on different hosts.
  prefs: []
  type: TYPE_NORMAL
- en: If you are fine with your settings and everything is working as you expected,
    the next step is to persist the `pm2` process to run it as daemon each time that
    the server is restarted; this is always a good idea as if the server restarts
    for some reason such as maintenance, your processes will spawn automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, `pm2` provides an easy way to daemonize your configuration with
    the `startup` command for many operative systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first command shows the available operative systems. As the `startup` command
    writes on the `/etc/` path, we need to run this command as the root user and that's
    the reason why we are using sudo command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the daemon, you need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before running this command, you will need to dump your current configuration
    in the daemon configuration and if you skip this step, the service will not start
    any process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this command, the current configuration of `pm2` will be used every time
    the server restarts or you manually restart the service.
  prefs: []
  type: TYPE_NORMAL
- en: That's how you can run your node application in a production environment; run
    a real HTTP server and run your node processes behind it with the help of a process
    manager such as `pm2`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to run a Node application in the Heroku platform
    and in a bare metal or virtual machine server with Linux. These two methods to
    deploy Node applications are simple; however, they are the base for more complex
    deployments. You can make deployments on Docker containers, for instance. With
    Docker, you will need to know how to install your application in a fresh Linux
    installation as we did, and then, manage containers as a process like Heroku does.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we don't see many things related to Backbone; however, if you
    have a Backbone application and it is backed by Node, you probably want to put
    your code in production. In this chapter, we have seen how to put the output of
    the distribution files in a production server.
  prefs: []
  type: TYPE_NORMAL
