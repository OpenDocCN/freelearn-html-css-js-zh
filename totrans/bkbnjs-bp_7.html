<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Building a Game</h1></div></div></div><p>We've come to the final chapter of this book, and if I may speak in first-person for a moment,<a id="id468" class="indexterm"/> this was my favorite application to build. Everybody loves a game, and if word games are your thing, you'll have fun with this too. Most of the applications we've written so far have been single-view applications; the only screen the user sees is the view that performs the main action of the application. However, full web applications often have other views that aren't the main purpose of the application, but serve to fill it out. We have one or two such views in this application.</p><p>So, here are a few of the topics we will cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Review all the primary uses of the Backbone components</li><li class="listitem" style="list-style-type: disc">Add non-Backbone pages to fill out the application</li><li class="listitem" style="list-style-type: disc">Build an app that uses data not provided by the user</li><li class="listitem" style="list-style-type: disc">Write (simple) game logic</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>What are we building?</h1></div></div></div><p>Once again, we'll start by describing what we're planning the build. It's going to be a word game, modeled after a very simple iPhone game I enjoy, called <em>7 Little Words</em> (<a class="ulink" href="http://www.7littlewords.com/">http://www.7littlewords.com/</a>). Each<a id="id469" class="indexterm"/> game (or round, if you will) has seven words that are broken into parts of two, three, or four letters. Your job is to reassemble the words based on the short definitions that you're given. To make it clear, I have no affiliation with this iPhone game, I just like playing it!</p><p>However, we're going<a id="id470" class="indexterm"/> to take it a little farther than that game does, by assigning different point values to words, and also timing our users. This way, players can compare scores and times to make things a little more competitive.</p><p>Here's a screenshot of what the game view of our application will look like when it is finished. At the bottom, you can see the tokens that the user will choose to combine into a word. There's a textbox in the middle that shows the word the user has assembled. Then, they'll click on the <strong>Guess</strong> button to see if the word matches one of the definitions above:<a id="id471" class="indexterm"/>
</p><div><img src="img/6997OS_07_05.jpg" alt="What are we building?"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>User accounts</h1></div></div></div><p>We'll start as <a id="id472" class="indexterm"/>we did in the last chapter; by adding user account to our basic application. We won't go over the whole process again; you can copy it from the previous chapter's application. There's only one change we have to make. In the <code class="literal">app.post('/create')</code> route, we create a <code class="literal">userAttrs</code> object that we store in the database. Users of this application will have three application-specific values to store:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">score</code>: This is their highest score</li><li class="listitem" style="list-style-type: disc"><code class="literal">time</code>: This is their lowest time</li><li class="listitem" style="list-style-type: disc"><code class="literal">games</code>: This is an array of the games they have played</li></ul></div><p>Here's the code to create the <code class="literal">userAttrs</code> object:</p><div><pre class="programlisting">var userAttrs = {
  username: req.body.username,
  passwordHash: signin.hashPassword(req.body.password),
  score: 0,
  time: 3600,
  games: []
};</pre></div><p>With this in place, and all the other user account creation code we've previously created, we have the shell of an application, ready to customize.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Templates</h1></div></div></div><p>Our server-side <a id="id473" class="indexterm"/>templates have been pretty basic in previous applications. We've only ever had a single <code class="literal">index.ejs</code> file, and maybe a <code class="literal">login.ejs</code> file. However, in a big application, you'll probably have several different server templates. When that's the case, you want to remove code duplication as much as possible. How you go about this is dependent on which server-side template system you use. Since we're using <code class="literal">ejs</code> (<a class="ulink" href="https://github.com/visionmedia/ejs">https://github.com/visionmedia/ejs</a>), we'll do this via <strong>includes</strong><a id="id474" class="indexterm"/>. So, in our project's <code class="literal">views</code> directory, make a file called <code class="literal">header.ejs</code>. Here's what goes in there:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt; Tokenr &lt;/title&gt;
  &lt;link rel="stylesheet"  href="/style.css" /&gt;
&lt;/head&gt;
&lt;body&gt;</pre></div><p>Basic and expected, right? Now, we're also going to have a <code class="literal">footer.ejs</code> file in the <code class="literal">views</code> directory, which will close these tags:</p><div><pre class="programlisting">&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Alternatively, you could just remember to add these two lines to the bottom of every template you <a id="id475" class="indexterm"/>create that uses the <code class="literal">header.ejs</code> include (or, if you're hip with the HTML5 lack-of-strictness, leave them out entirely), but I like the symmetry that comes from having both the <code class="literal">header.ejs</code> and <code class="literal">footer.ejs</code> files. For example, our <code class="literal">login.ejs</code> file in the <code class="literal">views</code> directory, which has both the login and signup forms:</p><div><pre class="programlisting">&lt;% include header %&gt;
&lt;div id="main"&gt;
  &lt;form method="post" action="/login"&gt;
    &lt;h1&gt; Sign In &lt;/h1&gt;
    &lt;p&gt;&lt;input type='text' name='username' /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type='password' name='password' /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button&gt;Log In&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
  &lt;form method="post" action="/create"&gt;
    &lt;h1&gt; Sign Up &lt;/h1&gt;
    &lt;p&gt;&lt;input type='text' name='username' /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type='password' name='password' /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;button&gt;Create Account&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;% include footer %&gt;</pre></div><p>See what I mean about symmetry? We can use the same technique in the <code class="literal">index.ejs</code> file in the <code class="literal">views</code> directory, which will start out like this:</p><div><pre class="programlisting">&lt;% include header %&gt;
&lt;div id="main"&gt;&lt;/div&gt;
&lt;script src="img/jquery.js"&gt;&lt;/script&gt;
&lt;script src="img/underscore.js"&gt;&lt;/script&gt;
&lt;script src="img/backbone.js"&gt;&lt;/script&gt;
&lt;script src="img/models.js"&gt;&lt;/script&gt;
&lt;script src="img/views.js"&gt;&lt;/script&gt;
&lt;script src="img/router.js"&gt;&lt;/script&gt;
&lt;% include footer %&gt;</pre></div><p>As you can see, we'll be splitting models, views, and the router into separate files again. This will be <a id="id476" class="indexterm"/>especially important in this application because of some of the complex code the models will use. So now that we have a <code class="literal">index.ejs</code> file in the <code class="literal">views</code> directory, we can render the index route. In the <code class="literal">server.js</code> file, this code should be your final route:</p><div><pre class="programlisting">app.get('/*', function (req, res) {
  if (!req.user) {
    res.redirect("/login");
    return;
  }
  res.render("index.ejs");
});</pre></div><p>Notice that we're not passing any values into the index template; this application won't require anything like that. This might sound strange. Since it is supposed to be a more advanced application, wouldn't you expect it to need more data out of the gate? If your application needs to shuttle a lot of data from the server to the browser, it is sometimes a smarter move not to move the data all at once; it could seriously slow down your load time. A better technique is to load the data when it is needed, and that's what we'll do here. Also, it is possible that you might need the user to make a decision before you know exactly what data you need; this is another reason to delay loading data, and this is true in our case as well.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Creating the game data</h1></div></div></div><p>Speaking<a id="id477" class="indexterm"/> of loading data, the next step is to create the data for our game—the words the users will spell. This is actually the only application in this book that begins with data, instead of only working with the data that users give to the application. The actual raw data will be in the <code class="literal">words.json</code> file in the root of our project. One of the keys to this being a good game is to have plenty of words to choose from. Here's how the file starts:</p><div><pre class="programlisting">[{"id":1,"level":3,"word":"anguine","definition":"snakelike"},
{"id":2, "level":1,"word":"cardinal","definition":"of fundamental importance"},
{"id":3, "level":3,"word":"detersion","definition":"act of cleansing"},
{"id":4, "level":3,"word":"exiguous","definition":"meager"},
{"id":5, "level":2,"word":"fraternise","definition":"associate with"},</pre></div><p>Of course, every word has an ID. Then, the important properties are the words and definitions. The <a id="id478" class="indexterm"/>definition is what the user will see, and the word is what they'll have to piece together. The level is a number between 1 and 3, with level 1 words being the easiest and level 3 words being the toughest. You can write your own list, or download this list from Github (<a class="ulink" href="https://gist.github.com/andrew8088/9627996">https://gist.github.com/andrew8088/9627996</a>).</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>During the development of this application, one idea was to use a dictionary API (such as <a class="ulink" href="http://dictionaryapi.com">dictionaryapi.com</a>) to randomly select words from a much larger database. However, this isn't really practical, because we need a short, crossword-puzzle-like definition, and standard dictionary definitions just don't cut it. Also, most APIs don't have a way of selecting a random word.</p></div></div><p>Once we have our list of words, we'll need to create the actual database. Add this to the top of the <code class="literal">server.js</code> file:</p><div><pre class="programlisting">var _ = require('./public/underscore');
var words = new Bourne('words.json');</pre></div><p>We also require the Underscore library here; you'll see what we need it for in a moment. We need the very same file that we use on the client side. This won't work for every file; it just happens that the latest version of Underscore (at the time of writing this book, 1.6.0) is written to work on both the client and the server.</p><p>Each game played by a user will have eight words; this means that we need to pull eight words randomly, but all of the same difficulty level, from the database. To do this, we'll add a <code class="literal">getWords</code> function to the server file:</p><div><pre class="programlisting">function getWords(level, cb) {
  words.find({ level: level }, function (err, records) {
    cb(null, _.shuffle(records).slice(0, 8));
  });
}</pre></div><p>This function will take a level number and a callback function. Then, we'll get all the words in the database for that level. We'll then shuffle the array of records, using Underscore's <code class="literal">shuffle</code> method. After we shuffle the array, we'll slice the first eight items off the array and pass them to the callback.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>It should be said that this is probably not an optimal way to get eight random words from most databases. Since I wrote the Bourne database system for small datasets, and it keeps all records in memory, what we do here should be fast. However, there will probably be better ways, depending on the database system you're using.</p></div></div><p>Now that we<a id="id479" class="indexterm"/> have a way of getting the words, we need to create a route for that:</p><div><pre class="programlisting">app.get('/game/:level', function (req, res) {
  var level = parseInt(req.params.level, 10);
  getWords(level, function (err, words) {
    res.json(words);
  });
});</pre></div><p>The level for the game is part of the URL. We convert it to a number, and then call our <code class="literal">getWords</code> function. Once we have the words, we can send them back to the browser as JSON.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec80"/>Writing the models</h1></div></div></div><p>Because of the nature<a id="id480" class="indexterm"/> of this application, we will have more models than usual. The two obvious ones are the <code class="literal">Word</code> model and its collection, <code class="literal">Game</code>. These hardly require explanation. However, remember that we'll split words into parts, which we'll call tokens. For this, we'll have a <code class="literal">Token</code> model and a <code class="literal">Tokens</code> collection. These are actually the simplest parts:</p><div><pre class="programlisting">var Token = Backbone.Model.extend({});
var Tokens = Backbone.Collection.extend({
  model: Token
});</pre></div><p>Since these are just shells for the chopped-up words, there doesn't need to be much to them. All the primary logic will be in the <code class="literal">Word</code> and <code class="literal">Game</code> classes. Let's start with the <code class="literal">Word</code> class:</p><div><pre class="programlisting">var Word = Backbone.Model.extend({
  initialize: function () {
    this.set('points', this.get('word').length + this.get('level'));
  },
  parts: function () {
    return Word.split(this.get('word'));
  }
});</pre></div><p>Every <code class="literal">Word</code> instance will need to be assigned a point value. It's not that tricky; just add the length of the word and its difficulty level. Later, multiply this value with another that's based on time. The other method calls the <code class="literal">Word.split</code> function, passing it the word. This is where the code gets a little more complex.</p><p>However, <a id="id481" class="indexterm"/>before we get to splitting up words, notice that the <code class="literal">split</code> method is a static or class-level method. This isn't something we've seen before in Backbone; but Backbone makes it very simple to add static methods. So far, we've only ever passed one parameter to the <code class="literal">Backbone.Model.extend</code> method; an object of instance-level properties and methods. However, the method can take a second object, with class properties and methods:</p><div><pre class="programlisting">Backbone.Model.extend({
  // instance properties
},
{
  // class properties
});</pre></div><p>This isn't just for models; it works with collections, views, and even routers. So, add a class properties object to the preceding <code class="literal">Word</code> model; we'll be using it in the next section.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec15"/>Splitting up words</h2></div></div></div><p>Randomly<a id="id482" class="indexterm"/> splitting the words into tokens is not as easy as you think. We want to do it randomly, so that each time a game is played, a word may be split up differently. We want to split every word into tokens of two, three, or four letters. You might think, then, that we could randomly select one of those numbers. However, we don't really want equal amounts of all three sizes; we'd like fewer two-letter tokens. This requires a weighted random selection, so we first have to write a function for that. The way to represent our weighted options is through an array like this:</p><div><pre class="programlisting">[[2, 0.2], [3, 0.4], [4,0.4]]</pre></div><p>Each array within this array has two elements. The first is the value we want to use; this could be a string, an object, or anything. The second value is the chance that this will be the value chosen. As you can see from this array, the value 2 will be chosen 20 percent of the time, and values 3 and 4 will be chosen 40 percent of the time, each. So, here's the function that takes that array as a parameter. Remember to put this in the class properties object of the <code class="literal">Word</code> model:</p><div><pre class="programlisting">weightedRandomGenerator: function(items) {
  var total = items.reduce(function (prev, cur) { 
    return prev + cur[1]; 
  }, 0),sum = 0,list = [];
  for (var i = 0; i &lt; items.length; i++) {
    sum = (sum*100 + items[i][1]*100) / 100;
    list.push(sum);
  }
  return function () {
    var random = Math.random() * total;
    for (var i = 0; i &lt; list.length; i++) {
      if (random &lt;= list[i]) {
        return items[i][0];
      }
    }
  }
}</pre></div><p>The first step is to add up the percentage values in the arrays. In our case, these values add up to 1, but <a id="id483" class="indexterm"/>they don't have to; if they add up to some other value, this will still work. We do this by calling the native reduce method on the array, summing up all seconds elements. The next step is to create a new array, which the weight values sum up as they go along. For example, our weight values are 0.2, 0.4, and 0.4. For these values, we need to create an array like this:</p><div><pre class="programlisting">[0.2, 0.6, 1]</pre></div><p>So, we create a <code class="literal">sum</code> variable and an array called <code class="literal">list</code>. Then, we loop over the items, adding the value to the <code class="literal">sum</code> variable, and then pushing that <code class="literal">sum</code> variable into the <code class="literal">list</code> array. We now have the array we need. Finally, we'll return a function. The function will start by getting a random number between 0 and the total. Then, we'll loop over the list, checking each item to see whether it is less than or equal to the random number. Once we get a match on that, we'll return the value from the original items parameter, using the same index number. That's all for our weighted random generator. Now, we're ready to use this in the function that splits the word into tokens. This is the <code class="literal">split</code> function:</p><div><pre class="programlisting">function split(word) {
  word = word.split('');
  var tokens = [];

  var rand234 = Word.weightedRandomGenerator([[2, 0.2], [3, 0.4], [4,0.4]]),
    rand23  = Word.weightedRandomGenerator([[2, 0.5], [3, 0.5]]),
    rand24  = Word.weightedRandomGenerator([[2, 0.5], [4, 0.5]]);

  var w, length;
  while (word.length &gt; 0) {
    w = word.length;
    if      (w  &gt;  5) length = rand234();
    else if (w === 5) length = rand23();
    else if (w === 4) length = rand24();
    else              length = w;

    tokens.push(word.splice(0, length).join(''));
  }
  return tokens;
}</pre></div><p>This function takes a word and splits it into tokens. First, we split the string into an array, and then create <a id="id484" class="indexterm"/>an array to hold the tokens. Next, we create three random generators, which we'll need at different points. Then, we have a <code class="literal">while</code> loop, for when the length of the word is greater than zero. If the length of the word is greater than five characters, we'll use the generator that will return a 2, 3, or 4. If the word is five characters long, we'll use the generator that returns either 2 or 3. If it's four characters long, we'll use the generator that will return either 2 or 4. The final <code class="literal">else</code> statement will be used if the word is shorter than four characters; we'll use the length of the word. </p><p>All of this ensures that the word will be split up into tokens of two, three, or four characters; it also makes sure that we'll never get a one-letter token, by slicing off all but one of the letters. The last step in the <code class="literal">while</code> loop is to use the word array's <code class="literal">splice</code> method. This method will mutate the original array, taking those letters out of the array and returning them (this is how the word length changes in the <code class="literal">while</code> loop condition). Once we've split up the word into tokens, we return the array of tokens. This is the function used in the <code class="literal">Word</code> class's parts method.</p><p>The collection class for this is <code class="literal">Game</code>. This will start out very simply:</p><div><pre class="programlisting">var Game = Backbone.Collection.extend({
  model: Word,
  initialize: function (models, options) {
    this.guessedCorrectly = [];
    this.seconds = -1;
    this.score = 0;
    this.level = 1;
  },
  getWords: function () {
    return Backbone
      .ajax("/game/" + this.level)
      .then(this.reset.bind(this));
  },
  tokens: function () {
    var tokens = _.flatten(this.invoke('parts'));
    return new Tokens(tokens.map(function (token) {
      return { text: token };
    }));
  }
});</pre></div><p>This really is just the start. One of these collection instances will handle much more, but we'll get there. We start by setting the model class for this collection, and then we create the <code class="literal">initialize</code> method. A collection object will be responsible for tracking time and points, so we <a id="id485" class="indexterm"/>give it a <code class="literal">seconds</code> and <code class="literal">score</code> property. Since our game will have levels, we also have a <code class="literal">level</code> property. Then, we have the <code class="literal">getWords</code> method. </p><p>As we know, we aren't sending a set of words with the initial page load, so this is the method that will do that. This makes an AJAX request to the route we created to send the words. The <code class="literal">Backbone.ajax</code> method actually wraps the <code class="literal">jQuery.ajax</code> method. It returns a promise, which we learned about in <a class="link" href="ch06.html" title="Chapter 6. Building a Podcast Application">Chapter 6</a>, <em>Building a Podcast Application</em>, here. We call its <code class="literal">then</code> method, passing it the collection's <code class="literal">reset</code> method. This method will replace any models in the collection with the array of models passed as a parameter. The <code class="literal">then</code> method will return the promise object, so we return it. This way, we can perform an action after the words have been loaded.</p><p>Finally, notice the <code class="literal">tokens</code> method; in here, we call the collection's <code class="literal">invoke</code> method. This method takes the name of another method and calls it on each model in the collection. This will return an array of values; in this case, the values will be an array of tokens, the split-up words. An array of arrays isn't useful, so we'll use Underscore's <code class="literal">flatten</code> method to flatten the nested arrays into a single array of tokens. Then, we return a <code class="literal">Tokens</code> collection instance, mapping the <code class="literal">tokens</code> array into an array of objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec81"/>Writing the tokens view</h1></div></div></div><p>Now that we<a id="id486" class="indexterm"/> have the models more or less in place, we're ready to start writing the actual views. Let's start with something simple: the tokens. We start with the <code class="literal">TokensView</code> class:</p><div><pre class="programlisting">var TokensView = Backbone.View.extend({
  render: function () {
    this.collection.tokens()
      .shuffle().forEach(this.addToken, this);
    return this;
  },
  addToken: function (token) {
    this.el.appendChild(new TokenView({ 
      model: token 
    }).render().el);
  }
});</pre></div><p>Writing this <a id="id487" class="indexterm"/>class is very simple. We get the collection of tokens from the game, call the built-in <code class="literal">shuffle</code> method to shuffle the tokens, and then render them each with the <code class="literal">addToken</code> method. This method renders a <code class="literal">TokenView</code> instance and appends it to the element. So that's the next stop—the <code class="literal">TokenView</code> class:</p><div><pre class="programlisting">var TokenView = Backbone.View.extend({
  className: 'token',
  events: {
    'click': 'choose'
  },
  render: function () {
    this.model.view = this;
    this.el.innerHTML = this.model.get('text');
    return this;
  },
  choose: function () {
    Backbone.trigger('token', this.model);
    this.hide();
  },
  hide: function () {
    this.$el.addClass('hidden');
  },
  show: function () {
    this.$el.removeClass('hidden');
  }
});</pre></div><p>Each <code class="literal">TokenView</code> instance will have a class: <code class="literal">token</code>. The <code class="literal">render</code> method is pretty basic—it just puts the text of the token in the element. However, notice the first line of the method; we're giving the model a view property that points to this view. This is something we haven't done before; we have never given a model a link to the view that renders it. This isn't always considered a good thing; it's often better to keep a clean separation between<a id="id488" class="indexterm"/> the model and the view. However, sometimes this can be a good thing, as we'll see in this case. Either way, it's very easy to do. When this element is clicked on, the <code class="literal">choose</code> method will be called. This method triggers the <code class="literal">token</code> event, using the model as a parameter. We've triggered events before, but this is the first time we've used the <code class="literal">Backbone.trigger</code> method<a id="id489" class="indexterm"/>. We can use this to trigger and listen for events globally across all our code. After we trigger the event, we'll hide the view. We have <code class="literal">hide</code> and <code class="literal">show</code> views here as well. These add or remove a class on the element to hide or show the token respectively.</p><p>Normally, this would be the point where we start the router, so we can render our view and then style it. However, we're going to go a different route this time. Often, when building a more complex application, you're on a roll with whatever you're working on—the views, in our case—and you don't want to switch mindsets. What I'll do in a case like this is put a <code class="literal">script</code> tag in the <code class="literal">index.ejs</code> file to test the view we just created:</p><div><pre class="programlisting">&lt;script&gt;
  var game = new Game();
  game.getWords().then(function () {
    $('#main').append(new TokensView({ 
      collection: game 
    }).render().el);
  }.bind(this));
&lt;/script&gt;</pre></div><p>It's quick and dirty; we create a <code class="literal">Game</code> object, get a set of words, and then append a new <code class="literal">TokensView</code> instance to the page. You should see something like this:</p><div><img src="img/6997OS_07_01.jpg" alt="Writing the tokens view"/></div><p>If you click on the individual tokens and open your developer tools, you'll see that they get the <code class="literal">hidden</code> class, just<a id="id490" class="indexterm"/> like we coded. Of course, nothing else happens right now, but that's because we don't have anything listening for the <code class="literal">'token'</code> event. It's a good start, and it's enough to begin the styling. So, open the <code class="literal">style.css</code> file of the <code class="literal">public</code> directory. Let's start with this:</p><div><pre class="programlisting">@import url("//fonts.googleapis.com/css?family=Lato:300,400,700");
body {
  margin: 0;
  padding: 0;
  font-family: lato, helvetica-neue, sans-serif;
  background: #2B3E50;
  font-weight:300;
  color: #ebebeb;
}
#main {
  width: 540px;
  padding: 0 5%;
  margin: auto;
}</pre></div><p>We're starting this by<a id="id491" class="indexterm"/> pulling in a Google font. There are several to choose from at <a class="ulink" href="https://www.google.com/fonts">https://www.google.com/fonts</a>; we're going with Lato. On the <code class="literal">&lt;body&gt;</code> element, we'll set the font, font color, and background. Then, we'll set a width on the main <code class="literal">&lt;div&gt;</code> element, the one most of our application will be inside. Next, we'll add some styling to our anchor elements:</p><div><pre class="programlisting">a {
  text-decoration: none;
  font-weight: 700;
  color: #ebebeb;
}
#main a:hover {
  text-decoration: underline;
}</pre></div><p>All the links will get a bit of styling—no underline, some bolding, and a new color—but only anchors in the main element will get the hover styling. This is because we're soon going to create a navigation bar (outside the main element), and we don't want the links to be underlined when hovered over. Now, we're ready to style the tokens, which we do with this code:</p><div><pre class="programlisting">.token {
  font-size: 150%;
  font-weight: 700;
  margin: 5px;
  padding:7px 0;
  display: inline-block;
  background:#F0AD4E;
  color: #474747;
  width: 100px;
  text-align:center;
}
.token:nth-child(5n+1) {
  margin-left: 0;
}
.token:nth-child(5n) {
  margin-right:0;
}
.token:hover {
  background: #DF691A;
  cursor: pointer;
  color: #ececec;
}
.hidden {
  visibility: hidden; 
}</pre></div><p>We style the token as, basically, an orange block. We space them out evenly; we use the <em>n</em>th-child selectors to<a id="id492" class="indexterm"/> remove the margin from the outer edges of the other blocks. We add a hover effect to the blocks. Finally, we add the <code class="literal">hidden</code> class. Now, a refresh of the page should result in something like this:</p><div><img src="img/6997OS_07_02.jpg" alt="Writing the tokens view"/></div><p>Looking pretty good, don't you think? Now, we're ready for the next view, the ones that display the clues, that is, the definitions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Views of the clues</h1></div></div></div><p>The clues <a id="id493" class="indexterm"/>for the words—the definitions—will need to appear above the tokens. The <code class="literal">CluesView</code> class is pretty simple:</p><div><pre class="programlisting">var CluesView = Backbone.View.extend({
  tagName: 'table',
  render: function () {
    this.collection.forEach(function (word) {
      this.el.appendChild(new ClueView({ 
        model: word 
      }).render().el);
    }, this);
    return this;
  }
});</pre></div><p>The clues will be in a table. In the <code class="literal">render</code> method, we'll loop over the collection, rendering a <code class="literal">ClueView</code> class for each <code class="literal">Word</code> model. The <code class="literal">ClueView</code> class is where all the action takes place. Here's the <code class="literal">ClueView</code> class's code:</p><div><pre class="programlisting">var ClueView = Backbone.View.extend({
  tagName: 'tr',
  template: _.template($('#clue').html()),
  initialize: function () {
    Backbone.on('correct', this.correct, this);
  },
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    return this;
  },
  correct: function (word) {
    if (this.model.get('word') === word.get('word')) {
      this.$el.addClass('correct');
      this.$('.word')
        .removeClass('clue')
        .text(word.get('word'));
    }
  }
});</pre></div><p>This view will use a table row element, and it's the first view we have that uses a template. To<a id="id494" class="indexterm"/> render the template, we'll just pass the JSON version of that model to the <code class="literal">template</code> function. In the <code class="literal">initialize</code> method, we listen for the <code class="literal">correct</code> event to occur. This is the event that will be triggered when the player has correctly guessed one of the words. This is another global event that we'll fire at another location. When it happens, we'll call the <code class="literal">correct</code> method. This method will receive as a parameter the <code class="literal">Word</code> model for the correct word. Even though only one word has been guessed, all the <code class="literal">ClueView</code> instances will be listening for the correct event. So, the first step will be to compare words and to find the right <code class="literal">ClueView</code> instance. If the model for this view matches, we'll add the <code class="literal">correct</code> class. Then, we'll remove the <code class="literal">clue</code> class from part of the template and add the word.</p><p>Speaking of the template, add this to the <code class="literal">index.ejs</code> file in the <code class="literal">views</code> directory:</p><div><pre class="programlisting">&lt;script type='text/template' id='clue'&gt;
  &lt;td&gt;{{ definition }}&lt;/td&gt;
  &lt;td class='word clue'&gt;{{ word.length }} letters&lt;/td&gt;
&lt;/script&gt;</pre></div><p>As you know, this will go inside our table row element. The first <code class="literal">&lt;td&gt;</code> element will have the definition. The second will start by displaying the number of letters in the word, as another small clue. As we've seen, when they correctly guess the word, the clue will be replaced with the word itself. Before we check this out in the browser, let's add some styling to the <code class="literal">style.css</code> file in the <code class="literal">public</code> directory:</p><div><pre class="programlisting">table {
  width: 100%;
}
td:nth-of-type(1) {
  width:75%;
}
.clue {
  font-size:75%;
}
.word {
  float: right;
}
.correct {
  color: #5CB85C;
  font-weight: 700;
}</pre></div><p>We'll straighten up the <code class="literal">table</code> element and the first <code class="literal">&lt;td&gt;</code> cell in each row. When the second <code class="literal">&lt;td&gt;</code> cell has<a id="id495" class="indexterm"/> the number of letters in it, the <code class="literal">clue</code> class will reduce the font size a little. Then, when the word is correctly guessed, we'll remove that class and add <code class="literal">correct</code> to the whole <code class="literal">&lt;tr&gt;</code> element, coloring it and making it bold.</p><p>Now, back in the <code class="literal">index.ejs</code> file, you can render this view in that same quick and dirty way. Replace the content inside the <code class="literal">getWords</code> callback with this:</p><div><pre class="programlisting">$('#main')
  .append(new CluesView({ collection: game }).render().el)
  .append(new TokensView({ collection: game }).render().el);</pre></div><p>Then, refresh the page. It should look like this:</p><div><img src="img/6997OS_07_03.jpg" alt="Views of the clues"/></div><p>We can't yet see the <a id="id496" class="indexterm"/>correct word styling, because we can't yet guess words. That brings us to the next step: the guess view.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec83"/>Creating the guess view</h1></div></div></div><p>This will be the<a id="id497" class="indexterm"/> longest view in our application, because it's got the most to do. Let's start this one with the template:</p><div><pre class="programlisting">&lt;script type='text/template' id='guess'&gt;
  &lt;div class='btn text'&gt;&lt;/div&gt;
  &lt;div id='guessBtn' class='btn'&gt; Guess &lt;/div&gt;
&lt;/script&gt;</pre></div><p>It looks simple. The first <code class="literal">&lt;div&gt;</code> element is where the token text will appear as the player clicks on tokens. <a id="id498" class="indexterm"/>The second <code class="literal">&lt;div&gt;</code> element will be a button; when they click on it, their guess will be "submitted". If the guess is one of the words, it will appear alongside the correct definition. Otherwise, the tokens will reappear with the other tokens. This is the code for the <code class="literal">GuessView</code> class:</p><div><pre class="programlisting">var GuessView = Backbone.View.extend({
  className: 'guess',
  template: $('#guess').html(),
  events: {
    'click #guessBtn': 'guess'
  },
  initialize: function () {
    Backbone.on('token', this.add, this);
    this.currentTokens = [];
  },
  render: function () {
    this.el.innerHTML = this.template;
    this.guessText = this.$('.text');
    return this;
  },
  add: function (token) {
    this.currentTokens.push(token);
    this.guessText.append(token.get('text'));
  }
});</pre></div><p>Here's the start; we'll give this element a class called <code class="literal">guess</code>, and we'll get the preceding template that we just created. In the <code class="literal">initialize</code> method, we'll listen for the <code class="literal">token</code> event. Remember, when one of the tokens is clicked on, this event will trigger globally. Here, we catch that event and run our <code class="literal">add</code> method. The other thing going on in the <code class="literal">initialize</code> method is the creation of a <code class="literal">currentTokens</code> property. This will keep track of the tokens the user selects before they actually make a guess. In the <code class="literal">render</code> method, we'll get the template (which is just a string in this case, because there's no template data in this view), and then create a property that points to the <code class="literal">&lt;div&gt;</code> element we're using as a text field. This property is used in the <code class="literal">add</code> method; the method gets the <code class="literal">Token</code> model as a parameter. We'll cache the token in the <code class="literal">currentTokens</code> array, and append its text to the element.</p><p>Before we continue with this, let's style it. You know where to go—the <code class="literal">style.css</code> file in the <code class="literal">public</code> directory:</p><div><pre class="programlisting">.guess {
  overflow: hidden;
  margin: 20px 0 5px;
  border: 5px solid #D4514D;
}
.btn {
  background: #D4514D;
  width: 30%;
  cursor: pointer;
  line-height: 50px;
  height: 50px;
  font-size:200%;
  text-align: center;
  float:left;
}
.btn:hover {
  background: #C04946;
}
.btn.text {
  background: #5BC0DE;
  width:70%;
}</pre></div><p>Both the inside <code class="literal">&lt;div&gt;</code> elements have the class <code class="literal">btn</code>; we'll float them to the left and apply height, width, <a id="id499" class="indexterm"/>and coloring. Then, for the one with both the <code class="literal">btn</code> and <code class="literal">text</code> classes, we'll adjust the background color and width. When the actual button <code class="literal">&lt;div&gt;</code> is hovered over, we'll change the background color a bit, as buttons should do.</p><p>Now, let's render this view. Back in the <code class="literal">index.ejs</code> file change the <code class="literal">getWords</code> callback one more time:</p><div><pre class="programlisting">$('#main')
  .append(new CluesView({ collection: game }).render().el)
  .append(new GuessView({ collection: game }).render().el)
  .append(new TokensView({ collection: game }).render().el);</pre></div><p>Open this in the browser and click on a couple of tokens. You should see something like this:</p><div><img src="img/6997OS_07_04.jpg" alt="Creating the guess view"/></div><p>After playing with this, you should see two changes we need to make to this view. The big obvious one<a id="id500" class="indexterm"/> is that our <strong>Guess</strong> button doesn't do anything. The smaller, design-related problem is that the red border of our <code class="literal">GuessView</code> class's <code class="literal">&lt;div&gt;</code> element doesn't change color when the button is hovered over. Since they're the same color, this would be a nice touch. However, we can't use CSS to change an attribute on a parent element when a child element is hovered over. Don't worry, JavaScript is here to rescue the situation. Add these two events to the <code class="literal">GuessView</code> class's events property:</p><div><pre class="programlisting">'mouseover #guessBtn': 'color',
'mouseout #guessBtn': 'color'</pre></div><p>When the button receives the <code class="literal">mouseover</code> or <code class="literal">mouseout</code> event, we'll call the <code class="literal">color</code> method. This method is really simple; all it does is toggle the <code class="literal">border</code> class on that parent element:</p><div><pre class="programlisting">color: function () {
  this.$el.toggleClass('border');
},</pre></div><p>Of course, this means that we'll have to add a <code class="literal">border</code> class to our CSS file:</p><div><pre class="programlisting">.border {
  border-color: #C04946;
}</pre></div><p>Now, let's focus <a id="id501" class="indexterm"/>on the more important problem; allowing the player to make an actual guess. We already have the <code class="literal">GuessView</code> class ready for the click on the <strong>Guess</strong> button. When this happens, we call the <code class="literal">guess</code> method:</p><div><pre class="programlisting">guess: function (evt) {
  var results = this.collection.guess(this.guessText.text());
  if (results.word) {
    Backbone.trigger('correct', results.word);
  } else {
    this.currentTokens.forEach(function (token) {
      token.view.show();
    });
  }
  this.currentTokens = [];
  this.guessText.text('');
  if (results.complete) 
    Backbone.trigger('completed', this.collection);
}</pre></div><p>The first step is to check this word against the collection. We do this by calling the collection's <code class="literal">guess</code> method. We haven't written this yet, but it will return an object with two properties. The first is the <code class="literal">word</code> property. If the guess is a word in the collection, this property will be the <code class="literal">Word</code> model itself; otherwise, it will be <code class="literal">undefined</code>. If there is a <code class="literal">Word</code> model, we'll trigger the <code class="literal">correct</code> event, passing along the <code class="literal">Word</code> model. Remember, the <code class="literal">ClueView</code> instances are listening for this event. If <code class="literal">results.word</code> is <code class="literal">undefined</code>, this means the tokens did not spell one of the words, and they need to be replaced. So, we'll loop over the tokens and call the <code class="literal">show</code> method on the <code class="literal">view</code> property that we gave them when rendering those views. In either case, we'll empty the <code class="literal">currentTokens</code> property and clear the text from the <code class="literal">guessText</code> property. The last step is to check for a <code class="literal">complete</code> property on <a id="id502" class="indexterm"/>the <code class="literal">results</code> object. If this is <code class="literal">true</code>, the player just completed the last word and finished the game. If the game is done, we'll trigger a <code class="literal">completed</code> event, passing the game object as a parameter.</p><p>The last step is to write the <code class="literal">Game</code> collection's <code class="literal">guess</code> method. Back in the <code class="literal">models.js</code> file of the <code class="literal">public</code> directory, add this method to the <code class="literal">Game</code> class:</p><div><pre class="programlisting">guess: function (word) {
  var results = {
    word: this.findWhere({ word: word }),
    complete: false
  };
  if (results.word) {
    results.word.set('correct', true);
    var score = results.word.get('points');
    var mult = 10 - parseInt(this.seconds / 15);
    if (mult &lt;= 0) mult = 1;
    this.score += score * mult;
    results.complete = this.where({
      correct:true
    }).length === this.length;
  }
  return results;
}</pre></div><p>We start by creating a <code class="literal">results</code> object with the <code class="literal">word</code> and <code class="literal">complete</code> properties. The <code class="literal">complete</code> property will be <code class="literal">false</code> by default; for the <code class="literal">word</code> property, we will search the collection to find a word model that matches the text we passed into this method. The <code class="literal">findWhere</code> method will return <code class="literal">undefined</code> if no word is found. However, if a <code class="literal">Word</code> model is found, we'll give that model a temporary property. We'll set <code class="literal">correct</code> to <code class="literal">true</code>. Since the player has just guessed a word correctly, the next step is to update the score. We create a <code class="literal">score</code> variable; it starts with the basic <code class="literal">points</code> property on the <code class="literal">Word</code> model. Then, we need to calculate the multiplier. As we saw earlier, a <code class="literal">Game</code> instance will have a <code class="literal">seconds</code> property; soon, we'll see how this will count up. </p><p>For now, we'll divide the seconds count by 15, round it with <code class="literal">parseInt</code>, and subtract it from 10. Then, if that results in a number less than or equal to <code class="literal">0</code>, we'll reset <code class="literal">mult</code> to <code class="literal">1</code>. This way, any correct guesses in the first 15 seconds will get a 10x multiplier, anything in the second 15 seconds will get a 9x multipler, and so on. After 2 minutes and 30 seconds, the multiplier will be 1. Then, we'll increment the <code class="literal">score</code> property by the word <code class="literal">score</code> times the multiplier. Finally, we'll compare the number of words with the <code class="literal">correct</code> property to the total number of <a id="id503" class="indexterm"/>words in the collection. If these are equal, <code class="literal">results.complete</code> will be <code class="literal">true</code>, because all the words have been guessed correctly. Finally, we'll return the <code class="literal">results</code> object.</p><p>Now, with this in place, we can refresh the page and actually play our game. Go ahead, give it a whirl! Here's what it should look like:</p><div><img src="img/6997OS_07_05.jpg" alt="Creating the guess view"/></div><p>Pretty impressive, don't you think? We can pretty much play our game. However, there are a lot of details to<a id="id504" class="indexterm"/> take care of. While we are playing the game here, we aren't actually keeping score yet. So that's the next step.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec84"/>Building the info view</h1></div></div></div><p>The next<a id="id505" class="indexterm"/> class is for what we'll call the <code class="literal">InfoView</code> class. This will have both the time counter and the current score. We'll start with the template. Add this to the <code class="literal">index.ejs</code> file in the <code class="literal">views</code> directory: we're creating two <code class="literal">&lt;span&gt;</code> elements: one for the time and another for the points. Here's the code of the template:</p><div><pre class="programlisting">&lt;script type='text/template' id='info'&gt;
  &lt;span class='timer'&gt; 00:00 &lt;/span&gt;
  &lt;span class='points'&gt; 0 points &lt;/span&gt;
&lt;/script&gt;</pre></div><p>Now, before we write the view class, we need to add a few more methods to our <code class="literal">Game</code> collection class. The <code class="literal">guess</code> method that we wrote earlier keeps track of the player's score. We also want a <code class="literal">Game</code> instance to track the time. The counter will be inside the game instance, but the <code class="literal">InfoView</code> class will have to actually show the time. This is the <code class="literal">start</code> method:</p><div><pre class="programlisting">start: function (callback) {
  this.callback = callback;
  this.loop();
},
loop: function () {
  this.seconds++;
  this.callback(this.time());
  this.timeout = setTimeout(this.loop.bind(this), 1000);
},</pre></div><p>The <code class="literal">start</code> method is what the <code class="literal">InfoView</code> class will use. It takes a <code class="literal">callback</code> function as a parameter and assigns it as a property of the instance. Then, it calls the <code class="literal">loop</code> method. This method increments the <code class="literal">seconds</code> count, and then calls the <code class="literal">callback</code> function, passing it the result of the <code class="literal">time</code> method (that's next). Then, we'll set a timeout for this method to be called again in one second; we have to bind <code class="literal">loop</code> to <code class="literal">this</code>, so the value of <code class="literal">this</code> will remain the same each time we call it. The <code class="literal">time</code> method just returns the <code class="literal">seconds</code> count as a nice timestamp:</p><div><pre class="programlisting">time: function () {
  var hrs = parseInt(this.seconds / 3600),
    min = parseInt((this.seconds % 3600) / 60),
    sec = (this.seconds % 3600) % 60;

  if (min &lt; 10) min = "0" + min;
  if (sec &lt; 10) sec = "0" + sec;
  var time = min + ":" + sec;

  if (hrs === 0) return time;

  if (hrs &lt; 10) hrs = "0" + hrs;
  return hrs + ":" + time;
},</pre></div><p>It's pretty basic math. We can use the division and modulus operators, and the <code class="literal">parseInt</code> function, to create a <a id="id506" class="indexterm"/>time string. So, when the <code class="literal">seconds</code> count is 42, the string will be "00:42"; 73 will be "01:13". If the time is over an hour (which is unlikely, but possible), we'll add the hour count to the front. This time, string is the value that will be passed to the callback.</p><p>Now, let's look at the actual class. We'll give the element the class <code class="literal">info</code>, and we'll fetch the template. This is the code of the <code class="literal">InfoView</code> class:</p><div><pre class="programlisting">var InfoView = Backbone.View.extend({
  className: 'info',
  template: $('#info').html(),
  initialize: function () {
    this.listenTo(Backbone, 'correct', this.updateScore);
    this.collection.listenTo(Backbone, 'completed', this.collection.stop);
  },
  render: function () {
    this.el.innerHTML = this.template;
    this.time = this.$('.timer');
    this.score = this.$('.score');
    this.collection.start(this.time.text.bind(this.time));
    return this;
  },
  updateScore: function () {
    this.score.text(this.collection.score + ' points');
  }
});</pre></div><p>The <code class="literal">render</code> method begins by using the template string, and then creating two properties for the timer element and the score element. Then, we call the <code class="literal">collection.start</code> method that we have just <a id="id507" class="indexterm"/>written. Remember that this method takes a callback that will receive the time string, so, we can just pass it the jQuery <code class="literal">text</code> method bound to our <code class="literal">this.time</code> element. This will now count the time for us.</p><p>Before we look at the <code class="literal">initialize</code> method, let's add a little bit of styling to this. Add this to the <code class="literal">style.css</code> file in the <code class="literal">public</code> directory:</p><div><pre class="programlisting">.info {
  font-size:60px;
  margin: 20px 0;
}
.info span {
  margin-right:40px;
}</pre></div><p>It's nothing big; we just up the font size and add some margin. Now, add an <code class="literal">InfoView</code> instance to the quick and dirty test we've been using:</p><div><pre class="programlisting">$('#main')
  .append(new InfoView({ collection: game }).render().el)
  .append(new CluesView({ collection: game }).render().el)
  .append(new GuessView({ collection: game }).render().el)
  .append(new TokensView({ collection: game }).render().el);</pre></div><p>Load this in the browser, and you should see something like this:</p><div><img src="img/6997OS_07_06.jpg" alt="Building the info view"/></div><p>Now, in the <code class="literal">initialize</code> method, we listen for two application-wide events. When the player guesses a word correctly<a id="id508" class="indexterm"/> and the <code class="literal">correct</code> event is triggered, we'll call the <code class="literal">updateScore</code> method. As you can see, this will set the text of the score element by using the <code class="literal">score</code> property that we're updating on the collection object. The other event we're listening for is the <code class="literal">completed</code> event, which will be triggered when the game<a id="id509" class="indexterm"/> is completed. When this happens, we call the <code class="literal">stop</code> method on the collection object. This method has two jobs to do. First, it must stop the timer, and secondly, it must log the game to the server. This is the last method to add to the <code class="literal">Game</code> class:</p><div><pre class="programlisting">stop: function () {
  clearTimeout(this.timeout);
  Backbone.ajax({
    url: '/game',
    method: 'POST', 
    data: {
      time: this.seconds,
      score: this.score,
      date: new Date().toJSON()
    }
  });
}</pre></div><p>When we create the timeout in the <code class="literal">loop</code> method, we assign it to the <code class="literal">this.timeout</code> property. In this <code class="literal">stop</code> method, we can clear the timeout to stop the timer. Then, we store the current game data to the server. Instead of doing this the Backbone way—by creating a model and using an instance of it to send the data to the server—we just use the <code class="literal">Backbone.ajax</code> method to POST this data to the server. If you'd rather use a model, it's very simple. First, create the model class in your <code class="literal">models.js</code> file:</p><div><pre class="programlisting">var GameInfo = Backbone.Model.extend({
  urlRoot: '/game'
});</pre></div><p>Then, replace the <code class="literal">Backbone.ajax</code> call with a <code class="literal">GameInfo</code> instance:</p><div><pre class="programlisting">(new GameInfo({
  time: this.seconds,
  score: this.score,
  date: new Date()
}).save();</pre></div><p>We're not actually going to do it this way, because we don't use the <code class="literal">GameInfo</code> class anywhere else. However, the beauty of these methods is that the server-side code is identical in both cases. Open the <code class="literal">server.js</code> file again, and add this router:</p><div><pre class="programlisting">app.post('/game', function (req, res) {
  if (!req.user) return res.redirect('/login');
  var game = {
    time : parseInt(req.body.time, 10),
    score: parseInt(req.body.score, 10),
    date : req.body.date
  };
  req.user.games.push(game);

  if (game.score &gt; req.user.score) req.user.score = game.score;
  if (game.time  &lt; req.user.time ) req.user.time  = game.time;

  users.update({ id: req.user.id }, req.user, function (err, user) {
    res.json(game);
  });
});</pre></div><p>First, we check to see that the user is logged in; we do this because we need the <code class="literal">req.user</code> object in<a id="id510" class="indexterm"/> this method, and we don't want to get an error. If a user is logged in, we'll put together a game object, with the time, score, and date that we sent from the browser. Then, we'll push that game object into the user's game array. You might recall that the user object has score and time properties of its own; these are for their highest score and lowest time. If the score or time from this game is better than the user's best, we'll update their best results. Finally, we'll store the updated record in the database. Of course, the last step is to return the game as JSON, but we won't really use that on the browser.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec85"/>Wrapping our views in a GameView class</h1></div></div></div><p>At this point, for the user to play<a id="id511" class="indexterm"/> the game, we are rendering four views. Let's wrap these views up into a single view: the <code class="literal">GameView</code> class. It is a pretty short view, but it will clean up the code in our router, once we start the router. Here's the code for the <code class="literal">GameView</code> class:</p><div><pre class="programlisting">var GameView = Backbone.View.extend({
  render: function () {
    var attrs  = { collection: this.collection },
      info   = new InfoView(attrs),
      clues  = new CluesView(attrs),
      guess  = new GuessView(attrs),
      tokens = new TokensView(attrs);

    this.$el.append(info.render().el)
      .append(clues.render().el)
      .append(guess.render().el)
      .append(tokens.render().el);

    return this;
  }
});</pre></div><p>In the <code class="literal">render</code> method, we'll create the four views, and append them to the element. We can test this view <a id="id512" class="indexterm"/>very easily—just replace the <code class="literal">callback</code> function code that creates the four views with this single line:</p><div><pre class="programlisting">$('#main').append(new GameView({ collection: game }).render().el);</pre></div><p>Nothing will look any different in the browser, and that's exactly what we want.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec86"/>Starting the router</h1></div></div></div><p>We're finally<a id="id513" class="indexterm"/> ready to begin building the router. As you might recall from the <code class="literal">index.ejs</code> file in the <code class="literal">views</code> directory, we pull in a <code class="literal">router.js</code> script, and so, create a <code class="literal">router.js</code> file in the <code class="literal">public</code> directory. Let's start with this:</p><div><pre class="programlisting">var Router = Backbone.Router.extend({
  initialize: function (options) {
    this.main = options.main;
  },
  routes: {
    'play': 'play',
    'play/:level': 'play'
  },
  play: function (level) {
    var game = new Game();
    if (level) game.level = level;
    game.getWords().then(function () {
      this.main.append(new GameView({ 
        collection: game 
      }).render().el);
    }.bind(this));
  }
});</pre></div><p>As in our previous applications, the <code class="literal">initialize</code> method will take an <code class="literal">options</code> object, which will set the main element for the application. In the <code class="literal">routes</code> object, you will see that we create two <a id="id514" class="indexterm"/>routes. To play the game, we can go to either <code class="literal">/play</code> or, say, <code class="literal">/play/2</code>: both routes call the <code class="literal">play</code> method. This method creates a <code class="literal">Game</code> collection object; if a level was selected via the route path, we'll set it; otherwise, we'll stick with the default level (level 1). Then, we can get the words and create the <code class="literal">GameView</code> instance once we have those words.</p><p>The next step is to get rid of our quick and dirty test and replace it with the use of our router. In the <code class="literal">index.ejs</code> file of the <code class="literal">views</code> directory, this is what the final script tag (the inline script) should look like:</p><div><pre class="programlisting">var r = new Router({
  main: $("#main")
});
Backbone.history.start({ pushState: true });</pre></div><p>Now, you can go back to the browser and try the routes <code class="literal">/play</code> or <code class="literal">/play/3</code>. You should be able to play the game just as before.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec87"/>Creating the home view</h1></div></div></div><p>When a user first <a id="id515" class="indexterm"/>comes to our website, we don't want to display the game view right away. Most web applications will have some kind of home view, or welcoming view, explaining the purpose of the application. We could make that a server-side template, but we're going to make it a Backbone view instead. Here's the code of the <code class="literal">HomeView</code> class:</p><div><pre class="programlisting">var HomeView = Backbone.View.extend({
  template: $('#levels').html(),
  events: {
    'click a' : 'chooseLevel'
  },
  render: function () {
    this.el.innerHTML = this.template;
    return this;
  },
  chooseLevel: function (evt) {
    evt.preventDefault();
    this.remove();
    Backbone.history.navigate(evt.currentTarget.pathname, 
      { trigger: true });
    return false;
  }
});</pre></div><p>We get the template with the <code class="literal">id</code> property of <code class="literal">home</code> from the <code class="literal">index.ejs</code> file. The <code class="literal">render</code> method is simple. <a id="id516" class="indexterm"/>The <code class="literal">events</code> object listens for clicks on anchor elements and calls the <code class="literal">chooseLevel</code> method. We've seen a method like this before; it just prevents the default action—the page refreshing—and uses <code class="literal">Backbone.history</code> to change the view instead. Finally, here's the template for this view:</p><div><pre class="programlisting">&lt;script type='text/template' id='home'&gt;
  &lt;h1&gt;Pick a Level:&lt;/h1&gt;
  &lt;h2&gt;&lt;a href='/play/1'&gt; Level 1 &lt;/a&gt;&lt;/h2&gt;
  &lt;h2&gt;&lt;a href='/play/2'&gt; Level 2 &lt;/a&gt;&lt;/h2&gt;
  &lt;h2&gt;&lt;a href='/play/3'&gt; Level 3 &lt;/a&gt;&lt;/h2&gt;
  &lt;h1&gt;Or, check out the &lt;a href='/scoreboard'&gt;scoreboard&lt;/a&gt;&lt;/h1&gt;
&lt;/script&gt;</pre></div><p>Let's style the <code class="literal">&lt;h1&gt;</code> elements a little bit. You know where this goes—in the <code class="literal">style.css</code> file:</p><div><pre class="programlisting">h1 {
  font-weight:300;
  font-size:39px;
}</pre></div><p>Now, we need to use this view in the router. Open the <code class="literal">router.js</code> file in the <code class="literal">public</code> directory and add the <code class="literal">index</code> route:</p><div><pre class="programlisting">'': 'index'</pre></div><p>Then, we'll add the <code class="literal">index</code> function:</p><div><pre class="programlisting">index: function () {
  this.main.html(new HomeView().render().el);
},</pre></div><p>Now, you should be able to go to the root route and see this:</p><div><img src="img/6997OS_07_07.jpg" alt="Creating the home view"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec88"/>Building a scoreboard</h1></div></div></div><p>We've <a id="id517" class="indexterm"/>already built the primary view for this application. However, every complete web application will have several views that aren't specific to the main purpose of the application, but help round out its usefulness. In our application, this will be a scoreboard view; a place where players can see each other's best time and score. Let's start on the server side this time, in the <code class="literal">server.js</code> file. Add this route before the catch-all route:</p><div><pre class="programlisting">app.get('/scoreboard', function (req, res) {
  users.find(function (err, userRecords) {
    userRecords.forEach(function (user) {
      user.totalScore = 0;
      user.games.forEach(function (game) {
        user.totalScore += game.score;
      });
    });
    userRecords.sort(function (a,b) { 
      return b.score - a.score
    });

    res.render("scoreboard.ejs", { users: userRecords });
  });
});</pre></div><p>We start by getting all the users in the database. Then, we loop over each user, adding a <code class="literal">totalScore</code> property to each one. We loop over the <code class="literal">games</code> array for each user and sum up the score for <a id="id518" class="indexterm"/>each game, creating the <code class="literal">totalScore</code> property. Note that we don't actually change anything in the database; we just create a temporary property here. Then, we sort the <code class="literal">userRecords</code> array; by default, the array's <code class="literal">sort</code> method will sort alphabetically, so we pass a function here that sorts the users from highest- to lowest-scoring. Then, we'll render the <code class="literal">scoreboard.ejs</code> template in the <code class="literal">views</code> directory, passing it the <code class="literal">userRecords</code> object.</p><p>Here is the code of the <code class="literal">scoreboard.ejs</code> template:</p><div><pre class="programlisting">&lt;% include header %&gt;
&lt;div id="main"&gt;
  &lt;h1&gt; Scoreboard &lt;/h1&gt;
  &lt;table class="users"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Total Score&lt;/th&gt;
      &lt;th&gt;Best Game&lt;/th&gt;
      &lt;th&gt;Best Time&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;% users.forEach(function(user){ %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%=: user.username | capitalize %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%=  user.totalScore %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= user.score %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%=: user.time | time %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% }); %&gt;
  &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/div&gt;
&lt;% include footer %&gt;</pre></div><p>As with our other full-page templates, we'll open and close with the header and footer includes. Then, we'll create the main element. This element has a table element inside it. We start with a <code class="literal">&lt;thead&gt;</code> element, with four column headers: the player's name, total score, best game score, and best time. Then, inside the <code class="literal">&lt;tbody&gt;</code> element, we loop over the <code class="literal">user</code> array <a id="id519" class="indexterm"/>and add a row for each user. We use one of the EJS's features here: filters. For example, we print the <code class="literal">user.username</code> property, but we filter it through the <code class="literal">capitalize</code> filter so that the first letter will be, you guessed it, capitalized. Then, the <code class="literal">user.time</code> property is a seconds count, so we filter it through the <code class="literal">time</code> filter to display it as a human-friendly string. However, this isn't a built-in filter, so we'll have to write it ourselves.</p><p>Back in the <code class="literal">server.js</code> file, we first require the <code class="literal">ejs</code> library that Express uses behind the scenes:</p><div><pre class="programlisting">var ejs = require('ejs');</pre></div><p>Then, we have to write the filter function. We can actually just copy and adjust the time method from the <code class="literal">Game</code> class:</p><div><pre class="programlisting">ejs.filters.time = function(seconds) {
  var hrs = parseInt(seconds / 3600),
    min = parseInt((seconds % 3600) / 60),
    sec = (seconds % 3600) % 60;

  if (min &lt; 10) min = "0" + min;
  if (sec &lt; 10) sec = "0" + sec;
  var time = min + ":" + sec;

  if (hrs === 0) return time;

  if (hrs &lt; 10) hrs = "0" + hrs;
  return hrs + ":" + time;
};</pre></div><p>The last step for the scoreboard is to add some styling to the user's table. Once again, turn to the <code class="literal">style.css</code> file in the <code class="literal">public</code> directory:</p><div><pre class="programlisting">table.users {
  border-collapse: collapse;
}

.users tbody tr {
  background: #4E5D6C;
}

.users tbody tr td {
  padding: 10px;
}

.users th,
.users td {
  width: 25%;
  text-align:center;
}</pre></div><p>It's nothing too<a id="id520" class="indexterm"/> fancy, but it will do the job. We'll add some padding and color the background, and we're done! Here's the final product:</p><div><img src="img/6997OS_07_08.jpg" alt="Building a scoreboard"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec89"/>Writing the navigation</h1></div></div></div><p>The next part of <a id="id521" class="indexterm"/>our application will pull things together; it is the navigation bar. In previous applications, the navigation has been its own Backbone view, but this is not the case this time. Instead, we'll create a new server-side template just for navigation. We'll be able to use this as an include, as we did with the header and footer templates. So, create the <code class="literal">nav.ejs</code> file in the <code class="literal">views</code> directory and put the following code in it:</p><div><pre class="programlisting">&lt;nav&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href="/"&gt;Tokenr&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/"&gt; Play &lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/scoreboard"&gt; Scoreboard &lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre></div><p>It's a basic list;<a id="id522" class="indexterm"/> there isn't much navigating to do in our application. But of course, we'll need to add some styling. Here's the last addition to the <code class="literal">style.css</code> file in the <code class="literal">public</code> directory:</p><div><pre class="programlisting">nav {
  margin:0;
  background-color: #4E5D6C;
  overflow: hidden;
  font-size:19px;
}
ul {
  list-style-type:none;
  margin:0;
  padding: 0;
}
nav li {
  display: inline-block;
}
nav li a {
  display: inline-block;
  padding: 10px;
}
nav li a:hover {
  background-color: #485563;
}
nav li:nth-of-type(1) a {
  color: #D4514D;
}</pre></div><p>This styling creates a nice navigation bar at the top of the page, with a nice hover effect on each link. The last part adds a color to the first item to make it appear like a logo. Now, add this as an include, under the header include of both the <code class="literal">index.ejs</code> and <code class="literal">scoreboard.ejs</code> files, like this:</p><div><pre class="programlisting">&lt;% include nav %&gt;</pre></div><p>That's it! Here's what it looks like:</p><div><img src="img/6997OS_07_09.jpg" alt="Writing the navigation"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec90"/>Adding new words</h1></div></div></div><p>Let's add one <a id="id523" class="indexterm"/>more feature to our application; the ability to add new words to the word list. We won't allow just any user to do this, only administrators. How exactly can we make a user an administrator? Well, we'll cheat. Open the <code class="literal">users.json</code> file directly, and add an <code class="literal">"admin":true</code> property to the user object of our choice. Then, we'll open the <code class="literal">server.js</code> file; first is the GET route for <code class="literal">/new</code>:</p><div><pre class="programlisting">app.get('/new', function (req, res) {
  if (req.user &amp;&amp; req.user.admin) {
    res.render('new.ejs');
  } else {
    res.redirect('/');
  }
});</pre></div><p>If there's a user logged in, and that user is an administrator, then we'll render the new word template. Otherwise, we'll redirect to the root route. Create the <code class="literal">new.ejs</code> file in the <code class="literal">views</code> directory, and write this:</p><div><pre class="programlisting">&lt;% include header %&gt;
&lt;% include nav %&gt;
&lt;div id='main'&gt;
  &lt;form method="post" action="/new"&gt;
    &lt;h1&gt; Add a Word &lt;/h1&gt;
    &lt;p&gt;Word:&lt;/p&gt;
    &lt;p&gt;&lt;input type='text' name='word' /&gt;&lt;/p&gt;
    &lt;p&gt;Definition:&lt;/p&gt;
    &lt;p&gt;&lt;input type='text' name='definition' /&gt;&lt;/p&gt;
    &lt;p&gt;Level:
      1 &lt;input type='radio' name='level' value='1' /&gt;
      2 &lt;input type='radio' name='level' value='2' /&gt;
      3 &lt;input type='radio' name='level' value='3' /&gt;
    &lt;/p&gt;
    &lt;p&gt;&lt;button&gt;Add&lt;/button&gt;&lt;/p&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;% include footer %&gt;</pre></div><p>We will post to the <code class="literal">/new</code> route when the form is submitted. We have an input element for the word and<a id="id524" class="indexterm"/> its definition (we could use a text area here, but an input element will encourage a short definition). Then, we have a set of radio buttons for choosing the level. Since this will post to the same route, we need a POST route on the server side to catch the new word:</p><div><pre class="programlisting">app.post('/new', function (req, res) {
  if (req.user &amp;&amp; req.user.admin) {
    var w = {
      word: req.body.word.toLowerCase(),
      definition: req.body.definition,
      level: parseInt(req.body.level, 10)
    };
    words.find({ word: w.word }, function (err, ws) {
      if (ws.length === 0) {
        words.insert(w);
      }
    });
    res.redirect('/new');
  } else {
    res.redirect('/');
  }
});</pre></div><p>If there's an admin user logged in, we'll create a word object, <code class="literal">w</code>. Then, we'll check the word's database to see if the word already exists; if it doesn't, we'll insert it. Finally, we'll return to the form so that the administrator can insert another word if they want to.</p><p>Finally, let's add this path to the navigation, but only when an administrator is logged in. In the <code class="literal">nav.ejs</code> file of the <code class="literal">views</code> directory, add this as the last list item:</p><div><pre class="programlisting">&lt;% if (admin) { %&gt;
  &lt;li&gt;&lt;a href="/new"&gt; Add Word &lt;/a&gt;&lt;/li&gt;
&lt;% } %&gt;</pre></div><p>Then, everywhere we call the <code class="literal">res.render</code> function on the templates that use <code class="literal">nav.ejs</code> (that's <code class="literal">new.ejs</code>, <code class="literal">scoreboard.ejs</code>, and <code class="literal">index.ejs</code>), we add the <code class="literal">admin</code> value to the values passed to the template. For example:</p><div><pre class="programlisting">res.render("index.ejs", { admin: req.user &amp;&amp; req.user.admin });</pre></div><p>If a user is logged in<a id="id525" class="indexterm"/> and they are an administrator, admin will be <code class="literal">true</code>. Otherwise, it will be <code class="literal">false</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec91"/>Summary</h1></div></div></div><p>This brings us to the end of the last chapter. The first big idea we looked at in this chapter is not loading any application data with the initial page load. If your application uses a lot of data, this can often be a good idea. Not only does this shorten the initial page load, but it also prevents you from loading data that the user doesn't need (for example, if the user never uses a specific feature of the application, the data needed for that feature never loads).</p><p>The other thing to remember from this chapter is that a Backbone application may not be just Backbone pages. Our scoreboard page is a good example of this. It wouldn't have been difficult to create that page via Backbone—just create a <code class="literal">User</code> model and a <code class="literal">Users</code> collection and a couple of views—but since the user records don't really have any client-side relevance, apart from being logged in, we took the simpler route of doing it from the server side. Your web app will likely have other pages too that don't need data: a contact page, an FAQ page, that kind of thing. Don't forget about these details!</p><p>Most of what we've covered in this chapter is a review of the primary ways of using Backbone's main components, the model, the collection, the view, and the router. As with anything, the beauty of having a complete understanding of the way something works is that you are then free to bend it in whatever way you choose. Throughout this book, we look at several different ways of doing almost anything in Backbone. If you take only one thing away from it all, let it be this; it's just JavaScript, and there are countless other ways not mentioned here to create patterns of your own. It could be said that programming is just as much about self-expression as anything else, and a skilled programmer isn't afraid to experiment. Here's just one example for the road. What if the <code class="literal">initialize</code> method of a view class ended by calling the <code class="literal">render</code> method? Have fun with your Backbone applications!</p></div></body></html>