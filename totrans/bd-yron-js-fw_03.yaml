- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Internal Framework Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部框架架构
- en: In the previous chapters, we learned about the history of the current frameworks
    and explored the concept of abstractions. We also looked at how JavaScript frameworks
    use, combine, and extend different abstractions to make a framework functional.
    In this chapter, we will dive into the architectural patterns of JavaScript frameworks.
    To go even further and expand our framework knowledge, we will have to closely
    inspect what goes into making a modern framework and what we can learn from existing
    patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了当前框架的历史，探讨了抽象的概念。我们还研究了JavaScript框架如何使用、组合和扩展不同的抽象来使框架功能化。在本章中，我们将深入研究JavaScript框架的架构模式。为了更进一步并扩展我们的框架知识，我们必须仔细检查现代框架的构建内容以及我们可以从现有模式中学到什么。
- en: 'As part of this chapter, we will explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将探讨以下内容：
- en: Understanding the core technical architectural patterns of existing frontend
    and backend frameworks. We will focus on the design, architecture, and structural
    patterns that are combined into a single system.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现有前端和后端框架的核心技术架构模式。我们将关注结合成一个单一系统的设计、架构和结构模式。
- en: Getting a glimpse into framework APIs, packaging configurations, and additional
    tooling.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概览框架API、打包配置和附加工具。
- en: Understanding additional tools that benefit the framework.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对框架有益的附加工具。
- en: Exposure to available compiles and bundlers.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的编译器和打包器。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Similar to the previous chapter, we will be using this book’s repository as
    an extension of this chapter. You can find it at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework),
    and the relevant files are in the `chapter3` directory. To run the code in this
    repository, you can use any environment that supports using a Terminal or a command
    prompt, running Node.js, such as Windows, macOS, and most varieties of Linux.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们将使用本书的存储库作为本章的扩展。您可以在[https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)找到它，相关文件位于`chapter3`目录中。要运行该存储库中的代码，您可以使用任何支持使用终端或命令提示符、运行Node.js的环境，例如Windows、macOS和大多数Linux版本。
- en: Most of the code mentioned in this chapter can be found in this book’s repository,
    so you don’t have to navigate external repositories. Follow the `README.md` instructions
    in the `chapter3` directory to get started. In addition, a lot of framework architecture
    focuses on the stakeholders or developers who will use the framework to build
    new projects. In this chapter, we will refer to them as *framework users*, not
    to be confused with the end users of applications built with these frameworks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的大部分代码都可以在本书的存储库中找到，因此您无需导航外部存储库。请按照`chapter3`目录中的`README.md`说明开始。此外，许多框架架构都关注于将使用该框架构建新项目的利益相关者或开发者。在本章中，我们将称他们为*框架用户*，以免与使用这些框架构建的应用程序最终用户混淆。
- en: Exploring the core architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索核心架构
- en: Let’s explore the core architectural pieces of building a framework. When a
    framework project is created, it is usually partitioned into an organized directory
    structure consisting of various specialized compartments. This approach helps
    separate the concerns of specific modules, scripts, and files. This organizational
    pattern is similar to how web application projects are organized. Except in the
    case of the framework, the project needs to export public interfaces and scripts
    to be usable. In some cases, frameworks can also be split into multiple repositories
    to allow a different approach to framework development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索构建框架的核心架构组件。当一个框架项目被创建时，它通常被划分为一个有组织的目录结构，包含各种专业部分。这种方法有助于分离特定模块、脚本和文件的关注点。这种组织模式类似于网络应用项目的组织方式。但在框架的情况下，项目需要导出公共接口和脚本以便使用。在某些情况下，框架也可以拆分为多个存储库，以允许采用不同的框架开发方法。
- en: Given that the programming environment for every language is different, the
    JavaScript and TypeScript frameworks have their own ways of structuring the framework
    projects, making it easier to generate artifacts and make the frameworks more
    usable within the projects that utilize them. A well-organized project makes it
    easier to maintain, collaborate, and refactor many parts of said project. For
    instance, let’s take real-world examples such as Vue.js and Angular. Angular keeps
    most of the framework files in a single repository (which can be found at [github.com/angular/angular](http://github.com/angular/angular)),
    except its command-line tools (located at [github.com/angular/angular-cli](http://github.com/angular/angular-cli)).
    However, many packages are published as separate dependencies in the package registry,
    such as **npm** (which can be found at [npmjs.com/package/@angular/core](http://npmjs.com/package/@angular/core)).
    The resulting payload for the framework package can be different from a frontend
    framework. In the case of Angular, it consists of pre-built files for different
    versions of JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种语言的编程环境都不同，JavaScript 和 TypeScript 框架都有自己的方式来构建框架项目，这使得生成工件和使框架在利用它们的项目中更容易使用。一个组织良好的项目使得维护、协作和重构该项目的许多部分变得更加容易。例如，让我们以
    Vue.js 和 Angular 这样的现实世界示例为例。Angular 将大多数框架文件保存在单个存储库中（可在 [github.com/angular/angular](http://github.com/angular/angular)
    找到），除了其命令行工具（位于 [github.com/angular/angular-cli](http://github.com/angular/angular-cli)）。然而，许多包作为独立的依赖项发布在包注册表中，例如
    **npm**（可在 [npmjs.com/package/@angular/core](http://npmjs.com/package/@angular/core)
    找到）。框架包的结果可能与前端框架不同。在 Angular 的情况下，它由针对不同版本的 JavaScript 的预构建文件组成。
- en: 'In *Figure 3**.1*, Angular core is provided as unflattened and flattened versions
    in the `esm2020`, `fesm2015`, `fesm2020` directories, and these packages also
    include various source maps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3*.1 中，Angular 核心以未扁平化和扁平化版本提供，位于 `esm2020`、`fesm2015`、`fesm2020` 目录中，这些包还包含了各种源映射：
- en: '![Figure 3.1: Angular core files provided as an npm package](img/Figure_3.1_B19014.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：作为 npm 包提供的 Angular 核心文件](img/Figure_3.1_B19014.jpg)'
- en: 'Figure 3.1: Angular core files provided as an npm package'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：作为 npm 包提供的 Angular 核心文件
- en: Depending on the browser target or the bundler technology used, Angular offers
    multiple import options. Vue.js has a similarly packaged export that offers a
    myriad of options to load the framework in a particular JavaScript module environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标浏览器或使用的打包技术，Angular 提供了多种导入选项。Vue.js 也有类似的打包导出，提供了多种选项来在特定的 JavaScript 模块环境中加载框架。
- en: 'The output directory in *Figure 3**.2* is the result of packaging the Vue.js
    framework using `rollup.js` ([rollupjs.org](http://rollupjs.org)) to create an
    output configuration for each of the target runtimes. The source of this configuration
    can be found at [github.com/vuejs/core/blob/main/rollup.config.js](http://github.com/vuejs/core/blob/main/rollup.config.js):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3*.2 中的输出目录是使用 `rollup.js` ([rollupjs.org](http://rollupjs.org)) 打包 Vue.js
    框架的结果，为每个目标运行时创建输出配置。该配置的源代码可以在 [github.com/vuejs/core/blob/main/rollup.config.js](http://github.com/vuejs/core/blob/main/rollup.config.js)
    找到：'
- en: '![Figure 3.2: Vue.js distribution as an NPM package](img/Figure_3.2_B19014.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：Vue.js 作为 NPM 包的分布](img/Figure_3.2_B19014.jpg)'
- en: 'Figure 3.2: Vue.js distribution as an NPM package'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：Vue.js 作为 NPM 包的分布
- en: The produced files of the targeted configurations slowly evolve with the runtime
    target as time progresses. For instance, if the framework is not usually included
    as a global variable inside of a `<script>` tag, then it might make sense to get
    rid of the global variable output or let the framework users convert the resulting
    output of the framework to suit their needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 针对配置产生的文件会随着运行时目标的变化而缓慢演变。例如，如果框架通常不作为全局变量包含在 `<script>` 标签内，那么删除全局变量输出或将框架用户的输出转换为满足其需求可能是有意义的。
- en: Examples of packaged frameworks
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打包框架的示例
- en: You can check out the examples of the framework bundles by running the `npm
    start` script in the `chapter3` directory. Once the packaged framework sources
    have been downloaded and extracted, you can view several resulting outputs for
    Angular and Vue.js.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `chapter3` 目录中运行 `npm start` 脚本来查看框架打包的示例。一旦打包的框架源代码下载并解压，您就可以查看 Angular
    和 Vue.js 的几个输出结果。
- en: Now that a build step is so widespread in JavaScript projects, these frameworks
    also provide direct ways to import the framework packages and include them as
    part of the build process. The “unflattened” version of the framework would be
    an example of this, where the framework files are not concatenated. Instead, the
    bundler would be combining those files and optimizing them with techniques such
    as code splitting if possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建步骤在JavaScript项目中如此普遍，这些框架也提供了直接导入框架包并将其包含在构建过程中的方法。框架的“未扁平化”版本就是这种情况的一个例子，其中框架文件没有被连接。相反，打包器会合并这些文件，并在可能的情况下使用代码拆分等技术进行优化。
- en: 'The applications that use the framework import the dependencies in the `package.json`
    file. Angular splits the different parts of the framework into different packages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架的应用程序在`package.json`文件中导入依赖项。Angular将框架的不同部分拆分为不同的包：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Splitting these modules into their own packages creates a well-defined boundary
    between the different modules. However, extra release tooling is usually required
    to make it easier to manage and release multiple modules without manually packaging
    them. The split packages also benefit framework users as they can pick and choose
    which modules are required for their applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些模块拆分为各自的包，为不同的模块之间创建了一个明确的边界。然而，通常需要额外的发布工具来简化管理和发布多个模块，而无需手动打包。拆分的包也使框架用户受益，因为他们可以根据自己的应用程序选择所需的模块。
- en: Angular core dependencies in action
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心依赖项的实际应用
- en: The framework showcase from [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015)
    has an existing example of all the Angular dependencies mentioned in this section.
    You can find the application in the `chapter1/angular` directory, run it, and
    tweak it to your preference. Many of these core dependencies can be found via
    the `@angular` namespace in the `npm` package list at `npmjs.com/search?q=%40angular`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1章**（[B19014_01.xhtml#_idTextAnchor015]）中的框架展示已经包含了本节中提到的所有Angular依赖项的现有示例。你可以在`chapter1/angular`目录中找到应用程序，运行它，并根据你的喜好进行调整。许多这些核心依赖项可以在`npmjs.com/search?q=%40angular`的`npm`包列表中的`@angular`命名空间中找到。'
- en: In the case of Vue.js, the core architecture is divided across many repositories
    at [github.com/vuejs](http://github.com/vuejs). The core, router, developer tools,
    documentation, and other parts of the framework are split across repositories
    in the Vue.js organization. When building a new framework, it is often easier
    to manage most of it in a single repository and even keep everything in a single
    package. The structure can still be well separated, and it will avoid the extra
    friction of managing extra repositories. As your project grows, it is possible
    to split it into multiple repositories as you see fit. By that point, the framework
    should already have an established release model and infrastructure to support
    this kind of expansion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js的情况下，核心架构被分散在许多GitHub仓库[github.com/vuejs](http://github.com/vuejs)中。核心、路由、开发者工具、文档和其他框架部分被分散在Vue.js组织的不同仓库中。在构建新的框架时，通常更容易在一个仓库中管理大部分内容，甚至将所有内容都放在一个包中。结构仍然可以很好地分离，并且可以避免管理额外仓库的额外摩擦。随着项目的增长，你可以根据自己的需要将其拆分为多个仓库。到那时，框架应该已经建立了一个稳定的发布模型和基础设施来支持这种扩展。
- en: 'To better understand the wider architectural patterns of framework design and
    maintenance, we are going to explore three important parts that comprise a framework’s
    technical architecture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解框架设计和维护的更广泛的架构模式，我们将探讨构成框架技术架构的三个重要部分：
- en: '**Modules**: The isolated parts of the code base, usually in a single JavaScript
    file. These often import or export functions, classes, or other types of structures,
    which are later utilized as part of a larger system.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：代码库的独立部分，通常位于单个JavaScript文件中。这些模块通常导入或导出函数、类或其他类型的结构，这些结构随后作为更大系统的一部分被使用。'
- en: '**Packages**: The main source code behind the framework includes interfaces
    that are exposed to the users and interfaces that are used internally to facilitate
    certain functionality.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：框架背后的主要源代码包括暴露给用户的接口和用于内部实现某些功能的接口。'
- en: '**Scripts**: Binaries and scripts that are exposed as part of the framework.
    Some of the scripts are also used for framework development and extra tooling
    required for specific use cases.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**：作为框架一部分公开的二进制文件和脚本。其中一些脚本也用于框架开发和特定用例所需的额外工具。'
- en: '**Compilers**: The programs that are included as part of the framework that
    either generate the main JavaScript output from the framework or are used as part
    of the development process.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器**：作为框架的一部分包含的程序，这些程序要么从框架中生成主要的JavaScript输出，要么作为开发过程的一部分使用。'
- en: Not everything in these categories is required for a successful framework, but
    as authors, we can pick and choose what is important to us for our project and
    focus on that. If we look at the existing frameworks of today, we will see similar
    patterns that work well for JavaScript, frontend, and backend projects – these
    projects employ all or most of these architectural categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并非这些类别中的每一项都是成功框架所必需的，但作为作者，我们可以挑选出对我们项目重要的部分，并专注于这些部分。如果我们观察现有的框架，我们会看到适用于JavaScript、前端和后端项目的相似模式——这些项目采用了所有或大部分这些建筑类别。
- en: In the next section, we will explore two types of technical patterns in framework
    development – these include architectural and design decisions that affect how
    the different frameworks function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨框架开发中的两种技术模式——这些包括影响不同框架如何工作的架构和设计决策。
- en: Patterns
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: The focus on framework development requires learning about different types of
    software patterns, such as architectural, design, and technical patterns. Knowing
    about these patterns and what kind of decisions went into implementing them in
    existing frameworks can assist new framework authors at being successful in their
    projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于框架开发需要了解不同类型的软件模式，例如架构、设计和技术模式。了解这些模式以及它们在现有框架中实现时所做出的决策，可以帮助新的框架作者在他们的项目中取得成功。
- en: Architectural patterns
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建筑模式
- en: We saw examples of existing architectural patterns such as MVC and MVVM in [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015). JavaScript frameworks have the freedom
    to choose any type of architectural model as they see fit for their use cases.
    For example, the component-based architecture is highly relevant in modern frontend
    frameworks and is used in many systems, especially those that extend the React
    library for their feature set. In this pattern, each component is encapsulated
    with its own state, a view, and a particular behavior, and could even consist
    of nested components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](B19014_01.xhtml#_idTextAnchor015)中看到了现有建筑模式的例子，如MVC和MVVM。JavaScript框架有自由选择任何类型的架构模型，只要它们认为适合它们的用例。例如，基于组件的架构在现代前端框架中非常相关，并被许多系统使用，特别是那些扩展React库以增加其功能集的系统。在这种模式中，每个组件都封装了自己的状态、视图和特定的行为，甚至可能包含嵌套组件。
- en: In backend frameworks, the middleware architectural pattern is often utilized
    to manage or mutate incoming requests and outgoing responses. This type of pattern
    works well due to the nature of the server requests and responses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端框架中，中间件架构模式通常被用来管理或修改传入的请求和传出的响应。这种模式由于服务器请求和响应的性质而非常有效。
- en: A different approach to architectural patterns can be seen within the Electron.js
    application framework. For the most part, Electron.js is designed on top of process
    communication between the interface renderer process and the main process for
    the lower-level operations. This architectural approach does not define a particular
    name but still directs the architecture toward the separation of concerns. If
    you look at some of the code bases of the Electron.js applications, you will notice
    the organization between the two responsibilities of the interface and the backend
    operations. Frameworks can also use a mix of architectural patterns that combine
    aspects of object-oriented, functional, and reactive programming to enable the
    most flexibility. A lot of these concepts can be witnessed within the Nest.js
    framework, as highlighted in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Electron.js应用程序框架中，我们可以看到对建筑模式的不同方法。大部分情况下，Electron.js是在界面渲染进程和主进程之间的进程通信之上设计的，用于低级操作。这种架构方法虽然没有定义特定的名称，但仍然将架构引导到关注点的分离。如果你查看一些Electron.js应用程序的代码库，你会注意到界面和后端操作之间的组织。框架也可以使用结合面向对象、函数式和响应式编程方面的混合架构模式，以实现最大的灵活性。许多这些概念可以在Nest.js框架中看到，如[第1章](B19014_01.xhtml#_idTextAnchor015)中所述。
- en: By browsing the design decisions and the code of various open source frameworks,
    you can find a variety of implementations of different architectural patterns.
    As a future framework author, I encourage you to innovate in this space by creating
    your original architectural patterns or deriving your own approach to the established
    patterns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览各种开源框架的设计决策和代码，你可以找到不同架构模式的多种实现。作为一个未来的框架作者，我鼓励你在这一领域进行创新，通过创建你自己的原始架构模式或从既定模式中推导出你自己的方法。
- en: Design patterns
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式
- en: In terms of design patterns, these focus on a much lower level compared to architectural
    patterns. These patterns address how a framework can solve frequent challenges
    of organizing code and techniques to enable a cohesive architecture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式方面，这些模式与架构模式相比处于更低的层次。这些模式解决的是框架如何解决组织代码和技术以实现一致架构的常见挑战。
- en: In [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we saw an example of a design
    pattern via the observer pattern. In addition to the observer technique, frameworks
    can also utilize a factory pattern, which helps create and manage reusable objects
    based on some definition. Depending on the implementation and the environment,
    additional enhancements may include managing the created objects. Another design
    pattern often seen in all types of JavaScript frameworks is the Publish and Subscribe
    pattern. This pattern allows both framework internals and components built with
    the framework abstractions to interact with each other by emitting events and
    subscribing to those events to create an asynchronous way of communicating between
    different parts of the system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B19014_01.xhtml#_idTextAnchor015)中，我们通过观察者模式看到了一个设计模式的例子。除了观察者技术之外，框架还可以利用工厂模式，这有助于根据某些定义创建和管理可重用对象。根据实现和环境的不同，额外的增强可能包括管理创建的对象。在所有类型的JavaScript框架中经常看到的设计模式还包括发布和订阅模式。这种模式允许框架内部和基于框架抽象构建的组件通过发出事件和订阅这些事件来相互交互，从而在系统不同部分之间创建一种异步通信方式。
- en: Modules and the module design pattern are also universal in all JavaScript software.
    You will find module APIs defined by the language itself and abstractions around
    modules refined by different frameworks. This pattern mainly concentrates on enforcing
    encapsulation, standardizing the code base, and preventing large convoluted pieces
    of code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和模块设计模式在所有JavaScript软件中也同样普遍。你将发现由语言本身定义的模块API以及由不同框架精炼的模块抽象。这种模式主要集中于强制封装、标准化代码库以及防止大量复杂的代码块。
- en: In the next section, we’ll look at the technical architecture. It consists of
    details related to the technical approach to outlining APIs, defining entry points,
    and using additional tooling to enable framework behaviors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨技术架构。它包括与技术方法相关的细节，例如概述API、定义入口点以及使用额外的工具来启用框架行为。
- en: The technical architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术架构
- en: The technical architecture and patterns mainly deal with technical challenges.
    For JavaScript applications, this could mean dealing with rendering a page, responding
    to a request, interacting with a database, loading an application, and more. In
    frameworks, the technical challenges extend beyond solving a particular technical
    problem. Instead, it is about creating a well-designed packaged system that can
    be beneficial for framework users to build their projects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 技术架构和模式主要处理技术挑战。对于JavaScript应用程序来说，这可能意味着处理页面渲染、响应请求、与数据库交互、加载应用程序等等。在框架中，技术挑战不仅限于解决特定技术问题。相反，它关于创建一个精心设计的包装系统，这对框架用户构建项目是有益的。
- en: To create this system, framework authors need to combine a set of packaged interfaces
    and a usable set of scripts and also use additional software to improve the JavaScript
    programming experience.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个系统，框架作者需要结合一组包装接口和一组可用的脚本，并使用额外的软件来改善JavaScript编程体验。
- en: 'While learning about the technical architecture, we are going to look at the
    three categories that enable the essential features of the framework. We are going
    to explore all the subcategories under these technical topics, as seen in *Figure
    3**.3*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习技术架构的过程中，我们将探讨三个类别，这些类别使得框架的基本功能得以实现。我们将探索这些技术主题下的所有子类别，正如在*图3*中所示。3*：
- en: '| **Packages** | **Scripts** | **Compilers** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **脚本** | **编译器** |'
- en: '| Core APIs | Binaries and executables | Framework compilers and bundlers |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 核心API | 二进制和可执行文件 | 框架编译器和打包器 |'
- en: '| Entry points | File generators | Types |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 入口点 | 文件生成器 | 类型 |'
- en: '| Developer tools |  | Source maps |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 开发者工具 |  | 源映射 |'
- en: '| Plugin and extension APIs |  |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 插件和扩展API |  |  |'
- en: 'Figure 3.3: Subcategories of the technical architecture'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：技术架构的子类别
- en: We will start with the core packages of the framework that enable substantial
    functionality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从框架的核心包开始，这些包能够提供强大的功能。
- en: Packages
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: Packages consist of the core logic of the framework, with public and private
    APIs. This directory can include any packages that are necessary for the framework
    to function. It consists of internal and public interfaces. It can also include
    a compiler or any building tools that are used as part of framework development
    or developer use cases. These include the core pieces that make the framework
    what it is. Depending on the framework, the packages can be functionally independent
    or rely on each other to function. In general, the packages part of the framework
    can consist of any related code that should be included as part of the framework,
    but there are several essential types of packages that today’s frameworks include.
    We are going to look at these in more detail in this section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 包包含框架的核心逻辑，以及公共和私有API。此目录可以包括框架运行所必需的任何包。它包括内部和公共接口。它还可以包括编译器或任何作为框架开发或开发者用例一部分使用的构建工具。这些是构成框架核心的部分。根据框架的不同，包可以是功能独立的，也可以相互依赖以实现功能。通常，框架的包部分可以包括任何应作为框架一部分包含的相关代码，但今天框架包括的包类型有几种基本类型。我们将在本节中更详细地探讨这些内容。
- en: Core APIs
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心API
- en: Depending on the framework, the “core” packages may consist of a variety of
    modules for providing public user-exposed interfaces and private interfaces to
    enable frameworks’ features. In [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030),
    we saw examples of public APIs provided by framework packages, such as router,
    event-management, template modules, and more. The core packages are usually structured
    similarly in both frontend and backend frameworks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据框架的不同，“核心”包可能包括各种模块，用于提供公共用户暴露的接口和私有接口以启用框架功能。在[*第二章*](B19014_02.xhtml#_idTextAnchor030)中，我们看到了框架包提供的公共API的示例，例如路由、事件管理、模板模块等。核心包在前后端框架中通常结构相似。
- en: Frontend frameworks enable `@vue/reactivity` ([npmjs.com/package/@vue/reactivity](http://npmjs.com/package/@vue/reactivity)).
    Reactivity is an important part of a framework feature set, and we are going to
    explore it further in later chapters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前端框架启用`@vue/reactivity`([npmjs.com/package/@vue/reactivity](http://npmjs.com/package/@vue/reactivity))。响应性是框架功能集的重要组成部分，我们将在后面的章节中进一步探讨它。
- en: '**Dependency injection** (**DI**) is at the core of some frameworks and allows
    modules within the framework and the application to declare their dependencies
    and use external interfaces. As part of DI, frameworks also have interfaces to
    declare dependency providers. You will find the use of DI in some frameworks,
    most famously in Angular. There is a guide and more details on Angular’s DI at
    [angular.io/guide/dependency-injection](http://angular.io/guide/dependency-injection).
    Due to the lack of interfaces and typing in JavaScript, the DI features are not
    as popular and are enabled through TypeScript or other compilers. You will also
    find injection features in Nest.js on the backend.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**(**DI**)是某些框架的核心，允许框架内和应用程序内的模块声明它们的依赖关系并使用外部接口。作为DI的一部分，框架也有接口来声明依赖提供者。你将在一些框架中找到DI的使用，最著名的是Angular。有关Angular的DI的指南和更多详细信息，请参阅[angular.io/guide/dependency-injection](http://angular.io/guide/dependency-injection)。由于JavaScript缺乏接口和类型，DI功能并不像TypeScript或其他编译器那样受欢迎，这些功能是通过TypeScript或其他编译器启用的。你也会在Nest.js的后端找到注入功能。'
- en: 'You will find a familiar pattern (as shown in the following code block) for
    DI in both Angular and Nest.js; the `@Injectable` decorator implementation is
    defined in one of the core packages of the framework at [github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts](http://github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在Angular和Nest.js中找到熟悉的DI模式（如下面的代码块所示）；`@Injectable`装饰器的实现定义在框架的核心包之一，在[github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts](http://github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts)：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another common core API is the `createRenderer()` API to do just that – you
    can learn more about it at [vuejs.org/api/custom-renderer.html](http://vuejs.org/api/custom-renderer.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的核心 API 是 `createRenderer()` API，用于执行上述操作——你可以在 [vuejs.org/api/custom-renderer.html](http://vuejs.org/api/custom-renderer.html)
    上了解更多信息。
- en: Full stack and backend frameworks provide a `@sveltejs/adapter-node` adapter.
    In addition, the framework provides several official adapters, specified at [kit.svelte.dev/docs/adapters](http://kit.svelte.dev/docs/adapters),
    that allow you to define adapters for maximum flexibility and compatibility with
    the deployment environment. It can also be the case that a frontend framework
    only uses a server as part of its internal components to enable development functionality,
    but in production use cases, developers would need to provide their own server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈和后端框架提供了一个 `@sveltejs/adapter-node` 适配器。此外，框架提供了几个官方适配器，具体请参阅 [kit.svelte.dev/docs/adapters](http://kit.svelte.dev/docs/adapters)，这些适配器允许你为最大灵活性和与部署环境的兼容性定义适配器。也可能出现这样的情况，即前端框架仅将其服务器作为其内部组件的一部分来启用开发功能，但在生产用例中，开发者需要提供自己的服务器。
- en: Source of the Svelte.js node.js adapter
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte.js node.js 适配器的来源
- en: The `chapter3` directory provides the source of the Svelte.js node.js adapter
    after it is extracted by the installation script. The framework uses this to consume
    code input and produce output in a framework-friendly manner.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装脚本提取之后，`chapter3` 目录提供了 Svelte.js node.js 适配器的源代码。框架使用这个源代码以框架友好的方式消费代码输入并生成输出。
- en: Often, all types of frameworks have a **shared package** that could consist
    of both public and private APIs. Usually, the most general logic, which is reused
    across many packages, goes into the shared package. Some contenders for the shared
    package could be code that is related to the runtime environment and the fundamentals.
    For example, this package can include utility functions, managing and escaping
    HTML entities, dealing with HTTP status codes, normalizing universal values across
    the whole framework, and storing constant values usable across the framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有类型的框架都有一个 **共享包**，可能包含公共和私有 API。通常，最通用的逻辑，在许多包中重复使用，会放入共享包中。共享包的竞争者可能包括与运行时环境和基础相关的代码。例如，这个包可以包括实用函数、管理并转义
    HTML 实体、处理 HTTP 状态码、在整个框架中规范化通用值，以及存储框架中可用的常量值。
- en: In the next section, we are going to look at the entry points of frameworks
    – that is, the glue that connects the core APIs with the start of framework execution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨框架的入口点——即连接核心 API 与框架执行开始的粘合剂。
- en: Entry points
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口点
- en: The primary way the framework’s users interact with the framework is through
    an *entry point*. This definition is very similar to an entry point of a simple
    program, and it is the place where the execution begins when we run a simple computer
    program. Depending on the framework’s abstractions and structure, this kind of
    entry point could be very different.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 框架用户与框架交互的主要方式是通过一个 *入口点*。这个定义与简单程序的入口点非常相似，并且是我们运行简单计算机程序时执行开始的地方。根据框架的抽象和结构，这种入口点可能会有很大差异。
- en: 'In frontend JavaScript frameworks, the concept of the entry point varies. These
    frameworks can be included via a `<script>` tag and later initialized on the page
    by calling the entry points. Angular has a root bootstrap module that is called
    upon to initialize the application, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端 JavaScript 框架中，入口点的概念有所不同。这些框架可以通过 `<script>` 标签包含，然后通过调用入口点在页面上进行初始化。例如，Angular
    有一个根引导模块，用于初始化应用程序：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `AppModule` root module is essential to initialize
    the application as it loads in the browser. It also defines the space to include
    top-level imports and service providers to enable external features in the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`AppModule` 根模块对于初始化应用程序至关重要，因为它在浏览器中加载。它还定义了包含顶层导入和服务提供者的空间，以在应用程序中启用外部功能。
- en: Ember.js uses a similar pattern by defining an instance of an `Application`
    class to instantiate a new application. This `Application` class extends the `Ember.Application`
    class and provides an object literal with configuration options. This object is
    used to configure the various components and features of the application. This
    entry point class is used to hold other classes of the application as developers
    further expand the features of their project. To get precise details on this `Application`
    class, check out the API documentation for it at [api.emberjs.com/ember/release/classes/Application](http://api.emberjs.com/ember/release/classes/Application).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 通过定义一个 `Application` 类的实例来实例化一个新的应用程序，使用类似的模式。这个 `Application` 类扩展了
    `Ember.Application` 类，并提供了带有配置选项的对象字面量。此对象用于配置应用程序的各种组件和功能。此入口点类用于在开发人员进一步扩展项目功能时持有应用程序的其他类。要获取关于此
    `Application` 类的精确细节，请查看其 API 文档，位于 [api.emberjs.com/ember/release/classes/Application](http://api.emberjs.com/ember/release/classes/Application)。
- en: Looking at SvelteKit as a different framework, due to the way it defines its
    abstractions, it relies on compiler and build tooling to be the initial entry
    point. The compiler detects the main `page.svelte` file in the root directory
    and treats that as an entry point to the index page of the application. Unlike
    Angular and Ember.js, this is a much less verbose entry point.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SvelteKit 视为一个不同的框架，由于它定义抽象的方式，它依赖于编译器和构建工具作为初始入口点。编译器检测根目录中的主 `page.svelte`
    文件，并将其视为应用程序索引页的入口点。与 Angular 和 Ember.js 不同，这是一个更加简洁的入口点。
- en: 'Another entry point example is the configuration file in Nuxt.js:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个入口点示例是 Nuxt.js 中的配置文件：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file is defined in the root of the project. It allows for framework configuration
    and extension and accepts a variety of options. All these possible options are
    available at [nuxt.com/docs/api/configuration/nuxt-config](http://nuxt.com/docs/api/configuration/nuxt-config).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义在项目根目录中。它允许进行框架配置和扩展，并接受各种选项。所有这些可能的选项都可以在 [nuxt.com/docs/api/configuration/nuxt-config](http://nuxt.com/docs/api/configuration/nuxt-config)
    中找到。
- en: In terms of pure backend frameworks, usually, the entry point is the bootstrap
    file that starts the server. As the server process boots up, it initializes the
    server configuration, such as properly binding the process to a particular port.
    This process is very well illustrated for *AdonisJs* as a state-changing machine
    at [docs.adonisjs.com/guides/application#boot-lifecycle](http://docs.adonisjs.com/guides/application#boot-lifecycle).
    This bootstrap is also similar to *NestJs* as the framework has a server-side
    `AppModule` that is used to bootstrap the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯后端框架方面，通常入口点是启动服务器的引导文件。随着服务器进程启动，它初始化服务器配置，例如正确地将进程绑定到特定端口。这个过程在 *AdonisJs*
    的 [docs.adonisjs.com/guides/application#boot-lifecycle](http://docs.adonisjs.com/guides/application#boot-lifecycle)
    中得到了很好的说明，它作为一个状态转换机。这个引导过程也与 *NestJs* 类似，因为框架有一个用于引导服务器的服务器端 `AppModule`。
- en: 'The following source code is for the Nest.js bootstrap script that initializes
    the application. It has to import `NestFactory` and `AppModule` as part of this
    process. `await listen` enables listening to incoming requests:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码是用于初始化应用程序的 Nest.js 引导脚本。在这个过程中，必须导入 `NestFactory` 和 `AppModule`。`await
    listen` 允许监听传入的请求：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This entry point file can work with environment variables to bootstrap the application
    on the desired port. The included `AppModule` file contains the additional modules
    defined by the user that will be loaded as the script starts. This pattern is
    prevalent in other frameworks too, such as Express.js and Hapi.js.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此入口点文件可以使用环境变量在所需的端口上引导应用程序。包含的 `AppModule` 文件包含用户定义的附加模块，这些模块将在脚本启动时加载。这种模式在其他框架中也很普遍，例如
    Express.js 和 Hapi.js。
- en: Developer tools
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者工具
- en: You may find sets of developer tools that make it easier to interact with the
    framework while you’re working on applications. These tools are intended to help
    with profiling, debugging, and other tasks. In frontend projects, these tools
    are often provided as browser extensions or standalone apps.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您可能会发现一些开发者工具集，这些工具可以使得与框架交互更加容易。这些工具旨在帮助进行性能分析、调试和其他任务。在前端项目中，这些工具通常以浏览器扩展或独立应用程序的形式提供。
- en: 'Vue.js provides well-integrated tools as part of its workflows through browser
    and standalone tooling. It allows us to quickly understand the application structure
    and further debug the output of the application. *Figure 3**.4* shows an example
    of the tools in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js通过浏览器和独立工具作为其工作流程的一部分提供了一些集成良好的工具。它允许我们快速了解应用程序结构，并进一步调试应用程序的输出。*图3.4*显示了这些工具在行动中的示例：
- en: '![Figure 3.4: Vue.js browser developer tools](img/Figure_3.4_B19014.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：Vue.js浏览器开发者工具](img/Figure_3.4_B19014.jpg)'
- en: 'Figure 3.4: Vue.js browser developer tools'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：Vue.js浏览器开发者工具
- en: 'Frontend frameworks provide some good examples of developer tooling, mostly
    as browser extensions but sometimes as standalone applications to decouple away
    from browser workflow:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前端框架提供了一些开发者工具的好例子，大多数是作为浏览器扩展，有时作为独立应用程序来解耦浏览器工作流程：
- en: '**Angular DevTools** ([angular.io/guide/devtools](http://angular.io/guide/devtools)):
    These tools provide profiling capabilities and debugging features. It renders
    the component tree, similar to what’s shown in *Figure 3**.4* in Vue.js.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular DevTools** ([angular.io/guide/devtools](http://angular.io/guide/devtools)):
    这些工具提供了性能分析能力和调试功能。它渲染组件树，类似于Vue.js中*图3.4*所示的内容。'
- en: '**Vue.js DevTools** ([github.com/vuejs/devtools](http://github.com/vuejs/devtools)):
    As shown in *Figure 3**.4*, it provides a detailed component tree with search
    as well as a route list that helps debug the router configuration. It also enables
    the timeline view to show a history of interaction with a Vue.js application.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vue.js DevTools** ([github.com/vuejs/devtools](http://github.com/vuejs/devtools)):
    如*图3.4*所示，它提供了一个详细的组件树，带有搜索功能，以及一个路由列表，有助于调试路由配置。它还启用了时间线视图，以显示与Vue.js应用程序的交互历史。'
- en: '**Ember Inspector** ([guides.emberjs.com/release/ember-inspector](http://guides.emberjs.com/release/ember-inspector)):
    This tooling provides an extensive number of features. It provides a way to explore
    Ember objects, the component tree, routing, data views, and more.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ember检查器** ([guides.emberjs.com/release/ember-inspector](http://guides.emberjs.com/release/ember-inspector)):
    这套工具提供了大量的功能。它提供了一种探索Ember对象、组件树、路由、数据视图等功能的方式。'
- en: '**React Developer Tools** ([beta.reactjs.org/learn/react-developer-tools](http://beta.reactjs.org/learn/react-developer-tools)):
    These tools allow you to inspect components, edit live properties of components,
    and modify the state.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React开发者工具** ([beta.reactjs.org/learn/react-developer-tools](http://beta.reactjs.org/learn/react-developer-tools)):
    这些工具允许您检查组件，编辑组件的实时属性，并修改状态。'
- en: '**SolidJS Developer Tools** ([github.com/thetarnav/solid-devtools](http://github.com/thetarnav/solid-devtools)):
    These tools visualize and add the ability to interact with the SolidJS reactivity
    graph. Like other tools, it can inspect the component state and navigate the tree.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SolidJS开发者工具** ([github.com/thetarnav/solid-devtools](http://github.com/thetarnav/solid-devtools)):
    这些工具可视化和增加了与SolidJS响应式图交互的能力。与其他工具一样，它可以检查组件状态并导航树。'
- en: An interesting challenge you can consider while supporting developer tools in
    your frameworks is keeping up with framework updates. Vue.js DevTools approaches
    this problem by targeting the major version of a framework – it defines a package
    for each version, such as `app-backend-vue1`, `app-backend-vue2`, `app-backend-vue3`,
    and so on. Given that most of the time, these are browser extensions, they have
    a similar architecture for utilizing the `DevTool` extension browser APIs ([developer.chrome.com/docs/extensions/mv3/devtools](http://developer.chrome.com/docs/extensions/mv3/devtools)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的框架中支持开发者工具时，可以考虑的一个有趣挑战是跟上框架的更新。Vue.js DevTools通过针对框架的主要版本来解决这个问题——它为每个版本定义了一个包，例如`app-backend-vue1`、`app-backend-vue2`、`app-backend-vue3`等等。鉴于这些通常是浏览器扩展，它们在利用`DevTool`扩展浏览器API方面具有类似的架构（[developer.chrome.com/docs/extensions/mv3/devtools](http://developer.chrome.com/docs/extensions/mv3/devtools)）。
- en: You may notice the lack of additional developer tools for backend frameworks.
    In those cases, developers rely on debuggers, such as a text editor or an IDE,
    as their tools of choice. We looked at Node.js application and framework debugging
    in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030) while debugging a Nest.js application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到后端框架缺少额外的开发者工具。在这些情况下，开发者依赖于调试器，如文本编辑器或IDE，作为他们选择的工具。我们在调试Nest.js应用程序时，研究了[*第2章*](B19014_02.xhtml#_idTextAnchor030)中的Node.js应用程序和框架调试。
- en: In framework development, introducing additional specific developer tools is
    not a necessary step at first. However, it makes the framework much more pleasant
    to work with and empowers its users. These days, JavaScript runtime environments
    generally have great tooling that helps with development no matter what framework
    you use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Plugin and extension APIs
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many instances, the packages provided by frameworks also enable extensibility.
    This kind of extensibility enables plugin and extension development, benefiting
    the framework in many ways. The provided API empowers other developers to customize
    the functionality and add new capabilities focused on the specific needs of the
    applications. It also allows the framework to stay focused on delivering the main
    feature set and not include every potential feature in the framework’s core.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'This extensibility may be useful as part of internal development, where framework
    authors can create adapters and interfaces based on the extension interface. It
    can also be useful for external use cases, where developers outside of the core
    development team can create features for specific use cases that plug into the
    framework. Let’s take a look at some examples of plugin interfaces that are provided
    by the frameworks we looked at in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrap** ([https://getbootstrap.com/docs/5.0/extend/approach/](https://getbootstrap.com/docs/5.0/extend/approach/))
    has documentation that consists of the guiding principles to create customizable
    components that work well with its core functionality. For this project, developers
    defined a set of rules that serve as the guideline.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ember install <addon>`. It has a full section that supports add-on development
    as part of its documentation. For example, must-have functionality for most applications,
    such as authentication, is provided via the `Ember Simple Auth` add-on ([ember-simple-auth.com](http://ember-simple-auth.com)).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install` function that executes the plugin logic.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng` command-line tooling, developers can quickly generate these new libraries.
    As part of the library’s workflow, the new modules get published to *npm* for
    others to use.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gatsby** ([gatsbyjs.com/docs/plugins](http://gatsbyjs.com/docs/plugins))
    has several plugins and very good documentation that enables their development.
    It provides workflows to develop generic plugins for any use, local plugins specific
    to a single project, and transformer plugins that convert data between types.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SolidJS** ([solidjs.com/ecosystem](http://solidjs.com/ecosystem)) defines
    an ecosystem of add-ons to fit different purposes. Developers can choose from
    a variety of UI, router, data, and general add-on plugin categories. The most
    popular category is the user interface additions, which make it easier to approach
    various web application layouts and widgets.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Svelte** ([sveltesociety.dev/tools](http://sveltesociety.dev/tools)) has
    a set of tools that are developed to improve the bundling, debugging, and editor
    experience.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Svelte** ([sveltesociety.dev/tools](http://sveltesociety.dev/tools)) 拥有一套旨在提高打包、调试和编辑体验的工具集。'
- en: '**Hapi.js** ([hapi.dev/tutorials/plugins](http://hapi.dev/tutorials/plugins))
    provides a powerful interface to extend the server-side functionality of the framework.
    The plugins have a fairly simple interface, where an asynchronous function is
    used to register and perform any additional extended functionality.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hapi.js** ([hapi.dev/tutorials/plugins](http://hapi.dev/tutorials/plugins))
    提供了一个强大的接口来扩展框架的服务端功能。插件具有相当简单的接口，其中使用异步函数来注册和执行任何额外的扩展功能。'
- en: '**AdonisJS** ([packages.adonisjs.com](http://packages.adonisjs.com)) provides
    “packages” that extend functionality. To speed up package development, Adonis
    uses an **MRM** code modification preset, which can be found at [github.com/adonisjs/mrm-preset](http://github.com/adonisjs/mrm-preset).
    It allows you to quickly scaffold packages for its framework.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AdonisJS** ([packages.adonisjs.com](http://packages.adonisjs.com)) 提供了扩展功能的“包”。为了加快包的开发速度，Adonis
    使用了 **MRM** 代码修改预设，可以在 [github.com/adonisjs/mrm-preset](http://github.com/adonisjs/mrm-preset)
    找到。它允许你快速为其框架搭建包的脚手架。'
- en: From the examples we just discussed, you can hopefully see that as part of writing
    your framework, it is good to enable this kind of extensibility. It will help
    the framework grow and benefit all those who are involved in your framework’s
    ecosystem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚才讨论的例子中，你可能会希望看到，在编写你的框架时，启用这种类型的可扩展性是很好的。这将有助于框架的成长，并使所有参与你框架生态系统的人受益。
- en: In the next section, we’ll explore the variety of scripts that help administer
    today’s frameworks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨各种脚本，这些脚本有助于管理当今的框架。
- en: Scripts
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: Every framework needs to be able to perform tasks on behalf of its users, and
    for those building the framework as well, this is where the architecture requires
    the introduction of various scripts and programs that can perform those day-to-day
    tasks. These scripts often help developers be more efficient and eliminate redundant
    tasks. Well-defined powerful scripts can also make the framework very pleasant
    to use. In this section, we are going to take a look at binaries and executables
    that are shipped with the framework, file generators, and other popular tooling
    within frameworks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架都需要能够代表其用户执行任务，对于构建框架的人来说也是如此，这就是架构需要引入各种脚本和程序来执行日常任务的地方。这些脚本通常有助于开发者提高效率并消除重复性任务。定义良好的强大脚本也可以使框架非常易于使用。在本节中，我们将查看框架附带的可执行二进制文件、文件生成器以及其他框架内流行的工具。
- en: Binaries and executables
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制文件和可执行文件
- en: Binaries and script files help with framework development and sometimes serve
    as an interface for users of the framework. These scripts can include build steps,
    automation, and other JavaScript-related tasks. In some cases, these can be helper
    scripts or can be run consistently as part of the coding process. Often, these
    are written in JavaScript/TypeScript to ensure cross-platform execution and to
    keep the workflow consistent with the same language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件和脚本文件有助于框架开发，有时也作为框架用户的接口。这些脚本可以包括构建步骤、自动化和其他与 JavaScript 相关的任务。在某些情况下，这些可以是辅助脚本，也可以作为编码过程的一部分持续运行。通常，这些是用
    JavaScript/TypeScript 编写的，以确保跨平台执行并保持与同一语言的流程一致性。
- en: 'Today’s frameworks have various executable tasks, and you may find short `npm`
    commands or full-fledged script files. These executables can be used for the following
    purposes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的框架具有各种可执行任务，你可能会发现简短的 `npm` 命令或完整的脚本文件。这些可执行文件可用于以下目的：
- en: '**Building and publishing**: This involves releasing new versions of the framework.
    At the beginning of this chapter, in the *Exploring the core architecture* section,
    we saw examples of multiple framework versions that are generated based on the
    same source. This is where a good build script that also updates the change log
    file and creates source version tags can be handy. This workflow can also involve
    generating static assets and uploading framework artifacts. A simple example of
    this can be found in Ember.js ([github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js](http://github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js)).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和发布**：这涉及到发布框架的新版本。在本章的开头，在 *探索核心架构* 部分中，我们看到了基于相同源生成的多个框架版本示例。这里，一个良好的构建脚本可以更新变更日志文件并创建源版本标签，这会很有用。此工作流程还可以涉及生成静态资产和上传框架工件。一个简单的例子可以在
    Ember.js 中找到 ([github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js](http://github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js))。'
- en: '**Full test runner**: An executable to run tests or other test integrations.
    Frameworks have many types of tests, and it is often important to create a script
    that can set up the test environment and swiftly execute all or just the needed
    tests.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整的测试运行器**：一个可执行文件，用于运行测试或其他测试集成。框架有许多类型的测试，通常创建一个可以设置测试环境并快速执行所有或所需测试的脚本非常重要。'
- en: '**Development workflow**: A script to quickly get started with the development
    of the framework. Usually, this includes starting a JavaScript bundler, a file
    watcher, and sometimes a development server.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发工作流程**：一个用于快速开始框架开发的脚本。通常，这包括启动 JavaScript 打包器、文件监视器和有时是开发服务器。'
- en: '**Managing dependencies**: Here, you can install and rebuild dependencies.
    Given that a lot of the parts of the framework can be in separate packages or
    repositories, it becomes much more efficient to automate the dependency management
    process.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理依赖项**：在这里，你可以安装和重新构建依赖项。鉴于框架的许多部分可能位于单独的包或存储库中，自动化依赖项管理过程变得更加高效。'
- en: '**Linting and code coverage**: Similar to the test runner, linting and code
    coverage ensure good code quality standards. These tools analyze the source code
    and track down abnormal usages of the language. Code coverage tools ensure that
    tests run through all paths of a framework’s code.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码风格检查和代码覆盖率**：与测试运行器类似，代码风格检查和代码覆盖率确保良好的代码质量标准。这些工具分析源代码并追踪语言的不正常使用。代码覆盖率工具确保测试运行通过框架代码的所有路径。'
- en: JavaScript frameworks use the scripts field of `package.json` ([docs.npmjs.com/cli/using-npm/scripts](http://docs.npmjs.com/cli/using-npm/scripts))
    to define a set of common scripts. In the existing frameworks, you may find that
    the list of scripts defined in that field can be very large – Vue.js, for example,
    has over 30 script commands defined in the core package file. Angular created
    a tool called `ng-dev` ([github.com/angular/dev-infra/tree/main/ng-dev](http://github.com/angular/dev-infra/tree/main/ng-dev))
    to manage all development tasks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 框架使用 `package.json` 的脚本字段 ([docs.npmjs.com/cli/using-npm/scripts](http://docs.npmjs.com/cli/using-npm/scripts))
    来定义一组常用脚本。在现有的框架中，你可能会发现该字段中定义的脚本列表可能非常庞大——例如，Vue.js 在核心包文件中定义了超过 30 个脚本命令。Angular
    创建了一个名为 `ng-dev` 的工具 ([github.com/angular/dev-infra/tree/main/ng-dev](http://github.com/angular/dev-infra/tree/main/ng-dev))
    来管理所有开发任务。
- en: 'AdonisJS ([github.com/adonisjs/core/blob/develop/package.json](http://github.com/adonisjs/core/blob/develop/package.json))
    has a fairly short script list that also serves as a good example of possible
    scripts a framework may require. Here, we can see examples of the publishing workflow,
    testing, linting, and more:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AdonisJS ([github.com/adonisjs/core/blob/develop/package.json](http://github.com/adonisjs/core/blob/develop/package.json))
    拥有一份相当短的脚本列表，同时也很好地展示了框架可能需要的脚本示例。在这里，我们可以看到发布工作流程、测试、代码风格检查等示例：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some of these scripts are shortcuts, such as the `clean` task, and call out
    to another tool to perform the action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些脚本是一些快捷方式，例如`clean`任务，并调用其他工具执行操作。
- en: As part of building your framework, it is a good idea to identify the common
    tasks you perform while working on the framework and publishing new releases.
    Once you do that, create a series of well-defined scripts for those tasks. This
    will result in a much more organized and pleasant development workflow.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的框架的过程中，确定你在框架开发和新版本发布时执行的一些常见任务是一个好主意。一旦你做到了这一点，为这些任务创建一系列定义良好的脚本。这将导致一个更加组织和愉快的开发工作流程。
- en: File generators
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件生成器
- en: You will often find that tools are provided to generate code for common components
    of a project. Usually, these “generate” the necessary skeleton files that can
    be later modified by the developer to add custom business logic. If you add this
    kind of scaffolding functionality to your framework, then it will allow developers
    to reduce the repetition of code written by hand and save time by preventing unexpected
    errors from being introduced by manually writing parts of the project. Commonly,
    the generators also create test files and configure the test runner, which is
    another time saver. These generator commands are often bundled with the framework
    and provided by a command-line interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现，工具被提供出来以生成项目的常见组件的代码。通常，这些工具“生成”必要的骨架文件，开发者可以稍后修改这些文件以添加自定义的业务逻辑。如果你将这种脚手架功能添加到你的框架中，那么它将允许开发者减少手动编写的代码重复，并通过防止手动编写项目部分时引入意外错误来节省时间。通常，生成器还会创建测试文件并配置测试运行器，这又是节省时间的一个方面。这些生成器命令通常与框架捆绑在一起，并通过命令行界面提供。
- en: JavaScript frameworks employ this generator pattern by allowing the application
    to be scaffolded or allowing developers to scaffold additional components as the
    project progresses. For example, Angular generates code using schematics ([angular.io/guide/schematics](http://angular.io/guide/schematics)).
    It has built-in schematics for its entities but also allows developers to author
    their own schematics. With this **Schematics API**, you can create custom tasks
    to perform on the application project, including the ability to fully manipulate
    the files and directories.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 框架通过允许应用程序被脚手架或允许开发者在项目进展过程中构建额外的组件来采用这种生成器模式。例如，Angular 使用图表（[angular.io/guide/schematics](http://angular.io/guide/schematics)）来生成代码。它为其实体内置了图表，但也允许开发者编写自己的图表。通过这个
    **Schematics API**，你可以创建自定义任务来在应用程序项目中执行，包括完全操作文件和目录的能力。
- en: 'In another instance, Next.js offers an application scaffolding tool called
    `create-next-app` ([github.com/vercel/next.js/tree/canary/packages/create-next-app](http://github.com/vercel/next.js/tree/canary/packages/create-next-app)),
    which allows framework users to quickly get started building an application with
    Next.js:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，Next.js 提供了一个名为 `create-next-app` 的应用程序脚手架工具（[github.com/vercel/next.js/tree/canary/packages/create-next-app](http://github.com/vercel/next.js/tree/canary/packages/create-next-app)），它允许框架用户快速开始使用
    Next.js 构建应用程序：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Next.js generator is built using common JavaScript modules and just like
    many web frameworks, it utilizes Node.js for this type of tooling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 生成器是使用常见的 JavaScript 模块构建的，就像许多网络框架一样，它利用 Node.js 来实现这类工具。
- en: Depending on how you intend your framework to be used, you will have to choose
    what kind of generator functionality you want to provide. If your framework is
    part of a large internal project and is often not used to create new application
    projects, then a schematic-like Angular approach would be more suitable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你打算如何使用你的框架，你必须选择你想要提供的生成器功能类型。如果你的框架是大型内部项目的一部分，并且通常不用于创建新的应用程序项目，那么类似于 Angular
    的图表方法会更合适。
- en: In [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we saw that many of the
    frameworks, such as Gatsby, are static site generators. This is another use case
    where a framework can rely on site generators based on some file generation tooling.
    This pattern can benefit in the same manner as with any generator – abstract away
    complexity, eliminate repetitive tasks, and reduce maintenance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](B19014_01.xhtml#_idTextAnchor015) 中，我们看到了许多框架，如 Gatsby，都是静态站点生成器。这是一个框架可以依赖于基于某些文件生成工具的站点生成器的另一个用例。这种模式可以以与任何生成器相同的方式受益——抽象复杂性，消除重复性任务，并减少维护。
- en: Compilers
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器
- en: In general computing, a compiler translates some type of source code into another
    target source code. JavaScript puts quite a twist on this with a huge number of
    compiler tools available, with many of these tools approaching the challenges
    of web development in different ways while adapting to the latest architectural
    trends. As years go by, more and more frameworks are using some sort of compiler
    for development purposes, enabling these projects to cherish the benefits of these
    tools. In this section, we are going to cover some examples that are used in frameworks
    today.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般计算中，编译器将某种类型的源代码转换为另一种目标源代码。JavaScript 在这个方面有很多不同的编译器工具，其中许多工具以不同的方式应对 Web
    开发的挑战，同时适应最新的架构趋势。随着时间的推移，越来越多的框架开始使用某种类型的编译器进行开发，使这些项目能够享受到这些工具的好处。在本节中，我们将介绍一些目前在框架中使用的示例。
- en: The development improvements and the workflows that these tools enable vastly
    benefit framework developers. When you are creating a new JavaScript framework,
    you will most certainly appreciate utilizing these tools.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具带来的开发改进和工作流程极大地造福了框架开发者。当您创建一个新的 JavaScript 框架时，您一定会欣赏利用这些工具。
- en: Framework compiler and builders
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架编译器和构建器
- en: 'The framework structure is usually assembled with a build tool. The goal of
    this step is to take all the necessary assets of the framework, perform specific
    optimizations on them, and output a developer-friendly bundle of code that targets
    a characteristic runtime environment. A JavaScript framework often uses such a
    tool as its build system. As part of this section, we’ll examine some of the possible
    compiler and bundler options:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 框架结构通常是通过构建工具组装的。这一步骤的目标是获取框架所需的所有资源，对它们进行特定的优化，并输出一个针对特定运行时环境的、开发者友好的代码包。JavaScript
    框架通常使用此类工具作为其构建系统。在本节中，我们将探讨一些可能的编译器和打包器选项：
- en: '`tsc` is the binary that can be invoked to build and analyze TypeScript files
    and turn them into JavaScript files.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsc` 是一个二进制文件，可以用来构建和分析 TypeScript 文件，并将它们转换为 JavaScript 文件。'
- en: '**Webpack**: This is a bundler compiler that can multiplex JavaScript and other
    web development-related files. Due to its popularity and extensive features, webpack
    has support for many advanced development features.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webpack**：这是一个可以将 JavaScript 和其他与 Web 开发相关的文件进行多路复用的打包编译器。由于其流行和丰富的功能，Webpack
    支持许多高级开发特性。'
- en: '**Turbopack**: A Webpack successor written by its authors in Rust, Go, and
    TypeScript, Turbopack consists of a bundler and an incremental build system. Similar
    to Webpack, the Turbo toolchain focuses on bundling your development assets into
    an optimized bundle. Turbo uses the Rust programming language to achieve faster
    builds, especially for larger projects.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Turbopack**：这是由 Webpack 的作者用 Rust、Go 和 TypeScript 编写的 Webpack 后继者，它由一个打包器和增量构建系统组成。与
    Webpack 类似，Turbopack 工具链专注于将您的开发资源打包成优化的包。Turbopack 使用 Rust 编程语言来实现更快的构建，特别是对于大型项目。'
- en: '**esbuild**: Written in the Go programming language, this tool parallelizes
    the workload to create JavaScript bundles.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**esbuild**：这是一个用 Go 编程语言编写的工具，它通过并行化工作负载来创建 JavaScript 包。'
- en: '**Babel**: This is a toolchain for transforming and generating new JavaScript
    syntax into compatible old syntax while focusing on cross-browser support and
    support for various JavaScript environments. You can include it in the build pipeline
    of your framework to make it functional and testable in older browsers.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel**：这是一个用于转换和生成新 JavaScript 语法到兼容旧语法的工具链，同时专注于跨浏览器支持和各种 JavaScript 环境的支持。您可以将它包含在框架的构建管道中，使其在旧浏览器中也能运行和测试。'
- en: '**rollup**: A module bundler for creating optimized bundles of JavaScript,
    it has a large ecosystem of configurations and plugins. It is very suitable for
    framework use due to its low overhead and output flexibility.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rollup**：这是一个用于创建优化后的 JavaScript 包的模块打包器，它拥有庞大的配置和插件生态系统。由于其低开销和输出灵活性，它非常适合框架使用。'
- en: '**Parcel**: This is a bundler tool that focuses on zero or minimal configuration.
    Parcel ships many built-in optimizations and automatically applies transforms
    for popular source types into JavaScript. Parcel can be used to produce optimized
    application bundles consisting of both business logic and framework code.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parcel**：这是一个专注于零配置或最小配置的打包工具。Parcel 集成了许多内置优化，并自动将流行的源类型转换为 JavaScript。Parcel
    可以用来生成包含业务逻辑和框架代码的优化后的应用程序包。'
- en: '**Speedy Web Compiler** (**SWC**): This is based on the Rust programming language,
    and its focus is to speed up the TypeScript compiling step. It’s used by Next.js
    and the **fresh** framework.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速 Web 编译器**（**SWC**）：这是基于 Rust 编程语言，其重点是加快 TypeScript 编译步骤。它被 Next.js 和
    **fresh** 框架使用。'
- en: 'Jest – a testing framework that we mentioned in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015)
    – uses Babel to build the testing framework itself. As the framework user, you
    can also opt-in to specific JavaScript targets by tweaking the Babel environment
    configuration via `babel.config.js`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Jest – 我们在 [*第 1 章*](B19014_01.xhtml#_idTextAnchor015) 中提到的测试框架 – 使用 Babel 构建测试框架本身。作为框架用户，你也可以通过调整
    `babel.config.js` 中的 Babel 环境配置来选择特定的 JavaScript 目标：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preset in the preceding code block allows Jest to run in the React Native
    environment, which is different from usual JavaScript application runtimes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块中的预设允许 Jest 在 React Native 环境中运行，这与常规的 JavaScript 应用程序运行时不同。
- en: 'The framework compiler can be the core piece of technology as it enables all
    the main features of the system. Svelte-based applications use the Svelte compiler,
    which takes a `.svelte` file and outputs JavaScript files:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 框架编译器可以是核心技术的一部分，因为它使系统的所有主要功能成为可能。基于 Svelte 的应用程序使用 Svelte 编译器，它接受 `.svelte`
    文件并输出 JavaScript 文件：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given a basic script, the JavaScript output that’s produced includes the required
    Svelte dependencies and the initialized `SvelteComponent`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个基本的脚本，生成的 JavaScript 输出包括所需的 Svelte 依赖项和初始化的 `SvelteComponent`：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding generated code is the compiler output and moves the instance of
    `console.log` to the instance function. After compilation, the script tag is removed,
    and the code is wrapped into an `instance` function, which executes the code as
    part of the `App` component. This becomes the entry point to an application that’s
    powered by Svelte. Svelte is capable of parsing CSS styling blocks and HTML-like
    syntax. More examples of the compiler in action can be found at [svelte.dev/examples](http://svelte.dev/examples).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述生成的代码是编译器输出，将 `console.log` 的实例移动到实例函数中。编译后，script 标签被移除，代码被包装在一个 `instance`
    函数中，该函数作为 `App` 组件的一部分执行代码。这成为由 Svelte 驱动的应用程序的入口点。Svelte 能够解析 CSS 样式块和类似 HTML
    的语法。更多编译器在行动的示例可以在 [svelte.dev/examples](http://svelte.dev/examples) 找到。
- en: If the framework uses a compiler that converts from statically typed code, then
    you may need to define and expose the defined types. In the next section, we will
    explore how that works.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果框架使用将静态类型代码转换为的编译器，那么你可能需要定义和公开定义的类型。在下一节中，我们将探讨它是如何工作的。
- en: Types
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: Exporting and building with a type system is another part of framework architecture
    and has become more and more popular in the modern JavaScript workflow. We have
    seen many frameworks utilize TypeScript for their architecture. TypeScript provides
    several options to organize these interfaces and types. It defines the implementation
    in `.ts` files and the declaration files in `.d.ts` files. As part of this architecture,
    the framework declares its TypeScript types for its internal and external files.
    The external types are available for the framework consumers as part of the documentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型系统进行导出和构建是框架架构的另一个部分，并且在现代 JavaScript 工作流程中变得越来越流行。我们已经看到许多框架利用 TypeScript
    进行其架构。TypeScript 提供了多种选项来组织这些接口和类型。它定义实现为 `.ts` 文件，声明文件为 `.d.ts` 文件。作为此架构的一部分，框架声明其
    TypeScript 类型以供其内部和外部文件使用。外部类型作为文档的一部分提供给框架消费者。
- en: 'The frameworks provide their type declarations as part of their published package.
    For example, the whole of the Solid.js framework is typed ([solidjs.com/guides/typescript](http://solidjs.com/guides/typescript)),
    just like many other projects, and includes the `types` directory when it is installed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 框架将其类型声明作为其发布包的一部分提供。例如，整个 Solid.js 框架都是类型化的([solidjs.com/guides/typescript](http://solidjs.com/guides/typescript))，就像许多其他项目一样，并且在安装时包含
    `types` 目录：
- en: '![Figure 3.5: Provided type declaration in Solid.js](img/Figure_3.5_B19014.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：Solid.js 中提供的类型声明](img/Figure_3.5_B19014.jpg)'
- en: 'Figure 3.5: Provided type declaration in Solid.js'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：Solid.js 中提供的类型声明
- en: '*Solid* distributes the type definitions as part of the `npm` package, providing
    specific definitions for the server, renderer, and reactive interface.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*Solid* 将类型定义作为 `npm` 包的一部分分发，为服务器、渲染器和反应式接口提供特定的定义。'
- en: In the next section, we are going to look at source maps, another type of compiled
    file that gets distributed with frameworks for the benefit of the development
    workflow.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨源映射，这是另一种与框架一起分发的编译文件，旨在提高开发工作流程的效率。
- en: Source maps
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源映射
- en: The concept of `.map` file extension. These maps are often created as part of
    some compilation or build process, hence why we’ll learn about them in this section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`.map`文件扩展名的概念。这些映射通常作为某些编译或构建过程的一部分被创建，因此我们将在这部分学习它们。
- en: '*Figure 3**.6* shows a snippet of a generated source map, though much of it
    is not humanly-readable:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.6* 展示了生成的源映射的一个片段，尽管其中大部分内容对人类来说难以阅读：'
- en: '![Figure 3.6: Generated source map of Angular’s core.js file](img/Figure_3.6_B19014.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：Angular的core.js文件生成的源映射](img/Figure_3.6_B19014.jpg)'
- en: 'Figure 3.6: Generated source map of Angular’s core.js file'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：Angular的core.js文件生成的源映射
- en: Here, we can see that the generated map is using the third version of the specification;
    the rest of the map is meant to be parsed by web-browser tooling that can process
    most of this file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到生成的映射正在使用规范的第三版；映射的其余部分旨在由能够处理大部分此文件的Web浏览器工具进行解析。
- en: As part of the published releases of frontend frameworks, the map files are
    provided as part of the framework bundle and it is up to developers to decide
    what to do with these files. The whole project can make the source maps available
    when the project is deployed into development environments. For example, Vue.js
    uses *esbuild* to bundle its code in development environments and *rollup* in
    production builds. As part of the build process, it can pass an option to both
    of these utilities to generate a source map for the output file. More about this
    feature in *esbuild* can be found at [esbuild.github.io/api/#sourcemap](http://esbuild.github.io/api/#sourcemap).
    Internally, *esbuild* uses the Go programming language to quickly build JavaScript
    projects and it has a source map specification implementation in its repository
    at [github.com/evanw/esbuild/tree/main/internal/sourcemap](http://github.com/evanw/esbuild/tree/main/internal/sourcemap).
    This is just one of the implementations, depending on how you decide to structure
    your framework. You will be able to find many ways to generate the source maps
    for your project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前端框架发布版本的一部分，映射文件作为框架包的一部分提供，开发者需要决定如何处理这些文件。当项目部署到开发环境时，整个项目可以使源映射可用。例如，Vue.js在开发环境中使用*esbuild*来打包其代码，在生产构建中使用*rollup*。作为构建过程的一部分，它可以为这两个实用工具传递一个选项来为输出文件生成源映射。关于*esbuild*的更多功能信息可以在[esbuild.github.io/api/#sourcemap](http://esbuild.github.io/api/#sourcemap)找到。内部，*esbuild*使用Go编程语言快速构建JavaScript项目，并在其[github.com/evanw/esbuild/tree/main/internal/sourcemap](http://github.com/evanw/esbuild/tree/main/internal/sourcemap)仓库中实现了源映射规范。这只是其中一种实现方式，具体取决于你如何决定构建你的框架。你将能够找到许多为你的项目生成源映射的方法。
- en: Source maps are utilized in server-side JavaScript as well. Due to the increased
    use of abstracted ways of writing JavaScript, the source map feature in Node.js
    can help you trace back to the original code, which could have been written in
    ClojureScript, TypeScript, or another language.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射同样在服务器端JavaScript中得到了应用。由于JavaScript抽象化编写方式的增加，Node.js中的源映射功能可以帮助你追踪回原始代码，这些代码可能是用ClojureScript、TypeScript或其他语言编写的。
- en: Usually, it is not that difficult to enable source map support in your framework.
    However, you need to make sure you configure it properly, making sure that the
    web browser tools can actually use the map properly and only expose the source
    map when it is applicable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在你的框架中启用源映射支持并不困难。然而，你需要确保你正确地配置了它，确保网络浏览器工具能够正确地使用映射，并且仅在适用时才暴露源映射。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter focused on the technical architectural structure of JavaScript
    frameworks. We focused on the three important parts of framework architecture:
    packages, scripts, and compilers. Combining this with the knowledge we gained
    from *Chapters 1* and *2*, we can start pinpointing the core differences in how
    various frameworks have their architectures structured. Having an overview of
    architectural patterns helps us understand how existing frameworks are formulated
    and makes it easier for us to build new frameworks.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了 JavaScript 框架的技术架构结构。我们关注了框架架构的三个重要部分：包（packages）、脚本（scripts）和编译器（compilers）。结合我们从第
    1 章和第 2 章中获得的知识，我们可以开始精确地指出各种框架在架构结构上的核心差异。对架构模式的概述有助于我们理解现有框架是如何构建的，并使得我们构建新的框架变得更加容易。
- en: Exploring established projects helps us borrow the best ideas from existing
    open source frameworks. In addition, learning the internal designs provides insight
    into how the frameworks fit into complex code bases that utilize a framework.
    The next chapter will look at development support techniques and patterns that
    make framework development and usability even better.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 探索现有的项目有助于我们从现有的开源框架中借鉴最佳想法。此外，学习内部设计可以深入了解框架如何适应使用框架的复杂代码库。下一章将探讨使框架开发和可用性更加完善的开发支持技术和模式。
