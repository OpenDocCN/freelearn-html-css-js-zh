- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a Cut Scene and Handling Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the work we’ve completed so far has contributed to the whole largely
    unseen and unheard. The only action we’ve required – or even listened for – from
    users is a single button click. How boring – and quiet. That’s all about to change,
    though! In this chapter, we’re going to add some flavor to our app’s launch by
    adding a Splash Screen that tells the world that everything they’re about to see
    is “Powered by Babylon.js” in the process of providing players with their first
    experience with Space-Truckers. We’ll also be giving users agency in the game
    world by adding inputs for multiple different device types, along with the logic
    to process inputs into actions in the game.
  prefs: []
  type: TYPE_NORMAL
- en: This seems like a lot to cover in such a short chapter, but thanks to how easy
    it can be to accomplish tasks in Babylon.js, progress can come faster than you
    might think.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Space-Truckers – the Splash Screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the Input System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything we’ll be doing will build from the work we’ve done in previous chapters,
    but it’s OK if you’re just picking things up from here – read on for technical
    details on how to obtain the source code to complete this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the first time that we’re going to be expanding the technical requirements,
    but it should hardly be a surprise to anyone that to work with a particular type
    of input device – be it a mouse and keyboard, Xbox™ controller, Sony PlayStation™
    controller, or even a VR joystick – it is necessary to either have one of such
    devices handy or (worst case) download and install a suitable emulator/simulation
    app. That said, Space-Truckers should be playable with the following input types:'
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard and mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual joysticks/touch screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xbox™ controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sony PlayStation™ controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic gamepads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An appropriate audio output device will be needed to play music and sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will follow a similar pattern as previous chapters, where we will
    build out one or more PlayGround snippets before integrating them into the application’s
    code base. The code we’ll be starting from is at [https://github.com/jelster/space-truckers/tree/ch4](https://github.com/jelster/space-truckers/tree/ch4)
    if you want a reference point or a place from where you can start your journey.
    Now, with that squared away, we can turn our full attention to our first task:
    building the Splash Screen!'
  prefs: []
  type: TYPE_NORMAL
- en: Space-Truckers – the Splash Screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing gets the attention of an audience better than a splashy entrance, and
    nobody knew this better than good ol’ William Shakespeare. A glance at the first
    few pages of any of his plays uncovers a host of different exciting scenes from
    a street brawl between rival gangs in *Romeo and Juliet* to an interrupted wedding
    in *A Midsummer Night’s Dream*. The Bard knew how to get the attention of his
    audiences – a notable feat in those times – and just as he shamelessly plundered
    history and mythology (sometimes both at the same time!) for his stories, we’re
    going to shamelessly plunder the techniques he used in our work.
  prefs: []
  type: TYPE_NORMAL
- en: The specific inspiration from Mr. S. that we will examine is the idea of engaging
    the attention of an audience to prepare and prime them for what they’re about
    to experience. We don’t have a fancy fight scene or a fantasy wedding in the cards
    for Space-Truckers, but we do have our Splash Screen!
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the Splash Screen in context, the user has just clicked the **Launch**
    button on the regular HTML web page, transitioning the page over to WebGL and
    rendering the animated Loading Screen we built back in [*Chapter 2*](B17266_02_Final_AM.xhtml#_idTextAnchor030)*,
    Ramping up on Babylon.js*. Immediately following the completion of the Splash
    Screen (either because it ran to the end or because the user chose to skip through
    it), the user will be taken to the **Main Menu** screen that we built out in the
    previous chapter. Through a series of animated sequences and in conjunction with
    the audio soundtrack, users will be put solidly into the mood of a Space-Trucker.
  prefs: []
  type: TYPE_NORMAL
- en: Storyboarding the Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it’s easy to let the mind wander off into the potential avenues that
    a splash scene might show, we’ll Save It For A PR™ and instead start with something
    incredibly simple that we can then use as a base for expansion. A storyboard doesn’t
    have to be an immensely complicated and planned-out artifact. Time spent storyboarding
    is time that isn’t being spent trying out the ideas laid out by the storyboard,
    so don’t worry about making it look good, worry about the boards capturing a set
    of snapshots of what you want to happen. The following diagram shows the sketched-out
    series of panels that comprise the Splash Screen storyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the
    numbers given for timings should not be taken at face value](img/Figure_5.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Storyboard for the Splash Screen sequence. Being a sketch, the
    numbers given for timings should not be taken at face value
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break this diagram down a bit by walking through the scene in a temporal
    order. At time = 0, we have a blank stage (screen). After 2 seconds have passed,
    the first panel with the words “Powered By” is fully visible. Half (0.5) a second
    after that (or T+2.5s) marks the beginning of the exit sub-sequence, which completes
    with the panel fully hidden another half a second later. The total amount of time
    that the first panel depicts is 3 seconds. Armed with that explanation, the other
    three panels should also make sense. Each panel progresses the scene forward,
    starting at the top-left, moving right, and wrapping back to the left panel, respectively.
    The image shown in a panel fades in and out according to the given timings, but
    those numbers should be used as rough guide markers only – it’s important to tweak
    the values to what you like.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to compare the storyboard with the final splash screen sequence,
    there are some gross similarities; the panels are all mostly the same and in the
    same order, the timings notated are roughly the same, and more. That shows the
    evolution of the design from start to finish and serves to drive home a central
    point of storyboarding – the boards are not the whole story! These admittedly
    crude sketches serve the purpose of putting a stake in the ground, giving loose
    definition to the basic elements and timings involved so that we can focus on
    other aspects of implementation – such as the code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is only one new concept that we haven’t encountered yet that we’ll need
    to learn to build out the Splash Screen in code. Everything else will use a combination
    of techniques that we’ve used in previous chapters in one way or another, so hopefully,
    this will seem pretty easy! For this part of the chapter, we’ll be working exclusively
    in the **PlayGround** (**PG**) – if you’re following along, this is where you’ll
    want to load up the PG with a new snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Code listings will continue to become less complete and more focused on specific
    aspects or areas of the code under discussion that are important, tricky, or non-obvious.
    The complete code for this chapter can be found at [https://github.com/jelster/space-truckers/tree/ch5](https://github.com/jelster/space-truckers/tree/ch5).
    Don’t hesitate to pull it up to compare your progress against it or check your
    work – sometimes, an explanation just won’t cut it and you need to see working
    code!
  prefs: []
  type: TYPE_NORMAL
- en: When we break out the various animated sequences outlined in the storyboard,
    there’s an immediate structure or way of ordering the cut scene that sticks out
    right away. Each board in the storyboard represents a distinct snapshot of what
    is happening at a given time in the scene, so we need to come up with a way to
    represent these cut scene segments in code. We want it to be a reusable component,
    and we want to be able to use The Power of `CutSceneSegment`, and a new `SplashScene`
    class can be used to compose and manage those segments with proper timings and
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: The CutSceneSegment Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CutSceneSegment` class is a simple container that can represent an atomic
    portion of the scene’s sequence, but although it is simple, it isn’t devoid of
    any behaviors. A `CutSceneSegment` should be able to `start` and `stop` its sequence,
    potentially looping playback. Similarly, other components may need to know when
    a segment completes, so a `onEnd` observable will make it easier for us to write
    controlling logic to manage multiple segments in sequence. Because we don’t hate
    ourselves and we don’t want to spend time debugging mysteriously misbehaving code,
    we’ll treat an instance of a `CutSceneSegment` as **immutable**. That is, once
    we’ve created the object, we’re not going to try to change it by say, swapping
    out the contained animations.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Can you keep a secret? Those who have experience with JavaScript may be thinking
    that the word “immutable” is incorrectly being applied. While it is true that
    from a strictly technical sense, the objects we’re dealing with are not immutable,
    the idea is that we simply pretend it is immutable. If we’re using it as-is, and
    if nobody tells, does it matter whether an object is immutable or not? Be warned,
    though – it’s easy to lose the distinction between ways of thinking about software
    and expressing those concepts in code, so don’t mistake this for language-specific
    guidance!
  prefs: []
  type: TYPE_NORMAL
- en: Although it would be useful to be able to control multiple target scene elements
    in a single `CutSceneSegment`, we don’t need that complexity to implement the
    scene from our storyboards. This decision, in conjunction with the previous decision
    regarding immutability, has two important implications for how we will write our
    classes’ **constructor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to get a `target` against which the segment will operate.
    This can be anything capable of being animated, so, pretty much any BJS type you
    may want to animate can be used here (with the notable exception of the types
    in `animationSequence`. Of course, the “ctor” (as the cool kids all call it) will
    need to take a reference to the current scene, which gives us the following signature
    for the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be unfamiliar with the highlighted language construct. That’s OK because
    although it’s not uncommon, it’s also not something that you might encounter in
    your everyday JavaScript. The three periods (`.`) before `animationSequence` indicate
    that the parameter is treated as an arbitrary params-style array. This is merely
    a convenient piece of “syntactic sugar” that allows callers of the function to
    avoid the need to create and pass an `Array` and instead pass a comma-separated
    list of the elements comprising the Array. The following code fragment shows arrays
    being passed as the trailing three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CutSceneSegment` constructor, there are two primary things we need
    to accomplish:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `TargetedAnimation` from each Animation in `animationSequence`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the TargetedAnimations to a new `AnimationGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Going in reverse order, `AnimationGroup` is something new to the project. Do
    not try to overthink it – it is and does exactly what its name suggests. Next,
    because we already have animations that just need targeting, we can loop through
    the `animationSequence` collection and use AnimationGroup’s `addTargetedAnimation`
    method to complete the binding. The Babylon.js Docs site at [https://doc.babylonjs.com/divingDeeper/animation/groupAnimations](https://doc.babylonjs.com/divingDeeper/animation/groupAnimations)
    has more information on different aspects of the `AnimationGroup` properties and
    methods, but other than the previous looping logic, the usage of an `AnimationGroup`
    is very similar to an individual `Animation`. Having accomplished these tasks,
    all that’s left for the constructor is to delegate the `CutSceneSegment.onEnd`
    member property to `AnimationGroup.onAnimationGroupEndObservable`. Here’s what
    the entire `constructor` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finishing the `CutSceneSegment` class are the `start` and `stop` methods. These
    are extremely simple, and just call the appropriate function of `this.animationGroup`.
    When we want to loop a `CutSceneSegment` – not a typical usage – we can set the
    `loopAnimation` flag to true before calling `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This completes the `CutSceneSegment` class. It’s ready to be used in the code
    we’re just about to write for the `SplashScene` class, where we’ll be creating
    a segment for each panel in the storyboard before playing them in sequence. First,
    though, let’s add another set of building blocks for our scene – the animations
    driving the scene’s visuals.
  prefs: []
  type: TYPE_NORMAL
- en: The Animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are only three separate types of animations that we need for the scene.
    The keyframes and targets may be different, but the base property being animated
    is the same. Separate from any class declaration, add declarations for `flipAnimation`,
    `fadeAnimation`, and `scaleAnimation`. To keep the frame rates the same, we declare
    `animationFps` as `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This should be pretty familiar by now, except for the highlighted `true` parameter;
    this instructs the Babylon.js animation engine to enable the animation to be blended
    with others. It’s not necessarily something we’re leveraging immediately in the
    scene, but it’s important to configure it correctly at the outset for when it’s
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the BJS PlayGround, IntelliSense may sometimes confuse the `BABYLON.Animation`
    type with browser or DOM types with the same name. Adding the `BABYLON` prefix
    can help clear up confusion, but remember to remove it later – you won’t need
    it when the code is integrated locally.
  prefs: []
  type: TYPE_NORMAL
- en: The pieces have all been prepared and moved into place for us to start constructing
    the `SplashScene` class, where we’ll create and assemble CutSceneSegments into
    a complete scene.
  prefs: []
  type: TYPE_NORMAL
- en: The SplashScene Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing a class or component’s code structure, a good way to start can
    be simply identifying and capturing any currently known variables of the state
    as class members, even if the value won’t be set until later. One such example
    of this is `currentSegment`. This property holds the currently playing `CutSceneSegment`.
    We’ll populate the various segments in the constructor, but by declaring the members
    outside of `constructor` (as opposed to defining it in the `this.foo = 3`), we
    improve the readability of the code – something that is incredibly important in
    any code destined for production! Here are the class members that we’ll want to
    define:'
  prefs: []
  type: TYPE_NORMAL
- en: '`currentSegment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poweredBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babylonBillboard`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`communityProduction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dedication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onReadyObservable = new Observable()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**skipRequested = false**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the preceding segments (save the highlighted ones, for obvious reasons)
    corresponds to a panel on the storyboard – in order of execution to help with
    readability. Though we won’t use it until later in this chapter, `onReadyObservable`
    is there to signal that all the assets have finished loading and the cutscene
    is ready to start. It’s a similar situation with `skipRequested` – later in this
    chapter, we’ll add the ability for players to skip the cut scene, so adding this
    now is legitimate. Adding the small pieces of code to hook it up is trivial too
    since we’re already working in that area, and it’s one less thing to worry about
    later.
  prefs: []
  type: TYPE_NORMAL
- en: There will be enough setup code in the constructor as it is, so a forward-thinker
    might consider adding method stubs to encapsulate each segment’s setup process!
    Turning our attention to the `createScene` function, we want to start seeing things
    as soon as possible, so let’s hook up one end of the logic, which will allow our
    segments to transition between each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as our previous PlayGround snippets have been structured, the `SplashScene`
    constructor needs a `BABYLON.Engine` instance passed as a parameter, which it
    uses to create the scene. Also similar is the sparse and simple `createScene`
    function, which is used purely in the PlayGround. In case a refresher is needed,
    here’s how to hook up the code with the Playground in the body of `createScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to be able to discretely control when `SplashScene` starts and stops,
    so the constructor isn’t going to be the place to start playing CutSceneSegments.
    Instead, we’ll add a `run` method (highlighted in the preceding snippet) to perform
    those duties in response to a signal from `onReadyObservable`. Now, as we enhance
    and expand `SplashScene`, we’ll be able to build off from this without having
    to worry about getting everything to start at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The `SplashScreen.run()` function looks very similar to the `run` function of
    the `SpaceTruckerApplication` run function if you squint enough and possibly stare
    unprotected at the sun for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Do not look directly at the sun without proper eye protection! Sunglasses, even
    ones that block UV radiation, are not sufficient protection for eyes, and permanent
    damage may result. On a related note, never take advice on what to do in the outdoors
    from a technical book on programming. HTH.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason they look similar to each other is that they both serve similar
    duties. Similar problems face similar solutions and all, so here we are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Even though this scene doesn’t use the `function*` generators that we saw in
    the previous chapter, it still qualifies as a simple type of state machine. The
    current state (represented by `currentSegment`) is polled on every frame and compared
    with the previous frame’s value. If they are different, then it means that a new
    segment has been swapped in and must have its `start` method invoked to continue
    the sequence. Because it’s so straightforward, and again because we’re already
    here, the logic for managing the use case where the player wishes to skip the
    cutscene and go straight to the Main Menu gets added as well. The only real items
    of note are the combination of setting `this.currentSegment = null` with the `?.`
    operators to prevent any attempt to call a method on an undefined value; if `currentSegment`
    is null (from the viewpoint of the code), then the cutscene either hasn’t started
    yet, or it has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a stable platform for creating the CutSceneSegments, there are still
    a few things that we need to add to the constructor logic, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the scene, camera, and light should be pretty standard by now, and
    although the `billboard` `camera` to render the scene, there’s `light` to illuminate
    `billboard`, and there’s `billboard` to display our content – whatever that may
    be! We want the billboard to face perpendicular to the camera’s view, hence setting
    the initial rotations. The values may seem a bit weird, but they will all make
    sense shortly. Now that we have the framework to render the cutscene, it’s time
    to start defining the cutscene segments! We’ve gone quite a bit without saving
    (or not, if you’re well disciplined!), so now’s a good time to run the snippet
    and check for any obvious issues or errors before saving it for posterity.
  prefs: []
  type: TYPE_NORMAL
- en: The “Powered By” CutScene Segment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Referring to our initial storyboard, as our first segment, we’ve got a billboard
    displaying a stylized “Powered By” image. The timings make sense, and it’s perfectly
    serviceable. However, the problem with it is that it’s just plain outright *boring*.
    Let’s spice it up a bit by having the billboard spin around slowly throughout
    the segment using `flipAnimation` we created earlier. At the same time, we’ll
    apply `fadeAnimation` to fade the billboard in and out at the appropriate times.
    To keep the constructor to a manageable size, add a new class member function
    to `SplashScene` and call it `buildPoweredByAnimations`. Then, in the body of
    the function, start by declaring constants for each of the key timing events of
    the segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in the preceding snippet were arrived at through experimentation,
    so feel free to try out other values until you find something that works right
    for you. With absolute timing values computed, we can also compute the associated
    frame number for each timing event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These frame numbers are important when we want to define the animations’ `flipKey`
    values represent the **y** component of the target’s **rotation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After defining each of the relevant keyframes according to the computed frame
    timings, it’s important to pass those keyframes onto the animation by calling
    `setKeys`. This works with our plan for reusing `Animations` because the keyframes
    are copied into the resulting `TargetAnimation` instance created when associated
    with its target; we can just call `setKeys` again with a new set of keyframes
    whenever needed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The pattern that we’re establishing here for this `CutSceneSegment` will be
    used for the rest of the segments. In other words, this will be on the test!
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing our `buildPoweredByAnimations` function needs to do is create
    and return a new `CutSceneSegment` that puts everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Back in the `SplashScene` constructor is where we’ll invoke the `buildPoweredByAnimations`
    function to create a `poweredBy` object variable. Assigning `poweredBy` to `this.currentSegment`
    will ensure that when `run` is called, the sequence is started. Following that,
    we need to load up the “Powered By” image as a texture that we can use with `billMat`.
    Since this involves an external image asset, add top-level declarations for the
    full URL to the image files (see the previous chapter for more on constructing
    the full GitHub URL for an asset). In this initial case, it’ll be a file called
    [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/powered-by.png).
    Use that URL to construct a new `billMat.diffuseTexture` property.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you load the texture before assigning it to the material!
  prefs: []
  type: TYPE_NORMAL
- en: When running, you should see the image on the surface of the billboard plane,
    which is a good way to test your work before saving it!
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the Next CutSceneSegment… and Beyond
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a `CutSceneSegment` begins running, it may make certain assumptions about
    the current state of the different actors and set pieces involved in a scene.
    For instance, a lighting animation that dims a light in a specific pattern may
    need the intensity values to start at a specific level. At the same time, a given
    segment can’t “know” anything about other segments or their relationships – with
    a single crucial, albeit caveated exception. Upon completion of a `CutSceneSegment`,
    the `onEnd` `onEnd` observable is the ideal solution – and at the same time is
    also the caveat! To keep some local variables in the constructor conveniently
    in scope, we can call `onEnd.addOnce(() => { … })`. The body of the function is
    where we want to tidy up objects in the scene, along with designating the next
    segment in the Splash Scene sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our immediate case, the next segment is going to be the `babylonBillboard`
    segment, so make the last statement be `this.currentSegment = babylonBillboard`
    in the `poweredBy.onEnd` handler. Before that expression, we need to reset the
    `billMat.diffuseTexture` for the Babylon.js logo texture.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next segment, it’s a good idea to try and run the PlayGround
    snippet to see how it looks and test it for any major errors. Opening the browser's
    Dev Tools to see logged messages can help you gain a sense of timing!
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s that? The new segment doesn’t exist and neither does the `buildBabylonAnimation`
    function: for the texture, use [https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png](https://raw.githubusercontent.com/BabylonJS/Brand-Toolkit/master/babylonjs_identity/fullColor/babylonjs_identity_color.png)
    and for `animationSequence`, use `fadeAnimation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After adding the `buildBabylonAnimation` method, make sure to call it in the
    constructor so that you can subscribe to the new segment’s `onEnd` observable.
    In the `babylonBillboard.onEnd` handler, there’s no need to reposition the billboard
    since it didn’t move during this segment, but there is the matter of teeing up
    the next one, in what is hopefully a familiar cadence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next segment is called `communityProduction` and is functionally identical
    to the previous segment save for a different texture, located at [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/splash-screen-community.png).
    It is also just using `fadeAnimation`. Here are the main relevant timings and
    numbers needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.02_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just like the previous segment, the `communityProduction.onEnd` handler will
    be responsible for setting the next segment – `callToAction` – and swapping `billMat.diffuseTexture`
    to the next one, which for lack of any better name will be called `rigTexture`.
    This texture is rendered onto the `billboard` mesh, where after fading in we’ll
    apply a looping animation to its `scaling` property to make it look more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The storyboard indicates this panel is where copyright notices and such would
    go, but there’s no reason those can’t go someplace else that’s equally useful
    but less prominent. Instead, we’ll make the panel contain a Space-Trucker image,
    with the image slowly pulsing the scale and opacity in a ready-wait indication
    state, waiting for the player to interact.
  prefs: []
  type: TYPE_NORMAL
- en: In a short while, we will be adding some input management. To prepare for that,
    we’re going to need a way to display some appropriately formatted Text. In a block.
    A sort of `TextBlock`, as it were. Our `SplashScreen` is going to need to use
    the **BABYLON.GUI**.
  prefs: []
  type: TYPE_NORMAL
- en: The Last Segment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our final `CutSceneSegment` – `callToAction` – follows a similar path that
    the others have taken, in that we use `billBoard` to display a `diffuseTexture`
    that fades into the scene. Here is where the segments start to diverge because
    instead of fading out again, we want it to fade in and then loop around without
    ever completely fading away. At the same time, we will use `scaleAnimation` to
    vary the scale of the `billboard` mesh along its *X*- and *Z*-axes. This will
    give the two-dimensional flat image a fake appearance of depth and scale as the
    animation cycles, which means that it looks cool! Here are the timings for each
    animation in the segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.03_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the end timing is reached, we want our **Call To Action** (**CTA**) text
    to be made visible, inviting us to press a key or tap their touch screen to continue.
    In another of the Bard’s favorite tricks, here is some foreshadowing (not of the
    shading variety, the literary kind) – the **CTA** serves the subtle purpose of
    allowing the application to figure out what type of input the player wants to
    use. It’s an incredibly direct means of communication between two entities that
    otherwise have almost zero capability to understand each other, and it works because
    its binary (the irony! It burns!) simplicity conveys a user’s preference simply
    by them picking up the device and engaging an input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go there, we need to wrap up the implementation of the constructor
    by creating `BABYLON.GUI.AdvancedDynamicTexture` mentioned earlier: `callToActionTexture`.
    Creating, configuring the properties of, and adding a `TextBlock` to a GUI is
    a familiar exercise by now (though stick around for [*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207),
    *Improving the Environment with Lighting and Materials,* where we’ll introduce
    the GUI Editor!), so the next listing should require very little explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One thing not to forget is to set the initial visibility of `ctaBlock` (highlighted)
    to `false`. If you want to display it sooner than in the handler for `callToAction.onEnd`,
    go ahead – it’s your game! Once you’ve gotten everything added to the constructor,
    give it a whirl and fix any errors that come up. Hit **Save**, then make sure
    you either put on headphones or can otherwise crank up your computer’s audio –
    it’s time to put in the theme song!
  prefs: []
  type: TYPE_NORMAL
- en: Fading in the Title Music
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After working on this `SplashScene` for so long by now, it’s probably started
    to feel a bit bland, and that is something we will not accept any longer. In [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, we
    added the Space-Truckers main theme song to the `SplashScene` twist.
  prefs: []
  type: TYPE_NORMAL
- en: Recall what was hopefully not-so-long-ago, when you read this gem?
  prefs: []
  type: TYPE_NORMAL
- en: “Though we won’t use it until later in this chapter, onReadyObservable is there
    to signal that all the assets have finished loading and the cutscene is ready
    to start.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, “later in this chapter” starts right now. Since we’ve already put everything
    else into place, there are only four tasks left to wrap up this bad boy and take
    ‘er home:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a string to hold the URL to the song (or substitute your own) at [https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a](https://raw.githubusercontent.com/jelster/space-truckers/develop/assets/music/space-trucker-title-theme.m4a).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `SplashScene.onReadyObservable.notifyObservers` in the `readyToPlayCallback`.
    Set the volume really low – `0.01` works nicely – to give the volume room to grow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a call to `this.music.play()` in the `SplashScene.run` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Crank up the volume (also in the `run` method) over some time by calling `this.music.setVolume(0.998,
    500)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the usual drill of running, fixing issues, repeating as needed, and then
    saving. If you run into trouble or want to compare your results with a known “working”
    snippet, check out [https://playground.babylonjs.com/#DSALXR](https://playground.babylonjs.com/#DSALXR).
    Still can’t seem to get things working? Head over to the Space-Truckers GitHub
    Discussion boards at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)
    and get help from the community, leave feedback or bug reports, and catch any
    updates to the code since this book was published. Having a runnable sample of
    what you want to accomplish in the PG is a great way to play around with ideas
    and concepts, but now, it’s time to metaphorically remove our more abstract and
    theoretical game designer’s hat and put on our more concrete and pragmatic software
    engineer’s work helmet – we’ll need those qualities as we integrate our PG code
    with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the SplashScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The integration phase of the work is where the shiny, pretty, elegant PG Snippet
    meets the hard-faced ugly truth of reality. It’s the part where things are most
    likely to go wrong, and also where bugs in the application code can be uncovered.
    The reason this happens has little to do with the character and attributes of
    the person writing the code, even though it might feel that way sometimes. Any
    bugs or defects uncovered at this point are reflections of what wasn’t known at
    the time the original code was written, and that means there’s an opportunity
    to improve it!
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the Difference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because you have the benefit of this text to help guide your efforts, you’ll
    be spared having to track down and fix two issues uncovered in the `SpaceTruckerApplication.js`
    component, along with some other changes we’ll make structurally to the class.
    Including the two issues just mentioned, here is a list of the things we need
    to do to integrate `SplashScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new files to `/src - cutSceneSegment.js` and `splashScene.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add appropriate imports to new files and copy over class definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `spaceTruckerApplication.js` file will see the greatest changes with these
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the placeholder `Promises` that were used to simulate loading times in
    `spaceTruckerApplication`. With those gone, we can also remove the `async` designator
    from their hosting functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate the Scenes in the `initialize` method instead of previous locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register an Observer in `goToOpeningCutscene` that listens for the `onReady`
    event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, the two issues that would otherwise prevent the application from
    correctly progressing and rendering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (Issue) `AppStateMachine` should yield `currentState`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Issue) Logic in the `engine.runRenderLoop` callback needs to be a class-level
    function to access `this` properly. The problem can be resolved by extracting
    the arrow function into a class-level function – that is, `this._engine.runRenderLoop(()
    => this.onRender());`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to visualize the changes is to view a `SplashScreen` into the app.
  prefs: []
  type: TYPE_NORMAL
- en: However it is accessed, the range of revisions we need to compare can be represented
    with the `ch4...6db9f7e` expression. Use this as an argument to `git diff` or
    paste it into a browser as the trailing path to `<repo URL>/compare/<revision
    range>`, or in this case, [https://github.com/jelster/space-truckers/compare/ch4...6db9f7e](https://github.com/jelster/space-truckers/compare/ch4...6db9f7e).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the particulars of your development environment, a **diff** will
    be displayed in a varying number of (pardon the pun) different ways. Regardless
    of the specific tool, almost every **diff** will organize its report by individual
    files that have changed between the given range of revisions. **VSCode’s** **Timeline**
    feature will show the commit history for an opened file; the diff can be viewed
    by clicking the revision in the **Timeline** pane.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Making a habit of examining these diffs closely before each commit or merge
    can improve your coding abilities, together with the quality of your code. A good
    sign that you are trying to do too much in a single commit is having a complicated
    and long changeset. Break the work into smaller components and commit each separately,
    and not only will any reviewers of your **Pull Request** (**PR**) thank you, but
    you’ll find yourself moving faster and with greater confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **GitHub** web interface can also be useful for viewing differences between
    **revisions**, **branches**, and even **forks** (also known as **upstream repositories**).
    Navigating through and understanding the different reports is a key skill for
    people who wish to become skilled in software development, but it can be tough
    to block out the inevitable noise that comes with viewing so much information.
    GitHub will try to do some of this for you, by collapsing large diffs by default,
    for instance, but the best way to deal with poor a signal:noise ratio is unfortunately
    not retroactive; it is only useful when applied at the time of **commit** or **push**.
    This solution is to be mindful of and structure commits with a high signal:noise
    ratio from the beginning. Here are some tips for helping with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_5.04_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the diff as a reference guide when needed, try to accomplish the activities
    listed earlier on your own. Of course, since you’re already looking at the diff,
    you should feel free to simply pull down the code at **commit 6db9f7e** if you’d
    simply like to resume following along right away. The following figure shows a
    still capture of where you should end up after running the application, clicking
    the **Launch** button, and after the conclusion of the Splash Screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Splash Screen finished and waiting for user input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Splash Screen finished and waiting for user input
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get into the nitty-gritty details of all of the items – some familiar,
    some new – contained in that commit’s **patch** soon enough, but before we do,
    let’s quickly recap what we’ve accomplished so far.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a set of storyboard panels depicting snapshots of the scene at
    various points in time, we used the boards to pin down timings for the various
    animations and transitions involved. Then, we crafted some reusable code to define
    a `CutSceneSegment`, along with other logic relating to animating objects. Finally,
    we wrote the containing `SplashScreen` class and its attendant asset and `CutSceneSegment`
    orchestration logic that comprises the full timeline of the scene. That’s a lot
    to accomplish – don’t neglect to acknowledge that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll be moving on to one of the more under-appreciated areas of game
    development: input systems. Because of its importance, we’ll be devoting the rest
    of this chapter to going over how the Space-Truckers input system functions and
    how it is implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Input System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of the **User Interface** (**UI**) often focuses quite heavily on
    visual elements, layout, and design. For the majority of web applications, the
    basics of tracking a pointer, touches, or taps along with keyboard input are handled
    by the web browser, which in turn delegates many responsibilities, such as hardware
    driver interfacing to the underlying **Operating System** (**OS**). When using
    a web-native application library such as Babylon.js, developers can take advantage
    of these already-present abstractions to make it quick and easy to add user interaction
    elements to their scenes. In this section, we’ll learn how to add the application
    scaffolding that can support multiple types of inputs on-the-fly, followed by
    implementing a way to map arbitrary inputs to actions or commands in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s said that imitation is the sincerest form of flattery, so let’s flatter
    the Babylon.js team by “stealing” (called “researching” in polite company) the
    camera input management code. Using the **FreeCamera** as an example (read about
    it at [https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts](https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Cameras/Inputs/freeCameraGamepadInput.ts)),
    here is how the data flows between the controller and the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web
    Browser’s APIs, to the HTML/Canvas and into Babylon.js and the various components
    of the FreeCamera’s input system](img/Figure_5.03_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Flow of input from a Human Input Device (HID) through the Web Browser’s
    APIs, to the HTML/Canvas and into Babylon.js and the various components of the
    FreeCamera’s input system
  prefs: []
  type: TYPE_NORMAL
- en: 'Data starts at the top with the device itself sending data to the connected
    host OS, which (via its device driver interface) translates that raw input data
    into structures compatible and familiar to the web browser or native host interfaces.
    Eventually, it makes its way into Babylon.js, where it is massaged, processed,
    filtered down, and passed around until it reaches the target of its affections:
    the **FreeCamera**. Here is a PG that represents a slightly simplified version
    of the actual input system we’ll be discussing now – use it as a working reference
    if you get lost: [https://playground.babylonjs.com/#78MJJ8#64](https://playground.babylonjs.com/%2378MJJ8%2364).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Main Menu Control Scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we won’t be defining control maps for the game phases at this time,
    the foundations we’ll establish with this pattern will make it quick, painless,
    and easy to add whatever arbitrary control maps later as they become necessary.
    The table shows the various inputs and actions that we’ll be interested in handling
    in the Menu system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Menu controls mapped to various inputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Menu controls mapped to various inputs
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the basic keyboard and (mouse) pointer interactions, the Babylon.js
    `onKeyboardObservable` and `onPointerObservable` properties to allow subscribers
    to be notified of keyboard and mouse (touch) interactions, respectively. `GamepadManager`
    (accessible from a scene’s `gamepadManager` property) and `VirtualJoystick` are
    useful for adding gamepads and their virtual touch equivalents for when mouse
    and keyboard aren’t the goal. You can read more about these in the Babylon.js
    docs at [https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks](https://doc.babylonjs.com/divingDeeper/input/virtualJoysticks)
    and [https://doc.babylonjs.com/divingDeeper/input/gamepads](https://doc.babylonjs.com/divingDeeper/input/gamepads).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As alluded to earlier, the topic of input handling is sufficiently complex that
    it would take a great deal of the finite space available in these pages to review
    all the code line by line, so the code that is listed will be highlighted in sections
    under a particular area of discussion. Don’t worry about not being able to follow
    along, though – you can still examine the full source code and the links to PG
    snippets won’t be going away either!
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Input Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the table of controls from the previous section is something that would
    work well in the game or application’s user manual, it’s less clear how the information
    in that table can be leveraged in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JavaScript `foo[“property”]`), indices will be represented in the new source
    file we’ll call `inputActionMaps.js`. In it, we will define all the various object
    constants and helper functions relating to – as suggested by the name – mapping
    inputs to actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On the left-hand side (the property name or `button1` and `buttonStart` members.
    Although it seems duplicative and redundant, having a layer of indirection between
    the actual device codes and the logic handling them gives the system a ton of
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to handling the various types of gamepad input, indirection comes
    in handy once again. The `BABYLON.DeviceType` enumeration defines constants for
    each supported type of gamepad device. We’ll use another object map to store how
    each particular device’s inputs matches up to our defined `inputControlsMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is what the mapping for the Xbox360 controller looks like
    at a very basic level. As the comment indicates, each object in the `deviceType`
    array corresponds to a different input index on the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a moment, we’ll learn how to use this mapping information at runtime to
    resolve inputs from connected devices, but first, let’s get a bit of a wider perspective
    by taking a small step back – not too far, we don’t want to get overwhelmed in
    it all! The following diagram illustrates the different concerns we’ll need to
    address to be able to handle input in Space-Truckers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Handling input Part 1 of 4\. This section covers mapping input
    data from multiple devices and types into standardized structures that can be
    resolved to game or application-level actions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Handling input Part 1 of 4\. This section covers mapping input
    data from multiple devices and types into standardized structures that can be
    resolved to game or application-level actions
  prefs: []
  type: TYPE_NORMAL
- en: Entire books can be written just on the topic of designing the input models
    and such, but the important thing to take away here is that the goal of the code
    we’re writing or are about to write is to hide away (or **abstract**) the details
    of how inputs are processed from the game’s core logic. The game logic doesn’t
    care or need to know about whether a user wants to move their truck with a keyboard
    or a gamepad – it just needs to know that the user wants to move their truck and
    in what direction!
  prefs: []
  type: TYPE_NORMAL
- en: Input Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to managing the specific inputs and devices, `SpaceTruckerInputManager`
    (follow along with the code at [https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js](https://github.com/jelster/space-truckers/blob/ch5/src/spaceTruckerInput.js))
    is responsible for managing the lower-level device management tasks of subscribing
    and unsubscribing to/from device events, retrieving input from the underlying
    Babylon.js input abstraction layers, and preparing it for being processed into
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coalescing**, or aggregating input from multiple devices, can be both tricky
    and tedious – not the best combination for anything requiring concentration and
    recall as coding does. Tackling the tricky part by breaking down the complexity
    is the first step; the second step is paradoxically (or perhaps ironically) more
    complicated than the first step because it is more up to the individual involved
    to find ways to keep chugging through to the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Addressing Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common decisions that needs to be made about a potential software
    design is where (in the code) to assign various responsibilities. It can sometimes
    be tempting to just put all the logic, data, and code into a single file for convenience’s
    sake, but unless this is all taking place in the PG, enhancing and maintaining
    the application will quickly become an uncontrollable nightmare in every practical
    respect.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way that the **SpaceTruckerInputManager** (**STIM**) manages complexity
    is by maintaining individual and separate device-specific registration logic.
    Different devices present their data in different ways; some types of inputs lend
    themselves to Observables that can be subscribed to receive input events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Observables propagating events – onKeyDownObservable in this
    case](img/Figure_5.06_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Observables propagating events – onKeyDownObservable in this case
  prefs: []
  type: TYPE_NORMAL
- en: 'Others are more suited to have their state polled on a frame-by-frame basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be
    polled to get the current state of the device](img/Figure_5.07_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Analog inputs (joystick axis, triggers, and more) need to be polled
    to get the current state of the device
  prefs: []
  type: TYPE_NORMAL
- en: To make things more fun, many devices mix paradigms, with some inputs exposed
    via observable events and some only available via polling! All this data is aggregated
    into an `inputMap` **hashmap** (there it is again!) that contains the current
    state of all registered inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The Input Manager must deal with either scenario with aplomb and grace according
    to Etiquette, and so it shall. Leaving a subscription dangling after the subscriber
    has gone away is considered poor form, so we must ensure the Input Manager also
    cleans up after itself like a good houseguest. That means we need to track our
    subscriptions and their sources so that we can use `Observable.remove`. Fortunately,
    we also have a parallel need for the Input Manager to have access to a given Scene.
  prefs: []
  type: TYPE_NORMAL
- en: Input Registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever a `SpaceTruckerInputManager`, it doesn’t matter who is invoking `registerInputForScene`,
    it just needs `sceneToRegister` into its `inputSubscriptions` array. The object
    map that’s added to the list is keyed by the scene being registered because the
    lifetime of `SpaceTruckerInputManager` follows a `Scene.onDisposeObservable` (highlighted).
    The subscriptions array contains the returned set of `enableKeyboard`, `enableMouse`,
    and `enableGamePad`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned device-enable functions return an object with a very specific
    shape – and that shape is one of the keys (pardon the deep-running pun here) to
    making everything come together smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To deal with inputs requiring polling, each type of device needs to have a
    `checkInput` method that knows how to retrieve input and place it into the `SpaceTruckerInputManager.inputMap`
    hash map. For devices that exclusively utilize observables in their input surfacing,
    the `checkInput` function can be a no-op or empty function that does nothing.
    Devices with mixed or solely axis inputs (for example, thumbsticks, joysticks,
    triggers – any input type that returns an input that isn’t always a 0 or 1) implement
    `checkInput` to read the gamepad’s state every time it is called (every frame).
    Since things such as normalizing input are concerns shared across different models
    of gamepads, the utility functions in `inputActionMap.js` (referenced as `SpaceTruckerControls`
    in the following code block) are leveraged to ensure that axis input values are
    in the range of *-1 <= value <= 1*. Other functions take those normalized values
    and map them to a particular input direction based on the inputs crossing a threshold
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block is from `spaceTruckerInput.js` and is contained as
    part of the `checkInputs` function object defined in the `enableGamepads` method.
    For any type of analog input device, there will be a certain amount of imprecision
    and noise in the inputs. To deal with that, the input is “normalized” (that is,
    values that are reported are in the range of `-1 <= x <= 1`) using static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Disposing Input Subscriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other property of the `enableDevice` contract is the `dispose` method.
    This is a function, like `checkInputs`, that contains all the specific logic needed
    to unsubscribe any observers and clean up after itself. Those two properties allow
    the consumers of `inputManager` to remain completely ignorant about the specifics
    of how input is collected by the application. This makes the code simpler and
    gives us more attention to focus on accomplishing other things (such as getting
    through the rest of this chapter). This is what the return value of the `enableGamepad`
    method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All this talk about observers, observables, and subscriptions can be confusing.
    That’s the complexity you’re tasting, but hopefully, that taste will yield to
    a more pleasing robust, functional flavor as we discuss the final piece of the
    `getInputs` method.
  prefs: []
  type: TYPE_NORMAL
- en: The getInputs Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we want a scene to check inputs every frame, we haven’t defined what
    will invoke that logic yet, or where it will occur in the application. For the
    `getInputs` function takes a Scene as its sole parameter. The `sceneInputHandler`
    local constant. Each of the subscriptions in the `sceneInputHandler.subscriptions`
    array has its `checkInputs` function invoked as part of a `forEach` loop; recall
    that each subscription represents a specific input type and that the `checkInputs`
    function populates `SpaceTruckerInputManager.inputMap` with the latest values.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `inputMap` containing all the various inputs to the Screen, an array of
    entries is iterated across and mapped into an input event structure containing
    the `lastEvent` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting inputs array is then returned to callers, as well as getting
    syndicated via `onInputAvailableObservable` (currently unused). Note the large
    gap in this discussion, namely the question as to where and who calls the `getInputs`
    function. This is indeed a good question, but it is not one that `SpaceTruckerInputManager`
    needs to concern itself with – that is a matter for our next topic: Input Processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Two of the four components covered so far](img/Figure_5.08_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Two of the four components covered so far
  prefs: []
  type: TYPE_NORMAL
- en: Input Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapping raw inputs to game or application inputs is a crucial part of Input
    Management, the two components of our input system that we’ve covered so far.
    That’s potentially enough to be sufficient for a relatively simple application
    or game, but Space-Truckers has different needs. It needs to be able to selectively
    route the input to Screens without needing to know anything about the details
    of that input. It also needs to handle input state – not just the current, but
    past as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a point whereupon it becomes rude to ask additional favors from a
    distinguished houseguest, and if our houseguest is `SpaceTruckerInputManager`,
    then asking it to take on these responsibilities is… well, it’s just too much.
    We need another component to take up the burden: `SpaceTruckerInputProcessor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the `registerInputForScene` and `unRegisterInputForScene` methods
    of its sibling, `SpaceTruckerInputManager`, the `attachControl` and `detachControl`
    functions. Unlike its sibling, though, the STIP functions do not accept a `SpaceTruckerInputProcessor.attachControl`
    method that calls `registerInputForScene` in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Also, as part of attaching control to the Screen, `inputManager.onInputObservable`
    gets `SpaceTruckerInputProcessor.inputAvailableHandler` subscribed to be notified
    when a new set of inputs has been received. It’s a simple little method that just
    pushes received inputs into `inputQueue`, which is processed as part of the `update`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is where the magic happens. After a quick check to ensure that it’s OK
    to be handling inputs, `inputManager.getInputs` is invoked, which, in turn, triggers
    an out-of-function process that ends up populating `inputQueue` with information.
    This may not happen in time for the rest of the update function logic, but that’s
    OK because it will just be handled in the next frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The current map of actions to state (`this.actionState`) is copied into `this.lastActionState`
    to preserve it for later usage in processing inputs. Then, `inputQueue` is drained
    of items one by one and dispatched by `inputCommandHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: InputCommandHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This deceptively simple method does a lot more than it might seem at first
    glance. That’s all due to the power of (third time’s the charm!) `actionMap`.
    The `actionMap` class member is an object map that relates a game action (`ACTIVATE`)
    to an executable function in the hosting Screen – a topic we’ll delve into shortly
    – which it uses to look up and invoke the game logic attached to the given action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we pass an object with `lastActionState`, along with the event
    object passed along from `inputManager`, and store the return value in a previously
    mentioned object map, `actionState`. Each individual `actionFn` decides what to
    return, as well as what to do with the passed-in state value without `inputProcessor`
    ever needing to deal with the specifics – nice and tidy!
  prefs: []
  type: TYPE_NORMAL
- en: The buildActionMap Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What `buildActionMap` does is what is known as `actionList`, the `actionDef.action`
    string property is used to look up a function with the same name in the `SpaceTruckerInputProcessor.screen`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If located, `actionMap` is populated with the located function after optionally
    wrapping it with a pre-processing `bounce` function to prevent it from being invoked
    too many times in a given period… which brings us to the final component of our
    input system: Action Handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Input Processing, Input Management, and Mapping of Input data
    covered. Just Action Handling remains](img/Figure_5.09_B17266.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Input Processing, Input Management, and Mapping of Input data covered.
    Just Action Handling remains
  prefs: []
  type: TYPE_NORMAL
- en: Action Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve spent the last few pages diving through multiple levels of abstraction
    and indirection, and we’re now finally at the point where it all starts to do
    something – the Action Handling. While the previous steps were confined to a specific
    class or instance type, the action handlers are the screens themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sounds like the name of a bad early 2000s cover band, but it’s a term for how
    we go about naming and describing our action functions on a given screen. It’s
    a lot simpler than it sounds: for every action that a `state` parameter. Should
    you need to get more information about the input event, add a second parameter
    to the function to accept an `inputEvent`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, an action is a game-specific concept, such as `MOVE_UP`, or `ACTIVATE`.
    Those are just the names given for this game; you are free to name them whatever
    you want!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `SpaceTruckerMainMenuScreen` as an example, the `MOVE_UP` and `MOVE_DOWN`
    actions should increment or decrement `selectedItemIndex` for the menu items.
    An `ACTIVATE` action should invoke the menu item. Here’s what that looks like
    when we code up the `MOVE_UP` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `ACTIVATE` retrieves `selectedItem` before simulating a click event
    by calling its `onPointerClickObservable.notifyObservers` method to invoke whatever
    result is indicated by the particular button selected.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the Splash Screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As part of constructing the Splash screen earlier in this chapter, we added
    a `skipRequested` flag to the scene, but there wasn’t ever anything that would
    change that value… until now! The `ACTIVATE` action doesn’t need to know what
    key was pressed – it only needs to know that it happened at all; just that a key
    was pressed in the first place. That makes this a pretty simple piece of logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `SpaceTruckerSplashScreen.update` function, where the `actionProcessor.update`
    function is invoked, is, in turn, called during `SpaceTruckerApplication.Render`,
    but only if it is the currently active screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – All four components of the input system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – All four components of the input system
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Glancing back through the previous pages in this chapter, it might be easy to
    think that we haven’t accomplished a whole lot, but never sell yourself short
    – the things we’ve covered in this chapter aren’t the most straightforward to
    understand or wrap your brain around! Constructing and orchestrating the sequencing
    of `SplashScreen` starts to ramp up the complexity of our code, not counting the
    mental whiplash induced by pivoting from that to input in the space of a page.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier and not redundantly stated again now, entire thick textbooks
    can and have been written on the topic of input handling, something we’re trying
    to cram into a mere fraction of that. Not only that, but we are now able to approach
    future features with a much clearer picture of how all of the non-game-specific
    tasks are to be managed and handled.
  prefs: []
  type: TYPE_NORMAL
- en: That statement could be expanded to cover this and the other chapters in this
    section as well – we’ve gotten much of the supporting application in place now,
    which leaves us far more attention to focus on the topics in our next section!
    In section two, we’ll build the gameplay mechanics, set up lighting and materials,
    and much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where to start? There are simply so many interesting things and possibilities
    to explore! Here are just a few ideas for things you can do to further your learning
    and enhance `SplashScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a camera animation to the beginning portion that has the camera moving and
    rotating along a path in such a way that the `billboard` panel grows in apparent
    size at about the same rate as the volume of the music rises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add background environmental effects to the Scene, similar to what we did with
    the Main Menu and the Procedural Starfield texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the final static image with a mesh, texture, material, or something
    else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The input system is also a great source of ideas. Here are a few to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement support for your favorite gamepad or joystick device. Use this testing
    site to see the various inputs and values emitted by your device: [https://luser.github.io/gamepadtest/](https://luser.github.io/gamepadtest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the input system to allow for multiple simultaneously connected users
    – that is, local multiplayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose the joystick sensitivity settings to the application so that they can
    be edited in-game by the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Constructing the Game'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this second part of the book, we will build on the foundations of the first
    part to implement the primary components that comprise **Space-Truckers: The Video
    Game**. The pace picks up, as there’s far more material to cover than there is
    space to contain it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *Implementing the
    Game Mechanics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142), *Processing Route
    Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166), *Building the Driving
    Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17266_09_Final_AM.xhtml#_idTextAnchor186), *Calculating and
    Displaying Scoring Results*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17266_10_Final_AM.xhtml#_idTextAnchor207), *Improving the Environment
    with Lighting and Materials*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
