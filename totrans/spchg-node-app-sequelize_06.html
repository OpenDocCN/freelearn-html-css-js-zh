<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-138"><a id="_idTextAnchor147"/>6</h1>
<h1 id="_idParaDest-139"><a id="_idTextAnchor148"/>Implementing Transactions with Sequelize</h1>
<p>Throughout the previous chapters, we went over how to ensure that data integrity is maintained from within our Node.js application using life cycle events, validations, and constraints. However, these methods do not guarantee that the data is internally consistent in the database itself. Databases offer a way to atomicize integrity using <strong class="bold">transactions</strong>. </p>
<p>Transactions are used for ensuring a process<a id="_idIndexMarker553"/> has been completed without interruptions such as a connection failure or the power abruptly failing. They are also used for isolating, or locking, applications from manipulating data concurrently, which alleviates <strong class="bold">race</strong><em class="italic"> </em><strong class="bold">condition</strong> issues. Transactions promise data validity by following the <strong class="bold">ACID</strong> principle, which stands for <strong class="bold">atomic</strong> (“all-or-nothing” behavior), <strong class="bold">consistent</strong> (adheres to constraints), <strong class="bold">isolated</strong> (transactions happen sequentially and unbeknownst toward each other), and <strong class="bold">durable</strong> (persistent storage).</p>
<p>A generic use case for transactions would be transferring funds from one user account to another. If <em class="italic">User A</em> had 30 coins in their account and was charged 20 coins by <em class="italic">User B</em> just before <em class="italic">User A</em> decided to make a purchase from another user for 15 coins, then the database should prevent <em class="italic">User A</em> from being able to purchase the item that costs 15 coins due to a low balance. The database would see that <em class="italic">User A</em> was charged 20 coins prior to charging 15 coins and then would issue a <strong class="bold">rollback</strong> for the second transaction.</p>
<p class="callout-heading">Note</p>
<p class="callout">Transactions also offer a feature called <strong class="bold">savepoints</strong> that would act as “snapshots<a id="_idIndexMarker554"/> of time for the database” with changes made from the transaction itself, which is useful for multi-step transactions. For instance, in a bank scenario, we only transact the currency itself, but in a vendor’s shop, we would have to ensure the item and currencies are in their appropriate places.</p>
<p>By default, Sequelize does not execute queries under a transaction, but it does offer two methods for interacting with transactions that are referred to as managed and unmanaged transactions. Managed transactions<a id="_idIndexMarker555"/> will either commit the changes or roll back their changes automatically/implicitly depending on whether there is an error. Unmanaged transactions<a id="_idIndexMarker556"/> rely on the developer to invoke the appropriate methods for committing or rolling back changes.</p>
<p>In this chapter, we will cover the following areas:</p>
<ul>
<li>A more in-depth look at – and examples of—managed and unmanaged transactions</li>
<li>Using <strong class="bold">Continuation-Local Storage</strong> (<strong class="bold">CLS</strong>) for partial transactions</li>
<li>Managing and configuring advanced transaction options including isolation levels</li>
<li>Using life cycle events and locks with transactions</li>
</ul>
<p>Specifically, we will look at the following topics:</p>
<ul>
<li>Managed and unmanaged transactions</li>
<li>Running transactions concurrently</li>
<li>Isolation levels and advanced configuration</li>
<li>Putting it all together</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You can always reference Sequelize’s code base to maintain an up-to-date list of available transaction methods here: </p>
<p class="callout"><a href="https://github.com/sequelize/sequelize/blob/v6/src/transaction.js">https://github.com/sequelize/sequelize/blob/v6/src/transaction.js</a></p>
<h1 id="_idParaDest-140">Technical requireme<a id="_idTextAnchor149"/>nts</h1>
<p>You can find the code files of this chapter at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6">https://github.com/PacktPublishing/Supercharging-Node.js-Application-with-Sequelize/blob/main/ch6</a>.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor150"/>Managed and unmanaged transactions</h1>
<p>Managed transactions<a id="_idIndexMarker557"/> are typically easier for developers with previous <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) experience, and unmanaged<a id="_idIndexMarker558"/> transactions may<a id="_idIndexMarker559"/> be more familiar to developers who write <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) directly. Unmanaged transactions<a id="_idIndexMarker560"/> are explicit by design, but managed transactions have some implicit behaviors for state management such as automatically creating a transaction instance and calling your callback method with that transaction.</p>
<p>Let’s look at the steps for creating<a id="_idIndexMarker561"/> unmanaged transactions, as follows:</p>
<ol>
<li>We would start by creating a transaction instance, like so:<pre>const tx = await sequelize.transaction();</pre></li>
<li>Next, we will want to wrap our queries in a <code>try</code> block. For this example, we will increment and decrement two account balances by <code>100</code> using the same transaction instance, like so:<pre>try {
    const amount = 100;
    await Account.increment(
        { balance: amount * -1 },
        {
            where: { id: 1 },
            <strong class="bold">transaction: tx</strong>
        }
    );
    await Account.increment(
        { balance: amount },
        {
            where: { id: 2 },
            <strong class="bold">transaction: tx</strong>
        }
    );</pre></li>
</ol>
<p>The following line of code will commit<a id="_idIndexMarker562"/> our transaction if our previous two queries are executed successfully:</p>
<pre>await tx.commit();</pre>
<ol>
<li value="3">Now, we can close the <code>try</code> block and add a <code>catch</code> block for handling any errors thrown from our transaction, as follows:<pre>} catch (error) {
  await tx.rollback();
  // log the error here
}</pre></li>
</ol>
<p>The <code>tx.rollback()</code> command will tell the database to revert any changes made within this transaction. You may roll back a transaction at any time regardless of whether there is a conditional statement or for error handling.</p>
<p>Sequelize can<a id="_idIndexMarker563"/> automate a lot of this work for you by using <em class="italic">managed transactions</em>. Let us presume that our <code>Account</code> model has a constraint where the balance had to be greater than zero, and the sender account only had five coins in its balance. We can rewrite our previous unmanaged transaction example into<a id="_idIndexMarker564"/> a managed transaction, like so:</p>
<pre class="source-code">
try {
    const amount = 100;
    await sequelize.transaction(async (tx) =&gt; {
        await Account.increment(
            { balance: amount },
            {
                where: { id: 1 },
                transaction: tx
            }
        );
    
        await Account.increment(
            { balance: amount * -1 },
            {
                where: { id: 2 },
                transaction: tx
            }
        );
    });
  
    <strong class="bold">// the transaction has automatically been committed</strong>
} catch (error) {
    <strong class="bold">// Sequelize has already rolled back the transaction </strong>
<strong class="bold">       from the try block</strong>
}</pre>
<p>Managed transactions<a id="_idIndexMarker565"/> will automatically commit or roll back depending on whether an exception was thrown from an applicable query. You can still roll back manually within a managed transaction by throwing an error within the transaction block, as follows:</p>
<pre class="source-code">
try {
    await sequelize.transaction(async (tx) =&gt; {
        // some queries
        throw new Error("rolling back the transaction manu
                         ally here");       
        // some more queries
    });
} catch (error) {
    // rolling back the transaction manually here
}</pre>
<p>Sometimes, our application will require different transactions to run concurrently. We can chain multiple transactions recursively<a id="_idIndexMarker566"/> or we could use a module called CLS. In the next section, we will cover how to use concurrent transactions with both methods.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor151"/>Running transactions concurrently</h1>
<p>Depending on whether your application<a id="_idIndexMarker567"/> requires isolation between reads and writes, within the database, you may need to explicitly run multiple transactions at the same time. Sequelize offers two methods for running transactions concurrently: recursively chaining transactions (Sequelize’s native method) or integrating your application with a third-party module called CLS.</p>
<p class="callout-heading">Note</p>
<p class="callout">SQLite does not support running multiple transactions concurrently.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor152"/>Running transactions concurrently with Sequelize</h2>
<p>We can run transactions<a id="_idIndexMarker568"/> concurrently with Sequelize concurrently by chaining two transaction<a id="_idIndexMarker569"/> methods together, which would look similar to this:</p>
<pre class="source-code">
sequelize.transaction((tx1) =&gt; {
    return sequelize.transaction((tx2) =&gt; {</pre>
<p>Now, we can run multiple queries simultaneously while using different transactions, as follows:</p>
<pre class="source-code">
        return Promise.all([
            Account.create({ id: 1 }, { transaction: null }),
            Account.create({ id: 2 }, { transaction: tx1 }),
            Account.create({ id: 3 }, { transaction: tx2 }),
        ]);
    });
});</pre>
<p>By default, Sequelize will not use a transaction instance variable. If we were to omit the <code>{ transaction: tx2 }</code> option for the last <code>Account.create</code> command, then Sequelize would not use a transaction instance variable and would act like the first <code>Account.create</code> command with <code>{ transaction: null }</code>. </p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor153"/>Running transactions with CLS</h2>
<p>Using CLS with Sequelize<a id="_idIndexMarker570"/> will help you automatically pass transactions<a id="_idIndexMarker571"/> to all queries, as well as provide something similar to thread-local storage. The advantage of CLS’ automatic transaction execution is that some database pool drivers require us to commit transactions<a id="_idIndexMarker572"/> across the wire, which would be cumbersome<a id="_idIndexMarker573"/> to manage manually. The thread-local storage gives us the ability to share context across transactions created in separate parts within our application.</p>
<p class="callout-heading">Note</p>
<p class="callout">To learn more about CLS, refer to the project’s Git repository at <a href="https://github.com/othiym23/node-continuation-local-storage">https://github.com/othiym23/node-continuation-local-storage</a>.</p>
<p>This book does not integrate CLS with Sequelize, but for completeness, we will cover how to enable CLS with Sequelize for your project. We will need to install the necessary package, as follows:</p>
<pre>npm install continuation-local-storage</pre>
<p>Then, we can initialize a CLS namespace, like so:</p>
<pre class="source-code">
const cls = require('continuation-local-storage');
const namespace = cls.createNamespace('custom-sequelize-namespace');</pre>
<p>We can then pass the <code>namespace</code> variable to the Sequelize constructor’s <code>useCLS</code> method, like so:</p>
<pre class="source-code">
const Sequelize = require('@sequelize/core');
Sequelize.useCLS(namespace);
const sequelize = new Sequelize(/* … */);</pre>
<p>Since we are using Sequelize’s constructor, all of Sequelize’s instances will share the same namespace. Individual CLS instances are not supported by Sequelize at this time.</p>
<p>Borrowing from the previous section’s example, we omit to classify the transaction parameter within our queries, as highlighted in the following example:</p>
<pre class="source-code">
sequelize.transaction((tx1) =&gt; {
    return sequelize.transaction((tx2) =&gt; {
        return Promise.all([
            Account.create({ id: 1 }, { transaction: null }),
            Account.create({ id: 2 }, { transaction: tx1 }),
            <strong class="bold">Account.create({ id: 3 }),</strong>
        ]);
    });
});</pre>
<p>With CLS, Sequelize will pass the innermost<a id="_idIndexMarker574"/> scoped transaction instance<a id="_idIndexMarker575"/> variable, which would be <code>tx2</code> from the previous example. If we were to omit the <code>{ transaction: null }</code> option for the first <code>Account.create</code> command, then Sequelize will presumptuously use <code>tx2</code> for its transaction, as in the last <code>Account.create</code> command. The second—or middle—<code>Account.create</code> command would still explicitly use the <code>tx1</code> transaction instance.</p>
<p>Since Sequelize automatically passes a transaction to queries, the following two examples would execute with the same <code>tx</code> instance variable:</p>
<pre class="source-code">
await sequelize.transaction(async () =&gt; { <strong class="bold">// the tx</strong>
<strong class="bold">argument is not required</strong>
        await removeUserInventory(id);
        await User.destroy({ where: { id } }); <strong class="bold">// tx is also </strong>
        <strong class="bold">used here</strong>
});
async function removeUserInventory(id) {
    <strong class="bold">// this query will also use the same scope tx variable </strong>
<strong class="bold">       as User.destroy</strong>
    await UserInventory.destroy({ where: { userId: id } });
}</pre>
<p>As you can see, enabling CLS with Sequelize <a id="_idIndexMarker576"/>can offer some advantages and organize the project’s code<a id="_idIndexMarker577"/> base a bit better. </p>
<p class="callout-heading">Note</p>
<p class="callout">For even more functionality with CLS, refer to a project<a id="_idIndexMarker578"/> called CLS-Hooked:</p>
<p class="callout"> <a href="https://github.com/jeff-lewis/cls-hooked">https://github.com/jeff-lewis/cls-hooked</a></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor154"/>Isolation levels and advanced configuration</h1>
<p>In this section, we will be covering<a id="_idIndexMarker579"/> the different isolation levels and configuration options available from Sequelize<a id="_idIndexMarker580"/> for every type of transaction. For managed transactions, the method signature looks like this: <code>sequelize.transaction(options, callback)</code>. The unmanaged transaction signature is <code>sequelize.transaction(options)</code>.</p>
<p>Here is a list of configurable options<a id="_idIndexMarker581"/> for both transaction types:</p>
<ul>
<li><code>type</code>—A SQLite option to set the transaction<a id="_idIndexMarker582"/> type. Possible values are <code>DEFERRED</code> (the default), <code>IMMEDIATE</code>, and <code>EXCLUSIVE</code>. Refer to <a href="https://www.sqlite.org/lang_transaction.xhtml">https://www.sqlite.org/lang_transaction.xhtml</a>.</li>
<li><code>isolationLevel</code>—Sets the transaction’s isolation level. The following explanations are under the context<a id="_idIndexMarker583"/> of MySQL but should be applicable to other <code>READ_UNCOMMITTED</code>—Reads data using non-locking mechanisms. This could cause concurrency issues using stale, or invalid, data from other transactions that have been rolled back.</li><li><code>READ_COMMITTED</code>—Performs consistent reads even from within the same transaction. In other words, reading data will be consistent with updates performed from prior queries within the same transaction.</li><li><code>REPEATABLE_READ</code>—Similar to <code>READ_COMMITTED</code> when it comes to reading the information, but<a id="_idIndexMarker584"/> there are some stipulations when it comes<a id="_idIndexMarker585"/> to MySQL’s InnoDB database engines explicitly. Refer to <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read">https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.xhtml#isolevel_repeatable-read</a> for more information on how to consistently lock records for when you need to.</li><li><code>SERIALIZABLE</code>—A stricter ruleset than <code>REPEATABLE_READ</code>. This isolation level is generally used for figuring out concurrency and deadlock-related issues for the database.</li></ul></li>
<li><code>deferrable</code>—Applicable to PostgreSQL only, this setting determines whether constraints can be deferred or checked immediately.</li>
<li><code>logging</code>—A function that Sequelize will pass a query and its parameters as arguments.</li>
</ul>
<p>Sequelize offers constant variables for convenience<a id="_idIndexMarker586"/> when setting isolation levels, like so:</p>
<pre class="source-code">
const Sequelize = require('@sequelize/core');
sequelize.transaction({
    isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.
                    SERIALIZABLE
}, (tx) =&gt; { /* ... */ });</pre>
<p>We can also set the transaction’s isolation level on an instance level by setting the <code>isolationLevel</code> option when initializing Sequelize, as follows:</p>
<pre class="source-code">
new Sequelize('db', 'user', 'pw', {
    isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.
                    READ_COMMITTED
});</pre>
<p>Now, any subsequent transactions<a id="_idIndexMarker587"/> will use the <code>READ_COMMITTED</code> level by default. These isolation levels<a id="_idIndexMarker588"/> pertain to reading data. In the next section, we will go over locking mechanisms for writing data to the database.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/>Locking rows with Sequelize</h2>
<p>Sometimes, our application<a id="_idIndexMarker589"/> requires us to temporarily lock information while performing<a id="_idIndexMarker590"/> a transaction and prevent other transactions from committing to the same table or row. Database practitioners may know this mechanism as a <code>SELECT FOR UPDATE</code> query. You can see an example of such a query in the following code snippet:</p>
<pre class="source-code">
sequelize.transaction((tx) =&gt; {
    const seat = Seats.findOne({
        where: { venue: 1, row: 5, seat: 13 }
        transaction: tx,
        lock: true
    });
    // ... more queries ...
});</pre>
<p>Presuming that each <code>row</code> and <code>seat</code> instance is unique per <code>venue</code> instance, the previous example will lock that particular seat’s record until the transaction has been committed or rolled back.</p>
<p>Suppose we wanted to retrieve a list of seats that were not in a pending transaction. If our DBMS supports the <code>SKIP LOCKED</code> command, then we can use a <code>skipLocked: true</code> configuration option when querying data. To demonstrate the <code>SKIP LOCKED</code> feature, we can begin by adding a locked record for a particular seat, as follows:</p>
<pre class="source-code">
const tx1 = await sequelize.transaction();
const seat = Seats.findOne({
    where: { venue: 1, row: 5, seat: 13 }
    transaction: tx1,
    lock: true
});</pre>
<p>Next, the following query<a id="_idIndexMarker591"/> will use the <code>SKIP LOCKED</code> rule and return any applicable row<a id="_idIndexMarker592"/> that is not locked by another pending transaction (in this particular case, row 5, seat 13):</p>
<pre class="source-code">
const tx2 = await sequelize.transaction();
const seats = Seats.findAll({
    where: { venue: 1 }
    transaction: tx2,
    lock: true,
    skipLocked: true
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">MySQL added support for <code>SKIP LOCKED</code> from version 8.0.1. This book’s code base will not require <code>skipLocked</code>, but if you are using an older version and try to use <code>skipLocked</code>, then Sequelize will silently omit the <code>SKIP LOCKED</code> command from the query and may yield unexpected behaviors or results.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor156"/>Using life cycle events for transactions</h2>
<p>Sequelize only offers one life cycle—even<a id="_idIndexMarker593"/> for transactions—explicitly at the moment. This life cycle<a id="_idIndexMarker594"/> event, named <code>afterCommit</code>, can be used for both managed and unmanaged transactions. This event will not be triggered if the transaction gets rolled back, nor can the event modify its transaction object (unlike traditional life cycle events).</p>
<p>To invoke the <code>afterCommit</code> hook, we can add the event to the transaction’s instance, like so:</p>
<pre class="source-code">
sequelize.transaction((tx) =&gt; {
    tx.afterCommit((trx) =&gt; {
        // … your logic here ...
    });
    // ... queries using tx ...
});</pre>
<p>We can append <code>afterCommit</code> events to an entire model<a id="_idIndexMarker595"/> via the <code>afterSave</code> event. A good use case<a id="_idIndexMarker596"/> for using <code>afterCommit</code> is sending serialized data to some other service, application, blockchain database, and so on. Here is an example of how to use <code>afterCommit</code>:</p>
<pre class="source-code">
Seats.afterSave((instance, options) =&gt; {
    if (options.transaction) {
        // appending afterCommit to the transaction instance here
        options.transaction.afterCommit(() =&gt; { /* your logic here */ });
        return;
    }
    // code will continue here if we did not save under a transaction
});</pre>
<p>So far, we have gone over the different kinds of transactions<a id="_idIndexMarker597"/> that Sequelize offers, namespace environments<a id="_idIndexMarker598"/> for transactions, isolation levels, locking, and life cycle events. Using a combination of these skillsets, we can finally start implementing some of this knowledge into our application. </p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor157"/>Putting it all together</h1>
<p>Now that we have gone over the core tenets<a id="_idIndexMarker599"/> of using transactions with Sequelize, we can begin adding to our <em class="italic">Avalon Airlines</em> project. Our business partner just informed us that the investors want a small demonstration for booking a flight without processing a payment. For this task, we will need to add a couple of new files, update the <code>BoardingTicket</code> and <code>FlightSchedule</code> models, add new routes to our express application, and install a new Node.js package.</p>
<p>First, let us begin by adding<a id="_idIndexMarker600"/> the new Node.js package that the project will require. This package is known as Luxon (<a href="https://moment.github.io/luxon/">https://moment.github.io/luxon/</a>), which is a date-and-time<a id="_idIndexMarker601"/> JavaScript library. Use the following command to add the package:</p>
<pre>npm i --save luxon</pre>
<p>Next, we will want to modify a life cycle event that exists within the <code>BoardingTicket</code> model located in <code>models/boardingticket.js</code> by adding/changing the following highlighted code:</p>
<pre class="source-code">
BoardingTicket.beforeSave('checkSeat', async (ticket, options) =&gt; {
    const newSeat = ticket.getDataValue('seat');
    const { transaction } = options;
    if (ticket.changed('seat')) {
      const boardingTicketExists = await BoardingTicket.findOne({
        where: {
          seat: newSeat
        },
        transaction,
      });
      if (boardingTicketExists !== null) {
        throw new Error(`The seat ${newSeat} has already been taken.`);
      }
    }
  });</pre>
<p>The other model that we will need<a id="_idIndexMarker602"/> to add a few updates to is the <code>FlightSchedule</code> model located in <code>models/flightschedule.js</code>. Add the following line of code to the top of the file:</p>
<pre class="source-code">
const { DateTime } = require('luxon');</pre>
<p>After that, add another validation within the <code>validate</code> object just below the <code>validDestination</code> method, as follows:</p>
<pre class="source-code">
      validateDepartureTime() {
        const dt = DateTime.fromJSDate(this.departureTime);
        if (!dt.isValid) {
          throw new Error("Invalid departure time");
        }
        if (dt &lt; DateTime.now()) {
          throw new Error("The departure time must be set 
                           within the future");
        }
      },</pre>
<p>Now, we can add a new folder<a id="_idIndexMarker603"/> and file located at <code>routes/flights.js</code> from the project’s main directory and add the following lines of code to load the appropriate modules and files:</p>
<pre class="source-code">
const { DateTime } = require("luxon");
const models = require("../models");</pre>
<p>For our first flight-related route, we will need to find a way to create our airplanes first. Looking at the attributes from <code>models/airplane.js</code>, we can determine that we will need a model name and the number of seats for each airplane. The code is illustrated in the following code snippet:</p>
<pre class="source-code">
async function createAirplane(req, res) {
    const { name, seats } = req.body;</pre>
<p>Within the <code>POST</code> data, we will expect <code>name</code> and <code>seats</code> values to be sent to our Express application. Now, we can add the airplane creation logic, along with closing and exporting the function, as follows:</p>
<pre class="source-code">
    try {
        const airplane = await models.Airplane.create({
            planeModel: name,
            totalSeats: seats,
        });
        return res.json(airplane);
    } catch (error) {
        res.status(500).send(error);
    }
}
exports.createAirplane = createAirplane;</pre>
<p>Our next function<a id="_idIndexMarker604"/> will be for creating flight schedules. We will require <code>airplaneId</code>, <code>origin</code>, <code>destination</code>, and <code>departure</code> <code>POST</code> values for creating flight schedules, as follows:</p>
<pre class="source-code">
async function createSchedule(req, res) {
    const { airplaneId, origin, destination, departure } = 
    req.body;</pre>
<p>First, let us validate and parse the departure time into a native <code>DateTime</code> object, like so:</p>
<pre class="source-code">
        const dt = DateTime.fromISO(departure);
        if (!dt.isValid) {
            return res.status(400).send("invalid departure 
                                         time");
        }</pre>
<p>Next, we will want to check whether the airplane actually exists, so we’ll execute the following code to find out:</p>
<pre class="source-code">
    try {
 const plane = await models.Airplane.findByPk(airplaneId);
        if (!plane) {
            return res.status(404).send("airplane does not 
                                         exist");
        }</pre>
<p>If the airplane does exist, we will want to create a flight schedule for it. We will wrap the creation in a transaction to ensure that creating the schedule, and associating the schedule with a particular airplane, would yield no errors. </p>
<p>For this particular demonstration, a transaction is not necessary, but in a real-world application, we would want to make<a id="_idIndexMarker605"/> sure that an airplane is not overbooked based on routing and departing times. The transaction block would look like this:</p>
<pre class="source-code">
        const flight = await sequelize.transaction(async 
        (tx) =&gt; {
   const schedule = await models.FlightSchedule.create({
                originAirport: origin,
                destinationAirport: destination,
                departureTime: dt,
            }, { transaction: tx });</pre>
<p>We follow this by setting the associated<a id="_idIndexMarker606"/> airplane, returning the schedule record, finishing the transaction, and rendering a response with <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) data, like so:</p>
<pre class="source-code">
            await schedule.setAirplane(plane, 
            { transaction: tx });
            return schedule;
        });
       return res.json(flight);</pre>
<p>The last part of this file is capturing any errors from the previous <code>try</code> block and exporting the <code>createSchedule</code> function, like so:</p>
<pre class="source-code">
    } catch (error) {
        return res.status(500).send(error);
    }
}
exports.createSchedule = createSchedule;</pre>
<p>Now, we can create a new file located at <code>routes/tickets.js</code> that will serve as the route for booking our actual flight. For demonstration<a id="_idIndexMarker607"/> purposes, we will omit complex functionalities such as determining prices and customer sessions and fill in those details with constant values. After creating the file, we would load our models at the top of the file, as follows:</p>
<pre class="source-code">
const models = require("../models");</pre>
<p>For our <code>bookTicket</code> method, we will need a <code>scheduleId</code> and <code>seat</code> <code>POST</code> parameter, in addition to opening a transaction for creating a ticket. Here’s how we can add these:</p>
<pre class="source-code">
async function bookTicket(req, res) {
    try {
        const { scheduleId, seat } = req.body;
        const t = await sequelize.transaction(async (tx) =&gt; {</pre>
<p>Check to see whether the <code>FlightSchedule</code> model exists by executing the following code:</p>
<pre class="source-code">
const schedule = await models.FlightSchedule.findByPk
(scheduleId, {transaction: tx});
            if (!schedule) {
                throw new Error("schedule could not be 
                                 found");
            }</pre>
<p>Let’s create our new boarding ticket, like so:</p>
<pre class="source-code">
const boardingTicket = await models.BoardingTicket.create({
                seat,
            }, { transaction: tx });</pre>
<p>We’ll now set our boarding ticket’s associations and then return the ticket while completing the transaction, as follows:</p>
<pre class="source-code">
            // this is where we would set a customer if we had an application with authentication, etc.
            // await ticket.setCustomer(customerId, { transaction: tx });
            await schedule.addBoardingTicket(boardingTicket, { transaction: tx });
    
            return boardingTicket;
        });
        return res.json(t.toJSON());</pre>
<p>Capture any errors<a id="_idIndexMarker608"/> and export the function, like so:</p>
<pre class="source-code">
    } catch (error) {
        return res.status(400).send(error.toString());
    }
}
exports.bookTicket = bookTicket;</pre>
<p>Next, we will want to add<a id="_idIndexMarker609"/> a module called <code>body-parser</code> that helps transform different <code>req.body</code> in Express). For more information, visit <a href="https://github.com/expressjs/body-parser">https://github.com/expressjs/body-parser</a>. We can install and add the package to our <code>package.json</code> file with the following command:</p>
<pre>npm i --save body-parser</pre>
<p>Our last file to edit would be the <code>index.js</code> file within the project’s main directory. We will want to add the following<a id="_idIndexMarker610"/> module after requiring the express module on the first line:</p>
<pre class="source-code">
const bodyParser = require("body-parser");</pre>
<p>Just below the <code>const models = require("./models");</code> line, we will want to add our new exported functions. Here’s how we do this:</p>
<pre class="source-code">
const { bookTicket } = require("./routes/tickets")
const { createAirplane, createSchedule } = require("./routes/flights");</pre>
<p>Just above the first route, <code>app.get('/', …)</code>, add the following line of code for JSON <code>POST</code> support:</p>
<pre class="source-code">
app.use(bodyParser.json({ type: 'application/json' }));</pre>
<p>Next, we will want to add the following line of code above the <code>app.get('/airplanes/:id', ...)</code> line for our <code>createAirplane</code> route:</p>
<pre class="source-code">
app.post('/airplanes', createAirplane);</pre>
<p>Then, we can add our remaining new routes just above the <code>app.listen(3000, ...)</code> line, like so:</p>
<pre class="source-code">
app.post('/schedules', createSchedule);
app.post('/book-flight', bookTicket);</pre>
<p>Since all of our changes have been committed, we can now run our application by executing the following command:</p>
<pre>npm run start</pre>
<p>In order to test our application, we can<a id="_idIndexMarker611"/> use cURL or any HTTP REST utility such as Postman (<a href="https://www.postman.com/">https://www.postman.com/</a>) or HTTPie (<a href="https://httpie.io/">https://httpie.io/</a>). Let us create a new airplane<a id="_idIndexMarker612"/> before a flight schedule, as follows:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d "{\"name\": \"A320\", \"seats\": -1}" http://127.0.0.1:3000/airplanes</pre>
<p>We should see a response similar to this:</p>
<pre>{"name":"SequelizeValidationError","errors":[{"message":"A plane must have at least one seat","type":"Validation error","path":"totalSeats","value":-1,"origin":"FUNCTION","instance":{"id":null,"planeModel":"A320","totalSeats":-1,"updatedAt":"2022-02-21T16:27:18.336Z","createdAt":"2022-02-21T16:27:18.336Z"},"validatorKey":"min","validatorName":"min","validatorArgs":[1],"original":{"validatorName":"min","validatorArgs":[1]}}]}</pre>
<p>This particular A320 model<a id="_idIndexMarker613"/> has up to 150 seats available at a time for customers. When we adjust our total number of seats available, our new command would look like this:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d "{\"name\": \"A320\", \"seats\": 150}" http://127.0.0.1:3000/airplanes</pre>
<p>The preceding command should return a response similar to this:</p>
<pre>{"id":1,"planeModel":"A320","totalSeats":150,"updatedAt":"2022-02-21T15:49:19.883Z","createdAt":"2022-02-21T15:49:19.883Z"}</pre>
<p>We will want to keep the <code>id</code> value in mind for the next command when creating a schedule:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d "{\"airplaneId\": 1, \"origin\": \"LAX\", \"destination\": \"ORD\", \"departure\": \"2060-01-01T14:00:00Z\"}"  http://127.0.0.1:3000/schedules</pre>
<p>The preceding request should result in an error that looks similar to this:</p>
<pre>{"name":"SequelizeValidationError","errors":[{"message":"Invalid destination airport","type":"Validation error","path":"destinationAirport","value":"ORD","origin":"LAX","instance":{"id":null,"originAirport":"LAX","destinationAirport":"ORD","updatedAt":"2022-02-21T18:11:02.108Z","createdAt":"2022-02-21T18:11:02.108Z"},"validatorKey":"isIn","validatorName":"isIn","validatorArgs":[["MIA","JFK","LAX"]],"original":{"validatorName":"isIn","validatorArgs":[["MIA","JFK","LAX"]]}}]}</pre>
<p>We currently do not fly to Chicago’s O’Hare International Airport! The new destination will now be Miami using the <code>MIA</code> code, as illustrated here:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d "{\"airplaneId\": 1, \"origin\": \"LAX\", \"destination\": \"MIA\", \"departure\": \"2060-01-01T14:00:00Z\"}" http://127.0.0.1:3000/schedules</pre>
<p>The response should look similar to this:</p>
<pre>{"id":1,"originAirport":"LAX","destinationAirport":"MIA","departureTime":"2060-01-01T14:00:00.000Z","updatedAt":"2022-02-21T18:34:46.049Z","createdAt":"2022-02-21T18:34:46.038Z","AirplaneId":1}</pre>
<p>For the booking request, we will need the previous response’s <code>id</code> value and a seating assignment, as follows:</p>
<pre>curl -X POST -H "Content-Type: application/json" -d "{\"scheduleId\": 1, \"seat\": \"1A\"}" http://127.0.0.1:3000/book-flight</pre>
<p>The response would look similar to this:</p>
<pre>{"isEmployee":{},"id":1,"seat":"1A","updatedAt":"2022-02-21T18:55:30.837Z","createdAt":"2022-02-21T18:55:30.837Z"}</pre>
<p>If we were to repeat the previous command, an error message would be shown to us indicating that the seat has already been taken, as shown here:</p>
<pre>Error: The seat 1A has already been taken.</pre>
<p>That wraps up our changes to the <em class="italic">Avalon Airlines</em> project. We implemented a way to create airplanes and new flight<a id="_idIndexMarker614"/> schedules and assign boarding tickets with transactions. This should complete the requirements for our next investor meeting.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor158"/>Summary</h1>
<p>In this chapter, we went through the differences between managed and unmanaged transactions, using CLS for global scoping transactions, the supported isolation levels, applicable life cycle events, and locking transactions. </p>
<p>In the next chapter, we will be covering how to handle customized, JSON, and <strong class="bold">binary large object</strong> (<strong class="bold">BLOB</strong>) data directly from Sequelize to the DBMS. The following chapter will also contain further instructions on completing the <em class="italic">Avalon Airlines</em> project.</p>
</div>
</div></body></html>