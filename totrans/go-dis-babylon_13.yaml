- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Converting the Application to a PWA
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用转换为PWA
- en: Over the course of the last couple of chapters, it may have started to become
    clear that we are closing in on the end of our journey. Passing through the sweeping,
    vast countryside that is Babylon.js, we’ve seen and done much, and Space-Truckers
    is a functionally complete game thanks to our efforts. Now, we have one last stretch
    on the highway to cover in this chapter before we hit the off-ramp to the side-streets
    of [*Chapter 14*](B17266_14_Final_AM.xhtml#_idTextAnchor290), *Extended Topics,
    Extended* chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，可能已经逐渐变得明显，我们正在接近旅程的终点。穿越Babylon.js的广阔乡村，我们看到了很多，也做了很多，Space-Truckers由于我们的努力已经是一个功能完整的游戏。现在，在我们进入第14章的“扩展主题，扩展”章节的旁路之前，我们还需要在本章中完成高速公路上的最后一程。
- en: Just because we’re close to the end doesn’t mean we are there yet – close doesn’t
    count when it comes to Space-Truckers or orbital mechanics, only horseshoes and
    hand grenades. We’ve still got some road ahead of us, Space-Trucker, and there’s
    still time before we hit the limit on our hours of service, so let’s drive!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们接近了终点，但这并不意味着我们已经到达那里——在Space-Truckers或轨道力学方面，接近并不算数，只有马蹄铁和手榴弹才算数。Space-Trucker，我们前面还有一段路要走，在我们达到服务时间限制之前还有时间，所以让我们继续前进吧！
- en: In this chapter, we are going to expose the intersection between Babylon.js
    and **Progressive Web Applications** (**PWAs**). A PWA is a middle space, a hybrid
    between the browser-based traditional web application (whatever that means these
    days) and a native desktop application. They can be browsed as a website can be,
    installed as an app can be, and run offline without an internet connection. Users
    can also find and install PWAs from their device or major app store – whether
    Google Play, Microsoft, and Apple. This gives developers greater space to allow
    potential users to discover their app while requiring little cost and effort to
    achieve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将揭示 Babylon.js 与 **渐进式网络应用**（**PWAs**）之间的交集。PWA 是一个中间空间，是基于浏览器的传统网络应用（无论这些天意味着什么）和原生桌面应用之间的混合体。它们可以像网站一样浏览，像应用一样安装，并且在没有互联网连接的情况下离线运行。用户还可以从他们的设备或主要的App商店中找到并安装PWA——无论是Google
    Play、Microsoft还是Apple。这为开发者提供了更大的空间，允许潜在用户发现他们的应用，同时实现成本和努力都相对较低。
- en: Important Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Apple’s support for PWAs is far behind other providers. There are some serious
    restrictions and limitations placed on PWAs running on iOS and they can have their
    own quirks when it comes to support for different features. See the excellent
    third-party site [https://firt.dev/notes/pwa-ios/](https://firt.dev/notes/pwa-ios/)
    for the latest feature support for Safari and iOS.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 对 PWAs 的支持远远落后于其他提供商。对在iOS上运行的PWA施加了一些严重的限制和限制，并且在支持不同功能时可能会有自己的怪癖。请参阅优秀的第三方网站
    [https://firt.dev/notes/pwa-ios/](https://firt.dev/notes/pwa-ios/)，了解Safari和iOS的最新功能支持。
- en: Converting our existing web app to a PWA is simple and easy, but it does require
    some changes to the application. A Service Worker is needed for offline support
    and a manifest is needed to describe the characteristics of our PWA. This includes
    icons, a description, and potentially even screenshots for store submissions.
    However, there is one final feature that Space-Truckers is missing that we’ll
    be implementing in this chapter (it wouldn’t be a *Going the Distance* chapter
    if we didn’t have something of this sort, would it?).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的现有网络应用转换为PWA既简单又容易，但确实需要对应用进行一些修改。需要一个Service Worker来支持离线功能，需要一个清单来描述我们的PWA的特性。这包括图标、描述，甚至可能还有用于商店提交的截图。然而，Space-Truckers缺少的一个最终特性我们将在本章中实现（如果我们没有这样的东西，这还算得上是“走得更远”的章节吗？）。
- en: This feature is one that has historically led to countless arguments and strained
    relationships among siblings and besties alike. A feature that has enabled bragging
    rights going back in time to the glory days of classics such as *Galaga*, *Pac-Man*,
    and *Donkey Kong*. This feature, of course, is a high score board. We’re going
    for a scoreboard that’s a bit more modern than the ones from those days because
    our scoreboard will save more than just the top 10 high scores; it will also retain
    those scores between application launches and computer restarts by saving data
    to the **IndexedDB**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在历史上导致了无数争论和兄弟姐妹、好朋友之间的紧张关系。这个功能使得人们可以吹嘘自己的高分，回想起那些经典的荣耀日子，如 *Galaga*、*Pac-Man*
    和 *Donkey Kong*。当然，这个功能是一个高分榜。我们追求的是一个比那些日子稍微现代一点的计分板，因为我们的计分板将保存不仅仅是前 10 名的高分；它还将通过将数据保存到
    **IndexedDB** 来保留这些分数在应用程序启动和计算机重启之间的状态。
- en: That’s the extent of the plan for this chapter – unlike previous chapters, there’s
    far less conceptual and theoretical discussion needed, so let’s get started. First
    though, let’s take a quick glance at the *Technical Requirements section* for
    this chapter. There’s a bit of a change from the previous ones, and that’s because,
    as we’ll shortly learn, PWAs have a specific set of hosting requirements that
    must be met.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章计划的全部内容——与之前的章节不同，这里需要的概念性和理论性讨论要少得多，所以让我们开始吧。不过，首先让我们快速浏览一下本章的 *技术要求部分*。与之前的不同，这是因为，正如我们很快就会了解到的那样，PWA
    有一些特定的主机要求必须满足。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Introduction to PWAs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWA 简介
- en: Converting the Space-Truckers Application into a PWA
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Space-Truckers 应用程序转换为 PWA
- en: Using IndexDB to Persist Scores
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IndexDB 持久化分数
- en: Storing and Displaying High Scores
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和显示高分
- en: Technical Requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has new tech requirements that, although low to no cost, do require
    some decisions and potentially a bit of research on your part to help get you
    to the specific outcome that works best for your project. After talking about
    the **Secure Sockets Layer** (**SSL**) certificate requirements, we’ll go over
    some of the more popular options for hosting your PWA.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有新的技术要求，尽管成本很低甚至没有成本，但确实需要您做出一些决定，并可能需要进行一些研究，以帮助您达到最适合您项目的具体结果。在讨论 **安全套接字层**（**SSL**）证书要求之后，我们将介绍一些托管您的
    PWA 的更受欢迎的选项。
- en: Hosting Requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机要求
- en: To explain it briefly, SSL is a mechanism through which a client can verify
    the identity of a particular server and establish an encrypted communications
    channel. It’s literally the ‘s’ in HTTPS! An SSL connection is a requirement for
    a PWA without exception. Even though there are no exceptions, there actually is
    one exception, and that is the localhost loop-back address, to make testing easier.
    Obtaining a valid SSL certificate in most cases is free and easy to carry out.
    Depending on your hosting setup, SSL support might even be built into the hosting
    platform! Check the documentation for your specific provider to learn more about
    how to obtain and bind a site to a certificate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，SSL 是一种机制，通过它客户端可以验证特定服务器的身份并建立加密的通信通道。它实际上是 HTTPS 中的“s”！SSL 连接是 PWA 的一个必要条件，没有例外。尽管没有例外，实际上有一个例外，那就是
    localhost 回环地址，这使得测试更加容易。在大多数情况下，获取有效的 SSL 证书是免费且易于执行的。根据您的托管设置，SSL 支持甚至可能已经集成到托管平台中！请查阅您特定提供商的文档，了解更多有关如何获取和绑定站点到证书的信息。
- en: Options for Hosting your PWA
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管您的 PWA 的选项
- en: 'There’s nothing special about a hosting provider with regards to making an
    application into a PWA; any public-facing website that supports SSL has the capability
    to host a PWA. Some environments may make the organization and the process around
    hosting an SSL or HTTPS-based web app harder or easier, so here is a table listing
    some of the major hosting options:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序制作成 PWA 方面，主机提供商并没有什么特别之处；任何支持 SSL 的公开网站都有能力托管 PWA。某些环境可能会使围绕 SSL 或 HTTPS
    基于的 Web 应用程序的组织和流程变得更容易或更难，因此这里有一个表格列出了一些主要的托管选项：
- en: '![](img/Table_13.01_B17266.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_13.01_B17266.jpg)'
- en: GitHub Pages is one of the easiest options if you’re hosting the source of the
    application in GitHub already. Deploying to a GH page site involves pushing commits
    to a specially named (and never merged) branch. What gets committed in our case
    is essentially the output of `npm run build` – the `dist/ folder` and all its
    contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序源代码已经在 GitHub 上托管，GitHub Pages 是一个最简单的选择。部署到 GH 页面站点涉及将提交推送到一个特别命名的（且从未合并的）分支。在我们的情况下，提交的内容实际上是
    `npm run build` 的输出——`dist/ 文件夹`及其所有内容。
- en: '`.github/workflows` folder for the details.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`.github/workflows` 文件夹包含详细信息。'
- en: Google and AWS Static Sites are both unique products that nevertheless perform
    the same essential services as the previous two. AWS offers static websites via
    AWS Amplify, while Google also has a similar offering within its Cloud Storage
    product. The reason for the asterisks on these services is that the base products
    do not support custom domains nor HTTPS served over those custom domains, at least
    not out of the box. More work is needed on the developer’s part to add the other
    infrastructure components (such as an HTTPS proxy) that are necessary to accomplish
    and fulfill the requirements for custom domains and SSL or HTTPS. See the documentation
    provided in the next section for more information on how to do this – we don’t
    have enough road left in front of us to swerve into the weeds following this topic!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Google 和 AWS 静态站点都是独特的产品，尽管如此，它们仍然提供了与之前两个相同的基本服务。AWS 通过 AWS Amplify 提供静态网站，而
    Google 也在其云存储产品中提供了类似的服务。这些服务旁边带有星号的原因是，基础产品不支持自定义域名，也不支持在这些自定义域名上提供 HTTPS，至少不是默认情况下。开发者需要做更多工作来添加其他必要的基础设施组件（例如
    HTTPS 代理），以实现和满足自定义域名和 SSL 或 HTTPS 的要求。有关如何进行此操作的更多信息，请参阅下一节提供的文档——我们面前没有足够的道路可以避开这个话题的细节！
- en: Resources and Reading
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源和阅读
- en: PWA Builder – [https://pwabuilder.com](https://pwabuilder.com)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWA Builder – [https://pwabuilder.com](https://pwabuilder.com)
- en: The IndexedDB API – [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB API – [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- en: 'Azure Static Web Apps:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 静态 Web 应用：
- en: '[https://docs.microsoft.com/en-us/azure/static-web-apps/](https://docs.microsoft.com/en-us/azure/static-web-apps/)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/static-web-apps/](https://docs.microsoft.com/en-us/azure/static-web-apps/)'
- en: '[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal)'
- en: AWS Amplify – [https://aws.amazon.com/amplify/hosting/](https://aws.amazon.com/amplify/hosting/)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Amplify – [https://aws.amazon.com/amplify/hosting/](https://aws.amazon.com/amplify/hosting/)
- en: Google Static Sites – [https://cloud.google.com/storage/docs/hosting-static-website](https://cloud.google.com/storage/docs/hosting-static-website)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 静态站点 – [https://cloud.google.com/storage/docs/hosting-static-website](https://cloud.google.com/storage/docs/hosting-static-website)
- en: GitHub Pages and PWAs - [https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/](https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Pages 和 PWAs - [https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/](https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/)
- en: 'Service Workers and Workbox:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Service Workers 和 Workbox：
- en: '[https://developer.chrome.com/docs/workbox/service-worker-overview/](https://developer.chrome.com/docs/workbox/service-worker-overview/)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.chrome.com/docs/workbox/service-worker-overview/](https://developer.chrome.com/docs/workbox/service-worker-overview/)'
- en: '[https://developer.chrome.com/docs/workbox/](https://developer.chrome.com/docs/workbox/)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.chrome.com/docs/workbox/](https://developer.chrome.com/docs/workbox/)'
- en: The source code for this chapter is in the `ch13` branch of the Space-Truckers
    GitHub repository - [https://github.com/jelster/space-truckers/tree/ch13](https://github.com/jelster/space-truckers/tree/ch13)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的源代码位于 Space-Truckers GitHub 仓库的 `ch13` 分支中 - [https://github.com/jelster/space-truckers/tree/ch13](https://github.com/jelster/space-truckers/tree/ch13)
- en: Playground URLs are listed in their relevant sections
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操场 URL 列在其相关部分
- en: Introduction to PWAs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWAs 简介
- en: As mentioned earlier in the introduction, a PWA is a sort of hybrid type of
    application that bridges the gap between a web application and a regular desktop
    application. Without additional context, it’s a description that comes close to
    meaninglessness context. It’s not the individual words and it’s not the term “Web
    App” that lacks clarity, so what does it mean for a web app to be “Progressive”?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中先前所述，PWA 是一种介于网络应用程序和常规桌面应用程序之间的混合类型的应用程序。在没有额外上下文的情况下，这是一个几乎无意义的描述。不是个别单词，也不是“Web
    App”这个术语缺乏清晰性，那么对于一个网络应用程序来说，“渐进式”意味着什么呢？
- en: Well, as most of us are aware of course, web browsers have a vastly different
    security model than regular applications or games. JavaScript running in a browser’s
    sandboxed environment has, by design, extremely limited access to the underlying
    machine’s hardware and filesystem. Important to our discussion is the limitation
    placed on scripts, along with the vast range of implementation support in browsers,
    which means that any given web application may or may not have access to certain
    device features and functions. In these types of cases, or when an application
    is being distributed widely across different device and software profiles, it
    is very important for an application to be able to – wait for it – “Progressively”
    and gracefully enhance or degrade its capabilities on-demand based on what the
    hosting device has and is willing to share with the browser app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如我们大多数人当然所意识到的，网络浏览器的安全模型与常规应用程序或游戏大不相同。在浏览器沙盒环境中运行的 JavaScript，按照设计，对底层机器的硬件和文件系统有极其有限的访问权限。对我们讨论来说重要的是对脚本的限制，以及浏览器中广泛的支持实现，这意味着任何给定的网络应用程序可能或可能没有访问某些设备功能和功能。在这些类型的案例中，或者当应用程序被广泛分发到不同的设备和软件配置文件中时，对于应用程序能够根据托管设备拥有的和愿意与浏览器应用程序共享的内容，按需“渐进式”和优雅地增强或降低其功能，这一点非常重要。
- en: 'That takes us to the next question, then: how do PWAs work? There are three
    main defining requirements that a web application must fulfill to be eligible
    to be installed as a PWA by a web browser. These requirements are **SSL**, **Service
    Workers**, and **(Web) Manifests** (**SSM**). So much word salad to digest, so
    little time. Let’s prep a salad fork and dig into these in more detail.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了下一个问题：PWA 是如何工作的？一个网络应用程序必须满足三个主要定义要求，才有资格被网络浏览器安装为 PWA。这些要求是 **SSL**、**Service
    Workers** 和 **(Web) Manifests** （**SSM**）。这么多需要消化的词汇，时间却如此有限。让我们准备一把沙拉叉，更详细地探讨这些内容。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer (or if you just really enjoy confusing people), you can use MMS
    or even SMS for an acronym. You do you!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢（或者如果你只是真的很喜欢让人困惑），你可以使用 MMS 或甚至 SMS 作为首字母缩略词。做你自己吧！
- en: SSL
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL
- en: Conducted over HTTPS, this is a non-negotiable requirement – and for good reason!
    Installing a web app as a PWA expands the capabilities of the app greatly, but
    at the same time, commensurately exposes the host machine and its data to a greater
    risk of malicious or incompetent actors accessing it. Requiring a secure connection
    between the client and server neither compensates for incompetent or bad coding
    nor does it guarantee that the server involved is protected from malicious intent.
    What it does guarantee is that the identity of the hosting site has been verified
    as being what the site says it is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 HTTPS 进行，这是一个不可协商的要求 – 而且原因很好！将网络应用程序作为 PWA 安装大大扩展了应用程序的功能，但同时也相应地使主机机器及其数据面临更大的风险，恶意或不称职的参与者可能会访问它。要求客户端和服务器之间建立安全连接既不能弥补不称职或糟糕的编码，也不能保证涉及的服务器免受恶意意图的侵害。它所保证的是，托管站点的身份已经得到验证，确认为该站点所声称的那样。
- en: Service Workers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Service Workers
- en: Used to fetch and retrieve assets for and from offline use, SW is code loaded
    from a JavaScript file separate from the main application’s code. Running in a
    DOM-less sandbox, an SW is nonetheless the key intermediary between the application
    and the underlying network. An SW enables offline usage of the app in a transparent
    fashion – nothing in the application knows that it is really communicating with
    the SW when it makes a web request for a resource.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以前用于从离线使用中获取和检索资产，SW 是从与主应用程序代码分离的 JavaScript 文件中加载的代码。在无 DOM 的沙盒中运行，SW 仍然是应用程序和底层网络之间的关键中介。SW
    允许应用程序以透明的方式离线使用 – 应用程序中没有任何部分知道当它为资源发出网络请求时，它实际上是在与 SW 通信。
- en: Every time a script, HTML tag, or CSS definition triggers a request from the
    web application, the request is intercepted and handled by the SW. The SW then
    has the choice of either returning the indicated resource to the caller from its
    cache or of refreshing its cache prior to returning the resource. To make this
    even more effective, the SW’s first job upon installation and activation is to
    pre-fetch all the resources and put them into its cache ahead of time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当脚本、HTML 标签或 CSS 定义触发来自 Web 应用程序的网络请求时，该请求会被 Service Worker 拦截和处理。然后，Service
    Worker 可以选择从其缓存中返回指示的资源给调用者，或者刷新其缓存后再返回资源。为了使这一过程更加有效，Service Worker 在安装和激活后的首要任务是预先获取所有资源并将它们提前放入其缓存中。
- en: Web Manifest
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 清单
- en: The last element needed to “unlock” the capabilities of a PWA in a browser is
    a Web Manifest. This is a simple JSON-formatted file that’s usually given an extension
    of `.webmanifest`, and it tells the web browser and other consumers of the manifest
    all sorts of neat information about the application. In addition to containing
    basic information about an application, such as the name, description, and version,
    the manifest contains sections that allow a developer to specify icon images at
    varying sizes and aspects for display by the host OS (e.g., the iOS Home Screen),
    display orientation preferences, screenshots, and even age and content ratings.
    View a full listing of possible elements and what they mean on the Mozilla Developer
    docs site at [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要“解锁”浏览器中 PWA 的功能，需要的是一个 Web 清单。这是一个简单的 JSON 格式文件，通常以 `.webmanifest` 扩展名，它向
    Web 浏览器和其他清单消费者提供了关于应用程序的各种有用信息。除了包含关于应用程序的基本信息，如名称、描述和版本外，清单还包含允许开发者指定图标图像的章节，这些图像可以以不同的尺寸和比例显示在宿主操作系统（例如
    iOS 主屏幕）上，显示方向偏好、截图，甚至年龄和内容评级。在 Mozilla 开发者文档网站上查看可能的元素及其含义的完整列表，请访问 [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest)。
- en: These different pieces of metadata all work together to describe how the application
    should be presented and the parameters of its expected behavior. In addition,
    the Web Manifest is heavily leveraged when listing a PWA in one of the app stores.
    The benefits of being able to define the application’s metadata once for publication
    everywhere should be obvious, but how to easily define values for each of those
    properties is not. Fortunately, as with working with Babylon.js, there are many
    tools and resources available that can help speed things along.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的元数据共同工作，描述了应用程序应该如何呈现以及其预期行为的参数。此外，当在应用商店中列出 PWA 时，Web 清单被大量利用。能够一次性定义应用程序的元数据并在任何地方发布的好处应该是显而易见的，但如何轻松地为这些属性定义值则不是那么简单。幸运的是，就像使用
    Babylon.js 一样，有许多工具和资源可以帮助加快这个过程。
- en: We’ll cover the tools and the mechanics of PWAs shortly but let’s summarize
    what we know about PWAs and how they work first. When users browse to a website
    that is PWA-enabled, an icon appears in the browser indicating that an application
    can be installed for the current site. Clicking the icon transforms what used
    to be a regular website into an offline-capable, Start Menu-pinnable application
    indistinguishable from a native application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍 PWA 的工具和机制，但首先让我们总结一下我们对 PWA 以及它们如何工作的了解。当用户浏览到一个启用了 PWA 的网站时，浏览器中会出现一个图标，表示可以为当前网站安装一个应用程序。点击该图标将原本的普通网站转换为一个离线可用、可固定到开始菜单的应用程序，与原生应用程序无法区分。
- en: 'What allows this to happen are the three specific things that a PWA must have
    properly configured – the SSM trio: (S)SL connections, a (S)ervice Worker to pre-fetch
    and cache resources for offline use, and a Web (M)anifest. Having an SSL connection
    means that the website hosting the PWA is accessed over the HTTPS protocol and
    requires a valid certificate to be obtained for this purpose. SWs are JavaScript
    code components that run in a separate sandbox from the rest of the browser’s
    application code. They intercept requests transparently and return cached resources
    stored locally. The Web Manifest describes everything that a hosting OS and web
    browser need to know to install the PWA. In addition, the Web Manifest also serves
    as an app Store package listing, meaning that for the effort of preparing a single
    store submission, one can make submissions to all of the major app Stores.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使得这一切成为可能的是PWA必须正确配置的三个具体事物——SSM三重奏：（S）SL连接，一个（S）ervice Worker来预先获取和缓存离线使用的资源，以及一个Web（M）anifest。拥有SSL连接意味着托管PWA的网站是通过HTTPS协议访问的，并且需要获得有效的证书来执行此目的。SWs是运行在浏览器应用程序代码的独立沙盒中的JavaScript代码组件。它们透明地拦截请求并返回存储在本地的缓存资源。Web
    Manifest描述了托管操作系统和浏览器需要知道的一切，以便安装PWA。此外，Web Manifest还充当应用商店包列表，这意味着通过准备单个商店提交的努力，可以提交到所有主要的应用商店。
- en: 'Coming up in the next section, we’re going to power up Space-Truckers: The
    Web Application and make it into Space-Truckers: The Progressive Web Application.
    We’ll see how two simple packages, along with a little bit of code and a WebPack
    configuration, are all that’s needed to get the job done. In a way, the simplicity
    and ease of making the conversion could be a bit anticlimactic, but don’t worry
    – we’ll soon thereafter be looking at adding something flashier and with more
    flare when we come to the high score board!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将增强Space-Truckers：Web应用，使其成为Space-Truckers：渐进式Web应用。我们将看到两个简单的包，加上一点代码和WebPack配置，就足以完成这项工作。从某种意义上说，转换的简单性和容易性可能有点令人失望，但别担心——我们很快就会看到，当我们来到高分榜时，我们会添加一些更炫酷、更有特色的东西！
- en: Converting the Space-Truckers application into a PWA
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Space-Truckers应用转换为PWA
- en: As we discussed shortly prior to this section, a hallmark – or signature – feature
    of a PWA is its ability to gracefully adapt to varying conditions and host environments.
    How should the application behave when a network connection is lost? What happens
    when a new version of the app is published? When assets change, how do you ensure
    that any cached versions of the old asset are evicted, and the new ones are stored?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节之前简要讨论的那样，PWA的一个标志性的——或称特征性——功能是其能够优雅地适应不同的条件和托管环境。当网络连接丢失时，应用程序应该如何表现？当发布应用程序的新版本时会发生什么？当资源发生变化时，你如何确保删除任何旧的缓存资源版本，并存储新的版本？
- en: Putting the “P” in PWA
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“P”融入PWA
- en: These are all good questions and present real technical and engineering challenges
    that need to be solved. If you are one of those beautiful, curious, intelligent,
    and slightly mad kinds of people, you should prepare yourself to be disappointed.
    While, again, these are worthy topics to study and understand, this is a case
    where tools have evolved to the point where it is possible to accomplish a lot
    while knowing very little about the underlying technology. It’s possible that
    the overall brevity of this section – or really, of this entire chapter – hasn’t
    escaped notice and that’s a hint at just how easy it is to put the ”P” in PWA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是很好的问题，它们提出了需要解决的真实的技术和工程挑战。如果你是那些美丽、好奇、聪明且有点疯狂的人之一，你应该准备好自己可能会失望。虽然，再次强调，这些都是值得研究和理解的有价值的话题，但这是一个工具已经发展到可以知道很少关于底层技术的情况下完成很多事情的情况。这个部分——或者更确切地说，整个章节——的总体简洁性可能没有逃过你的注意，这只是一个提示，说明了将“P”融入PWA是多么容易。
- en: It’s also possible that the author of this book counted the number of pages
    originally promised and realized that the budgeted page count had been blown quite
    a while back, but nobody’s here to litigate the issue of which is which, are we?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能这本书的作者最初计算了承诺的页数，并意识到预算的页数已经很久以前就超出了，但这里没有人来争论哪个是哪个，对吧？
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*[Why yes, actually. We are paying quite close attention to the page count.
    – The Editors]*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*[是的，实际上，我们非常关注页面数量。 —— 编辑们]*'
- en: Right then. In the interest of getting to the point, and in not further antagonizing
    The Editors, let’s walk through the steps that will make Space-Truckers into a
    PWA.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为了尽快进入正题，并且避免进一步激怒编辑们，让我们一步步来，将 Space-Truckers 转换成一个 PWA。
- en: Step 1 – Installing the Workbox WebPack Plugin
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 – 安装 Workbox WebPack 插件
- en: '**Workbox** is an open source project maintained by Google with the purpose
    of making the creation, usage, and management of SWs smooth and easy. The project
    also maintains a plugin that integrates with **WebPack** (see [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creatingthe Application*) and automatically generates the SW code for you. Install
    it into the project as a developer dependency along with **CopyPlugin** with this
    command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Workbox** 是由 Google 维护的一个开源项目，旨在使 SW 的创建、使用和管理变得顺畅和简单。该项目还维护了一个与 **WebPack**
    集成的插件（见 [*第 4 章*](B17266_04_Final_AM.xhtml#_idTextAnchor070)，*创建应用程序*），并自动为你生成
    SW 代码。使用以下命令将它们作为开发依赖项安装到项目中，与 **CopyPlugin** 一起：'
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`copy-webpack-plugin` is a simple plugin that copies static files from a given
    directory into the output directory with the rest of the webpack output, which
    is handy for when we want to include icons and a **Web Manifest** with the build.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy-webpack-plugin` 是一个简单的插件，它将静态文件从指定的目录复制到与 webpack 输出相同的目录中，这在我们需要将图标和
    **Web Manifest** 包含在构建中时非常有用。'
- en: Step 2 – Configuring WebPack Plugins
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 – 配置 WebPack 插件
- en: 'We’ve made new plugins available to WebPack and now we need to import them
    into `webpack.common.js`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将新插件提供给 WebPack，现在我们需要将它们导入到 `webpack.common.js`：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will instantiate the plugins with their respective options. If you
    recall from [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049), *Establishing
    the Development Workflow*, WebPack plugins run in the order they are defined.
    These new plugins need to run after the HTML template has been injected with the
    bundle and after the destination directory has been cleaned:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用各自的选项实例化插件。如果你还记得 [*第 3 章*](B17266_03_Final_AM.xhtml#_idTextAnchor049)，*建立开发工作流程*，WebPack
    插件的运行顺序是它们被定义的顺序。这些新插件需要在将包注入 HTML 模板和清理目标目录之后运行：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `GenerateSW` and `InjectManifest`, the use cases for which fall under the
    categories “Basic” and “Advanced”. Our needs are currently quite Basic, so we
    are using the `GenerateSW` plugin. Its configuration has flags that specify the
    SW should immediately claim matching clients (for upgrade scenarios) as well as
    skip waiting for older workers to be disposed. Most importantly, we set `maximumFileSizeToCacheInBytes`
    to four times its default value. This is needed because we want as many of our
    assets to be cached locally as possible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateSW` 和 `InjectManifest`，它们的使用案例分别属于“基础”和“高级”类别。我们的需求目前非常基础，所以我们使用 `GenerateSW`
    插件。它的配置有标志指定 SW 应立即声明匹配的客户端（对于升级场景）以及跳过等待旧工作者被销毁。最重要的是，我们将 `maximumFileSizeToCacheInBytes`
    设置为其默认值的四倍。这是因为我们希望尽可能多的资产被本地缓存。'
- en: The `.webmanifest` extension along the way). We’ll create those files in subsequent
    steps after we make some changes to our `index.xhtml` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续步骤中创建这些文件之前，我们将对 `index.xhtml` 文件进行一些修改。
- en: Step 3 – Modifying index.xhtml
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步 – 修改 index.xhtml
- en: 'Two important modifications need to be made to the `index.xhtml` file in the
    repository’s `/public` folder. The first is to add a `<link>` tag for the Web
    Manifest to the files’ `<head>` tag. The second is to add a short `<script>` tag
    that loads and registers the SW on page load:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对存储库 `/public` 文件夹中的 `index.xhtml` 文件进行两项重要修改。第一项是在文件的 `<head>` 标签中添加一个 `<link>`
    标签用于 Web Manifest。第二项是在页面加载时加载和注册 SW 的简短 `<script>` 标签：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In keeping with the graceful enhancement strategy that PWA advocates, our script
    is completely transparent to the rest of the application – when it is present,
    things just work. After checking to see whether the browser supports SWs, the
    `navigator.serviceWorker.register` function is called with the name and path of
    the SW script. This script is generated by `GenerateSW` and output into the `/dist`
    folder, so it shouldn’t trouble you that the file referenced doesn’t seem to exist!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 PWA 倡导的优雅增强策略，我们的脚本对应用程序的其他部分是完全透明的——当它存在时，一切正常工作。在检查浏览器是否支持 SWs 后，使用 SW
    脚本的名字和路径调用 `navigator.serviceWorker.register` 函数。这个脚本由 `GenerateSW` 生成并输出到 `/dist`
    文件夹，所以文件引用似乎不存在不应该让你感到困扰！
- en: At this point, running the app should generate the expected console messages
    indicating successful SW registration and operation. Common problems that may
    occur are an incorrect path or file name for the SW, or an incorrect `GenerateSW`
    configuration. That’s the SW part of the PWA requirements met – let’s fill in
    the one for the missing Web Manifest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，运行应用应该会生成预期的控制台消息，表明成功注册和操作了 SW。可能出现的常见问题包括 SW 的路径或文件名不正确，或者 `GenerateSW`
    配置不正确。这样，PWA 要求中的 SW 部分就满足了——让我们来填写缺失的 Web Manifest。
- en: Step 4 – Adding the Web Manifest
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 添加 Web Manifest
- en: The Web Manifest, as previously mentioned in the *Introduction to PWA* section,
    is the developer-friendly, JSON-formatted file describing the PWA’s attributes
    and characteristics. To maintain the development-time experience, we place the
    Web Manifest into the `/public` folder as a sibling to `index.xhtml`. This makes
    sure that our links work properly when being hosted on `webpack-dev-server` or
    built for a production environment and hosted from the `/dist` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在 *PWA 简介* 部分所述，Web Manifest 是一个开发者友好的、JSON 格式的文件，描述了 PWA 的属性和特征。为了保持开发时的体验，我们将
    Web Manifest 放入 `/public` 文件夹中，作为 `index.xhtml` 的同级文件。这确保了当我们的链接在 `webpack-dev-server`
    上托管或为生产环境构建并从 `/dist` 文件夹托管时，链接能够正常工作。
- en: 'The file is named `manifest.json` in the `/public` folder, which is then renamed
    to `manifest.webmanifest` at build-time. Here are some of the more important properties:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名为 `manifest.json`，位于 `/public` 文件夹中，然后在构建时重命名为 `manifest.webmanifest`。以下是一些更重要属性：
- en: '![](img/Table_13.02_B17266.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Table_13.02_B17266.jpg)'
- en: For the `icons` array, each entry in the array specifies an icon whitespace-separated
    list of sizes, along with a path either directly to a file or to a base file name
    with sizes prefixed – as in, `myicon`, where the file names are `48x48-myicon`
    and `52x52-myicon`. Supplying entries for every possible icon size isn’t necessary,
    although depending on the source image, some distortion and unintended display
    effects could occur. At this point, when the application is run on the local web
    server, the browser should “light up” with the ability to install the site as
    a PWA. If it doesn’t, open the browser developer tools and check for relevant
    console errors. The **Lighthouse** tab in Google Chrome and Microsoft Edge browsers
    can scan websites for many types of problems and optimization issues, including
    those involving PWAs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `icons` 数组，数组中的每个条目指定了一个图标，包括空白分隔的大小列表，以及一个路径，该路径直接指向一个文件或带有大小前缀的基本文件名——例如，`myicon`，其中文件名为
    `48x48-myicon` 和 `52x52-myicon`。为每个可能的图标大小提供条目不是必需的，尽管根据源图像，可能会出现一些扭曲和意外的显示效果。在此阶段，当应用程序在本地
    Web 服务器上运行时，浏览器应该能够“点亮”，允许将网站作为 PWA 安装。如果不行，请打开浏览器开发者工具并检查相关的控制台错误。在 Google Chrome
    和 Microsoft Edge 浏览器的 **Lighthouse** 选项卡中可以扫描网站的各种问题以及优化问题，包括涉及 PWA 的问题。
- en: A great many other properties are defined for the Web Manifest schema, and although
    not many are required, many are recommended. To see more of the properties available
    in the manifest, see [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest).
    It can be difficult to manually create and manage all the different metadata,
    not to mention creating the icons, and that’s why there are tools that can help
    us get the job done fast. One such tool previously discussed was the Workbox project.
    Another tool we haven’t discussed yet though is the **PWABuilder Extension** for
    **VSCode**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Web Manifest 架构定义了许多其他属性，尽管不是很多是必需的，但许多是推荐的。要查看 manifest 中可用的更多属性，请参阅 [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest)。手动创建和管理所有不同的元数据可能很困难，更不用说创建图标了，这就是为什么有工具可以帮助我们快速完成任务。之前讨论过的一个这样的工具是
    Workbox 项目。另一个我们尚未讨论的工具是 **VSCode** 的 **PWABuilder 扩展**。
- en: Using the PWABuilder Extension
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PWABuilder 扩展
- en: Carrying out the previous steps manually has some benefits. You get fine control
    over every detail of the process while learning the internals of everything along
    the way. It’s also a tedious process prone to error. An alternative to the previous
    steps is to use the official **PWABuilder Extension for Visual Studio Code**.
    This extension, built and maintained by the same team that maintains the excellent
    resource [PWABuilder.com](http://PWABuilder.com), makes setting up a PWA quick
    and easy. Aside from generating the source code for various PWA components, the
    extension can validate an existing website to check its PWA readiness status –
    very useful for debugging.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行前面的步骤有一些好处。你在学习过程中可以精细控制每个细节，同时了解所有事物的内部结构。这同样是一个繁琐且容易出错的过程。前面步骤的一个替代方案是使用官方的**Visual
    Studio Code PWABuilder 扩展**。这个扩展由维护着优秀资源[PWABuilder.com](http://PWABuilder.com)的同一团队开发和维护，使得设置PWA变得快速且简单。除了为各种PWA组件生成源代码外，该扩展还可以验证现有网站以检查其PWA准备状态——这对于调试非常有用。
- en: After installing the extension from the **VSCode** extension marketplace, open
    the extension’s left-hand pane to reveal the **Web Manifest** and **Service Worker**
    panes. Click the **+** icons on the respective panes to generate those resources.
    When generating the application icons, depending on your settings, the PWA extension
    may generate the entire range of icon sizes – which can number above 60\. For
    that reason, once the icons have been generated, feel free to go ahead and whittle
    down those files to whatever set of sizes works best. Make sure to update the
    manifest to remove the files!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从**VSCode**扩展市场安装扩展后，打开扩展的左侧面板，以显示**Web Manifest**和**Service Worker**面板。在相应的面板上点击**+**图标以生成这些资源。在生成应用程序图标时，根据你的设置，PWA扩展可能会生成整个范围的图标大小——数量可能超过60个。因此，一旦图标生成，你可以随意将这些文件缩减到最适合的一组大小。务必更新清单以删除这些文件！
- en: When generating the SW, the extension will ask whether you would like a `npm`
    packages (such as `workbox`) and provide a code snippet to copy-paste into your
    `index.xhtml`. Does the code look familiar?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成SW时，扩展会询问你是否想要`npm`包（例如`workbox`），并提供一个代码片段供你复制粘贴到`index.xhtml`中。代码看起来熟悉吗？
- en: The final step when making a PWA is, of course, publishing the application to
    an HTTPS host. The specifics of this depend on your hosting provider, but Google,
    AWS, and Microsoft all provide VSCode extensions that can make publishing a breeze.
    Whichever provider is involved, the goal will be to run the `build` script followed
    by copying all of the files in the `/dist` folder to the root of the hosting website.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 制作PWA的最后一步当然是发布应用程序到HTTPS主机。具体细节取决于你的主机提供商，但Google、AWS和Microsoft都提供了可以简化发布过程的VSCode扩展。无论涉及哪个提供商，目标都是运行`build`脚本，然后将`/dist`文件夹中的所有文件复制到主机网站的根目录。
- en: As promised in this section’s introduction, the tools and technologies available
    make creating and deploying a PWA incredibly simple and fast. A series of four
    straightforward steps are needed – adding two WebPack plugin packages to generate
    the Service Worker, modifying `webpack config`, then `index.xhtml` to register
    the SW and link assets, then finally adding a Web Manifest to describe the extent
    of the changes needed. Whether those changes are performed manually or with the
    help of an extension such as the PWA Builder Extension, there’s a rich world of
    native application functionality that opens up to application developers. We’re
    not seeing the full range and extent of the capabilities of PWAs, so head over
    to [PWABuilder.com](http://PWABuilder.com) to read more about the different cool
    tricks that can be done with them!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节引言中所承诺的，可用的工具和技术使得创建和部署PWA变得极其简单和快速。需要一系列四个简单的步骤——添加两个Webpack插件包以生成Service
    Worker，修改`webpack config`，然后修改`index.xhtml`以注册SW和链接资源，最后添加Web Manifest来描述所需更改的范围。无论这些更改是手动执行还是借助如PWA
    Builder Extension之类的扩展，都会为应用开发者打开一个丰富的原生应用功能世界。我们还没有看到PWAs的全部功能和范围，所以请访问[PWABuilder.com](http://PWABuilder.com)了解更多关于它们可以执行的不同酷炫技巧！
- en: Before we wrap things up for the chapter, there’s one more topic to explore.
    High scores are a staple for arcade-style games such as `IndexedDB` object store
    built into most modern browsers is a great solution for this type of problem,
    and in the following section, we’re going to learn how to create a component to
    make use of it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章内容之前，还有一个话题需要探讨。高分是像`IndexedDB`这样的街机风格游戏的基础，大多数现代浏览器内置的`IndexedDB`对象存储是解决这类问题的绝佳方案，在接下来的章节中，我们将学习如何创建一个组件来利用它。
- en: Using IndexedDB to Persist Scores
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IndexedDB持久化分数
- en: Web developers needing to store information on a local client have traditionally
    had a limited number of options, most of which have had significant drawbacks.
    One of the oldest and simplest methods is the humble browser cookie. These little
    text files stored on the client’s browser are sent to the server alongside every
    request made by the browser client. Because of that, and for similarly related
    reasons, cookies aren’t an efficient or practical solution to many if not most
    client-side storage needs, including our own. For an in-depth examination of the
    different pros and cons of available client-side storage, see [https://web.dev/storage-for-the-web/](https://web.dev/storage-for-the-web/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在本地客户端存储信息的Web开发者传统上只有有限的选择，其中大多数都有显著的缺点。最古老和最简单的方法之一是谦逊的浏览器cookie。这些存储在客户端浏览器上的小文本文件会随着浏览器客户端发出的每个请求一起发送到服务器。正因为如此，以及类似的原因，cookie并不是解决许多如果不是大多数客户端存储需求的效率高或实用的解决方案，包括我们自己的。要深入了解不同客户端存储的优缺点，请参阅[https://web.dev/storage-for-the-web/](https://web.dev/storage-for-the-web/)。
- en: The **IndexedDb Object Store** (**IDB**) is a client-side, browser-sandboxed
    database enjoying a broad spectrum of consistently implemented support across
    major browsers and platforms. While the amount of data a site is allowed to store
    is limited to the disk space that’s available to the browser, our application
    has very modest storage space requirements outside of the assets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**IndexedDb对象存储**（**IDB**）是一个客户端、浏览器沙盒数据库，在主要浏览器和平台上享有广泛且一致实现的跨平台支持。尽管一个网站允许存储的数据量限制在浏览器可用的磁盘空间内，但我们的应用程序除了资产之外，对存储空间的要求非常有限。'
- en: Important Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While it is possible to use IDB as an asset cache for textures, meshes, and
    the like, it is far easier, efficient, and a better fit overall for those assets
    to use the SW set up earlier in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用IDB作为纹理、网格等资产的缓存，但使用本章早期设置的SW（Simple Web）设置对这些资产来说要容易得多、效率更高，并且整体上更适合。
- en: This section’s focus is on the basics of IDB and how we will make use of it
    in our application. After taking a moment to review the foundational elements
    of `IndexedDb`, we’ll put together some code to wrap the lower-level IDB functions
    with more application-layer-friendly helpers. Then, we’ll see how to integrate
    those helpers into a Playground that we’ll use in the next section, *Storing and
    Displaying High Scores*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的重点是IDB的基础知识以及我们如何在我们的应用程序中使用它。在花点时间回顾`IndexedDb`的基础元素之后，我们将编写一些代码，用更适用于应用层的辅助函数包装底层的IDB函数。然后，我们将看到如何将这些辅助函数集成到我们在下一节中使用的Playground中，即*存储和显示高分*。
- en: Learning about IndexedDB
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解IndexedDB
- en: '`IndexedDB` is an official API specification maintained by the **World Wide
    Web Consortium** (**w3c**), an organization also responsible for most web-based
    standards such as HTML and CSS. The specification can be found at [https://w3c.github.io/IndexedDB/](https://w3c.github.io/IndexedDB/)
    but we don’t need to go much deeper here to gain an understanding of how IDB works.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexedDB`是由**万维网联盟**（**w3c**）维护的官方API规范，该组织还负责大多数基于Web的标准，如HTML和CSS。规范可以在[https://w3c.github.io/IndexedDB/](https://w3c.github.io/IndexedDB/)找到，但在这里我们不需要深入探讨以了解IDB的工作原理。'
- en: The wide support in web browsers for the IDB specification gives us confidence
    that we can proceed with using the APIs and that the same code should work the
    same across different browsers – the operative phrase being “should work.” Don’t
    leave off testing across different browsers and versions. Otherwise, you run a
    very high potential risk of running into support issues with end users that aren’t
    using the same setup as you!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IDB规范在Web浏览器中的广泛支持让我们有信心可以继续使用这些API，并且相同的代码应该在不同的浏览器中工作得一样好——关键短语是“应该工作”。不要忽略在不同浏览器和版本之间的测试。否则，你可能会面临很高的风险，遇到使用与您不同的设置的最终用户的支持问题！
- en: When it comes to consuming the IDB API, there are two important things to note.
    First is that they are asynchronous. The second is that operations produce results
    via various event handler functions. When an asynchronous operation is invoked,
    the return value of that function isn’t immediately available – the function doesn’t
    return anything. Further, the operation may or may not succeed. In the case of
    the former, the result is produced by an event handler function specific to the
    operation and object involved. The `IDBOpenRequest` object has event handlers
    such as `onsuccess`, `onerror`, and `onupgradedneeded`, while the `IDBObjectStore`
    object has events such as `transaction.oncomplete`. As some of the names suggest,
    the latter case of an operation failing is handled by the `onerror` handler function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用IDB API时，有两点需要注意。首先，它们是异步的。其次，操作通过各种事件处理函数产生结果。当一个异步操作被调用时，该函数的返回值不会立即可用——该函数不返回任何内容。此外，操作可能成功也可能失败。在前一种情况下，结果由特定于操作和对象的特定事件处理函数产生。`IDBOpenRequest`对象具有`onsuccess`、`onerror`和`onupgradedneeded`等事件处理程序，而`IDBObjectStore`对象具有`transaction.oncomplete`等事件。正如一些名称所暗示的，操作失败的情况由`onerror`处理函数处理。
- en: An important consideration is how the various code paths of the `indexedDB.open`
    function are managed. The `onsuccess` event produces an instance of `IDBDatabase`,
    but that’s only part of the story. When a unique combination of the database name
    and the current schema versions (the first and second parameters to the `Open`
    operation) is requested that does not match any existing object stores, the `onpugradeneeded`
    event is fired. It is at that time that the specific object store has its schema
    created, any indexes added, and any version change migrations performed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的考虑因素是如何管理`indexedDB.open`函数的各种代码路径。`onsuccess`事件产生一个`IDBDatabase`实例，但这只是故事的一部分。当请求一个不匹配任何现有对象存储的数据库名称和当前模式版本的唯一组合（`Open`操作的第一个和第二个参数）时，将触发`onpugradeneeded`事件。正是在那时，特定的对象存储创建了其模式，添加了任何索引，并执行了任何版本更改迁移。
- en: That’s enough foundational concepts for us to start writing some code! We need
    to write some helper code that takes the event-based asynchronous `IndexedDB`
    functions and makes them easy to use in our application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们开始编写代码来说，这些基础概念已经足够了！我们需要编写一些辅助代码，这些代码将基于事件异步的`IndexedDB`函数，并使它们在我们的应用程序中易于使用。
- en: Using IndexedDB
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IndexedDB
- en: All the different needs, scenarios, and data schema definitions involved with
    `IndexedDB` constitute several moving parts. Therefore, our first task is going
    to be crafting a wrapper around these operations that exposes the desired API
    in the form of functions returning Promises. There are several libraries available
    that implement similar helper code, but for our simple needs, it is more illustrative
    and useful to just write the code ourselves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与`IndexedDB`相关的所有不同需求、场景和数据模式定义构成了几个动态部分。因此，我们的第一个任务将是围绕这些操作构建一个包装器，以函数返回Promise的形式公开所需的API。有几个库实现了类似的辅助代码，但为了我们的简单需求，自己编写代码更具说明性和实用性。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following code pattern is common in JavaScript programming as an approach
    for wrapping lower-level or legacy programming interfaces into forms more friendly
    to higher-level applications consuming that functionality. If you’re not familiar
    with this pattern, it’s a useful one to have in your toolbox!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码模式在JavaScript编程中很常见，作为一种将较低级别或遗留编程接口包装成更易于高级应用程序消费的形式的方法。如果您不熟悉这种模式，它是一个值得拥有的工具箱中的有用工具！
- en: The Playground snippet **#U20E4X** contains the code we’ll be using for this
    and the next part, so follow along as we visit some of the more interesting, opaque,
    and complex parts of the sample.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段**#U20E4X**包含了我们将用于本部分和下一部分的内容，所以请跟随我们的步伐，一起探索一些更有趣、更不透明和更复杂的样本部分。
- en: 'We will start by declaring and storing the `SpaceTruckersDb` function as our
    outer scope. The body of this function contains our working set of variables shared
    across our helper functions to maintain the internal state, as well as a `const`
    array of seed `scoreData`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明并存储`SpaceTruckersDb`函数作为我们的外部作用域。该函数的主体包含我们工作集的变量，这些变量在辅助函数之间共享以保持内部状态，以及一个包含种子`scoreData`的`const`数组：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Jumping to the bottom of the function, we are returning an object containing
    the helper functions to retrieve a list of scores as well as to add a new score.
    Alongside these functions is `readyPromise`, used to check for and ensure full
    initialization at a time of the caller’s choosing. Because our needs are so simple,
    we don’t need any additional logic or methods currently.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到函数的底部，我们返回一个包含辅助函数的对象，这些函数用于检索分数列表以及添加新的分数。与这些函数并列的是`readyPromise`，它用于在调用者选择的时间检查并确保完整初始化。由于我们的需求非常简单，目前不需要任何额外的逻辑或方法。
- en: The most complicated logic of the entire sample is the first step – initializing
    the IDB object database and the corresponding object store (or table) that we’re
    using to store the scoring data for our application. This is tricky to handle
    because there are multiple potential branches that the code might need to take
    depending on whether the object store already exists, and further, whether the
    schema version of the object stores matches the most current version requested.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 整个示例中最复杂的逻辑是第一步——初始化IDB对象数据库以及相应的对象存储（或表），我们使用它来存储应用程序的评分数据。这很棘手处理，因为代码可能需要根据对象存储是否已存在以及对象存储的架构版本是否与请求的最新版本匹配来采取多个潜在分支。
- en: That’s what the `onupgradeneeded` event handler must, uh, handle. We start at
    the top of the `readyPromise` delegate’s function body by invoking `indexedDb.open`.
    This returns (one of the only times this happens with the IDB APIs) an `openDbRequest`
    object with its attendant `onerror`, `onsuccess`, and of course, the `onupgradeneeded`
    events. The error logic is simple – reject `readyPromise` and pass through the
    thrown error. The success logic is also simple – just set the database variable
    to `event.target.result` and resolve the promise with it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`onupgradeneeded`事件处理器必须处理的内容。我们从`readyPromise`代理函数体的顶部开始，通过调用`indexedDb.open`来执行操作。这返回（这是IDB
    API中唯一发生这种情况的时候之一）一个带有其伴随的`onerror`、`onsuccess`以及当然的`onupgradeneeded`事件的`openDbRequest`对象。错误逻辑很简单——拒绝`readyPromise`并传递抛出的错误。成功逻辑也很简单——只需将数据库变量设置为`event.target.result`，并用它来解决承诺。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, the `onsuccess` event is not fired on the first run of the script
    for a given `currentSchemaVersion` and `databaseName`. Instead, `onupgradeneeded`
    is raised.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于给定的`currentSchemaVersion`和`databaseName`，脚本第一次运行时不会触发`onsuccess`事件。相反，会触发`onupgradeneeded`。
- en: 'Let’s look at what happens with the `onupgradeneeded` event. After extracting
    the database from the event object, we create `objectStore` itself. The `autoIncrement`
    flag indicates that new records should get an autoincremented key assigned and
    is followed by the creation of the non-unique score index. This is important and
    needed to ensure that the scores are stored in the proper ranked order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`onupgradeneeded`事件会发生什么。在从事件对象中提取数据库之后，我们创建`objectStore`本身。`autoIncrement`标志表示新记录应分配一个自动递增的键，随后是创建非唯一分数索引。这很重要，也是必需的，以确保分数按正确的排名顺序存储：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To proceed after creating the score index, we attach a function to the `oncomplete`
    event of `objectStore.transaction`. This function immediately initiates a `readwrite`
    transaction against the same table (`scoreStore`), which is then used to populate
    the initially empty score table with a set of initial high scores (`scoreData`).
    After adding the seed data to the store, we resolve `readyPromise` – there’s no
    need to wait for the write transaction to complete. That’s the most complicated
    logic we have for this component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建分数索引后继续操作，我们将一个函数附加到`objectStore.transaction`的`oncomplete`事件。这个函数立即对同一表（`scoreStore`）发起一个`readwrite`事务，然后用于用一组初始高分（`scoreData`）填充最初为空的分数表。在将种子数据添加到存储后，我们解决`readyPromise`——不需要等待写事务完成。这是我们为此组件拥有的最复杂的逻辑。
- en: The `retrieveScores` and `addScore` functions are both simpler variations on
    the main themes presented with the `onupgradeneeded` event logic. A `txn` object
    is created with requested permissions of either read-only or read-write. `objectStore`
    is then retrieved from the transaction and used to perform either a `getAll` or
    `add` operation. For `getAll`, the results are produced in the `onsuccess` handler
    of the object returned from `objectStore.getAll`, similarly to how the result
    of `indexedDB.open` is produced in `onsuccess`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieveScores` 和 `addScore` 函数都是基于 `onupgradeneeded` 事件逻辑所展示的主要主题的简化变体。一个带有请求的只读或读写权限的
    `txn` 对象被创建。然后从事务中检索 `objectStore` 并用于执行 `getAll` 或 `add` 操作。对于 `getAll`，结果在 `objectStore.getAll`
    返回的对象的 `onsuccess` 处理程序中产生，类似于 `indexedDB.open` 的结果在 `onsuccess` 中产生。'
- en: Recap
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: As simply as this, we’ve created a reusable component that we can drop into
    the Space-Truckers application as part of a high score screen! Let’s review what
    we’ve learned about `IndexedDB` before we move on to the next section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们已经创建了一个可重用的组件，我们可以将其作为高分屏幕的一部分放入 Space-Truckers 应用程序中！在我们继续下一节之前，让我们回顾一下我们关于
    `IndexedDB` 的学习内容。
- en: IDB is a browser-based storage mechanism that has the capability of storing
    very large amounts of data. While the basic storage means is object-based, IDB
    has the concept of databases containing a set of one or more object stores or
    tables. The schema for each table must be defined at the time of creation or schema
    version upgrade. This is defined by `currentSchemaVersion` passed to the `indexedDB.open`
    function. When the current version doesn’t exist or is lower than the version
    requested, the `onupgradeneeded` event fires.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: IDB 是一种基于浏览器的存储机制，具有存储大量数据的能力。虽然基本存储方式是基于对象的，但 IDB 有包含一组一个或多个对象存储或表的数据库的概念。每个表的架构必须在创建时或架构版本升级时定义。这是通过传递给
    `indexedDB.open` 函数的 `currentSchemaVersion` 来定义的。当当前版本不存在或低于请求的版本时，`onupgradeneeded`
    事件被触发。
- en: During this event, object stores are created, their indexes are defined, and
    their data is populated. When upgrading versions, it’s important to include migration
    logic in this event handler – otherwise, data will be lost! In our case, we don’t
    need to migrate score data and it’s unlikely we’ll need to do much substantially
    to require a schema change soon (see the *Extended Topics* section at the end
    of this chapter for some ideas that might involve doing that).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件期间，创建对象存储，定义它们的索引，并填充它们的数据。在升级版本时，在事件处理程序中包含迁移逻辑很重要——否则，数据将会丢失！在我们的情况下，我们不需要迁移分数数据，而且我们不太可能很快需要进行实质性的更改来要求架构更改（请参阅本章末尾的
    *扩展主题* 部分以获取一些可能涉及该操作的想法）。
- en: Because the pattern of accessing the IDB APIs doesn’t natively support Promises,
    we’ve wrapped the major operations we need in a Promise-capable one. `readyPromise`
    is where the actual initialization and opening of the object store are performed
    and is also where the `onupgradeneeded` logic is housed. Once `readyPromise` resolves,
    the `getScores` and `addScore` methods become operational. These functions also
    return Promises for their respective operations, producing a list of scores or
    a confirmation that a new score was added.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问 IDB API 的模式本身不支持 Promises，我们已将所需的操作包装在一个支持 Promises 的包装器中。`readyPromise`
    是实际初始化和打开对象存储的地方，也是 `onupgradeneeded` 逻辑所在之处。一旦 `readyPromise` 解决，`getScores`
    和 `addScore` 方法就变得可用。这些函数也返回它们各自操作的 Promises，生成分数列表或确认已添加新分数。
- en: 'Our IDB wrapper functions are the tools that we had to build in order to build
    the high score screen – now, it’s time to use them. In the last section of this
    chapter, we’re going to combine what we’ve just learned with the knowledge we’ve
    gained about coroutines and toss in our reusable GUI DialogBox component to create
    a tasty salad that is Space-Truckers: The High Scores!'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 IDB 包装函数是我们为了构建高分屏幕而必须构建的工具——现在，是时候使用它们了。在本章的最后部分，我们将结合我们刚刚学到的内容以及我们关于协程的知识，再加上我们可重用的
    GUI DialogBox 组件，来创建一份美味的沙拉，那就是 Space-Truckers：高分榜！
- en: Storing and Displaying High Scores
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和显示高分
- en: Keeping with the cooking theme that we wrapped up the previous section on, this
    section is all about combining our ingredients into a meal. All the hard work
    and learning have already happened, so this section will go by quickly – all the
    better to start feasting! The Playground at [https://playground.babylonjs.com/#VBMMDZ#23](https://playground.babylonjs.com/%23VBMMDZ%2323)
    is what we’ll use as a live example – keep following along or try to replicate
    the functionality in the sample from the descriptions and snippets mentioned in
    this section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着我们在上一节结束的烹饪主题，本节是关于将我们的成分组合成一顿饭。所有艰苦的工作和学习都已经发生，所以这一节会很快过去——这样我们就可以开始大快朵颐了！我们将使用[https://playground.babylonjs.com/#VBMMDZ#23](https://playground.babylonjs.com/%23VBMMDZ%2323)上的游乐场作为现场示例——继续跟随或尝试在本节描述和代码片段中提到的示例中复制功能。
- en: Important Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t try to eat your computer, or anything that isn’t food – we are just using
    a metaphor, albeit one taken a bit further than needed! In fact, let’s just switch
    themes entirely. For the rest of this section, we’ll go with a classic heist,
    in the style of *Ocean’s Eleven*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试吃掉你的电脑，或者任何不是食物的东西——我们只是在用隐喻，尽管这个隐喻比必要的还要夸张！事实上，让我们完全改变主题。在本节的剩余部分，我们将采用经典的盗窃风格，类似于*Ocean’s
    Eleven*。
- en: The Heist
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《盗窃案》
- en: It won’t be enough to enlist the reluctant aid of the “muscle”, `DialogBox`,
    to throw a list of scores onto the screen and call it a day. Nor is it enough
    to bring in the quick-witted “safe cracker”, `SpaceTruckersDb`, to finish the
    job. If we truly want to pull off this major gig, The High Score, each score needs
    to make a grand entrance. Failing that, they can at least not all appear on the
    screen at the same time as a crowd of raucous monkeys storming a banana barrel.
    In the case of a new high score in need of recording, we need to be able to collect
    the user’s initials in the “traditional” three-letter format used by the arcade
    cabinets of old. We need “brains”to do the thinking. We need our old friend the
    **coroutine** to “come out of retirement for one last job”.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仅依靠“肌肉”即`DialogBox`的不情愿帮助，将分数列表扔到屏幕上并就此结束是不够的。同样，仅引入机智的“破锁匠”`SpaceTruckersDb`来完成工作也是不够的。如果我们真的想完成这项重大任务，即《高分》，每个分数都需要有一个盛大的亮相。否则，至少它们不应该像一群喧闹的猴子冲击香蕉桶一样同时出现在屏幕上。对于需要记录的新高分，我们需要能够以“传统”的三字母格式收集用户的姓名，这种格式是老式街机柜所使用的。我们需要“智慧”来进行思考。我们需要我们的老朋友**协程**“为了最后一次工作而‘退休归来’”。
- en: To summarize our plan in exciting sub-sections, imagine of a compelling montage
    sequence that shows exactly how hard (actually, it’s not hard but roll with it)
    completing the job will be for The Crew, let’s begin.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以激动人心的子章节总结我们的计划，想象一个引人入胜的蒙太奇序列，展示对《队伍》来说完成这项工作有多困难（实际上，并不困难，但请随我这么说），让我们开始吧。
- en: The Muscle
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 肌肉
- en: 'We’ll host the high score display with the `DialogBox` component (see *section
    Building a Reusable Dialog Box Component* in[*Chapter 9*](B17266_09_Final_AM.xhtml#_idTextAnchor186)*,
    Calculating and Displaying Scoring Results*). Scores themselves are hosted within
    a `bodyContainer`. Each score is an object with just the name and score properties.
    The `getScoreTextLine` helper function takes an individual score object and returns
    a formatted string that can be displayed in `TextBox`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`DialogBox`组件来托管高分显示（参见[*第9章*](B17266_09_Final_AM.xhtml#_idTextAnchor186)中的*“构建可重用对话框组件”部分，*计算和显示得分结果*）。分数本身托管在`bodyContainer`中。每个分数都是一个仅包含名称和分数属性的对象。`getScoreTextLine`辅助函数接受一个单独的分数对象，并返回一个可以显示在`TextBox`中的格式化字符串：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Though we expect the `s.score` value to be present, we check for its absence
    anyhow, since the process of adding a new score necessarily precludes the entry
    of a name. We also expect the score to be a whole, integer value, but we convert
    it to a fixed string with zero points beyond the decimal just to be safe. A format
    string is returned that considers the length of the score value’s text representation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们期望`s.score`值存在，但我们仍然检查其缺失，因为添加新分数的过程必然排除了输入姓名的可能性。我们还期望分数是一个完整的整数值，但我们将其转换为固定字符串，小数点后没有零分，以确保安全。返回一个格式字符串，考虑分数值文本表示的长度。
- en: The Safe Cracker
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破锁匠
- en: Persistence logic will be provided by `SpaceTruckersDb` that we built in the
    previous section. Its functions are called and managed by `scoreBoardCoro`. True
    to the current thematic form, there’s not much else to be said about the “safe
    cracker” that won’t be included with our review of the “brains.”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性逻辑将由我们在上一节中构建的 `SpaceTruckersDb` 提供。其函数由 `scoreBoardCoro` 调用和管理。正如当前主题形式所要求的，关于“撬锁者”的更多内容将不会包含在我们的“大脑”审查中。
- en: The Brains
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大脑
- en: 'The `DialogBox` as well as the edit mode for entering new scores. When `scoreBoardCoro`
    is invoked as a function (as part of preparing to run the coroutine – see [*Chapter
    9*](B17266_09_Final_AM.xhtml#_idTextAnchor186)*, Calculating and Displaying Scoring
    Results*, for more), the `newScore` parameter is used to pass in the new high
    score awaiting three-letter branding. If present, the `editHighScores` flag is
    set and a placeholder, `scoreToAdd`, is added to the scores list already retrieved
    by `databaseManager` that is initialized immediately upon entry. Equally, the
    `nameInput` `nameInput.onTextChangedObservable` that limits entries to three characters
    or fewer. Additionally, it will also take action when detecting that the *Enter*
    key was pressed by setting the `editHighScores` flag to `false`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBox` 以及输入新得分的编辑模式。当 `scoreBoardCoro` 作为函数被调用（作为准备运行协程的一部分——见 [*第9章*](B17266_09_Final_AM.xhtml#_idTextAnchor186)*，计算和显示得分结果*，了解更多），`newScore`
    参数用于传入等待三个字母品牌的新高分。如果存在，则设置 `editHighScores` 标志，并将一个占位符 `scoreToAdd` 添加到已由 `databaseManager`
    获取的得分列表中，该列表在进入时立即初始化。同样，`nameInput` 的 `nameInput.onTextChangedObservable` 限制了输入长度为三个字符或更少。此外，当检测到按下
    *Enter* 键时，它还会采取行动，将 `editHighScores` 标志设置为 `false`：'
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the coroutine has finished waiting to exit edit mode, if there’s `newScore`,
    that means the user’s entered their initials and that the score is waiting to
    be saved. We do that before cleaning up the controls involved in gathering the
    user input:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦协程完成等待退出编辑模式，如果有 `newScore`，这意味着用户已经输入了他们的首字母，得分正在等待保存。我们在清理涉及收集用户输入的控制之前完成这项工作：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the controls have been cleaned up, we refresh the `scores` list from storage
    to put everything back into a clean, initial state. If there isn’t a `newScore`,
    the coroutine’s work is done and the job’s complete – the scores were already
    retrieved and displayed at the beginning of the coroutine’s execution. With such
    a skilled Crew and exquisite preparation, it shouldn’t surprise anyone following
    along that the Job of displaying the scores itself is short and sweet.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理了控制之后，我们从存储中刷新 `scores` 列表，将一切恢复到干净、初始的状态。如果没有 `newScore`，协程的工作就完成了，工作也就完成了——得分已经在协程执行的开始时检索并显示。有了这样一支技艺高超的团队和精心的准备，对于跟随的人来说，展示得分的任务本身既简短又甜蜜。
- en: The Job
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作
- en: 'Assembling The Crew was the crucial first step, planning out The Job was the
    second, and now it’s time to execute that plan. Here’s our shortcut to a montage
    of the following steps in a linear sequence of events:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 组建团队是至关重要的第一步，规划工作内容是第二步，现在到了执行计划的时候了。以下是以下步骤在事件线性序列中的蒙太奇快捷方式：
- en: (`yield`) until the “safe cracker” (`databaseManager`) signals that it’s ready.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (`yield`) 直到“撬锁者”（`databaseManager`）表示它已准备好。
- en: Get the `scores` list from the “safe cracker” (`databaseManager`) and put them
    into the `scores` array.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“撬锁者”（`databaseManager`）获取 `scores` 列表并将其放入 `scores` 数组中。
- en: Show “the muscle” (`DialogBox`). Wait for it to fully make its entrance before
    continuing.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示“肌肉”（`DialogBox`）。等待它完全进入后再继续。
- en: 'If “the brains” “sez” there’s another score to add (`newScore`), the following
    happens:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果“大脑”表示还有另一个得分要添加（`newScore`），则会发生以下情况：
- en: The `editHighScores` flag is set
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`editHighScores` 标志被设置'
- en: A placeholder score entry is created sans a name and added to the `scores` list
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个不带名称的占位符得分条目，并将其添加到 `scores` 列表中
- en: Input elements are put into place to collect the player’s initials (`nameInput`
    and `virtualKB`)
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入元素被放置以收集玩家的首字母（`nameInput` 和 `virtualKB`）
- en: A “little bird” (a.k.a an observer) listens for changes in the input element,
    toggling out of the `editHighScores` mode when the *Enter* key is pressed or three
    elements or greater have been entered
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只“小鸟”（即观察者）监听输入元素的变化，当按下 *Enter* 键或输入了三个或更多元素时，会切换出 `editHighScores` 模式
- en: “The host” puts on the show of showing the scores (`displayScores` is called).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “主持人”展示得分（调用 `displayScores`）。
- en: Tension builds on the stakeout as everyone waits for the edit flag to drop (`yield`
    in use while `editHighScores` is `true`).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在等待编辑标志落下（当`editHighScores`为`true`时使用`yield`）的过程中，紧张感逐渐升级。
- en: Prepare the getaway, but first, have “the brains” scan the newly-“liberated”
    score (`scoreToAdd`).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备逃跑，但首先，“大脑”扫描新“解放”的分数（`scoreToAdd`）。
- en: Before jumping into the getaway car, “the host” puts on a smoke-and-mirrors
    show (clears and re-displays the scores from storage).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在跳上逃跑车辆之前，“主持人”上演了一场烟雾弹表演（清除并重新显示存储中的分数）。
- en: We see The Crew walking off into the sunset having successfully completed The
    Job. The credits roll and lights go up.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到《船员》团队成功完成工作后走向夕阳。字幕滚动，灯光亮起。
- en: '![Figure 13.1 – The Space-Truckers high score board in add or edit mode'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – 在添加或编辑模式下的《太空卡车手》高分排行榜'
- en: '](img/Figure_13.01_B17266.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.01_B17266.jpg)'
- en: Figure 13.1 – The Space-Truckers high score board in add or edit mode
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 在添加或编辑模式下的《太空卡车手》高分排行榜
- en: There are no plans for a sequel (yet…) – however, the extended edition (director’s
    cut) shows what happens after the plucky heisters have finished their job, and
    that’s the nitty-gritty of integrating the crafted code from the snippet discussed
    previously with the overall Space-Truckers application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有计划制作续集（…） – 然而，扩展版（导演剪辑版）展示了勇敢的盗贼完成工作后的情况，以及将之前讨论的代码片段与整体《太空卡车手》应用程序整合的细节。
- en: The Integration
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合
- en: The beauty of the `DialogBox` component is that it can be slotted into an existing
    Scene. This is a good thing because we want to be able to display the screen in
    two separate places – `HighScoreScreen` is the high-level wrapper function that
    instantiates and starts the `ScoreBoard` coroutine, returning the `scoreBo.dialog`
    instance so that callers can listen for its dismissal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBox`组件的美丽之处在于它可以被插入到现有的场景中。这是好事，因为我们希望能够在两个不同的地方显示屏幕 – `HighScoreScreen`是一个高级包装函数，它实例化和启动`ScoreBoard`协程，返回`scoreBo.dialog`实例，以便调用者可以监听其关闭。'
- en: 'How this works out in the `onHighScoreActionObservable` that is hooked up to
    the also newly-added **High Scores** button, which is defined by this option data:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这在连接到也新添加的**高分**按钮的`onHighScoreActionObservable`中是如何实现的，该按钮由以下选项数据定义：
- en: '[PRE9]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the same pattern used for the other menu buttons added as part of the
    `_addMenuItems` private function of the `MainMenuScene` constructor – the menu
    is faded out for one second before notifying observers of `onHighScoreActionObservable`
    that something interesting happened.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他作为`MainMenuScene`构造函数的`_addMenuItems`私有函数部分添加的菜单按钮使用的相同模式 – 菜单在通知`onHighScoreActionObservable`观察者有有趣的事情发生之前淡出了一秒钟。
- en: 'The subscriber of this observable is set up in the constructor function of
    the `MainMenuScene` constructor, and is responsible for setting up `scoreDialog`
    and then returning the UI to **Main Menu** after the user clicks **Go Back**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该观察者的订阅者是在`MainMenuScene`构造函数的构造函数中设置的，负责设置`scoreDialog`并在用户点击**返回**后返回UI到**主菜单**：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve introduced the `isTopMost` flag to `MainMenuScene` so that we know whether
    to handle input (see the `MainMenuScene.update` function) or if any `DialogBox`
    instances are responsible for that task. Once we set that flag, we show and get
    the `scoreDialog` instance via the `HighScoreScreen` function. Now that the `scoreDialog`
    instance is available, we can then attach logic to `onCancelledObservable`, which
    re-displays the menu and sets it to handle input.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`isTopMost`标志引入到`MainMenuScene`中，以便我们知道是否处理输入（参见`MainMenuScene.update`函数）或者是否有任何`DialogBox`实例负责这项任务。一旦我们设置了该标志，我们就通过`HighScoreScreen`函数显示并获取`scoreDialog`实例。现在`scoreDialog`实例可用，我们就可以将其逻辑附加到`onCancelledObservable`上，该逻辑重新显示菜单并将其设置为处理输入。
- en: 'Similarly, `scoringDialog` attaches a handler to its `onAcceptedObservable`,
    which does the same as the `MainMenuScreen.onHighScoreActionObservable` handler
    does:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`scoringDialog`将其处理程序附加到其`onAcceptedObservable`上，这与`MainMenuScreen.onHighScoreActionObservable`处理程序所做的一样：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The major difference here is that before calling `HighScoreScreen`, we are extracting
    the `Final Total` score value and passing it into the function along with the
    scene so that it can potentially be added as a new entry to the list.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于在调用`HighScoreScreen`之前，我们正在提取`Final Total`分数值并将其与场景一起传递到函数中，以便它可能被添加为列表中的新条目。
- en: Being able to meet new requirements by putting together existing components
    with few modifications is a pinnacle achievement in software architecture and
    design, which makes it a great place to finish this section. In this section,
    we’ve gone over the sequence of events and actors involved in the processes of
    both persisting and displaying high scores. The existing `DialogBox` component
    is reused to host the scoreboard, while the `IndexedDB` component built in the
    previous section of this chapter provides the storage and the `ScoreBoard` coroutine
    orchestrates everything.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 能够通过少量修改现有组件来满足新要求，是软件架构和设计的一个巅峰成就，这使得它成为结束本节的绝佳地方。在本节中，我们概述了持久化和显示高分过程中涉及的事件序列和参与者。现有的`DialogBox`组件被重用来托管分数板，而本章前面的部分构建的`IndexedDB`组件提供了存储，`ScoreBoard`协程则协调一切。
- en: Integration is simplest in the case of progressing to the high score screen
    from the `isTopMost` flag to the menu so that it knew not to handle input when
    a dialog is being shown, and we also added `onHighScoresActionObserver` to signal
    when to change screens. The rest is just hooking up appropriate show and hide
    logic to the various dialog events. What else is there that could be done? So
    much! See the *Extended Topics* section at the end of this chapter for some ideas
    on things to improve that you can contribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 集成最简单的情况是从`isTopMost`标志到高分屏幕的过渡，这样它就知道在显示对话框时不要处理输入，我们还添加了`onHighScoresActionObserver`来指示何时切换屏幕。其余的只是将适当的显示和隐藏逻辑连接到各种对话框事件。还能做些什么呢？太多了！请参阅本章末尾的*扩展主题*部分，以获取一些关于可以贡献的改进想法。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We started this chapter by focusing on what is needed to turn our application
    into a PWA and how this is done. We finished the chapter by implementing a high
    score board for our application, and in between, we managed to learn a lot. Let’s
    recap what we’ve learned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章从关注将我们的应用转变为PWA所需的要素以及如何实现开始。我们通过实现应用的高分榜结束本章，并在其中我们学到了很多。让我们回顾一下我们学到了什么。
- en: A PWA is a type of application that blurs the boundaries between a regular website
    and a traditional native application. As with desktop applications, a PWA can
    run offline without a network connection. It has access to the host computer’s
    filesystem and hardware devices. Also, as with desktop applications, a PWA can
    be published and deployed via an App Store such as the Apple App Store, Google
    Play, or Microsoft Store. Unlike a desktop app, PWAs can be accessed via a single
    URL and operate as a regular web application with reduced functionality. When
    different limitations or restrictions are encountered, the app gracefully enhances
    or degrades its functionality, making PWAs useful for a wide range of application
    scenarios.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: PWA是一种应用类型，它模糊了常规网站和传统原生应用之间的界限。与桌面应用一样，PWA可以在没有网络连接的情况下离线运行。它能够访问宿主计算机的文件系统和硬件设备。此外，与桌面应用一样，PWA可以通过App
    Store（如苹果App Store、谷歌Play或微软商店）发布和部署。与桌面应用不同，PWA可以通过单个URL访问，并以功能减少的常规Web应用的形式运行。当遇到不同的限制或约束时，应用会优雅地增强或降低其功能，这使得PWA适用于广泛的场景。
- en: 'Three elements are needed for a web application to be considered a PWA: SSL
    hosting to secure the connection, an SW to pre-cache and intercept requests, and
    a Web Manifest to define the application’s metadata. Hosting a site under SSL
    has a widely varying set of steps needed that depend very heavily on the specific
    hosting provider. For instance, Azure Static Web Apps allows a site with a custom
    domain name to have SSL without the need for the developer to provide or purchase
    a certificate, whereas Google and AWS both require additional infrastructure to
    be provisioned to support some or all SSL scenarios. SWs are pieces of code that
    run in a sandboxed execution environment in the web browser. They can do all sorts
    of things, but in our simple application use case, we are using them to perform
    pre-caching and the loading of assets. When the application requests a particular
    resource from a remote URL, the SW intercepts the request and supplies the response
    from the local cache, allowing for a transparent mechanism of going offline without
    having to modify any application code. The Web Manifest serves as the main descriptor
    of the application to any interested systems. A JSON document containing a few
    required and many optional elements, the Web Manifest is what is used to package
    and publish a PWA to an app store, as well as to specify how the PWA should look
    and feel when installed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络应用程序要被视为PWA，需要三个元素：用于保护连接的SSL托管，用于预缓存和拦截请求的SW，以及用于定义应用程序元数据的Web Manifest。在SSL下托管网站需要一系列步骤，这些步骤因具体的托管提供商而异，并且非常依赖于特定的托管提供商。例如，Azure
    Static Web Apps允许具有自定义域名的网站无需开发者提供或购买证书即可使用SSL，而Google和AWS都要求提供额外的基础设施来支持某些或所有SSL场景。SW是运行在浏览器沙箱执行环境中的代码片段。它们可以做各种事情，但在我们的简单应用程序用例中，我们使用它们来进行预缓存和资产的加载。当应用程序从远程URL请求特定资源时，SW会拦截请求并从本地缓存中提供响应，从而允许在不修改任何应用程序代码的情况下实现透明的离线机制。Web
    Manifest充当应用程序对任何感兴趣系统的主描述符。它是一个包含一些必需元素和许多可选元素的JSON文档，用于将PWA打包和发布到应用商店，以及指定PWA安装后的外观和感觉。
- en: When it comes to different ways of storing data on the client, there’s no longer
    any need to rely on mechanisms such as cookies to persist arbitrary amounts of
    data. The IndexedDb browser service provides an object store for applications
    that can store an arbitrarily large amount of data. Although not terribly complicated
    to employ, the programming patterns used to work with IDB are best integrated
    by wrapping them with more easy-to-handle Promises. Our needs were simple enough
    that we didn’t need to use one of the many existing libraries that can work with
    IDB here, as we only needed to be able to add a single score and retrieve a list
    of scores.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在客户端存储数据的不同方式时，不再需要依赖于如cookies之类的机制来持久化任意数量的数据。IndexedDb浏览器服务为应用程序提供了一个对象存储，可以存储任意大量的数据。尽管使用IDB的编程模式并不复杂，但最好通过包装它们以更易于处理的方式与Promises集成。我们的需求足够简单，以至于我们不需要在这里使用许多现有的可以与IDB一起工作的库，因为我们只需要能够添加一个分数并检索分数列表。
- en: The high score screen displays the beauty and power of the `DialogBox` component
    for display, the IDB component for persistence, and a coroutine to manage it all
    into the `SpaceTruckerHighScores` component. The generic nature of `DialogBox`
    allows us to easily integrate the new high score screen into the rest of the Space-Truckers
    application. Both the main menu and the **Scoring Dialog** play host to the scoreboard,
    which allows players with scores that make the cut to enter their three-letter
    initials using either a physical or virtual keyboard.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 高分屏幕展示了`DialogBox`组件的美丽与强大，用于显示，IDB组件用于持久化，以及一个协程来管理所有这些到`SpaceTruckerHighScores`组件中。`DialogBox`的通用性使我们能够轻松地将新的高分屏幕集成到Space-Truckers应用程序的其余部分。主菜单和**得分对话框**都为计分板提供托管，允许得分达到标准的玩家使用物理键盘或虚拟键盘输入他们的三个字母的首字母。
- en: There’s a lot that can be enhanced and added to the application, but the beauty
    of an open source project is that anyone can contribute to it – even you! Check
    out and post on the **discussion boards** with questions or comments on the game
    or book. The issues listed in the repository capture various pieces of work that
    different folks have identified as needing to be addressed or implemented. Different
    labels denote and categorize the issues in different ways – for example, the *“Good
    First Issue”* label is intended to give new contributors a simple or straightforward
    task that can get their feet wet and can be done relatively easily without discussion.
    See the list of issues at [https://github.com/jelster/space-truckers/issues](https://github.com/jelster/space-truckers/issues)
    and discussions at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以增强和添加到应用程序中的内容有很多，但开源项目的美妙之处在于任何人都可以为其做出贡献——甚至是你！查看并发布有关游戏或书籍的**讨论板**上的问题或评论。仓库中列出的问题涵盖了不同的人确定需要解决或实现的各种工作。不同的标签以不同的方式表示和分类问题——例如，*“良好入门问题”*
    标签旨在为新贡献者提供一个简单或直接的任务，以便他们能够轻松上手，并且可以在不讨论的情况下相对容易地完成。查看 [https://github.com/jelster/space-truckers/issues](https://github.com/jelster/space-truckers/issues)
    上的问题列表和 [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)
    上的讨论。
- en: Our turn signal is on as we prepare to reach the terminal phase of our space-road
    trip – we’re approaching the end of the line! As we navigate our way through local
    streets and intersections towards the space docks for delivery, we still have
    a few loose ends to wrap up. The next chapter is going to be a grab-bag of topics,
    as we try to fit in as much as possible about all the things that we haven’t previously
    covered. Local guides will help us navigate these winding and sometimes convoluted
    streets as we look at cutting-edge topics such as real-time ray tracing (path
    marching), **WebXR**, VR and AR applications, and Babylon Native, but also important
    pragmatic subjects such as using Babylon.js with a CMS or e-commerce application.
    Keep your seatbelts buckled – this trip isn’t finished yet!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的空间之旅信号已开启，我们正准备进入旅行的最终阶段——我们正接近终点！在我们通过当地街道和十字路口导航到太空码头进行交付的过程中，我们还有一些未了的事宜要处理。下一章将是一个大杂烩，我们将尝试尽可能多地涵盖我们之前未涉及的所有内容。当地导游将帮助我们穿越这些蜿蜒曲折的街道，同时我们将探讨一些前沿主题，如实时光线追踪（路径行进）、**WebXR**、VR
    和 AR 应用程序，以及 Babylon Native，但也会涉及一些重要的实用主题，例如使用 Babylon.js 与 CMS 或电子商务应用程序。请系好安全带——这次旅行还没有结束！
- en: Extended Topics
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: Use an SW to do something other than fetch and cache data. Take your framerates
    to the ultimate by moving the Space-Trucker rendering into an *offscreen canvas*.
    Essentially, you’ll use SW to do the actual rendering work on a different execution
    thread from the single main thread JavaScript is normally stuck with. The Babylon.js
    docs go into more detail on this at [https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas](https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SW 执行除了获取和缓存数据之外的任务。通过将 Space-Trucker 渲染移至 *离屏画布*，将你的帧率提升到极致。本质上，你将使用 SW
    在与 JavaScript 通常卡在的单个主执行线程不同的执行线程上执行实际的渲染工作。Babylon.js 文档在 [https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas](https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas)
    对此有更详细的说明。
- en: 'Add a button or key combination that clears all existing scores from the database.
    This is a two-part feature: the first task would be to add the ability to remove
    or clear the scores in `SpaceTruckerDb` and the second to provide a way for that
    to be invoked.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个按钮或键组合，从数据库中清除所有现有得分。这是一个两阶段特性：第一个任务是向 `SpaceTruckerDb` 添加删除或清除得分的功能，第二个任务是提供一种调用该功能的方法。
- en: Animate the entrance of each individual score in the list. Bonus points for
    effects that change with the rank of the score. Even more bonus points for giving
    players a nice fireworks display when they get a top score.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化列表中每个单独得分的进入效果。如果效果随得分排名而变化，则加分。如果玩家获得高分时能展示一场精彩的烟花表演，则额外加分。
- en: Split the entry JavaScript module so that the landing page, scores, and main
    menu are in the initially loaded module with the driving and route planning sections
    in separate ones. This will supercharge the initial page load time and allow the
    SW to fetch game assets more efficiently.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将入口 JavaScript 模块拆分，使着陆页、得分和主菜单在最初加载的模块中，而驾驶和路线规划部分在单独的模块中。这将极大地提高初始页面加载时间，并允许
    SW 更高效地获取游戏资源。
