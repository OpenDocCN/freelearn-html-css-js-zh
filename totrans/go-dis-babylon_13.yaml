- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting the Application to a PWA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of the last couple of chapters, it may have started to become
    clear that we are closing in on the end of our journey. Passing through the sweeping,
    vast countryside that is Babylon.js, we’ve seen and done much, and Space-Truckers
    is a functionally complete game thanks to our efforts. Now, we have one last stretch
    on the highway to cover in this chapter before we hit the off-ramp to the side-streets
    of [*Chapter 14*](B17266_14_Final_AM.xhtml#_idTextAnchor290), *Extended Topics,
    Extended* chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Just because we’re close to the end doesn’t mean we are there yet – close doesn’t
    count when it comes to Space-Truckers or orbital mechanics, only horseshoes and
    hand grenades. We’ve still got some road ahead of us, Space-Trucker, and there’s
    still time before we hit the limit on our hours of service, so let’s drive!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to expose the intersection between Babylon.js
    and **Progressive Web Applications** (**PWAs**). A PWA is a middle space, a hybrid
    between the browser-based traditional web application (whatever that means these
    days) and a native desktop application. They can be browsed as a website can be,
    installed as an app can be, and run offline without an internet connection. Users
    can also find and install PWAs from their device or major app store – whether
    Google Play, Microsoft, and Apple. This gives developers greater space to allow
    potential users to discover their app while requiring little cost and effort to
    achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Apple’s support for PWAs is far behind other providers. There are some serious
    restrictions and limitations placed on PWAs running on iOS and they can have their
    own quirks when it comes to support for different features. See the excellent
    third-party site [https://firt.dev/notes/pwa-ios/](https://firt.dev/notes/pwa-ios/)
    for the latest feature support for Safari and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Converting our existing web app to a PWA is simple and easy, but it does require
    some changes to the application. A Service Worker is needed for offline support
    and a manifest is needed to describe the characteristics of our PWA. This includes
    icons, a description, and potentially even screenshots for store submissions.
    However, there is one final feature that Space-Truckers is missing that we’ll
    be implementing in this chapter (it wouldn’t be a *Going the Distance* chapter
    if we didn’t have something of this sort, would it?).
  prefs: []
  type: TYPE_NORMAL
- en: This feature is one that has historically led to countless arguments and strained
    relationships among siblings and besties alike. A feature that has enabled bragging
    rights going back in time to the glory days of classics such as *Galaga*, *Pac-Man*,
    and *Donkey Kong*. This feature, of course, is a high score board. We’re going
    for a scoreboard that’s a bit more modern than the ones from those days because
    our scoreboard will save more than just the top 10 high scores; it will also retain
    those scores between application launches and computer restarts by saving data
    to the **IndexedDB**.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the extent of the plan for this chapter – unlike previous chapters, there’s
    far less conceptual and theoretical discussion needed, so let’s get started. First
    though, let’s take a quick glance at the *Technical Requirements section* for
    this chapter. There’s a bit of a change from the previous ones, and that’s because,
    as we’ll shortly learn, PWAs have a specific set of hosting requirements that
    must be met.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to PWAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the Space-Truckers Application into a PWA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IndexDB to Persist Scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and Displaying High Scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has new tech requirements that, although low to no cost, do require
    some decisions and potentially a bit of research on your part to help get you
    to the specific outcome that works best for your project. After talking about
    the **Secure Sockets Layer** (**SSL**) certificate requirements, we’ll go over
    some of the more popular options for hosting your PWA.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To explain it briefly, SSL is a mechanism through which a client can verify
    the identity of a particular server and establish an encrypted communications
    channel. It’s literally the ‘s’ in HTTPS! An SSL connection is a requirement for
    a PWA without exception. Even though there are no exceptions, there actually is
    one exception, and that is the localhost loop-back address, to make testing easier.
    Obtaining a valid SSL certificate in most cases is free and easy to carry out.
    Depending on your hosting setup, SSL support might even be built into the hosting
    platform! Check the documentation for your specific provider to learn more about
    how to obtain and bind a site to a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Options for Hosting your PWA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s nothing special about a hosting provider with regards to making an
    application into a PWA; any public-facing website that supports SSL has the capability
    to host a PWA. Some environments may make the organization and the process around
    hosting an SSL or HTTPS-based web app harder or easier, so here is a table listing
    some of the major hosting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_13.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GitHub Pages is one of the easiest options if you’re hosting the source of the
    application in GitHub already. Deploying to a GH page site involves pushing commits
    to a specially named (and never merged) branch. What gets committed in our case
    is essentially the output of `npm run build` – the `dist/ folder` and all its
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: '`.github/workflows` folder for the details.'
  prefs: []
  type: TYPE_NORMAL
- en: Google and AWS Static Sites are both unique products that nevertheless perform
    the same essential services as the previous two. AWS offers static websites via
    AWS Amplify, while Google also has a similar offering within its Cloud Storage
    product. The reason for the asterisks on these services is that the base products
    do not support custom domains nor HTTPS served over those custom domains, at least
    not out of the box. More work is needed on the developer’s part to add the other
    infrastructure components (such as an HTTPS proxy) that are necessary to accomplish
    and fulfill the requirements for custom domains and SSL or HTTPS. See the documentation
    provided in the next section for more information on how to do this – we don’t
    have enough road left in front of us to swerve into the weeds following this topic!
  prefs: []
  type: TYPE_NORMAL
- en: Resources and Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PWA Builder – [https://pwabuilder.com](https://pwabuilder.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IndexedDB API – [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Static Web Apps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/static-web-apps/](https://docs.microsoft.com/en-us/azure/static-web-apps/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-portal)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Amplify – [https://aws.amazon.com/amplify/hosting/](https://aws.amazon.com/amplify/hosting/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Static Sites – [https://cloud.google.com/storage/docs/hosting-static-website](https://cloud.google.com/storage/docs/hosting-static-website)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Pages and PWAs - [https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/](https://christianheilmann.com/2022/01/13/turning-a-github-page-into-a-progressive-web-app/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service Workers and Workbox:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.chrome.com/docs/workbox/service-worker-overview/](https://developer.chrome.com/docs/workbox/service-worker-overview/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.chrome.com/docs/workbox/](https://developer.chrome.com/docs/workbox/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is in the `ch13` branch of the Space-Truckers
    GitHub repository - [https://github.com/jelster/space-truckers/tree/ch13](https://github.com/jelster/space-truckers/tree/ch13)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playground URLs are listed in their relevant sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to PWAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in the introduction, a PWA is a sort of hybrid type of
    application that bridges the gap between a web application and a regular desktop
    application. Without additional context, it’s a description that comes close to
    meaninglessness context. It’s not the individual words and it’s not the term “Web
    App” that lacks clarity, so what does it mean for a web app to be “Progressive”?
  prefs: []
  type: TYPE_NORMAL
- en: Well, as most of us are aware of course, web browsers have a vastly different
    security model than regular applications or games. JavaScript running in a browser’s
    sandboxed environment has, by design, extremely limited access to the underlying
    machine’s hardware and filesystem. Important to our discussion is the limitation
    placed on scripts, along with the vast range of implementation support in browsers,
    which means that any given web application may or may not have access to certain
    device features and functions. In these types of cases, or when an application
    is being distributed widely across different device and software profiles, it
    is very important for an application to be able to – wait for it – “Progressively”
    and gracefully enhance or degrade its capabilities on-demand based on what the
    hosting device has and is willing to share with the browser app.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes us to the next question, then: how do PWAs work? There are three
    main defining requirements that a web application must fulfill to be eligible
    to be installed as a PWA by a web browser. These requirements are **SSL**, **Service
    Workers**, and **(Web) Manifests** (**SSM**). So much word salad to digest, so
    little time. Let’s prep a salad fork and dig into these in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer (or if you just really enjoy confusing people), you can use MMS
    or even SMS for an acronym. You do you!
  prefs: []
  type: TYPE_NORMAL
- en: SSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conducted over HTTPS, this is a non-negotiable requirement – and for good reason!
    Installing a web app as a PWA expands the capabilities of the app greatly, but
    at the same time, commensurately exposes the host machine and its data to a greater
    risk of malicious or incompetent actors accessing it. Requiring a secure connection
    between the client and server neither compensates for incompetent or bad coding
    nor does it guarantee that the server involved is protected from malicious intent.
    What it does guarantee is that the identity of the hosting site has been verified
    as being what the site says it is.
  prefs: []
  type: TYPE_NORMAL
- en: Service Workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Used to fetch and retrieve assets for and from offline use, SW is code loaded
    from a JavaScript file separate from the main application’s code. Running in a
    DOM-less sandbox, an SW is nonetheless the key intermediary between the application
    and the underlying network. An SW enables offline usage of the app in a transparent
    fashion – nothing in the application knows that it is really communicating with
    the SW when it makes a web request for a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a script, HTML tag, or CSS definition triggers a request from the
    web application, the request is intercepted and handled by the SW. The SW then
    has the choice of either returning the indicated resource to the caller from its
    cache or of refreshing its cache prior to returning the resource. To make this
    even more effective, the SW’s first job upon installation and activation is to
    pre-fetch all the resources and put them into its cache ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: Web Manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last element needed to “unlock” the capabilities of a PWA in a browser is
    a Web Manifest. This is a simple JSON-formatted file that’s usually given an extension
    of `.webmanifest`, and it tells the web browser and other consumers of the manifest
    all sorts of neat information about the application. In addition to containing
    basic information about an application, such as the name, description, and version,
    the manifest contains sections that allow a developer to specify icon images at
    varying sizes and aspects for display by the host OS (e.g., the iOS Home Screen),
    display orientation preferences, screenshots, and even age and content ratings.
    View a full listing of possible elements and what they mean on the Mozilla Developer
    docs site at [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest).
  prefs: []
  type: TYPE_NORMAL
- en: These different pieces of metadata all work together to describe how the application
    should be presented and the parameters of its expected behavior. In addition,
    the Web Manifest is heavily leveraged when listing a PWA in one of the app stores.
    The benefits of being able to define the application’s metadata once for publication
    everywhere should be obvious, but how to easily define values for each of those
    properties is not. Fortunately, as with working with Babylon.js, there are many
    tools and resources available that can help speed things along.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the tools and the mechanics of PWAs shortly but let’s summarize
    what we know about PWAs and how they work first. When users browse to a website
    that is PWA-enabled, an icon appears in the browser indicating that an application
    can be installed for the current site. Clicking the icon transforms what used
    to be a regular website into an offline-capable, Start Menu-pinnable application
    indistinguishable from a native application.
  prefs: []
  type: TYPE_NORMAL
- en: 'What allows this to happen are the three specific things that a PWA must have
    properly configured – the SSM trio: (S)SL connections, a (S)ervice Worker to pre-fetch
    and cache resources for offline use, and a Web (M)anifest. Having an SSL connection
    means that the website hosting the PWA is accessed over the HTTPS protocol and
    requires a valid certificate to be obtained for this purpose. SWs are JavaScript
    code components that run in a separate sandbox from the rest of the browser’s
    application code. They intercept requests transparently and return cached resources
    stored locally. The Web Manifest describes everything that a hosting OS and web
    browser need to know to install the PWA. In addition, the Web Manifest also serves
    as an app Store package listing, meaning that for the effort of preparing a single
    store submission, one can make submissions to all of the major app Stores.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming up in the next section, we’re going to power up Space-Truckers: The
    Web Application and make it into Space-Truckers: The Progressive Web Application.
    We’ll see how two simple packages, along with a little bit of code and a WebPack
    configuration, are all that’s needed to get the job done. In a way, the simplicity
    and ease of making the conversion could be a bit anticlimactic, but don’t worry
    – we’ll soon thereafter be looking at adding something flashier and with more
    flare when we come to the high score board!'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the Space-Truckers application into a PWA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed shortly prior to this section, a hallmark – or signature – feature
    of a PWA is its ability to gracefully adapt to varying conditions and host environments.
    How should the application behave when a network connection is lost? What happens
    when a new version of the app is published? When assets change, how do you ensure
    that any cached versions of the old asset are evicted, and the new ones are stored?
  prefs: []
  type: TYPE_NORMAL
- en: Putting the “P” in PWA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are all good questions and present real technical and engineering challenges
    that need to be solved. If you are one of those beautiful, curious, intelligent,
    and slightly mad kinds of people, you should prepare yourself to be disappointed.
    While, again, these are worthy topics to study and understand, this is a case
    where tools have evolved to the point where it is possible to accomplish a lot
    while knowing very little about the underlying technology. It’s possible that
    the overall brevity of this section – or really, of this entire chapter – hasn’t
    escaped notice and that’s a hint at just how easy it is to put the ”P” in PWA.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible that the author of this book counted the number of pages
    originally promised and realized that the budgeted page count had been blown quite
    a while back, but nobody’s here to litigate the issue of which is which, are we?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*[Why yes, actually. We are paying quite close attention to the page count.
    – The Editors]*'
  prefs: []
  type: TYPE_NORMAL
- en: Right then. In the interest of getting to the point, and in not further antagonizing
    The Editors, let’s walk through the steps that will make Space-Truckers into a
    PWA.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Installing the Workbox WebPack Plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Workbox** is an open source project maintained by Google with the purpose
    of making the creation, usage, and management of SWs smooth and easy. The project
    also maintains a plugin that integrates with **WebPack** (see [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creatingthe Application*) and automatically generates the SW code for you. Install
    it into the project as a developer dependency along with **CopyPlugin** with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`copy-webpack-plugin` is a simple plugin that copies static files from a given
    directory into the output directory with the rest of the webpack output, which
    is handy for when we want to include icons and a **Web Manifest** with the build.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Configuring WebPack Plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve made new plugins available to WebPack and now we need to import them
    into `webpack.common.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will instantiate the plugins with their respective options. If you
    recall from [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049), *Establishing
    the Development Workflow*, WebPack plugins run in the order they are defined.
    These new plugins need to run after the HTML template has been injected with the
    bundle and after the destination directory has been cleaned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `GenerateSW` and `InjectManifest`, the use cases for which fall under the
    categories “Basic” and “Advanced”. Our needs are currently quite Basic, so we
    are using the `GenerateSW` plugin. Its configuration has flags that specify the
    SW should immediately claim matching clients (for upgrade scenarios) as well as
    skip waiting for older workers to be disposed. Most importantly, we set `maximumFileSizeToCacheInBytes`
    to four times its default value. This is needed because we want as many of our
    assets to be cached locally as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The `.webmanifest` extension along the way). We’ll create those files in subsequent
    steps after we make some changes to our `index.xhtml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Modifying index.xhtml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two important modifications need to be made to the `index.xhtml` file in the
    repository’s `/public` folder. The first is to add a `<link>` tag for the Web
    Manifest to the files’ `<head>` tag. The second is to add a short `<script>` tag
    that loads and registers the SW on page load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In keeping with the graceful enhancement strategy that PWA advocates, our script
    is completely transparent to the rest of the application – when it is present,
    things just work. After checking to see whether the browser supports SWs, the
    `navigator.serviceWorker.register` function is called with the name and path of
    the SW script. This script is generated by `GenerateSW` and output into the `/dist`
    folder, so it shouldn’t trouble you that the file referenced doesn’t seem to exist!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, running the app should generate the expected console messages
    indicating successful SW registration and operation. Common problems that may
    occur are an incorrect path or file name for the SW, or an incorrect `GenerateSW`
    configuration. That’s the SW part of the PWA requirements met – let’s fill in
    the one for the missing Web Manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Adding the Web Manifest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Web Manifest, as previously mentioned in the *Introduction to PWA* section,
    is the developer-friendly, JSON-formatted file describing the PWA’s attributes
    and characteristics. To maintain the development-time experience, we place the
    Web Manifest into the `/public` folder as a sibling to `index.xhtml`. This makes
    sure that our links work properly when being hosted on `webpack-dev-server` or
    built for a production environment and hosted from the `/dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is named `manifest.json` in the `/public` folder, which is then renamed
    to `manifest.webmanifest` at build-time. Here are some of the more important properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_13.02_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the `icons` array, each entry in the array specifies an icon whitespace-separated
    list of sizes, along with a path either directly to a file or to a base file name
    with sizes prefixed – as in, `myicon`, where the file names are `48x48-myicon`
    and `52x52-myicon`. Supplying entries for every possible icon size isn’t necessary,
    although depending on the source image, some distortion and unintended display
    effects could occur. At this point, when the application is run on the local web
    server, the browser should “light up” with the ability to install the site as
    a PWA. If it doesn’t, open the browser developer tools and check for relevant
    console errors. The **Lighthouse** tab in Google Chrome and Microsoft Edge browsers
    can scan websites for many types of problems and optimization issues, including
    those involving PWAs.
  prefs: []
  type: TYPE_NORMAL
- en: A great many other properties are defined for the Web Manifest schema, and although
    not many are required, many are recommended. To see more of the properties available
    in the manifest, see [https://developer.mozilla.org/en-US/docs/Web/Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest).
    It can be difficult to manually create and manage all the different metadata,
    not to mention creating the icons, and that’s why there are tools that can help
    us get the job done fast. One such tool previously discussed was the Workbox project.
    Another tool we haven’t discussed yet though is the **PWABuilder Extension** for
    **VSCode**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PWABuilder Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Carrying out the previous steps manually has some benefits. You get fine control
    over every detail of the process while learning the internals of everything along
    the way. It’s also a tedious process prone to error. An alternative to the previous
    steps is to use the official **PWABuilder Extension for Visual Studio Code**.
    This extension, built and maintained by the same team that maintains the excellent
    resource [PWABuilder.com](http://PWABuilder.com), makes setting up a PWA quick
    and easy. Aside from generating the source code for various PWA components, the
    extension can validate an existing website to check its PWA readiness status –
    very useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the extension from the **VSCode** extension marketplace, open
    the extension’s left-hand pane to reveal the **Web Manifest** and **Service Worker**
    panes. Click the **+** icons on the respective panes to generate those resources.
    When generating the application icons, depending on your settings, the PWA extension
    may generate the entire range of icon sizes – which can number above 60\. For
    that reason, once the icons have been generated, feel free to go ahead and whittle
    down those files to whatever set of sizes works best. Make sure to update the
    manifest to remove the files!
  prefs: []
  type: TYPE_NORMAL
- en: When generating the SW, the extension will ask whether you would like a `npm`
    packages (such as `workbox`) and provide a code snippet to copy-paste into your
    `index.xhtml`. Does the code look familiar?
  prefs: []
  type: TYPE_NORMAL
- en: The final step when making a PWA is, of course, publishing the application to
    an HTTPS host. The specifics of this depend on your hosting provider, but Google,
    AWS, and Microsoft all provide VSCode extensions that can make publishing a breeze.
    Whichever provider is involved, the goal will be to run the `build` script followed
    by copying all of the files in the `/dist` folder to the root of the hosting website.
  prefs: []
  type: TYPE_NORMAL
- en: As promised in this section’s introduction, the tools and technologies available
    make creating and deploying a PWA incredibly simple and fast. A series of four
    straightforward steps are needed – adding two WebPack plugin packages to generate
    the Service Worker, modifying `webpack config`, then `index.xhtml` to register
    the SW and link assets, then finally adding a Web Manifest to describe the extent
    of the changes needed. Whether those changes are performed manually or with the
    help of an extension such as the PWA Builder Extension, there’s a rich world of
    native application functionality that opens up to application developers. We’re
    not seeing the full range and extent of the capabilities of PWAs, so head over
    to [PWABuilder.com](http://PWABuilder.com) to read more about the different cool
    tricks that can be done with them!
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap things up for the chapter, there’s one more topic to explore.
    High scores are a staple for arcade-style games such as `IndexedDB` object store
    built into most modern browsers is a great solution for this type of problem,
    and in the following section, we’re going to learn how to create a component to
    make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: Using IndexedDB to Persist Scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web developers needing to store information on a local client have traditionally
    had a limited number of options, most of which have had significant drawbacks.
    One of the oldest and simplest methods is the humble browser cookie. These little
    text files stored on the client’s browser are sent to the server alongside every
    request made by the browser client. Because of that, and for similarly related
    reasons, cookies aren’t an efficient or practical solution to many if not most
    client-side storage needs, including our own. For an in-depth examination of the
    different pros and cons of available client-side storage, see [https://web.dev/storage-for-the-web/](https://web.dev/storage-for-the-web/).
  prefs: []
  type: TYPE_NORMAL
- en: The **IndexedDb Object Store** (**IDB**) is a client-side, browser-sandboxed
    database enjoying a broad spectrum of consistently implemented support across
    major browsers and platforms. While the amount of data a site is allowed to store
    is limited to the disk space that’s available to the browser, our application
    has very modest storage space requirements outside of the assets.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to use IDB as an asset cache for textures, meshes, and
    the like, it is far easier, efficient, and a better fit overall for those assets
    to use the SW set up earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This section’s focus is on the basics of IDB and how we will make use of it
    in our application. After taking a moment to review the foundational elements
    of `IndexedDb`, we’ll put together some code to wrap the lower-level IDB functions
    with more application-layer-friendly helpers. Then, we’ll see how to integrate
    those helpers into a Playground that we’ll use in the next section, *Storing and
    Displaying High Scores*.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about IndexedDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`IndexedDB` is an official API specification maintained by the **World Wide
    Web Consortium** (**w3c**), an organization also responsible for most web-based
    standards such as HTML and CSS. The specification can be found at [https://w3c.github.io/IndexedDB/](https://w3c.github.io/IndexedDB/)
    but we don’t need to go much deeper here to gain an understanding of how IDB works.'
  prefs: []
  type: TYPE_NORMAL
- en: The wide support in web browsers for the IDB specification gives us confidence
    that we can proceed with using the APIs and that the same code should work the
    same across different browsers – the operative phrase being “should work.” Don’t
    leave off testing across different browsers and versions. Otherwise, you run a
    very high potential risk of running into support issues with end users that aren’t
    using the same setup as you!
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to consuming the IDB API, there are two important things to note.
    First is that they are asynchronous. The second is that operations produce results
    via various event handler functions. When an asynchronous operation is invoked,
    the return value of that function isn’t immediately available – the function doesn’t
    return anything. Further, the operation may or may not succeed. In the case of
    the former, the result is produced by an event handler function specific to the
    operation and object involved. The `IDBOpenRequest` object has event handlers
    such as `onsuccess`, `onerror`, and `onupgradedneeded`, while the `IDBObjectStore`
    object has events such as `transaction.oncomplete`. As some of the names suggest,
    the latter case of an operation failing is handled by the `onerror` handler function.
  prefs: []
  type: TYPE_NORMAL
- en: An important consideration is how the various code paths of the `indexedDB.open`
    function are managed. The `onsuccess` event produces an instance of `IDBDatabase`,
    but that’s only part of the story. When a unique combination of the database name
    and the current schema versions (the first and second parameters to the `Open`
    operation) is requested that does not match any existing object stores, the `onpugradeneeded`
    event is fired. It is at that time that the specific object store has its schema
    created, any indexes added, and any version change migrations performed.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough foundational concepts for us to start writing some code! We need
    to write some helper code that takes the event-based asynchronous `IndexedDB`
    functions and makes them easy to use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using IndexedDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the different needs, scenarios, and data schema definitions involved with
    `IndexedDB` constitute several moving parts. Therefore, our first task is going
    to be crafting a wrapper around these operations that exposes the desired API
    in the form of functions returning Promises. There are several libraries available
    that implement similar helper code, but for our simple needs, it is more illustrative
    and useful to just write the code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The following code pattern is common in JavaScript programming as an approach
    for wrapping lower-level or legacy programming interfaces into forms more friendly
    to higher-level applications consuming that functionality. If you’re not familiar
    with this pattern, it’s a useful one to have in your toolbox!
  prefs: []
  type: TYPE_NORMAL
- en: The Playground snippet **#U20E4X** contains the code we’ll be using for this
    and the next part, so follow along as we visit some of the more interesting, opaque,
    and complex parts of the sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by declaring and storing the `SpaceTruckersDb` function as our
    outer scope. The body of this function contains our working set of variables shared
    across our helper functions to maintain the internal state, as well as a `const`
    array of seed `scoreData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Jumping to the bottom of the function, we are returning an object containing
    the helper functions to retrieve a list of scores as well as to add a new score.
    Alongside these functions is `readyPromise`, used to check for and ensure full
    initialization at a time of the caller’s choosing. Because our needs are so simple,
    we don’t need any additional logic or methods currently.
  prefs: []
  type: TYPE_NORMAL
- en: The most complicated logic of the entire sample is the first step – initializing
    the IDB object database and the corresponding object store (or table) that we’re
    using to store the scoring data for our application. This is tricky to handle
    because there are multiple potential branches that the code might need to take
    depending on whether the object store already exists, and further, whether the
    schema version of the object stores matches the most current version requested.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what the `onupgradeneeded` event handler must, uh, handle. We start at
    the top of the `readyPromise` delegate’s function body by invoking `indexedDb.open`.
    This returns (one of the only times this happens with the IDB APIs) an `openDbRequest`
    object with its attendant `onerror`, `onsuccess`, and of course, the `onupgradeneeded`
    events. The error logic is simple – reject `readyPromise` and pass through the
    thrown error. The success logic is also simple – just set the database variable
    to `event.target.result` and resolve the promise with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the `onsuccess` event is not fired on the first run of the script
    for a given `currentSchemaVersion` and `databaseName`. Instead, `onupgradeneeded`
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at what happens with the `onupgradeneeded` event. After extracting
    the database from the event object, we create `objectStore` itself. The `autoIncrement`
    flag indicates that new records should get an autoincremented key assigned and
    is followed by the creation of the non-unique score index. This is important and
    needed to ensure that the scores are stored in the proper ranked order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To proceed after creating the score index, we attach a function to the `oncomplete`
    event of `objectStore.transaction`. This function immediately initiates a `readwrite`
    transaction against the same table (`scoreStore`), which is then used to populate
    the initially empty score table with a set of initial high scores (`scoreData`).
    After adding the seed data to the store, we resolve `readyPromise` – there’s no
    need to wait for the write transaction to complete. That’s the most complicated
    logic we have for this component.
  prefs: []
  type: TYPE_NORMAL
- en: The `retrieveScores` and `addScore` functions are both simpler variations on
    the main themes presented with the `onupgradeneeded` event logic. A `txn` object
    is created with requested permissions of either read-only or read-write. `objectStore`
    is then retrieved from the transaction and used to perform either a `getAll` or
    `add` operation. For `getAll`, the results are produced in the `onsuccess` handler
    of the object returned from `objectStore.getAll`, similarly to how the result
    of `indexedDB.open` is produced in `onsuccess`.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As simply as this, we’ve created a reusable component that we can drop into
    the Space-Truckers application as part of a high score screen! Let’s review what
    we’ve learned about `IndexedDB` before we move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: IDB is a browser-based storage mechanism that has the capability of storing
    very large amounts of data. While the basic storage means is object-based, IDB
    has the concept of databases containing a set of one or more object stores or
    tables. The schema for each table must be defined at the time of creation or schema
    version upgrade. This is defined by `currentSchemaVersion` passed to the `indexedDB.open`
    function. When the current version doesn’t exist or is lower than the version
    requested, the `onupgradeneeded` event fires.
  prefs: []
  type: TYPE_NORMAL
- en: During this event, object stores are created, their indexes are defined, and
    their data is populated. When upgrading versions, it’s important to include migration
    logic in this event handler – otherwise, data will be lost! In our case, we don’t
    need to migrate score data and it’s unlikely we’ll need to do much substantially
    to require a schema change soon (see the *Extended Topics* section at the end
    of this chapter for some ideas that might involve doing that).
  prefs: []
  type: TYPE_NORMAL
- en: Because the pattern of accessing the IDB APIs doesn’t natively support Promises,
    we’ve wrapped the major operations we need in a Promise-capable one. `readyPromise`
    is where the actual initialization and opening of the object store are performed
    and is also where the `onupgradeneeded` logic is housed. Once `readyPromise` resolves,
    the `getScores` and `addScore` methods become operational. These functions also
    return Promises for their respective operations, producing a list of scores or
    a confirmation that a new score was added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our IDB wrapper functions are the tools that we had to build in order to build
    the high score screen – now, it’s time to use them. In the last section of this
    chapter, we’re going to combine what we’ve just learned with the knowledge we’ve
    gained about coroutines and toss in our reusable GUI DialogBox component to create
    a tasty salad that is Space-Truckers: The High Scores!'
  prefs: []
  type: TYPE_NORMAL
- en: Storing and Displaying High Scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping with the cooking theme that we wrapped up the previous section on, this
    section is all about combining our ingredients into a meal. All the hard work
    and learning have already happened, so this section will go by quickly – all the
    better to start feasting! The Playground at [https://playground.babylonjs.com/#VBMMDZ#23](https://playground.babylonjs.com/%23VBMMDZ%2323)
    is what we’ll use as a live example – keep following along or try to replicate
    the functionality in the sample from the descriptions and snippets mentioned in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t try to eat your computer, or anything that isn’t food – we are just using
    a metaphor, albeit one taken a bit further than needed! In fact, let’s just switch
    themes entirely. For the rest of this section, we’ll go with a classic heist,
    in the style of *Ocean’s Eleven*.
  prefs: []
  type: TYPE_NORMAL
- en: The Heist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It won’t be enough to enlist the reluctant aid of the “muscle”, `DialogBox`,
    to throw a list of scores onto the screen and call it a day. Nor is it enough
    to bring in the quick-witted “safe cracker”, `SpaceTruckersDb`, to finish the
    job. If we truly want to pull off this major gig, The High Score, each score needs
    to make a grand entrance. Failing that, they can at least not all appear on the
    screen at the same time as a crowd of raucous monkeys storming a banana barrel.
    In the case of a new high score in need of recording, we need to be able to collect
    the user’s initials in the “traditional” three-letter format used by the arcade
    cabinets of old. We need “brains”to do the thinking. We need our old friend the
    **coroutine** to “come out of retirement for one last job”.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize our plan in exciting sub-sections, imagine of a compelling montage
    sequence that shows exactly how hard (actually, it’s not hard but roll with it)
    completing the job will be for The Crew, let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: The Muscle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll host the high score display with the `DialogBox` component (see *section
    Building a Reusable Dialog Box Component* in[*Chapter 9*](B17266_09_Final_AM.xhtml#_idTextAnchor186)*,
    Calculating and Displaying Scoring Results*). Scores themselves are hosted within
    a `bodyContainer`. Each score is an object with just the name and score properties.
    The `getScoreTextLine` helper function takes an individual score object and returns
    a formatted string that can be displayed in `TextBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Though we expect the `s.score` value to be present, we check for its absence
    anyhow, since the process of adding a new score necessarily precludes the entry
    of a name. We also expect the score to be a whole, integer value, but we convert
    it to a fixed string with zero points beyond the decimal just to be safe. A format
    string is returned that considers the length of the score value’s text representation.
  prefs: []
  type: TYPE_NORMAL
- en: The Safe Cracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Persistence logic will be provided by `SpaceTruckersDb` that we built in the
    previous section. Its functions are called and managed by `scoreBoardCoro`. True
    to the current thematic form, there’s not much else to be said about the “safe
    cracker” that won’t be included with our review of the “brains.”
  prefs: []
  type: TYPE_NORMAL
- en: The Brains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DialogBox` as well as the edit mode for entering new scores. When `scoreBoardCoro`
    is invoked as a function (as part of preparing to run the coroutine – see [*Chapter
    9*](B17266_09_Final_AM.xhtml#_idTextAnchor186)*, Calculating and Displaying Scoring
    Results*, for more), the `newScore` parameter is used to pass in the new high
    score awaiting three-letter branding. If present, the `editHighScores` flag is
    set and a placeholder, `scoreToAdd`, is added to the scores list already retrieved
    by `databaseManager` that is initialized immediately upon entry. Equally, the
    `nameInput` `nameInput.onTextChangedObservable` that limits entries to three characters
    or fewer. Additionally, it will also take action when detecting that the *Enter*
    key was pressed by setting the `editHighScores` flag to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the coroutine has finished waiting to exit edit mode, if there’s `newScore`,
    that means the user’s entered their initials and that the score is waiting to
    be saved. We do that before cleaning up the controls involved in gathering the
    user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After the controls have been cleaned up, we refresh the `scores` list from storage
    to put everything back into a clean, initial state. If there isn’t a `newScore`,
    the coroutine’s work is done and the job’s complete – the scores were already
    retrieved and displayed at the beginning of the coroutine’s execution. With such
    a skilled Crew and exquisite preparation, it shouldn’t surprise anyone following
    along that the Job of displaying the scores itself is short and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: The Job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assembling The Crew was the crucial first step, planning out The Job was the
    second, and now it’s time to execute that plan. Here’s our shortcut to a montage
    of the following steps in a linear sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: (`yield`) until the “safe cracker” (`databaseManager`) signals that it’s ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `scores` list from the “safe cracker” (`databaseManager`) and put them
    into the `scores` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show “the muscle” (`DialogBox`). Wait for it to fully make its entrance before
    continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If “the brains” “sez” there’s another score to add (`newScore`), the following
    happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `editHighScores` flag is set
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A placeholder score entry is created sans a name and added to the `scores` list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Input elements are put into place to collect the player’s initials (`nameInput`
    and `virtualKB`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A “little bird” (a.k.a an observer) listens for changes in the input element,
    toggling out of the `editHighScores` mode when the *Enter* key is pressed or three
    elements or greater have been entered
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: “The host” puts on the show of showing the scores (`displayScores` is called).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tension builds on the stakeout as everyone waits for the edit flag to drop (`yield`
    in use while `editHighScores` is `true`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the getaway, but first, have “the brains” scan the newly-“liberated”
    score (`scoreToAdd`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before jumping into the getaway car, “the host” puts on a smoke-and-mirrors
    show (clears and re-displays the scores from storage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We see The Crew walking off into the sunset having successfully completed The
    Job. The credits roll and lights go up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The Space-Truckers high score board in add or edit mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.01_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – The Space-Truckers high score board in add or edit mode
  prefs: []
  type: TYPE_NORMAL
- en: There are no plans for a sequel (yet…) – however, the extended edition (director’s
    cut) shows what happens after the plucky heisters have finished their job, and
    that’s the nitty-gritty of integrating the crafted code from the snippet discussed
    previously with the overall Space-Truckers application.
  prefs: []
  type: TYPE_NORMAL
- en: The Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The beauty of the `DialogBox` component is that it can be slotted into an existing
    Scene. This is a good thing because we want to be able to display the screen in
    two separate places – `HighScoreScreen` is the high-level wrapper function that
    instantiates and starts the `ScoreBoard` coroutine, returning the `scoreBo.dialog`
    instance so that callers can listen for its dismissal.
  prefs: []
  type: TYPE_NORMAL
- en: 'How this works out in the `onHighScoreActionObservable` that is hooked up to
    the also newly-added **High Scores** button, which is defined by this option data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the same pattern used for the other menu buttons added as part of the
    `_addMenuItems` private function of the `MainMenuScene` constructor – the menu
    is faded out for one second before notifying observers of `onHighScoreActionObservable`
    that something interesting happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscriber of this observable is set up in the constructor function of
    the `MainMenuScene` constructor, and is responsible for setting up `scoreDialog`
    and then returning the UI to **Main Menu** after the user clicks **Go Back**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ve introduced the `isTopMost` flag to `MainMenuScene` so that we know whether
    to handle input (see the `MainMenuScene.update` function) or if any `DialogBox`
    instances are responsible for that task. Once we set that flag, we show and get
    the `scoreDialog` instance via the `HighScoreScreen` function. Now that the `scoreDialog`
    instance is available, we can then attach logic to `onCancelledObservable`, which
    re-displays the menu and sets it to handle input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `scoringDialog` attaches a handler to its `onAcceptedObservable`,
    which does the same as the `MainMenuScreen.onHighScoreActionObservable` handler
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The major difference here is that before calling `HighScoreScreen`, we are extracting
    the `Final Total` score value and passing it into the function along with the
    scene so that it can potentially be added as a new entry to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to meet new requirements by putting together existing components
    with few modifications is a pinnacle achievement in software architecture and
    design, which makes it a great place to finish this section. In this section,
    we’ve gone over the sequence of events and actors involved in the processes of
    both persisting and displaying high scores. The existing `DialogBox` component
    is reused to host the scoreboard, while the `IndexedDB` component built in the
    previous section of this chapter provides the storage and the `ScoreBoard` coroutine
    orchestrates everything.
  prefs: []
  type: TYPE_NORMAL
- en: Integration is simplest in the case of progressing to the high score screen
    from the `isTopMost` flag to the menu so that it knew not to handle input when
    a dialog is being shown, and we also added `onHighScoresActionObserver` to signal
    when to change screens. The rest is just hooking up appropriate show and hide
    logic to the various dialog events. What else is there that could be done? So
    much! See the *Extended Topics* section at the end of this chapter for some ideas
    on things to improve that you can contribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by focusing on what is needed to turn our application
    into a PWA and how this is done. We finished the chapter by implementing a high
    score board for our application, and in between, we managed to learn a lot. Let’s
    recap what we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: A PWA is a type of application that blurs the boundaries between a regular website
    and a traditional native application. As with desktop applications, a PWA can
    run offline without a network connection. It has access to the host computer’s
    filesystem and hardware devices. Also, as with desktop applications, a PWA can
    be published and deployed via an App Store such as the Apple App Store, Google
    Play, or Microsoft Store. Unlike a desktop app, PWAs can be accessed via a single
    URL and operate as a regular web application with reduced functionality. When
    different limitations or restrictions are encountered, the app gracefully enhances
    or degrades its functionality, making PWAs useful for a wide range of application
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three elements are needed for a web application to be considered a PWA: SSL
    hosting to secure the connection, an SW to pre-cache and intercept requests, and
    a Web Manifest to define the application’s metadata. Hosting a site under SSL
    has a widely varying set of steps needed that depend very heavily on the specific
    hosting provider. For instance, Azure Static Web Apps allows a site with a custom
    domain name to have SSL without the need for the developer to provide or purchase
    a certificate, whereas Google and AWS both require additional infrastructure to
    be provisioned to support some or all SSL scenarios. SWs are pieces of code that
    run in a sandboxed execution environment in the web browser. They can do all sorts
    of things, but in our simple application use case, we are using them to perform
    pre-caching and the loading of assets. When the application requests a particular
    resource from a remote URL, the SW intercepts the request and supplies the response
    from the local cache, allowing for a transparent mechanism of going offline without
    having to modify any application code. The Web Manifest serves as the main descriptor
    of the application to any interested systems. A JSON document containing a few
    required and many optional elements, the Web Manifest is what is used to package
    and publish a PWA to an app store, as well as to specify how the PWA should look
    and feel when installed.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to different ways of storing data on the client, there’s no longer
    any need to rely on mechanisms such as cookies to persist arbitrary amounts of
    data. The IndexedDb browser service provides an object store for applications
    that can store an arbitrarily large amount of data. Although not terribly complicated
    to employ, the programming patterns used to work with IDB are best integrated
    by wrapping them with more easy-to-handle Promises. Our needs were simple enough
    that we didn’t need to use one of the many existing libraries that can work with
    IDB here, as we only needed to be able to add a single score and retrieve a list
    of scores.
  prefs: []
  type: TYPE_NORMAL
- en: The high score screen displays the beauty and power of the `DialogBox` component
    for display, the IDB component for persistence, and a coroutine to manage it all
    into the `SpaceTruckerHighScores` component. The generic nature of `DialogBox`
    allows us to easily integrate the new high score screen into the rest of the Space-Truckers
    application. Both the main menu and the **Scoring Dialog** play host to the scoreboard,
    which allows players with scores that make the cut to enter their three-letter
    initials using either a physical or virtual keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot that can be enhanced and added to the application, but the beauty
    of an open source project is that anyone can contribute to it – even you! Check
    out and post on the **discussion boards** with questions or comments on the game
    or book. The issues listed in the repository capture various pieces of work that
    different folks have identified as needing to be addressed or implemented. Different
    labels denote and categorize the issues in different ways – for example, the *“Good
    First Issue”* label is intended to give new contributors a simple or straightforward
    task that can get their feet wet and can be done relatively easily without discussion.
    See the list of issues at [https://github.com/jelster/space-truckers/issues](https://github.com/jelster/space-truckers/issues)
    and discussions at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions).
  prefs: []
  type: TYPE_NORMAL
- en: Our turn signal is on as we prepare to reach the terminal phase of our space-road
    trip – we’re approaching the end of the line! As we navigate our way through local
    streets and intersections towards the space docks for delivery, we still have
    a few loose ends to wrap up. The next chapter is going to be a grab-bag of topics,
    as we try to fit in as much as possible about all the things that we haven’t previously
    covered. Local guides will help us navigate these winding and sometimes convoluted
    streets as we look at cutting-edge topics such as real-time ray tracing (path
    marching), **WebXR**, VR and AR applications, and Babylon Native, but also important
    pragmatic subjects such as using Babylon.js with a CMS or e-commerce application.
    Keep your seatbelts buckled – this trip isn’t finished yet!
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use an SW to do something other than fetch and cache data. Take your framerates
    to the ultimate by moving the Space-Trucker rendering into an *offscreen canvas*.
    Essentially, you’ll use SW to do the actual rendering work on a different execution
    thread from the single main thread JavaScript is normally stuck with. The Babylon.js
    docs go into more detail on this at [https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas](https://doc.babylonjs.com/divingDeeper/scene/offscreenCanvas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a button or key combination that clears all existing scores from the database.
    This is a two-part feature: the first task would be to add the ability to remove
    or clear the scores in `SpaceTruckerDb` and the second to provide a way for that
    to be invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate the entrance of each individual score in the list. Bonus points for
    effects that change with the rank of the score. Even more bonus points for giving
    players a nice fireworks display when they get a top score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split the entry JavaScript module so that the landing page, scores, and main
    menu are in the initially loaded module with the driving and route planning sections
    in separate ones. This will supercharge the initial page load time and allow the
    SW to fetch game assets more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
