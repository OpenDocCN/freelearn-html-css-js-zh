- en: Category Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别论
- en: In the previous chapter, we learned about functions, asynchronous programming,
    and the runtime and functional programming principles and techniques, including
    pure functions and functional composition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了函数、异步编程以及运行时和函数式编程的原则和技术，包括纯函数和函数组合。
- en: 'In this chapter, we are going to focus on category theory and algebraic data
    types. We are going to learn about the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注类别论和代数数据类型。我们将学习以下概念：
- en: Category theory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别论
- en: Algebraic data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型
- en: Functors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Applicative
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: Maybe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能
- en: Either
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么
- en: Monads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩纳哥
- en: Category theory
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类别论
- en: Functional programming has a reputation for being difficult to learn and understand
    due to its mathematical background. Functional programming languages and design
    patterns are influenced by concepts that originated in different mathematical
    fields. However, we can highlight **category theory** as one of the most significant
    influences. We can think about category theory as an alternative to set theory.
    It defines the theory behind a series of data structures or objects known as **algebraic
    data types**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程因其数学背景而以难以学习和理解而闻名。函数式编程语言和设计模式受到源自不同数学领域的概念的影响。然而，我们可以将**类别论**作为最重要的一个影响因素。我们可以将类别论视为集合论的一种替代。它定义了一系列称为**代数数据类型**的数据结构或对象的背后理论。
- en: 'There are many algebraic data types, and understanding all the properties and
    rules that they must implement requires a significant amount of time and effort.
    The following diagram illustrates the relationships between some of the most common
    algebraic data types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型有很多，理解它们必须实现的全部属性和规则需要大量的时间和努力。以下图表展示了某些最常见代数数据类型之间的关系：
- en: '![](img/5e37f1c4-ee1e-499a-8ac3-512ff85266a6.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e37f1c4-ee1e-499a-8ac3-512ff85266a6.png)'
- en: The arrows in the diagram indicate that a given algebraic data type must implement
    the specification of some other algebraic data types. For example, the **Monad**
    type must implement the specifications of the **Applicative** and **Chain** types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的箭头表示给定的代数数据类型必须实现某些其他代数数据类型的规范。例如，**Monad** 类型必须实现 **Applicative** 和 **Chain**
    类型的规范。
- en: The open source project, fantasy-land, declares a specification for some of
    these algebraic data types. The open source project, ramda-fantasy, implements
    these specifications in a way that is compatible with Ramda, which is a popular
    functional programming library that we will explore later in this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目 fantasy-land 声明了一些代数数据类型的规范。开源项目 ramda-fantasy 以与 Ramda 兼容的方式实现了这些规范，Ramda
    是一个流行的函数式编程库，我们将在本书的后续部分探讨。
- en: The algebraic data type specifications can be implemented in many ways. For
    example, the `Functor` specification can be implemented by a `Maybe` or an `Either`
    data type. Both types implement the `Functor` specification, but can also implement
    other specifications, such as the `Monad` or the `Applicative` specification.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型规范可以以多种方式实现。例如，`Functor` 规范可以通过 `Maybe` 或 `Either` 数据类型实现。这两种类型都实现了 `Functor`
    规范，但也可以实现其他规范，如 `Monad` 或 `Applicative` 规范。
- en: 'The following table describes which specifications (listed in the top row)
    are implemented by one of the algebraic data type implementations (left row) in
    the fantasy-ramda project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了在 fantasy-ramda 项目中，哪些规范（列在顶部行）由代数数据类型实现（左侧行）：
- en: '| **Name** | **Setoid** | **Semigroup** | **Functor** | **Applicative** | **Monad**
    | **Foldable** | **ChainRec** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **Setoid** | **Semigroup** | **Functor** | **Applicative** | **Monad**
    | **Foldable** | **ChainRec** |'
- en: '| **Either** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘
    |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **要么** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |  
            ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: '| **Future** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **Future** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: '| **Identity** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |
    ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **Identity** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |
    ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: '| **IO** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **IO** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: '| **Maybe** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |             ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **Maybe** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |             ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: '| **Reader** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **Reader** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ |'
- en: '| **Tuple** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ | ✘ | ✘ |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **Tuple** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ | ✘ | ✘ |'
- en: '| **State** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **State** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
- en: 'Understanding the field of category theory and all these data types and specifications
    is outside the scope of this book. However, in this chapter, we are going to learn
    the basics regarding two of the most common algebraic data types: `Functors` and
    `Monads`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解范畴论领域以及所有这些数据类型和规范超出了本书的范围。然而，在本章中，我们将学习关于两种最常见的代数数据类型的基础知识：`Functors` 和 `Monads`。
- en: Please refer to the fantasy-land project at [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)
    and the fantasy-ramda project at [https://github.com/ramda/ramda-fantasy](https://github.com/ramda/ramda-fantasy)
    to learn more about algebraic data types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)
    上的 fantasy-land 项目和 [https://github.com/ramda/ramda-fantasy](https://github.com/ramda/ramda-fantasy)
    上的 fantasy-ramda 项目，以了解更多关于代数数据类型的信息。
- en: Functors
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Functors
- en: 'The `Functor` type has two main characteristics:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor` 类型有两个主要特征：'
- en: It holds a value
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含一个值
- en: It implements a method named `map`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了一个名为 `map` 的方法
- en: 'The following code snippet declares a class named `Container`. This class can
    be considered a `Functor`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `Container` 的类。这个类可以被视为一个 `Functor`：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use the container as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用容器：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, you may think that the `Functor` type is not very useful because
    we have implemented the most basic version possible. The next two sections implement
    two `Functors` known as `Maybe` and `Either`. These two `Functors` are much more
    useful and will demonstrate that `Functors` are a powerful tool. However, before
    we can implement the `Maybe` and `Either` types, we need to learn about the `Applicative`
    type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为 `Functor` 类型不是很实用，因为我们已经实现了最基本版本。接下来的两个部分实现了两个称为 `Maybe` 和 `Either`
    的 `Functor`。这两个 `Functor` 要有用得多，并将证明 `Functors` 是一个强大的工具。然而，在我们能够实现 `Maybe` 和
    `Either` 类型之前，我们需要了解 `Applicative` 类型。
- en: Applicative
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applicative
- en: An `Applicative` is a `Functor` that implements a method named `of`. However,
    an `Applicative` is not just a `Functor` type; it is also an `Apply` type. For
    a type to be an implementation of `Apply`, it must implement a method named `ap`
    that takes a `Functor` that wraps a function as an argument.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative` 是一个实现了名为 `of` 的方法的 `Functor`。然而，`Applicative` 不仅仅是一个 `Functor`
    类型；它也是一个 `Apply` 类型。为了使一个类型成为 `Apply` 的实现，它必须实现一个名为 `ap` 的方法，该方法接受一个作为参数的包装函数的
    `Functor`。'
- en: 'The following code snippet implements an `Applicative` and, as a result, it
    has an `of`, a `map`, and an `ap` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个 `Applicative`，因此它有一个 `of`、一个 `map` 和一个 `ap` 方法：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the `Applicative` to wrap a number and a function as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Applicative` 来包装一个数字和一个函数，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use the `map` method to map the value wrapped by the `Functor` using
    a mapping function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `map` 方法使用映射函数映射 `Functor` 包装的值：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we can use the `ap` function to perform the same operation using
    a `Functor` that wraps a function instead of a function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `ap` 函数来执行相同的操作，使用一个包装函数的 `Functor` 而不是函数：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Maybe
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maybe
- en: 'The following `Maybe` data type is a `Functor` and an `Applicative`, which
    means that it contains a value and implements the `map` method. The main difference
    with the preceding implementation of `Functor` is that the value contained is
    optional:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Maybe` 数据类型是一个 `Functor` 和一个 `Applicative`，这意味着它包含一个值并实现了 `map` 方法。与前面实现的
    `Functor` 的主要区别在于所包含的值是可选的：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see in the preceding implementation of the `map` method, the mapping
    function is only applied if the `Maybe` data type contains a value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的 `map` 方法实现中我们可以看到，映射函数仅在 `Maybe` 数据类型包含值时才被应用。
- en: 'To demonstrate how to use the `Maybe` type and why it is useful, we are going
    to declare a function to fetch the latest TypeScript news from [www.reddit.com](http://www.reddit.com),
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 `Maybe` 类型以及为什么它是有用的，我们将声明一个函数来从 [www.reddit.com](http://www.reddit.com)
    获取最新的 TypeScript 新闻，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet uses the `fetch` API to send an HTTP request. This
    is an asynchronous operation, which explains why the snippet creates a `Promise`
    instance. When the operations are completed successfully, the response is returned
    as a `Maybe` instance that contains a value. When the operations are completed
    unsuccessfully, an empty `Maybe` instance is returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `fetch` API 发送 HTTP 请求。这是一个异步操作，这也解释了为什么代码片段创建了一个 `Promise` 实例。当操作成功完成时，响应作为包含值的
    `Maybe` 实例返回。当操作未成功完成时，返回一个空的 `Maybe` 实例。
- en: 'The following code snippet demonstrates how we can use the `fetchNews` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用 `fetchNews` 函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet uses the `fetchNews` function to fetch a list of
    posts concerning TypeScript from Reddit. If the request is completed successfully,
    the  `fetchNews` function returns the HTTP response wrapped in a `MayBe` instance.
    We then use the `map` method to find the list of posts within the response. The
    nice thing about using a `MayBe` instance is that mapping logic is only executed
    if there is an actual response, so we don't need to worry about potential `null`
    or `undefined` errors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `fetchNews` 函数从 Reddit 获取有关 TypeScript 的帖子列表。如果请求成功完成，`fetchNews`
    函数将返回一个包装在 `MayBe` 实例中的 HTTP 响应。然后我们使用 `map` 方法来找到响应中的帖子列表。使用 `MayBe` 实例的好处是，只有当实际有响应时，映射逻辑才会执行，所以我们不需要担心潜在的
    `null` 或 `undefined` 错误。
- en: Please note that the preceding example uses some browser APIs, which means that
    we need to add `dom` to the `lib` field in our `tsconfig.json` file. We are also
    using the `async` keyword, which requires the es6 in `lib`. This will prevent
    compilation errors such as Cannot find name fetch.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例使用了一些浏览器API，这意味着我们需要在`tsconfig.json`文件中的`lib`字段中添加`dom`。我们还使用了`async`关键字，这需要`lib`中的es6。这将防止出现类似于“无法找到名称fetch”的编译错误。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: Either
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或者
- en: 'The `Either` algebraic data type is the union of the `Just` and `Nothing` types:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`代数数据类型是`Just`和`Nothing`类型的并集：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The just type is a `Functor` used to represent a non-nullable value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Just`类型是一个用于表示非空值的`Functor`：'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Nothing` type represents the lack of a value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing`类型表示值的缺失：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code snippet is an implementation of the `fetchNews` function
    that we declared in the preceding section. The main difference this time is that
    we will return an instance of `Just` if the HTTP request is completed successfully,
    and an instance of `Nothing` if the HTTP request is not completed successfully:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是我们之前章节中声明的`fetchNews`函数的实现。这次的主要区别是，如果HTTP请求成功完成，我们将返回一个`Just`实例，如果HTTP请求未成功完成，我们将返回一个`Nothing`实例：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we try to use `map` on an `Either` instance, we will get a compilation error:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在一个`Either`实例上使用`map`，我们将得到一个编译错误：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can use a type guard to ensure that we are accessing a `Nothing` instance
    when a request fails, and a `Just` instance when a request is completed without
    errors:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类型守卫来确保在请求失败时访问一个`Nothing`实例，在请求成功完成且无错误时访问一个`Just`实例：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The good thing about using `Either` is that the compiler forces us to use a
    type guard. This means that using `Either` can lead to increased type safety when
    dealing with potential failures in I/O operations such as HTTP requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Either`的好处是编译器强制我们使用类型守卫。这意味着使用`Either`可以在处理潜在失败的I/O操作（如HTTP请求）时提高类型安全性。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: Monads
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态
- en: We are going to finish our introduction to algebraic data types by learning
    about monads. A `Monad` is a `Functor`, but it also implements the `Applicative`
    and `Chain` specifications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习模态来结束我们对代数数据类型的介绍。`Monad`是一个`Functor`，但它还实现了`Applicative`和`Chain`规范。
- en: 'We can transform the previously declared `Maybe` data type into a `Monad` by
    adding two extra methods named `join` and `chain`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加两个额外的方法`join`和`chain`将之前声明的`Maybe`数据类型转换为`Monad`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Maybe` data type was already a `Functor` and an `Applicative`, but now
    it is also a `Monad`. The following code snippet showcases how we can use it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe`数据类型已经是一个`Functor`和`Applicative`，但现在它也是一个`Monad`。以下代码片段展示了我们如何使用它：'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code snippet demonstrates how the `join` and `chain` methods work.
    As you can see, they are very useful when we have a `Functor` of a `Functor`,
    and we want to access the contained value. The `chain` method is just a one-step
    shortcut for the two operations, `join` and `map`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段展示了`join`和`chain`方法的工作原理。正如你所见，当我们在一个`Functor`的`Functor`中，并且想要访问包含的值时，它们非常有用。`chain`方法只是`join`和`map`两个操作的简化一步。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套的源代码中。
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about a number of algebraic data types, including
    the `Functor`, `Nothing`, `Just`, `Maybe`, `Either`, and `Monad` data types. We
    have learned how these types can help us to ensure that certain errors are handled
    correctly by our code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了许多代数数据类型，包括`Functor`、`Nothing`、`Just`、`Maybe`、`Either`和`Monad`数据类型。我们学习了这些类型如何帮助我们确保代码正确处理某些错误。
- en: 'In the next chapter, we are going to learn about other functional programming
    constructs known as Optics, as well as two new powerful techniques: lazy evaluation
    and immutability.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习其他函数式编程结构，称为Optics，以及两种新的强大技术：懒评估和不可变性。
