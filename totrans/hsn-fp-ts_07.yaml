- en: Category Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about functions, asynchronous programming,
    and the runtime and functional programming principles and techniques, including
    pure functions and functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on category theory and algebraic data
    types. We are going to learn about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming has a reputation for being difficult to learn and understand
    due to its mathematical background. Functional programming languages and design
    patterns are influenced by concepts that originated in different mathematical
    fields. However, we can highlight **category theory** as one of the most significant
    influences. We can think about category theory as an alternative to set theory.
    It defines the theory behind a series of data structures or objects known as **algebraic
    data types**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many algebraic data types, and understanding all the properties and
    rules that they must implement requires a significant amount of time and effort.
    The following diagram illustrates the relationships between some of the most common
    algebraic data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e37f1c4-ee1e-499a-8ac3-512ff85266a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The arrows in the diagram indicate that a given algebraic data type must implement
    the specification of some other algebraic data types. For example, the **Monad**
    type must implement the specifications of the **Applicative** and **Chain** types.
  prefs: []
  type: TYPE_NORMAL
- en: The open source project, fantasy-land, declares a specification for some of
    these algebraic data types. The open source project, ramda-fantasy, implements
    these specifications in a way that is compatible with Ramda, which is a popular
    functional programming library that we will explore later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic data type specifications can be implemented in many ways. For
    example, the `Functor` specification can be implemented by a `Maybe` or an `Either`
    data type. Both types implement the `Functor` specification, but can also implement
    other specifications, such as the `Monad` or the `Applicative` specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes which specifications (listed in the top row)
    are implemented by one of the algebraic data type implementations (left row) in
    the fantasy-ramda project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Setoid** | **Semigroup** | **Functor** | **Applicative** | **Monad**
    | **Foldable** | **ChainRec** |'
  prefs: []
  type: TYPE_TB
- en: '| **Either** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘
    |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Future** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Identity** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |
    ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) | ✘ |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **IO** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Maybe** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |             ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |            
       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **Reader** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| **Tuple** |       ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |    
        ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ | ✘ | ✘ | ✘ |'
  prefs: []
  type: TYPE_TB
- en: '| **State** | ✘ | ✘ |           ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |          ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png)
    | ✘ |                ![](img/a5f6ebac-139f-48f1-b7ef-6393904955f8.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Understanding the field of category theory and all these data types and specifications
    is outside the scope of this book. However, in this chapter, we are going to learn
    the basics regarding two of the most common algebraic data types: `Functors` and
    `Monads`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the fantasy-land project at [https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)
    and the fantasy-ramda project at [https://github.com/ramda/ramda-fantasy](https://github.com/ramda/ramda-fantasy)
    to learn more about algebraic data types.
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Functor` type has two main characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It holds a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It implements a method named `map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet declares a class named `Container`. This class can
    be considered a `Functor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you may think that the `Functor` type is not very useful because
    we have implemented the most basic version possible. The next two sections implement
    two `Functors` known as `Maybe` and `Either`. These two `Functors` are much more
    useful and will demonstrate that `Functors` are a powerful tool. However, before
    we can implement the `Maybe` and `Either` types, we need to learn about the `Applicative`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `Applicative` is a `Functor` that implements a method named `of`. However,
    an `Applicative` is not just a `Functor` type; it is also an `Apply` type. For
    a type to be an implementation of `Apply`, it must implement a method named `ap`
    that takes a `Functor` that wraps a function as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet implements an `Applicative` and, as a result, it
    has an `of`, a `map`, and an `ap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Applicative` to wrap a number and a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `map` method to map the value wrapped by the `Functor` using
    a mapping function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `ap` function to perform the same operation using
    a `Functor` that wraps a function instead of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following `Maybe` data type is a `Functor` and an `Applicative`, which
    means that it contains a value and implements the `map` method. The main difference
    with the preceding implementation of `Functor` is that the value contained is
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding implementation of the `map` method, the mapping
    function is only applied if the `Maybe` data type contains a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use the `Maybe` type and why it is useful, we are going
    to declare a function to fetch the latest TypeScript news from [www.reddit.com](http://www.reddit.com),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet uses the `fetch` API to send an HTTP request. This
    is an asynchronous operation, which explains why the snippet creates a `Promise`
    instance. When the operations are completed successfully, the response is returned
    as a `Maybe` instance that contains a value. When the operations are completed
    unsuccessfully, an empty `Maybe` instance is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how we can use the `fetchNews` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet uses the `fetchNews` function to fetch a list of
    posts concerning TypeScript from Reddit. If the request is completed successfully,
    the  `fetchNews` function returns the HTTP response wrapped in a `MayBe` instance.
    We then use the `map` method to find the list of posts within the response. The
    nice thing about using a `MayBe` instance is that mapping logic is only executed
    if there is an actual response, so we don't need to worry about potential `null`
    or `undefined` errors.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding example uses some browser APIs, which means that
    we need to add `dom` to the `lib` field in our `tsconfig.json` file. We are also
    using the `async` keyword, which requires the es6 in `lib`. This will prevent
    compilation errors such as Cannot find name fetch.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Either
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Either` algebraic data type is the union of the `Just` and `Nothing` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The just type is a `Functor` used to represent a non-nullable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Nothing` type represents the lack of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet is an implementation of the `fetchNews` function
    that we declared in the preceding section. The main difference this time is that
    we will return an instance of `Just` if the HTTP request is completed successfully,
    and an instance of `Nothing` if the HTTP request is not completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use `map` on an `Either` instance, we will get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a type guard to ensure that we are accessing a `Nothing` instance
    when a request fails, and a `Just` instance when a request is completed without
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The good thing about using `Either` is that the compiler forces us to use a
    type guard. This means that using `Either` can lead to increased type safety when
    dealing with potential failures in I/O operations such as HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to finish our introduction to algebraic data types by learning
    about monads. A `Monad` is a `Functor`, but it also implements the `Applicative`
    and `Chain` specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform the previously declared `Maybe` data type into a `Monad` by
    adding two extra methods named `join` and `chain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Maybe` data type was already a `Functor` and an `Applicative`, but now
    it is also a `Monad`. The following code snippet showcases how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates how the `join` and `chain` methods work.
    As you can see, they are very useful when we have a `Functor` of a `Functor`,
    and we want to access the contained value. The `chain` method is just a one-step
    shortcut for the two operations, `join` and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about a number of algebraic data types, including
    the `Functor`, `Nothing`, `Just`, `Maybe`, `Either`, and `Monad` data types. We
    have learned how these types can help us to ensure that certain errors are handled
    correctly by our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to learn about other functional programming
    constructs known as Optics, as well as two new powerful techniques: lazy evaluation
    and immutability.'
  prefs: []
  type: TYPE_NORMAL
