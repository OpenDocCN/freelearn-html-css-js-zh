- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Working with Blender and Three.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Blender 和 Three.js 一起工作
- en: 'In this chapter, we’ll dive a bit deeper into how you can use Blender and Three.js
    together. We’ll explain the following concepts in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨如何使用 Blender 和 Three.js 一起工作。我们将在本章中解释以下概念：
- en: '*Exporting from Three.js and importing into Blender*: We’ll create a simple
    scene, export it from Three.js, and load and render it in Blender.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 Three.js 导出并导入到 Blender 中*：我们将创建一个简单场景，从 Three.js 中导出它，然后在 Blender 中加载和渲染。'
- en: '*Exporting a static scene from Blender and importing it into Three.js*: Here,
    we will create a scene in Blender, export it into Three.js, and render it in Three.js.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 Blender 导出静态场景并导入到 Three.js 中*：在这里，我们将创建一个场景在 Blender 中，将其导出为 Three.js，并在
    Three.js 中渲染。'
- en: '*Exporting an animation from Blender and importing it into Three.js*: Blender
    allows us to create animations, we’ll create a simple animation, and load and
    show it in Three.js.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 Blender 导出动画并导入到 Three.js 中*：Blender 允许我们创建动画，我们将创建一个简单动画，并在 Three.js 中加载和显示。'
- en: '*Baking lightmaps and ambient occlusion maps in Blender*: Blender allows us
    to bake different types of maps that we can use in Three.js.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Blender 中烘焙光照贴图和环境遮挡贴图*：Blender 允许我们烘焙不同类型的贴图，这些贴图可以在 Three.js 中使用。'
- en: '*Custom UV modeling in Blender*: With UV modeling, we determine how a texture
    is applied to a geometry. Blender provides a lot of tools to make that easy. We’ll
    explore how you can use the UV modeling capabilities of Blender and use the results
    in Three.js.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Blender 中进行自定义 UV 建模*：通过 UV 建模，我们确定纹理如何应用于几何体。Blender 提供了许多工具来简化这一过程。我们将探讨如何使用
    Blender 的 UV 建模功能，并将结果用于 Three.js。'
- en: 'Before we get started with this chapter, make sure to install Blender so that
    you can follow along. You can install Blender by downloading the installer for
    your OS from here: [https://www.blender.org/download/](https://www.blender.org/download/).
    The screenshots shown of Blender in this chapter were taken using the macOS version
    of Blender, but the versions for Windows and Linux look the same.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章之前，请确保安装 Blender，以便你可以跟随。你可以从以下链接下载适用于你的操作系统的安装程序：[https://www.blender.org/download/](https://www.blender.org/download/)。本章中显示的
    Blender 截图是使用 Blender 的 macOS 版本拍摄的，但 Windows 和 Linux 的版本看起来相同。
- en: Let’s get started with our first topic, where we create a scene in Three.js,
    export it to an intermediate format, and finally import it into Blender.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个主题，在这个主题中，我们在 Three.js 中创建一个场景，将其导出为中间格式，最后将其导入到 Blender 中。
- en: Exporting from Three.js and importing into Blender
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Three.js 导出并导入到 Blender 中
- en: 'For this example, we’ll just take a simple sample reusing the parametric geometry
    we saw in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101), *Exploring Advanced
    Geometries*. If you open `export-to-blender.html` in the browser, you can create
    some parametric geometries. At the bottom of the menu on the right, we’ve added
    an **exportScene** button:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将只使用我们在 [*第 6 章*](B18726_06.xhtml#_idTextAnchor101) 中看到的参数化几何体进行简单示例重用，*探索高级几何体*。如果你在浏览器中打开
    `export-to-blender.html`，你可以创建一些参数化几何体。在右侧菜单的底部，我们添加了一个 **exportScene** 按钮：
- en: '![Figure 13.1 – A simple scene that we’ll export](img/Figure_13.1_B18726.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 我们将要导出的简单场景](img/Figure_13.1_B18726.jpg)'
- en: Figure 13.1 – A simple scene that we’ll export
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 我们将要导出的简单场景
- en: 'When you click on that button, the model will be saved in the GLTF format and
    downloaded onto your computer. To export a model with Three.js, we can use `GLTFexporter`
    like so:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击该按钮时，模型将以 GLTF 格式保存并下载到你的电脑上。要使用 Three.js 导出模型，我们可以使用 `GLTFexporter` 如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can see that we have created a `GLTFExporter` that we can use to export
    a `THREE.Scene`. We can export a scene in the glTF binary format or the JSON format.
    For this example, we export in JSON. The glTF format is a complex format, and
    while `GLTFExporter` supports many of the objects that make up a Three.js scene,
    you can still run into issues where the export fails. Updating to the latest version
    of Three.js is often the best solution since work is being constantly done on
    this component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们创建了一个 `GLTFExporter`，我们可以用它来导出 `THREE.Scene`。我们可以以 glTF 二进制格式或 JSON
    格式导出场景。对于这个例子，我们以 JSON 格式导出。glTF 格式是一个复杂的格式，虽然 `GLTFExporter` 支持构成 Three.js 场景的许多对象，但你仍然可能会遇到导出失败的问题。更新到
    Three.js 的最新版本通常是最佳解决方案，因为该组件正在不断进行工作。
- en: 'Once we’ve got our `output`, we can trigger the browser’s `download` functionality,
    which will save it to your local machine:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到我们的 `output`，我们可以触发浏览器的 `download` 功能，它将保存到你的本地机器上：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is a glTF file, and its first couple of lines look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个 glTF 文件，其前几行看起来像这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we’ve got a glTF file containing our scene, we can import this into
    Blender. So, open up Blender and you’ll be presented with the default scene with
    a single cube. Remove the cube by selecting it and pressing **x**. Once removed,
    we have an empty scene in which we’ll load our exported scene.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了包含我们场景的 glTF 文件，我们可以将其导入 Blender。因此，打开 Blender，你会看到一个默认场景，其中有一个单个小立方体。通过选择它并按
    **x** 键来删除立方体。一旦删除，我们就有一个空场景，我们将在这里加载导出的场景。
- en: 'From the **File** menu at the top, select **Import | glTF 2.0**, and you’ll
    be presented with a file browser. Navigate to where you’ve downloaded the model,
    select the file, and click on **Import glTF 2.0**. This will open the file, and
    show you something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部的 **文件** 菜单中选择 **导入 | glTF 2.0**，你将看到一个文件浏览器。导航到你下载模型的位置，选择文件，然后点击 **导入 glTF
    2.0**。这将打开文件，并显示类似以下内容：
- en: '![Figure 13.2 – Three.js scene imported in Blender](img/Figure_13.2_B18726.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 在 Blender 中导入的 Three.js 场景](img/Figure_13.2_B18726.jpg)'
- en: Figure 13.2 – Three.js scene imported in Blender
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 在 Blender 中导入的 Three.js 场景
- en: 'As you can see, Blender has imported our complete scene, and the `THREE.Mesh`
    we defined in Three.js is now available in Blender. In Blender, we can now use
    this just like any other mesh. For this example, however, let’s keep it simple
    and just render this scene with the **Cycles** Blender renderer. To do this, click
    on **Render Properties** in the menu on the right (the icon that looks like a
    camera) and for **Render Engine**, select **Cycles**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Blender 已经导入了我们的完整场景，我们在 Three.js 中定义的 `THREE.Mesh` 现在在 Blender 中可用。在 Blender
    中，我们现在可以像使用任何其他网格一样使用它。然而，对于这个例子，让我们保持简单，只用 Blender 的 **Cycles** 渲染器渲染这个场景。为此，点击右侧菜单中的
    **渲染属性**（看起来像相机的图标）并选择 **渲染引擎** 为 **Cycles**：
- en: '![Figure 13.3 – Rendering with the Cycles render engine in Blender](img/Figure_13.03_B18726.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 在 Blender 中使用 Cycles 渲染引擎进行渲染](img/Figure_13.03_B18726.jpg)'
- en: Figure 13.3 – Rendering with the Cycles render engine in Blender
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 在 Blender 中使用 Cycles 渲染引擎进行渲染
- en: 'Next, we need to position the camera correctly, so use the mouse to move around
    the scene until you’ve got a view you’re happy with, and then press *Ctrl* + *Alt*
    + *numpad 0* to align the camera. At this point, you’ll have something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要正确放置相机，所以使用鼠标在场景中移动，直到你得到一个满意的视图，然后按 *Ctrl* + *Alt* + *numpad 0* 来对齐相机。此时，你将得到类似以下内容：
- en: '![Figure 13.4 – Showing the area the camera sees and what will be rendered](img/Figure_13.2_B18726.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 显示相机看到的区域和将要渲染的内容](img/Figure_13.2_B18726.jpg)'
- en: Figure 13.4 – Showing the area the camera sees and what will be rendered
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 显示相机看到的区域和将要渲染的内容
- en: 'Now, we can render the scene by hitting *F12*. This will start the **Cycles**
    render engine, and you’ll see the model being rendered in Blender:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过按 *F12* 来渲染场景。这将启动 **Cycles** 渲染引擎，你将看到模型在 Blender 中被渲染：
- en: '![Figure 13.5 – Final image being rendered in Blender from our exported Three.js
    model](img/Figure_13.5_B18726.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 在 Blender 中从导出的 Three.js 模型渲染的最终图像](img/Figure_13.5_B18726.jpg)'
- en: Figure 13.5 – Final image being rendered in Blender from our exported Three.js
    model
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 在 Blender 中从导出的 Three.js 模型渲染的最终图像
- en: As you’ve seen, using the glTF as a format for exchanging models and scenes
    between Three.js and Blender is very straightforward. Just use `GLTFExporter`,
    import the model in Blender, and you can use everything Blender has to offer on
    your model.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 glTF 作为 Three.js 和 Blender 之间交换模型和场景的格式非常简单。只需使用 `GLTFExporter`，将模型导入
    Blender，你就可以在你的模型上使用 Blender 提供的所有功能。
- en: Of course, the other way around works just as easily, as we’ll show you in the
    next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，反过来操作也同样简单，我们将在下一节中向你展示。
- en: Exporting a static scene from Blender and importing it into Three.js
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Blender 导出静态场景并将其导入 Three.js
- en: 'Exporting models from Blender is just as easy as importing them. In the older
    version of Three.js, there was a specific Blender plugin you could use to export
    in a Three.js-specific JSON format. In later versions though, glTF in Three.js
    has become the standard for exchanging models with other tools. So, to get this
    working with Blender, all we have to do is this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Blender 导出模型与导入它们一样简单。在 Three.js 的旧版本中，你可以使用一个特定的 Blender 插件来导出为 Three.js
    特定的 JSON 格式。然而，在后来的版本中，glTF 在 Three.js 中已成为与其他工具交换模型的标准。因此，为了与 Blender 一起使用，我们只需做以下操作：
- en: Create a model in Blender.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blender 中创建一个模型。
- en: Export the model to a glTF file.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型导出为 glTF 文件。
- en: Import the glTF file in Blender and add it to the scene.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blender 中导入 glTF 文件并将其添加到场景中。
- en: 'Let’s create a simple model in Blender first. We’ll use the default model Blender
    uses, which can be added in **Object Mode** by selecting **Add** | **Mesh** |
    **Monkey** from the menu. Click on **monkey** to select it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Blender 中首先创建一个简单的模型。我们将使用 Blender 默认使用的模型，该模型可以通过从菜单中选择 **添加** | **网格**
    | **猴子** 在 **对象模式** 中添加。点击 **猴子** 以选择它：
- en: '![Figure 13.6 – Creating the model in Blender that you want to export](img/Figure_13.6_B18726.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 在 Blender 中创建要导出的模型](img/Figure_13.6_B18726.jpg)'
- en: Figure 13.6 – Creating the model in Blender that you want to export
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 在 Blender 中创建要导出的模型
- en: 'Once the model is selected, in the top menu, select `File->Export->glTF 2.0`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选中模型后，在上部菜单中选择 `文件->导出->glTF 2.0`：
- en: '![Figure 13.7 – Selecting the glTF export](img/Figure_13.07_B18726.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 选择 glTF 导出](img/Figure_13.07_B18726.jpg)'
- en: Figure 13.7 – Selecting the glTF export
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 选择 glTF 导出
- en: For this example, we only export the mesh. Note that when you’re exporting from
    Blender, always check the **Apply Modifiers** checkbox. This will make sure any
    advanced generators or modifiers used in Blender are applied before exporting
    the mesh.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们只导出网格。请注意，当你从 Blender 导出时，始终要检查 **应用修改器** 复选框。这将确保在导出网格之前应用了 Blender
    中使用的任何高级生成器或修改器。
- en: '![Figure 13.8 – Exporting the model as a glTF file](img/Figure_13.08_B18726.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 将模型导出为 glTF 文件](img/Figure_13.08_B18726.jpg)'
- en: Figure 13.8 – Exporting the model as a glTF file
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 将模型导出为 glTF 文件
- en: 'Once the file is exported, we can load it in Three.js using `GLTFImporter`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导出后，我们可以在 Three.js 中使用 `GLTFImporter` 加载它：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The final result is the exact model from Blender, but visualized in Three.js
    (see the `import-from-blender.html` example):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是 Blender 中的确切模型，但在 Three.js 中可视化（见 `import-from-blender.html` 示例）：
- en: '![Figure 13.9 – The Blender model visualized in Three.js](img/Figure_13.9_B18726.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 在 Three.js 中可视化的 Blender 模型](img/Figure_13.9_B18726.jpg)'
- en: Figure 13.9 – The Blender model visualized in Three.js
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 在 Three.js 中可视化的 Blender 模型
- en: Note that this isn’t just limited to the meshes – with glTF, we can also export
    lights, cameras, and textures in the same manner.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不仅仅限于网格 – 使用 glTF，我们还可以以相同的方式导出灯光、相机和纹理。
- en: Exporting an animation from Blender and importing it into Three.js
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Blender 导出动画并将其导入到 Three.js
- en: 'Exporting an animation from Blender works in pretty much the same way as exporting
    a static scene. Therefore, for this example, we’ll create a simple animation,
    export it in the glTF format again, and load it into a Three.js scene. For this,
    we’re going to create a simple scene where we render a cube falling and breaking
    into parts. The first thing we need for this is a floor and a cube. Therefore,
    create a plane and a cube that hangs a little bit above this plane:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Blender 导出动画的方式基本上与导出静态场景的方式相同。因此，对于这个例子，我们将创建一个简单的动画，再次以 glTF 格式导出，并将其加载到
    Three.js 场景中。为此，我们将创建一个简单的场景，在其中渲染一个掉落并破碎成块的立方体。为此，我们首先需要一个地板和一个立方体。因此，创建一个平面和一个稍微高于这个平面的立方体：
- en: '![Figure 13.10 – An empty Blender project](img/Figure_13.10_B18726.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 一个空的 Blender 项目](img/Figure_13.10_B18726.jpg)'
- en: Figure 13.10 – An empty Blender project
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 一个空的 Blender 项目
- en: 'Here, we just moved the cube up a little bit (press *G* to grab the cube) and
    added a plane (**Add** | **Mesh** | **Plane**), and then we scaled this plane
    to make it bigger. Now, we can add physics to the scene. In [*Chapter 12*](B18726_12.xhtml#_idTextAnchor212),
    *Adding Physics and Sounds to Your Scene*, we introduced the concept of rigid
    bodies. Blender uses this same approach. Select the cube and use **Object** |
    **Rigid Body** | **Add Active**, and select the plane and add its rigid body like
    this: **Object** | **Rigid Body** | **Add Passive**. At this point, when we play
    (by using the *spacebar*) the animation in Blender, you’ll see that the cube falls:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将立方体向上移动了一点（按 *G* 键以抓取立方体）并添加了一个平面（**添加** | **网格** | **平面**），然后我们将这个平面缩放以使其变大。现在，我们可以向场景添加物理效果。在
    [*第 12 章*](B18726_12.xhtml#_idTextAnchor212) 中，*向场景添加物理和声音*，我们介绍了刚体的概念。Blender
    使用相同的方法。选择立方体并使用 **对象** | **刚体** | **添加活动**，然后选择平面并像这样添加其刚体：**对象** | **刚体** |
    **添加被动**。此时，当我们（通过使用 *空格键*）在 Blender 中播放动画时，你会看到立方体掉落：
- en: '![Figure 13.11 – A halfway animation of a cube falling](img/Figure_13.11_B18726.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 立方体掉落的一半动画](img/Figure_13.11_B18726.jpg)'
- en: Figure 13.11 – A halfway animation of a cube falling
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 立方体掉落的一半动画
- en: 'To create the breaking block effect, we need to enable the `Cell Fracture`
    plugin, and check the checkbox to enable the plugin:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建破碎块效果，我们需要启用 `单元格裂缝` 插件，并勾选复选框以启用插件：
- en: '![Figure 13.12 – Enabling the Cell Fracture plugin](img/Figure_13.12_B18726.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.12 – 启用单元格裂缝插件](img/Figure_13.12_B18726.jpg)'
- en: Figure 13.12 – Enabling the Cell Fracture plugin
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – 启用单元格裂缝插件
- en: 'Before we split up the cube into smaller parts, let’s add some vertices to
    the model so that Blender has a good number of vertices, which it can use to split
    up the model. For this, select the cube in **Edit Mode** (by using the *Tab* key)
    and from the menu at the top, select **Edge** | **Subdivide**. Do this twice,
    and you’ll have something looking like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将立方体分割成更小的部分之前，让我们给模型添加一些顶点，以便 Blender 有一个很好的顶点数量，它可以用来分割模型。为此，在 **编辑模式**
    中选择立方体（通过使用 *Tab* 键）并从顶部菜单中选择 **边** | **细分**。这样做两次，你会得到类似这样的效果：
- en: '![Figure 13.13 – Showing the cube with a number of sub-divisions](img/Figure_13.13_B18726.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 显示具有多个细分部分的立方体](img/Figure_13.13_B18726.jpg)'
- en: Figure 13.13 – Showing the cube with a number of sub-divisions
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 显示具有多个细分部分的立方体
- en: 'Hit *Tab* to go back to **Object Mode** and with the cube selected, open the
    **Cell Fracture** window, and go to **Object** | **Quick Effects** | **Cell Fracture**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Tab* 键返回到 **对象模式**，选中立方体后，打开 **单元格裂缝** 窗口，然后转到 **对象** | **快速效果** | **单元格裂缝**：
- en: '![Figure 13.14 – Configuring fractures](img/Figure_13.14_B18726.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – 配置裂缝](img/Figure_13.14_B18726.jpg)'
- en: Figure 13.14 – Configuring fractures
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 配置裂缝
- en: 'You can play around with these settings to get different kinds of fractures.
    With the settings configured in *Figure 13**.3*, you’ll get something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整这些设置以获得不同类型的裂缝。在 *图 13*.3 中配置的设置，你会得到类似这样的效果：
- en: '![Figure 13.15 – Cube showing fractures](img/Figure_13.15_B18726.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 显示裂缝的立方体](img/Figure_13.15_B18726.jpg)'
- en: Figure 13.15 – Cube showing fractures
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 显示裂缝的立方体
- en: Next, select the original cube and hit **x** to delete it. This will only leave
    the fractured parts, which we’ll animate. To do this, select all the cells from
    the cube and use **Object** | **Rigid Body** | **Add Active** again. Once done,
    hit the *spacebar* and you’ll see the cube falling and breaking down on impact.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择原始立方体并按 **x** 键删除它。这将只留下裂缝部分，我们将对它们进行动画处理。为此，选择立方体中的所有单元格，并再次使用 **对象**
    | **刚体** | **添加活动**。完成后，按 *空格键*，你会看到立方体正在下落并在撞击时破碎。
- en: '![Figure 13.16 – The cube after being dropped](img/Figure_13.16_B18726.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – 立方体掉落后的样子](img/Figure_13.16_B18726.jpg)'
- en: Figure 13.16 – The cube after being dropped
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 立方体掉落后的样子
- en: 'At this point, we’ve pretty much got our animation ready. Now, we need to export
    this animation so that we can load it into Three.js and replay it from there.
    Before we do this, make sure to set the end of the animation (the lower-right
    corner of the screen) at frame 80, since it isn’t that useful to export the full
    250 frames. Besides this, we need to tell Blender to convert the information from
    the physics engine into a set of keyframes. This needs to be done since we can’t
    export the physics engine itself, so we have to bake the position and rotation
    of all the meshes so that we can export them. To do this, select all the cells
    again, and use **Object** | **Rigid Body** | **Bake to Keyframes**. You can select
    the defaults and click on the **Export glTF2.0** button to get the following screen:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们的动画基本上已经准备好了。现在，我们需要导出这个动画，以便我们可以将其加载到 Three.js 中并从那里重新播放它。在这样做之前，请确保将动画的结束（屏幕的右下角）设置为帧
    80，因为导出完整的 250 帧并不那么有用。此外，我们需要告诉 Blender 将物理引擎的信息转换为一系列关键帧。这是因为我们不能导出物理引擎本身，所以我们必须烘焙所有网格的位置和旋转，以便我们可以导出它们。为此，再次选择所有单元格，并使用
    **对象** | **刚体** | **烘焙到关键帧**。你可以选择默认设置并点击 **导出 glTF2.0** 按钮，以获得以下屏幕：
- en: '![Figure 13.17 – Animation export settings](img/Figure_13.17_B18726.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.17 – 动画导出设置](img/Figure_13.17_B18726.jpg)'
- en: Figure 13.17 – Animation export settings
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 – 动画导出设置
- en: 'At this point, we’ll have an animation for each of the cells, which keeps track
    of the rotation and position of the individual meshes. With this information,
    we can load the scene in Three.js and set up the animation mixer for playback:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们将为每个单元格创建一个动画，它跟踪单个网格的旋转和位置。有了这些信息，我们可以在 Three.js 中加载场景并设置动画混音器以进行播放：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the render loop, we need to update the mixer for each animation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染循环中，我们需要为每个动画更新混音器：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来是这样的：
- en: '![Figure 13.18 – An exploded cube in Three.js](img/Figure_13.18_B18726.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图13.18 – 在Three.js中的爆炸立方体](img/Figure_13.18_B18726.jpg)'
- en: Figure 13.18 – An exploded cube in Three.js
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 在Three.js中的爆炸立方体
- en: The same principle we’ve shown you here can be applied to different kinds of
    animations supported by Blender. The main thing to keep in mind is that Three.js
    won’t understand physics engines used by Blender, or other advanced animation
    models. Therefore, when you export an animation, make sure you bake the animation
    so that you can use the standard Three.js tools to play back these keyframe-based
    animations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里向您展示的相同原理可以应用于Blender支持的不同类型的动画。需要记住的主要一点是，Three.js不会理解Blender使用的物理引擎或其他高级动画模型。因此，当您导出动画时，请确保烘焙动画，以便您可以使用标准的Three.js工具回放这些基于关键帧的动画。
- en: For the next section, we’re going to look a bit closer at how you can use Blender
    to bake different kinds of textures (maps) that you can then load into Three.js.
    We’ve already seen the results in action in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working with Textures*, but in this section, we’ll show you how to
    use Blender to bake these maps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地探讨如何使用Blender烘焙不同类型的纹理（贴图），然后将其加载到Three.js中。我们已经在[*第10章*](B18726_10.xhtml#_idTextAnchor171)中看到了实际效果，*加载和操作纹理*，但在这个章节中，我们将向您展示如何使用Blender来烘焙这些贴图。
- en: Baking lightmaps and ambient occlusion maps in Blender
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Blender中烘焙光照贴图和环境遮挡贴图
- en: 'For this scenario, we’re going to revisit the example from [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    where we used a lightmap from Blender. This lightmap provides good-looking lighting
    without having to calculate it in real time in Three.js. To do this with Blender,
    we’re going to take the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，我们将回顾[*第10章*](B18726_10.xhtml#_idTextAnchor171)中的示例，其中我们使用了Blender中的光照贴图。这个光照贴图提供了良好的光照效果，而无需在Three.js中实时计算。为此，我们将采取以下步骤：
- en: Set up a simple scene in Blender with a couple of models.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender中设置一个简单的场景，包含几个模型。
- en: Set up the lighting and the models in Blender.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender中设置灯光和模型。
- en: Bake the lighting to textures in Blender.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender中将光照烘焙到纹理中。
- en: Export the scene.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出场景。
- en: Render everything in Three.js.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Three.js中渲染一切。
- en: In the following sections, we will discuss each step in detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讨论每个步骤。
- en: Setting up a scene in Blender
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Blender中设置场景
- en: 'For this example, we’ll create a simple scene in which we’ll bake in some lighting.
    Start a new project, delete the default cube by selecting it and hitting `e` and
    then `z` to extrude along the *z*-axis to get a simple shape like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将创建一个简单的场景，并在其中烘焙一些灯光。开始一个新项目，选择默认的立方体并按`e`然后按`z`沿*z*轴挤出以获得一个简单的形状，如下所示：
- en: '![Figure 13.19 – Creating a simple room structure](img/Figure_13.19_B18726.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图13.19 – 创建一个简单的房间结构](img/Figure_13.19_B18726.jpg)'
- en: Figure 13.19 – Creating a simple room structure
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 创建一个简单的房间结构
- en: 'Once you’ve got this model, go back to **Object Mode** (using *Tab*), and place
    a couple of meshes in the room to get something looking similar to what is shown
    here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个模型，回到**对象模式**（使用*Tab*），在房间中放置几个网格以获得类似以下所示的效果：
- en: '![Figure 13.20 – A full room with some meshes](img/Figure_13.20_B18726.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图13.20 – 带有网格的完整房间](img/Figure_13.20_B18726.jpg)'
- en: Figure 13.20 – A full room with some meshes
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 带有网格的完整房间
- en: 'Nothing special at this point – just a simple room without any lighting. Before
    we move on to adding some lighting, change the colors of the objects a bit. Therefore,
    in Blender, go to **Material Properties**, create a new material for each mesh,
    and set a color. The result will look something similar to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有特别之处——只是一个没有灯光的简单房间。在我们添加灯光之前，先改变一下物体的颜色。因此，在Blender中，转到**材质属性**，为每个网格创建一个新的材质，并设置颜色。结果将类似于以下这样：
- en: '![Figure 13.21 – Adding colors to the different objects in the scene](img/Figure_13.21_B18726.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图13.21 – 向场景中的不同物体添加颜色](img/Figure_13.21_B18726.jpg)'
- en: Figure 13.21 – Adding colors to the different objects in the scene
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 – 向场景中的不同物体添加颜色
- en: Next, we’ll add some nice lighting.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些漂亮的灯光。
- en: Adding lighting to the scene
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加灯光
- en: 'For the lighting in this scene, we’ll add nice HDRI-based lighting. With HDRI
    lighting, we don’t have a single source of light but provide an image that’ll
    be used as the source of light for the scene. For this example, we’ve downloaded
    an HDRI image from here: [https://polyhaven.com/a/thatch_chapel](https://polyhaven.com/a/thatch_chapel).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景的光照，我们将添加基于 HDRI 的良好光照。使用 HDRI 光照，我们不是只有一个光源，而是提供一个将被用作场景光源的图像。对于这个例子，我们从这里下载了一个
    HDRI 图像：[https://polyhaven.com/a/thatch_chapel](https://polyhaven.com/a/thatch_chapel)。
- en: '![Figure 13.22 – Downloading an HDRI from Poly Haven](img/Figure_13.22_B18726.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.22 – 从 Poly Haven 下载 HDRI](img/Figure_13.22_B18726.jpg)'
- en: Figure 13.22 – Downloading an HDRI from Poly Haven
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 – 从 Poly Haven 下载 HDRI
- en: 'After downloading, we have a large image file that we can use in Blender. For
    this, open up the **World** tab from the **Properties Editor** panel, select the
    **Surface** dropdown, and select **Background**. Below this, you’ll find the **Color**
    option, click this, and select **Environment Texture**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，我们有一个大图像文件，我们可以在 Blender 中使用。为此，从**属性编辑器**面板打开**世界**选项卡，选择**表面**下拉菜单，并选择**背景**。在此之下，您将找到**颜色**选项，点击此选项，并选择**环境纹理**：
- en: '![Figure 13.23 – Adding an environment texture to the world](img/Figure_13.23_B18726.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.23 – 向世界中添加环境纹理](img/Figure_13.23_B18726.jpg)'
- en: Figure 13.23 – Adding an environment texture to the world
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23 – 向世界中添加环境纹理
- en: 'Next, click on **Open**, browse to where you downloaded the image, and select
    that location. At this point, we can just render the scene and see what the HDRI
    map provides as lighting:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**打开**，浏览到您下载图片的位置，并选择该位置。此时，我们只需渲染场景并查看 HDRI 贴图提供的照明：
- en: '![Figure 13.24 – Rendering the scene to check out the HDRI lighting](img/Figure_13.24_B18726.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.24 – 渲染场景以检查 HDRI 光照](img/Figure_13.24_B18726.jpg)'
- en: Figure 13.24 – Rendering the scene to check out the HDRI lighting
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.24 – 渲染场景以检查 HDRI 光照
- en: As you can see here, the scene already looks quite nice without us having to
    position separate lights. We now have some nice soft shadows on the walls, the
    objects seem to be lit from multiple angles, and the objects look nice. To use
    the information from the lights as a static lightmap, we need to bake the lighting
    onto a texture and map that texture to the objects in Three.js.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，场景已经相当不错，我们无需放置单独的灯光。现在，墙上有一些漂亮的柔和阴影，物体似乎从多个角度被照亮，物体看起来很漂亮。为了将灯光信息作为静态光照贴图使用，我们需要将光照烘焙到纹理上，并将该纹理映射到
    Three.js 中的物体上。
- en: Baking the light textures
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙光照纹理
- en: 'To bake the lights, first, we have to create a texture to hold this information.
    Select the cube (or any of the other objects you want to bake the lighting for).
    Go to the **Shading** view, and in **Node Editor** at the bottom of the screen,
    add a new **Image Texture** item: **Add** | **Texture** | **Image Texture**. The
    default values should be good to use:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要烘焙光照，首先，我们需要创建一个纹理来存储这些信息。选择立方体（或您想要烘焙光照的任何其他对象）。转到**着色**视图，在屏幕底部的**节点编辑器**中，添加一个新的**图像纹理**项：**添加**
    | **纹理** | **图像纹理**。默认值应该适合使用：
- en: '![Figure 13.25 – Adding a texture image to hold the baked lightmap](img/Figure_13.25_B18726.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.25 – 向纹理图像中添加烘焙光照贴图](img/Figure_13.25_B18726.jpg)'
- en: Figure 13.25 – Adding a texture image to hold the baked lightmap
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.25 – 向纹理图像中添加烘焙光照贴图
- en: 'Next, click on the **New** button of the node you just added, and select the
    size and name of the texture:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击您刚刚添加的节点上的**新建**按钮，并选择纹理的大小和名称：
- en: '![Figure 13.26 – Adding a new image to be used with the texture image](img/Figure_13.26_B18726.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.26 – 添加用于纹理图像的新图像](img/Figure_13.26_B18726.jpg)'
- en: Figure 13.26 – Adding a new image to be used with the texture image
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.26 – 添加用于纹理图像的新图像
- en: 'Now, go to the **Render** tab of the **Properties Editor** panel and set the
    following properties:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到**属性编辑器**面板的**渲染**选项卡，并设置以下属性：
- en: '**Render** **Engine**: **Cycles**.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染引擎**：**Cycles**。'
- en: '`512` or rendering the lightmap will take a very long time.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`512` 或渲染光照贴图将花费非常长的时间。'
- en: In the **Bake** menu, select **Diffuse** from the **Bake Type** menu, and in
    the **Influence** section, select **Direct** and **Indirect**. This will just
    render the influence of our environment lighting.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**烘焙**菜单中，从**烘焙类型**菜单中选择**漫反射**，在**影响**部分，选择**直接**和**间接**。这将仅渲染环境光照的影响。
- en: 'Now, you can click **Bake** and Blender will render the lightmap for the selected
    object to the texture:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以点击**烘焙**，Blender 将为所选对象渲染光照贴图到纹理中：
- en: '![Figure 13.27 – Rendered lightmap for the cube](img/Figure_13.27_B18726.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.27 – 立方体的渲染光照贴图](img/Figure_13.27_B18726.jpg)'
- en: Figure 13.27 – Rendered lightmap for the cube
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.27 – 立方体的渲染光照贴图
- en: 'And that’s it. As you can see in the image viewer on the bottom left, we’ve
    now got a nice-looking rendered lightmap for our cube. You can export this image
    as a standalone texture by clicking on the hamburger menu in the image viewer:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如图 13.29 所示，在左下角的图像查看器中可以看到，我们现在已经得到了一个看起来很不错的立方体渲染光照贴图。您可以通过点击图像查看器中的汉堡菜单将此图像导出为独立的纹理：
- en: '![Figure 13.28 – Exporting the lightmap to an external file](img/Figure_13.28_B18726.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.28 – 将光照贴图导出到外部文件](img/Figure_13.28_B18726.jpg)'
- en: Figure 13.28 – Exporting the lightmap to an external file
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.28 – 将光照贴图导出到外部文件
- en: 'You can now repeat this for the other meshes. Before doing this for the box
    though, we quickly need to fix the UV mapping. We need to do this since we extruded
    a couple of vertices to make the room-like structure, and Blender needs to know
    how to map them correctly. Without going into too much detail here, we can have
    Blender make a proposal on how to create the UV mapping. Click on the **UV Editing**
    menu at the top, select **Plane**, go to **Edit Mode**, and from the **UV** menu,
    select **UV** | **Unwrap** | **Smart Unwrap**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以为其他网格重复此操作。但在为盒子做这个之前，我们首先需要快速修复 UV 映射。我们需要这样做，因为我们拉伸了一些顶点以创建类似房间的结构，Blender
    需要知道如何正确映射它们。不深入细节，我们可以让 Blender 提出一个创建 UV 映射的建议。点击顶部的**UV 编辑**菜单，选择**平面**，进入**编辑模式**，然后从**UV**菜单中选择**UV**
    | **展开** | **智能展开**：
- en: '![Figure 13.29 – Fixing the UVs for the room mesh](img/Figure_13.29_B18726.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.29 – 修复房间网格的 UV](img/Figure_13.29_B18726.jpg)'
- en: Figure 13.29 – Fixing the UVs for the room mesh
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.29 – 修复房间网格的 UV
- en: 'This will make sure that a lightmap will be generated for all sides of the
    room. Now, repeat this for all the meshes, and you will have the lightmaps for
    this specific scene. Once you’ve exported all the lightmaps, we can export the
    scene itself and after that, render it using these created lightmaps in Three.js:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保为房间的所有侧面生成光照贴图。现在，为所有网格重复此操作，您将拥有这个特定场景的光照贴图。一旦导出所有光照贴图，我们就可以导出场景本身，然后使用这些创建的光照贴图在
    Three.js 中渲染：
- en: '![Figure 13.30 – All the created lightmaps](img/Figure_13.30_B18726.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.30 – 所创建的所有光照贴图](img/Figure_13.30_B18726.jpg)'
- en: Figure 13.30 – All the created lightmaps
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.30 – 所创建的所有光照贴图
- en: Now that we’ve baked all our maps, the next step is exporting everything from
    Blender and importing the scene and maps in Three.js.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经烘焙了所有贴图，下一步是从 Blender 导出所有内容，并将场景和贴图导入到 Three.js 中。
- en: Exporting the scene and importing it into Blender
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出场景并将其导入 Blender
- en: 'We’ve already seen in the *Exporting a static scene from Blender and importing
    it into Three.js* section how to export a scene from Blender to be used in Three.js,
    so we’ll repeat these same steps. Click on **File** | **Export** | **glTF 2.0**.
    We can use the defaults and since we don’t have an animation, we can disable the
    animation checkbox. After exporting it, we can import the scene into Three.js.
    If we don’t apply the texture (and use our own default lights), the scene will
    look something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*从 Blender 导出静态场景并将其导入 Three.js*部分中看到了如何从 Blender 导出场景以在 Three.js 中使用，所以我们将重复这些相同的步骤。点击**文件**
    | **导出** | **glTF 2.0**。我们可以使用默认设置，因为我们没有动画，所以可以禁用动画复选框。导出后，我们可以将场景导入到 Three.js。如果我们不应用纹理（并使用我们自己的默认灯光），场景将看起来像这样：
- en: '![Figure 13.31 – The Three.js scene rendered with default lights without the
    lightmaps](img/Figure_13.31_B18726.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.31 – 没有光照贴图的默认灯光渲染的 Three.js 场景](img/Figure_13.31_B18726.jpg)'
- en: Figure 13.31 – The Three.js scene rendered with default lights without the lightmaps
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.31 – 没有光照贴图的默认灯光渲染的 Three.js 场景
- en: 'We’ve already seen how to load and apply a lightmap in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171).
    The following code fragment shows how to load the lightmap textures for all the
    lightmaps we’ve exported from Blender:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第 10 章*](B18726_10.xhtml#_idTextAnchor171)中看到了如何加载和应用光照贴图。以下代码片段展示了如何加载从
    Blender 导出的所有光照贴图纹理：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when we look at the same scene (`import-from-blender-lightmap.html`),
    we have a scene with very nice lighting, even though we didn’t provide any light
    sources ourselves and used the baked lights from Blender instead:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们查看相同的场景（`import-from-blender-lightmap.html`）时，我们有一个非常好的光照场景，尽管我们没有提供任何光源，而是使用了
    Blender 中的烘焙灯光：
- en: '![Figure 13.32 – The same scene but with the baked lightmaps applied from Blender](img/Figure_13.31_B18726.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图13.32 – 应用Blender烘焙的光照贴图的相同场景](img/Figure_13.31_B18726.jpg)'
- en: Figure 13.32 – The same scene but with the baked lightmaps applied from Blender
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32 – 应用Blender烘焙的光照贴图的相同场景
- en: If we export the lightmaps, we already implicitly get information about the
    shadows as well since, at those locations, there is, of course, less light. We
    can also get more detailed shadow maps from Blender. For instance, we can generate
    ambient occlusion maps so we don’t have to create those at runtime.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导出光照贴图，我们隐式地也得到了关于阴影的信息，因为在那些位置，光线当然会更少。我们还可以从Blender中获得更详细的阴影贴图。例如，我们可以生成环境遮蔽贴图，这样我们就不需要在运行时创建它们。
- en: Baking an ambient occlusion map in Blender
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Blender中烘焙环境遮蔽贴图
- en: 'If we go back to the scene we already have, we can also bake an ambient occlusion
    map. The approach for this is the same as that used for baking a lightmap:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们已有的场景，我们也可以烘焙环境遮蔽贴图。这个方法与烘焙光照贴图的方法相同：
- en: Set up a scene.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置场景。
- en: Add all the lights and objects that cast shadows.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有产生阴影的光源和对象。
- en: Make sure you’ve got an empty **Image Texture** in **Shader Editor**, to which
    we can bake the shadows.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在**着色器编辑器**中有一个空的**图像纹理**，我们可以将阴影烘焙到这个纹理上。
- en: Select the relevant baking options and render the shadows to the image.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择相关的烘焙选项并将阴影渲染到图像中。
- en: 'Since the first three steps are the same as those for lightmaps, we’ll skip
    those and look at the render settings needed to render the shadow maps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前三个步骤与光照贴图相同，我们将跳过这些步骤，看看渲染阴影贴图所需的渲染设置：
- en: '![Figure 13.33 – Render settings to bake an ambient occlusion map](img/Figure_13.33_B18726.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图13.33 – 烘焙环境遮蔽贴图的渲染设置](img/Figure_13.33_B18726.jpg)'
- en: Figure 13.33 – Render settings to bake an ambient occlusion map
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.33 – 烘焙环境遮蔽贴图的渲染设置
- en: 'As you can see, you only have to change the dropdown for **Bake Type** to **Ambient
    Occlusion**. Now, you can select the mesh for which you want to bake these shadows
    and click on the **Bake** button. For the room mesh, the result looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你只需要更改**烘焙类型**下拉菜单为**环境遮蔽**。现在，你可以选择要烘焙这些阴影的网格并点击**烘焙**按钮。对于房间网格，结果看起来像这样：
- en: '![Figure 13.34 – An ambient occlusion map as a texture](img/Figure_13.34_B18726.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图13.34 – 作为纹理的环境遮蔽贴图](img/Figure_13.34_B18726.jpg)'
- en: Figure 13.34 – An ambient occlusion map as a texture
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.34 – 作为纹理的环境遮蔽贴图
- en: Blender provides a number of other bake types that you can use to get good-looking
    textures (especially for the static parts of your scene), which can greatly improve
    the rendering performance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Blender提供了一些其他烘焙类型，你可以使用它们来获得看起来很好的纹理（特别是对于场景的静态部分），这可以大大提高渲染性能。
- en: There is one more subject we’re going to look at for this section on Blender,
    and that is how to use Blender to change the UV mapping of a texture.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节关于Blender的内容，我们还将探讨一个主题，那就是如何使用Blender更改纹理的UV贴图。
- en: Custom UV modeling in Blender
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Blender中进行自定义UV建模
- en: 'In this section, we’re going to start with a new empty Blender scene, and we’ll
    use the default cube to experiment with. To get a good overview of how UV mapping
    works, you can use something called a UV grid, which looks something like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从一个新的空Blender场景开始，并使用默认的立方体进行实验。为了获得UV贴图工作原理的良好概述，你可以使用一种称为UV网格的东西，它看起来像这样：
- en: '![Figure 13.35 – A sample UV texture](img/Figure_13.35_B18726.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图13.35 – 一个示例UV纹理](img/Figure_13.35_B18726.jpg)'
- en: Figure 13.35 – A sample UV texture
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35 – 一个示例UV纹理
- en: 'When you apply this as the texture of the default cube, you’ll see how the
    various vertices of a mesh map to a specific location on the texture. To use this,
    the first thing we need to do is define this texture. You can easily do this from
    **Material Properties** in the **Properties** view on the right of the screen.
    Click on the yellow dot before the **Base Color** property and select **Image
    Texture**. This allows you to browse for an image to use as texture:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此作为默认立方体的纹理应用时，你会看到网格的各个顶点如何映射到纹理上的特定位置。为了使用这个，我们首先需要定义这个纹理。你可以轻松地从屏幕右侧的**属性**视图中的**材质属性**中进行此操作。点击**基础颜色**属性前的黄色点并选择**图像纹理**。这允许你浏览并选择用作纹理的图像：
- en: '![Figure 13.36 – Adding a texture to a mesh in Blender](img/Figure_13.36_B18726.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图13.36 – 在Blender中向网格添加纹理](img/Figure_13.36_B18726.jpg)'
- en: Figure 13.36 – Adding a texture to a mesh in Blender
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36 – 在Blender中向网格添加纹理
- en: 'You can already see in the main viewport how this texture is applied to the
    cube. If we export this mesh including the material into Three.js and render it,
    we will see exactly the same mapping because Three.js will use the UV mapping
    defined by Blender (`import-from-blender-uv-map-1.html`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在主视图中看到这个纹理是如何应用到立方体上的。如果我们将这个网格及其材质导出到 Three.js 并渲染它，我们会看到完全相同的映射，因为 Three.js
    将使用 Blender 定义的 UV 映射 (`import-from-blender-uv-map-1.html`)：
- en: '![Figure 13.37 – A box with a UV grid rendered in Three.js](img/Figure_13.37_B18726.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.37 – 在 Three.js 中渲染的带有 UV 网格的盒子](img/Figure_13.37_B18726.jpg)'
- en: Figure 13.37 – A box with a UV grid rendered in Three.js
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.37 – 在 Three.js 中渲染的带有 UV 网格的盒子
- en: Now, let’s switch back to Blender, and open up the **UV Editing** tab. Go to
    **Edit Mode** (using the *Tab* key) on the right-hand side of the screen and select
    the four front-facing vertices. When you’ve selected these, you’ll see the position
    of these four vertices on the left-hand side of the screen as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换回 Blender，并打开 **UV 编辑** 选项卡。在屏幕右侧的 **编辑模式**（使用 *Tab* 键）中选择四个面向前方的顶点。当你选择这些顶点后，你会在屏幕左侧看到这四个顶点的位置。
- en: '![Figure 13.38 – The UV editor showing the mapping of the four pixels that
    make up the front face of the cube](img/Figure_13.38_B18726.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.38 – UV 编辑器显示组成立方体前表面的四个像素的映射](img/Figure_13.38_B18726.jpg)'
- en: Figure 13.38 – The UV editor showing the mapping of the four pixels that make
    up the front face of the cube
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.38 – UV 编辑器显示组成立方体前表面的四个像素的映射
- en: 'In the UV editor, you can now grab (*g*) the vertices and move them to a different
    position on the texture. For instance, you can move them to the edges of the texture
    like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UV 编辑器中，你现在可以抓取 (*g*) 顶点并将它们移动到纹理上的不同位置。例如，你可以将它们移动到纹理的边缘，如下所示：
- en: '![Figure 13.39 – One side mapped to the complete texture](img/Figure_13.39_B18726.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.39 – 一侧映射到完整纹理](img/Figure_13.39_B18726.jpg)'
- en: Figure 13.39 – One side mapped to the complete texture
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.39 – 一侧映射到完整纹理
- en: 'Moving the vertices will result in a cube that looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 移动顶点将导致一个看起来像这样的立方体：
- en: '![Figure 13.40 – The Blender render of the cube with custom UV mapping](img/Figure_13.40_B18726.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.40 – 带有自定义 UV 映射的 Blender 立方体渲染](img/Figure_13.40_B18726.jpg)'
- en: Figure 13.40 – The Blender render of the cube with custom UV mapping
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.40 – 带有自定义 UV 映射的 Blender 立方体渲染
- en: 'And, of course, this is also directly shown in Three.js as well when we export
    and import this minimal model:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们导出并导入这个最小模型时，这也在 Three.js 中直接显示：
- en: '![Figure 13.41 – The Three.js view of the cube with custom UV mapping](img/Figure_13.41_B18726.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.41 – 带有自定义 UV 映射的立方体的 Three.js 视图](img/Figure_13.41_B18726.jpg)'
- en: Figure 13.41 – The Three.js view of the cube with custom UV mapping
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.41 – 立方体的 Three.js 视图，带有自定义 UV 映射
- en: Using this approach, it is very easy to define exactly which parts of your mesh
    should be mapped to which part of a texture.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，可以非常容易地定义你的网格的哪些部分应该映射到纹理的哪个部分。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how you can work together with Blender and Three.js.
    We showed how you can use the glTF format as the standard format to exchange data
    between Three.js and Blender. This works great for meshes, animations, and most
    textures. However, for advanced texture properties, you will probably need some
    fine-tuning in either Three.js or Blender. We also showed how you can bake specific
    textures such as lightmaps and ambient occlusion maps in Blender and use them
    in Three.js. This allows you to render this information once in Blender, import
    it into Three.js, and create great shadows, lights, and ambient occlusion without
    the heavy calculations that Three.js would have to do normally. Note that this,
    of course, will only work for scenes where the lighting is static, and the geometries
    and meshes don’t move around or change shape. Often, you can use this for the
    static parts of your scene. Finally, we looked a bit at how UV mapping works,
    where vertices are mapped to a position on a texture, and how you can use Blender
    to play around with this mapping. Once again, by using glTF as the exchange format,
    all the information from Blender can be easily used in Three.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何与Blender和Three.js协同工作。我们展示了如何使用glTF格式作为标准格式在Three.js和Blender之间交换数据。这对于网格、动画和大多数纹理来说效果很好。然而，对于高级纹理属性，你可能需要在Three.js或Blender中进行一些微调。我们还展示了如何在Blender中烘焙特定的纹理，如光照贴图和环境遮挡贴图，并在Three.js中使用它们。这允许你在Blender中一次性渲染这些信息，将其导入到Three.js中，并创建出优秀的阴影、灯光和环境遮挡，而无需Three.js通常必须进行的复杂计算。请注意，当然，这仅适用于光照静态、几何体和网格不移动或改变形状的场景。通常，你可以用这个方法来处理场景中的静态部分。最后，我们简要地探讨了UV贴图的工作原理，即顶点被映射到纹理上的一个位置，以及如何使用Blender来玩转这种映射。再次强调，通过使用glTF作为交换格式，Blender中的所有信息都可以轻松地用于Three.js。
- en: We’re now reaching the end of this book. In the last chapter, we’re going to
    look at two additional subjects – how can you use Three.js together with React.js,
    and we’ll have a quick look at Three.js’s support for VR and AR.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在即将结束这本书的阅读。在最后一章，我们将探讨两个额外的主题——如何将Three.js与React.js结合使用，以及我们将快速浏览Three.js对VR和AR的支持。
