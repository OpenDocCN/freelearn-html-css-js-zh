<html><head></head><body>
		<div id="_idContainer111">
			<h1 id="_idParaDest-184" class="chapter-number"><a id="_idTextAnchor185"/>10</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>API Communication and Data Contracts in Microservices</h1>
			<p>When working with microservices architecture and Node.js, API communication and data contracts are some of the pillars of building a <span class="No-Break">successful application.</span></p>
			<p>We’ll start this chapter by understanding better how to work with APIs and data contracts in microservices with Node.js. Communicating between microservices through APIs involves establishing a clear contract for data exchange and defining the interface through which services interact with each other. By following these practices, you can establish effective communication between your microservices using APIs. This enables decoupling, scalability, and flexibility in your microservices architecture, allowing individual services to evolve independently while maintaining <span class="No-Break">seamless interactions.</span></p>
			<p>By the end of this chapter, you will have learned how to communicate with APIs and data contracts <span class="No-Break">in Node.js.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Defining API contracts and RESTful <span class="No-Break">API design</span></li>
				<li>REST API libraries and <span class="No-Break">API versioning</span></li>
				<li>Authentication and authorization and <span class="No-Break">data validation</span></li>
				<li>Error handling and <span class="No-Break">API documentation</span></li>
				<li>API testing and <span class="No-Break">API gateway</span></li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/>Defining API contracts and RESTful API design</h1>
			<p>In this section, we’re going to show how to define the API contracts for each microservice and follow the RESTful principles for designing <span class="No-Break">your APIs.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>Defining API contracts</h2>
			<p>API contracts <a id="_idIndexMarker770"/>microservices are the definitions of and agreements for how microservices communicate and interact with each other and external clients. An API contract specifies the format, structure, and rules of the data exchange between the service provider and the service consumer. Defining API contracts is a crucial step in designing microservices, ensuring clear communication and interoperability between <a id="_idIndexMarker771"/>different services. Here are its <span class="No-Break">key components:</span></p>
			<ul>
				<li><strong class="bold">Endpoints and routes</strong>: Clearly define the endpoints and routes for each service, specifying<a id="_idIndexMarker772"/> the URI paths through which different operations can <span class="No-Break">be performed.</span></li>
				<li><strong class="bold">HTTP methods</strong>: Specify <a id="_idIndexMarker773"/>the HTTP methods (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, etc.) allowed for each endpoint. Define the purpose of each method and the <span class="No-Break">expected behavior.</span></li>
				<li><strong class="bold">Request and response formats</strong>: Clearly define the expected request and response<a id="_idIndexMarker774"/>¤k formats. Specify the structure of data, required headers, and any <span class="No-Break">authentication mechanisms.</span></li>
				<li><strong class="bold">Data types and validation</strong>: Define<a id="_idIndexMarker775"/> the data types used in API requests and responses. Specify validation rules to ensure that data conforms to <span class="No-Break">expected formats.</span></li>
				<li><strong class="bold">Status codes</strong>: Clearly define <a id="_idIndexMarker776"/>the HTTP status codes that the API can return. For example, use <strong class="source-inline">200</strong> for successful requests, <strong class="source-inline">404</strong> for not found, and <strong class="source-inline">500</strong> for <span class="No-Break">server errors.</span></li>
				<li><strong class="bold">Authentication and authorization</strong>: Specify the authentication and authorization mechanisms <a id="_idIndexMarker777"/>required to access different endpoints. Define how clients should authenticate themselves and the permissions needed for <span class="No-Break">each operation.</span></li>
				<li><strong class="bold">Error handling</strong>: Clearly<a id="_idIndexMarker778"/> define how errors will be handled. Specify the structure of error responses, including error codes, messages, and any <span class="No-Break">additional information.</span></li>
				<li><strong class="bold">Rate limiting and quotas</strong>: If applicable, define rate limiting and quotas to control the<a id="_idIndexMarker779"/> number of requests a client can make within a specific <span class="No-Break">time frame.</span></li>
			</ul>
			<p>An API contract outlines<a id="_idIndexMarker780"/> the rules and specifications for how services <span class="No-Break">should interact.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>RESTful API design</h2>
			<p>RESTful API design<a id="_idIndexMarker781"/> follows <a id="_idIndexMarker782"/>a set of principles to create scalable, maintainable, and easily consumable APIs. Here are the key principles of RESTful <span class="No-Break">API design:</span></p>
			<ul>
				<li><strong class="bold">Resource-based</strong>: Design APIs around resources that represent the entities in the system. Each resource should <a id="_idIndexMarker783"/>have a <strong class="bold">unique identifier</strong> (<strong class="bold">URI</strong>) and be accessible through a standard set of <span class="No-Break">HTTP methods.</span></li>
				<li><strong class="bold">Uniform interface</strong>: Maintain a uniform interface by using standard HTTP methods (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>) and following conventions for resource naming <span class="No-Break">and manipulation.</span></li>
				<li><strong class="bold">Statelessness</strong>: Keep APIs stateless, meaning that each request from a client contains all the information the server needs to fulfill that request. The server state is not stored <span class="No-Break">between requests.</span></li>
				<li><strong class="bold">Representation</strong>: Use different<a id="_idIndexMarker784"/> representations (<strong class="bold">JSON</strong>, <strong class="bold">XML</strong>, etc.) for resources <a id="_idIndexMarker785"/>based on client needs. Clients can request a specific representation using <span class="No-Break">content negotiation.</span></li>
				<li><strong class="bold">Hypermedia</strong>: Optionally, include hypermedia controls in responses, allowing clients to navigate the API dynamically. This is <a id="_idIndexMarker786"/>known as <strong class="bold">Hypermedia as the Engine of Application </strong><span class="No-Break"><strong class="bold">State</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">HATEOAS</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Consistent naming conventions</strong>: Follow consistent naming conventions for resources and endpoints. Use plural nouns for resource names and maintain a logical and <span class="No-Break">predictable structure.</span></li>
				<li><strong class="bold">Versioning</strong>: If needed, implement a versioning strategy to ensure backward compatibility as the API evolves. This can be done through URI versioning, headers, or <span class="No-Break">other methods.</span></li>
				<li><strong class="bold">Idempotence and safety</strong>: Ensure that operations<a id="_idIndexMarker787"/> are <strong class="bold">idempotent</strong> (multiple identical requests have the same effect as a single request) and safe (do not modify the <span class="No-Break">resource state).</span></li>
				<li><strong class="bold">Security</strong>: Implement<a id="_idIndexMarker788"/> proper security measures, including authentication, authorization, and encryption, to protect sensitive data and ensure secure API interactions. Security in REST API design is a crucial aspect of developing and maintaining web applications that expose data and functionality through APIs. There are many best practices and guidelines for ensuring the security of <span class="No-Break">REST APIs:</span><ul><li>Always use TLS encryption to protect the data in transit and prevent man-in-the-middle attacks. TLS also enables clients to verify the identity of the API server and ensures the integrity of <span class="No-Break">the messages.</span></li><li>Implement a sound and scalable authentication and authorization model to control who can access and modify the API resources. There are different methods and standards for implementing authentication and authorization, such as API keys, OAuth2, JWT, and OpenID Connect. Choose the most suitable one for your use case and follow the security recommendations for <span class="No-Break">each method.</span></li><li>Don’t include sensitive information in URLs, such as passwords, tokens, or personal data. URLs can be logged, cached, or exposed in various ways, so they are not a secure way to transmit sensitive information. Use headers, body, or cookies instead, and encrypt or hash the data <span class="No-Break">if possible.</span></li><li>Narrowly define the allowed RESTful API requests and responses, such as the HTTP methods, the content types, the parameters, and the headers. Validate the input and output data and reject any malformed, unexpected, or malicious requests or responses. Use schemas, parsers, sanitizers, and filters to ensure data quality <span class="No-Break">and consistency.</span></li><li>Implement <a id="_idIndexMarker789"/>continuous API discovery capabilities to monitor and audit the API endpoints, operations, and usage. Use tools and frameworks that can help you document, test, and analyze your APIs, such as Swagger, Postman, or SoapUI. Keep track of the API changes, versions, and dependencies, and communicate them to the API consumers <span class="No-Break">and developers.</span></li><li>Implement error handling and logging mechanisms to handle and report any exceptions or failures that occur in the API. Use appropriate HTTP status codes and error messages to inform the API consumers of the problem and the possible solutions. Avoid exposing sensitive or internal information in error messages, such as stack traces, database queries, or configuration details. Use secure and centralized logging tools to store and analyze the API logs and protect them from unauthorized access <span class="No-Break">or tampering.</span></li></ul></li>
			</ul>
			<p>Remember, it is important to design RESTful APIs carefully while maintaining <span class="No-Break">robust applications.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em> illustrates the <a id="_idIndexMarker790"/>process of designing <span class="No-Break">RESTful APIs:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B14980_10_01.jpg" alt="Figure 10.1: Process of designing RESTful APIs (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Process of designing RESTful APIs (image by Freepik)</p>
			<p>In summary, by <a id="_idIndexMarker791"/>defining clear API contracts and adhering to RESTful principles, microservices can communicate effectively, promoting interoperability and scalability in a <span class="No-Break">distributed architecture.</span></p>
			<p>With the understanding of these concepts, let’s now move to REST API libraries and <span class="No-Break">API versioning.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor190"/>REST API libraries and API versioning</h1>
			<p>In microservices architecture, you can use Node.js frameworks such as Express.js or Fastify to build RESTful APIs and implement API versioning to handle changes and updates to your <span class="No-Break">microservices APIs.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>REST API libraries</h2>
			<p>When building <a id="_idIndexMarker792"/>RESTful APIs in Node.js, several libraries simplify the development process, handling routing, request parsing, and response formatting. Here are some commonly <span class="No-Break">used libraries:</span></p>
			<ul>
				<li><strong class="bold">Express</strong>: Express.js is a <a id="_idIndexMarker793"/>minimalist web framework <a id="_idIndexMarker794"/>for Node.js that provides robust routing, middleware support, and an easy-to-use API. The following is an example of <span class="No-Break">using Express.js:</span><pre class="source-code">
const express = require('express');</pre><pre class="source-code">
const app = express();</pre><pre class="source-code">
app.get('/api/resource', (req, res) =&gt; {</pre><pre class="source-code">
  res.send('Hello, API!');</pre><pre class="source-code">
});</pre><pre class="source-code">
app.listen(3000, () =&gt; {</pre><pre class="source-code">
  console.log('Server is running on port 3000');</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Restify</strong>: Restify is <a id="_idIndexMarker795"/>designed specifically for building REST APIs and<a id="_idIndexMarker796"/> focuses on performance, correctness, and simplicity. The following code is an example of <span class="No-Break">using Restify:</span><pre class="source-code">
// Import the restify module</pre><pre class="source-code">
const restify = require('restify');</pre><pre class="source-code">
// Create a server instance</pre><pre class="source-code">
const server = restify.createServer();</pre><pre class="source-code">
// Define a GET handler for the /api/resource endpoint</pre><pre class="source-code">
server.get('/api/resource', (req, res, next) =&gt; {</pre><pre class="source-code">
  // Send a response with the text "Hello, API!"</pre><pre class="source-code">
  res.send('Hello, API!');</pre><pre class="source-code">
});</pre><pre class="source-code">
// Start the server and listen on port 3000</pre><pre class="source-code">
server.listen(3000, () =&gt; {</pre><pre class="source-code">
  // Log a message to the console</pre><pre class="source-code">
  console.log('Server is running on port 3000');</pre><pre class="source-code">
});</pre></li>
			</ul>
			<p>In this section, we have<a id="_idIndexMarker797"/> learned some examples of REST API libraries and<a id="_idIndexMarker798"/> how to use them. Feel free to experiment with them. To run this code locally, you need firstly to create a file with the <strong class="source-inline">.js</strong> extension within a local folder and open it with your desired IDE such as Visual Studio Code. Then you can write the code in the example, open a terminal from your IDE, and install the Node.js packages required for this example – <strong class="source-inline">restify</strong> – with the <strong class="source-inline">npm install restify</strong> command. When the process of installing the package has finished, you can run it in the integrated terminal example using the <strong class="source-inline">filename_example.js</strong> <span class="No-Break">command node.</span></p>
			<p>With these concepts learned, we can continue with <span class="No-Break">API versioning.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>API versioning</h2>
			<p><strong class="bold">API versioning</strong> is<a id="_idIndexMarker799"/> essential for managing changes and maintaining backward compatibility as an API evolves. API versioning is the process of managing and tracking changes to an API and communicating those changes to the API’s consumers. API versioning is important for ensuring the compatibility, reliability, and security of API-based applications. API versioning can be done in different ways, such as using URI versioning, media type versioning, or content negotiation. Each approach has its own advantages and disadvantages and requires careful design and configuration. Here are common approaches to <span class="No-Break">API versioning:</span></p>
			<ul>
				<li><strong class="bold">URI versioning</strong>: URI versioning<a id="_idIndexMarker800"/> is a method of <a id="_idIndexMarker801"/>applying different versions to a REST API by adding a version indicator to the URI of the endpoints. URI versioning is a common way to handle changes and updates in REST APIs. It involves adding a version number or identifier to the base URI of the API, such as v1, v2, or v3. For example, <strong class="source-inline">https://example.com/v1/users</strong> and <strong class="source-inline">https://example.com/v2/users</strong> would represent different versions of the same resource. The <a id="_idIndexMarker802"/>following lists an example<a id="_idIndexMarker803"/> and the pros and cons of <span class="No-Break">this method:</span><ul><li><em class="italic">Example</em>: <strong class="source-inline">/api/v1/resource</strong> (This means that this is version 1 of <span class="No-Break">the resource).</span></li><li><em class="italic">Pros</em>: It is simple and easy to implement and the version is explicit in <span class="No-Break">the URL.</span></li><li><em class="italic">Cons</em>: It can result in longer and less <span class="No-Break">readable URLs.</span></li></ul></li>
				<li><strong class="bold">Header versioning</strong>: Header versioning <a id="_idIndexMarker804"/>is a method of applying different versions<a id="_idIndexMarker805"/> to a REST API by using a custom header (such as the <strong class="source-inline">Accept</strong> version) or the standard <strong class="source-inline">Accept</strong> header to indicate the desired version of the API. The following lists an example and the pros and cons of <span class="No-Break">this method:</span><ul><li><em class="italic">Example</em>: <strong class="source-inline">Accept</strong> (The <strong class="source-inline">Accept</strong> header is used by HTTP clients, such as web browsers or microservices, to indicate which content types they can understand and prefer to receive from the <span class="No-Break">server): </span><span class="No-Break"><strong class="source-inline">application/vnd.myapi.v1+json</strong></span><span class="No-Break">.</span></li><li><em class="italic">Pros</em>: It results in lean URLs and the version information is <span class="No-Break">in headers.</span></li><li><em class="italic">Cons</em>: It requires clients to set <span class="No-Break">headers correctly.</span></li></ul></li>
				<li><strong class="bold">Query parameter versioning</strong>: Query parameter versioning is a method of applying <a id="_idIndexMarker806"/>different versions to a REST API <a id="_idIndexMarker807"/>by using a query parameter (such as <strong class="source-inline">version</strong>) in the URL to indicate the desired version of the API. The following lists an example and the pros and cons of <span class="No-Break">this method:</span><ul><li><em class="italic">Example</em>: <strong class="source-inline">/api/resource?version=1</strong> (This is an example of URI versioning, a common way to handle changes and updates in REST APIs. It involves adding a version number or identifier to the base URI of the API, such as <strong class="source-inline">v1</strong>, <strong class="source-inline">v2</strong>, or <strong class="source-inline">v3</strong>. In this case, the version is <strong class="source-inline">1</strong> and it is specified as a query parameter after the <strong class="source-inline">?</strong> symbol. This means that the client is requesting the first<a id="_idIndexMarker808"/> version of the API for the<a id="_idIndexMarker809"/> <span class="No-Break">resource </span><span class="No-Break"><strong class="source-inline">/api/resource</strong></span><span class="No-Break">).</span></li><li><em class="italic">Pros</em>: It is simple <span class="No-Break">to implement.</span></li><li><em class="italic">Cons</em>: It can be less readable and the version information is in <span class="No-Break">query parameters.</span></li></ul></li>
				<li><strong class="bold">Media type versioning (content negotiation)</strong>: Media type versioning is a method<a id="_idIndexMarker810"/> of applying <a id="_idIndexMarker811"/>different versions to a REST API by using the media type parameter in the <strong class="source-inline">Accept</strong> or <strong class="source-inline">Content-Type</strong> header to indicate the desired version of the API. The following lists an example and the pros and cons of <span class="No-Break">this method:</span><ul><li><em class="italic">Example</em>: <strong class="source-inline">Content-Type</strong> (The <strong class="source-inline">Content-Type</strong> header is used to indicate the media type of the resource or the data that is being sent or received in a web request or response. The media type is a string that describes the format, structure, and encoding of the data, such as <strong class="source-inline">text/html</strong>, <strong class="source-inline">application/JSON</strong>, or <strong class="source-inline">image/png</strong>): <span class="No-Break"><strong class="source-inline">application/json; version=1</strong></span><span class="No-Break">.</span></li><li><em class="italic">Pros</em>: It is built on top of existing <span class="No-Break">HTTP standards.</span></li><li><em class="italic">Cons</em>: Similar to header versioning, it requires clients to set <span class="No-Break">headers correctly.</span></li></ul></li>
				<li><strong class="bold">No versioning (implicit versioning)</strong>: No versioning <a id="_idIndexMarker812"/>in API versioning is a method of <a id="_idIndexMarker813"/>designing a REST API that does not require any explicit version indicators in the URIs, headers, or media types. The following lists an example and the pros and cons of <span class="No-Break">this method:</span><ul><li><em class="italic">Example</em>: <strong class="source-inline">/api/resource</strong> (The <strong class="source-inline">/api/resource</strong> part of the URI is the path that identifies the specific resource that the client wants to access <span class="No-Break">or manipulate).</span></li><li><em class="italic">Pros</em>: It is the <span class="No-Break">simplest approach.</span></li><li><em class="italic">Cons</em>: It may lead to backward compatibility issues as the <span class="No-Break">API evolves.</span></li></ul></li>
			</ul>
			<p>API versioning is <a id="_idIndexMarker814"/>essential for maintaining <a id="_idIndexMarker815"/>better compatibility while working and <span class="No-Break">deploying APIs.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> depicts the process of REST API libraries <span class="No-Break">and versioning:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B14980_10_02.jpg" alt="Figure 10.2: REST API libraries and versioning (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: REST API libraries and versioning (image by Freepik)</p>
			<p>In summary, choose the versioning strategy that aligns with your application’s needs and ensures a smooth transition for existing clients while accommodating <span class="No-Break">future changes.</span></p>
			<p>Now, we can continue to the next section, in which we will talk about authentication and authorization and <span class="No-Break">data validation.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor193"/>Authentication and authorization and data validation</h1>
			<p>In microservices architecture, you have to authenticate, authorize, and validate data in order to continue to get results from <span class="No-Break">API architecture.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Authentication and authorization</h2>
			<p><strong class="bold">Authentication and authorization</strong> are critical components of securing a microservices architecture. Here’s an overview of <span class="No-Break">these concepts:</span></p>
			<ul>
				<li><strong class="bold">Authentication</strong>: Authentication in<a id="_idIndexMarker816"/> microservices is the process of verifying the identity of users or services that access or communicate with the microservices. Authentication is essential for ensuring the security and reliability of <span class="No-Break">microservice-based applications:</span><ul><li><em class="italic">Node.js implementation</em>: Use authentication middleware, such as <strong class="bold">Passport.js</strong>, to <a id="_idIndexMarker817"/>handle user authentication. Implement various authentication strategies (e.g., local authentication, OAuth, JWT) depending on the <span class="No-Break">application’s requirements.</span></li><li><em class="italic">Example</em> (using Passport.js with <span class="No-Break">local strategy):</span><pre class="source-code">
const passport = require('passport');</pre><pre class="source-code">
const LocalStrategy = require('passport-local').Strategy;</pre><pre class="source-code">
passport.use(new LocalStrategy(</pre><pre class="source-code">
  (username, password, done) =&gt; {</pre><pre class="source-code">
    // Assuming a simple username/password check for demonstration purposes</pre><pre class="source-code">
if (username === 'same_name' &amp;&amp; password === 'secret') {</pre><pre class="source-code">
      const user = { id: 1, username: ' same_name' };</pre><pre class="source-code">
      return done(null, user); // Authentication successful</pre><pre class="source-code">
    } else {</pre><pre class="source-code">
      return done(null, false); // Authentication failed</pre><pre class="source-code">
    }</pre><pre class="source-code">
  }</pre><pre class="source-code">
));</pre></li></ul></li>
				<li><strong class="bold">Authorization</strong>: Authorization <a id="_idIndexMarker818"/>determines what actions a user, system, or application is allowed to perform <span class="No-Break">after authentication:</span><ul><li><em class="italic">Node.js implementation</em>: Use middleware or custom functions to check user roles or permissions before allowing access to <span class="No-Break">certain routes.</span></li><li><em class="italic">Example</em> (middleware for checking <span class="No-Break">user roles):</span><pre class="source-code">
function isAdmin(req, res, next) {</pre><pre class="source-code">
  if (req.user &amp;&amp; req.user.role === 'admin') {</pre><pre class="source-code">
    return next(); // User is authorized</pre><pre class="source-code">
  }</pre><pre class="source-code">
  res.status(403).send('Forbidden'); // User is not authorized</pre><pre class="source-code">
}</pre><pre class="source-code">
// Usage in a route</pre><pre class="source-code">
app.get('/admin/resource', isAdmin, (req, res) =&gt; {</pre><pre class="source-code">
  // Handle the request for admin-only resource</pre><pre class="source-code">
});</pre></li></ul></li>
				<li><strong class="bold">Token-based authentication</strong>: <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) are a compact, URL-safe <a id="_idIndexMarker819"/>means of representing claims between <a id="_idIndexMarker820"/>two parties. They are commonly used <span class="No-Break">for authentication:</span><ul><li><em class="italic">Node.js implementation</em>: Use a library such as <strong class="source-inline">jsonwebtoken</strong> to generate and <span class="No-Break">verify JWTs.</span></li><li><em class="italic">Example</em> (using JWT for token generation <span class="No-Break">and verification):</span><pre class="source-code">
const jwt = require('jsonwebtoken');</pre><pre class="source-code">
// Generate a token</pre><pre class="source-code">
const token = jwt.sign({ userId: '123' }, 'secretKey', { expiresIn: '1h' });</pre><pre class="source-code">
// Verify a token</pre><pre class="source-code">
jwt.verify(token, 'secretKey', (err, decoded) =&gt; {</pre><pre class="source-code">
  if (err) {</pre><pre class="source-code">
    // Token is invalid</pre><pre class="source-code">
  } else {</pre><pre class="source-code">
    // Token is valid, use decoded data</pre><pre class="source-code">
  }</pre><pre class="source-code">
});</pre></li></ul></li>
			</ul>
			<p>Having these <a id="_idIndexMarker821"/>concepts in mind and practicing with these codes can help create a better architecture for authenticating and authorizing <span class="No-Break">in Node.js.</span></p>
			<p>We can continue now with <span class="No-Break">data validation.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Data validation</h2>
			<p><strong class="bold">Data validation</strong> is<a id="_idIndexMarker822"/> crucial for ensuring that incoming data meets the expected criteria, preventing security vulnerabilities, and maintaining data integrity. The methods of validation are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Joi validation library</strong>: Joi is a <a id="_idIndexMarker823"/>powerful validation library for<a id="_idIndexMarker824"/> JavaScript that allows you to define the structure of data and validate it against <span class="No-Break">a schema:</span><ul><li><em class="italic">Node.js implementation</em>: Install using <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install joi</strong></span><span class="No-Break">.</span></li><li><em class="italic">Example</em> (using Joi for request validation in <span class="No-Break">a route):</span><pre class="source-code">
const Joi = require('joi');</pre><pre class="source-code">
const schema = Joi.object({</pre><pre class="source-code">
  username: Joi.string().alphanum().min(3).max(30).required(),</pre><pre class="source-code">
  password: Joi.string().pattern(new RegExp('^[a-zA-Z0-9]{3,30}$')),</pre><pre class="source-code">
});</pre><pre class="source-code">
app.post('/api/register', (req, res) =&gt; {</pre><pre class="source-code">
  const { error, value } = schema.validate(req.body);</pre><pre class="source-code">
  if (error) {</pre><pre class="source-code">
    res.status(400).send(error.details[0].message);</pre><pre class="source-code">
  } else {</pre><pre class="source-code">
    // Process the valid data</pre><pre class="source-code">
  }</pre><pre class="source-code">
});</pre></li></ul></li>
				<li><strong class="bold">Validator.js library</strong>: A<a id="_idIndexMarker825"/> library <a id="_idIndexMarker826"/>of string validators <span class="No-Break">and sanitizers:</span><ul><li><em class="italic">Node.js implementation</em>: Install the library with the command <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">install validator</strong></span><span class="No-Break">.</span></li><li><em class="italic">Example</em> (using validator.js library for string validators <span class="No-Break">and sanitizers):</span><pre class="source-code">
// import the validator module</pre><pre class="source-code">
var validator = require('validator');</pre><pre class="source-code">
// check if the example email is a true email</pre><pre class="source-code">
validator.isEmail('foo@bar.com'); //=&gt; true</pre></li></ul></li>
				<li><strong class="bold">Sanitization</strong>: Sanitization<a id="_idIndexMarker827"/> involves cleaning and validating data to protect against common security vulnerabilities, such as SQL injection<a id="_idIndexMarker828"/> or <strong class="bold">cross-site </strong><span class="No-Break"><strong class="bold">scripting</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">XSS</strong></span><span class="No-Break">):</span><ul><li><em class="italic">Node.js implementation</em>: Use libraries such<a id="_idIndexMarker829"/> as <strong class="bold">dompurify</strong> for sanitizing HTML input or parameterized queries for preventing <span class="No-Break">SQL injection.</span></li><li><em class="italic">Example</em> (using dompurify for <span class="No-Break">HTML sanitization):</span><pre class="source-code">
const DOMPurify = require('dompurify');</pre><pre class="source-code">
const sanitizedHTML = DOMPurify.sanitize(req.body.htmlInput);</pre></li></ul></li>
				<li><strong class="bold">Regular Expressions</strong>: Regular expressions (regex) can be used for more complex <a id="_idIndexMarker830"/>data validation, such as validating email addresses <span class="No-Break">or passwords.</span><ul><li><em class="italic">Example</em> (using a regex for <span class="No-Break">email validation):</span><pre class="source-code">
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;</pre><pre class="source-code">
if (!emailRegex.test(req.body.email)) {</pre><pre class="source-code">
  // Handle invalid email address</pre><pre class="source-code">
}</pre></li></ul></li>
				<li><strong class="bold">Cross-site scripting (XSS)</strong>: A type <a id="_idIndexMarker831"/>of web security vulnerability that allows attackers to inject and execute malicious code in web pages. XSS attacks can compromise the confidentiality, integrity, and availability of web applications and their users. XSS attacks can be classified into three types: reflected, stored, <span class="No-Break">and DOM-based.</span><p class="list-inset">Sanitization is a <a id="_idIndexMarker832"/>technique to prevent or mitigate XSS attacks by removing or encoding any potentially harmful characters or scripts from user input or output. Sanitization can be applied at different stages of the web application, such as input validation, output encoding, or <span class="No-Break">HTML sanitization:</span></p><ul><li><strong class="bold">Input validation</strong>: This <a id="_idIndexMarker833"/>is the process of checking and rejecting any user input that does not meet the expected criteria or format. Input validation can help prevent XSS attacks by blocking malicious input before it reaches the web application logic <span class="No-Break">or database.</span></li><li><strong class="bold">Output encoding</strong>: This is<a id="_idIndexMarker834"/> the process of converting any special characters or symbols in user output to their equivalent HTML entities or codes. Output encoding can help prevent XSS attacks by ensuring that user output is treated as plain text and not as code by <span class="No-Break">the browser.</span></li><li><strong class="bold">HTML sanitization</strong>: This <a id="_idIndexMarker835"/>is the process of filtering and removing any unwanted or dangerous HTML tags, attributes, or styles from user output. HTML sanitization can help prevent XSS attacks by allowing only safe and well-formed HTML output to be rendered by <span class="No-Break">the browser.</span></li></ul></li>
			</ul>
			<p>Sanitization is an essential technique to protect web applications and users from XSS attacks. However, sanitization alone is not enough to prevent all types of XSS attacks. Sanitization should be combined with other defensive measures, such as using secure web frameworks, following secure coding practices, implementing content security policies, and educating users about <span class="No-Break">web security.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em> illustrates <a id="_idIndexMarker836"/>data validation <span class="No-Break">in API:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B14980_10_03.jpg" alt="Figure 10.3: Data validation in API (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: Data validation in API (image by Freepik)</p>
			<p>In summary, implementing <a id="_idIndexMarker837"/>strong authentication, authorization, and data validation practices is crucial for building secure and reliable microservices in a <span class="No-Break">Node.js environment.</span></p>
			<p>In the next section, we will learn about error handling and <span class="No-Break">API documentation.</span></p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Error handling and API documentation</h1>
			<p><strong class="bold">Error handling</strong> is a<a id="_idIndexMarker838"/> critical aspect of building robust microservices to ensure graceful degradation and effective debugging. Clear and comprehensive API documentation is essential for enabling developers to understand and consume <span class="No-Break">your microservices.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Error handling</h2>
			<p>Here’s how you can handle errors in a Node.js <span class="No-Break">microservices environment:</span></p>
			<ul>
				<li><strong class="bold">Express.js error handling middleware</strong>: Use Express.js middleware to handle<a id="_idIndexMarker839"/> errors globally. This middleware is invoked for unhandled errors that occur during request processing. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
app.use((err, req, res, next) =&gt; {</pre><pre class="source-code">
  console.error(err.stack);</pre><pre class="source-code">
  res.status(500).send('Something went wrong!');</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Custom error classes</strong>: Create <a id="_idIndexMarker840"/>custom error classes for different types of errors that may occur in your application. This helps in identifying and handling errors more precisely. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
class CustomError extends Error {</pre><pre class="source-code">
  constructor(message, statusCode) {</pre><pre class="source-code">
    super(message);</pre><pre class="source-code">
    this.statusCode = statusCode;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre><pre class="source-code">
// Usage</pre><pre class="source-code">
throw new CustomError('Custom error message', 400);</pre></li>
				<li><strong class="bold">Logging</strong>: Implement <a id="_idIndexMarker841"/>comprehensive logging to record details about errors, including stack traces, and to request information and any relevant context. The following snippet is an example of this (using a logging library <a id="_idIndexMarker842"/>such <span class="No-Break">as </span><span class="No-Break"><strong class="bold">Winston</strong></span><span class="No-Break">):</span><pre class="source-code">
const winston = require('winston');</pre><pre class="source-code">
winston.error('Error message', { error: err, request: req });</pre></li>
				<li><strong class="bold">HTTP status codes</strong>: Use appropriate HTTP status codes to indicate the nature <a id="_idIndexMarker843"/>of the error. Common status codes include <strong class="source-inline">400</strong> for client errors, <strong class="source-inline">500</strong> for server errors, and others as needed. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
app.get('/api/resource', (req, res, next) =&gt; {</pre><pre class="source-code">
  const error = new Error('Resource not found');</pre><pre class="source-code">
  error.status = 404;</pre><pre class="source-code">
  next(error);</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Async/await error handling</strong>: When using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>, ensure proper error<a id="_idIndexMarker844"/> handling using <strong class="source-inline">try</strong> or <strong class="source-inline">catch</strong> blocks. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
app.get('/api/resource', async (req, res, next) =&gt; {</pre><pre class="source-code">
  try {</pre><pre class="source-code">
    const data = await fetchData();</pre><pre class="source-code">
    res.json(data);</pre><pre class="source-code">
  } catch (err) {</pre><pre class="source-code">
    next(err);</pre><pre class="source-code">
  }</pre><pre class="source-code">
});</pre></li>
			</ul>
			<p>Error handling in microservices can avoid headaches later while developing microservices in Node.js. It helps developers to <span class="No-Break">debug faster.</span></p>
			<p>In the next section, we will talk about API documentation <span class="No-Break">in microservices.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>API documentation</h2>
			<p>Clear and comprehensive<a id="_idIndexMarker845"/> API documentation is essential for enabling developers to understand and consume your microservices. Here are some approaches for documenting <span class="No-Break">your APIs:</span></p>
			<ul>
				<li><strong class="bold">Swagger/OpenAPI</strong>: Use <strong class="bold">Swagger</strong>/<strong class="bold">OpenAPI</strong> specifications<a id="_idIndexMarker846"/> to describe your API endpoints, including <a id="_idIndexMarker847"/>details about request and response formats, authentication methods, and more. Tools such <a id="_idIndexMarker848"/>as <strong class="bold">Swagger UI</strong> or <strong class="bold">ReDoc</strong> can <a id="_idIndexMarker849"/>render interactive documentation from OpenAPI specifications. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
openapi: 3.0.0</pre><pre class="source-code">
info:</pre><pre class="source-code">
  title: My API</pre><pre class="source-code">
  version: 1.0.0</pre><pre class="source-code">
paths:</pre><pre class="source-code">
  /api/resource:</pre><pre class="source-code">
    get:</pre><pre class="source-code">
      summary: Get resource</pre><pre class="source-code">
      responses:</pre><pre class="source-code">
        '200':</pre><pre class="source-code">
          description: Successful response</pre></li>
				<li><strong class="bold">API Blueprint</strong>: API Blueprint is <a id="_idIndexMarker850"/>another format for API documentation. API Blueprint is a language for designing and documenting web APIs. It uses a combination of Markdown and MSON syntax to describe the format, structure, and rules of the data exchange between the service provider and the consumer. API Blueprint allows for easy collaboration, abstraction, and modularity in the API design process. Tools such as <strong class="bold">Apiary</strong> can<a id="_idIndexMarker851"/> generate documentation from API Blueprint files. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
## Get Resource [/api/resource]</pre><pre class="source-code">
+ Response 200 (application/json)</pre><pre class="source-code">
  + Body</pre><pre class="source-code">
    {</pre><pre class="source-code">
      "data": "Resource data"</pre><pre class="source-code">
    }</pre></li>
				<li><strong class="bold">Postman collections</strong>: If you’re <a id="_idIndexMarker852"/>using <strong class="bold">Postman</strong> for testing, you can create collections<a id="_idIndexMarker853"/> that include detailed information about your API requests and responses. Postman allows you to export collections, making it a shareable form of <span class="No-Break">API documentation.</span></li>
				<li><strong class="bold">Inline comments in code</strong>: Include inline comments in your code to describe the purpose<a id="_idIndexMarker854"/> and usage of each API endpoint. These comments can be extracted into documentation using tools such<a id="_idIndexMarker855"/> as <strong class="bold">JSDoc</strong>. The following snippet is an example <span class="No-Break">of this:</span><pre class="source-code">
/**</pre><pre class="source-code">
* Get resource</pre><pre class="source-code">
* @route GET /api/resource</pre><pre class="source-code">
* @returns {object} 200 - Successful response</pre><pre class="source-code">
*/</pre><pre class="source-code">
app.get('/api/resource', (req, res) =&gt; {</pre><pre class="source-code">
  res.json({ data: 'Resource data' });</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Documentation sites</strong>: Create a <a id="_idIndexMarker856"/>dedicated documentation website for your microservices, presenting detailed guides, examples, and <a id="_idIndexMarker857"/>interactive API exploration. Tools such as <strong class="bold">Docusaurus</strong> or <strong class="bold">Slate</strong> can<a id="_idIndexMarker858"/> help in building <span class="No-Break">documentation websites.</span></li>
			</ul>
			<p>In summary, ensure that your API documentation is kept up to date with changes to the API, providing accurate and relevant information to the developers who consume <span class="No-Break">your microservices.</span></p>
			<p>In the last section, we are going to talk about API testing and <span class="No-Break">API gateway.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>API testing and API gateway</h1>
			<p>API testing is crucial for ensuring the reliability and correctness of microservices. An API Gateway is a central component in a microservices architecture, providing a unified entry point for managing and <span class="No-Break">securing APIs.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>API testing</h2>
			<p><strong class="bold">API testing</strong> is the <a id="_idIndexMarker859"/>process of confirming that an API is working as expected. Developers can run API tests manually, or they can automate them with an API testing tool. There are several types of API tests, and each one plays a distinct role in ensuring that the API <span class="No-Break">remains reliable:</span></p>
			<ul>
				<li><strong class="bold">Unit testing</strong>: In <a id="_idIndexMarker860"/>unit testing, we<a id="_idIndexMarker861"/> test individual units of code (functions, modules) in isolation. Requirements and examples are <span class="No-Break">as follows:</span><ul><li><em class="italic">Tools</em>: Testing <a id="_idIndexMarker862"/>frameworks<a id="_idIndexMarker863"/> such<a id="_idIndexMarker864"/> as <strong class="bold">Jest</strong>, <strong class="bold">Mocha</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="bold">Jasmine</strong></span><span class="No-Break">.</span></li><li><em class="italic">Example</em> (<span class="No-Break">using Jest):</span><pre class="source-code">
test('adds 1 + 2 to equal 3', () =&gt; {</pre><pre class="source-code">
  expect(sum(1, 2)).toBe(3);</pre><pre class="source-code">
});</pre></li></ul></li>
				<li><strong class="bold">Integration testing</strong>: Through<a id="_idIndexMarker865"/> integration testing, we <a id="_idIndexMarker866"/>verify the interaction between different components or services. Requirements and examples are <span class="No-Break">as follows:</span><ul><li><em class="italic">Tools</em>: <strong class="bold">Supertest</strong>, <strong class="bold">Chai HTTP</strong>, or your<a id="_idIndexMarker867"/> preferred HTTP <span class="No-Break">testing </span><span class="No-Break"><a id="_idIndexMarker868"/></span><span class="No-Break">library.</span></li><li><em class="italic">Example</em> (<span class="No-Break">using Supertest):</span><pre class="source-code">
const request = require('supertest');</pre><pre class="source-code">
const app = require('../app');</pre><pre class="source-code">
test('GET /api/resource returns 200', async () =&gt; {</pre><pre class="source-code">
  const response = await request(app).get('/api/resource');</pre><pre class="source-code">
  expect(response.status).toBe(200);</pre><pre class="source-code">
});</pre></li></ul></li>
				<li><strong class="bold">End-to-end testing</strong>: The purpose<a id="_idIndexMarker869"/> of end-to-end testing is to <a id="_idIndexMarker870"/>test the entire application or a specific user <a id="_idIndexMarker871"/>flow. Requirements <a id="_idIndexMarker872"/>and examples <a id="_idIndexMarker873"/>are <span class="No-Break">as follows:</span><ul><li><em class="italic">Tools</em>: <strong class="bold">Cypress</strong>, <strong class="bold">Puppeteer</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Nightwatch</strong></span><span class="No-Break">.</span></li><li><em class="italic">Example</em> (<span class="No-Break">using Cypress):</span><pre class="source-code">
describe('My API', () =&gt; {</pre><pre class="source-code">
  it('successfully loads', () =&gt; {</pre><pre class="source-code">
    cy.visit('/api/resource');</pre><pre class="source-code">
    cy.contains('Resource data');</pre><pre class="source-code">
  });</pre><pre class="source-code">
});</pre></li></ul></li>
				<li><strong class="bold">Mocking and stubbing</strong>: Through<a id="_idIndexMarker874"/> this, we simulate dependencies <a id="_idIndexMarker875"/>or external services<a id="_idIndexMarker876"/> to isolate the system under test. Requirements and examples are <span class="No-Break">as follows:</span><ul><li><em class="italic">Tools</em>: <strong class="bold">Nock</strong>, <strong class="bold">Sinon</strong>, or<a id="_idIndexMarker877"/> Jest’s <a id="_idIndexMarker878"/>built-in <span class="No-Break">mocking functions.</span></li><li><em class="italic">Example</em> (<span class="No-Break">using Nock):</span><pre class="source-code">
const nock = require('nock');</pre><pre class="source-code">
nock('https://api.example.com')</pre><pre class="source-code">
  .get('/data')</pre><pre class="source-code">
  .reply(200, { data: 'Mocked data' });</pre></li></ul></li>
				<li><strong class="bold">Data-driven testing</strong>: In <a id="_idIndexMarker879"/>data-driven testing, we test <a id="_idIndexMarker880"/>different input data and conditions to ensure the system behaves correctly. Requirements and examples are <span class="No-Break">as follows:</span><ul><li><em class="italic">Tools</em>: Jest’s parameterized tests, and test <span class="No-Break">data libraries.</span></li><li><em class="italic">Example</em> (Jest <span class="No-Break">parameterized test):</span><pre class="source-code">
test.each([</pre><pre class="source-code">
  [1, 2, 3],</pre><pre class="source-code">
  [0, 0, 0],</pre><pre class="source-code">
  [-1, 1, 0],</pre><pre class="source-code">
])('adds %i + %i to equal %i', (a, b, expected) =&gt; {</pre><pre class="source-code">
  expect(sum(a, b)).toBe(expected);</pre><pre class="source-code">
});</pre></li></ul></li>
			</ul>
			<p>As we have learned, these concepts of testing can favor a lot to test the software better and deliver <span class="No-Break">well-tested software.</span></p>
			<p>We can now continue to the <span class="No-Break">API gateway.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>API gateway</h2>
			<p>An <strong class="bold">API gateway</strong> is a<a id="_idIndexMarker881"/> software component that acts as an intermediary between clients and backend services. It handles various tasks such as routing, authentication, rate limiting, monitoring, and policy enforcement for the API calls. It also simplifies client-side development by providing a unified interface to access <span class="No-Break">multiple services.</span></p>
			<p>One of the benefits of using an API gateway is that it can reduce the complexity and improve the performance of microservices-based applications. Using an API gateway, you can decouple the internal structure of your application from the external clients and implement common functionalities at the gateway level instead of repeating them in each service. You can also use an API gateway to aggregate and transform the responses from multiple services into a single result for <span class="No-Break">the client.</span></p>
			<p>Here’s how API Gateways contribute to a Node.js <span class="No-Break">microservices ecosystem:</span></p>
			<ul>
				<li><strong class="bold">Request routing</strong>: An <a id="_idIndexMarker882"/>API gateway routes incoming requests to the appropriate microservice based on predefined rules or configurations. The following shows an example (<span class="No-Break">Express.js route):</span><pre class="source-code">
// API Gateway route</pre><pre class="source-code">
app.get('/api/resource', (req, res) =&gt; {</pre><pre class="source-code">
  // Forward request to the appropriate microservice</pre><pre class="source-code">
  // ...</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Load balancing</strong>: Load balancers are devices or applications that distribute the incoming<a id="_idIndexMarker883"/> network traffic across multiple servers or nodes. They help to improve the performance, scalability, and reliability of web applications by balancing the workload and avoiding overloading any single server. Load balancers use different algorithms or methods to decide which server should handle each request, such as round robin, least connections, least time, hash, or random. Load balancers can be either <a id="_idIndexMarker884"/>hardware-based or software-based, and they can run on a dedicated device, a server, a virtual machine, or in the cloud. Distribute incoming traffic across multiple instances of a microservice to ensure optimal resource utilization and reliability. The following shows an example (Nginx load <span class="No-Break">balancing configuration):</span><pre class="source-code">
upstream microservices {</pre><pre class="source-code">
  server microservice1:3000;</pre><pre class="source-code">
  server microservice2:3000;</pre><pre class="source-code">
}</pre></li>
				<li><strong class="bold">Authentication and authorization</strong>: Centralize<a id="_idIndexMarker885"/> authentication and authorization logic, ensuring that only <a id="_idIndexMarker886"/>authenticated and authorized requests reach the microservices. The following shows  an example (<span class="No-Break">Express.js middleware):</span><pre class="source-code">
// API Gateway middleware</pre><pre class="source-code">
app.use('/api', (req, res, next) =&gt; {</pre><pre class="source-code">
  // Authenticate and authorize the request</pre><pre class="source-code">
  // ...</pre><pre class="source-code">
  next();</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Rate limiting and throttling</strong>: Control the rate at which requests are allowed to <a id="_idIndexMarker887"/>prevent abuse or overuse of microservices. The following shows an example (Express.js rate <span class="No-Break">limiting middleware):</span><pre class="source-code">
const rateLimit = require('express-rate-limit');</pre><pre class="source-code">
const apiLimiter = rateLimit({</pre><pre class="source-code">
  windowMs: 15 * 60 * 1000, // 15 minutes</pre><pre class="source-code">
  max: 100, // limit each IP to 100 requests per windowMs</pre><pre class="source-code">
});</pre><pre class="source-code">
// Apply rate limiting to the API Gateway routes</pre><pre class="source-code">
app.use('/api', apiLimiter);</pre></li>
				<li><strong class="bold">Response aggregation</strong>: Aggregate <a id="_idIndexMarker888"/>responses from multiple microservices into a single response for the client. The following shows an example (<span class="No-Break">Express.js route):</span><pre class="source-code">
// API Gateway route for response aggregation</pre><pre class="source-code">
app.get('/api/aggregated-resource', async (req, res) =&gt; {</pre><pre class="source-code">
  // Call multiple microservices and aggregate responses</pre><pre class="source-code">
  // ...</pre><pre class="source-code">
});</pre></li>
				<li><strong class="bold">Monitoring and analytics</strong>: Collect <a id="_idIndexMarker889"/>and analyze data on API usage, performance, and errors to gain insights into the health of the <span class="No-Break">microservices architecture.</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em> illustrates the process of the <span class="No-Break">API gateway:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B14980_10_04.jpg" alt="Figure 10.4: API Gateway (image by Freepik)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: API Gateway (image by Freepik)</p>
			<p>In summary, an<a id="_idIndexMarker890"/> API Gateway simplifies the management and orchestration of microservices, providing a unified interface for clients while offloading common functionalities from individual microservices. It plays a crucial role in enhancing security, scalability, and maintainability in a <span class="No-Break">distributed system.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor202"/>Summary</h1>
			<p>In this chapter, we have learned a lot about microservices, how to communicate with APIs in microservices, and how different services interact with each other to fulfill business processes. Data contracts define how data is structured and exchanged <span class="No-Break">between microservices.</span></p>
			<p>In summary, effective API communication and data contracts are foundational to the success of microservices. They contribute to system flexibility, maintainability, and the ability to scale in complex, <span class="No-Break">distributed architectures.</span></p>
			<p>In the next chapter, we are going to learn about caching and asynchronous messaging <span class="No-Break">in microservices.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Quiz time</h1>
			<ul>
				<li>What are the key components to define <span class="No-Break">API contracts?</span></li>
				<li>What are the commonly used REST <span class="No-Break">API libraries?</span></li>
				<li>How can you handle authentication and authorization <span class="No-Break">with examples?</span></li>
				<li>How to document <span class="No-Break">your APIs?</span></li>
			</ul>
		</div>
	</body></html>