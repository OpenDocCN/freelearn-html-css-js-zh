- en: Chapter 8. SOLID Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID Principles are well-known Object-Oriented Design (**OOD**)principles summarized
    by Uncle Bob (Robert C. Martin). The word SOLID comes from the initials of the
    five principles it refers to, including **Single responsibility principle**, **Open-closed
    principle**, **Liskov substitution principle**, **Interface segregation principle**
    and **Dependency inversion principle**. Those principles are closely related to
    each other, and can be a great guidance in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a widely used summary of SOLID principles from Uncle Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility principle**: A class should have one, and only one,
    reason to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-closed principle**: You should be able to extend a classes behavior,
    without modifying it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution principle**: Derived classes must be substitutable for
    their base classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation principle**: Make fine-grained interfaces that are
    client specific'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion principle**: Depend on abstractions, not on concretions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will walk through them and find out how those principles
    can help form a design that *smells* nice.
  prefs: []
  type: TYPE_NORMAL
- en: But before we proceed, I want to mention that a few of the reasons why those
    principles exist might be related to the age in which they were raised, the languages
    and their building or distributing process people were working with, and even
    computing resources. When being applied to JavaScript and TypeScript projects
    nowadays, some of the details may not be necessary. Think more about what problems
    those principles want to prevent people from getting into, rather than the literal
    descriptions of how a principle should be followed.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The single responsibility principle declares that a class should have one, and
    only one reason to change. And the definition of the world *reason* in this sentence
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a `Command` class that is designed to work with both command-line
    interface and graphical user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this actually work, `execute` method would need to handle both the
    command execution and result displaying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, there are two reasons for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: How a command gets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How the result of a command gets displayed in different environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Those reasons lead to changes in different dimensions and violate the single
    responsibility principle. This might result in a messy situation over time. A
    better solution is to have those two responsibilities separated and managed by
    the `CommandEnvironment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Does this look familiar to you? Because it is a variant of the Visitor Pattern.
    Now it is the environment that executes a specific command and handles its result
    based on a concrete environment class.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be thinking, doesn't `CommandResult` violate the single responsibility
    principle by having the abilities to display content in a different environment?
    Yes, and no. When the axis of this reason is set to displaying content, it does
    not; but if the axis is set to displaying in a specific environment, it does.
    But take the overall structure into consideration, the result of a command is
    expected to be an output that can adapt to a different environment. And thus the
    reason is one-dimensional and confirms the principle.
  prefs: []
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The open-closed principle declares that you should be able to extend a class''
    behavior, without modifying it. This principle is raised by Bertrand Meyer in
    1988:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software entities (classes, modules, functions, etc.) should be open for extension,
    but closed for modification.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A program depends on all the entities it uses, that means changing the already-being-used
    part of those entities may just crash the entire program. So the idea of the open-closed
    principle is straightforward: we''d better have entities that never change in
    any way other than extending itself.'
  prefs: []
  type: TYPE_NORMAL
- en: That means once a test is written and passing, ideally, it should never be changed
    for newly added features (and it needs to keep passing, of course). Again, ideally.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider an API hub that handles HTTP requests to and responses from the server.
    We are going to have several files written as modules, including `http-client.ts`,
    `hub.ts` and `app.ts` (but we won't actually write `http-client.ts` in this example,
    you will need to use some imagination).
  prefs: []
  type: TYPE_NORMAL
- en: Save the code below as file `hub.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And save the code below as file `app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Bravely done! Now we have `app.ts` badly coupled with `http-client.ts`. And
    if we want to adapt this API hub to something like WebSocket, BANG.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we create entities that are open for extension, but closed for modification?
    The key is a *stable abstraction that adapts*. Consider the storage and client
    example we took with Adapter Pattern in [Chapter 4](ch04.html "Chapter 4. Structural
    Design Patterns"), *Structural Design Patterns* we had a `Storage` interface that
    isolates implementation of database operations from the client. And assuming that
    the interface is well-designed to meet upcoming feature requirements, it is possible
    that it will never change or just need to be extended during the life cycle of
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction in JavaScript and TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guess what, our beloved JavaScript does not have an interface, and it is dynamically
    typed. We were not even able to actually write an interface. However, we could
    still write down documentation about the abstraction and create new concrete implementations
    just by obeying that description.
  prefs: []
  type: TYPE_NORMAL
- en: 'But TypeScript offers interface, and we can certainly take advantage of it.
    Consider the `CommandResult` class in the previous section. We were writing it
    as a concrete class, but it may have subclasses that override the `print` or `render`
    method for customized output. However, the type system in TypeScript cares only
    about the shape of a type. That means, while you are declaring an entity with
    type `CommandResult`, the entity does not need to be an instance of `CommandResult`:
    any object with a compatible type (namely has methods `print` and `render` with
    proper signatures in this case) will do the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Refactor earlier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I double stressed that the open-closed principle can only be perfectly followed
    under ideal scenarios. That can be a result of two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Not all entities in a system can be open to extension and closed to modification
    at the same time*. There will always be changes that need to break the closure
    of existing entities to complete their functionalities. When we are designing
    the interfaces, we need different strategies for creating stable closures for
    different foreseeable situations. But this requires notable experience and no
    one can do it perfectly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*None of us is too good at designing a program that lasts long and stays healthy
    forever*. Even with thorough consideration, abstractions designed at the beginning
    can be choppy facing the changing requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So when we are expecting the entities to be closed for modification, it does
    not mean that we should just stand there and watch it being closed. Instead, when
    things are still under control, we should refactor and *keep the abstraction in
    the status of being open to extension and closed to modification* at the time
    point of refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The open-closed principle is the essential principle of keeping code maintainable
    and reusable. And the key to the open-closed principle is abstraction with polymorphism.
    Behaviors like implementing interfaces, or extending classes make polymorphic
    *shapes*, but that might not be enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Liskov substitution principle declares that derived classes must be substitutable
    for their base classes. Or in the words of Barbara Liskov, who raised this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What is wanted here is something like the following substitution property:
    If for each object o1 of type S there is an object o2 of type T such that for
    all programs P defined in terms of T, the behavior of P is unchanged when o1 is
    substituted for o2 then S is a subtype of T.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Never mind. Let''s try another one: *any foreseeable usage of the instance
    of a class should be working with the instances of its derived classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And here we go with a straightforward violation example. Consider `Noodles`
    and `InstantNoodles` (a subclass of `Noodles`) to be cooked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now if we want to have some fried noodles... The `cookNoodles` function does
    not seem to be capable of handling that. Clearly, this violates the Liskov substitution
    principle, though it does not mean that it's a bad design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example written by Uncle Bob in his article talking
    about this principle. We are creating class `Square` which is a subclass of `Rectangle`,
    but instead of adding new features, it adds a constraint to `Rectangle`: the width
    and height of a square should always be equal to each other. Assume we have a
    `Rectangle` class that allows its width and height to be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a problem with its subclass `Square`, because it gets `width` and
    `height` setters from `Rectangle` while it shouldn't. We can certainly override
    those setters and make both of them update width and height simultaneously. But
    in some situations, the client might just not want that, because doing so will
    make the program harder to be predicted.
  prefs: []
  type: TYPE_NORMAL
- en: The `Square` and `Rectangle` example violates the Liskov substitution principle.
    Not because we didn't find a good way to inherit, but because `Square` does not
    conform the behavior of `Rectangle` and should not be a subclass of it at the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: The constraints of substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type is an important part in a programming language, even in JavaScript. But
    having the same *shape*, being on the same hierarchy does not mean they can be
    the substitution of another without some pain. More than just the *shape*, the
    complete behavior is what really matters for implementations that hold to the
    Liskov substitution principle.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already discussed the important role played by abstractions in object-oriented
    design. The abstractions and their derived classes without separation usually
    come up with hierarchical tree structures. That means when you choose to create
    a branch, you create a parallel abstraction to all of those on another branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a family of classes with only one level of inheritance, this is not a problem:
    because it is just what you want to have those classes derived from. But for a
    hierarchy with greater depth, it could be.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the `TextReader` example we took with Template Method Pattern in [Chapter
    6](ch06.html "Chapter 6. Behavioral Design Patterns: Continuous"), *Behavioral
    Design Patterns: Continuous* we had `FileAsciiTextReader` and `HttpAsciiTextReader`
    derived from `AsciiTextReader`. But what if we want to have other readers that
    understand UTF-8 encoding?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that goal, we have two common options: separate the interface into
    two for different objects that cooperate, or separate the interface into two then
    get them implemented by a single class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first case, we can refactor the code with two abstractions, `BytesReader`
    and `TextReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And for the second case, we can separate method `readAllBytes` and `decodeBytes`
    onto two interfaces, for example, `BytesReader` and `BytesDecoder`. Thus we may
    implement them separately and use techniques like mixin to put them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An interesting point about this example is that `TextReader` above itself is
    an abstract class. To make this mixin actually work, we need to create a concrete
    class of `TextReader` (without actually implementing `readAllBytes` and `decodeBytes`),
    and then mixin two concrete classes of `BytesReader` and `BytesDecoder`.
  prefs: []
  type: TYPE_NORMAL
- en: Proper granularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is said that by creating smaller interfaces, we can avoid a client from using
    big classes with features that it never needs. This may cause unnecessary usage
    of resources, but in practice, that usually won't be a problem. The most important
    part of the interface segregation principle is still about keeping code maintainable
    and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Then the question comes out again, how small should an interface be? I don't
    think I have a simple answer for that. But I am sure that being too small might
    not help.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about dependencies, the natural sense is about dependencies from
    bottom to top, just like how buildings are built. But unlike a building that stands
    for tens of years with little change, software keeps changing during its life
    cycle. Every change costs, more or less.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle declares that entities should depend on abstractions,
    not on concretions. Higher level code should not depend directly on low-level
    implementations, instead, it should depend on abstractions that *lead to* those
    implementations. And this is why things are *inverse*.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Still taking the HTTP client and API hub as an example, which obviously violates
    the dependency inversion principle, taking the foreseeable application into consideration,
    what the API hub should depend on is a messaging mechanism bridging client and
    server, but not bare HTTP client. This means we should have an abstraction layer
    of messaging before the concrete implementation of HTTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Separating layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to other principles discussed in this chapter, the dependency inversion
    principle cares more about the scope of modules or packages. As the abstraction
    might usually be more stable than concrete implementations, by following dependency
    inversion principle, we can minimize the impact from low-level changes to higher
    level behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: But for JavaScript (or TypeScript) projects as the language is dynamically typed,
    this principle is more about an idea of guidance that leads to a stable abstraction
    between different layers of code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, an important benefit of following this principle is that, if modules
    or packages are relatively larger, separating them by abstraction could save a
    lot of time in compilation. But for JavaScript, we don't have to worry about that;
    and for TypeScript, we don't have to recompile the entire project for making changes
    to separated modules either.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the well-known SOLID principles with simple
    examples. Sometimes, following those principles could lead us to a useful design
    pattern. And we also found that those principles are strongly bound to each other.
    Usually violating one of them may indicate other violations.
  prefs: []
  type: TYPE_NORMAL
- en: Those principles could be extremely helpful for OOD, but could also be overkill
    if they are applied without proper adaptions. A well-designed system should have
    those principles confirmed just right, or it might harm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, instead of theories, we'll have more time with a complete
    workflow with testing and continuous integration involved.
  prefs: []
  type: TYPE_NORMAL
