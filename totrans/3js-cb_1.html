<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started</h1></div></div></div><p>In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with the WebGL renderer</li><li class="listitem" style="list-style-type: disc">Getting started with the Canvas renderer</li><li class="listitem" style="list-style-type: disc">Getting started with the CSS 3D renderer</li><li class="listitem" style="list-style-type: disc">Detecting WebGL support</li><li class="listitem" style="list-style-type: disc">Setting up an animation loop</li><li class="listitem" style="list-style-type: disc">Determining the frame rate for your scene</li><li class="listitem" style="list-style-type: disc">Controlling the variables used in the scene</li><li class="listitem" style="list-style-type: disc">Setting up a local web server with Python</li><li class="listitem" style="list-style-type: disc">Setting up a local web server with Node.js</li><li class="listitem" style="list-style-type: disc">Setting up a local web server using Mongoose</li><li class="listitem" style="list-style-type: disc">Solving cross-origin-domain error messages in Chrome</li><li class="listitem" style="list-style-type: disc">Solving cross-origin-domain error messages in Firefox</li><li class="listitem" style="list-style-type: disc">Adding keyboard controls</li><li class="listitem" style="list-style-type: disc">Loading textures asynchronously</li><li class="listitem" style="list-style-type: disc">Loading models asynchronously</li><li class="listitem" style="list-style-type: disc">Loading models asynchronously with progress</li><li class="listitem" style="list-style-type: disc">Loading other resources asynchronously with progress</li><li class="listitem" style="list-style-type: disc">Waiting until resources are loaded</li><li class="listitem" style="list-style-type: disc">Dragging a file from the desktop to the scene</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>In this chapter we'll show you a number of recipes that introduce the basic usage of Three.js. We'll start with a number of simple recipes that you can use as a starting point for your Three.js projects. Next, we'll show you a couple of features that you can add to your project, such as WebGL detection and defining an animation loop. We'll end with a number of more advanced features such as adding drag and drop support, and loading resources synchronously and asynchronously.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Getting started with the WebGL renderer</h1></div></div></div><p>When <a id="id0" class="indexterm"/>you want to create an initial Three.js project that uses WebGL for rendering, you always have to set up the same couple of variables. You need a <code class="literal">THREE.WebGLRenderer</code> object, a <code class="literal">THREE.Scene</code> object, a camera, and some way to render the scene. In this recipe, we'll provide you with a standard template that you can use in your own projects to quickly get started with the WebGL renderer.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>Make sure that you download the sources for this book. You can either do this in the following two ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, you can do this by cloning the Git repo that you can find at <a class="ulink" href="https://github.com/josdirksen/threejs-cookbook">https://github.com/josdirksen/threejs-cookbook</a>.</li><li class="listitem" style="list-style-type: disc">Alternatively, you can download the sources from Packt Publishing website. When you extract the ZIP file or clone the repository you'll find a set of directories; one for each chapter of this book. For this recipe, you can use <code class="literal">0</code> as a reference.</li></ul></div><p>You can directly view the end result of this recipe by opening the previously mentioned file in your browser. When you open this example in the browser, you'll see the following screenshot:</p><div><img src="img/1182OS_01_01.jpg" alt="Getting ready"/></div><p>This is <a id="id1" class="indexterm"/>a minimal scene, rendered with the <code class="literal">THREE.WebGLRenderer</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>Creating a skeleton that you can use as a base for your projects is easy. With a couple of simple steps, you'll get your first WebGLRenderer-based Three.js scene up and running:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's first define the basic HTML that we'll use:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;01.01 - WebGLRenderer - Skeleton&lt;/title&gt;
    &lt;script src="img/three.js"&gt;&lt;/script&gt;
    &lt;style&gt;
      body {
      margin: 0;
      overflow: hidden;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      ...
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>As you <a id="id2" class="indexterm"/>can see this is use a simple page, with a <code class="literal">script</code> tag in the body that'll contain our Three.js code. The only interesting part is the CSS style. </p><p>We will add this style to the body element to make sure that our Three.js scene will run in fullscreen mode and won't show any scrollbars.</p></li><li class="listitem">Next, let's start by filling in the script tag. The first thing that we will do is create a number of global variables that are used throughout this recipe:<div><pre class="programlisting">      // global variables
      var renderer;
      var scene;
      var camera;</pre></div><p>The <code class="literal">renderer</code> variable will hold a reference to the <code class="literal">THREE.WebGLRenderer</code> object that we're going to create in the next step. The <code class="literal">scene</code> variable is the container for all the objects that we want to render, and the <code class="literal">camera</code>  variable determines what we will see when we render the scene.</p></li><li class="listitem">Usually, you'd want to wait for all the HTML elements to finish loading, before you start running your JavaScript. For this, we use the following JavaScript:<div><pre class="programlisting">      // calls the init function when the window is done loading.
      window.onload = init;</pre></div><p>With this code, we tell the browser to call the <code class="literal">init</code> function, once the complete page has loaded. In the next step, we'll show the content of this <code class="literal">init</code> function.</p></li><li class="listitem">For your<a id="id3" class="indexterm"/> skeleton to work, you need to add the <code class="literal">init</code> function, which looks as follows:<div><pre class="programlisting">function init() {

      // create a scene, that will hold all our elements 
      // such as objects, cameras and lights.
      scene = new THREE.Scene(); 
      // create a camera, which defines where we looking at.
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      // position and point the camera to the center
      camera.position.x = 15;
      camera.position.y = 16;
      camera.position.z = 13;
      camera.lookAt(scene.position);

      // create a renderer, set the background color and size
      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0x000000, 1.0);
      renderer.setSize(window.innerWidth, window.innerHeight);

      // create a cube and add to scene
      var cubeGeometry = new THREE.BoxGeometry(10 * Math.random(), 10 * Math.random(), 10 * Math.random());

      var cubeMaterial = new THREE.MeshNormalMaterial();

      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      scene.add(cube);

      // add the output of the renderer to the html element
      document.body.appendChild(renderer.domElement);

      // call the render function
      renderer.render(scene, camera);

      }</pre></div><p>In this <code class="literal">init</code> function, we first created a <code class="literal">THREE.Scene</code> object with the container for all the objects that we want to render. Next, we created a camera, which determines the field of the view that will be rendered. Next, we created the <code class="literal">THREE.WebGLRenderer</code> object, which is used to render the scene using WebGL. The <code class="literal">THREE.WebGLRenderer</code> object has many properties. In this recipe, we used the <code class="literal">setClearColor</code> property to set the background of our scene to black, and we told the renderer to use the complete window for its output, using the <code class="literal">window.innerWidth</code> and <code class="literal">window.innerHeight</code> properties. To see whether our skeleton page is working, we then added a simple <code class="literal">THREE.Mesh</code> object with a <code class="literal">THREE.BoxGeometry</code> object to the scene. At this point, we can add the output of the WebGL, as a child of the HTML body element. We do this by appending the renderer's DOM element to the document body. Now, all that is left to do is render the scene by calling <code class="literal">renderer.render()</code>.</p></li></ol></div><p>With <a id="id4" class="indexterm"/>these steps, you've created a basic <code class="literal">WebGLRenderer</code> based Three.js scene, which you can use as a basic starting point for all your Three.js experiments.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">THREE.WebGLRenderer</code> object only works when your browser supports WebGL. Even though most modern desktop browsers (and even a large number of mobile browsers) support WebGL, in some cases, you might need to look for an alternative. Three.js provides a couple of other renderers, which you can use. To get an up-to-date overview of which browsers support WebGL, you <a id="id5" class="indexterm"/>can check out the information on this topic at <a class="ulink" href="http://caniuse.com/webgl">http://caniuse.com/webgl</a>.</li><li class="listitem" style="list-style-type: disc">Besides using the <code class="literal">THREE.WebGLRenderer</code> object to render your scene, you can use the <code class="literal">THREE.CanvasRenderer</code> object, which is explained in <em>Getting started with the Canvas renderer</em> recipe or the <code class="literal">THREE.CSS3DRenderer</code> object, which is explained in the <em>Getting started with the CSS 3D renderer</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting started with the Canvas renderer</h1></div></div></div><p>If your<a id="id6" class="indexterm"/> system doesn't support WebGL, there is an alternative renderer that you can use to render your scenes: the <code class="literal">CanvasRenderer</code> object. This renderer doesn't use WebGL to render the output, but directly uses JavaScript to draw the HTML5 canvas element.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Getting ready</h2></div></div></div><p>In the r69 Version of Three.js, the canvas renderer has been removed from the default distribution. To use this renderer, we have to first import the following two files:</p><div><pre class="programlisting">    &lt;script src="img/CanvasRenderer.js"&gt;&lt;/script&gt;
    &lt;script src="img/Projector.js"&gt;&lt;/script&gt;</pre></div><p>For this recipe, you can take a look at the <code class="literal">01.02-canvasrenderer-skeleton.html</code> example from the sources in this chapter. If you open this example in your browser, you'll see a cube, pretty much like the one in the previous recipe:</p><div><img src="img/1182OS_01_02.jpg" alt="Getting ready"/></div><p>This time, however, this cube is rendered with the HTML5 canvas element. HTML5 canvas is supported on many devices, but provides less performance than the WebGL- based solution.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it...</h2></div></div></div><p>To set up the WebGL renderer, you will follow exactly the same steps as we showed in the previous<a id="id7" class="indexterm"/> recipe, <em>Getting started with the WebGL renderer</em>, so we won't go into the details in this section but we'll just list down the differences:</p><div><ol class="orderedlist arabic"><li class="listitem">To get started with the <code class="literal">THREE.CanvasRenderer</code> object, the only thing we need to change is the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replace the <code class="literal">THREE.WebGLRenderer</code> object in the following piece of code:<div><pre class="programlisting">      renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0x000000, 1.0);
      renderer.setSize(window.innerWidth, window.innerHeight);</pre></div></li><li class="listitem" style="list-style-type: disc">Replace the THREE.WebGLRenderer object with the <code class="literal">THREE.CanvasRenderer</code> object as follows:<div><pre class="programlisting">    renderer = new THREE.CanvasRenderer();
    renderer.setClearColor(0x000000, 1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);</pre></div></li></ul></div></li></ol></div><p>And that's it. With this change, we move from rendering using WebGL to rendering on the HTML5 canvas.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How it works...</h2></div></div></div><p>The main difference between the HTML5 canvas renderer and the WebGL renderer is that this approach uses JavaScript to directly draw to the HTML5 canvas for rendering your 3D scene. The main issue with this approach is the lousy performance. When you use the <code class="literal">THREE.WebGLRenderer</code> object, you can use hardware-accelerated rendering. However, with the <code class="literal">THREE.CanvasRenderer</code> object, you have to completely rely on software-based rendering, which will result in lower performance. An added disadvantage of <code class="literal">THREE.CanvasRenderer</code> is that you can't use the advanced materials and features of Three.js, as that relies on WebGL specific functionality.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you can use the WebGL approach given in the <em>Getting started with the WebGL renderer</em> recipe, you should really use it. It provides more features than those that are available with the canvas-based approach, and has much better performance.</li><li class="listitem" style="list-style-type: disc">In the following recipe, <em>Getting started with the CSS 3D renderer</em>, this will also show a different approach where we use the CSS 3D-based renderer to animate the HTML elements. CSS 3D also provides hardware accelerated rendering, but only has support for a limited set of Three.js features.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Getting started with the CSS 3D renderer</h1></div></div></div><p>HTML and <a id="id8" class="indexterm"/>CSS are getting more and more powerful each day. Modern browsers, both mobile and desktop variants, have great support for these two standards. The latest versions of CSS also support 3D transformations. With the <code class="literal">THREE.CSS3DRenderer</code> object, we can directly access these CSS 3D features and transform an arbitrary HTML element in 3D space.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Getting ready</h2></div></div></div><p>To use the CSS 3D renderer, we first have to download the specific JavaScript file from the Three.js site, as it hasn't been included in the standard Three.js distribution. You can download<a id="id9" class="indexterm"/> this file directly from GitHub at <a class="ulink" href="https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js">https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/renderers/CSS3DRenderer.js</a> or look in the lib directory of the sources provided with this book.</p><p>To see the <code class="literal">CSS3DRenderer</code> scene in action, you can open the example <code class="literal">01.03-cssrenderer-skeleton.html</code> in your browser:</p><div><img src="img/1182OS_01_03.jpg" alt="Getting ready"/></div><p>What you <a id="id10" class="indexterm"/>see here is a standard HTML div element, rendered in 3D with the <code class="literal">THREE.CSS3DRenderer</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><p>To set up a <code class="literal">THREE.CSS3DRenderer</code> based scene, we need to perform a couple of simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Before we get started with the <code class="literal">THREE.CSS3DRenderer</code> specific information, first, you have to set up a simple basic HTML page as we did in the <em>Getting started with the WebGL renderer</em> recipe. So walk through the first three steps of that recipe, and then continue with the next step.</li><li class="listitem">After the initial setup, the first thing that we need to do is to add the correct JavaScript to our head element:<div><pre class="programlisting">    &lt;script src="img/CSS3DRenderer.js"&gt;&lt;/script&gt;</pre></div><p>Next, we'll start with the definition of the global variables that we need:</p><div><pre class="programlisting">    var content = '&lt;div&gt;' +
      '&lt;h1&gt;This is an H1 Element.&lt;/h1&gt;' +
      '&lt;span class="large"&gt;Hello Three.js cookbook&lt;/span&gt;' +
      '&lt;textarea&gt; And this is a textarea&lt;/textarea&gt;' +
    '&lt;/div&gt;';

    // global variables, referenced from render loop
    var renderer;
    var scene;
    var camera;</pre></div></li><li class="listitem">What we define here is a string representation of the element that we want to render. As the <code class="literal">THREE.CSS3DRenderer</code> object works with the HTML elements, we won't use any of the standard Three.js geometries here, but just plain HTML. The renderer, scene, and camera are simple variables for the corresponding Three.js elements, so that we can easily access them from the <code class="literal">render()</code> function, which we'll see later on.</li><li class="listitem">Similar to the other skeletons we will initialize the scene in the <code class="literal">init()</code> function. The function that you need to add to the <code class="literal">THREE.CSS3DRenderer</code> object is shown as follows:<div><pre class="programlisting">    function init() {

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

<strong>      // create a CSS3DRenderer</strong>
<strong>      renderer = new THREE.CSS3DRenderer();</strong>
<strong>      renderer.setSize(window.innerWidth, window.innerHeight);</strong>
<strong>      document.body.appendChild(renderer.domElement);</strong>

      // position and point the camera to the center of the scene
      camera.position.x = 500;
      camera.position.y = 500;
      camera.position.z = 500;
      camera.lookAt(scene.position);

<strong>      var cssElement = createCSS3DObject(content);</strong>
<strong>      cssElement.position.set(100, 100, 100);</strong>
<strong>      scene.add(cssElement);</strong>

      render();
    }</pre></div></li><li class="listitem">We'll focus<a id="id11" class="indexterm"/> on the highlighted parts in this code fragment. For an explanation of the other parts of this function, we will take a look at the <em>Getting started with the WebGL renderer</em> recipe. As you can see in this fragment, this time we will create a <code class="literal">THREE.CSS3DRenderer</code> object. Just as we did with the other renderers, we also need to set the size. Since we want to fill the screen, we will use the <code class="literal">window.innerwidth</code> and <code class="literal">window.innerheight</code> properties. The rest of the code stays the same.</li><li class="listitem">Now, all we need to do to finish this skeleton is add an element. With the CSS 3D renderer, we can only add <code class="literal">THREE.CSS3DObject</code> elements. For this step, just add the following function: <div><pre class="programlisting">
<code class="literal">function createCSS3DObject(content)</code> 
    {
      // convert the string to dome elements
      var wrapper = document.createElement('div');
      wrapper.innerHTML = content;
      var div = wrapper.firstChild;

      // set some values on the div to style it.
      // normally you do this directly in HTML and 
      // CSS files.
      div.style.width = '370px';
      div.style.height = '370px';
      div.style.opacity = 0.7;
      div.style.background = new THREE.Color(Math.random() * 0xffffff).getStyle();

      // create a CSS3Dobject and return it.
      var object = new THREE.CSS3DObject(div);
      return object;
    }</pre></div><p>This function takes an HTML string as the input, converts it to an HTML element, sets some CSS styles, and uses this as the input to create a <code class="literal">THREE.CSS3DObject</code> object, which is added to the scene.</p></li></ol></div><p>If you<a id="id12" class="indexterm"/> open this file in your browser, you'll see something that resembles the example we showed in the <em>Getting ready</em> section of this recipe. You can use the HTML page and JavaScript as a template for the entirety of your CSS 3D renderer project.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works...</h2></div></div></div><p>With CSS 3D, you can apply all kinds of transformations to the HTML elements. For instance, you can apply a specific rotation around an axis using the transform property. The interesting thing is that you can also apply matrix transformations. Three.js uses matrix transformations internally to position and rotate the elements. With the <code class="literal">THREE.CSS3DRenderer</code> object, Three.js hides the internal CSS 3D specific transformations and styles and provides a nice abstraction level, which you can use to work with the HTML elements in 3D.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you can use the WebGL approach from the <em>Getting started with the WebGL renderer </em>recipe, you should really use it. It provides more features than those that are available with the CSS-based approach, but has less support for mobile devices. If, on the other hand, you're looking to manipulate the HTML elements on screen, the <code class="literal">THREE.CSS3DRenderer</code> object is a great solution.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Detecting WebGL support</h1></div></div></div><p>Not all<a id="id13" class="indexterm"/> browsers currently support WebGL. When you create a page that uses the <code class="literal">THREE.WebGLRenderer</code> object, it is a good idea to make sure that the browser supports WebGL. If a browser doesn't support it, this will result in all kinds of strange JavaScript errors in the JavaScript console and an empty screen for the end user. To make sure that your WebGL projects work as expected, we'll explain how to detect WebGL support in a browser in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Getting ready</h2></div></div></div><p>In this<a id="id14" class="indexterm"/> recipe, as an example, we will use the <code class="literal">01.04-detect-webgl-support.html</code> file, which you can find in the sources provided with this book. If you open this file, you'll see the following result if your browser doesn't support WebGL:</p><div><img src="img/1182OS_01_04.jpg" alt="Getting ready"/></div><p>Let's take a look at the recipe to create the preceding example.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How to do it...</h2></div></div></div><p>To detect WebGL and create the message <strong>WebGL is not-supported</strong>, we need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we'll create the CSS for the pop up to show when WebGL isn't supported.</li><li class="listitem">Then, we need to detect whether the browser WebGL is supported. For this, we'll write a method that returns the values true or false.</li><li class="listitem">Finally, we'll <a id="id15" class="indexterm"/>use the result from the previous step to either show the pop up or just continue.<p>In the following section, we'll look at these steps in detail:</p></li><li class="listitem">The first thing you need to do is set up the CSS that we'll use:<div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
      .black_overlay {
        display: none;
        position: absolute;
        top: 0;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: black;
        z-index: 1001;
        opacity: .80;
      }

      .white-content {
        display: none;
        position: absolute;
        top: 25%;
        left: 25%;
        width: 50%;
        height: 70px;
        padding: 16px;
        border: 2px solid grey;
        background-color: black;
        z-index: 1002;
      }

      .big-message {
        width: 80%;
        height: auto;
        margin: 0 auto;
        padding: 5px;
        text-align: center;
        color: white;

        font-family: serif;
        font-size: 20px;
      }

    &lt;/style&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;</pre></div><p>As you can see, there is nothing special in this CSS. The only thing that we will do here is create a number of classes that we'll use to create a pop-up message and hide the background. Next, we will define the HTML that is used to create the pop ups.</p></li><li class="listitem">The <a id="id16" class="indexterm"/>following snippet shows you the HTML code, which will contain the message. Using the CSS that we previously defined we can show or hide this element:<div><pre class="programlisting">    &lt;!-- Lightbox to show when WebGL is supported or not--&gt;
    &lt;div id="lightbox" class="white-content"&gt;
    &lt;div class="big-message" id="message"&gt;
    
    &lt;/div&gt;
    &lt;a href="javascript:void(0)" onclick="hideLightbox()"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
    &lt;div id="fade" class="black_overlay"&gt;&lt;/div&gt;</pre></div><p>As you can see, we just create a number of <code class="literal">div</code> elements that are currently hidden. When we detect that WebGL isn't supported this will be shown by the two <code class="literal">div</code> elements by changing their visibility.</p></li><li class="listitem">Next, let's take a look at the JavaScript you need to add to detect WebGL. We'll create the following function for it:<div><pre class="programlisting">    // loosely based on the http://get.webgl.org function detectWebGL() {

      // first create a canvas element
      var testCanvas = document.createElement("canvas");
      // and from that canvas get the webgl context
      var gl = null;

      // if exceptions are thrown, indicates webgl is null
      try {
        gl = testCanvas.getContext("webgl");
      } catch (x) {
        gl = null;
      }

      // if still null try experimental
      if (gl == null) {
        try {
        gl = testCanvas.getContext("experimental-webgl");
        } catch (x) {
        gl = null;
        }

    }
    // if webgl is all good return true;
    if (gl) {
      return true;
    } else {
      return false;
    }
}</pre></div><p>As you can see, we create an HTML <code class="literal">canvas</code> element and then try to create a WebGL context with the <code class="literal">getContext</code> function. If this fails, the <code class="literal">gl</code> variable is set to null but if it succeeds, the <code class="literal">gl</code> variable will contain the WebGL context. If the <code class="literal">gl</code> variable isn't null, it will return true. On the hand, if it is, it will return false.</p></li><li class="listitem">Now<a id="id17" class="indexterm"/> that we're able to detect whether a browser supports WebGL or not, we'll use this function to show a pop up. For this recipe, we'll also show you a pop up when WebGL is supported:<div><pre class="programlisting">    var hasGl = detectWebGL();
    if (hasGl) {
      showLightbox("WebGL is supported");
    } else {
    showLightbox("WebGL is not-supported");
    }

    function showLightbox(message) {
      var lightBox = document.getElementById('light');
      lightBox.style.display = 'block';

      var fadeBox = document.getElementById('fade');
      fadeBox.style.display = 'block'

      var msg = document.getElementById('message');
      msg.textContent = message;
    }

    function hideLightbox() {
      var lightBox = document.getElementById('light');
      lightBox.style.display = 'none';

      var fadeBox = document.getElementById('fade');
      fadeBox.style.display = 'none'
    }</pre></div></li></ol></div><p>And that<a id="id18" class="indexterm"/> is it for this recipe. If we add this to a web page, a browser that supports WebGL shows a pop up with <strong>WebGL is supported</strong>, if no WebGL is available, a pop up is shown with the text <strong>WebGL isn't supported</strong>. Besides this approach, you can<a id="id19" class="indexterm"/> also use the detector object provided by Three.js at <a class="ulink" href="https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js">https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js</a>. If you include this file in your JavaScript, you can detect WebGL by checking the <code class="literal">webgl</code> attribute of the <code class="literal">Detector</code> object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Setting up an animation loop</h1></div></div></div><p>In the <a id="id20" class="indexterm"/>recipes at the beginning of this chapter, we showed you how to set up a basic Three.js scene, using one of the available renderers. If you want to add animations to your Three.js scene, for instance, to move the camera around or rotate an object, you'll need to call the <code class="literal">render</code> function multiple times. In the old days of JavaScript, you had to control this yourself using the <code class="literal">setTimeout</code> or <code class="literal">setInterval</code> JavaScript functions. The problem with these functions is that they don't take into account what is happening in your browser. For instance, your page will be hidden or the Three.js scene might be scrolled out of view. A better solution for animations, and the one that we'll use in this recipe, is <code class="literal">requestAnimationFrame</code>. With this function, your browser determines when it is the best time to call the animation code.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Getting ready</h2></div></div></div><p>For this recipe, we will use the <code class="literal">01.05-setup-animation-loop.html</code> example HTML file. To see the animation in action, just open this file in your browser:</p><div><img src="img/1182OS_01_05.jpg" alt="Getting ready"/></div><p>This <a id="id21" class="indexterm"/>example uses the WebGL renderer. You can of course apply this same recipe to the other renderers we've discussed in this chapter.</p><p>Let's take a look at the steps we need to take to set up such an animation loop.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it...</h2></div></div></div><p>To create an animation loop you don't have to change much in your existing code:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's first look at how to use <code class="literal">requestAnimationFrame</code> for rendering. For this, we've created a render function:<div><pre class="programlisting">    function render() {
      renderer.render(scene, camera);
      scene.getObjectByName('cube').rotation.x += 0.05;
      requestAnimationFrame(render);
    }</pre></div><p>As you can see, we pass the render function as an argument to request a frame for animation. This will cause the <code class="literal">render</code> function to be called at a regular interval. In the <code class="literal">render</code> function, we will also update the rotation of the <em>x</em> axis of the cube to show you that the scene is re-rendered.</p></li><li class="listitem">To use this function in the recipes, which we saw at the beginning of this chapter, we just have to replace this call:<div><pre class="programlisting">    function init() {
      ...
      // call the render function
      renderer.render(scene, camera);
    }
With the following:
    function init() {
      ...
      // call the render function
      render();
    }</pre></div></li><li class="listitem">You <a id="id22" class="indexterm"/>will now have your own animation loop, so any changes made to your model, camera, or other objects in the scene can now be done from within the <code class="literal">render()</code> function.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We mentioned that in this recipe, we've used the <code class="literal">THREE.WebGLRenderer</code> object as an example. You can of course also apply this to the skeletons from the <em>Getting started with the Canvas renderer</em> recipe or <em>Getting started with the CSS 3D renderer</em> recipe.</li><li class="listitem" style="list-style-type: disc">What will be of interest to you also is the <em>Determining the frame rate of your scene</em> recipe, where we'll add additional functionality to the skeletons so you can easily see how often the render function is called by <code class="literal">requestAnimationFrame</code>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Determining the frame rate for your scene</h1></div></div></div><p>When <a id="id23" class="indexterm"/>you create large Three.js applications with many objects and animations, it is good to keep an eye on the frame rate at which the browser can render your scene. You can do this yourself using log statements from your animation loop, but luckily, there is already a good solution available that integrates great with Three.js (which isn't that strange since it was originally written for Three.js).</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>For this recipe, we'll use the <code class="literal">stats.js</code> JavaScript library that you can download from its GitHub<a id="id24" class="indexterm"/> repository at <a class="ulink" href="https://github.com/mrdoob/stats.js/">https://github.com/mrdoob/stats.js/</a>. To use this library, you have to include it at the top of your HTML file such as this:</p><div><pre class="programlisting">    &lt;script src="img/stats.min.js"&gt;&lt;/script&gt;</pre></div><p>We've <a id="id25" class="indexterm"/>also provided a ready to use example for this recipe. If you open the <code class="literal">01.06-determine-framerate.html</code> file in your browser, you can directly see how this library shows the current framerate, which you can see at the top-left of the browser, as shown in the following screenshot:</p><div><img src="img/1182OS_01_06.jpg" alt="Getting ready"/></div><p>Let's take a look at the steps you need to take to add this to your Three.js application.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it...</h2></div></div></div><p>Adding this functionality to your scene only takes a couple of small steps, which are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, we<a id="id26" class="indexterm"/> have to create the <code class="literal">stats</code> object and position it. For this, we create a simple function:<div><pre class="programlisting">    function createStats() {
      var stats = new Stats();
      stats.setMode(0);

      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0';
      stats.domElement.style.top = '0';

      return stats;
    }</pre></div><p>We create the statistics object by calling <code class="literal">new Stats()</code>. The <code class="literal">Stats.js</code> library supports two different modes that we can set with the <code class="literal">setMode</code> function. If we pass <code class="literal">0</code> as an argument, you see the frames rendered in the last second, and if we set the mode to <code class="literal">1</code>, we see the milliseconds that were needed to render the last frame. For this recipe, we want to see the framerate, so we set the mode to <code class="literal">0</code>.</p></li><li class="listitem">Now that we can create the statistics object, we need to append the <code class="literal">init</code> method we've seen in the skeleton recipes:<div><pre class="programlisting">    // global variables
    var renderer;
    var scene;
    var camera;
<strong>    var stats;</strong>

    function init() {
      ...
<strong>      stats = createStats();</strong>
<strong>      document.body.appendChild( stats.domElement );</strong>

      // call the render function
      render();
    }</pre></div><p>As you can see we created a new global variable called <code class="literal">stats</code>, which we'll use to access our statistics object. In the <code class="literal">init</code> method, we use the function we just created, and add the <code class="literal">stats</code> object to our HTML body.</p></li><li class="listitem">We're<a id="id27" class="indexterm"/> almost there. The only thing we need to do now is make sure that we update the <code class="literal">stats</code> object whenever the render function is called. This way, the <code class="literal">stats</code> object can calculate either the framerate or the time it took to run the render function:<div><pre class="programlisting">    function render() {
      requestAnimationFrame(render);

      scene.getObjectByName('cube').rotation.x+=0.05;
      renderer.render(scene, camera);
<strong>      stats.update();</strong>
    }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>We mentioned that <code class="literal">Stats.js</code> provides two modes. It either shows the framerate or the time it took to render the last frame. The <code class="literal">Stats.js</code> library works by simply keeping track of the time passed between calls and its <code class="literal">update</code> function. If you're monitoring the framerate, it counts how often the update was called within the last second, and shows that value. If you're monitoring the render time, it just shows the time between calls and  the <code class="literal">update</code> function.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Controlling the variables used in the scene</h1></div></div></div><p>When <a id="id28" class="indexterm"/>you're developing and writing JavaScript, you often need to tune some variables for the best visualization. You might need to change the color of a sphere, change the speed of an animation, or experiment with more complex material properties. You can just change the source code, and reload the HTML, but that becomes tedious and time consuming. In this recipe, we'll show you an alternative way to quickly and easily control the variables in your Three.js scene.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>For this<a id="id29" class="indexterm"/> recipe, we also need an external JavaScript library called <code class="literal">dat.gui</code>. You can download the latest version from <a class="ulink" href="https://code.google.com/p/dat-gui/">https://code.google.com/p/dat-gui/</a>, or look into the <code class="literal">libs</code> directory of the sources provided with this book. To use this library, you first have to include it in the top of your HTML file:</p><div><pre class="programlisting">    &lt;script src="img/dat.gui.min.js"&gt;&lt;/script&gt;</pre></div><p>In the source folder of this chapter, there is also a ready-to-use example, which we'll explain in the<a id="id30" class="indexterm"/> following sections. When you open the <code class="literal">01.07-control-variables.html</code> file, you'll see the following:</p><div><img src="img/1182OS_01_07.jpg" alt="Getting ready"/></div><p>As you can see in the preceding screenshot, a menu is available in the top-right corner that you can use to control the rotation speed and the scaling of the cube.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>To use this library for yourself, you only need to do a couple of small things:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing you need to do is define a JavaScript object that contains the properties you want to control. In this case, you need to add it to the <code class="literal">init</code> function and create a new global JavaScript variable with the name, <code class="literal">control</code>:<div><pre class="programlisting">    ...
    var control;
    function init() {
      ...

      control = new function() {
        this.rotationSpeed = 0.005;
        this.scale = 1;
      };
      addControls(control);

      // call the render function
      render();
    }</pre></div></li><li class="listitem">The <a id="id31" class="indexterm"/>control object in the preceding code contains two properties: <code class="literal">rotationSpeed</code> and <code class="literal">scale</code>. In the <code class="literal">addControls</code> function, we'll create the UI component that is shown in the preceding screenshot:<div><pre class="programlisting">    function addControls(controlObject) {
      var gui = new dat.GUI();
      gui.add(controlObject, 'rotationSpeed', -0.1, 0.1);
      gui.add(controlObject, 'scale', 0.01, 2);
    }</pre></div><p>In this <code class="literal">addControls</code> function, we use the provided argument that contains the <code class="literal">rotationSpeed</code> and <code class="literal">scale</code> properties in order to create the control GUI. For each variable, we specify four arguments:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Object</strong>: The <a id="id32" class="indexterm"/>first argument is the JavaScript object that contains the variables. In our case, it's the object passed to the <code class="literal">addControls</code> function.</li><li class="listitem"><strong>Name</strong>: The <a id="id33" class="indexterm"/>second argument is the name of the variable we want to add. This should point to one of the variables (or functions) available in the object that is provided in the first argument.</li><li class="listitem"><strong>Minimum value</strong>: The<a id="id34" class="indexterm"/> third argument is the minimum value that should be shown in the GUI.</li><li class="listitem"><strong>Maximum value</strong>: The<a id="id35" class="indexterm"/> last argument specifies the maximum value that should be shown.</li></ol></div></li><li class="listitem">At <a id="id36" class="indexterm"/>this point, we've got a GUI that can be used to control the variables, as you can see in the following screenshot:<div><img src="img/1182OS_01_08.jpg" alt="How to do it..."/></div><p>The only thing we now need to do is make sure that we update our object in the render loop, which is based on the variables from the GUI. We can do this easily in the <code class="literal">render</code> function,  which is as follows:</p><div><pre class="programlisting">    function render() {
      renderer.render(scene, camera);
      scene.getObjectByName('cube').rotation.x+= control.rotationSpeed;
      scene.getObjectByName('cube').scale.set (control.scale,
        control.scale,
        control.scale);
      requestAnimationFrame(render);
    }</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>There's more...</h2></div></div></div><p>In this<a id="id37" class="indexterm"/> recipe, we've just used <code class="literal">dat.gui</code> to change the numeric values. The <code class="literal">dat.gui</code> library also allows you to add controls for other types of values as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the variable you add is a Boolean, a checkbox will be shown</li><li class="listitem" style="list-style-type: disc">If the variable is a string, you can add an array of valid values</li><li class="listitem" style="list-style-type: disc">If the variable is a color, you can use add color to create a color picker</li><li class="listitem" style="list-style-type: disc">If the variable is a function, you get a button that fires the selected function</li></ul></div><p>Besides this, you can add different kinds of event listeners to fire custom callbacks when a value <a id="id38" class="indexterm"/>managed by <code class="literal">dat.gui</code> changes. For more information, see <a id="id39" class="indexterm"/>the <code class="literal">dat.gui</code> library documentation which you can find at <a class="ulink" href="http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage">http://workshop.chromeexperiments.com/examples/gui/#1--Basic-Usage</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Setting up a local web server with Python</h1></div></div></div><p>The best <a id="id40" class="indexterm"/>way to test your Three.js applications, or <a id="id41" class="indexterm"/>any JavaScript application for that matter, is to run it on a local web server. This way, you have the best representation of how your users will eventually see your Three.js visualization. In this chapter, we will show you three different ways in which you can run a web server locally. The three different ways to set up a local web server are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One way to do this is via a Python-based approach that you can use if you've got Python installed</li><li class="listitem" style="list-style-type: disc">Another way is to do if you use Node.js or have already played around with Node.js, you can use the <code class="literal">npm</code> command to install a simple web server</li><li class="listitem" style="list-style-type: disc">A third option is if you don't want to use the <code class="literal">npm</code> command or Python, you can also<a id="id42" class="indexterm"/> use <strong>Mongoose</strong>, which is a simple portable web server, that runs on OS X and Windows</li></ul></div><p>This recipe will focus on the Python-based approach (the first bullet point).</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>Getting ready</h2></div></div></div><p>If you've got Python installed, you can very easily run a simple web server. You will first need to check whether you've got Python installed. The easiest way to do this is just type in <code class="literal">python</code> on a console and hit <em>enter</em>. If you see an output as follows, you are ready to begin:</p><div><pre class="programlisting">&gt; python
Python 2.7.3 (default, Apr 10 2013, 05:09:49) 
[GCC 4.7.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Once<a id="id43" class="indexterm"/> Python (<a class="ulink" href="http://python.org">http://python.org</a>) has been installed, you can run a simple web server by just executing the following Python command. You will need to do this in the directory from where you want to host the files:<div><pre class="programlisting">
<strong>&gt; python -m SimpleHTTPServer</strong>
</pre></div></li><li class="listitem">The following output shows the web server running on port 8000:<div><pre class="programlisting">
<strong>Serving HTTP on 0.0.0.0 port 8000...</strong>
</pre></div></li></ol></div><p>If you<a id="id44" class="indexterm"/> don't have Python installed, take a look <a id="id45" class="indexterm"/>at one of the following two recipes for alternative options.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Setting up a local web server with Node.js</h1></div></div></div><p>If you <a id="id46" class="indexterm"/>would like to test your Three.js applications, then as described in the <em>How to set up a local web server with Python</em> recipe, you<a id="id47" class="indexterm"/> can run it in three different ways. This recipe will focus on the Node.js approach.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>To run a local web<a id="id48" class="indexterm"/> server with Node.js (<a class="ulink" href="https://nodejs.org">https://nodejs.org</a>), we first have to check whether we've got <code class="literal">npm</code> (the node package manager, which is installed together with Node.js) installed. You can check this by running the <code class="literal">npm</code> command from the command line:</p><div><pre class="programlisting">
<strong>&gt; npm</strong>
</pre></div><p>If the output is similar to the following code snippet, you've got <code class="literal">npm</code> installed and you are ready to begin the recipe:</p><div><pre class="programlisting">
<strong>Usage: npm &lt;command&gt;</strong>
<strong>where ...</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">You can use it to run a simple web server using:<div><pre class="programlisting">
<strong>Usage: npm &lt;command&gt;...</strong>
</pre></div></li><li class="listitem">Now, you are ready to install a web server by running:<div><pre class="programlisting">
<strong>&gt; npm install -g http-server</strong>
</pre></div></li><li class="listitem">Finally, you are ready to start the web server by running <code class="literal">http-server</code> from the command line:<div><pre class="programlisting">
<strong>&gt; http-server</strong>
<strong>Starting up http-server, serving ./ on port: 8080</strong>
<strong>Hit CTRL-C to stop the server</strong>
</pre></div></li></ol></div><p>A final recipe for running your own web server is presented in the next section. In that recipe you don't need Python or Node.js installed, but we will show you how to download a <a id="id49" class="indexterm"/>portable<a id="id50" class="indexterm"/> web server that you can run without requiring any installation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Setting up a local web server using Mongoose</h1></div></div></div><p>If you<a id="id51" class="indexterm"/> would like to test your Three.js <a id="id52" class="indexterm"/>applications, then as described in the <em>How to set up a local web server with Python</em> recipe, you can run it in three different ways. If the first two approaches fail, you can always use a simple portable web server using Mongoose. This recipe will focus on the Mongoose approach.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>Getting ready</h2></div></div></div><p>Before you run<a id="id53" class="indexterm"/> Mongoose, you first have to download it. You can download Mongoose from <a class="ulink" href="https://code.google.com/p/mongoose/downloads/list">https://code.google.com/p/mongoose/downloads/list</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The platform you are using will affect how you run Mongoose. If you're running Windows, you can just copy the downloaded file (an executable) to the folder from where you want to host your files from (for example, the directory where you extracted the sources for this book), and double-click on the executable to start the web server on port 8080.</li><li class="listitem">For Linux or OS X platforms, you will also need to have a copy of the downloaded file in the directory where your files are located, but you have to start Mongoose from the command line.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you can't install a local web server, you can take a look at the <em>Solving cross-origin-domain error messages in Chrome</em> recipe. This recipe provides you with an alternative way of running the more advanced Three.js examples.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Solving cross-origin-domain error messages in Chrome</h1></div></div></div><p>When <a id="id54" class="indexterm"/>you are developing <a id="id55" class="indexterm"/>Three.js applications, the simplest way of testing your application is to just open the file in your browser. For a lot of scenarios, this will work, until you start loading textures and models. If you try to do this, you'll be presented with an error that looks something like this:</p><div><img src="img/1182OS_01_09.jpg" alt="Solving cross-origin-domain error messages in Chrome"/></div><p>This <a id="id56" class="indexterm"/>error, which you can <a id="id57" class="indexterm"/>easily reproduce yourself by just dragging <code class="literal">01.09-solve-cross-origin-issues.html</code> to your browser, will have the terms <strong>cross-origin</strong> or <strong>SecurityError</strong> in its message. What this error means is that the browsers prevents the current page loading a resource from a different domain. This is a necessary feature to avoid maleficent websites access to personal information. During development, however, this can be a bit incovenient. In this recipe, we'll show you how you can circumvent these kinds of errors by tweaking the security settings of your browser.</p><p>We'll take a look at how to disable the security checks for the two browsers that have the best support for WebGL: Chrome and Firefox. In this recipe, we'll look at how to do this in Chrome, and in the next recipe, we'll show you how to do this in Firefox. An important note, though, before we go on with the recipe. If you can, run a local web server. It's much more secure and doesn't result in low security settings in your browser.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">After the installation of Chrome is complete, we will then need to disable the security settings in Chrome, for <a id="id58" class="indexterm"/>which we <a id="id59" class="indexterm"/>have to pass a command line parameter. Each operating system, however, does this slightly differently:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For Windows, you call the following (from the command line):<div><pre class="programlisting">chrome.exe --disable-web-security</pre></div></li><li class="listitem" style="list-style-type: disc">On Linux, do the following:<div><pre class="programlisting">google-chrome --disable-web-security</pre></div></li><li class="listitem" style="list-style-type: disc">And on Mac OS, you disable the settings by starting Chrome using:<div><pre class="programlisting">
<strong>open -a Google\ Chrome --args --disable-web-security</strong>
</pre></div></li></ul></div></li><li class="listitem">When you start Chrome this way, even running it directly from the filesystem will load the resources correctly to give you the following result:<div><img src="img/1182OS_01_10.jpg" alt="How to do it..."/></div></li><li class="listitem">Do remember to<a id="id60" class="indexterm"/> restart the <a id="id61" class="indexterm"/>browser normally after you're done experimenting or developing with Three.js, since you've lowered the security settings of your browser.</li><li class="listitem">For Firefox users, we explain how to solve these cross-origin issues for this browser in the following recipe.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Solving cross-origin-domain error messages in Firefox</h1></div></div></div><p>In<a id="id62" class="indexterm"/> the previous recipe, we<a id="id63" class="indexterm"/> explained that cross-origin error messages can occur when you run Three.js applications from the filesystem. In this recipe, we showed you how to solve these kind of issues on Chrome. In this recipe, we look at how to solve these issues in another popular browser: Firefox.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">For Firefox, we will then need to disable the security settings directly from the browser. If you type <code class="literal">about:config</code> in the URL bar, you will see the following:<div><img src="img/1182OS_01_11.jpg" alt="How to do it..."/></div></li><li class="listitem">On this screen, just click on the <strong>I'll be careful, I promise!</strong> button. This will bring you to an overview page that shows you all the internal properties available in Firefox.</li><li class="listitem">Following this, in the search box on this screen type <code class="literal">security.fileuri.strict_origin_policy</code> and change its value, as shown in the following <a id="id64" class="indexterm"/>screenshot:<div><img src="img/1182OS_01_12.jpg" alt="How to do it..."/></div></li><li class="listitem">Now, when you open a file directly in the browser, even the resources loaded through<a id="id65" class="indexterm"/> one of the asynchronous loaders will work.</li><li class="listitem">Do remember to change these settings back after you're done experimenting or developing with Three.js, since you've lowered the security settings of your browser.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How it works...</h2></div></div></div><p>The reason we have to set these properties is that, by default, the modern browser checks whether you're allowed to request a resource from a different domain than the one you're running on. When you use Three.js to load a model or a texture, it uses an <code class="literal">XMLHTTPRequest</code> object to access that resource. Your browser will check for the availability of the correct headers, and since you're requesting a resource from your local system, which doesn't provide the correct headers, an error will occur. Even, though with this<a id="id66" class="indexterm"/> recipe, you can circumvent<a id="id67" class="indexterm"/> this restriction, it is better to always test with a local web server, since that will most closely resemble how your users will access it online.</p><p>For more <a id="id68" class="indexterm"/>information on CORS, refer to <a class="ulink" href="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As we mentioned in the previous section, a better way to handle these kinds of errors is by setting up a local web server. The <em>Setting up a local web server with Python</em> recipe, explains how to accomplish this.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec22"/>Adding keyboard controls</h1></div></div></div><p>If you <a id="id69" class="indexterm"/>want to create games or more advanced 3D scenes, you often need a way to control elements in your scene using keyboard controls. For instance, you might make a platform game where the user uses the arrows on the keyboard to move through your game. Three.js in itself doesn't provide a specific functionality to handle keyboard events, since it is very easy to connect the standard HTML JavaScript event handling to Three.js.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec46"/>Getting ready</h2></div></div></div><p>For this recipe, we included an example where you can rotate a cube around its <em>x</em> and <em>z</em> axes using the arrows on your keyboard. If you first open an example <code class="literal">01.10-keyboard-controls.html</code> in your browser, you'll see a simple cube:</p><div><img src="img/1182OS_01_13.jpg" alt="Getting ready"/></div><p>With<a id="id70" class="indexterm"/> the up, down, left, and right arrows on your keyboard, you can rotate this cube. With this file open, you are now ready to begin.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec47"/>How to do it...</h2></div></div></div><p>Adding a key support in your browser is very easy; all you have to do is assign an event handler to <code class="literal">document.onkeydown</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">To do this we need to assign a function to the <code class="literal">document.onkeydown</code> object This function will get called whenever a key is pressed. The following code, wrapped in the <code class="literal">setupKeyControls</code> function, registers this listener:<div><pre class="programlisting">    function setupKeyControls() {
      var cube = scene.getObjectByName('cube');
      document.onkeydown = function(e) {
        switch (e.keyCode) {
          case 37:
          cube.rotation.x += 0.1;
          break;
          case 38:
          cube.rotation.z -= 0.1;
          break;
          case 39:
          cube.rotation.x -= 0.1;
          break;
          case 40:
          cube.rotation.z += 0.1;
          break;
        }
      };
    }</pre></div></li><li class="listitem">In <a id="id71" class="indexterm"/>this function, we use the <code class="literal">keyCode</code> property from the passed event <code class="literal">e</code> in order to determine what to do. In this example, if a user presses the left arrow key that corresponds to key code <code class="literal">37</code>, we change the <code class="literal">rotation.x</code> property of the Three.js object in our scene. We apply the same principle to the up arrow key(<code class="literal">38</code>), the right arrow (<code class="literal">39</code>), and the down arrow (<code class="literal">40</code>).</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec48"/>How it works...</h2></div></div></div><p>Using event handlers is a standard HTML JavaScript mechanism, they are a part of the DOM API. This API allows you to register functions for all kinds of different events. Whenever that specific event occurs, the provided function is called. In this recipe, we chose to use the <code class="literal">KeyDown</code> event. This event is triggered when the user presses a key. There is also a <code class="literal">KeyUp</code> event available that is triggered when the user releases a key, which one to use depends on your use case. Note that there is also a <code class="literal">KeyPress</code> event available. This event, though, is meant to be used with characters and doesn't register any noncharacter key press.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec49"/>There's more...</h2></div></div></div><p>In this recipe, we only showed the key code values for the arrows. There is, of course, a separate key code for each key on your keyboard. A good explanation of how the various keys are mapped (especially, the special ones such as the function keys) can be found at <a class="ulink" href="http://unixpapa.com/js/key.html">http://unixpapa.com/js/key.html</a>. If you want to know the key value of a specific key, and you don't feel like looking up the value in a list, you can also use just the following simple handler to output the key codes to the JavaScript console:</p><div><pre class="programlisting">    function setupKeyLogger() {
      document.onkeydown = function(e) {
        console.log(e);
      }
    }</pre></div><p>This small handler logs the complete event. In the output to the console, you can then see the key <a id="id72" class="indexterm"/>code that is used, as shown in the following screenshot:</p><div><img src="img/1182OS_01_14.jpg" alt="There's more..."/></div><p>As you can see, you also see a lot of other interesting information. For instance, you can see whether the <em>shift</em> or <em>Alt</em> keys were also pressed at the same time of the event.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec50"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you <a id="id73" class="indexterm"/>want to learn more about key events, Mozilla provides a good overview of all the events that are available at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec23"/>Loading textures asynchronously</h1></div></div></div><p>When <a id="id74" class="indexterm"/>you create Three.js scenes, you often need to load resources. There might be textures you want to load for your objects, you might have some external models you want to include in your scene, or maybe some CSV data that you want to use as an input for your visualization. Three.js offers a number of different ways of loading these resources asynchronously, which we'll explore in this and the following recipes.</p><p>To run these recipes and experiment with them, we included a simple sample in the source folder of this chapter that shows this loading in action. If you open an example <code class="literal">01.11-load-async-resources.html</code> in your browser, and open the JavaScript console, you'll see the progress and the result of loading resources asynchronously.</p><p>Please note that since we are loading files directly from the browser, you need to have either a local web server installed (see the <em>Setting up a local web server with Python </em>recipe or the <em>Setting up a local web server with Node.js</em> recipe) or disable some security checks as explained in the <em>Solving cross-origin-domain error messages in Chrome</em> recipe or the <em>Solving cross-origin-domain error messages in Firefox</em> recipe.</p><div><img src="img/1182OS_01_15.jpg" alt="Loading textures asynchronously"/></div><p>In<a id="id75" class="indexterm"/> these first of the five recipes, we'll show you how you can load textures asynchronously with Three.js.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec51"/>Getting ready</h2></div></div></div><p>Before looking at the steps in this recipe, you will need to create a number of standard callbacks that can be used by all the different loaders. These callbacks are used to inform you when a resource is loaded, when loading fails and, if available, the progress of the current request.</p><p>So for loading resources, we need to define three different callbacks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">onload</code> callback: Whenever a resource is loaded, this callback will be called <a id="id76" class="indexterm"/>with the loaded resource as an argument.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">onprogress</code> callback: Some loaders provide progress during the loading <a id="id77" class="indexterm"/>of a resource. At specific intervals, this callback will be called to inform you how much of the resource has been loaded.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">onerror</code> callback: If something goes wrong during the loading of the resource, this <a id="id78" class="indexterm"/>callback is used to inform you about the error that occurred.</li></ul></div><p>For <a id="id79" class="indexterm"/>all the recipes dealing with asynchronous loading, we'll use the same set of loaders. These loaders just output some information to the console, but you can of course customize these callbacks for your specific use case.</p><p>First, we define the <code class="literal">onLoadCallback</code> function, which is called when a resource is loaded:</p><div><pre class="programlisting">    function onLoadCallback(loaded) {
      // just output the length for arrays and binary blobs
      if (loaded.length) {
        console.log("Loaded", loaded.length);
      } else {
        console.log("Loaded", loaded);
      }
    }</pre></div><p>As you can see from the function definition, we just output the passed argument to the console. The other two callbacks, <code class="literal">onProgressCallback</code> and <code class="literal">onErrorCallback</code>, work exactly in the same manner as they are presented:</p><div><pre class="programlisting">    function onProgressCallback(progress) {
      console.log("Progress", progress);
    }

    function onErrorCallback(error) {
      console.log("Error", error)
    }</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>In the following sections and recipes, we'll reference these callbacks when we use the Three.js provided functionality to load resources.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec52"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To load a texture asynchronously, we use the <code class="literal">loadTexture</code> function from <code class="literal">THREE.ImageUtils</code>:<div><pre class="programlisting">    function loadTexture(texture) {
      var texture = THREE.ImageUtils.loadTexture(textureURL, null, onLoadCallback, onErrorCallback);
      console.log("texture after loadTexture call", texture);
    }</pre></div></li><li class="listitem">The <code class="literal">loadTexture</code> function from <code class="literal">THREE.ImageUtils</code> takes the following four<a id="id80" class="indexterm"/> arguments:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first one points to the location of the image you want to load</li><li class="listitem" style="list-style-type: disc">The second one can be used to provide a custom UV mapping (a UV mapping is used to determine which part of a texture to apply to a specific face)</li><li class="listitem" style="list-style-type: disc">The third argument is the callback to be used when the textures have been loaded</li><li class="listitem" style="list-style-type: disc">The final argument is the callback to be used in case of an error</li></ul></div><div><img src="img/1182OS_01_16.jpg" alt="How to do it..."/></div></li><li class="listitem">Note that the first console output also shows a valid texture object. Three.js does this, so you can immediately assign this object as a texture to a material. The actual image inside the texture, however, is only loaded after the <code class="literal">onLoadCallback</code> function is called.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec53"/>How it works...</h2></div></div></div><p>Three.js provides a nice wrapper to load textures. Internally, Three.js uses the standard way<a id="id81" class="indexterm"/> of loading resources from an <code class="literal">XMLHTTPRequest</code> web page With an <code class="literal">XMLHTTPRequest</code> web page, you can make an HTTP request for a specific resource and process the result. If you don't want to use the Three.js provided functionality, you can also implement an <code class="literal">XMLHTTPRequest</code> function yourself.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec54"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To run these examples and load resources asynchronously, we need to either run a web server locally, as explained in the <em>Setting up a local web server using Python</em> recipe or the <em>Setting up a web server using Node.js</em> recipe, or disable some security settings, as explained in the <em>Solving cross-origin-domain error messages in Chrome</em> recipe or the <em>Solving cross-origin-domain error messages in Firefox</em> recipe.</li><li class="listitem" style="list-style-type: disc">Alternatively, if <a id="id82" class="indexterm"/>you don't want to load resources asynchronously, but wait for all the resources to load, before you initialize your scene you can look at the next <em>Waiting until resources are loaded</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec24"/>Loading models asynchronously</h1></div></div></div><p>In the <em>Loading textures asynchronously</em> recipe, we explained that Three.js offers helper functions<a id="id83" class="indexterm"/> to load different types of resources asynchronously. In this recipe, we'll look at how you can use the <code class="literal">THREE.JSONLoader</code> object to load models asynchronously.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec55"/>Getting ready</h2></div></div></div><p>Before you get started with this recipe, make sure that you've walked through the steps explained in the <em>Getting ready</em> section of the <em>Loading textures asynchronously</em> recipe. In the following section, we'll reference the JavaScript callbacks defined in the <em>Getting ready</em> section of that recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec56"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Three.js also allows you to easily load external models. The following function shows you how to do this for the JSON models' Three.js uses. The same, however, applies to any of the other model loaders:<div><pre class="programlisting">    function loadModel(modelUrl) {
      var jsonLoader = new THREE.JSONLoader();
      jsonLoader.load(modelUrl, onLoadCallback, null);
    }</pre></div></li><li class="listitem">The <code class="literal">jsonLoader.load</code> function takes the following three arguments:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first one is the location of the model you want to load</li><li class="listitem" style="list-style-type: disc">The second is the callback to call when the model is successfully loaded</li><li class="listitem" style="list-style-type: disc">The final parameter is the one that we can specify the path from where the texture images should be loaded</li></ul></div></li><li class="listitem">When we call this function, you'll see the following output on the console:<div><img src="img/1182OS_01_17.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec57"/>There is more...</h2></div></div></div><p>With<a id="id84" class="indexterm"/> this approach, the <code class="literal">JSONLoader</code> object doesn't provide any feedback on how much it has loaded. If you want to load large models, it is nice to know something about the progress. The <code class="literal">JSONLoader</code> object also provides <a id="id85" class="indexterm"/>an alternative way of loading models that also provides progress. In the <em>Load model asynchronously with progress</em> recipe, we show you how to load a model and provide feedback on the progress. Besides the <code class="literal">THREE.JSONLoader</code> object, which loads Three.js' own proprietary models, Three.js is also shipped with a large number of loaders that you can use for other model formats. For an overview of what is provided by Three.js, please refer to <a class="ulink" href="https://github.com/mrdoob/three.js/tree/master/examples/js/loaders">https://github.com/mrdoob/three.js/tree/master/examples/js/loaders</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec25"/>Loading models asynchronously with progress</h1></div></div></div><p>In <a id="id86" class="indexterm"/>the previous section, the <em>Loading models asynchronously</em> recipe, we loaded a model asynchronously without providing feedback about the progress. In this recipe, we'll explain how you can add progress feedback to that scenario.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec58"/>Getting started</h2></div></div></div><p>Before you get started with this recipe, make sure that you've walked through the steps explained in the <em>Getting ready</em> section of the <em>Loading textures asynchronously</em> recipe. In the following section, we'll reference the JavaScript callbacks defined in the <em>Getting ready</em> section of that recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec59"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To load models and to also show progress, we have to use a different method apart from <code class="literal">THREE.JSONLoader</code>. If we use the <code class="literal">loadAjaxJSON</code> function, we can also specify a progress callback instead of just the load callback:<div><pre class="programlisting">    function loadModelWithProgress(model) {
      var jsonLoader = new THREE.JSONLoader();
      jsonLoader.loadAjaxJSON(jsonLoader, model, onLoadCallback, null, onProgressCallback);
    }</pre></div></li><li class="listitem">If we now load the same model as the previous one, we see the loading progress as follows:<div><img src="img/1182OS_01_18.jpg" alt="How to do it..."/></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec26"/>Loading other resources asynchronously with progress</h1></div></div></div><p>Besides<a id="id87" class="indexterm"/> loading specific resources, Three.js also provides a simple helper object to load any type of resource asynchronously. In this recipe, we'll explain how you can use the <code class="literal">THREE.XHRLoader</code> object to load any type of resource asynchronously.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec60"/>Getting ready</h2></div></div></div><p>Before you get started with this recipe, make sure that you've walked through the steps explained in the <em>Getting ready</em> section of the <em>Loading textures asynchronously</em> recipe. In the following section, we'll reference the JavaScript callbacks defined in the <em>Getting ready</em> section of that recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec61"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The final resource loader we want to show in this recipe is the <code class="literal">THREE.XHRLoader</code> object. This loader allows you to load any resource that you might need in your Three.js scene:<div><pre class="programlisting">    function loadOthers(res) {
      var xhrLoader = new THREE.XHRLoader();
      xhrLoader.load(res, onLoadCallback, onProgressCallback, onErrorCallback);
    }</pre></div></li><li class="listitem">The arguments for the <code class="literal">XHRLoader.load</code> function should look pretty familiar by now, as it's pretty <a id="id88" class="indexterm"/>much the same as for the other loaders. First, we pass the location of the resource we want to load, and then we specify the various callbacks. The output from this function looks like this:<div><img src="img/1182OS_01_19.jpg" alt="How to do it..."/></div><p>In the preceding screenshot, you can also see the progress while the resource is being loaded.</p></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec27"/>Waiting until resources are loaded</h1></div></div></div><p>In the <em>Load resources asynchronously</em> recipe, we showed how you can load external Three.js<a id="id89" class="indexterm"/> resources asynchronously. For many sites and visualization, loading resources asynchronously is a good approach. Sometimes, however, you want to make sure that all the resources you require in your scene have been loaded beforehand. For instance, when you're creating a game, you might want to load all the data for a specific level beforehand. A common method of loading resources synchronously is nesting the asynchronous callbacks we've seen in the previous recipe. This, however, quickly becomes unreadable and very hard to manage. In this recipe, we'll use a different approach and work with a JavaScript library called Q.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec62"/>Getting ready</h2></div></div></div><p>As for all the external libraries that we use, we need to include the Q library in our HTML. You can download the latest version of this library from its GitHub repository at <a class="ulink" href="https://github.com/kriskowal/q">https://github.com/kriskowal/q</a>, or use the version provided in the <code class="literal">libs</code> folder in the sources for this book. To include this library in your HTML page, add the following in the <code class="literal">head</code> element of your HTML page:</p><div><pre class="programlisting">    &lt;script src="img/q.js"&gt;&lt;/script&gt;</pre></div><p>In the sources for this chapter, you can also find an example where we load resources synchronously. Open <code class="literal">01.12-wait-for-resources.html</code> in your browser and open the JavaScript console:</p><div><img src="img/1182OS_01_20.jpg" alt="Getting ready"/></div><p>On <a id="id90" class="indexterm"/>the console output, you'll see that the required resources and models are loaded one after another.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec63"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's first take a look at what we're aiming for in this recipe. We want to load resources synchronously, using the Q library, in the following manner:<div><pre class="programlisting">    loadModel(model)
      .then(function(result) {return loadTexture(texture)})
      .then(function(result) {return loadModel(m)})
      .then(function(result) {return loadTexture(texture)})
      .then(function(result) {return loadOthers(resource)})
      .then(function(result) {return loadModelWithProgress(m)})
      .then(function(result) {return loadModel(model)})
      .then(function(result) {return loadOthers(resource)})
      .then(function(result) {return loadModel(model)})
      .then(function() {console.log("All done with sequence")})
      .catch(function(error) {
        console.log("Error occurred in sequence:",error);
      })
      .progress(function(e){
        console.log("Progress event received:", e);
       });</pre></div></li><li class="listitem">What this <a id="id91" class="indexterm"/>code fragment means is that:<div><ol class="orderedlist arabic"><li class="listitem">Firstly, we want to call <code class="literal">loadModel(model)</code>.</li><li class="listitem">Once the model is loaded, we load, using the <code class="literal">then</code> function, a texture using the <code class="literal">loadTexture(texture)</code> function. Once this texture is loaded, we will then load the next resource and so on. In this code fragment, you can also see that we also call a <code class="literal">catch</code> and a <code class="literal">progress</code> function. If an error occurs during loading, the function provided to <code class="literal">catch()</code> will be called. The same goes for <code class="literal">progress()</code>. If one of the methods wants to provide information about its progress, the function passed into <code class="literal">progress()</code> will be called.</li><li class="listitem">However, you will then find out that this won't work with the functions from our previous recipe. To get this to work, we have to replace the callbacks from these functions with a special Q construct that is called a deferred function:<div><pre class="programlisting">    function loadTexture(texture) {

      var deferred = Q.defer();
      var text = THREE.ImageUtils.loadTexture
      (texture, null, function(loaded) {
        console.log("Loaded texture: ", texture);
        deferred.resolve(loaded);
      }, function(error) {
        deferred.reject(error);
      });

      return deferred.promise;
    }</pre></div></li><li class="listitem">In this code snippet, we create a new JavaScript object with the name <code class="literal">deferred</code>. The <code class="literal">deferred</code> object will make sure that the results of the callbacks, this time defined as anonymous functions, are returned in such a way that we can use the <code class="literal">then</code> function we saw at the beginning of this chapter. If the resource is loaded successfully, we use the <code class="literal">deferred.resolve</code> function to store the result; if the resource was loaded unsuccessfully, we store the error using the <code class="literal">deferred.reject</code> function.</li><li class="listitem">We <a id="id92" class="indexterm"/>use the same approach for the <code class="literal">loadModel</code>, <code class="literal">loadOthers</code>,  and <code class="literal">loadModelWithProgress</code> functions:<div><pre class="programlisting">    function loadModel(model) {

      var deferred = Q.defer();
      var jsonLoader = new THREE.JSONLoader();
      jsonLoader.load(model, function(loaded) {
        console.log("Loaded model: ", model);
        deferred.resolve(loaded);
      }, null);

      return deferred.promise;
    }

    function loadOthers(res) {
      var deferred = Q.defer();

      var xhrLoader = new THREE.XHRLoader();
      xhrLoader.load(res, function(loaded) {
        console.log("Loaded other: ", res);
        deferred.resolve(loaded);
      }, function(progress) {
        deferred.notify(progress);
      }, function(error) {
        deferred.reject(error);
      });

      return deferred.promise;
    }</pre></div></li><li class="listitem">In the <code class="literal">loadOthers</code> function, we are also provided with the progress information. To make sure that the progress callback is handled correctly, we use the <code class="literal">deferred.notify()</code> function and pass in the <code class="literal">progress</code> object:<div><pre class="programlisting">    function loadModelWithProgress(model) {
      var deferred = Q.defer();

      var jsonLoader = new THREE.JSONLoader();
      jsonLoader.loadAjaxJSON(jsonLoader, model,
      function(model) {
        console.log("Loaded model with progress: ", model);
        deferred.resolve(model)
      }, null,
      function(progress) {
        deferred.notify(progress)
      });

      return deferred.promise;
    }</pre></div></li><li class="listitem">With these changes, we can now load the resources synchronously.</li></ol></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec64"/>How it works...</h2></div></div></div><p>To <a id="id93" class="indexterm"/>understand how this works, you have to understand what Q does. Q is a promises library. With promises, you can replace the nested callbacks (also called the Pyramid of doom at <a class="ulink" href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/</a>) with simple steps. The following example for the Q site nicely shows what this accomplishes:</p><div><pre class="programlisting">step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // Do something with value4
      });
    });
  });
});</pre></div><p>Using promises, we can flatten this to the following (just like we did in this recipe):</p><div><pre class="programlisting">Q.fcall(promisedStep1)
then(promisedStep2)
then(promisedStep3)
then(promisedStep4)
then(function (value4) {
  // Do something with value4
})
catch(function (error) {
  // Handle any error from all above steps
})
done();</pre></div><p>If we were to rewrite the Three.js library, we could have used promises in Three.js internally, but since Three.js already uses callbacks, we had to use the <code class="literal">Q.defer()</code> function provided by Q to convert these callbacks to promises.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec65"/>There is more...</h2></div></div></div><p>We <a id="id94" class="indexterm"/>only touched a small part of what is possible with the Q promises library. We used it for synchronous loading, but Q has many other useful features. A <a id="id95" class="indexterm"/>very good starting point is the Q wiki available at <a class="ulink" href="https://github.com/kriskowal/q/wiki">https://github.com/kriskowal/q/wiki</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec66"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Just like every recipe that loads resources you have to make sure that you run it either with a local web server, see the <em>Setting up a local web server using Python</em> recipe or the <em>Setting up a web server using Node.js</em> recipe, or disable some security settings (see the <em>Solving cross-origin-domain error messages in Chrome</em> recipe or the <em>Solving cross-origin-domain error messages in Firefox</em> recipe). If you want to load resources asynchronously, you can take a look at the <em>Load any resource asynchronously</em> recipe.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec28"/>Dragging a file from the desktop to the scene</h1></div></div></div><p>When <a id="id96" class="indexterm"/>you create visualizations, it is a nice feature to let your users provide their own resources. For instance, you might want to let the user specify their own textures or models. You can implement this with a traditional upload form, but with HTML5, you also have the option to let the user drag and drop a resource directly from the desktop. In this recipe, we'll explain how to provide this drag and drop functionality to your users.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec67"/>Getting ready</h2></div></div></div><p>The easiest way to prepare for this recipe is by first looking at the example we created for you. Open an example <code class="literal">01.14-drag-file-to-scene.html</code> in your browser.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Please note that this only works when running your own web server, or with security exceptions disabled.</p></div></div><div><img src="img/1182OS_01_21.jpg" alt="Getting ready"/></div><p>When <a id="id97" class="indexterm"/>you drag and drop an image file onto the drop area (the dashed square), you'll immediately see that the texture of the rotating box is changed and the image that you provide is used.</p><p>In the following section, we'll explain how you can create this functionality.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec68"/>How to do it...</h2></div></div></div><p>To do this, please carry out the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we have to set up the correct CSS and define the drop area. To create the dashed drop area, we add the following CSS to the <code class="literal">style</code> element in the <code class="literal">head</code> element of our page:<div><pre class="programlisting">    #holder { border: 10px dashed #ccc; 
    width: 150px; height: 150px; 
    margin: 20px auto;}
    #holder.hover { border: 10px dashed #333; #333}</pre></div><p>As you can see in this CSS, we style the HTML element with ID <code class="literal">holder</code> to have a dashed border. The HTML for the <code class="literal">holder div</code> element is shown next:</p><div><pre class="programlisting">  &lt;body&gt;
    &lt;div id="holder"&gt;&lt;/div&gt;
  &lt;/body&gt;</pre></div><p>The drop area has been defined, so the next step is to add drag and drop the functionality to it.</p></li><li class="listitem">Then, we <a id="id98" class="indexterm"/>have to assign the correct event handlers so that we can respond to the various drag and drop related events.</li><li class="listitem">Just as in our previous recipes, we defined a function that contains all the required logic:<div><pre class="programlisting">    function setupDragDrop() {
      var holder = document.getElementById('holder');
   
      holder.ondragover = function() {
        this.className = 'hover';
        return false;
      };

      holder.ondragend = function() {
        this.className = '';
        return false;
      };

      holder.ondrop = function(e) {
        ...
      }
    }</pre></div><p>In this code fragment, we defined three event handlers. The <code class="literal">holder.ondragover</code> event handler sets the class on the div element to <code class="literal">'hover'</code>. This way, the user can see that they are allowed to drop the file there. The <code class="literal">holder.ondragend</code> event handler is called when the user moves away from the drop area. In the event handler, we remove the class of the <code class="literal">div</code> element. Finally, if the user drops a file in the designated area, the <code class="literal">holder.ondrop</code> function is called, which we use to process the dropped image.</p></li><li class="listitem">The <a id="id99" class="indexterm"/>final step is to process the dropped resource and update the material of our box. When a user drops a file, the following piece of code is executed:<div><pre class="programlisting">      this.className = '';
      e.preventDefault();

      var file = e.dataTransfer.files[0],
      var reader = new FileReader();
      reader.onload = function(event) {
        holder.style.background = 
        'url(' + event.target.result + ') no-repeat center';

        var image = document.createElement('img');
        image.src = event.target.result;
        var texture = new THREE.Texture(image);
        texture.needsUpdate = true;

        scene.getObjectByName('cube').material.map = texture;
      };
      reader.readAsDataURL(file);
      return false;</pre></div><p>The first thing that happens is that we call <code class="literal">e.preventDefault()</code>. We need to do this to make sure that the browser doesn't just show the file, since that is its normal behavior. Next, we look at the event and retrieve the dropped file using <code class="literal">e.dataTransfer.files[0]</code>. We can't really do much with the file itself, since Three.js can't work directly with those, so we have to convert it to an <code class="literal">img</code> element. For this, we use a <code class="literal">FileReader</code> object. When the reader is done loading, we use the content to create this <code class="literal">img</code> element. This element is then used to create the <code class="literal">THREE.Texture</code> object, which we set as material for our box.</p><div><img src="img/1182OS_01_22.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec69"/>How it works...</h2></div></div></div><p>Drag and drop functionality isn't something that is supported by Three.js out of the box. As we <a id="id100" class="indexterm"/>saw in the previous section, we use the standard HTML5 drag and drop related events. A good overview of what events are available <a id="id101" class="indexterm"/>can be found in the official HTML5 documentation at <a class="ulink" href="http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model">http://www.w3.org/TR/html5/editing.html#drag-and-drop-processing-model</a>.</p><p>One interesting thing to note is the addition of <code class="literal">texture.needsUpdate = true</code> to the <code class="literal">ondrop</code> event handler. The reason we need to set this property of the texture is to inform Three.js that our texture has changed. This is needed because WebGL and also Three.js caches textures for performance reasons. If we change a texture, we have to set this property to <code class="literal">true</code> to make sure that WebGL knows what to render.</p></div></div></body></html>