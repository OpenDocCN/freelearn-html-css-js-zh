- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Becoming Functional – Several Questions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** (or **FP**) has been around since the earliest days
    of computing and is going through a sort of revival because of its increased use
    with several frameworks and libraries, most particularly in **JavaScript**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduce some concepts of FP to give a small taste of what it means
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the benefits (and problems) implied by the usage of FP and why we should
    use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start thinking about why JavaScript can be considered an appropriate language
    for FP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go over the language features and tools that you should be aware of to fully
    take advantage of everything in this book
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have the basic tools that we’ll be using
    throughout this book, so let’s get started by learning about FP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back in computer history, you’ll find that the second oldest programming
    language still in use, Lisp, is based on FP. Since then, there have been many
    more functional languages, and FP has been applied more widely. But even so, if
    you ask people what FP is, you’ll probably get two widely dissimilar answers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A bit of trivia
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: For trivia or history buffs, the oldest programming language still in use is
    Fortran, which appeared in 1957, a year before Lisp. Quite shortly after Lisp
    came another long-lived language, COBOL, for business-oriented programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Depending on whom you ask, you’ll either learn that it’s a modern, advanced,
    enlightened approach to programming that leaves every other paradigm behind or
    that it’s mainly a theoretical thing, with more complications than benefits, that’s
    practically impossible to implement in the real world. And, as usual, the real
    answer is not in the extremes, but somewhere in between. Let’s start by looking
    at the theory versus practice and see how we plan to use FP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Theory versus practice
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we won’t be going about FP in a theoretical way. Instead, our
    point is to show you how some of its techniques and tenets can be successfully
    applied to common, everyday JavaScript programming. But – and this is important
    – we won’t be going about this dogmatically, but in a very practical way. We won’t
    dismiss useful JavaScript constructs simply because they don’t happen to fulfill
    the academic expectations of FP. Similarly, we won’t avoid practical JavaScript
    features just to fit the FP paradigm. We could almost say that we’ll be doing
    **Sorta Functional Programming** (**SFP**) because our code will be a mixture
    of FP features, more classical imperative ones, and **object-oriented** **programming**
    (**OOP**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, though: what we just said doesn’t mean that we’ll be leaving all
    the theory by the side. We’ll be picky, and just touch the main theoretical points,
    learn some vocabulary and definitions, and explain core FP concepts, but we’ll
    always be keeping in sight the idea of producing actual, useful JavaScript code,
    rather than trying to meet some mystical, dogmatic FP criteria.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: OOP has been a way to solve the inherent complexity of writing large programs
    and systems, and developing clean, extensible, scalable application architectures;
    however, because of the scale of today’s web applications, the complexity of all
    code bases is continuously growing. Also, the newer features of JavaScript make
    it possible to develop applications that wouldn’t even have been possible just
    a few years ago; think of mobile (hybrid) apps that are made with Ionic, Apache
    Cordova, or React Native or desktop apps that are made with Electron, Tauri, or
    NW.js, for example. JavaScript has also migrated to the backend with Node.js or
    Deno, so today, the scope of usage for the language has grown in a serious way
    that deals with all the added complexity of modern designs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A different way of thinking
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FP is a different way of writing programs and can sometimes be difficult to
    learn. In most languages, programming is done imperatively: a program is a sequence
    of statements, executed in a prescribed fashion, and the desired result is achieved
    by creating objects and manipulating them, which usually means modifying the objects
    themselves. FP is based on producing the desired result by evaluating expressions
    built out of functions that are composed together. In FP, it’s common to pass
    functions around (such as passing parameters to other functions or returning functions
    as the result of a calculation), not use loops (opting for recursion instead),
    and skip side effects (such as modifying objects or global variables).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In other words, FP focuses on *what* should be done, rather than on *how* it
    should be done. Instead of worrying about loops or arrays, you work at a higher
    level, considering what needs to be done. After becoming accustomed to this style,
    you’ll find that your code becomes simpler, shorter, and more elegant, and can
    be easily tested and debugged. However, don’t fall into the trap of considering
    FP as the goal! Think of FP only as a means to an end, as with all software tools.
    Functional code isn’t good just for being functional, and writing bad code is
    just as possible with FP as with any other technique!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: FP and other programming paradigms
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming paradigms classify programming languages according to their features.
    However, some languages may be classified into multiple paradigms – as is the
    case of JavaScript itself!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A primary division is *imperative* versus *declarative* languages. In the former,
    developers must instruct the machine on how to do its work, step by step. Programming
    may be *procedural* (if instructions are grouped into procedures) or *object-oriented*
    (if instructions are grouped with a related state).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In declarative languages, in opposition, developers just declare properties
    that the sought result must satisfy, but not how to calculate it. Declarative
    languages may be *logic-based* (based on logic rules and constraints), *reactive*
    (based on data and event streams), or *functional* (based on the application and
    combination of functions). In a sense, we could say that imperative languages
    focus on *how*, while declarative languages focus on *what*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is multi-paradigm: it’s imperative (both procedural and object-oriented)
    but also allows declarative programming, both functional (like almost everything
    in this book! In particular, we will devote [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, to this topic) and reactive (we’ll see reactive FP
    in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing* *Design Patterns*).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to give you a basic example of the difference between imperative and declarative
    ways of solving a problem, let’s solve a simple problem: assume you have an array
    of personal data of people, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Imagine you want to extract the data for adults (at least 21 years old). Imperatively,
    you would do something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have to initialize the output array (`result1`) for the selected people.
    Then, you must specify a loop, saying how the index variable (`i`) is to be initialized,
    tested, and updated. On each pass of the loop, you check the corresponding person’s
    age, and if the person is an adult, you push the data to the output array. In
    other terms, you specify, step by step, everything that the code will have to
    do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Working declaratively, you’d rather write something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line declares how to test if a person is an adult; the second line
    says that the result is the result of filtering the data array, picking those
    elements that satisfy the given predicate. (For `isAdult()`, we’re using an arrow
    function; we’ll see more on that in the *Arrow functions* section, later in this
    chapter.) You don’t have to initialize the output array, specify how to loop,
    or ensure that your array index doesn’t go beyond the array’s length, and so on
    – all those details are taken care of by the language, so you don’t need to.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Reading and understanding the imperative version requires knowledge of both
    the programming language and algorithms or techniques for looping; the declarative
    version is shorter to write, easier to maintain, and much more readable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: What FP is not
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’ve been talking quite a bit about what FP is, let’s also clear up
    some common misconceptions, and look at what FP is not:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '*FP isn’t just an academic ivory tower thing*: The lambda calculus upon which
    it is based was developed by Alonzo Church in 1936 as a tool to prove an important
    result in theoretical computer science (which preceded modern computer languages
    by more than 20 years!); however, FP languages are being used today for all kinds
    of systems.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FP isn’t the opposite of OOP*: It isn’t a case of choosing declarative or
    imperative ways of programming. You can mix and match as best suits you, and we’ll
    be doing this throughout this book, bringing together the best of all worlds.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FP isn’t overly complex to learn*: Some of the FP languages are rather different
    from JavaScript, but the differences are mostly syntactic. Once you learn the
    basic concepts, you’ll see that you can get the same results in JavaScript as
    with FP languages.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may also be relevant to mention that several modern frameworks, such as the
    React and Redux combination, include FP ideas.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: For example, in React, it’s said that the view (whatever the user gets to see
    at a given moment) is a function of the current state. You use a function to compute
    what HTML and CSS must be produced at each moment, thinking in a black-box fashion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in Redux, you have the concept of actions that are processed by reducers.
    An action provides some data, and a reducer is a function that produces the new
    state for the application in a functional way out of the current state and the
    provided data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: So, both because of the theoretical advantages (we’ll be getting to those in
    the following section) and the practical ones (such as getting to use the latest
    frameworks and libraries), it makes sense to consider FP coding. Let’s get on
    with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Why use FP?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the years, there have been many programming styles and fads. However,
    FP has proven quite resilient and is of great interest today. Why would you want
    to use FP? Rather, the first question to ask should be, what do you need? And
    only then, does FP get you that? We’ll answer these important questions in the
    following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: What we need
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can certainly agree that the following list of concerns is universal. Our
    code should have the following qualities:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular**: The functionality of your program should be divided into independent
    modules, each of which contains a part of the solution. Changes in a module or
    function shouldn’t affect the rest of the code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understandable**: A reader of your program should be able to discern its
    components, functions, and relationships without undue effort. This is closely
    linked with the **maintainability** of the code; your code will have to be maintained
    in the future, whether to be changed or to have new functionality added.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testable**: **Unit tests** try out small parts of your program, verifying
    their behavior independently of the rest of the code. Your programming style should
    favor writing code that simplifies the job of writing unit tests. Unit tests are
    also like documentation in that they can help readers understand what the code
    is supposed to do.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: It’s a fact that your program will someday require maintenance,
    possibly to add new functionality. Those changes should impact the structure and
    data flow of the original code only minimally (if at all). Small changes shouldn’t
    imply large, serious refactoring of your code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable**: Code reuse has the goal of saving resources, time, and money,
    and reducing redundancy by taking advantage of previously written code. Some characteristics
    help with this goal, such as **modularity** (which we already mentioned), **high
    cohesion** (all the pieces in a module belong together), **low coupling** (modules
    are independent of each other), **separation of concerns** (the parts of a program
    should overlap in functionality as little as possible), and **information hiding**
    (internal changes in a module shouldn’t affect the rest of the system).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we get
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, does FP give you the five characteristics we just listed in the previous
    section?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In FP, the goal is to write separate independent functions that are joined together
    to produce the final results.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that are written in a functional style usually tend to be cleaner,
    shorter, and easier to understand.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be tested on their own, and FP code has advantages in achieving
    this.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reuse functions in other programs because they stand on their own, not
    depending on the rest of the system. Most functional programs share common functions,
    several of which we’ll be considering in this book.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional code is free from side effects, which means you can understand the
    objective of a function by studying it without having to consider the rest of
    the program.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, once you get used to the FP style of programming, code becomes more
    understandable and easier to extend. So, it seems that all five characteristics
    can be achieved with FP!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Why use FP?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: For a well-balanced look at the reasons to use FP, I’d suggest reading *Why
    Functional Programming Matters*, by John Hughes; it’s available online at [www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf).
    It’s not geared toward JavaScript, but the arguments are easily understandable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Not all is gold
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, let’s strive for a bit of balance. Using FP isn’t a silver bullet that
    will automagically make your code better. Some FP solutions are tricky, and some
    developers greatly enjoy writing code and then asking, what does this do? If you
    aren’t careful, your code may become write-only and practically impossible to
    maintain; there goes understandable, extensible, and reusable out the door!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Another disadvantage is that you may find it harder to find FP-savvy developers.
    (Quick question: how many *FP-sought* job ads have you ever seen?) The vast majority
    of today’s web code is written in imperative, non-functional ways, and most coders
    are used to that way of working. For some, having to switch gears and start writing
    programs differently may prove an unpassable barrier.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you try to go fully functional, you may find yourself at odds with
    JavaScript, and simple tasks may become hard to do. As we said at the beginning,
    we’ll opt for **SFP**, so we won’t be drastically rejecting any language features
    that aren’t 100% functional. After all, we want to use FP to simplify our coding,
    not to make it more complex!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'So, while I’ll strive to show you the advantages of going functional in your
    code, as with any change, there will always be some difficulties. However, I’m
    fully convinced that you’ll be able to surmount them and that your organization
    will develop better code by applying FP. Dare to change! So, given that you accept
    that FP may apply to your problems, let’s consider the other question: can we
    use JavaScript in a functional way and is it appropriate?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Is JavaScript functional?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At about this time, there is another important question that you should be
    asking: *is JavaScript a functional language?* Usually, when thinking about FP,
    the list of languages that are mentioned does not include JavaScript, but does
    include less common options, such as Clojure, Erlang, Haskell, and Scala; however,
    there is no precise definition for FP languages or a precise set of features that
    such languages should include. The main point is that you can consider a language
    to be functional if it supports the common programming style associated with FP.
    Let’s start by learning about why we would want to use JavaScript at all and how
    the language has evolved to its current version, and then see some of the key
    features that we’ll be using to work in a functional way.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as a tool
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is JavaScript? If you consider popularity indices, such as the ones at
    [www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/) or [pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html),
    you’ll find that JavaScript is consistently in the top 10 most popular languages.
    From a more academic point of view, the language is sort of a mixture, borrowing
    features from several different languages. Several libraries helped the growth
    of the language by providing features that weren’t so easily available, such as
    classes and inheritance (today’s version of the language does support classes,
    but that was not the case not too long ago), that otherwise had to be achieved
    by doing some prototype tricks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: What’s in a name?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The name *JavaScript* was chosen to take advantage of the popularity of Java
    – just as a marketing ploy! Its first name was *Mocha*, then, *LiveScript*, and
    only then *JavaScript*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has grown to be incredibly powerful. But, as with all power tools,
    it gives you a way to not only produce great solutions but also to do great harm.
    FP could be considered as a way to reduce or leave aside some of the worst parts
    of the language and focus on working in a safer, better way; however, due to the
    immense amount of existing JavaScript code, you cannot expect it to facilitate
    large reworkings of the language that would cause most sites to fail. You must
    learn to live with the good and the bad, and simply avoid the latter part.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the language has a broad variety of available libraries that complete
    or extend the language in many ways. In this book, we’ll be focusing on using
    JavaScript on its own, but we will make references to existing, available code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: If we ask whether JavaScript is functional, the answer will be, once again,
    “sorta”. It can be seen as functional because of several features, such as first-class
    functions, anonymous functions, recursion, and closures – we’ll get back to this
    later. On the other hand, it also has plenty of non-FP aspects, such as side effects
    (impurity), mutable objects, and practical limits to recursion. So, when programming
    in a functional way, we’ll be taking advantage of all the relevant, appropriate
    language features, and we’ll try to minimize the problems caused by the more conventional
    parts of the language. In this sense, JavaScript will or won’t be functional,
    depending on your programming style!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use FP, you should decide which language to use; however, opting
    for fully functional languages may not be so wise. Today, developing code isn’t
    as simple as just using a language; you will surely require frameworks, libraries,
    and other sundry tools. If we can take advantage of all the provided tools but
    at the same time introduce FP ways of working in our code, we’ll be getting the
    best of both worlds, regardless of whether JavaScript is functional!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Going functional with JavaScript
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has evolved through the years, and the version we’ll be using is
    (informally) called JS13, and (formally) ECMAScript 2022, usually shortened to
    ES2022 or ES13; this version was finalized in June 2022\. The previous versions
    were as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 1, June 1997
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 2, June 1998, which was the same as the previous version, ECMAScript
    3, December 1999, with several new functionalities
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5, December 2009 (and no, there never was an ECMAScript 4, because
    it was abandoned)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5.1, June 2011
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 6 (or ES6; later renamed ES2015), June 2015 ECMAScript 7 (also ES7,
    or ES2016), June 2016 ECMAScript 8 (ES8 or ES2017), June 2017
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 9 (ES9 or ES2018), June 2018
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 10 (ES10 or ES2019), June 2019
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 11 (ES11 or ES2020), June 2020
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 12 (ES12 or ES2021), June 2021
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s ECMA?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: ECMA originally stood for European Computer Manufacturers Association, but nowadays,
    the name isn’t considered an acronym anymore. The organization is responsible
    for standards other than JavaScript as well, including JSON, C#, Dart, and others.
    For more details, go to its site at [www.ecma-international.org/](http://www.ecma-international.org/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: You can read the standard language specification at [www.ecma-international.org/publications-and-standards/standards/ecma-262/](http://www.ecma-international.org/publications-and-standards/standards/ecma-262/).
    Whenever we refer to JavaScript in the text without further specification, ES13
    (ES2022) is what is being referred to; however, in terms of the language features
    that are used in this book, if you were just to use ES2015, then you’d mostly
    have no problems with this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: No browsers fully implement ES13; most provide an older version, JavaScript
    5 (from 2009), with an (always growing) smattering of features from ES6 up to
    ES13\. This will prove to be a problem, but fortunately, a solvable one; we’ll
    get to this shortly. We’ll be using ES13 throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Differences, differences…
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: There are only a few differences between ES2016 and ES2015, such as the `Array.prototype.includes`
    method and the exponentiation operator, `**`. There are more differences between
    ES2017 and ES2016 – such as `async` and `await`, some string padding functions,
    and more – but they won’t impact our code. We will also be looking at alternatives
    for even more modern additions, such as `flatMap()`, in later chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to work with JavaScript, let’s start by considering its most
    important features that pertain to our FP goals.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Key features of JavaScript
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript isn’t a purely functional language, but it has all the features
    that we need for it to work as if it were. The main features of the language that
    we will be using are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see some examples of each one and find out why they will be useful to
    us. Keep in mind, though, that there are more features of JavaScript that we will
    be using; the upcoming sections just highlight the most important features in
    terms of what we will be using for FP.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saying that functions are **first-class objects** (also called **first-class
    entities** or **first-class citizens**) means that you can do everything with
    functions that you can do with other objects. For example, you can store a function
    in a variable, you can pass it to a function, you can print it out, and so on.
    This is really the key to doing FP; we will often be passing functions as parameters
    (to other functions) or returning a function as the result of a function call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have been doing async Ajax calls, then you have already been using this
    feature: a **callback** is a function that will be called after the Ajax call
    finishes and is passed as a parameter. Using jQuery, you could write something
    like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `$.get()` function receives a callback function as a parameter and calls
    it after the result is obtained.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The way to go
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: This is better solved, in a more modern way, by using promises or `async`/`await`,
    but for the sake of our example, the old way is enough. We’ll be getting back
    to promises, though, in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building
    Better Containers*, when we discuss monads; in particular, see the *Unexpected
    monads –* *promises* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functions can be stored in variables, you could also write something
    like the following. Pay attention to how we use the `doSomething` variable in
    the `$.``get(...)` call:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll be seeing more examples of this in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Recursion** is the most potent tool for developing algorithms and a great
    aid for solving large classes of problems. The idea is that a function can, at
    a certain point, call itself and, when *that* call is done, continue working with
    whatever result it has received. This is usually quite helpful for certain classes
    of problems or definitions. The most often quoted example is the factorial function
    (the factorial of *n* is written as *n!*), as defined for nonnegative integer
    values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is 0, then *n*! = 1
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is greater than 0, then *n*! = *n* * (*n*-1)!
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging things
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The value of *n!* is the number of ways that you can arrange *n* different elements
    in a row. For example, if you want to place five books in line, you can pick any
    of the five for the first place, and then order the other four in every possible
    way, so 5! = 5*4!. To order those four, you can pick any of them for the first
    place, and then order the other three in every way, so 4! = 4*3!. If you continue
    to work on this example, you’ll end up with 5! = 5*4*3*2*1=120, and in general,
    *n*! is the product of all numbers up to *n*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be immediately turned into code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Recursion will be a great aid for designing algorithms. By using recursion,
    you could do without any `while` or `for` loops – not that we want to do that,
    but it’s interesting that we can! We’ll be devoting the entirety of [*Chapter
    9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, to designing algorithms
    and writing functions recursively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closures are a way to implement data hiding (with private variables), which
    leads to modules and other nice features. The key concept of closures is that
    when you define a function, it can refer to not only its local variables but also
    to everything outside of the context of the function. We can write a counting
    function that will keep its `count` using a closure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even after `newCounter()` exits, the inner function still has access to `count`,
    but that variable is not accessible to any other parts of your code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a very good example of FP – a function (`nc()`, in this case) isn’t
    expected to return different results when called with the same parameters!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We’ll find several uses for closures, such as **memoization** (see [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, and [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*) and the **module pattern** (see [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, and [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*), among others.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`(parameter, anotherparameter, ...etc) => { statements }` or `(parameter, anotherparameter,
    ...etc) => expression`. The first allows you to write as much code as you want,
    while the second is short for `{ return expression }`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite our earlier Ajax example as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A new version of the factorial code could be like the following code – the
    only difference is the usage of an arrow function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Functions, anonymous
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions are usually called anonymous functions because of their lack
    of a name. If you need to refer to an arrow function, you’ll have to assign it
    to a variable or object attribute, as we did here; otherwise, you won’t be able
    to use it. We’ll learn more about this in the *Arrow functions – the modern way*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out* *with
    Functions*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'You would probably write `fact2()` as a one-liner – can you see the equivalence
    to our earlier code? Using a ternary operator instead of `if` is quite common:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this shorter form, you don’t have to write `return` – it’s implied.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Functions – the lambda way
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, a function such as *x* => 2**x* would be represented as
    λ*x.*2**x*. Although there are syntactical differences, the definitions are analogous.
    Functions with more parameters are a bit more complicated; (*x,y*)=>*x*+*y* would
    be expressed as λ*x*.λ*y*.*x*+*y*. We’ll learn more about this in the *Of lambdas
    and functions* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting
    Out with Functions*, and in the *Currying* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,*
    *Transforming Functions*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other small thing to bear in mind: when the arrow function has
    a single parameter, you can omit the parentheses around it. I usually prefer leaving
    them, but I’ve applied a JavaScript beautifier, *Prettier*, to the code, which
    removes them. It’s really up to you whether to include them or not! (For more
    on this tool, check out [github.com/prettier/prettier](http://github.com/prettier/prettier).)
    By the way, my options for formatting were `--print-width 75 -- tab-width` `2
    --no-bracket-spacing`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Spread
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The spread `...` operator (see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator))
    lets you expand an expression in places where you would otherwise require multiple
    arguments, elements, or variables. For example, you can replace arguments in a
    function call, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create or join arrays, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It works with objects too:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also use it to work with functions that expect separate parameters
    instead of an array. Common examples of this would be `Math.min()` and `Math.max()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are specifying that `maxArray()` shall receive an array of numbers as an
    argument.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write the following equality since the `.apply()` method requires
    an array of arguments, but `.call()` expects individual arguments, which you can
    get by spreading:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A mnemonic for arguments
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have problems remembering what arguments are required by `.apply()`
    and `.call()`, this mnemonic may help: *A is for Array, and C is for Comma*. See
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
    for more information.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread operator helps with writing shorter, more concise code, and
    we will be taking advantage of it. We have seen all of the most important JavaScript
    features that we will be using. Let’s round off this chapter by looking at some
    tools that we’ll be working with.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How do we work with JavaScript?
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all well and good, but as we mentioned before, it so happens that the
    JavaScript version available almost everywhere isn’t ES13, but rather the earlier
    JS5\. An exception to this is Node.js. It is based on Chrome’s V8 high-performance
    JavaScript engine, which already has several ES13 features available. Nonetheless,
    at the time of writing, ES13 coverage isn’t 100% complete, and there are features
    that you will miss. (Check out [nodejs.org/en/docs/es6/](http://nodejs.org/en/docs/es6/)
    for more on Node.js and v8.) This is surely changing since Internet Explorer is
    fading away (support for it ended in June 2022), having been replaced with Microsoft’s
    Edge browser, which shares Chrome’s engine. In any case, we must still deal with
    older, less powerful engines.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to be sure of your choices before using any given new feature,
    check out the compatibility table at [kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    (see *Figure 1**.1*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them](img/Figure_1.1_B19301.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'For Node.js specifically, check out [node.green/](http://node.green/), which
    takes its data from the Kangax table; see *Figure 1**.2*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Compatibility table specifically for Node.js](img/Figure_1.2_B19301.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Compatibility table specifically for Node.js
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: So, what can you do if you want to code using the latest version, but the available
    one is an earlier, poorer one? Or what happens if most of your users are using
    older browsers, which don’t support the fancy features you’re keen on using? Let’s
    see some solutions for this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Using transpilers
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get out of this availability and compatibility problem, there are a couple
    of transpilers that you can use. Transpilers take your original ES13 code, which
    might use the most modern JavaScript features, and transforms it into equivalent
    JS5 code. It’s a source-to-source transformation, instead of source-to-object
    code that would be used in compilation. You can code using advanced ES13 features,
    but the user’s browsers will receive JS5 code. A transpiler will also let you
    keep up with upcoming versions of the language, despite the time needed by browsers
    to adopt new standards across desktop and mobile devices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: On word origins
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wonder where the word *transpiler* came from, it is a portmanteau of
    *translate* and *compiler*. There are many such combinations in technological
    speak: *email* (*electronic* and *mail*), *emoticon* (*emotion* and *icon*), *malware*
    (*malicious* and *software*), *alphanumeric* (*alphabetic* and *numeric*), and
    many more.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the most common transpiler for JavaScript is **Babel** ([babeljs.io/](http://babeljs.io/));
    years ago, we also had **Traceur** ([github.com/google/traceur-compiler](http://github.com/google/traceur-compiler)),
    but that’s not maintained any longer. Two other possibilities are **SWC** ([swc.rs/](http://swc.rs/))
    and **Sucrase** ([sucrase.io/](http://sucrase.io/)); in particular, the latter
    boasts a much faster transpilation speed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'With tools such as **npm** or **webpack**, it’s fairly easy to configure things
    so that your code will get automatically transpiled and provided to end users.
    You can also carry out transpilation online; see *Figure 1**.3* for an example
    of Babel’s online environment:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5
    code](img/Figure_1.3_B19301.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5 code
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: There are specific ways of installing these tools for your programming environment,
    and usually, you won’t have to do it by hand; check out [www.typescriptlang.org/download](http://www.typescriptlang.org/download)
    for more information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Working online
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some more online tools that you can use to test out your JavaScript
    code. Check out **JSFiddle** ([jsfiddle.net/](http://jsfiddle.net/)), **CodePen**
    ([codepen.io/](http://codepen.io/)), and **JSBin** ([jsbin.com/](http://jsbin.com/)),
    among others. You can see an example of CodePen in *Figure 1**.4*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools](img/Figure_1.4_B19301.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Using these tools provides a very quick way to try out code or do small experiments
    – and I can truly vouch for this since I’ve tested much of the code in this book
    in this way!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A step further – TypeScript
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous editions of this book, we went with straight JavaScript. Still,
    in the years since, Microsoft’s **TypeScript** ([www.typescriptlang.org/](http://www.typescriptlang.org/)),
    a superset of the language that is itself compiled into JavaScript, has gained
    a lot of following, is now standard with many frameworks, and you can use both
    for frontend and backend code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of TypeScript is the ability to add (optional) static type
    checks to JavaScript, which helps detect programming errors at compile time. But
    beware: as with Babel, not all of ES13 will be available. However, it’s entirely
    sufficient for our purposes, allowing us to be more careful with coding.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Most statistics about programming language popularity rank TypeScript in the
    top 10; *Figure 1**.5* (from [spectrum.ieee.org/top-programming-languages-2022](http://spectrum.ieee.org/top-programming-languages-2022))
    confirms this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum](img/Figure_1.5_B19301.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Going to the source
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Despite using TypeScript, in the rest of this book, we’ll keep referring to
    JavaScript, which is, after all, the language that is executed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform type checks by using Facebook’s **Flow** ([flow.org/](http://flow.org/)).
    However, there’s more support for using external libraries with TypeScript than
    with Flow. Also, the tooling and installation for development are simpler for
    TypeScript.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring types?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: There’s a proposal (that may go nowhere – be warned!) to allow JavaScript to
    process (by ignoring) types, so you would be able to run TypeScript directly,
    with no preprocessing or transpiling of any kind. For more on this, go to [tc39.es/proposal-type-annotations/](http://tc39.es/proposal-type-annotations/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: It should be made clear that TypeScript is more than just a type checker; it’s
    a language on its own (OK, it's very similar to JavaScript, but still…). For example,
    it adds interfaces, decorators, enumerated types, and more to the language, so
    you can use such features that are typical in other languages. In any case, if
    you don’t care for TypeScript, you can just ignore the types-related syntax, and
    then you’ll have plain JavaScript.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is available via online tools, and you can also test it online on
    their playground ([www.typescriptlang.org/play/](http://www.typescriptlang.org/play/)).
    You can set options to be more or less strict with data type checks, and you can
    also run your code on the spot; see *Figure 1**.6* for more details:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – You can check and transpile your code online, on TypeScript’s
    website](img/Figure_1.6_B19301.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – You can check and transpile your code online, on TypeScript’s website
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, in the *Specifying data types* section of [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will consider a formal type system for FP languages
    (not just JavaScript) and we’ll find out that our TypeScript work has allayed
    most difficulties.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'A final admission: at times, TypeScript may seem more of a hindrance than a
    help when you have to deal with complex data typing expressions. (Updating all
    the code in this book to TypeScript sometimes led me to doubt my sanity in using
    it!) However, in the long run, code written in TypeScript is less prone to bugs,
    because its static type checks detect and avoid many common errors.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will also touch on testing, which is, after all, one of FP’s main advantages.
    In previous editions of this book, we went with **Jasmine** ([jasmine.github.io/](http://jasmine.github.io/)),
    but now, we’ve changed to Facebook’s **Jest** ([jestjs.io/](http://jestjs.io/))
    – which is built on top of Jasmine!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest has grown in popularity due to its ease of use and broad applicability:
    you can test frontend and backend code equally well, with little configuration.
    (See [jestjs.io/docs/getting-started](http://jestjs.io/docs/getting-started) for
    its installation and configuration.) We won’t be writing tests for every single
    piece of code in this book, but while following the ideas of **test-driven development**
    (**TDD**), we’ll often do so.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the basics of FP, a bit of its history, its advantages
    (and also some possible disadvantages, to be fair), why we can apply it in JavaScript
    (which isn’t usually considered a functional language), and what tools we’ll need
    to go through the rest of this book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we’ll go over an example of a simple problem, look at it in common ways, and end
    by solving it in a functional manner and analyzing the advantages of our method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1.1 **TypeScript, please!** Let’s keep our promise: convert the JavaScript
    examples provided in this chapter into TypeScript.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 **TypeScript，请！** 让我们遵守承诺：将本章提供的JavaScript示例转换为TypeScript。
- en: '1.2 **Classes as first-class objects**: We learned that functions are first-class
    objects, but did you know that classes also are? (Though, of course, speaking
    of classes as objects does sound weird.) Look at the following example and see
    what makes it tick! Be careful: there’s some purposefully weird code in it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 **类作为一等对象**：我们了解到函数是一等对象，但你是否知道类也是一等对象？（尽管，当然，将类称为对象听起来有点奇怪。）看看下面的例子，看看是什么让它运转！请注意：里面有一些故意写得很奇怪的代码：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '1.3 **Climbing factorial**: Our implementation of a factorial starts by multiplying
    by *n*, then by *n*-1, then *n*-2, and so on in what we could call a downward
    fashion. Can you write a new version of the factorial function that will loop
    upwards?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 **递减阶乘**：我们实现阶乘的方法是从乘以 *n* 开始，然后是 *n*-1，然后是 *n*-2，以此类推，这可以称为递减方式。你能编写一个新的阶乘函数，使其向上循环吗？
- en: '1.4 **Factorial errors**: Factorials, as we defined them, should only be calculated
    for non-negative integers. However, the function that we wrote in the *Recursion*
    section doesn’t check whether its argument is valid. Can you add the necessary
    checks? Try to avoid repeated, redundant tests!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 **阶乘错误**：根据我们的定义，阶乘只应该对非负整数进行计算。然而，我们在 *递归* 部分编写的函数并没有检查其参数是否有效。你能添加必要的检查吗？尽量避免重复和冗余的测试！
- en: '1.5 **Factorial testing**: Write complete tests for the function in the previous
    question. Try to achieve 100% coverage.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5 **阶乘测试**：为上一题中的函数编写完整的测试。尽量达到100%的覆盖率。
- en: 1.6 `newCounter()` to half its length. Can you see how?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6 将 `newCounter()` 缩短到一半。你能看到如何做到吗？
- en: 1.7 `newCounter()` function?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7 `newCounter()` 函数？
