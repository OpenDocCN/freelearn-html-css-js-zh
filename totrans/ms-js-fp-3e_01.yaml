- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Becoming Functional – Several Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional programming** (or **FP**) has been around since the earliest days
    of computing and is going through a sort of revival because of its increased use
    with several frameworks and libraries, most particularly in **JavaScript**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce some concepts of FP to give a small taste of what it means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the benefits (and problems) implied by the usage of FP and why we should
    use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start thinking about why JavaScript can be considered an appropriate language
    for FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go over the language features and tools that you should be aware of to fully
    take advantage of everything in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have the basic tools that we’ll be using
    throughout this book, so let’s get started by learning about FP.
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you go back in computer history, you’ll find that the second oldest programming
    language still in use, Lisp, is based on FP. Since then, there have been many
    more functional languages, and FP has been applied more widely. But even so, if
    you ask people what FP is, you’ll probably get two widely dissimilar answers.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of trivia
  prefs: []
  type: TYPE_NORMAL
- en: For trivia or history buffs, the oldest programming language still in use is
    Fortran, which appeared in 1957, a year before Lisp. Quite shortly after Lisp
    came another long-lived language, COBOL, for business-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on whom you ask, you’ll either learn that it’s a modern, advanced,
    enlightened approach to programming that leaves every other paradigm behind or
    that it’s mainly a theoretical thing, with more complications than benefits, that’s
    practically impossible to implement in the real world. And, as usual, the real
    answer is not in the extremes, but somewhere in between. Let’s start by looking
    at the theory versus practice and see how we plan to use FP.
  prefs: []
  type: TYPE_NORMAL
- en: Theory versus practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we won’t be going about FP in a theoretical way. Instead, our
    point is to show you how some of its techniques and tenets can be successfully
    applied to common, everyday JavaScript programming. But – and this is important
    – we won’t be going about this dogmatically, but in a very practical way. We won’t
    dismiss useful JavaScript constructs simply because they don’t happen to fulfill
    the academic expectations of FP. Similarly, we won’t avoid practical JavaScript
    features just to fit the FP paradigm. We could almost say that we’ll be doing
    **Sorta Functional Programming** (**SFP**) because our code will be a mixture
    of FP features, more classical imperative ones, and **object-oriented** **programming**
    (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, though: what we just said doesn’t mean that we’ll be leaving all
    the theory by the side. We’ll be picky, and just touch the main theoretical points,
    learn some vocabulary and definitions, and explain core FP concepts, but we’ll
    always be keeping in sight the idea of producing actual, useful JavaScript code,
    rather than trying to meet some mystical, dogmatic FP criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: OOP has been a way to solve the inherent complexity of writing large programs
    and systems, and developing clean, extensible, scalable application architectures;
    however, because of the scale of today’s web applications, the complexity of all
    code bases is continuously growing. Also, the newer features of JavaScript make
    it possible to develop applications that wouldn’t even have been possible just
    a few years ago; think of mobile (hybrid) apps that are made with Ionic, Apache
    Cordova, or React Native or desktop apps that are made with Electron, Tauri, or
    NW.js, for example. JavaScript has also migrated to the backend with Node.js or
    Deno, so today, the scope of usage for the language has grown in a serious way
    that deals with all the added complexity of modern designs.
  prefs: []
  type: TYPE_NORMAL
- en: A different way of thinking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FP is a different way of writing programs and can sometimes be difficult to
    learn. In most languages, programming is done imperatively: a program is a sequence
    of statements, executed in a prescribed fashion, and the desired result is achieved
    by creating objects and manipulating them, which usually means modifying the objects
    themselves. FP is based on producing the desired result by evaluating expressions
    built out of functions that are composed together. In FP, it’s common to pass
    functions around (such as passing parameters to other functions or returning functions
    as the result of a calculation), not use loops (opting for recursion instead),
    and skip side effects (such as modifying objects or global variables).'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, FP focuses on *what* should be done, rather than on *how* it
    should be done. Instead of worrying about loops or arrays, you work at a higher
    level, considering what needs to be done. After becoming accustomed to this style,
    you’ll find that your code becomes simpler, shorter, and more elegant, and can
    be easily tested and debugged. However, don’t fall into the trap of considering
    FP as the goal! Think of FP only as a means to an end, as with all software tools.
    Functional code isn’t good just for being functional, and writing bad code is
    just as possible with FP as with any other technique!
  prefs: []
  type: TYPE_NORMAL
- en: FP and other programming paradigms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming paradigms classify programming languages according to their features.
    However, some languages may be classified into multiple paradigms – as is the
    case of JavaScript itself!
  prefs: []
  type: TYPE_NORMAL
- en: A primary division is *imperative* versus *declarative* languages. In the former,
    developers must instruct the machine on how to do its work, step by step. Programming
    may be *procedural* (if instructions are grouped into procedures) or *object-oriented*
    (if instructions are grouped with a related state).
  prefs: []
  type: TYPE_NORMAL
- en: In declarative languages, in opposition, developers just declare properties
    that the sought result must satisfy, but not how to calculate it. Declarative
    languages may be *logic-based* (based on logic rules and constraints), *reactive*
    (based on data and event streams), or *functional* (based on the application and
    combination of functions). In a sense, we could say that imperative languages
    focus on *how*, while declarative languages focus on *what*.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is multi-paradigm: it’s imperative (both procedural and object-oriented)
    but also allows declarative programming, both functional (like almost everything
    in this book! In particular, we will devote [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, to this topic) and reactive (we’ll see reactive FP
    in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing* *Design Patterns*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to give you a basic example of the difference between imperative and declarative
    ways of solving a problem, let’s solve a simple problem: assume you have an array
    of personal data of people, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you want to extract the data for adults (at least 21 years old). Imperatively,
    you would do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You have to initialize the output array (`result1`) for the selected people.
    Then, you must specify a loop, saying how the index variable (`i`) is to be initialized,
    tested, and updated. On each pass of the loop, you check the corresponding person’s
    age, and if the person is an adult, you push the data to the output array. In
    other terms, you specify, step by step, everything that the code will have to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working declaratively, you’d rather write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line declares how to test if a person is an adult; the second line
    says that the result is the result of filtering the data array, picking those
    elements that satisfy the given predicate. (For `isAdult()`, we’re using an arrow
    function; we’ll see more on that in the *Arrow functions* section, later in this
    chapter.) You don’t have to initialize the output array, specify how to loop,
    or ensure that your array index doesn’t go beyond the array’s length, and so on
    – all those details are taken care of by the language, so you don’t need to.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and understanding the imperative version requires knowledge of both
    the programming language and algorithms or techniques for looping; the declarative
    version is shorter to write, easier to maintain, and much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: What FP is not
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’ve been talking quite a bit about what FP is, let’s also clear up
    some common misconceptions, and look at what FP is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FP isn’t just an academic ivory tower thing*: The lambda calculus upon which
    it is based was developed by Alonzo Church in 1936 as a tool to prove an important
    result in theoretical computer science (which preceded modern computer languages
    by more than 20 years!); however, FP languages are being used today for all kinds
    of systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FP isn’t the opposite of OOP*: It isn’t a case of choosing declarative or
    imperative ways of programming. You can mix and match as best suits you, and we’ll
    be doing this throughout this book, bringing together the best of all worlds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FP isn’t overly complex to learn*: Some of the FP languages are rather different
    from JavaScript, but the differences are mostly syntactic. Once you learn the
    basic concepts, you’ll see that you can get the same results in JavaScript as
    with FP languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may also be relevant to mention that several modern frameworks, such as the
    React and Redux combination, include FP ideas.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in React, it’s said that the view (whatever the user gets to see
    at a given moment) is a function of the current state. You use a function to compute
    what HTML and CSS must be produced at each moment, thinking in a black-box fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in Redux, you have the concept of actions that are processed by reducers.
    An action provides some data, and a reducer is a function that produces the new
    state for the application in a functional way out of the current state and the
    provided data.
  prefs: []
  type: TYPE_NORMAL
- en: So, both because of the theoretical advantages (we’ll be getting to those in
    the following section) and the practical ones (such as getting to use the latest
    frameworks and libraries), it makes sense to consider FP coding. Let’s get on
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Why use FP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the years, there have been many programming styles and fads. However,
    FP has proven quite resilient and is of great interest today. Why would you want
    to use FP? Rather, the first question to ask should be, what do you need? And
    only then, does FP get you that? We’ll answer these important questions in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: What we need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can certainly agree that the following list of concerns is universal. Our
    code should have the following qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular**: The functionality of your program should be divided into independent
    modules, each of which contains a part of the solution. Changes in a module or
    function shouldn’t affect the rest of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understandable**: A reader of your program should be able to discern its
    components, functions, and relationships without undue effort. This is closely
    linked with the **maintainability** of the code; your code will have to be maintained
    in the future, whether to be changed or to have new functionality added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testable**: **Unit tests** try out small parts of your program, verifying
    their behavior independently of the rest of the code. Your programming style should
    favor writing code that simplifies the job of writing unit tests. Unit tests are
    also like documentation in that they can help readers understand what the code
    is supposed to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: It’s a fact that your program will someday require maintenance,
    possibly to add new functionality. Those changes should impact the structure and
    data flow of the original code only minimally (if at all). Small changes shouldn’t
    imply large, serious refactoring of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusable**: Code reuse has the goal of saving resources, time, and money,
    and reducing redundancy by taking advantage of previously written code. Some characteristics
    help with this goal, such as **modularity** (which we already mentioned), **high
    cohesion** (all the pieces in a module belong together), **low coupling** (modules
    are independent of each other), **separation of concerns** (the parts of a program
    should overlap in functionality as little as possible), and **information hiding**
    (internal changes in a module shouldn’t affect the rest of the system).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we get
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, does FP give you the five characteristics we just listed in the previous
    section?
  prefs: []
  type: TYPE_NORMAL
- en: In FP, the goal is to write separate independent functions that are joined together
    to produce the final results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that are written in a functional style usually tend to be cleaner,
    shorter, and easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be tested on their own, and FP code has advantages in achieving
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reuse functions in other programs because they stand on their own, not
    depending on the rest of the system. Most functional programs share common functions,
    several of which we’ll be considering in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional code is free from side effects, which means you can understand the
    objective of a function by studying it without having to consider the rest of
    the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, once you get used to the FP style of programming, code becomes more
    understandable and easier to extend. So, it seems that all five characteristics
    can be achieved with FP!
  prefs: []
  type: TYPE_NORMAL
- en: Why use FP?
  prefs: []
  type: TYPE_NORMAL
- en: For a well-balanced look at the reasons to use FP, I’d suggest reading *Why
    Functional Programming Matters*, by John Hughes; it’s available online at [www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf).
    It’s not geared toward JavaScript, but the arguments are easily understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Not all is gold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, let’s strive for a bit of balance. Using FP isn’t a silver bullet that
    will automagically make your code better. Some FP solutions are tricky, and some
    developers greatly enjoy writing code and then asking, what does this do? If you
    aren’t careful, your code may become write-only and practically impossible to
    maintain; there goes understandable, extensible, and reusable out the door!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another disadvantage is that you may find it harder to find FP-savvy developers.
    (Quick question: how many *FP-sought* job ads have you ever seen?) The vast majority
    of today’s web code is written in imperative, non-functional ways, and most coders
    are used to that way of working. For some, having to switch gears and start writing
    programs differently may prove an unpassable barrier.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you try to go fully functional, you may find yourself at odds with
    JavaScript, and simple tasks may become hard to do. As we said at the beginning,
    we’ll opt for **SFP**, so we won’t be drastically rejecting any language features
    that aren’t 100% functional. After all, we want to use FP to simplify our coding,
    not to make it more complex!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, while I’ll strive to show you the advantages of going functional in your
    code, as with any change, there will always be some difficulties. However, I’m
    fully convinced that you’ll be able to surmount them and that your organization
    will develop better code by applying FP. Dare to change! So, given that you accept
    that FP may apply to your problems, let’s consider the other question: can we
    use JavaScript in a functional way and is it appropriate?'
  prefs: []
  type: TYPE_NORMAL
- en: Is JavaScript functional?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At about this time, there is another important question that you should be
    asking: *is JavaScript a functional language?* Usually, when thinking about FP,
    the list of languages that are mentioned does not include JavaScript, but does
    include less common options, such as Clojure, Erlang, Haskell, and Scala; however,
    there is no precise definition for FP languages or a precise set of features that
    such languages should include. The main point is that you can consider a language
    to be functional if it supports the common programming style associated with FP.
    Let’s start by learning about why we would want to use JavaScript at all and how
    the language has evolved to its current version, and then see some of the key
    features that we’ll be using to work in a functional way.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as a tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is JavaScript? If you consider popularity indices, such as the ones at
    [www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/) or [pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html),
    you’ll find that JavaScript is consistently in the top 10 most popular languages.
    From a more academic point of view, the language is sort of a mixture, borrowing
    features from several different languages. Several libraries helped the growth
    of the language by providing features that weren’t so easily available, such as
    classes and inheritance (today’s version of the language does support classes,
    but that was not the case not too long ago), that otherwise had to be achieved
    by doing some prototype tricks.
  prefs: []
  type: TYPE_NORMAL
- en: What’s in a name?
  prefs: []
  type: TYPE_NORMAL
- en: The name *JavaScript* was chosen to take advantage of the popularity of Java
    – just as a marketing ploy! Its first name was *Mocha*, then, *LiveScript*, and
    only then *JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has grown to be incredibly powerful. But, as with all power tools,
    it gives you a way to not only produce great solutions but also to do great harm.
    FP could be considered as a way to reduce or leave aside some of the worst parts
    of the language and focus on working in a safer, better way; however, due to the
    immense amount of existing JavaScript code, you cannot expect it to facilitate
    large reworkings of the language that would cause most sites to fail. You must
    learn to live with the good and the bad, and simply avoid the latter part.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the language has a broad variety of available libraries that complete
    or extend the language in many ways. In this book, we’ll be focusing on using
    JavaScript on its own, but we will make references to existing, available code.
  prefs: []
  type: TYPE_NORMAL
- en: If we ask whether JavaScript is functional, the answer will be, once again,
    “sorta”. It can be seen as functional because of several features, such as first-class
    functions, anonymous functions, recursion, and closures – we’ll get back to this
    later. On the other hand, it also has plenty of non-FP aspects, such as side effects
    (impurity), mutable objects, and practical limits to recursion. So, when programming
    in a functional way, we’ll be taking advantage of all the relevant, appropriate
    language features, and we’ll try to minimize the problems caused by the more conventional
    parts of the language. In this sense, JavaScript will or won’t be functional,
    depending on your programming style!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use FP, you should decide which language to use; however, opting
    for fully functional languages may not be so wise. Today, developing code isn’t
    as simple as just using a language; you will surely require frameworks, libraries,
    and other sundry tools. If we can take advantage of all the provided tools but
    at the same time introduce FP ways of working in our code, we’ll be getting the
    best of both worlds, regardless of whether JavaScript is functional!
  prefs: []
  type: TYPE_NORMAL
- en: Going functional with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript has evolved through the years, and the version we’ll be using is
    (informally) called JS13, and (formally) ECMAScript 2022, usually shortened to
    ES2022 or ES13; this version was finalized in June 2022\. The previous versions
    were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 1, June 1997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 2, June 1998, which was the same as the previous version, ECMAScript
    3, December 1999, with several new functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5, December 2009 (and no, there never was an ECMAScript 4, because
    it was abandoned)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 5.1, June 2011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 6 (or ES6; later renamed ES2015), June 2015 ECMAScript 7 (also ES7,
    or ES2016), June 2016 ECMAScript 8 (ES8 or ES2017), June 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 9 (ES9 or ES2018), June 2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 10 (ES10 or ES2019), June 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 11 (ES11 or ES2020), June 2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 12 (ES12 or ES2021), June 2021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s ECMA?
  prefs: []
  type: TYPE_NORMAL
- en: ECMA originally stood for European Computer Manufacturers Association, but nowadays,
    the name isn’t considered an acronym anymore. The organization is responsible
    for standards other than JavaScript as well, including JSON, C#, Dart, and others.
    For more details, go to its site at [www.ecma-international.org/](http://www.ecma-international.org/).
  prefs: []
  type: TYPE_NORMAL
- en: You can read the standard language specification at [www.ecma-international.org/publications-and-standards/standards/ecma-262/](http://www.ecma-international.org/publications-and-standards/standards/ecma-262/).
    Whenever we refer to JavaScript in the text without further specification, ES13
    (ES2022) is what is being referred to; however, in terms of the language features
    that are used in this book, if you were just to use ES2015, then you’d mostly
    have no problems with this book.
  prefs: []
  type: TYPE_NORMAL
- en: No browsers fully implement ES13; most provide an older version, JavaScript
    5 (from 2009), with an (always growing) smattering of features from ES6 up to
    ES13\. This will prove to be a problem, but fortunately, a solvable one; we’ll
    get to this shortly. We’ll be using ES13 throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Differences, differences…
  prefs: []
  type: TYPE_NORMAL
- en: There are only a few differences between ES2016 and ES2015, such as the `Array.prototype.includes`
    method and the exponentiation operator, `**`. There are more differences between
    ES2017 and ES2016 – such as `async` and `await`, some string padding functions,
    and more – but they won’t impact our code. We will also be looking at alternatives
    for even more modern additions, such as `flatMap()`, in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to work with JavaScript, let’s start by considering its most
    important features that pertain to our FP goals.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript isn’t a purely functional language, but it has all the features
    that we need for it to work as if it were. The main features of the language that
    we will be using are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see some examples of each one and find out why they will be useful to
    us. Keep in mind, though, that there are more features of JavaScript that we will
    be using; the upcoming sections just highlight the most important features in
    terms of what we will be using for FP.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saying that functions are **first-class objects** (also called **first-class
    entities** or **first-class citizens**) means that you can do everything with
    functions that you can do with other objects. For example, you can store a function
    in a variable, you can pass it to a function, you can print it out, and so on.
    This is really the key to doing FP; we will often be passing functions as parameters
    (to other functions) or returning a function as the result of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have been doing async Ajax calls, then you have already been using this
    feature: a **callback** is a function that will be called after the Ajax call
    finishes and is passed as a parameter. Using jQuery, you could write something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `$.get()` function receives a callback function as a parameter and calls
    it after the result is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: The way to go
  prefs: []
  type: TYPE_NORMAL
- en: This is better solved, in a more modern way, by using promises or `async`/`await`,
    but for the sake of our example, the old way is enough. We’ll be getting back
    to promises, though, in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building
    Better Containers*, when we discuss monads; in particular, see the *Unexpected
    monads –* *promises* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functions can be stored in variables, you could also write something
    like the following. Pay attention to how we use the `doSomething` variable in
    the `$.``get(...)` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be seeing more examples of this in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Recursion** is the most potent tool for developing algorithms and a great
    aid for solving large classes of problems. The idea is that a function can, at
    a certain point, call itself and, when *that* call is done, continue working with
    whatever result it has received. This is usually quite helpful for certain classes
    of problems or definitions. The most often quoted example is the factorial function
    (the factorial of *n* is written as *n!*), as defined for nonnegative integer
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is 0, then *n*! = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *n* is greater than 0, then *n*! = *n* * (*n*-1)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging things
  prefs: []
  type: TYPE_NORMAL
- en: The value of *n!* is the number of ways that you can arrange *n* different elements
    in a row. For example, if you want to place five books in line, you can pick any
    of the five for the first place, and then order the other four in every possible
    way, so 5! = 5*4!. To order those four, you can pick any of them for the first
    place, and then order the other three in every way, so 4! = 4*3!. If you continue
    to work on this example, you’ll end up with 5! = 5*4*3*2*1=120, and in general,
    *n*! is the product of all numbers up to *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be immediately turned into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Recursion will be a great aid for designing algorithms. By using recursion,
    you could do without any `while` or `for` loops – not that we want to do that,
    but it’s interesting that we can! We’ll be devoting the entirety of [*Chapter
    9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, to designing algorithms
    and writing functions recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closures are a way to implement data hiding (with private variables), which
    leads to modules and other nice features. The key concept of closures is that
    when you define a function, it can refer to not only its local variables but also
    to everything outside of the context of the function. We can write a counting
    function that will keep its `count` using a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Even after `newCounter()` exits, the inner function still has access to `count`,
    but that variable is not accessible to any other parts of your code.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a very good example of FP – a function (`nc()`, in this case) isn’t
    expected to return different results when called with the same parameters!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll find several uses for closures, such as **memoization** (see [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, and [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*) and the **module pattern** (see [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, and [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*), among others.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`(parameter, anotherparameter, ...etc) => { statements }` or `(parameter, anotherparameter,
    ...etc) => expression`. The first allows you to write as much code as you want,
    while the second is short for `{ return expression }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite our earlier Ajax example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A new version of the factorial code could be like the following code – the
    only difference is the usage of an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Functions, anonymous
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions are usually called anonymous functions because of their lack
    of a name. If you need to refer to an arrow function, you’ll have to assign it
    to a variable or object attribute, as we did here; otherwise, you won’t be able
    to use it. We’ll learn more about this in the *Arrow functions – the modern way*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out* *with
    Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would probably write `fact2()` as a one-liner – can you see the equivalence
    to our earlier code? Using a ternary operator instead of `if` is quite common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this shorter form, you don’t have to write `return` – it’s implied.
  prefs: []
  type: TYPE_NORMAL
- en: Functions – the lambda way
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, a function such as *x* => 2**x* would be represented as
    λ*x.*2**x*. Although there are syntactical differences, the definitions are analogous.
    Functions with more parameters are a bit more complicated; (*x,y*)=>*x*+*y* would
    be expressed as λ*x*.λ*y*.*x*+*y*. We’ll learn more about this in the *Of lambdas
    and functions* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054), *Starting
    Out with Functions*, and in the *Currying* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,*
    *Transforming Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other small thing to bear in mind: when the arrow function has
    a single parameter, you can omit the parentheses around it. I usually prefer leaving
    them, but I’ve applied a JavaScript beautifier, *Prettier*, to the code, which
    removes them. It’s really up to you whether to include them or not! (For more
    on this tool, check out [github.com/prettier/prettier](http://github.com/prettier/prettier).)
    By the way, my options for formatting were `--print-width 75 -- tab-width` `2
    --no-bracket-spacing`.'
  prefs: []
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The spread `...` operator (see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator))
    lets you expand an expression in places where you would otherwise require multiple
    arguments, elements, or variables. For example, you can replace arguments in a
    function call, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create or join arrays, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It works with objects too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use it to work with functions that expect separate parameters
    instead of an array. Common examples of this would be `Math.min()` and `Math.max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are specifying that `maxArray()` shall receive an array of numbers as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write the following equality since the `.apply()` method requires
    an array of arguments, but `.call()` expects individual arguments, which you can
    get by spreading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A mnemonic for arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have problems remembering what arguments are required by `.apply()`
    and `.call()`, this mnemonic may help: *A is for Array, and C is for Comma*. See
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)
    and [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
    for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread operator helps with writing shorter, more concise code, and
    we will be taking advantage of it. We have seen all of the most important JavaScript
    features that we will be using. Let’s round off this chapter by looking at some
    tools that we’ll be working with.
  prefs: []
  type: TYPE_NORMAL
- en: How do we work with JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is all well and good, but as we mentioned before, it so happens that the
    JavaScript version available almost everywhere isn’t ES13, but rather the earlier
    JS5\. An exception to this is Node.js. It is based on Chrome’s V8 high-performance
    JavaScript engine, which already has several ES13 features available. Nonetheless,
    at the time of writing, ES13 coverage isn’t 100% complete, and there are features
    that you will miss. (Check out [nodejs.org/en/docs/es6/](http://nodejs.org/en/docs/es6/)
    for more on Node.js and v8.) This is surely changing since Internet Explorer is
    fading away (support for it ended in June 2022), having been replaced with Microsoft’s
    Edge browser, which shares Chrome’s engine. In any case, we must still deal with
    older, less powerful engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to be sure of your choices before using any given new feature,
    check out the compatibility table at [kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    (see *Figure 1**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them](img/Figure_1.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The latest JavaScript features may not be widely and fully supported,
    so you’ll have to check before using them
  prefs: []
  type: TYPE_NORMAL
- en: 'For Node.js specifically, check out [node.green/](http://node.green/), which
    takes its data from the Kangax table; see *Figure 1**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Compatibility table specifically for Node.js](img/Figure_1.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Compatibility table specifically for Node.js
  prefs: []
  type: TYPE_NORMAL
- en: So, what can you do if you want to code using the latest version, but the available
    one is an earlier, poorer one? Or what happens if most of your users are using
    older browsers, which don’t support the fancy features you’re keen on using? Let’s
    see some solutions for this.
  prefs: []
  type: TYPE_NORMAL
- en: Using transpilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get out of this availability and compatibility problem, there are a couple
    of transpilers that you can use. Transpilers take your original ES13 code, which
    might use the most modern JavaScript features, and transforms it into equivalent
    JS5 code. It’s a source-to-source transformation, instead of source-to-object
    code that would be used in compilation. You can code using advanced ES13 features,
    but the user’s browsers will receive JS5 code. A transpiler will also let you
    keep up with upcoming versions of the language, despite the time needed by browsers
    to adopt new standards across desktop and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: On word origins
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wonder where the word *transpiler* came from, it is a portmanteau of
    *translate* and *compiler*. There are many such combinations in technological
    speak: *email* (*electronic* and *mail*), *emoticon* (*emotion* and *icon*), *malware*
    (*malicious* and *software*), *alphanumeric* (*alphabetic* and *numeric*), and
    many more.'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the most common transpiler for JavaScript is **Babel** ([babeljs.io/](http://babeljs.io/));
    years ago, we also had **Traceur** ([github.com/google/traceur-compiler](http://github.com/google/traceur-compiler)),
    but that’s not maintained any longer. Two other possibilities are **SWC** ([swc.rs/](http://swc.rs/))
    and **Sucrase** ([sucrase.io/](http://sucrase.io/)); in particular, the latter
    boasts a much faster transpilation speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With tools such as **npm** or **webpack**, it’s fairly easy to configure things
    so that your code will get automatically transpiled and provided to end users.
    You can also carry out transpilation online; see *Figure 1**.3* for an example
    of Babel’s online environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5
    code](img/Figure_1.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The Babel transpiler converts ES13 code into compatible JS5 code
  prefs: []
  type: TYPE_NORMAL
- en: There are specific ways of installing these tools for your programming environment,
    and usually, you won’t have to do it by hand; check out [www.typescriptlang.org/download](http://www.typescriptlang.org/download)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Working online
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some more online tools that you can use to test out your JavaScript
    code. Check out **JSFiddle** ([jsfiddle.net/](http://jsfiddle.net/)), **CodePen**
    ([codepen.io/](http://codepen.io/)), and **JSBin** ([jsbin.com/](http://jsbin.com/)),
    among others. You can see an example of CodePen in *Figure 1**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools](img/Figure_1.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – CodePen lets you try out modern JavaScript code (plus HTML and
    CSS) without requiring any other tools
  prefs: []
  type: TYPE_NORMAL
- en: Using these tools provides a very quick way to try out code or do small experiments
    – and I can truly vouch for this since I’ve tested much of the code in this book
    in this way!
  prefs: []
  type: TYPE_NORMAL
- en: A step further – TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous editions of this book, we went with straight JavaScript. Still,
    in the years since, Microsoft’s **TypeScript** ([www.typescriptlang.org/](http://www.typescriptlang.org/)),
    a superset of the language that is itself compiled into JavaScript, has gained
    a lot of following, is now standard with many frameworks, and you can use both
    for frontend and backend code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of TypeScript is the ability to add (optional) static type
    checks to JavaScript, which helps detect programming errors at compile time. But
    beware: as with Babel, not all of ES13 will be available. However, it’s entirely
    sufficient for our purposes, allowing us to be more careful with coding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most statistics about programming language popularity rank TypeScript in the
    top 10; *Figure 1**.5* (from [spectrum.ieee.org/top-programming-languages-2022](http://spectrum.ieee.org/top-programming-languages-2022))
    confirms this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum](img/Figure_1.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Programming language popularity in 2022 according to IEEE Spectrum
  prefs: []
  type: TYPE_NORMAL
- en: Going to the source
  prefs: []
  type: TYPE_NORMAL
- en: Despite using TypeScript, in the rest of this book, we’ll keep referring to
    JavaScript, which is, after all, the language that is executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform type checks by using Facebook’s **Flow** ([flow.org/](http://flow.org/)).
    However, there’s more support for using external libraries with TypeScript than
    with Flow. Also, the tooling and installation for development are simpler for
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring types?
  prefs: []
  type: TYPE_NORMAL
- en: There’s a proposal (that may go nowhere – be warned!) to allow JavaScript to
    process (by ignoring) types, so you would be able to run TypeScript directly,
    with no preprocessing or transpiling of any kind. For more on this, go to [tc39.es/proposal-type-annotations/](http://tc39.es/proposal-type-annotations/).
  prefs: []
  type: TYPE_NORMAL
- en: It should be made clear that TypeScript is more than just a type checker; it’s
    a language on its own (OK, it's very similar to JavaScript, but still…). For example,
    it adds interfaces, decorators, enumerated types, and more to the language, so
    you can use such features that are typical in other languages. In any case, if
    you don’t care for TypeScript, you can just ignore the types-related syntax, and
    then you’ll have plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is available via online tools, and you can also test it online on
    their playground ([www.typescriptlang.org/play/](http://www.typescriptlang.org/play/)).
    You can set options to be more or less strict with data type checks, and you can
    also run your code on the spot; see *Figure 1**.6* for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – You can check and transpile your code online, on TypeScript’s
    website](img/Figure_1.6_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – You can check and transpile your code online, on TypeScript’s website
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, in the *Specifying data types* section of [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will consider a formal type system for FP languages
    (not just JavaScript) and we’ll find out that our TypeScript work has allayed
    most difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final admission: at times, TypeScript may seem more of a hindrance than a
    help when you have to deal with complex data typing expressions. (Updating all
    the code in this book to TypeScript sometimes led me to doubt my sanity in using
    it!) However, in the long run, code written in TypeScript is less prone to bugs,
    because its static type checks detect and avoid many common errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will also touch on testing, which is, after all, one of FP’s main advantages.
    In previous editions of this book, we went with **Jasmine** ([jasmine.github.io/](http://jasmine.github.io/)),
    but now, we’ve changed to Facebook’s **Jest** ([jestjs.io/](http://jestjs.io/))
    – which is built on top of Jasmine!
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest has grown in popularity due to its ease of use and broad applicability:
    you can test frontend and backend code equally well, with little configuration.
    (See [jestjs.io/docs/getting-started](http://jestjs.io/docs/getting-started) for
    its installation and configuration.) We won’t be writing tests for every single
    piece of code in this book, but while following the ideas of **test-driven development**
    (**TDD**), we’ll often do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the basics of FP, a bit of its history, its advantages
    (and also some possible disadvantages, to be fair), why we can apply it in JavaScript
    (which isn’t usually considered a functional language), and what tools we’ll need
    to go through the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19301_02.xhtml#_idTextAnchor037), *Thinking Functionally*,
    we’ll go over an example of a simple problem, look at it in common ways, and end
    by solving it in a functional manner and analyzing the advantages of our method.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1.1 **TypeScript, please!** Let’s keep our promise: convert the JavaScript
    examples provided in this chapter into TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: '1.2 **Classes as first-class objects**: We learned that functions are first-class
    objects, but did you know that classes also are? (Though, of course, speaking
    of classes as objects does sound weird.) Look at the following example and see
    what makes it tick! Be careful: there’s some purposefully weird code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '1.3 **Climbing factorial**: Our implementation of a factorial starts by multiplying
    by *n*, then by *n*-1, then *n*-2, and so on in what we could call a downward
    fashion. Can you write a new version of the factorial function that will loop
    upwards?'
  prefs: []
  type: TYPE_NORMAL
- en: '1.4 **Factorial errors**: Factorials, as we defined them, should only be calculated
    for non-negative integers. However, the function that we wrote in the *Recursion*
    section doesn’t check whether its argument is valid. Can you add the necessary
    checks? Try to avoid repeated, redundant tests!'
  prefs: []
  type: TYPE_NORMAL
- en: '1.5 **Factorial testing**: Write complete tests for the function in the previous
    question. Try to achieve 100% coverage.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 `newCounter()` to half its length. Can you see how?
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 `newCounter()` function?
  prefs: []
  type: TYPE_NORMAL
