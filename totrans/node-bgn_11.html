<html><head></head><body>
		<div><h1 id="_idParaDest-292" class="chapter-number"><a id="_idTextAnchor300"/>11</h1>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor301"/>Building a Web Application Project from Scratch</h1>
			<p>In this chapter, we will start a new project that will be the base for the next chapters. We will apply all the lessons learned from the previous chapters and we will put into practice asynchronous programming, Node.js core libraries, external modules, testing, and all the concepts that we learned about regarding REST APIs.</p>
			<p>This project will evolve, so we will iterate over the project, adding new features and new tests, so you can experience the full development cycle of a real-world application using Node.js.</p>
			<p>In this chapter, we will use the file system library to store the changes we produce in the project while managing operations from the REST API we create. In the next chapter, we will learn how to connect the web application to MongoDB, but we will do a migration using the tests that we built in this chapter.</p>
			<p>At the end of the book, we will deploy this project in several ways, and we will expose our application to the internet and to real users.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How to start an Express application including UI and API REST</li>
				<li>How to test an Express application using Supertest and Jest</li>
				<li>How to include data stores in our projects</li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor302"/>Technical requirements</h1>
			<p>The coode files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a></p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/JYWmvQrGu78">https://youtu.be/JYWmvQrGu78</a></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor303"/>The project Kickoff</h1>
			<p>This is so <a id="_idIndexMarker653"/>exciting! We are going to apply all the knowledge that we have learned in the previous chapters to build a CRUD REST API with Express. We will use the file system to store the data, and we will use the most common Express middleware to build a robust API.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor304"/>The project goal</h2>
			<p>We are going to build a microblogging platform called “Whispering,” where users can create, read, update, and delete whispers (short posts).</p>
			<h3>Preview</h3>
			<p>While we <a id="_idIndexMarker654"/>will focus on the backend, we will have a basic frontend included to test the API. So, we will start working with a simple app skeleton that we will evolve over the next chapters.</p>
			<div><div><img src="img/B21678_11_1.jpg" alt="Figure 11.1 – Preview of the home page from the project in the web browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Preview of the home page from the project in the web browser</p>
			<h3>Requirements</h3>
			<p>The requirements <a id="_idIndexMarker655"/>will evolve over the next chapters, but for now, we will focus on the following:</p>
			<ul>
				<li>Adding a welcome landing page using a template engine</li>
				<li>Serving static files</li>
				<li>Adding a CRUD REST API with Express</li>
				<li>Using the file system to store the data in JSON format</li>
				<li>Adding tests to ensure that the API is working as expected</li>
			</ul>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor305"/>Starting with the first step</h2>
			<p>To start <a id="_idIndexMarker656"/>working on the project, we need to download the project from  <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <code>step0</code> folder. Now, enter the folder and feel free to explore the code. You will see that we have a basic skeleton with the following structure:</p>
			<pre class="source-code">
|____.babelrc
|____db.json
|____server.js
|____store.js
|____jest.config.js
|____tests
| |____server.test.js
| |____fixtures.js
| |____store.test.js
| |____utils.js
|____index.js
|____public
| |____index.html
| |____styles.css
| |____app.js
| |____people.jpg
|____package-lock.json
|____package.json
|____.nvmrc
|____views
| |____about.ejs</pre>			<p>Now that <a id="_idIndexMarker657"/>we are clear about the project objective, let’s start building the application. In the next section, we will start building the application by adding the dependencies, the basic structure, the stores, and other things in order to build a solid REST API that can be used in the next chapters.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor306"/>Building a REST API</h1>
			<p>Now that we have a basic understanding of Express, let’s build a REST API for the microblogging <a id="_idIndexMarker658"/>platform. We will start with the basic CRUD operations and then we will add more features.</p>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, we learned about the principles of building RESTful APIs. We will apply them now. As the platform is called “whispering” and the users will be able to create, read, update, and delete whispers, we will have the following endpoints:</p>
			<ul>
				<li><code>GET /api/v1/whisper</code>: Get all the whispers</li>
				<li><code>GET /api/v1/whisper/:id</code>: Get a whisper by ID</li>
				<li><code>POST /api/v1/whisper</code>: Create a new whisper</li>
				<li><code>PUT /api/v1/whisper/:id</code>: Update a whisper by ID</li>
				<li><code>DELETE /api/v1/whisper/:id</code>: Delete a whisper by ID</li>
			</ul>
			<p>In this case, we used the prefix <code>/api/v1/</code> because we are building the first version of the API. It is a good practice to version the API in the URL because, in the future, you may want to introduce breaking changes, and it will be hard for your consumers to adapt to the new changes if you don’t version the API.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor307"/>Adding the routes</h2>
			<p>As the <a id="_idIndexMarker659"/>first step, let’s add the dependencies:</p>
			<pre class="console">
npm install express@4 body-parser@1</pre>			<p>Let’s start by adding the routes to the <code>server.js</code> file and configure Express:</p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
const app = express()
app.use(bodyParser.json())
app.get('/api/v1/whisper', (req, res) =&gt; {
    res.json([])
})
app.get('/api/v1/whisper/:id', (req, res) =&gt; {
    const id = parseInt(req.params.id)
    res.json({ id })
})
app.post('/api/v1/whisper', (req, res) =&gt; {
    res.status(201).json(req.body)
})
app.put('/api/v1/whisper/:id', (req, res) =&gt; {
  //const id = parseInt(req.params.id)
  res.sendStatus(200)
})
app.delete('/api/v1/whisper/:id', (req, res) =&gt; {
    res.sendStatus(200)
})
export { app }</pre>			<p>We created the basic routes for the CRUD operations, and we are returning a JSON response with <a id="_idIndexMarker660"/>the data that we received in the request. This time, we made a little change, and we will export the app object so we can use it in the tests later. Now, let’s initialize the server in the <code>index.js</code> file:</p>
			<pre class="source-code">
import { app } from "./server.js";
const port = 3000
app.listen(port, () =&gt; {
    console.log(`Running in http://localhost:${port}`)
})</pre>			<p>Now let’s add the npm scripts to run the application in the <code>package.json</code> file:</p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js"
    }
}</pre>			<h2 id="_idParaDest-300"><a id="_idTextAnchor308"/>Adding the stores</h2>
			<p>As this is a <a id="_idIndexMarker661"/>simple application, we will use the file system to store the data. We will create a <code>store.js</code> file and we will add the following functions:</p>
			<pre class="source-code">
import fs from 'node:fs/promises'
import path from 'node:path'
const filename = path.join(process.cwd(), 'db.json')
const saveChanges = data =&gt; fs.writeFile(filename, JSON.stringify(data))
const readData = async () =&gt; {
    const data = await fs.readFile(filename, 'utf-8')
    return JSON.parse(data)
}
const getAll = readData
const getById = async (id) =&gt; {
    const data = await readData()
    return data.find(item =&gt; item.id === id)
}
const create = async (message) =&gt; {
    const data = await readData()
    const newItem = { message, id: data.length +1}
    await saveChanges(data.concat([newItem]))
    return newItem
}
const updateById = async (id, message) =&gt; {
    const data = await readData()
    const newData = data.map(current =&gt; {
        if(current.id === id) {
            return { ...current, message }
        }
        return current
    })
    await saveChanges(newData)
}
const deleteById = async id =&gt; {
    const data = await readData()
    await saveChanges(data
.filter(current =&gt; current.id !== id)
    )
}
export { getAll, getById, create, updateById, deleteById }</pre>			<p>Basically, we are using the file system to store the data in a JSON file. We are using <code>saveChanges</code> to save the data and <code>readData</code> to read the data.</p>
			<p>Then we <a id="_idIndexMarker662"/>have the basic CRUD operations defined in the functions <code>getAll</code>, <code>getById</code>, <code>create</code>, and <code>updateById</code>.</p>
			<p>Now, let’s add the tests for the store. As the first step, let’s add the dependencies, <code>npm install -D jest@29 @babel/preset-env@7</code>, and then let’s add the skeleton for the tests to the <code>tests/store.test.js</code> file:</p>
			<pre class="source-code">
import { getAll, getById, create, updateById, deleteById } from '../store.js'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
const dbPath = join(process.cwd(), 'db.json')
const restoreDb = () =&gt; writeFileSync(dbPath, JSON.stringify([]))
const populateDb = (data) =&gt; writeFileSync(dbPath, JSON.stringify(data))
const fixtures = [{ id: 1, message: 'test' }, { id: 2, message: 'hello world' }]
const inventedId = 12345
const existingId = fixtures[0].id
describe('store', () =&gt; {
    beforeEach(() =&gt; populateDb(fixtures))
    afterAll(restoreDb)
    // Here we will be the tests
})</pre>			<p>In <a href="B21678_08.xhtml#_idTextAnchor218"><em class="italic">Chapter 8</em></a>, we learned the principles of testing. One of the principles is that the tests should be independent, and that means that the tests should not depend on the state of previous tests and that we can run them as many times as we want and the result should not change.</p>
			<p>As we are <a id="_idIndexMarker663"/>using an external file to store the data, we need to make sure that the data is in the initial state before each test. So, we are using the <code>beforeEach</code> function to populate the database with the fixtures and the <code>afterAll</code> function to restore the database to the initial state. This way, we can make sure that the tests always start from the same state.</p>
			<p>Also, we added some fixtures and variables that we will use in the tests when we need to create, update, or delete data. This will help us to avoid hardcoding values and make the tests more readable.</p>
			<p>Now, let’s add the tests for the <code>getAll</code> function:</p>
			<pre class="source-code">
describe('getAll', () =&gt; {
    it("Should return an empty array when there's no data", async () =&gt; {
        restoreDb()
        const data = await getAll()
        expect(data).toEqual([])
    })
    it('Should return an array with one item when there is one item', async () =&gt; {
        const data = await getAll()
        expect(data).toEqual(fixtures)
    })
})</pre>			<p>We have two test cases only – when the database is empty and when the database has data. In both cases, we are expecting an array.</p>
			<p>Now, let’s add the tests for the <code>getById</code> function:</p>
			<pre class="source-code">
describe('getById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async () =&gt; {
        const item = await getById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should return the item with the given id', async () =&gt; {
        const item = await getById(fixtures[0].id)
        expect(item).toEqual(fixtures[0])
    })
})</pre>			<p>We have <a id="_idIndexMarker664"/>two test cases only – when we match an item and when we don’t match an item.</p>
			<p>Now, let’s add the tests for the <code>create</code> function:</p>
			<pre class="source-code">
describe('create', () =&gt; {
    it('Should return the created item', async () =&gt; {
        const newItem = { id: fixtures.length + 1, message: 'test 3' }
        const item = await create(newItem.message)
        expect(item).toEqual(newItem)
    })
    it('Should add the item to the db', async () =&gt; {
        const newItem = { id: fixtures.length + 1, message: 'test 3' }
        const { id } = await create(newItem.message)
        const item = await getById(id)
        expect(item).toEqual(newItem)
    })
})</pre>			<p>In this case, we expect the item to be returned including the ID when it is returned from the function, and we expect the item to be added to the database.</p>
			<p>Let’s add <a id="_idIndexMarker665"/>the tests for the <code>updateById</code> function:</p>
			<pre class="source-code">
describe('updateById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async() =&gt; {
        const item = await updateById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should not return the updated item', async () =&gt; {
        const updatedItem = { id: existingId, message: 'updated' }
        const item = await updateById(updatedItem.id, updatedItem.message)
        expect(item).toBeUndefined()
    })
    it('Should update the item in the db', async () =&gt; {
        const updatedItem = { id: existingId, message: 'updated' }
        await updateById(updatedItem.id, updatedItem.message)
        const item = await getById(existingId)
        expect(item).toEqual(updatedItem)
    })
})</pre>			<p>In this case, we expect the item to be updated in the database only if it exists, but not to be returned from the function at all.</p>
			<p>Let’s add <a id="_idIndexMarker666"/>the last tests for the <code>deleteById</code> function:</p>
			<pre class="source-code">
describe('deleteById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async () =&gt; {
        const item = await deleteById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should not return the deleted item', async () =&gt; {
        const item = await deleteById(existingId)
        expect(item).toBeUndefined()
    })
    it('Should delete the item from the db', async () =&gt; {
        await deleteById(existingId)
        const items = await getAll()
        expect(items).toEqual(fixtures.filter(item =&gt; item.id !== existingId))
    })
})</pre>			<p>We expect a similar behavior as in the <code>updateById</code> function. The item should be deleted from the database only if it exists, and the item is not returned. Now, let’s include the test scripts in the <code>package.json</code> file:</p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js",
        "test": "jest",
        "test:coverage": "jest --coverage"
    }
}</pre>			<p>Run the <a id="_idIndexMarker667"/>tests with <code>npm run test</code>. Your output should be similar to this:</p>
			<div><div><img src="img/B21678_11_2.jpg" alt="Figure 11.2 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Terminal screenshot</p>
			<p>Our first storage is working, and fully tested. Now, let’s just finish by adding a linter to the project. First, install the linter with <code>npm i -D standard@17</code> and then update the <code>package.json</code> scripts:</p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js",
        "test": "jest",
        "test:coverage": "jest --coverage",
        "lint": "standard",
        "lint:fix": "standard --fix"
    }
}</pre>			<p>Now, you can <a id="_idIndexMarker668"/>run the linter with <code>npm run lint</code> and fix the errors with <code>npm run lint:fix</code>. Sometimes you might need to fix the errors manually, but most of the time the linter will fix them for you.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor309"/>Adding the static files</h2>
			<p>Now, let’s add the static files to the application. Basically, in the <code>public</code> folder, we have <a id="_idIndexMarker669"/>several files that we want to serve to the client, such as the <code>index.html</code>, <code>style.css</code>, and <code>app.js</code> files. So, let’s add the following code to the <code>server.js</code> file:</p>
			<pre class="source-code">
const app = express()
app.use(express.static('public'))
app.use(bodyParser.json())</pre>			<p>Now if we start the server with <code>npm run start</code>, and you go to <code>http://localhost:3000/styles.css</code>, you will see the content of the <code>styles.css</code> file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Until we finish this chapter, the URL <code>http://localhost:3000</code> might not work as expected, as the backend is not finished yet.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor310"/>Adding the templates</h2>
			<p>In this <a id="_idIndexMarker670"/>project we will use the server render approach to handle certain parts of the application. So we will install the <code>ejs</code> template engine:</p>
			<pre class="console">
npm i ejs@3</pre>			<p>Let’s import the store functions in the <code>server.js</code> file:</p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
<strong class="bold">import { getAll, getById, create, updateById, deleteById } from './store.js'</strong>
const app = express()</pre>			<p>Then, register <a id="_idIndexMarker671"/>the template engine in the <code>server.js</code> file:</p>
			<pre class="source-code">
app.use(bodyParser.json())
<strong class="bold">app.set('view engine', 'ejs')</strong>
app.get('/api/v1/whisper', async (req, res) =&gt; {
    const whispers = await getAll()
    res.json(whispers)
})</pre>			<p>Finally, we will create a route, <code>about</code>, that will render the <code>views/about.ejs</code> template and we will provide the whispers to the template:</p>
			<pre class="source-code">
app.set('view engine', 'ejs')
<strong class="bold">app.get('/about', async (req, res) =&gt; {</strong>
<strong class="bold">    const whispers = await getAll()</strong>
<strong class="bold">    res.render('about', { whispers })</strong>
<strong class="bold">})</strong>
app.get('/api/v1/whisper', async (req, res) =&gt; {/*...*/})</pre>			<p>Now, let’s start the server with <code>npm run start</code> and go to <code>http://localhost:3000/about</code> and you will see the template rendered.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <code>step1</code> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs more easily.</p>
			<p>In the <a id="_idIndexMarker672"/>next section, we will continue building the REST API by adding tests. Adding tests to the REST API is very important because it will allow us to make sure that the API is working as expected and it will allow us to iterate over it in the next chapters more easily.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor311"/>Testing with supertest</h1>
			<p>Now, it is time <a id="_idIndexMarker673"/>to make sure that our REST API is working as expected. We will learn in this section how to build solid tests while using Express.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor312"/>Adding stores to the server</h2>
			<p>We will <a id="_idIndexMarker674"/>refactor each route to use the store functions. Let’s start with the <code>GET /</code><code>api/v1/whisper</code> route:</p>
			<pre class="source-code">
app.get('/api/v1/whisper', async (req, res) =&gt; {
    <strong class="bold">const whispers = await getAll()</strong>
<strong class="bold">    res.json(whispers</strong>)
})</pre>			<p>Basically, we are using the <code>getAll</code> function to get all the whispers and we are returning them in the response. Now, let’s refactor the <code>GET /</code><code>api/v1/whisper/:id</code> route:</p>
			<pre class="source-code">
app.get('/api/v1/whisper/:id', async (req, res) =&gt; {
    <strong class="bold">const id = parseInt(req.params.id)</strong>
<strong class="bold">    const whisper = await getById(id)</strong>
<strong class="bold">    if (!whisper) {</strong>
<strong class="bold">        res.sendStatus(404)</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">        res.json(whisper)</strong>
<strong class="bold">    }</strong>
})</pre>			<p>In this case, we will return a 404 status code if the whisper doesn’t exist, and we will return the <a id="_idIndexMarker675"/>whisper if it exists. Now, let’s refactor the <code>POST /</code><code>api/v1/whisper</code> route:</p>
			<pre class="source-code">
app.post("/api/v1/whisper", async (req, res) =&gt; {
  <strong class="bold">const { message } = req.body;</strong>
<strong class="bold">  if (!message) {</strong>
<strong class="bold">    res.sendStatus(400);</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    const whisper = await create(message);</strong>
<strong class="bold">    res.status(201).json(whisper);</strong>
<strong class="bold">  }</strong>
});</pre>			<p>In this case, we are validating that the message is not empty in the request body, returning a 400 status code in those cases. If the creation was successful, we return the whisper details. Now, let’s refactor the <code>PUT /</code><code>api/v1/whisper/:id</code> route:</p>
			<pre class="source-code">
app.put('/api/v1/whisper/:id', async (req, res) =&gt; {
    <strong class="bold">const { message } = req.body</strong>
<strong class="bold">    const id = parseInt(req.params.id)</strong>
<strong class="bold">    if(!message) {</strong>
<strong class="bold">        res.sendStatus(400)</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">        const whisper = await getById(id);</strong>
<strong class="bold">        if (!whisper) {</strong>
<strong class="bold">            res.sendStatus(404);</strong>
<strong class="bold">        } else {</strong>
<strong class="bold">            await updateById(id, message);</strong>
<strong class="bold">            res.sendStatus(200);</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<code>POST /api/v1/whisper</code> and we validate <a id="_idIndexMarker676"/>that the whisper exists before updating it. Now, let’s refactor the <code>DELETE /</code><code>api/v1/whisper/:id</code> route:</p>
			<pre class="source-code">
app.delete('/api/v1/whisper/:id', async (req, res) =&gt; {
<strong class="bold">    const id = parseInt(req.params.id)</strong>
<strong class="bold">    const whisper = await getById(id)</strong>
<strong class="bold">    if(!whisper) {</strong>
<strong class="bold">        res.sendStatus(404)</strong>
<strong class="bold">        return</strong>
<strong class="bold">    }</strong>
<strong class="bold">    await deleteById(id)</strong>
<strong class="bold">    res.sendStatus(200)</strong>
<strong class="bold">})</strong></pre>			<p>In this case, we validate that the whisper exists before deleting it. Now, let’s add the tests for the routes.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor313"/>Creating test utils</h2>
			<p>Before we start adding the tests, there is some code that we can reuse between the test files, such as <a id="_idIndexMarker677"/>the fixtures and the functions to populate and restore the database. So, let’s do a little refactoring first.</p>
			<p>As the first step, let’s create a file called <code>fixtures.js</code> in the <code>tests</code> folder, and let’s add the following content:</p>
			<pre class="source-code">
const whispers = [{ id: 1, message: 'test' }, { id: 2, message: 'hello world' }]
const inventedId = 12345
const existingId = whispers[0].id
export {
    whispers,
    inventedId,
    existingId
}</pre>			<p>Then, create a file called <code>utils.js</code> in the <code>tests</code> folder, and let’s add the following content:</p>
			<pre class="source-code">
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
const dbPath = join(process.cwd(), 'db.json')
const restoreDb = () =&gt; writeFileSync(dbPath, JSON.stringify([]))
const populateDb = (data) =&gt; writeFileSync(dbPath, JSON.stringify(data))
export { restoreDb, populateDb }</pre>			<p>Now, let’s refactor the <code>store.test.js</code> file to use the new files:</p>
			<pre class="source-code">
import { getAll, getById, create, updateById, deleteById } from '../store.js'
<strong class="bold">import { restoreDb, populateDb } from './utils.js'</strong>
<strong class="bold">import { whispers, inventedId, existingId } from './fixtures.js'</strong>
describe('store', () =&gt; {
    //...
})</pre>			<p>Also, find and <a id="_idIndexMarker678"/>replace the <code>fixtures</code> variable with <code>whispers</code> in the tests.</p>
			<p>Now you can run the tests with <code>npm run test</code> and you will see that the tests are passing:</p>
			<div><div><img src="img/B21678_11_3.jpg" alt="Figure 11.3 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Terminal screenshot</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor314"/>Adding server tests</h2>
			<p>Now, let’s <a id="_idIndexMarker679"/>add the tests for the routes. In this case, we will <a id="_idIndexMarker680"/>use supertest (<a href="https://www.npmjs.com/package/supertest">https://www.npmjs.com/package/supertest</a>) to test the routes. As the first step, let’s install the new dependency:</p>
			<pre class="console">
npm i -D supertest@6</pre>			<h3>Defining the tests</h3>
			<p>You can use <code>it.todo</code> to mark the tests that you need to add. This way, you can focus on the <a id="_idIndexMarker681"/>description of the tests and not on the implementation details. So, let’s create the <code>tests/server.test.js</code> file with the following content:</p>
			<pre class="source-code">
import supertest from 'supertest'
import { app } from '../server'
import { restoreDb, populateDb } from './utils.js'
import { whispers, inventedId, existingId } from './fixtures.js'
import { getById } from '../store'
describe('Server', () =&gt; {
    beforeEach(() =&gt; populateDb(whispers))
    afterAll(restoreDb)
    describe("GET /api/v1/whisper", () =&gt; {
        it.todo("Should return an empty array when there's no data")
        it.todo("Should return all the whispers")
    })
    describe("GET /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a whisper details")
    })
    describe("POST /api/v1/whisper", () =&gt; {
        it.todo("Should return a 400 when the body is empty")
        it.todo("Should return a 400 when the body is invalid")
        it.todo("Should return a 201 when the whisper is created")
    })
    describe("PUT /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 400 when the body is empty")
        it.todo("Should return a 400 when the body is invalid")
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a 200 when the whisper is updated")
    })
    describe("DELETE /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a 200 when the whisper is deleted")
    })
})</pre>			<p>Run the tests with the <code>npm run </code><code>test</code> command:</p>
			<div><div><img src="img/B21678_11_4.jpg" alt="Figure 11.4 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Terminal screenshot</p>
			<p>You will <a id="_idIndexMarker682"/>see that the previous tests pass, and the new tests are marked as <em class="italic">todo</em>. This is a good practice to keep track of the tests that you need to add, and it does not break the test suite.</p>
			<h3>Adding the tests with supertest</h3>
			<p>Basically, we will <a id="_idIndexMarker683"/>use supertest to make requests <a id="_idIndexMarker684"/>to the server and we will validate the response. Let’s start with the <code>GET /api/v1/whisper</code> route. Let’s replace the <code>it.todo</code> tests with the following code:</p>
			<pre class="source-code">
describe("GET /api/v1/whisper", () =&gt; {
    it("Should return an empty array when there's no data", async () =&gt; {
        await restoreDb() // empty the db
        const response = await supertest(app).get("/api/v1/whisper")
        expect(response.status).toBe(200)
        expect(response.body).toEqual([])
    })
    it("Should return all the whispers", async () =&gt; {
        const response = await supertest(app).get("/api/v1/whisper")
        expect(response.status).toBe(200)
        expect(response.body).toEqual(whispers)
    })
})</pre>			<p>In each <a id="_idIndexMarker685"/>request, we check that the status code and <a id="_idIndexMarker686"/>the response payload are correct. Now, let’s add the tests for the <code>GET /</code><code>api/v1/whisper/:id</code> route:</p>
			<pre class="source-code">
describe("GET /api/v1/whisper/:id", () =&gt; {
    it("Should return a 404 when the whisper doesn't exist", async () =&gt; {
        const response = await supertest(app).get(`/api/v1/whisper/${inventedId}`)
        expect(response.status).toBe(404)
    })
    it("Should return a whisper details", async () =&gt; {
        const response = await supertest(app).get(`/api/v1/whisper/${existingId}`)
        expect(response.status).toBe(200)
        expect(response.body).toEqual(whispers.find(w =&gt; w.id === existingId))
    })
})</pre>			<p>As you can see, the tests are very similar to the ones we did for <code>storage.test.js</code>. Now, let’s add the tests for the <code>POST /</code><code>api/v1/whisper</code> route.</p>
			<p>We will start by adding the parent description for the route:</p>
			<pre class="source-code">
describe("POST /api/v1/whisper", () =&gt; {
    // it("....")
})</pre>			<p>All the tests will be added inside the <code>describe</code> function. So, let’s define all the scenarios that we want to cover in the tests:</p>
			<p>We want <a id="_idIndexMarker687"/>to be sure that we return a 400 status <a id="_idIndexMarker688"/>code when the request does not include a body:</p>
			<pre class="source-code">
it("Should return a 400 when the body is empty",
async () =&gt; {
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 400 status code when the request does not include a proper body, for example, when some required properties are missing:</p>
			<pre class="source-code">
it("Should return a 400 when the body is invalid",
async () =&gt; {
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({invented: "This is a new whisper"})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 201 status and the details of the new whisper when the payload in the request is correct. Also, we want to check that the whisper was properly stored in the database:</p>
			<pre class="source-code">
it("Should return a 201 when the whisper is created",
async () =&gt; {
  const newWhisper = {
id: whispers.length + 1,
message: "This is a new whisper"
  }
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({message: newWhisper.message})
  // HTTP Response
  expect(response.status).toBe(201)
  expect(response.body).toEqual(newWhisper)
  // Database changes
  const storedWhisper = await getById(newWhisper.id)
  expect(storedWhisper).toStrictEqual(newWhisper)
})</pre>			<p>As you can see, when we created a new whisper we also validated that the whisper was added to <a id="_idIndexMarker689"/>the database. This is because these tests are <a id="_idIndexMarker690"/>integration tests and we want to make sure that the changes are recorded in the <em class="italic">database</em> as well.</p>
			<p>Now, let’s add the tests for the <code>PUT /api/v1/whisper/:id</code> route. We will start by adding the parent description for the route:</p>
			<pre class="source-code">
describe("PUT /api/v1/whisper/:id", () =&gt; {
    // it("....")
})</pre>			<p>All the tests will be added inside the <code>describe</code> function. So, let’s define all the scenarios that we want to cover in the tests:</p>
			<p>We want to be sure that we return a 400 status code when the request does not include a body:</p>
			<pre class="source-code">
it("Should return a 400 when the body is empty",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({})
  expect(response.status).toBe(400)
})</pre>			<p>We want <a id="_idIndexMarker691"/>to be sure that we return a 400 status <a id="_idIndexMarker692"/>code when the request does not include a proper body, for example, when some required properties are missing:</p>
			<pre class="source-code">
it("Should return a 400 when the body is invalid",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({invented: "This a new field"})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 404 status code when the request is targeting a non-existent whisper:</p>
			<pre class="source-code">
it("Should return a 404 when the whisper doesn't exist",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${inventedId}`)
    .send({message: "Whisper updated"})
  expect(response.status).toBe(404)
})</pre>			<p>We want to be sure that we return a 200 status when the payload and the target are correct. Also, we want to check that the whisper was properly updated in the database:</p>
			<pre class="source-code">
it("Should return a 200 when the whisper is updated",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({message: "Whisper updated"})
  expect(response.status).toBe(200)
  // Database changes
  const storedWhisper = await getById(existingId)
  expect(storedWhisper).toStrictEqual({id: existingId, message: "Whisper updated"})
})</pre>			<p>Finally, let’s <a id="_idIndexMarker693"/>add the tests for the <code>DELETE /api/v1/whisper/:id</code> route. We will start by adding the parent description for the route:</p>
			<pre class="source-code">
describe(" DELETE /api/v1/whisper/:id", () =&gt; {
    // it("....")
})</pre>			<p>All the <a id="_idIndexMarker694"/>tests will be added inside the <code>describe</code> function. So, let’s define all the scenarios that we want to cover in the tests:</p>
			<p>We want to be sure that we return a 404 status code when the request is targeting a non-existent whisper:</p>
			<pre class="source-code">
it("Should return a 404 when the whisper doesn't exist", async () =&gt; {
  const response = await supertest(app)
    .delete(`/api/v1/whisper/${inventedId}`)
  expect(response.status).toBe(404)
})</pre>			<p>We want <a id="_idIndexMarker695"/>to be sure that we return a 200 status <a id="_idIndexMarker696"/>code when the request is targeting a valid whisper. Also, we want to check that the whisper was properly removed from the database:</p>
			<pre class="source-code">
it("Should return a 200 when the whisper is deleted", async () =&gt; {
  const response = await supertest(app)
    .delete(`/api/v1/whisper/${existingId}`)
  expect(response.status).toBe(200)
  // Database changes
  const storedWhisper = await getById(existingId)
  expect(storedWhisper).toBeUndefined()
})</pre>			<p>Now, you can run the tests with <code>npm run test</code> and you will see that the tests are passing:</p>
			<div><div><img src="img/B21678_11_5.jpg" alt="Figure 11.5 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Terminal screenshot</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <code>step2</code> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs more easily.</p>
			<p>In the next section, we will review the final result and we will see how to use the application and what we are planning to do in the next chapters.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor315"/>Reviewing the final result of the project</h1>
			<p>At this <a id="_idIndexMarker697"/>point, you should have a fully functional REST API with Express and if your tests are passing, you can start using the application.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor316"/>The about page</h2>
			<p>If you go to <code>http://localhost:3000/about</code>, you will see the about page:</p>
			<div><div><img src="img/B21678_11_6.0.jpg" alt="Figure 11.6 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Web browser screenshot</p>
			<p>This page <a id="_idIndexMarker698"/>was served using the server render approach, and we are using the EJS template engine to render the page. We are using the whispers data from the database to render the page. The text <em class="italic">Currently there are 3 whispers available</em> is dynamic text that will change depending on the number of whispers in the database.</p>
			<p>You can see the reference in the <code>views/about.ejs</code> file:</p>
			<pre class="source-code">
&lt;p&gt;Currently there are &lt;%= whispers.length %&gt; whispers available&lt;/p&gt;</pre>			<h3>Web interface</h3>
			<p>The web interface is a simple page where you can create, update, and delete whispers. You can <a id="_idIndexMarker699"/>access the web interface at <code>http://localhost:3000</code>. It will start with an empty list of whispers. In my case, I have three whispers in the database, so I will see the following page:</p>
			<div><div><img src="img/B21678_11_7.0.jpg" alt="Figure 11.7 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Web browser screenshot</p>
			<p>In order to make the frontend source code more readable, I used plain JavaScript to make the requests to the API and old browser APIs such as <code>prompts</code> and <code>confirms</code> to interact with the user. You can see the source code in the <code>public/app.js</code> file. For a production application, you should avoid these browser APIs as they are quite limited and implement a solution that works on all devices using UI elements that are properly integrated. Also, you will need to handle errors and loading states. For larger projects, it is quite common <a id="_idIndexMarker700"/>to use UI libraries such as tailwind (<a href="https://tailwindcss.com/">https://tailwindcss.com/</a>) or frameworks <a id="_idIndexMarker701"/>such as Vue (<a href="https://vuejs.org/">https://vuejs.org/</a>).</p>
			<h3>Adding whispers</h3>
			<p>It is possible <a id="_idIndexMarker702"/>to add whispers to the list. Just click on the <strong class="bold">Spread a whisper</strong> button and you will see a prompt asking for the message of the whisper:</p>
			<div><div><img src="img/B21678_11_8.0.jpg" alt="Figure 11.8 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Web browser screenshot</p>
			<h3>Editing whispers</h3>
			<p>It is possible <a id="_idIndexMarker703"/>to edit whispers. Just click on the pencil button and you will see a prompt asking for the new message of the whisper:</p>
			<div><div><img src="img/B21678_11_9.0.jpg" alt="Figure 11.9 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Web browser screenshot</p>
			<h3>Deleting whispers</h3>
			<p>It is possible <a id="_idIndexMarker704"/>to delete whispers. Just click on the trash button and you will see a confirm dialog asking for the confirmation:</p>
			<div><div><img src="img/B21678_11_10.jpg" alt="Figure 11.10 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Web browser screenshot</p>
			<h3>Your challenge</h3>
			<p>If you are familiar with frontend development, you can try to improve the web interface and make <a id="_idIndexMarker705"/>it more user-friendly or directly replace it with a modern frontend framework such as React, Vue, or Angular. If you are not familiar with front-end development, you can skip this challenge and continue with the next chapter.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor317"/>Let’s celebrate it!</h2>
			<p>Feel free to explore the code and play with it, you can start the application with <code>npm run start</code> and you can go to <code>http://localhost:3000</code> and create a few whispers that you can later edit or remove from the web interface.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor318"/>Next steps</h2>
			<p>Congratulations! You have created a solid REST API, but there are a lot of things that you can do to improve it. In the next chapter, we will see how to properly store the information in the database.</p>
			<p>In <a href="B21678_13.xhtml#_idTextAnchor348"><em class="italic">Chapter 13</em></a>, we will see how to add authentication to the API, so only authenticated users can create, update, or delete whispers and multiple users will be able to use our application.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor319"/>Summary</h1>
			<p>In this chapter, we learned how to use supertest to test our API in depth. We learned how to test the routes and how to test the stores. We created a solid API that we will evolve in the next chapters.</p>
			<p>In the next chapter, we will see how to properly store the information in the database, using MongoDB. We will take the opportunity to refactor our project and use a better software pattern to organize the code and a MongoDB database to store the data.</p>
		</div>
	</body></html>