<html><head></head><body>
		<div id="_idContainer081">
			<h1 id="_idParaDest-292" class="chapter-number"><a id="_idTextAnchor300"/>11</h1>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor301"/>Building a Web Application Project from Scratch</h1>
			<p>In this chapter, we will start a new project that will be the base for the next chapters. We will apply all the lessons learned from the previous chapters and we will put into practice asynchronous programming, Node.js core libraries, external modules, testing, and all the concepts that we learned about regarding <span class="No-Break">REST APIs.</span></p>
			<p>This project will evolve, so we will iterate over the project, adding new features and new tests, so you can experience the full development cycle of a real-world application <span class="No-Break">using Node.js.</span></p>
			<p>In this chapter, we will use the file system library to store the changes we produce in the project while managing operations from the REST API we create. In the next chapter, we will learn how to connect the web application to MongoDB, but we will do a migration using the tests that we built in <span class="No-Break">this chapter.</span></p>
			<p>At the end of the book, we will deploy this project in several ways, and we will expose our application to the internet and to <span class="No-Break">real users.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to start an Express application including UI and <span class="No-Break">API REST</span></li>
				<li>How to test an Express application using Supertest <span class="No-Break">and Jest</span></li>
				<li>How to include data stores in <span class="No-Break">our projects</span></li>
			</ul>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor302"/>Technical requirements</h1>
			<p>The coode files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/JYWmvQrGu78"><span class="No-Break">https://youtu.be/JYWmvQrGu78</span></a></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor303"/>The project Kickoff</h1>
			<p>This is so <a id="_idIndexMarker653"/>exciting! We are going to apply all the knowledge that we have learned in the previous chapters to build a CRUD REST API with Express. We will use the file system to store the data, and we will use the most common Express middleware to build a <span class="No-Break">robust API.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor304"/>The project goal</h2>
			<p>We are going to build a microblogging platform called “Whispering,” where users can create, read, update, and delete whispers (<span class="No-Break">short posts).</span></p>
			<h3>Preview</h3>
			<p>While we <a id="_idIndexMarker654"/>will focus on the backend, we will have a basic frontend included to test the API. So, we will start working with a simple app skeleton that we will evolve over the <span class="No-Break">next chapters.</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B21678_11_1.jpg" alt="Figure 11.1 – Preview of the home page from the project in the web browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Preview of the home page from the project in the web browser</p>
			<h3>Requirements</h3>
			<p>The requirements <a id="_idIndexMarker655"/>will evolve over the next chapters, but for now, we will focus on <span class="No-Break">the following:</span></p>
			<ul>
				<li>Adding a welcome landing page using a <span class="No-Break">template engine</span></li>
				<li>Serving <span class="No-Break">static files</span></li>
				<li>Adding a CRUD REST API <span class="No-Break">with Express</span></li>
				<li>Using the file system to store the data in <span class="No-Break">JSON format</span></li>
				<li>Adding tests to ensure that the API is working <span class="No-Break">as expected</span></li>
			</ul>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor305"/>Starting with the first step</h2>
			<p>To start <a id="_idIndexMarker656"/>working on the project, we need to download the project from  <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a> and access the <strong class="source-inline">step0</strong> folder. Now, enter the folder and feel free to explore the code. You will see that we have a basic skeleton with the <span class="No-Break">following structure:</span></p>
			<pre class="source-code">
|____.babelrc
|____db.json
|____server.js
|____store.js
|____jest.config.js
|____tests
| |____server.test.js
| |____fixtures.js
| |____store.test.js
| |____utils.js
|____index.js
|____public
| |____index.html
| |____styles.css
| |____app.js
| |____people.jpg
|____package-lock.json
|____package.json
|____.nvmrc
|____views
| |____about.ejs</pre>			<p>Now that <a id="_idIndexMarker657"/>we are clear about the project objective, let’s start building the application. In the next section, we will start building the application by adding the dependencies, the basic structure, the stores, and other things in order to build a solid REST API that can be used in the <span class="No-Break">next chapters.</span></p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor306"/>Building a REST API</h1>
			<p>Now that we have a basic understanding of Express, let’s build a REST API for the microblogging <a id="_idIndexMarker658"/>platform. We will start with the basic CRUD operations and then we will add <span class="No-Break">more features.</span></p>
			<p>In <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we learned about the principles of building RESTful APIs. We will apply them now. As the platform is called “whispering” and the users will be able to create, read, update, and delete whispers, we will have the <span class="No-Break">following endpoints:</span></p>
			<ul>
				<li><strong class="source-inline">GET /api/v1/whisper</strong>: Get all <span class="No-Break">the whispers</span></li>
				<li><strong class="source-inline">GET /api/v1/whisper/:id</strong>: Get a whisper <span class="No-Break">by ID</span></li>
				<li><strong class="source-inline">POST /api/v1/whisper</strong>: Create a <span class="No-Break">new whisper</span></li>
				<li><strong class="source-inline">PUT /api/v1/whisper/:id</strong>: Update a whisper <span class="No-Break">by ID</span></li>
				<li><strong class="source-inline">DELETE /api/v1/whisper/:id</strong>: Delete a whisper <span class="No-Break">by ID</span></li>
			</ul>
			<p>In this case, we used the prefix <strong class="source-inline">/api/v1/</strong> because we are building the first version of the API. It is a good practice to version the API in the URL because, in the future, you may want to introduce breaking changes, and it will be hard for your consumers to adapt to the new changes if you don’t version <span class="No-Break">the API.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor307"/>Adding the routes</h2>
			<p>As the <a id="_idIndexMarker659"/>first step, let’s add <span class="No-Break">the dependencies:</span></p>
			<pre class="console">
npm install express@4 body-parser@1</pre>			<p>Let’s start by adding the routes to the <strong class="source-inline">server.js</strong> file and <span class="No-Break">configure Express:</span></p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
const app = express()
app.use(bodyParser.json())
app.get('/api/v1/whisper', (req, res) =&gt; {
    res.json([])
})
app.get('/api/v1/whisper/:id', (req, res) =&gt; {
    const id = parseInt(req.params.id)
    res.json({ id })
})
app.post('/api/v1/whisper', (req, res) =&gt; {
    res.status(201).json(req.body)
})
app.put('/api/v1/whisper/:id', (req, res) =&gt; {
  //const id = parseInt(req.params.id)
  res.sendStatus(200)
})
app.delete('/api/v1/whisper/:id', (req, res) =&gt; {
    res.sendStatus(200)
})
export { app }</pre>			<p>We created the basic routes for the CRUD operations, and we are returning a JSON response with <a id="_idIndexMarker660"/>the data that we received in the request. This time, we made a little change, and we will export the app object so we can use it in the tests later. Now, let’s initialize the server in the <span class="No-Break"><strong class="source-inline">index.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import { app } from "./server.js";
const port = 3000
app.listen(port, () =&gt; {
    console.log(`Running in http://localhost:${port}`)
})</pre>			<p>Now let’s add the npm scripts to run the application in the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js"
    }
}</pre>			<h2 id="_idParaDest-300"><a id="_idTextAnchor308"/>Adding the stores</h2>
			<p>As this is a <a id="_idIndexMarker661"/>simple application, we will use the file system to store the data. We will create a <strong class="source-inline">store.js</strong> file and we will add the <span class="No-Break">following functions:</span></p>
			<pre class="source-code">
import fs from 'node:fs/promises'
import path from 'node:path'
const filename = path.join(process.cwd(), 'db.json')
const saveChanges = data =&gt; fs.writeFile(filename, JSON.stringify(data))
const readData = async () =&gt; {
    const data = await fs.readFile(filename, 'utf-8')
    return JSON.parse(data)
}
const getAll = readData
const getById = async (id) =&gt; {
    const data = await readData()
    return data.find(item =&gt; item.id === id)
}
const create = async (message) =&gt; {
    const data = await readData()
    const newItem = { message, id: data.length +1}
    await saveChanges(data.concat([newItem]))
    return newItem
}
const updateById = async (id, message) =&gt; {
    const data = await readData()
    const newData = data.map(current =&gt; {
        if(current.id === id) {
            return { ...current, message }
        }
        return current
    })
    await saveChanges(newData)
}
const deleteById = async id =&gt; {
    const data = await readData()
    await saveChanges(data
.filter(current =&gt; current.id !== id)
    )
}
export { getAll, getById, create, updateById, deleteById }</pre>			<p>Basically, we are using the file system to store the data in a JSON file. We are using <strong class="source-inline">saveChanges</strong> to save the data and <strong class="source-inline">readData</strong> to read <span class="No-Break">the data.</span></p>
			<p>Then we <a id="_idIndexMarker662"/>have the basic CRUD operations defined in the functions <strong class="source-inline">getAll</strong>, <strong class="source-inline">getById</strong>, <strong class="source-inline">create</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">updateById</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s add the tests for the store. As the first step, let’s add the dependencies, <strong class="source-inline">npm install -D jest@29 @babel/preset-env@7</strong>, and then let’s add the skeleton for the tests to the <span class="No-Break"><strong class="source-inline">tests/store.test.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import { getAll, getById, create, updateById, deleteById } from '../store.js'
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
const dbPath = join(process.cwd(), 'db.json')
const restoreDb = () =&gt; writeFileSync(dbPath, JSON.stringify([]))
const populateDb = (data) =&gt; writeFileSync(dbPath, JSON.stringify(data))
const fixtures = [{ id: 1, message: 'test' }, { id: 2, message: 'hello world' }]
const inventedId = 12345
const existingId = fixtures[0].id
describe('store', () =&gt; {
    beforeEach(() =&gt; populateDb(fixtures))
    afterAll(restoreDb)
    // Here we will be the tests
})</pre>			<p>In <a href="B21678_08.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we learned the principles of testing. One of the principles is that the tests should be independent, and that means that the tests should not depend on the state of previous tests and that we can run them as many times as we want and the result should <span class="No-Break">not change.</span></p>
			<p>As we are <a id="_idIndexMarker663"/>using an external file to store the data, we need to make sure that the data is in the initial state before each test. So, we are using the <strong class="source-inline">beforeEach</strong> function to populate the database with the fixtures and the <strong class="source-inline">afterAll</strong> function to restore the database to the initial state. This way, we can make sure that the tests always start from the <span class="No-Break">same state.</span></p>
			<p>Also, we added some fixtures and variables that we will use in the tests when we need to create, update, or delete data. This will help us to avoid hardcoding values and make the tests <span class="No-Break">more readable.</span></p>
			<p>Now, let’s add the tests for the <span class="No-Break"><strong class="source-inline">getAll</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
describe('getAll', () =&gt; {
    it("Should return an empty array when there's no data", async () =&gt; {
        restoreDb()
        const data = await getAll()
        expect(data).toEqual([])
    })
    it('Should return an array with one item when there is one item', async () =&gt; {
        const data = await getAll()
        expect(data).toEqual(fixtures)
    })
})</pre>			<p>We have two test cases only – when the database is empty and when the database has data. In both cases, we are expecting <span class="No-Break">an array.</span></p>
			<p>Now, let’s add the tests for the <span class="No-Break"><strong class="source-inline">getById</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
describe('getById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async () =&gt; {
        const item = await getById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should return the item with the given id', async () =&gt; {
        const item = await getById(fixtures[0].id)
        expect(item).toEqual(fixtures[0])
    })
})</pre>			<p>We have <a id="_idIndexMarker664"/>two test cases only – when we match an item and when we don’t match <span class="No-Break">an item.</span></p>
			<p>Now, let’s add the tests for the <span class="No-Break"><strong class="source-inline">create</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
describe('create', () =&gt; {
    it('Should return the created item', async () =&gt; {
        const newItem = { id: fixtures.length + 1, message: 'test 3' }
        const item = await create(newItem.message)
        expect(item).toEqual(newItem)
    })
    it('Should add the item to the db', async () =&gt; {
        const newItem = { id: fixtures.length + 1, message: 'test 3' }
        const { id } = await create(newItem.message)
        const item = await getById(id)
        expect(item).toEqual(newItem)
    })
})</pre>			<p>In this case, we expect the item to be returned including the ID when it is returned from the function, and we expect the item to be added to <span class="No-Break">the database.</span></p>
			<p>Let’s add <a id="_idIndexMarker665"/>the tests for the <span class="No-Break"><strong class="source-inline">updateById</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
describe('updateById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async() =&gt; {
        const item = await updateById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should not return the updated item', async () =&gt; {
        const updatedItem = { id: existingId, message: 'updated' }
        const item = await updateById(updatedItem.id, updatedItem.message)
        expect(item).toBeUndefined()
    })
    it('Should update the item in the db', async () =&gt; {
        const updatedItem = { id: existingId, message: 'updated' }
        await updateById(updatedItem.id, updatedItem.message)
        const item = await getById(existingId)
        expect(item).toEqual(updatedItem)
    })
})</pre>			<p>In this case, we expect the item to be updated in the database only if it exists, but not to be returned from the function <span class="No-Break">at all.</span></p>
			<p>Let’s add <a id="_idIndexMarker666"/>the last tests for the <span class="No-Break"><strong class="source-inline">deleteById</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
describe('deleteById', () =&gt; {
    it('Should return undefined when there is no item with the given id', async () =&gt; {
        const item = await deleteById(inventedId)
        expect(item).toBeUndefined()
    })
    it('Should not return the deleted item', async () =&gt; {
        const item = await deleteById(existingId)
        expect(item).toBeUndefined()
    })
    it('Should delete the item from the db', async () =&gt; {
        await deleteById(existingId)
        const items = await getAll()
        expect(items).toEqual(fixtures.filter(item =&gt; item.id !== existingId))
    })
})</pre>			<p>We expect a similar behavior as in the <strong class="source-inline">updateById</strong> function. The item should be deleted from the database only if it exists, and the item is not returned. Now, let’s include the test scripts in the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js",
        "test": "jest",
        "test:coverage": "jest --coverage"
    }
}</pre>			<p>Run the <a id="_idIndexMarker667"/>tests with <strong class="source-inline">npm run test</strong>. Your output should be similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B21678_11_2.jpg" alt="Figure 11.2 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Terminal screenshot</p>
			<p>Our first storage is working, and fully tested. Now, let’s just finish by adding a linter to the project. First, install the linter with <strong class="source-inline">npm i -D standard@17</strong> and then update the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> scripts:</span></p>
			<pre class="source-code">
{
    "scripts": {
        "start": "node index.js",
        "test": "jest",
        "test:coverage": "jest --coverage",
        "lint": "standard",
        "lint:fix": "standard --fix"
    }
}</pre>			<p>Now, you can <a id="_idIndexMarker668"/>run the linter with <strong class="source-inline">npm run lint</strong> and fix the errors with <strong class="source-inline">npm run lint:fix</strong>. Sometimes you might need to fix the errors manually, but most of the time the linter will fix them <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor309"/>Adding the static files</h2>
			<p>Now, let’s add the static files to the application. Basically, in the <strong class="source-inline">public</strong> folder, we have <a id="_idIndexMarker669"/>several files that we want to serve to the client, such as the <strong class="source-inline">index.html</strong>, <strong class="source-inline">style.css</strong>, and <strong class="source-inline">app.js</strong> files. So, let’s add the following code to the <span class="No-Break"><strong class="source-inline">server.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
const app = express()
app.use(express.static('public'))
app.use(bodyParser.json())</pre>			<p>Now if we start the server with <strong class="source-inline">npm run start</strong>, and you go to <strong class="source-inline">http://localhost:3000/styles.css</strong>, you will see the content of the <span class="No-Break"><strong class="source-inline">styles.css</strong></span><span class="No-Break"> file.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Until we finish this chapter, the URL <strong class="source-inline">http://localhost:3000</strong> might not work as expected, as the backend is not <span class="No-Break">finished yet.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor310"/>Adding the templates</h2>
			<p>In this <a id="_idIndexMarker670"/>project we will use the server render approach to handle certain parts of the application. So we will install the <strong class="source-inline">ejs</strong> <span class="No-Break">template engine:</span></p>
			<pre class="console">
npm i ejs@3</pre>			<p>Let’s import the store functions in the <span class="No-Break"><strong class="source-inline">server.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import express from 'express'
import bodyParser from 'body-parser'
<strong class="bold">import { getAll, getById, create, updateById, deleteById } from './store.js'</strong>
const app = express()</pre>			<p>Then, register <a id="_idIndexMarker671"/>the template engine in the <span class="No-Break"><strong class="source-inline">server.js</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
app.use(bodyParser.json())
<strong class="bold">app.set('view engine', 'ejs')</strong>
app.get('/api/v1/whisper', async (req, res) =&gt; {
    const whispers = await getAll()
    res.json(whispers)
})</pre>			<p>Finally, we will create a route, <strong class="source-inline">about</strong>, that will render the <strong class="source-inline">views/about.ejs</strong> template and we will provide the whispers to <span class="No-Break">the template:</span></p>
			<pre class="source-code">
app.set('view engine', 'ejs')
<strong class="bold">app.get('/about', async (req, res) =&gt; {</strong>
<strong class="bold">    const whispers = await getAll()</strong>
<strong class="bold">    res.render('about', { whispers })</strong>
<strong class="bold">})</strong>
app.get('/api/v1/whisper', async (req, res) =&gt; {/*...*/})</pre>			<p>Now, let’s start the server with <strong class="source-inline">npm run start</strong> and go to <strong class="source-inline">http://localhost:3000/about</strong> and you will see the <span class="No-Break">template rendered.</span></p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <strong class="source-inline">step1</strong> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs <span class="No-Break">more easily.</span></p>
			<p>In the <a id="_idIndexMarker672"/>next section, we will continue building the REST API by adding tests. Adding tests to the REST API is very important because it will allow us to make sure that the API is working as expected and it will allow us to iterate over it in the next chapters <span class="No-Break">more easily.</span></p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor311"/>Testing with supertest</h1>
			<p>Now, it is time <a id="_idIndexMarker673"/>to make sure that our REST API is working as expected. We will learn in this section how to build solid tests while <span class="No-Break">using Express.</span></p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor312"/>Adding stores to the server</h2>
			<p>We will <a id="_idIndexMarker674"/>refactor each route to use the store functions. Let’s start with the <strong class="source-inline">GET /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
app.get('/api/v1/whisper', async (req, res) =&gt; {
    <strong class="bold">const whispers = await getAll()</strong>
<strong class="bold">    res.json(whispers</strong>)
})</pre>			<p>Basically, we are using the <strong class="source-inline">getAll</strong> function to get all the whispers and we are returning them in the response. Now, let’s refactor the <strong class="source-inline">GET /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper/:id</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
app.get('/api/v1/whisper/:id', async (req, res) =&gt; {
    <strong class="bold">const id = parseInt(req.params.id)</strong>
<strong class="bold">    const whisper = await getById(id)</strong>
<strong class="bold">    if (!whisper) {</strong>
<strong class="bold">        res.sendStatus(404)</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">        res.json(whisper)</strong>
<strong class="bold">    }</strong>
})</pre>			<p>In this case, we will return a 404 status code if the whisper doesn’t exist, and we will return the <a id="_idIndexMarker675"/>whisper if it exists. Now, let’s refactor the <strong class="source-inline">POST /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
app.post("/api/v1/whisper", async (req, res) =&gt; {
  <strong class="bold">const { message } = req.body;</strong>
<strong class="bold">  if (!message) {</strong>
<strong class="bold">    res.sendStatus(400);</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">    const whisper = await create(message);</strong>
<strong class="bold">    res.status(201).json(whisper);</strong>
<strong class="bold">  }</strong>
});</pre>			<p>In this case, we are validating that the message is not empty in the request body, returning a 400 status code in those cases. If the creation was successful, we return the whisper details. Now, let’s refactor the <strong class="source-inline">PUT /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper/:id</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
app.put('/api/v1/whisper/:id', async (req, res) =&gt; {
    <strong class="bold">const { message } = req.body</strong>
<strong class="bold">    const id = parseInt(req.params.id)</strong>
<strong class="bold">    if(!message) {</strong>
<strong class="bold">        res.sendStatus(400)</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">        const whisper = await getById(id);</strong>
<strong class="bold">        if (!whisper) {</strong>
<strong class="bold">            res.sendStatus(404);</strong>
<strong class="bold">        } else {</strong>
<strong class="bold">            await updateById(id, message);</strong>
<strong class="bold">            res.sendStatus(200);</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
<strong class="bold">})</strong></pre>			<p>In this case, we do a payload validation as in <strong class="source-inline">POST /api/v1/whisper</strong> and we validate <a id="_idIndexMarker676"/>that the whisper exists before updating it. Now, let’s refactor the <strong class="source-inline">DELETE /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper/:id</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
app.delete('/api/v1/whisper/:id', async (req, res) =&gt; {
<strong class="bold">    const id = parseInt(req.params.id)</strong>
<strong class="bold">    const whisper = await getById(id)</strong>
<strong class="bold">    if(!whisper) {</strong>
<strong class="bold">        res.sendStatus(404)</strong>
<strong class="bold">        return</strong>
<strong class="bold">    }</strong>
<strong class="bold">    await deleteById(id)</strong>
<strong class="bold">    res.sendStatus(200)</strong>
<strong class="bold">})</strong></pre>			<p>In this case, we validate that the whisper exists before deleting it. Now, let’s add the tests for <span class="No-Break">the routes.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor313"/>Creating test utils</h2>
			<p>Before we start adding the tests, there is some code that we can reuse between the test files, such as <a id="_idIndexMarker677"/>the fixtures and the functions to populate and restore the database. So, let’s do a little <span class="No-Break">refactoring first.</span></p>
			<p>As the first step, let’s create a file called <strong class="source-inline">fixtures.js</strong> in the <strong class="source-inline">tests</strong> folder, and let’s add the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
const whispers = [{ id: 1, message: 'test' }, { id: 2, message: 'hello world' }]
const inventedId = 12345
const existingId = whispers[0].id
export {
    whispers,
    inventedId,
    existingId
}</pre>			<p>Then, create a file called <strong class="source-inline">utils.js</strong> in the <strong class="source-inline">tests</strong> folder, and let’s add the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
const dbPath = join(process.cwd(), 'db.json')
const restoreDb = () =&gt; writeFileSync(dbPath, JSON.stringify([]))
const populateDb = (data) =&gt; writeFileSync(dbPath, JSON.stringify(data))
export { restoreDb, populateDb }</pre>			<p>Now, let’s refactor the <strong class="source-inline">store.test.js</strong> file to use the <span class="No-Break">new files:</span></p>
			<pre class="source-code">
import { getAll, getById, create, updateById, deleteById } from '../store.js'
<strong class="bold">import { restoreDb, populateDb } from './utils.js'</strong>
<strong class="bold">import { whispers, inventedId, existingId } from './fixtures.js'</strong>
describe('store', () =&gt; {
    //...
})</pre>			<p>Also, find and <a id="_idIndexMarker678"/>replace the <strong class="source-inline">fixtures</strong> variable with <strong class="source-inline">whispers</strong> in <span class="No-Break">the tests.</span></p>
			<p>Now you can run the tests with <strong class="source-inline">npm run test</strong> and you will see that the tests <span class="No-Break">are passing:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B21678_11_3.jpg" alt="Figure 11.3 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Terminal screenshot</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor314"/>Adding server tests</h2>
			<p>Now, let’s <a id="_idIndexMarker679"/>add the tests for the routes. In this case, we will <a id="_idIndexMarker680"/>use supertest (<a href="https://www.npmjs.com/package/supertest">https://www.npmjs.com/package/supertest</a>) to test the routes. As the first step, let’s install the <span class="No-Break">new dependency:</span></p>
			<pre class="console">
npm i -D supertest@6</pre>			<h3>Defining the tests</h3>
			<p>You can use <strong class="source-inline">it.todo</strong> to mark the tests that you need to add. This way, you can focus on the <a id="_idIndexMarker681"/>description of the tests and not on the implementation details. So, let’s create the <strong class="source-inline">tests/server.test.js</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import supertest from 'supertest'
import { app } from '../server'
import { restoreDb, populateDb } from './utils.js'
import { whispers, inventedId, existingId } from './fixtures.js'
import { getById } from '../store'
describe('Server', () =&gt; {
    beforeEach(() =&gt; populateDb(whispers))
    afterAll(restoreDb)
    describe("GET /api/v1/whisper", () =&gt; {
        it.todo("Should return an empty array when there's no data")
        it.todo("Should return all the whispers")
    })
    describe("GET /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a whisper details")
    })
    describe("POST /api/v1/whisper", () =&gt; {
        it.todo("Should return a 400 when the body is empty")
        it.todo("Should return a 400 when the body is invalid")
        it.todo("Should return a 201 when the whisper is created")
    })
    describe("PUT /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 400 when the body is empty")
        it.todo("Should return a 400 when the body is invalid")
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a 200 when the whisper is updated")
    })
    describe("DELETE /api/v1/whisper/:id", () =&gt; {
        it.todo("Should return a 404 when the whisper doesn't exist")
        it.todo("Should return a 200 when the whisper is deleted")
    })
})</pre>			<p>Run the tests with the <strong class="source-inline">npm run </strong><span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B21678_11_4.jpg" alt="Figure 11.4 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Terminal screenshot</p>
			<p>You will <a id="_idIndexMarker682"/>see that the previous tests pass, and the new tests are marked as <em class="italic">todo</em>. This is a good practice to keep track of the tests that you need to add, and it does not break the <span class="No-Break">test suite.</span></p>
			<h3>Adding the tests with supertest</h3>
			<p>Basically, we will <a id="_idIndexMarker683"/>use supertest to make requests <a id="_idIndexMarker684"/>to the server and we will validate the response. Let’s start with the <strong class="source-inline">GET /api/v1/whisper</strong> route. Let’s replace the <strong class="source-inline">it.todo</strong> tests with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
describe("GET /api/v1/whisper", () =&gt; {
    it("Should return an empty array when there's no data", async () =&gt; {
        await restoreDb() // empty the db
        const response = await supertest(app).get("/api/v1/whisper")
        expect(response.status).toBe(200)
        expect(response.body).toEqual([])
    })
    it("Should return all the whispers", async () =&gt; {
        const response = await supertest(app).get("/api/v1/whisper")
        expect(response.status).toBe(200)
        expect(response.body).toEqual(whispers)
    })
})</pre>			<p>In each <a id="_idIndexMarker685"/>request, we check that the status code and <a id="_idIndexMarker686"/>the response payload are correct. Now, let’s add the tests for the <strong class="source-inline">GET /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper/:id</strong></span><span class="No-Break"> route:</span></p>
			<pre class="source-code">
describe("GET /api/v1/whisper/:id", () =&gt; {
    it("Should return a 404 when the whisper doesn't exist", async () =&gt; {
        const response = await supertest(app).get(`/api/v1/whisper/${inventedId}`)
        expect(response.status).toBe(404)
    })
    it("Should return a whisper details", async () =&gt; {
        const response = await supertest(app).get(`/api/v1/whisper/${existingId}`)
        expect(response.status).toBe(200)
        expect(response.body).toEqual(whispers.find(w =&gt; w.id === existingId))
    })
})</pre>			<p>As you can see, the tests are very similar to the ones we did for <strong class="source-inline">storage.test.js</strong>. Now, let’s add the tests for the <strong class="source-inline">POST /</strong><span class="No-Break"><strong class="source-inline">api/v1/whisper</strong></span><span class="No-Break"> route.</span></p>
			<p>We will start by adding the parent description for <span class="No-Break">the route:</span></p>
			<pre class="source-code">
describe("POST /api/v1/whisper", () =&gt; {
    // it("....")
})</pre>			<p>All the tests will be added inside the <strong class="source-inline">describe</strong> function. So, let’s define all the scenarios that we want to cover in <span class="No-Break">the tests:</span></p>
			<p>We want <a id="_idIndexMarker687"/>to be sure that we return a 400 status <a id="_idIndexMarker688"/>code when the request does not include <span class="No-Break">a body:</span></p>
			<pre class="source-code">
it("Should return a 400 when the body is empty",
async () =&gt; {
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 400 status code when the request does not include a proper body, for example, when some required properties <span class="No-Break">are missing:</span></p>
			<pre class="source-code">
it("Should return a 400 when the body is invalid",
async () =&gt; {
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({invented: "This is a new whisper"})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 201 status and the details of the new whisper when the payload in the request is correct. Also, we want to check that the whisper was properly stored in <span class="No-Break">the database:</span></p>
			<pre class="source-code">
it("Should return a 201 when the whisper is created",
async () =&gt; {
  const newWhisper = {
id: whispers.length + 1,
message: "This is a new whisper"
  }
  const response = await supertest(app)
    .post("/api/v1/whisper")
    .send({message: newWhisper.message})
  // HTTP Response
  expect(response.status).toBe(201)
  expect(response.body).toEqual(newWhisper)
  // Database changes
  const storedWhisper = await getById(newWhisper.id)
  expect(storedWhisper).toStrictEqual(newWhisper)
})</pre>			<p>As you can see, when we created a new whisper we also validated that the whisper was added to <a id="_idIndexMarker689"/>the database. This is because these tests are <a id="_idIndexMarker690"/>integration tests and we want to make sure that the changes are recorded in the <em class="italic">database</em> <span class="No-Break">as well.</span></p>
			<p>Now, let’s add the tests for the <strong class="source-inline">PUT /api/v1/whisper/:id</strong> route. We will start by adding the parent description for <span class="No-Break">the route:</span></p>
			<pre class="source-code">
describe("PUT /api/v1/whisper/:id", () =&gt; {
    // it("....")
})</pre>			<p>All the tests will be added inside the <strong class="source-inline">describe</strong> function. So, let’s define all the scenarios that we want to cover in <span class="No-Break">the tests:</span></p>
			<p>We want to be sure that we return a 400 status code when the request does not include <span class="No-Break">a body:</span></p>
			<pre class="source-code">
it("Should return a 400 when the body is empty",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({})
  expect(response.status).toBe(400)
})</pre>			<p>We want <a id="_idIndexMarker691"/>to be sure that we return a 400 status <a id="_idIndexMarker692"/>code when the request does not include a proper body, for example, when some required properties <span class="No-Break">are missing:</span></p>
			<pre class="source-code">
it("Should return a 400 when the body is invalid",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({invented: "This a new field"})
  expect(response.status).toBe(400)
})</pre>			<p>We want to be sure that we return a 404 status code when the request is targeting a <span class="No-Break">non-existent whisper:</span></p>
			<pre class="source-code">
it("Should return a 404 when the whisper doesn't exist",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${inventedId}`)
    .send({message: "Whisper updated"})
  expect(response.status).toBe(404)
})</pre>			<p>We want to be sure that we return a 200 status when the payload and the target are correct. Also, we want to check that the whisper was properly updated in <span class="No-Break">the database:</span></p>
			<pre class="source-code">
it("Should return a 200 when the whisper is updated",
async () =&gt; {
  const response = await supertest(app)
    .put(`/api/v1/whisper/${existingId}`)
    .send({message: "Whisper updated"})
  expect(response.status).toBe(200)
  // Database changes
  const storedWhisper = await getById(existingId)
  expect(storedWhisper).toStrictEqual({id: existingId, message: "Whisper updated"})
})</pre>			<p>Finally, let’s <a id="_idIndexMarker693"/>add the tests for the <strong class="source-inline">DELETE /api/v1/whisper/:id</strong> route. We will start by adding the parent description for <span class="No-Break">the route:</span></p>
			<pre class="source-code">
describe(" DELETE /api/v1/whisper/:id", () =&gt; {
    // it("....")
})</pre>			<p>All the <a id="_idIndexMarker694"/>tests will be added inside the <strong class="source-inline">describe</strong> function. So, let’s define all the scenarios that we want to cover in <span class="No-Break">the tests:</span></p>
			<p>We want to be sure that we return a 404 status code when the request is targeting a <span class="No-Break">non-existent whisper:</span></p>
			<pre class="source-code">
it("Should return a 404 when the whisper doesn't exist", async () =&gt; {
  const response = await supertest(app)
    .delete(`/api/v1/whisper/${inventedId}`)
  expect(response.status).toBe(404)
})</pre>			<p>We want <a id="_idIndexMarker695"/>to be sure that we return a 200 status <a id="_idIndexMarker696"/>code when the request is targeting a valid whisper. Also, we want to check that the whisper was properly removed from <span class="No-Break">the database:</span></p>
			<pre class="source-code">
it("Should return a 200 when the whisper is deleted", async () =&gt; {
  const response = await supertest(app)
    .delete(`/api/v1/whisper/${existingId}`)
  expect(response.status).toBe(200)
  // Database changes
  const storedWhisper = await getById(existingId)
  expect(storedWhisper).toBeUndefined()
})</pre>			<p>Now, you can run the tests with <strong class="source-inline">npm run test</strong> and you will see that the tests <span class="No-Break">are passing:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B21678_11_5.jpg" alt="Figure 11.5 – Terminal screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Terminal screenshot</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the <strong class="source-inline">step2</strong> folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs <span class="No-Break">more easily.</span></p>
			<p>In the next section, we will review the final result and we will see how to use the application and what we are planning to do in the <span class="No-Break">next chapters.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor315"/>Reviewing the final result of the project</h1>
			<p>At this <a id="_idIndexMarker697"/>point, you should have a fully functional REST API with Express and if your tests are passing, you can start using <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor316"/>The about page</h2>
			<p>If you go to <strong class="source-inline">http://localhost:3000/about</strong>, you will see the <span class="No-Break">about page:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B21678_11_6.0.jpg" alt="Figure 11.6 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Web browser screenshot</p>
			<p>This page <a id="_idIndexMarker698"/>was served using the server render approach, and we are using the EJS template engine to render the page. We are using the whispers data from the database to render the page. The text <em class="italic">Currently there are 3 whispers available</em> is dynamic text that will change depending on the number of whispers in <span class="No-Break">the database.</span></p>
			<p>You can see the reference in the <span class="No-Break"><strong class="source-inline">views/about.ejs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;p&gt;Currently there are &lt;%= whispers.length %&gt; whispers available&lt;/p&gt;</pre>			<h3>Web interface</h3>
			<p>The web interface is a simple page where you can create, update, and delete whispers. You can <a id="_idIndexMarker699"/>access the web interface at <strong class="source-inline">http://localhost:3000</strong>. It will start with an empty list of whispers. In my case, I have three whispers in the database, so I will see the <span class="No-Break">following page:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B21678_11_7.0.jpg" alt="Figure 11.7 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Web browser screenshot</p>
			<p>In order to make the frontend source code more readable, I used plain JavaScript to make the requests to the API and old browser APIs such as <strong class="source-inline">prompts</strong> and <strong class="source-inline">confirms</strong> to interact with the user. You can see the source code in the <strong class="source-inline">public/app.js</strong> file. For a production application, you should avoid these browser APIs as they are quite limited and implement a solution that works on all devices using UI elements that are properly integrated. Also, you will need to handle errors and loading states. For larger projects, it is quite common <a id="_idIndexMarker700"/>to use UI libraries such as tailwind (<a href="https://tailwindcss.com/">https://tailwindcss.com/</a>) or frameworks <a id="_idIndexMarker701"/>such as <span class="No-Break">Vue (</span><a href="https://vuejs.org/"><span class="No-Break">https://vuejs.org/</span></a><span class="No-Break">).</span></p>
			<h3>Adding whispers</h3>
			<p>It is possible <a id="_idIndexMarker702"/>to add whispers to the list. Just click on the <strong class="bold">Spread a whisper</strong> button and you will see a prompt asking for the message of <span class="No-Break">the whisper:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B21678_11_8.0.jpg" alt="Figure 11.8 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Web browser screenshot</p>
			<h3>Editing whispers</h3>
			<p>It is possible <a id="_idIndexMarker703"/>to edit whispers. Just click on the pencil button and you will see a prompt asking for the new message of <span class="No-Break">the whisper:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B21678_11_9.0.jpg" alt="Figure 11.9 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Web browser screenshot</p>
			<h3>Deleting whispers</h3>
			<p>It is possible <a id="_idIndexMarker704"/>to delete whispers. Just click on the trash button and you will see a confirm dialog asking for <span class="No-Break">the confirmation:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B21678_11_10.jpg" alt="Figure 11.10 – Web browser screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Web browser screenshot</p>
			<h3>Your challenge</h3>
			<p>If you are familiar with frontend development, you can try to improve the web interface and make <a id="_idIndexMarker705"/>it more user-friendly or directly replace it with a modern frontend framework such as React, Vue, or Angular. If you are not familiar with front-end development, you can skip this challenge and continue with the <span class="No-Break">next chapter.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor317"/>Let’s celebrate it!</h2>
			<p>Feel free to explore the code and play with it, you can start the application with <strong class="source-inline">npm run start</strong> and you can go to <strong class="source-inline">http://localhost:3000</strong> and create a few whispers that you can later edit or remove from the <span class="No-Break">web interface.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor318"/>Next steps</h2>
			<p>Congratulations! You have created a solid REST API, but there are a lot of things that you can do to improve it. In the next chapter, we will see how to properly store the information in <span class="No-Break">the database.</span></p>
			<p>In <a href="B21678_13.xhtml#_idTextAnchor348"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, we will see how to add authentication to the API, so only authenticated users can create, update, or delete whispers and multiple users will be able to use <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor319"/>Summary</h1>
			<p>In this chapter, we learned how to use supertest to test our API in depth. We learned how to test the routes and how to test the stores. We created a solid API that we will evolve in the <span class="No-Break">next chapters.</span></p>
			<p>In the next chapter, we will see how to properly store the information in the database, using MongoDB. We will take the opportunity to refactor our project and use a better software pattern to organize the code and a MongoDB database to store <span class="No-Break">the data.</span></p>
		</div>
	</body></html>