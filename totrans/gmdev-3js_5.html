<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Design and Development</h1></div></div></div><p>While other chapters have focused on the Three.js API and how to use it to build games, this chapter discusses how to make <em>good</em> games using Three.js and the Web as a platform. We'll use what we've learned so far as a foundation to explore game design concepts and development processes, investigate performance considerations, and introduce JavaScript-based game networking.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Game design for the Web</h1></div></div></div><p>Building games based on <a class="indexterm" id="id517"/>WebGL that match or exceed console quality should be<a class="indexterm" id="id518"/> possible, and doing so is a worthy goal. Additionally, building games for the Web presents an opportunity to take advantage of features that aren't possible for desktop and console games, although there are also a few drawbacks.</p><p>For example, you can build mechanics around having game data in URLs. Beyond just indicating save/load points, URLs could encode pickups, locations, random seeds, or other information. Add sharing to the mix and suddenly you have the ability for users to e-mail or tweet a link to their friends and have them drop instantly into the same point in your game. Unlike console games, web games can build on viral dynamics, the ubiquity of browsers, and low barriers to entry to attract more users and introduce new gameplay. You might imagine collaborative puzzle games that require a certain number of players to be completed—a concept that wouldn't be reliable for an expensive console game.</p><p>At the same time, gamers who buy an expensive console game are probably more likely to put in some effort to get over an initial learning curve. Unless users pay for your game up front, it's important to be conscious of the fact that users can leave your game just as easily as they arrived. Gaming has always been about balancing difficulty with engagement; it's the same formula, but it's more important than ever to consider the amount of time between hitting your landing page and that first taste of sweet satisfaction.</p><p>Web-based games also benefit from a strong tradition of APIs and integrations. Of course console games can also use APIs, but by definition, web-based games can typically rely on players having an Internet connection, so you can imagine gameplay elements such as imagery from Google Earth, location names and tips based on Foursquare data, and AI characters who actively use social networks. In particular, you can easily integrate payment processing into your games, perhaps even superimposed over a cash register or ATM, and reasonably expect that many users will have access to a keyboard that will let them type in their credit card information more easily than they could with a joystick. This opens the door to non-traditional payment methods that don't require charging up-front for games, more akin to the way mobile games often make money from in-app sales.</p><p>Additionally, webcam and<a class="indexterm" id="id519"/> microphone access is growing rapidly among laptop<a class="indexterm" id="id520"/> users, and Chrome and Firefox now support these peripherals with the WebRTC API. Potential uses of this technology go beyond simple chatting. Ambient sound could be detected and used to adjust the tempo of game music. With some machine vision or perhaps a Leap Motion device, users could interact directly with the game by waving their hands instead of manipulating a mouse. Imagine a game of Roller Coaster Tycoon where you could literally pick up visitors and fling them to the other side of your park! There are lots of other cool uses for machine vision as well. <em>John Carmack</em> (lead programmer of Doom and Quake among other iconic games) recently suggested running garbage collection when the user blinks. Research at MIT has shown that webcam video can be used to accurately identify visitors' heart rates, which could allow games to adjust their pace to match (or compensate for) users' excitement (<a class="ulink" href="http://people.csail.mit.edu/mrub/vidmag/">http://people.csail.mit.edu/mrub/vidmag/</a>). And hand-tracking technology is already being used for 3D modeling, game development, and even rocket design.</p><p>Other external devices such as the Oculus Rift augmented reality headset can be supported for deeper integration into your environment. (Three.js actually includes a controller for the Oculus Rift in the <code class="literal">examples/js/controls</code> folder). For example, mobile phones can be used as controllers for web games as described at <a class="ulink" href="http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game">http://cykod.com/blog/post/2011-08-using-nodejs-and-your-phone-to-control-a-browser-game</a> and <a class="ulink" href="http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/">http://blog.artlogic.com/2013/06/21/phone-to-browser-html5-gaming-using-node-js-and-socket-io/</a>. Experimental support for traditional USB game controllers exists in some browsers as well; one library to help with that is available at <a class="ulink" href="http://www.gamepadjs.com/">http://www.gamepadjs.com/</a>. Phones and tablets could even be used as an additional screen—perhaps for a minimap, inventory list, or rearview mirror.</p><p>That said, because the Web is universally available, consider what devices may be accessing your game and what constraints they may have. Varied screen sizes and resolutions are nothing new, but touch controls in particular can present challenges for 3D games. Still, applying traditional web development techniques to games can yield creative solutions. For instance, taking the approach of graceful degradation / progressive enhancement, mobile users could be delivered a spectator view or some other reduced version of the game. Alternatively, you could provide onscreen controls when keyboards and mice aren't available, perhaps with the HTML5 Virtual Game Controller library (<a class="ulink" href="https://github.com/austinhallock/html5-virtual-game-controller">https://github.com/austinhallock/html5-virtual-game-controller</a>).</p><p>One final point to <a class="indexterm" id="id521"/>think about: Three.js-driven games can integrate smoothly with <a class="indexterm" id="id522"/>existing websites. For example, most games need menus, and it's much easier to create them in HTML than in 3D. Don't feel like your entire application needs to display exclusively on the canvas. On the other hand, if you want to get creative, you can actually embed HTML inside your Three.js environment. You can read more about how to do this at <a class="ulink" href="http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/">http://learningthreejs.com/blog/2013/04/30/closing-the-gap-between-html-and-webgl/</a> and <a class="ulink" href="http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/">http://jensarps.de/2013/07/02/html-elements-in-webgl-recursion/</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Performance</h1></div></div></div><p>In some ways, performance considerations<a class="indexterm" id="id523"/> for 3D games in browsers are pretty similar to those for consoles and desktop games. The biggest difference is that all resources must (at least initially) be streamed to the client instead of read from a disk. For complex 3D games with gigabytes of assets, overcoming this limitation for low-bandwidth clients can be a serious challenge.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>As legendary programmer <em>Donald Knuth</em> wrote:</p><div><blockquote class="blockquote"><p>"Premature optimization is the root of all evil."</p></blockquote></div><p>This section discusses best practices and suggestions to get great performance out of your game, but before expending significant effort, you should measure and test your application to see where the bottlenecks are and whether the effort is worthwhile.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl2sec27"/>Bandwidth/network constraints</h1></div></div></div><p>To combat<a class="indexterm" id="id524"/> bandwidth constraints<a class="indexterm" id="id525"/>, the first thing <a class="indexterm" id="id526"/>you should do is apply traditional optimizations which web developers have been using<a class="indexterm" id="id527"/> for years: compress the content your server sends with <code class="literal">gzip</code>, combine and minify JavaScript to minimize the number of requests the browser has to make to the server, optimize your images, enable the Keep-Alive header, serve assets from a limited number of domains, and use headers to leverage browser caching, among other techniques.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>Optimizing websites in general is a particularly detailed topic, but this section mostly sticks to explaining optimizations specifically for games. If you are interested in learning more about <strong>Web Performance Optimization</strong> (<strong>WPO</strong>)<a class="indexterm" id="id528"/>, start with these rules from Google and Yahoo!:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developers.google.com/speed/docs/best-practices/rules_intro">https://developers.google.com/speed/docs/best-practices/rules_intro</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://developer.yahoo.com/performance/rules.html">http://developer.yahoo.com/performance/rules.html</a></li></ul></div></div></div><p>However, complex games won't be able to rely on browser caching for user return visits because browsers have limits on the maximum amount of memory cached resources can consume across all websites. Your game's resources will be pushed out of the cache as the user navigates other websites,<a class="indexterm" id="id529"/> and the cache size may be too small for all your resources anyway. As a result, the next place to look for optimizations is caching inside of your game in order to<a class="indexterm" id="id530"/> minimize the number of server requests that need to be made. This can be done in three ways. First, you can store resources in other caches. The IndexedDB API<a class="indexterm" id="id531"/> (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/IndexedDB">https://developer.mozilla.org/en-US/docs/IndexedDB</a>) supports storing files, and the Web Storage API (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage">https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#localStorage</a>) supports storing strings (including JSON, so you can store exported Three.js objects). Chrome also supports the FileSystem API<a class="indexterm" id="id532"/> (<a class="ulink" href="http://www.html5rocks.com/en/tutorials/file/filesystem/">http://www.html5rocks.com/en/tutorials/file/filesystem/</a>) which can manage a sandboxed local filesystem.<a class="indexterm" id="id533"/> Second, you can reduce the total number of resources you need by generating some<a class="indexterm" id="id534"/> of them on the client. For example, if you need similar textures in different colors, it might make sense to modify those textures dynamically on the client rather than ask the server for multiple images. Or, if you can describe the way a mesh should animate with a system of equations, you might consider manually animating it on the client instead of sending animation data. Third, you can make sure your code is structured in a way that allows reusing resources instead of requesting them repeatedly. For example, if two meshes use the same texture, you should try to load the texture once instead of twice.</p><p>Finally, you can use a binary format for imported meshes that has a higher compression ratio than standard text-based files in order to reduce the size of assets the server needs to send to the client. To do so, you should export your meshes to Wavefront OBJ / MTL files, and then use the converter script at <code class="literal">utils/converters/obj/convert_obj_three.py</code> to generate a file that the <code class="literal">THREE.BinaryLoader</code> can import. (Instructions for running the script are at the top of the file.)</p><p>In addition to reducing the total size of resources that need to be retrieved from a server, you can try to load as much data as possible while the user doesn't need to see it. For example, if players enter your game from a menu, you may be able to start loading while the player is navigating the menu rather than waiting until they click to start the game. You can also wait to load parts of your scene that won't be visible initially until after the player has entered the game, in order to let the player start playing as quickly as possible. For example, linear mission-based<a class="indexterm" id="id535"/> games can wait to load parts of the map until the<a class="indexterm" id="id536"/> player reaches certain checkpoints. Just make sure you have a fallback plan if resources are loading slowly and the player reaches your unloaded area too early. You might want to have a door that won't open until the resources are loaded. You could also just pause the game momentarily when <a class="indexterm" id="id537"/>the player is in a<a class="indexterm" id="id538"/> transitional location.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl2sec28"/>Level of detail</h1></div></div></div><p>Similarly, you can load low-poly meshes and low-resolution textures when the user starts playing the game and replace them with higher-detail assets during gameplay, either when the larger assets are loaded or when the user gets close enough to them to see the improved detail. The<a class="indexterm" id="id539"/> latter technique is called <strong>Level-of-Detail</strong> (<strong>LOD</strong>),<a class="indexterm" id="id540"/> and Three.js has built-in support for it using the <code class="literal">THREE.LOD</code> object<a class="indexterm" id="id541"/>. For example, we could modify the spinning shape example we built in <a class="link" href="ch01.html" title="Chapter 1. Hello, Three.js">Chapter 1</a>, <em>Hello, Three.js</em>, to change the detail of our sphere depending on how close to it we are. First we need to change how we add the mesh to the scene:</p><div><pre class="programlisting">geometry = [
  [new THREE.IcosahedronGeometry(200, 4), 50],
  [new THREE.IcosahedronGeometry(200, 3), 300],
  [new THREE.IcosahedronGeometry(200, 2), 1000],
  [new THREE.IcosahedronGeometry(200, 1), 2000],
  [new THREE.IcosahedronGeometry(200, 0), 8000],
];
material = new THREE.MeshNormalMaterial();

lod = new THREE.LOD();
for (var i = 0; i &lt; geometry.length; i++) {
  var mesh = new THREE.Mesh(geometry[i][0], material);
  lod.addLevel(mesh, geometry[i][1]);
}
scene.add(lod);</pre></div><p>The <code class="literal">LOD</code> object<a class="indexterm" id="id542"/> stores objects of different complexities along with the distances at which higher-detail versions should be used. To make the mesh change detail when the camera moves closer or farther away, we'll update the <code class="literal">LOD</code> object in the animation loop:</p><div><pre class="programlisting">scene.traverse(function(object) {
  if (object instanceof THREE.LOD) {
    object.position.z = 2500 * Math.cos(Date.now() / 1000);
    object.update(camera);
  }
});</pre></div><p>We added a little bit of movement here so that we can see the detail change. Let's move the camera so that we <a class="indexterm" id="id543"/>can see the movement better by setting <code class="literal">camera.position.z = 3000</code>. Now you should be able<a class="indexterm" id="id544"/> to see the detail change dynamically, as shown in the following screenshot:</p><div><img alt="Level of detail" src="img/8539_05_01.jpg"/><div><p>A sphere with increasing detail as the camera gets closer</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl2sec29"/>Rendering optimizations</h1></div></div></div><p>Three.js has built-in support for <a class="indexterm" id="id545"/>other detail-related optimizations as well in order to make processing faster. <strong>Culling</strong><a class="indexterm" id="id546"/>, the process of excluding hidden objects from rendering, is a common example. Three.js does <strong>view frustum culling</strong><a class="indexterm" id="id547"/> based on bounding spheres, meaning it will avoid spending valuable compute time calculating visual information about objects that are off screen. It also does <strong>backface culling</strong><a class="indexterm" id="id548"/> by default, which hides the back side of mesh faces. However, it doesn't do <strong>occlusion culling</strong><a class="indexterm" id="id549"/>, meaning it doesn't know not to render an object that is in front of the camera but obscured by another object that is closer to the camera. The implication of these optimizations is that large meshes should often be split into several smaller ones to reduce computation if only part of the large mesh is on the screen, and you don't get any benefits by default from having short viewable distances. This simple change might be sufficient for top-down games where few objects are obscured by other objects. Other games, such as first-person shooters where buildings or terrain can block long view distances, may need to compensate in other ways. For example, if you have really large or detailed worlds, you may want to work on manual occlusion culling. Game engines typically do this using a technique called <strong>depth testing</strong><a class="indexterm" id="id550"/>, but a simpler approach that can work for enclosed layouts (such as the insides of buildings) is to create invisible cubes encompassing different zones in the world based on view distances and then toggle the visibility of meshes inside those zones when the player gets close enough.</p><p>We've already discussed the advantages of merging geometry in <a class="link" href="ch02.html" title="Chapter 2. Building a World">Chapter 2</a>, <em>Building a World</em>, but you can get additional performance benefit out of transforming static geometry into <code class="literal">BufferGeometry</code>. <code class="literal">BufferGeometry</code> typically renders faster than standard <code class="literal">Geometry</code> because it uses a data structure that is closer to what will get passed to the GPU instead of one that is<a class="indexterm" id="id551"/> easy for humans to understand. As a result, it is harder to manipulate, but it works well if you know your geometry won't change. The easiest way to use <code class="literal">BufferGeometry</code> is to convert from existing <code class="literal">Geometry</code> using the utility in <code class="literal">examples/js/BufferGeometryUtils.js</code>:</p><div><pre class="programlisting">THREE.BufferGeometryUtils.fromGeometry(geometry);</pre></div><p>You can use the result with meshes the same way you would use normal geometry.</p><p>Another powerful optimization is changing the resolution of the canvas. Assuming <code class="literal">renderer</code> and <code class="literal">camera</code> are globals, you can use this function to do so:</p><div><pre class="programlisting">var resize = (function() {
  var canvas = renderer.domElement;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  var originalWidth = canvas.width;
  var originalHeight = canvas.height;
  return function(scale) {
    canvas.width = Math.round(originalWidth*scale);
    canvas.height = Math.round(originalHeight*scale);
    camera.aspect = canvas.width / canvas.height;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.width, canvas.height);
  }
})();</pre></div><p>You can use this function by calling <code class="literal">resize(0.5)</code>, for example, which will allow the renderer to paint only <code class="literal">0.5*0.5 = 25%</code> of the pixels it would paint at full resolution, even though the canvas will take up the same amount of space on the screen. (The <code class="literal">scale</code> parameter<a class="indexterm" id="id552"/> is always relative to the canvas' original size.) This works because canvases are basically just images. In the same way that you can style an image to be larger in CSS without changing its actual size, you can style a canvas to be larger too. In our <code class="literal">resize</code> function<a class="indexterm" id="id553"/>, we first reduce the actual size of the canvas by changing its <code class="literal">width</code> <a class="indexterm" id="id554"/>and <code class="literal">height</code> attributes<a class="indexterm" id="id555"/>, then scale it back up using the CSS width and height styles. The result is that the canvas takes up the same amount of screen space that it did originally, but each actual pixel is displayed larger. This significantly reduces the amount of computation required to render a scene, although the <a class="indexterm" id="id556"/>scene will be blurrier.</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>Changing the resolution of the canvas affects how you need to compute where the user clicks. You should track the canvas' current scale and adjust the screen-space vector in our click method from <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em>, accordingly:</p><div><pre class="programlisting">  var vector = new THREE.Vector3(
    scale *  renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
    scale * -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
    0.5
    );</pre></div></div></div><p>Techniques that compromise visual detail in favor of speed are especially useful when combined with frame-rate testing. If the frame rate dips below a certain threshold for more than a given percent of the time in a certain testing period, you may want to reduce your game's detail. (You should figure out what your bottleneck is before implementing this approach. If your frame rates are low because your physics loop takes a long time to run, reducing visual detail may not help much.)</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>If physics is your bottleneck, you can run your physics at a lower frame rate than your rendering as discussed in <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em>. You may also want to consider using the Web Worker API (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers">https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers</a>) to execute JavaScript code in parallel. This can allow calculating movement and collision without blocking the rendering. The Physi.js library introduced in <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em>, does this automatically.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl2sec30"/>Battery life and GPU memory</h1></div></div></div><p>Although bandwidth/network speed and <a class="indexterm" id="id557"/>processing time are the factors that usually affect the performance of Three.js games the most, battery life and memory <a class="indexterm" id="id558"/>constraints may also come into play. For hardcore games, you may be able to assume the user is plugged in, but more casual games should be aware that more processing typically equates to more battery drain. On the memory front, the question is less about storage space and more about the graphics card having a limited amount of embedded memory with which it can perform fast computations. The main thing you can do to limit how much of the GPU's onboard memory you consume is to use compressed textures. (Normally, images such as JPGs and PNGs are decompressed before being sent to the GPU, but compressed textures use a special format that allows the GPU to hold them in embedded memory in a compressed state. Since the compression only matters for the GPU, it doesn't actually save network bandwidth.) Three.js supports compressed textures in DDS format. You can import DDS textures into Three.js like this:</p><div><pre class="programlisting">var texture = <code class="literal">THREE.ImageUtils.loadCompressedTexture(imagePath)</code>;</pre></div><p>The resulting <code class="literal">texture</code> value can be treated the same way normal images are treated; you can use it as the value for the <code class="literal">map</code> property<a class="indexterm" id="id559"/> of materials, for example, and Three.js will automatically know how to handle it.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>To create DDS images, you can use a plugin for Gimp (<a class="ulink" href="https://code.google.com/p/gimp-dds/">https://code.google.com/p/gimp-dds/</a>) or Photoshop (<a class="ulink" href="https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop">https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop</a>).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl2sec31"/>Performance-measuring tools</h1></div></div></div><p>Finally, there are a number of useful tools for measuring JavaScript performance. Conveniently, the original <a class="indexterm" id="id560"/>author of Three.js has written a library called Stats.js<a class="indexterm" id="id561"/> (<a class="ulink" href="https://github.com/mrdoob/stats.js">https://github.com/mrdoob/stats.js</a>) for tracking frame rates, the most crucial performance statistic for games. For comprehensive tracing, Google's Web Tracing Framework<a class="indexterm" id="id562"/> (<a class="ulink" href="http://google.github.io/tracing-framework/index.html">http://google.github.io/tracing-framework/index.html</a>) is hard to beat, and it even has an example for tracing a WebGL game. You can also easily get some statistics about onscreen geometry with the RenderStats library<a class="indexterm" id="id563"/> from <em>Jerome Etienne</em> (<a class="ulink" href="https://github.com/jeromeetienne/threex.rendererstats">https://github.com/jeromeetienne/threex.rendererstats</a>).</p><p>For brute-force debugging, you may also want to try the console-extras library, which makes it easier to log information about things that happen in the main game loop without dumping thousands <a class="indexterm" id="id564"/>of messages (<a class="ulink" href="https://github.com/unconed/console-extras.js">https://github.com/unconed/console-extras.js</a>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Networking and multiplayer</h1></div></div></div><p>Game networking<a class="indexterm" id="id565"/> is hard because the goal of networking is to keep game state in sync across multiple devices, but network latency prevents devices from communicating<a class="indexterm" id="id566"/> fast enough to keep that state from being<a class="indexterm" id="id567"/> occasionally inconsistent. Additionally, floating point rounding errors create indeterminate results across devices for the same set of input (this is where the timing and movement techniques discussed in <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em> come into play, since small differences in precision can result in huge differences over time). As a result, networking code becomes a process of reconciling differences.</p><p>There are basically two different approaches<a class="indexterm" id="id568"/> to networking depending on the requirements of the game. RTS and turn-based games usually use an approach called<a class="indexterm" id="id569"/> <strong>lock-step</strong><a class="indexterm" id="id570"/>, which is a peer-to-peer model in which each computer in a match sends its commands to<a class="indexterm" id="id571"/> all the other computers in the match. The main strength of this model is that only a small amount of data (the players' commands) needs to be sent over the network, so it is useful when the game state is huge (for example, when there are thousands of units in a map). However, running a game in lock-step depends on all players having an identical copy of the game state, which is a great idea in theory but is difficult to maintain for several reasons. First, although the JavaScript specification states that floating point calculations should be deterministic, in practice there may be subtle differences across implementations that could prevent clients from being in sync.</p><p>Second, all clients will see the game run at the speed of the most-latent client because commands from each player must be collected before advancing in order to ensure synchronicity. As a result, extra precautions must be taken to keep clients from cheating by pretending to have higher latency and waiting for the other computers' commands before making a decision. The latency issue also creates trouble when one machine is taking a particularly long time to return a command. In such a situation, the game may have to drop that player. Since the reason for using lock-step is that the entire game state is too large to transfer over the network while maintaining synchronicity, it may not be feasible for a player to join (or re-join) after a game has already started.</p><p>The other approach to game networking is a client-server prediction model<a class="indexterm" id="id572"/>
<a class="indexterm" id="id573"/>, which<a class="indexterm" id="id574"/> usually works like this:</p><div><ol class="orderedlist arabic"><li class="listitem">The client triggers some input (such as pressing a key or moving the mouse) that changes the game state.</li><li class="listitem">The client input is sent to the server.</li><li class="listitem">Optionally, the server forwards the input to the other clients.</li><li class="listitem">The server processes the inputs it receives from all players, reconciles them, and produces a new, authoritative description of the game's state at a specific time.</li><li class="listitem">If the server forwarded other clients' inputs, the clients receive those inputs and continue updating the local game state by predicting what the server thinks the state should be.</li><li class="listitem">The server periodically sends the latest complete description of the authoritative game state to each client.</li><li class="listitem">The client adjusts its state to sync with the server's official state.</li></ol></div><p>The main difference here<a class="indexterm" id="id575"/> compared to <a class="indexterm" id="id576"/>lock-step is that clients can advance the game independently, and the entire game state can be sent from the server to ensure each player sees something pretty close to what the others see. This is a better model for action games like FPSs or games with many players like MMOs because players generally experience less dramatic latency effects.</p><p>To reduce the lag that gamers can feel, we design the client-server communication to be asynchronous because waiting for the new game state from the server can take a long time due to network latency. Since we try to keep running the game locally while we wait for the server, we need to adjust the client when we do finally get an authoritative update from the server. Adjusting the client can be tricky, though. First of all, by the time we get a response from the server, the state it sends us will be in the past. To deal with this, we'll need to keep track of all player input since <a class="indexterm" id="id577"/>the last time we got an official server update, rewind the game to the newly received authoritative game state, and then replay any more recent input on top of that. The result will be our latest guess of what the server thinks the game state should be at the current time, which will likely be slightly different than what we've actually been showing the <a class="indexterm" id="id578"/>player. We could just snap the current game state to our ideal game state, but that would make the game seem jittery since things might <a class="indexterm" id="id579"/>spontaneously teleport. Instead, if the differences between states are small enough, clients should interpolate between their current state and their projected ideal state. If we drift too far away, we can snap back to the server state, but otherwise we'll lag a few frames in order to ensure smoothness. Snapping happens most often with complex physics interactions or when players collide.</p><p>Ideally, we'd like to just send players' inputs to the clients because they're smaller than the full game state (so they take up fewer network packets). This might be the only sane way to handle MMO games with potentially thousands of players. However, this can cause drifting over time due to floating point rounding error, so it may not be accurate enough to be the only solution for intense action games like first-person shooters. As a compromise, inputs can be sent frequently and the full game state sent only periodically; then clients can use the inputs to predict how the game should progress.</p><p>Of course, not all physics is driven by user input. If your game has gameplay-affecting nature-driven physics such as wind or avalanches, you may need to have the server simulate the physics without client prediction, and clients will just have to deal with some latency. On the other hand, you can simulate some physics entirely on the client. For example, it doesn't really matter if the clouds in the sky are in exactly the same position on each client since they're typically just decorative.</p><p>The game state tracked by the server<a class="indexterm" id="id580"/> usually includes, at a minimum,<a class="indexterm" id="id581"/> the position and velocity of all movable actors, a unique identifier for the version of the state, and a timestamp. The server does not need to send a full scene<a class="indexterm" id="id582"/> export to every client since that would be too expensive. However, the server does need to simulate the full scene in order to accurately update the game state.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>For more information on lock-step, check out <a class="ulink" href="http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/">http://www.altdevblogaday.com/2011/07/09/synchronous-rts-engines-and-a-tale-of-desyncs/</a> and <a class="ulink" href="http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/">http://www.altdevblogaday.com/2011/07/24/synchronous-rts-engines-2-sync-harder/</a>.</p><p>For more information about client-server prediction, check out <a class="ulink" href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/">http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/</a>.</p><p>To learn about interpolating between authoritative and client states, see <a class="ulink" href="http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914">http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/defeating-lag-with-cubic-splines-r914</a>.</p><p>There is a great Google Tech Talk by <em>Rob Hawkes</em> on HTML5 multiplayer game development with many tips about overcoming common pitfalls. You can watch it at <a class="ulink" href="https://www.youtube.com/watch?v=zj1qTrpuXJ8">https://www.youtube.com/watch?v=zj1qTrpuXJ8</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Technologies</h2></div></div></div><p>The Web Sockets API<a class="indexterm" id="id583"/> (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/WebSockets">https://developer.mozilla.org/en-US/docs/WebSockets</a>) is the<a class="indexterm" id="id584"/> most practical way to maintain a fast connection with a game server in JavaScript, and the easiest way to use web sockets is to use node.js (<a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a>) on the server with the socket.io library (<a class="ulink" href="http://socket.io/">http://socket.io/</a>). Node.js allows JavaScript to be a first-class server-side language, so you can write your game code once and worry less about differences between the server-side and client-side simulations. It's also mentally easier to write both the server-side and client-side code in a single language.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Web sockets are the best we can do at the moment because JavaScript doesn't have as much control over how it accesses the Internet as desktop and console games do, for security reasons. Web sockets are actually reasonably good, but they are based on <strong>TCP</strong><a class="indexterm" id="id585"/>, which is a common way to access the Internet that ensures reliability but occasionally causes delays. Many desktop and console games that use client-server prediction use <strong>UDP</strong><a class="indexterm" id="id586"/> to access the Internet instead, which serves the same purpose as TCP but compromises data-integrity guarantees in favor of minimal delays.</p></div></div><p>Voxel.js (<a class="ulink" href="http://voxeljs.com/">http://voxeljs.com/</a>) is a good example of a networked game framework using Three.js. If you are building a Minecraft-style game, it is a great place to start. For more information and code examples<a class="indexterm" id="id587"/> on writing game networking code in JavaScript with Socket.io and Node.js, there is a good article at <a class="ulink" href="http://buildnewgames.com/real-time-multiplayer/">http://buildnewgames.com/real-time-multiplayer/</a>. It uses a 2D game as an example, but everything applies cleanly to 3D games as well.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Anticheating</h2></div></div></div><p>Stopping cheaters in multiplayer games is a hard problem in general, and it's particularly difficult in JavaScript for three reasons. One, it's very difficult to detect whether client input is automated or their display has changed illegally; two, JavaScript code is relatively hard to obfuscate and validate without significant performance penalties; and three, cheating programs can directly and easily override your client code. As a result, anticheating efforts typically focus on moving as much logic as possible from the client to the server, detecting unusual patterns of client activity, minimizing the benefits of cheating, and perhaps creating just enough annoying barriers to cheating that some aspiring cheaters give up. <a class="indexterm" id="id588"/>Common methods include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Only letting the client send whitelisted inputs to the server, not arbitrary values; this allows a trusted computer (the server) to do important calculations and avoids letting cheaters make illegal requests such as <code class="literal">addPoints(1000000)</code></li><li class="listitem" style="list-style-type: disc">Tracking how long the user plays the game; if a user plays for 48 hours straight, they're worth investigating</li><li class="listitem" style="list-style-type: disc">Tracking the amount of time that passes between user actions; if a user clicks on the same part of the screen every 10 minutes (suspiciously accurate) or 16 milliseconds (suspiciously fast), they might be automating their behavior</li><li class="listitem" style="list-style-type: disc">Reporting snapping, the behavior in first-person shooters of instantly turning to shoot at a target as soon as there is nothing in the way, even when that target wasn't onscreen, and never missing</li><li class="listitem" style="list-style-type: disc">Making debugging harder, for example by disabling console logging (<code class="literal">console = {}</code>) and wrapping your entire client-side code in a closure to prevent any global variables from being easily available to cheaters' scripts</li><li class="listitem" style="list-style-type: disc">Making it easy for users to report abuse</li></ul></div><p>This is certainly not an<a class="indexterm" id="id589"/> exhaustive list, and it's very difficult to stop cheaters entirely, but these suggestions are a reasonable place to start.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>It's generally considered poor form to prevent client-side cheating in single-player modes, except when it comes to artifacts that other players can see, such as high scores.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Development processes</h1></div></div></div><p>Whether you're an individual who builds games as a hobby or a developer for a large game publisher, you can benefit from following a number of best practices adopted from JavaScript development for the Web and game development on other platforms. You can also build Three.js-based games without deviating too far from your favorite game development processes.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>JavaScript best practices</h2></div></div></div><p>In previous chapters, we haven't been very concerned with the high-level structure of our code. We wrote some<a class="indexterm" id="id590"/> examples as single HTML files, and we split the FPS and CTF projects into separate files, but for polished games we should be more careful, especially when working with teams. General coding lessons apply:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keep assets in folders by file type/purpose. For example, at a high level you might have folders such as <code class="literal">css</code>, <code class="literal">js</code>, <code class="literal">images</code>, <code class="literal">models</code>, and <code class="literal">sounds</code>. Within the <code class="literal">js</code> folder, organize JavaScript files by purpose; keep library, source, and production code separate.</li><li class="listitem" style="list-style-type: disc">Avoid putting code that directly handles user input event listeners in class constructors, because that makes them harder to reuse and extend.</li><li class="listitem" style="list-style-type: disc">Use separate files for configuration/constants that you can fiddle with to adjust how the game <em>feels</em>.</li><li class="listitem" style="list-style-type: disc">Detect features instead of browsers, since different browser versions support different features and some features can be toggled on or off in browser settings.</li><li class="listitem" style="list-style-type: disc">Avoid using <code class="literal">setTimeout</code> and <code class="literal">setInterval</code> for timers in the animation loop because having a lot of separate timers can cause performance issues. Instead, check how much time has passed in your animation loop, for example, using <a class="indexterm" id="id591"/><code class="literal">Date.now()</code> or <code class="literal">THREE.Clock</code>.<div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>If your game can pause, make sure you're not including time elapsed while paused.</p></div></div></li><li class="listitem" style="list-style-type: disc">Though it may feel natural to write the entire application in JavaScript, try to avoid creating new DOM in JavaScript. Doing so is slow, and there's a reason HTML and CSS exist. (Also, don't be afraid to use HTML and CSS; sometimes that's a much easier solution than, say, writing a custom shader.)</li><li class="listitem" style="list-style-type: disc">Use a style guide. Which one you choose is not especially important, but maintaining a consistent style helps avoid silly mistakes that are otherwise vulnerable to JavaScript's dynamic typing and expressive syntax.</li><li class="listitem" style="list-style-type: disc">JavaScript's prototypal inheritance tends to feel strange to developers used to classical object-oriented programming. The main advantages are that it's dynamic (you can add<a class="indexterm" id="id592"/> new properties to prototypes and objects after they're created); there is no <em>diamond problem</em> (you never have ambiguities due to multiple ancestors); and it's simpler to just do what you want without rigid structures. We've seen that Three.js uses an inheritance pattern; you can also use OOP patterns in your code, and it helps to be aware of JavaScript's strengths in this regard instead of fighting with its weaknesses.</li></ul></div><p>Using Grunt<a class="indexterm" id="id593"/> (<a class="ulink" href="http://gruntjs.com/">http://gruntjs.com/</a>) is strongly recommended to simplify your publishing and testing workflow because it helps minimize the amount of time between making a change and testing it in action. Grunt<a class="indexterm" id="id594"/> is a command-line tool that executes predetermined tasks, so you can use it to easily perform other publishing steps. For example, production code should be minified, concatenated, and checked for syntax errors, which Grunt can do using the UglifyJS and JSHint projects. If your project is open source, big enough, or has enough people to need separate documentation, JSDuck<a class="indexterm" id="id595"/> (<a class="ulink" href="https://github.com/senchalabs/jsduck">https://github.com/senchalabs/jsduck</a>) is a useful tool to automatically generate it from code comments (and Grunt supports it too). You can find a great tutorial on getting started with Grunt at <a class="ulink" href="http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/">http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Existing workflows and level development</h2></div></div></div><p>Few changes should be <a class="indexterm" id="id596"/>needed to studios' existing game development pipelines in order to produce Three.js-based games. Some programmers may not even need to learn JavaScript if they're not already familiar with it since many languages compile to JavaScript. Existing processes can be maintained for testing and producing as well as for developing pitches, concepts, storyboards, models, textures, sounds, and<a class="indexterm" id="id597"/> other resources. The biggest challenge is in assembling those resources—building levels into Three.js scenes. There aren't amazing tools yet for designing levels for Three.js games that need them, partly because Three.js is a graphics library and games have a lot of custom requirements that are hard to generalize well for a single tool. Level editors tend to be tied pretty closely to the game engine and the classes it provides.</p><p>The original Three.js author has created a scene editor that you can try at <a class="ulink" href="http://mrdoob.github.io/three.js/editor/">http://mrdoob.github.io/three.js/editor/</a>. It is useful for small projects, but quickly becomes unwieldy for big ones (especially when multiple people need to work on a project at the same time). Also, the scene editor can't handle custom objects such as spawn points, so if you use it, at least part of each level will need to be defined in custom code.</p><p>As a result, if you need to create many levels or you need to do so visually, you will probably need to build your own scene layout tool. There are a few ways you could do this. First, the Three.js scene editor is part of the Three.js project (in the <code class="literal">editor</code> folder), so you could start with that and edit it. Second, you could try writing an exporter for an existing level development tool or a converter for its save files, then writing a custom Three.js loader. Third, you could try writing your own tool from scratch. The good news on that front is that once you've written one, you can use it again in other projects.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>Clearly, writing reusable components is helpful if you're going to build more than one Three.js project. Before writing your own components, you may want to check out two Three.js helper libraries by <em>Jerome Etienne</em>: an extension system called <strong>tQuery</strong><a class="indexterm" id="id598"/> and a series of utilities called <strong>THREEx</strong><a class="indexterm" id="id599"/>, available at <a class="ulink" href="http://jeromeetienne.github.io/tquery/">http://jeromeetienne.github.io/tquery/</a> and <a class="ulink" href="http://jeromeetienne.github.io/threex/">http://jeromeetienne.github.io/threex/</a>, respectively.</p></div></div><p>Voxel.js<a class="indexterm" id="id600"/> (<a class="ulink" href="http://voxeljs.com/">http://voxeljs.com/</a>) is a good example of a game engine with its own level editor. It also has a bunch of modules (including a multiplayer module) that you can plug in. It's designed for Minecraft-style games, but you might be able to use it as a starting point for other large-scale projects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we learned about designing and developing high-quality games for the Web. We covered aspects of game design and development that are unique to the Web, and how Three.js supports them; important performance considerations; and basic client-server and lock-step networking.</p><p>You are now prepared to embrace the next generation of gaming. Congratulations!</p></div></body></html>