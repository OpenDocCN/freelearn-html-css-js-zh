<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. The Ember.Object Model</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Working with classes and instances</li><li class="listitem">Working with computed properties</li><li class="listitem">Working with Ember observers in Ember.js</li><li class="listitem">Working with bindings</li><li class="listitem">Using mixins</li><li class="listitem">Using enumerables with arrays</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec17" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8"><strong class="calibre9">Ember.Object</strong> <a id="id59" class="calibre1"/>is the base class for almost every other Ember object. Routes, models, views, and components all inherit from Ember.Object. It's used everywhere so it's important to understand how it works and how it can be used in our application.</p><p class="calibre8">Standard JavaScript objects aren't used often in Ember. Ember's object model builds on JavaScript objects and adds important features such as observers, mixins, computed properties, and <a id="id60" class="calibre1"/>initializers. Many of these features are aligned to be in the new <strong class="calibre9">ECMAScript</strong> standard.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Working with classes and instances</h1></div></div></div><p class="calibre8">Creating and <a id="id61" class="calibre1"/>extending classes is a major feature of the Ember object model. In this recipe, we'll take a look at how creating and extending objects works.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec29" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Let's begin by creating a very simple <code class="email">Ember</code> class using <code class="email">extend()</code>:<div><pre class="programlisting">const Light = Ember.Object.extend({
  isOn: false
});</pre></div><p class="calibre14">This defines a new <code class="email">Light</code> class with a property called <code class="email">isOn</code>. <code class="email">Light</code> inherits properties and behavior from the Ember object, such as initializers, mixins, and computed properties.</p><div><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Ember Twiddle tip</strong></p><p class="calibre8">At any point of <a id="id62" class="calibre1"/>time, you might need to test out small snippets of the Ember code. An easy way to do this is to use a website called <a id="id63" class="calibre1"/>
<strong class="calibre9">Ember Twiddle</strong>. From this website, you can create an Ember application and run it in the browser as if you were using the Ember CLI. You can even save and share it. It has similar tools such as JSFiddle but only for Ember. Check it out at <a class="calibre1" href="http://ember-twiddle.com">http://ember-twiddle.com</a>.</p></div></li><li class="listitem" value="2">Once you have defined a class, you'll need to be able to create an instance of it. You can do this using the <code class="email">create()</code> method. We'll go ahead and create an instance of <code class="email">Light</code>:<div><pre class="programlisting">constbulb = Light.create();</pre></div></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec15" class="calibre1"/>Accessing properties within the bulb instance</h3></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">We <a id="id64" class="calibre1"/>can access <a id="id65" class="calibre1"/>the properties of the <code class="email">bulb</code> object using the <code class="email">set</code> and <code class="email">get</code> accessor methods. Let's go ahead and get the <code class="email">isOn</code> property of the <code class="email">Light</code> class:<div><pre class="programlisting">console.log(bulb.get('isOn'));</pre></div><p class="calibre14">The preceding code will get the <code class="email">isOn</code> property from the <code class="email">bulb</code> instance.</p></li><li class="listitem" value="2">To change the <code class="email">isOn</code> property, we can use the <code class="email">set</code> accessor method:<div><pre class="programlisting">bulb.set('isOn', true)</pre></div><p class="calibre14">The <code class="email">isOn</code> property will now be set to <code class="email">true</code> instead of <code class="email">false</code>.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec16" class="calibre1"/>Initializing the Ember object</h3></div></div></div><p class="calibre8">The <a id="id66" class="calibre1"/>
<code class="email">init</code> method is invoked whenever a <a id="id67" class="calibre1"/>new instance is created. This is a great place to put in any code that you may need for the new instance.</p><div><ol class="orderedlist"><li class="listitem" value="1">In our example, we'll add an alert message that displays the default setting for the <code class="email">isOn</code> property:<div><pre class="programlisting">const Light = Ember.Object.extend({
  init(){
    alert('The isON property is defaulted to ' + this.get('isOn'));
  },
  isOn: false
});</pre></div></li><li class="listitem" value="2">As soon as the <code class="email">Light.create</code> line of code is executed, the instance will be created and <strong class="calibre9">The isON property is defaulted to false</strong> message will pop up on the screen.<div><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Subclass</strong></p><p class="calibre8">Be aware <a id="id68" class="calibre1"/>that you can create subclasses of <a id="id69" class="calibre1"/>your objects in Ember. You can override methods and access the parent class using the <code class="email">_super()</code> keyword method. This is done by creating a new object that uses the Ember <code class="email">extend</code> method on the parent class.</p><p class="calibre8">Another important thing is if you're subclassing a framework class such as <code class="email">Ember.Component</code> and you override the <code class="email">init</code> method, you'll need to make sure that you call <code class="email">this._super()</code>. If not, the component might not work properly.</p></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec17" class="calibre1"/>Reopening classes</h3></div></div></div><p class="calibre8">At any time, you <a id="id70" class="calibre1"/>can reopen a class and define new properties or methods in it. For this, use the <code class="email">reopen</code> method.</p><p class="calibre8">In our previous example, we had an <code class="email">isON</code> property. Let's reopen the same class and add a <code class="email">color</code> property:</p><div><ol class="orderedlist"><li class="listitem" value="1">To add the <code class="email">color</code> property, we need to use the <code class="email">reopen()</code> method:<div><pre class="programlisting">    Light.reopen({
      color: 'yellow'
    });</pre></div></li><li class="listitem" value="2">If needed, you can add static methods or properties using <code class="email">reopenClass</code>:<div><pre class="programlisting">Light.reopenClass({
  wattage: 80
});</pre></div></li><li class="listitem" value="3">You can now access the static property <code class="email">Light.wattage</code>.</li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec30" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">In the previous examples, we created an Ember object using <code class="email">extend</code>. This tells Ember to create a new <code class="email">Ember</code> class. The <code class="email">extend</code> method uses inheritance in the Ember.js framework. The <code class="email">Light</code> object inherits all the methods and bindings of the Ember object.</p><p class="calibre8">The <code class="email">create</code> <a id="id71" class="calibre1"/>method also inherits from the Ember object class and returns a new instance of this class. The <code class="email">bulb</code> object is a new instance of the Ember object that we created.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec31" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">To use the previous examples, we can create our own module and import it to our project.</p><div><ol class="orderedlist"><li class="listitem" value="1">To do this, create a new file in the <code class="email">app</code> folder called <code class="email">MyObject.js</code>:<div><pre class="programlisting">// app/myObject.js
import Ember from 'ember';
export default function() {
    const Light = Ember.Object.extend({
      init(){
        alert('The isON property is defaulted to ' +this.get('isOn'));
      },
      isOn: false
    });

    Light.reopen({
      color: 'yellow'
    });

    Light.reopenClass({
      wattage: 80
    });

    const bulb = Light.create();

    console.log(bulb.get('color'));
    console.log(Light.wattage);
}</pre></div><p class="calibre14">This is a module that we can now import to any file in our Ember application.</p></li><li class="listitem" value="2">In the <code class="email">app</code> folder, edit the <code class="email">app.js</code> file. You'll need to add the following line at the top of the file:<div><pre class="programlisting">// app/app.js
import myObject from './myObject';</pre></div></li><li class="listitem" value="3">At the bottom, before the export, add this line:<div><pre class="programlisting">myObject();</pre></div><p class="calibre14">This will execute the <code class="email">myObject</code> function that we created in the <code class="email">myObject.js</code> file. After running  <code class="email">ember server</code>, you'll see the <code class="email">isOn</code> property <a id="id72" class="calibre1"/>defaulted to a <code class="email">false</code> popup message.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Working with computed properties</h1></div></div></div><p class="calibre8">In this <a id="id73" class="calibre1"/>recipe, we'll take a look at computed properties and how they can be used to display data, even if that data changes as the application is running.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec32" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Let's create a new Ember.Object and add a computed property to it:</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's begin by creating a new <code class="email">description</code> computed property. This property will reflect the status of the <code class="email">isOn</code> and <code class="email">color</code> properties:<div><pre class="programlisting">const Light = Ember.Object.extend({
  isOn: false,
  color: 'yellow',

  description: Ember.computed('isOn','color',function() {
    return 'The ' + this.get('color') + ' light is set to ' + this.get('isOn');
  })

});</pre></div></li><li class="listitem" value="2">We can now create a new <code class="email">Light</code> object and get the computed property <code class="email">description</code>:<div><pre class="programlisting">const bulb = Light.create();
bulb.get('description'); //The yellow light is set to false</pre></div><p class="calibre14">The preceding example creates a computed property that depends on the <code class="email">isOn</code> and <code class="email">color</code> properties. When the <code class="email">description</code> function is called, it returns a string describing the state of the light.</p><p class="calibre14">Computed properties will observe changes and dynamically update whenever they occur.</p></li><li class="listitem" value="3">To see this in action, we can change the preceding example and set the <code class="email">isOn</code> property to <code class="email">false</code>. Use the following code to accomplish this:<div><pre class="programlisting">bulb.set('isOn', true);
bulb.get('description') //The yellow light is set to true</pre></div><p class="calibre14">The description <a id="id74" class="calibre1"/>has been automatically updated and will now display <code class="email">The yellow light is set to true</code>.</p></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec18" class="calibre1"/>Chaining the Light object</h3></div></div></div><p class="calibre8">Ember provides <a id="id75" class="calibre1"/>you with a nice feature that allows computed properties to be present in other computed properties. In the previous example, we <a id="id76" class="calibre1"/>created a <code class="email">description</code> property that outputted some basic information about the <code class="email">Light</code> object.</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's add another property that gives a full description:<div><pre class="programlisting">const Light = Ember.Object.extend({
  isOn: false,
  color: 'yellow',
  age: null,

  description: Ember.computed('isOn','color',function() {
    return 'The ' + this.get('color') + ' light is set to ' + this.get('isOn');
  }),

  fullDescription: Ember.computed('description','age',function() {
    return this.get('description') + ' and the age is ' + this.get('age')
  }),

});</pre></div></li><li class="listitem" value="2">The <code class="email">fullDescription</code> function returns a string that concatenates the output from the description with a new string that displays <code class="email">age</code>:<div><pre class="programlisting">const bulb = Light.create({age:22});
bulb.get('fullDescription'); //The yellow light is set to false and the age is 22</pre></div><p class="calibre14">In this example, during the instantiation of the <code class="email">Light</code> object, we set the <code class="email">age</code> to <code class="email">22</code>. We could have overwritten any property if necessary.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec19" class="calibre1"/>Alias</h3></div></div></div><p class="calibre8">The <code class="email">Ember.computed.alias</code> method allows us to create a property that is an alias for another <a id="id77" class="calibre1"/>property or object.</p><div><ol class="orderedlist"><li class="listitem" value="1">Any call to <code class="email">get</code> or <code class="email">set</code> will behave as if the changes were made to the original property:<div><pre class="programlisting">const Light = Ember.Object.extend({
  isOn: false,
  color: 'yellow',
  age: null,
  description: Ember.computed('isOn','color',function() {
    return 'The ' + this.get('color') + ' light is set to ' + this.get('isOn');
  }),
  fullDescription: Ember.computed('description','age',function() {
    return this.get('description') + ' and the age is ' + this.get('age')
  }),
<strong class="calibre9">  aliasDescription: Ember.computed.alias('fullDescription')</strong>
});

const bulb = Light.create({age: 22});
bulb.get('aliasDescription');//The yellow light is set to false and the age is 22.</pre></div></li><li class="listitem" value="2">The <code class="email">aliasDescription</code> alias will display the same text as <code class="email">fullDescription</code> as it's just an alias of this object. If we made any changes to any properties in the <code class="email">Light</code> object later, the alias would also observe these changes and be computed properly. We'll discuss more about this in the <em class="calibre13">Working with bindings</em> recipe.</li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec33" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Computed properties are built on top of the observer pattern. Whenever an observation shows a state change, it recomputes the output. If no changes occur, then the result is cached.</p><p class="calibre8">In other words, computed properties are functions that get updated whenever any of their dependent values change. You can use them in much the same way that you would use a static property. They are common and useful throughout Ember and its codebase.</p><p class="calibre8">Keep in mind that a computed property will only update if it is in a template or function that is being used. If the function or template is not being called, nothing will occur. This will help with performance.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Working with Ember observers in Ember.js</h1></div></div></div><p class="calibre8">Observers <a id="id78" class="calibre1"/>are fundamental to the Ember object model. In the next recipe, we'll take our light example, add an observer, and see how it operates.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec34" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">To begin, we'll add a new observer called <code class="email">isOnChanged</code>. This will only trigger when the <code class="email">isOn</code> property changes:<div><pre class="programlisting">const Light = Ember.Object.extend({
  isOn: false,
  color: 'yellow',
  age: null,
  description: Ember.computed('isOn','color',function() {
    return 'The ' + this.get('color') + 'light is set to ' + this.get('isOn')
  }),
  fullDescription: Ember.computed ('description','age',function() {
    return this.get('description') + ' and the age is ' + this.get('age')
  }),
  desc: Ember.computed.alias('description'),
<strong class="calibre9">  isOnChanged: Ember.observer('isOn',function() {</strong>
<strong class="calibre9">    console.log('isOn value changed')</strong>
<strong class="calibre9">  })</strong>
});

const bulb = Light.create({age: 22});

bulb.set('isOn',true); //console logs isOn value changed</pre></div><p class="calibre14"><code class="email">Ember.observer</code> <code class="email">isOnChanged</code> monitors the <code class="email">isOn</code> property. If any changes occur to this property, <code class="email">isOnChanged</code> is invoked.</p><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8"><strong class="calibre9">Computed properties versus observers</strong></p><p class="calibre8">At first glance, it might seem that observers are the same as computed properties. In fact, they are very different. Computed properties can use <code class="email">get</code> and <code class="email">set</code> methods and can be used in templates. Observers, on the other hand, just monitor property changes and cannot be used in templates or be accessed like properties. They don't return any values as well. With this said, be careful not to overuse observers. In many instances, a computed property is a more appropriate solution.</p></div></li><li class="listitem" value="2">Additionally, if <a id="id79" class="calibre1"/>needed, you can add multiple properties to the observer. Just use the following code:<div><pre class="programlisting">Light.reopen({  
isAnythingChanged: Ember.observer('isOn','color',function() {
    console.log('isOn or color value changed')
  })
});

const bulb = Light.create({age: 22});
bulb.set('isOn',true); // console logs isOn or color value changed
bulb.set('color','blue'); // console logs isOn or color value changed</pre></div><p class="calibre14">The <code class="email">isAnything</code> observer is invoked whenever the <code class="email">isOn</code> or <code class="email">color</code> properties change. The observer will fire twice as each property has changed.</p></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec20" class="calibre1"/>Synchronous issues with the Light object and observers</h3></div></div></div><p class="calibre8">It's very <a id="id80" class="calibre1"/>easy to get observers out of sync. If, for example, a property that it observes changes, it will be invoked as expected. After being invoked, it might manipulate a property that hasn't been updated yet. This can cause synchronization issues as everything happens at the same time.</p><div><ol class="orderedlist"><li class="listitem" value="1">The following example shows this behavior:<div><pre class="programlisting">  Light.reopen({
    checkIsOn: Ember.observer('isOn', function() {
      console.log(this.get('fullDescription'));
    })
  });

const bulb = Light.create({age: 22});
bulb.set('isOn', true);</pre></div><p class="calibre14">When <code class="email">isOn</code> is changed it's not clear if <code class="email">fullDescription</code>, a computed property, has been updated yet or not. As observers work synchronously, it's difficult to tell what has been fired and changed. This can lead to unexpected behavior.</p></li><li class="listitem" value="2">To counter this, it's best to use the <code class="email">Ember.run.once</code> method. This method is a part of the Ember <code class="email">run</code> loop, which is Ember's way of managing how code gets <a id="id81" class="calibre1"/>executed. Reopen the <code class="email">Light</code> object and you will see the following:<div><pre class="programlisting">Light.reopen({
    checkIsOn: Ember.observer('isOn','color', function() {
      Ember.run.once(this,'checkChanged');
    }),
    checkChanged: Ember.observer('description',function() {
      console.log(this.get('description'));
    })
});
const bulb = Light.create({age: 22});
bulb.set('isOn', true);
bulb.set('color', 'blue'); </pre></div><p class="calibre14">The <code class="email">checkIsOn</code> observer calls the <code class="email">checkChanged</code> observer using <code class="email">Ember.run.once</code>. This method gets run only once per <code class="email">run</code> loop. Normally, <code class="email">checkChanged</code> would get fired twice; however, as it's being called using <code class="email">Ember.run.once</code>, it outputs only once.</p></li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec35" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember observers are mixins from the <code class="email">Ember.Observable</code> class. They work by monitoring property changes. When any change occurs, they are triggered. Keep in mind that these are not the same as computed properties and cannot be used in templates or with getters or setters.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Working with bindings</h1></div></div></div><p class="calibre8">Most <a id="id82" class="calibre1"/>frameworks include some sort of binding implementation. Ember is no exception and has bindings that can be used with any object. The following recipes explain how to use them as well as one-way and two-way binding.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec36" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In this example, there is a teacher and student Ember object. Each has its own set of properties and they both have homeroom. We can share the homeroom by setting an alias for the teacher object.</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's begin by creating a teacher and student <code class="email">Ember.Object</code>:<div><pre class="programlisting">const Teacher = Ember.Object.extend({
  homeroom: '',
  age: '',
  gradeTeaching: ''
});

const Student = Ember.Object.extend({
  homeroom: Ember.computed.alias('teacher.homeroom'),
  age: '',
  grade: '',
  teacher: null
});</pre></div><p class="calibre14">The student <code class="email">homeroom</code> is <code class="email">Ember.computed.alias</code>, which will bind the <code class="email">homeroom</code> property to <code class="email">teacher.homeroom</code>.</p></li><li class="listitem" value="2">Next, we'll <a id="id83" class="calibre1"/>instantiate the <code class="email">teacher</code> and <code class="email">student</code> objects:<div><pre class="programlisting">const avery = Teacher.create({
  age: '27',
  homeroom: '1075',
  gradeTeaching: 'sophmore'
});

const joey = student.create({
  age: '16',
  grade: 'sophmore',
  teacher: avery
});</pre></div><p class="calibre14">The <code class="email">joey</code> object has the <code class="email">homeroom</code> property set to <code class="email">avery</code>, which is the <code class="email">teacher</code> object that we just created.</p></li><li class="listitem" value="3">We can now use <code class="email">console.log</code> to output our findings:<div><pre class="programlisting">console.log(joey.get('age')); //16
console.log(avery.get('homeroom')); //1075
avery.set('homeroom','2423');
console.log(joey.get('homeroom')); //2423</pre></div><p class="calibre14">As you can see, whenever the <code class="email">avery</code> object changes its <code class="email">homeroom</code>, the student <code class="email">joey</code> <code class="email">homeroom</code> changes as well. This is because the homeroom for joey is an alias for the teacher, <code class="email">avery</code>.</p></li><li class="listitem" value="4">You do not always have to access properties that reference other objects. You can bind to anything:<div><pre class="programlisting">const myName = Ember.Object.extend({
  name: 'Erik Hanchett',
  otherName: Ember.computed.alias('name')
});

const erik = myName.create();

console.log(erik.get('name')); //Erik Hanchett
console.log(erik.get('otherName')); //Erik Hanchett</pre></div><p class="calibre14">The alias points to <code class="email">name</code>; therefore, when printing to the console, it shows <code class="email">Erik Hanchett</code> for both.</p><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">Ember has a class called <code class="email">Ember.Binding</code>. This is a public class that has very similar <a id="id84" class="calibre1"/>behavior and functionality as <code class="email">Ember.computed.alias</code> and <code class="email">Ember.computed.oneWay</code>. You should use <code class="email">Ember.computed.alias</code> and not <code class="email">Ember.Binding</code>. Computed aliases are the preferred method of binding in Ember. <code class="email">Ember.Binding</code> is still around and will probably be deprecated at some point.</p></div></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec21" class="calibre1"/>One-way binding</h3></div></div></div><p class="calibre8">Ember defaults to <a id="id85" class="calibre1"/>something called two-way binding. What this means is <a id="id86" class="calibre1"/>that when properties are changed in the UI, this is updated back in the controller or component. On the other hand, one-way binding propagates changes in one direction only.</p><p class="calibre8">For instance, let's say that we have a <code class="email">User</code> object with a <code class="email">firstName</code>, <code class="email">lastName</code>, and <code class="email">nickName</code> property. We can use <code class="email">Ember.computed.oneWay</code> to create a one-way binding for the <code class="email">firstName</code> property.</p><p class="calibre8">Let's see what happens when we try to make a change to it. Create a new user object with these properties. Instantiate the object and try changing the properties:</p><div><pre class="programlisting">const User = Ember.Object.extend({
  firstName: null,
  lastName: null,
  nickName: Ember.computed.oneWay('firstName')
});

const user = User.create({
  firstName: 'Erik',
  lastName:  'Hanchett'
});

console.log(user.get('nickName'));              // 'Erik'
user.set('nickName', 'Bravo'); // 'Bravo'
console.log(user.get('firstName'));             // 'Erik'</pre></div><p class="calibre8">You can see that <code class="email">nickName</code> does not change even though user has been updated. You can think of one-way binding <a id="id87" class="calibre1"/>like using <code class="email">Ember.computed.alias</code>. However, it allows you to get values only and not set them. The upstream properties don't get changed when using <code class="email">Ember.computed.oneWay</code>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec37" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember bindings are used in many parts of the Ember framework. They are derived from the <code class="email">Ember.computed</code> namespace. In this namespace is the computed alias method. A computed alias specifies the path <a id="id88" class="calibre1"/>to another object by creating a two-way binding.</p><p class="calibre8">Binding objects don't update immediately. Ember waits until all the application code has finished running before synchronizing all the changes. This prevents unneeded overhead of syncing bindings when values are being updated.</p><p class="calibre8">One-way binding works by information being propagated only one way. Information does not get updated in the upstream properties.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Using mixins</h1></div></div></div><p class="calibre8">Mixins are a great <a id="id89" class="calibre1"/>way of reusing and sharing code in Ember. The following recipes go over some basic operations on how to use them in your code.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec38" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In this recipe, we'll create a common mixin object.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create an Ember mixin object that has a couple of properties and a function:<div><pre class="programlisting">const common = Ember.Mixin.create({
    property1: 'This is a mixin property',
    edit: function() {
      console.log('Starting to edit');
      this.set('isEditing', true);
    },
    isEditing: false
});</pre></div><p class="calibre14">This mixin can be added to any object. For the sake of simplicity, all this mixin does is display some text and set the <code class="email">isEditing</code> property to <code class="email">true</code> if the <code class="email">edit</code> function is invoked.</p></li><li class="listitem" value="2">Let's see what it looks like when we add this object to an object:<div><pre class="programlisting">const obj = Ember.Object.extend(common,{
  objprop: 'This is an Ember object property'
});

const object = obj.create();</pre></div><p class="calibre14">The <code class="email">extend</code> method present in <code class="email">Ember.Object</code> allows for one or more optional arguments of the <code class="email">Ember.Mixin</code> type. In this example, we added the common mixin to the new <code class="email">Ember.Object</code> object. We then instantiated this Ember object using <code class="email">create</code>.</p></li><li class="listitem" value="3">All that's left is to <a id="id90" class="calibre1"/>output the contents. Use <code class="email">console.log</code> to display each property:<div><pre class="programlisting">console.log(object.get('objprop'));  //This is an Ember object property
console.log(object.get('property1'));  //This is a mixin property
console.log(object.get('isEditing'));  //false
object.edit();  //Starting to edit
console.log(object.get('isEditing')); //true</pre></div><p class="calibre14">This is what the output will look like. As you can see, we can access any of the mixin properties or methods as if the mixin was included in the Ember object itself. This is a convenient way of reusing code in your applications.</p></li><li class="listitem" value="4">Let's create another mixin:<div><pre class="programlisting">const secondMixin = Ember.Mixin.create({
  secondProperty: 'This is the second mixin property'
});</pre></div></li><li class="listitem" value="5">Now let's see how this looks if we add it to an Ember object:<div><pre class="programlisting">const obj = Ember.Object.extend(common,secondMixin,{
  objprop: 'This is an Ember object Property'
});</pre></div></li><li class="listitem" value="6">Now, we can have access to both the common and <code class="email">secondMixin</code> in our object. We can use <code class="email">console.log</code> to output <code class="email">secondProperty</code>:<div><pre class="programlisting">console.log(object.get('secondProperty'));//This is the   second mixin propety</pre></div></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec22" class="calibre1"/>Mixins with the Ember CLI</h3></div></div></div><p class="calibre8">Mixins work very well <a id="id91" class="calibre1"/>with the Ember CLI. To start, use the mixin generator to create one.</p><div><ol class="orderedlist"><li class="listitem" value="1">Make sure that you're in the application directory, and then type the following command:<div><pre class="programlisting">
<strong class="calibre9">$ ember generate mixin common</strong>
<strong class="calibre9">installing mixin</strong>
<strong class="calibre9">  create app/mixins/common.js</strong>
<strong class="calibre9">installing mixin-test</strong>
<strong class="calibre9">  create tests/unit/mixins/common-test.js</strong>
</pre></div><p class="calibre14">The <code class="email">generator</code> command creates an <code class="email">app/mixins</code> folder and the <code class="email">common.js</code> file. The <code class="email">common.js</code> file is where we will put the code for the mixin.</p></li><li class="listitem" value="2">We'll use the <a id="id92" class="calibre1"/>mixin from the previous example and add it to this file:<div><pre class="programlisting">// app/mixins/common.js
import Ember from 'ember';

export default Ember.Mixin.create({
    property1: 'This is a mixin property',
    edit: function() {
      console.log('Starting to edit');
      this.set('isEditing', true);
    },
    isEditing: false
});</pre></div><p class="calibre14">This mixin is exactly the same as the previous example; however, now it's in a module that we can import anywhere, including components or controllers.</p><p class="calibre14">For now, we'll import it to our <code class="email">app.js</code> file in the <code class="email">app</code> folders directory.</p></li><li class="listitem" value="3">First, we'll need to add the <code class="email">import</code> statement to the top of the file:<div><pre class="programlisting">import common from './mixins/common';</pre></div><p class="calibre14">This allows us to use the common mixin anywhere in the <code class="email">app.js</code> file.</p></li><li class="listitem" value="4">We'll add the following code to the bottom of the <code class="email">app/app.js</code> file:<div><pre class="programlisting">// app/app.js

const obj = Ember.Object.extend(common,{
  objprop: 'This is an Ember object property'
});

const object = obj.create();

console.log(object.get('objprop'));//This is an Ember object property
console.log(object.get('property1'));//This is a mixin property
console.log(object.get('isEditing'));//false
object.edit();  //Starting to edit
console.log(object.get('isEditing'));  //true</pre></div><p class="calibre14">As you can see, all the properties and methods in the common mixin are available to the object.</p></li><li class="listitem" value="5">If we were to <a id="id93" class="calibre1"/>add the common mixin to a component, it might look like following code. Add this code to the <code class="email">common-example.js</code> file:<div><pre class="programlisting">// app/components/common-example.js
import Ember from 'ember';
import common from '../mixins/common';

export default Ember.Component.extend(common,{
    compprop: 'This is a component property',
    actions: {
      pressed: function(){
        this.edit();
      }
    }
});</pre></div><p class="calibre14">As always, we must first import the mixin to our component. The path is always relative to the directory you're in, therefore, we must use <code class="email">../mixins/common</code> to find it.</p><p class="calibre14">In the component, I added a simple action called <code class="email">pressed</code> that triggers the mixin <code class="email">edit</code> method. If the action gets triggered, we would see the <code class="email">Starting to edit message</code> in the console. Look for more examples of components in <a class="calibre1" title="Chapter 6. Ember Components" href="part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb">Chapter 6</a>, <em class="calibre13">Ember Components</em>.</p></li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec39" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="email">Ember.Mixin</code> class allows the creation of mixins whose properties and methods can be added to other classes. They can't be instantiated but they can be added or <em class="calibre13">mixed in</em>.</p><p class="calibre8">A mixin in computer science is a class that lends or copies it's behavior to a borrowing class using composition instead of inheritance. It encourages code reuse and avoids ambiguity that multiple inheritance can cause.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Using enumerables with arrays</h1></div></div></div><p class="calibre8">The <a id="id94" class="calibre1"/>
<code class="email">Ember.Enumerable</code> methods are very important when dealing with arrays. In these recipes, we'll look at some common use cases.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec40" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To understand how to use enumerables, we must first take a look at the standard JavaScript array methods and their equivalents using observable enumerables:</p><div><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Standard method</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Observable equivalent</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">unshift</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">unshiftObject</code></p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">shift</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">shiftObject</code></p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">reverse</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">reverseObjects</code></p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">push</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">pushObject</code></p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">pop</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">popObject</code></p>
</td></tr></tbody></table></div><p class="calibre8">We'll be using some of these methods in our examples, so keep in mind what the standard and observable equivalents are.</p><p class="calibre8">The <code class="email">Ember.Enumerable</code> class has several methods that we can use in our Ember applications. Here is the list of the more common methods and what they do:</p><div><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Enumerable method</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Definition</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">forEach</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This iterates through the enumerable, calling the passed function on each item</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">firstObject</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns the first object in a collection</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">lastObject</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns the last object in a collection</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">map()</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This maps all the items in the enumeration to another value, similar to map in JavaScript 1.6</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">mapBy()</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Similar to map, this returns the value of the named property on all items on the enumeration</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">filter</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns an array with all of the items in the enumeration that the passed function returns true</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">find</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns the first item in the array that the method returns true</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">findby</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns the first item with a property that matches the passed value</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">every</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns true only if the passed function returns true for every item in the enumeration</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22"><code class="literal">any</code></p>
</td><td valign="top" class="calibre24">
<p class="calibre22">This returns true only if the passed function returns true for any item in the enumeration</p>
</td></tr></tbody></table></div><p class="calibre8">Many of these methods are similar to their JavaScript counterparts. If you know how to use the JavaScript method, you should be able to use the Ember equivalent as well.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec41" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8"><code class="email">Ember.Enumerables</code> adds all the nice features of Ember objects to enumerables. We'll take a look at <a id="id95" class="calibre1"/>several examples on how to do this. The contents for all these recipes are in the <code class="email">chapter2/example6</code> folder in the <code class="email">app.js</code> file.</p><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec23" class="calibre1"/>Using forEach with an array</h3></div></div></div><p class="calibre8">A very common <a id="id96" class="calibre1"/>use case for an enumerable is iterating <a id="id97" class="calibre1"/>over an array with <code class="email">forEach</code>.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create an array of students:<div><pre class="programlisting">const students = ['Erik', 'Jim', 'Shelly', 'Kate'];</pre></div></li><li class="listitem" value="2">Use the <code class="email">forEach</code> enumerable to iterate over the array:<div><pre class="programlisting">students.forEach(function(item, index) {
  console.log(`Student #${index+1}: ${item}`);
});</pre></div><p class="calibre14">The console output will show each student's name in the array:</p><div><pre class="programlisting">
<strong class="calibre9">Student #1: Erik</strong>
<strong class="calibre9">Student #2: Jim</strong>
<strong class="calibre9">Student #3: Shelly</strong>
<strong class="calibre9">Student #4: Kate</strong>
</pre></div><div><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Template literals</strong></p><p class="calibre8">Ember is compatible with the latest in ECMAScript 2015. One neat new feature is called template literals or template strings. Template literals are string literals that can stretch across multiple lines and include interpolated expressions. You can do string interpolation by surrounding variables in your strings, like this <code class="email">${}</code>. Each variable will be displayed in the string as shown in the preceding <code class="email">forEach</code> example.</p></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec24" class="calibre1"/>Using map with an array</h3></div></div></div><p class="calibre8">The <code class="email">map</code> method <a id="id98" class="calibre1"/>takes an array, maps each item, and returns a new <a id="id99" class="calibre1"/>modified array. Let's say that we want to make the student names all in uppercase. We can do this using <code class="email">map</code>.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a list of <code class="email">students</code>:<div><pre class="programlisting">const students = ['Erik', 'Jim', 'Shelly', 'Kate'];</pre></div><p class="calibre14">The first letter is capitalized; however, we want all the letters in uppercase.</p></li><li class="listitem" value="2">Use <code class="email">map</code> to convert every item to uppercase:<div><pre class="programlisting">const upperCaseStudent= students.map(function(item) {
  return item.toUpperCase();
});</pre></div><p class="calibre14">Every item in the array has been converted to uppercase. The new <code class="email">upperCaseStudent</code> array has all the new values.</p></li><li class="listitem" value="3">Use the <code class="email">forEach</code> enumerable to iterate through every item in the array and display its contents:<div><pre class="programlisting">upperCaseStudent.forEach(function(item, index) {
  console.log(`student #${index+1}: ${item}`);
});</pre></div><p class="calibre14">The output displays each name in the new <code class="email">upperCaseStudent</code> array:</p><div><pre class="programlisting">
<strong class="calibre9">student #1: ERIK</strong>
<strong class="calibre9">student #2: JIM</strong>
<strong class="calibre9">student #3: SHELLY</strong>
<strong class="calibre9">student #4: KATE</strong>
</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec25" class="calibre1"/>Using mapBy with an array</h3></div></div></div><p class="calibre8">The <code class="email">mapBy</code> <a id="id100" class="calibre1"/>enumerable can be used if your array is comprised of <a id="id101" class="calibre1"/>objects. From each object, we can extract its named properties and return a new array.</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's create a teacher and student object:<div><pre class="programlisting">const student = Ember.Object.extend({
  name: 'Erik Hanchett'
});

const teacher = Ember.Object.extend({
  name: 'John P. Smith'
  
});</pre></div><p class="calibre14">Each object has one property called <code class="email">name</code>:</p></li><li class="listitem" value="2">Next we'll <a id="id102" class="calibre1"/>instantiate each object.<div><pre class="programlisting">const t= teacher.create();
const s = student.create();
const people = [s, t];</pre></div><p class="calibre14">Each object is <a id="id103" class="calibre1"/>put into a <code class="email">people</code> array:</p></li><li class="listitem" value="3">We can use <code class="email">mapBy</code> to create a new array.<div><pre class="programlisting">console.log(people.mapBy('name'));//['Erik Hanchett', 'John P.   Smith']</pre></div><p class="calibre14">This new array returned has the values from the <code class="email">name</code> property from both objects.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec26" class="calibre1"/>Finding the first and last objects in an array</h3></div></div></div><p class="calibre8">If necessary, we <a id="id104" class="calibre1"/>have an easy way to grab the first and last objects in an array.</p><div><ol class="orderedlist"><li class="listitem" value="1">We'll begin by creating a student array:<div><pre class="programlisting">const students = ['Erik', 'Jim', 'Shelly', 'Kate', 'Jenny', 'Susan'];</pre></div><p class="calibre14">This array has six different students.</p></li><li class="listitem" value="2">Let's grab the last object in the array:<div><pre class="programlisting">console.log(students.get('lastObject')); //Susan</pre></div><p class="calibre14">This will display <code class="email">Susan</code>, the last object in the array.</p></li><li class="listitem" value="3">Now let's retrieve the first object in the array:<div><pre class="programlisting">console.log(students.get('firstObject')); //Erik</pre></div><p class="calibre14">This will display <code class="email">Erik</code>, the first item in the array.</p></li><li class="listitem" value="4">We can push objects on the array as well:<div><pre class="programlisting">students.pushObject('Jeff');</pre></div></li><li class="listitem" value="5">The student <code class="email">Jeff</code> has now been added to the list:<div><pre class="programlisting">console.log(students.get('lastObject')); //Jeff</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec27" class="calibre1"/>Fun with filters</h3></div></div></div><p class="calibre8">A very common <a id="id105" class="calibre1"/>practice is to take an array and return a filtered list of items.</p><div><ol class="orderedlist"><li class="listitem" value="1">To begin, create an array of numbers:<div><pre class="programlisting">const array = [1,2,5,10,25,23];</pre></div></li><li class="listitem" value="2">Take the <code class="email">array</code> and <code class="email">filter</code> it, returning only those numbers over <code class="email">10</code>:<div><pre class="programlisting">const newArray =array.filter(function(item, index, self) {
  return item &gt; 10;
})</pre></div></li><li class="listitem" value="3">Use <code class="email">console.log</code> to display the new array:<div><pre class="programlisting">console.log(newArray); //[25,23]</pre></div><p class="calibre14">This new array has numbers only greater then 10 in it.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec28" class="calibre1"/>Using filterBy with a collection of objects</h3></div></div></div><p class="calibre8">With <code class="email">filterBy</code>, you <a id="id106" class="calibre1"/>can take a collection of <a id="id107" class="calibre1"/>objects and filter it by some property.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new <code class="email">student</code> object that has a <code class="email">name</code> and <code class="email">grade</code>:<div><pre class="programlisting">const student = Ember.Object.extend({
  grade: null,
  name: null
});</pre></div></li><li class="listitem" value="2">Add the students to a new array:<div><pre class="programlisting">const listOfStudents = [
  student.create({grade: 'senior', name: 'Jen Smith'}),
  student.create({grade: 'sophmore', name: 'Ben Shine'}),
  student.create({grade: 'senior', name: 'Ann Cyrus'})
];</pre></div></li><li class="listitem" value="3">Use <code class="email">filterBy</code> to show the students who are seniors:<div><pre class="programlisting">const newStudent = listOfStudents.filterBy('grade','senior');</pre></div><p class="calibre14">This returns an array of students who are seniors.</p></li><li class="listitem" value="4">We can double-check the output using <code class="email">forEach</code>:<div><pre class="programlisting">newStudent.forEach(function(item,index){
  console.log(item.get('name'));
});
Jen Smith
Ann Cyrus</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec29" class="calibre1"/>Using find to get the first match</h3></div></div></div><p class="calibre8">The <code class="email">find</code> <a id="id108" class="calibre1"/>enumerable works very similarly to <a id="id109" class="calibre1"/>
<code class="email">filter</code> except that it stops after finding the first match.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create an array of numbers:<div><pre class="programlisting">const array = [1,2,5,10,25,23];</pre></div></li><li class="listitem" value="2">Use <code class="email">array.find</code> to retrieve the first number in the list that is over <code class="email">10</code>:<div><pre class="programlisting">const newArray =array.find(function(item, index){
  return item &gt; 10;
}); </pre></div></li><li class="listitem" value="3">We'll then check the output of the new array:<div><pre class="programlisting">console.log(newArray); //25</pre></div><p class="calibre14">The answer is <code class="email">25</code> as it's the first number in the list that is over 10.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec30" class="calibre1"/>Using findBy with collections</h3></div></div></div><p class="calibre8">The <code class="email">findBy</code> <a id="id110" class="calibre1"/>enumerable works very similarly to <code class="email">filterBy</code> <a id="id111" class="calibre1"/>except that it stops after finding the first match.</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new <code class="email">student</code> object:<div><pre class="programlisting">const student = Ember.Object.extend({
  grade: null,
  name: null
});</pre></div></li><li class="listitem" value="2">Next, create an array of students:<div><pre class="programlisting">const listOfStudents = [
  student.create({grade: 'senior', name: 'Jen Smith'}),
  student.create({grade: 'sophmore', name: 'Ben Shine'}),
  student.create({grade: 'senior', name: 'Ann Cyrus'})
];</pre></div></li><li class="listitem" value="3">Use <code class="email">findBy</code> to match only the properties that have <code class="email">grade</code> of <code class="email">senior</code>:<div><pre class="programlisting">const newStudent = listOfStudents.findBy('grade','senior');</pre></div></li><li class="listitem" value="4">This will return the first student who is a senior:<div><pre class="programlisting">console.log(newStudent.get('name')); //Jen Smith</pre></div><p class="calibre14"><code class="email">Jen Smith</code> is the first student who matches this criteria so it is returned to the <code class="email">newStudent</code> array.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec31" class="calibre1"/>Learning with the every enumerable</h3></div></div></div><p class="calibre8">The <code class="email">every</code> <a id="id112" class="calibre1"/>enumerable will return <code class="email">true</code> only if every item matches <a id="id113" class="calibre1"/>a certain condition.</p><div><ol class="orderedlist"><li class="listitem" value="1">Begin by creating an array of numbers:<div><pre class="programlisting">const array = [11,25,23,30];</pre></div></li><li class="listitem" value="2">Use the <code class="email">every</code> enumerable to check whether every item in the array is greater than <code class="email">10</code>:<div><pre class="programlisting">console.log(array.every(function(item, index, self) {
  return item &gt; 10;
})); //returns true</pre></div><p class="calibre14">This returns <a id="id114" class="calibre1"/>
<code class="email">true</code> because every item in the array is over <code class="email">10</code></p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch02lvl3sec32" class="calibre1"/>Using any to find at least one match</h3></div></div></div><p class="calibre8">The <code class="email">any</code> <a id="id115" class="calibre1"/>enumerable will return <code class="email">true</code> if at least one item matches a certain condition.</p><div><ol class="orderedlist"><li class="listitem" value="1">Once again, create a list of numbers:<div><pre class="programlisting">const array = [1,2,5,10,25,23];</pre></div></li><li class="listitem" value="2">Use the <code class="email">any</code> enumerable to check whether any of these numbers in this array are over <code class="email">10</code>:<div><pre class="programlisting">console.log(array.any(function(item, index, self) {
  return item &gt; 10;
})); //returns true</pre></div><p class="calibre14">This will return <code class="email">true</code> because at least one number is above <code class="email">10</code>.</p></li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec42" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The <code class="email">Ember.Enumerable</code> mixin is Ember's implementation of the array API defined up to JavaScript 1.8. It's applied automatically on page load so any method is available. In order for Ember to be able to observe changes in an enumerable, you must use <code class="email">Ember.Enumerable</code>.</p><p class="calibre8">The enumerable API follows ECMAScript specifications as much as possible so it minimizes incompatibilities with the other libraries. It uses native browser implementations in arrays where available.</p></div></div></body></html>