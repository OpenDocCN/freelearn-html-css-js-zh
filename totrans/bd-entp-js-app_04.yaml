- en: Setting Up Development Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first section of this book (Chapters 1-3) was written to provide sufficient
    background knowledge so that we can code without interruption. In this chapter,
    we will actually start building our user directory application, called 'hobnob',
    by setting up our local development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this chapter is to help you understand how different tools and standards
    in the Node.js ecosystem work together. Specifically, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is **Node.js**?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different formats/standards for JavaScript **modules**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing modules with `npm` and `yarn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpiling code with **Babel**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching for changes with `nodemon`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linting our code with **ESLint**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Node.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in [Chapter 2](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml), *The
    State of JavaScript*, Node.js is "JavaScript on the server". Before we move forward,
    let's delve a little deeper into understanding what that means.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, JavaScript is interpreted by a JavaScript engine that converts
    JavaScript code into more optimized, machine-executable code, which then gets
    executed. The engine interprets the JavaScript code at the time it is run. This
    is unlike **compiled languages** such as C#, which must first be compiled into
    an **intermediate language** (**IL**), where this IL is then executed by the **common
    language runtime** (**CLR**), software similar in function to the JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it is inaccurate to classify a language as interpreted or compiled—how
    a language is processed depends on the implementation. Someone can build a compiler
    that converts JavaScript into machine code and run it; in that instance, JavaScript
    would be a compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: However, since JavaScript is almost always interpreted by a JavaScript engine,
    you'll often hear people refer to JavaScript as an interpreted language.
  prefs: []
  type: TYPE_NORMAL
- en: Different browsers use different JavaScript engines. Chrome uses V8, Firefox
    uses SpiderMonkey, WebKit browsers such as Safari use JavaScriptCore, and Microsoft
    Edge uses Chakra. Node.js uses V8 as its JavaScript engine and adds C++ bindings
    that allow it to access operating system resources, such as files and networking.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because JavaScript was traditionally interpreted at runtime, and because runtimes
    in other languages (such as C#, mentioned before) do actually execute the code,
    many people incorrectly call the JavaScript engine the JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: But, they are different things—the engine is the software that translates the
    high-level JavaScript code into machine-executable code, and then executes it.
    The JavaScript engine then exposes all the objects obtained from parsing the code
    to the JavaScript runtime environment, which can then use it.
  prefs: []
  type: TYPE_NORMAL
- en: So, JavaScript in the browser and Node.js both use the same V8 engine, but run
    in different runtime environments. For example, the browser runtime environment
    provides the `window` global object, which is not available in the Node.js runtime.
    Conversely, the browser runtime lacks the `require` global, and cannot act on
    system resources such as file systems.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The
    Importance of Good Code*, clean code should be structured in a modular way. In
    the next few sections, we'll introduce you to the concept of modular design, before
    explaining the different module formats. Then, for the rest of the chapter, we
    will begin composing our project by incorporating existing Node modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s remind ourselves why modular design is important. Without
    it, the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Logic from one business domain can easily be interwoven with that of another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When debugging, it's hard to identify where the bug is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There'll likely be duplicate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, writing modular code means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules are logical separations of domains—for example, for a simple social
    network, you might have a module for user accounts, one for user profiles, one
    for posts, one for comments, and so on. This ensures a clear **separation of concerns**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module should have a very specific purpose—that is, it should be granular.
    This ensures that there is as much **code reusability** as possible. A side effect
    of code reusability is *consistency*, because changes to the code in one location
    will be applied everywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module provides an API for other modules to interact with—for example,
    the comments module might provide methods that allow for creating, editing, or
    deleting a comment. It should also hide internal properties and methods. This
    turns the module into a black box, encapsulating internal logic to ensure that
    the API is as minimal as is practical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By writing our code in a modular way, we'll end up with many small and manageable
    modules, instead of one uncontrollable mess.
  prefs: []
  type: TYPE_NORMAL
- en: The dawn of modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules were not supported in JavaScript until ECMAScript 2015, because JavaScript
    was initially designed to add small bits of interactivity to web pages, not to
    cater for building full-fledged applications. When developers wanted to use a
    library or framework, they''d simply add `<script>` tags somewhere inside the
    HTML, and that library would be loaded when the page was loaded. However, this
    is not ideal as the scripts must be loaded in the correct order. For example,
    Bootstrap (a UI framework) depends on jQuery (a utility library), so we must manually
    check that the jQuery script is added first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine as the dependency tree is relatively small and shallow. However,
    as **single-page applications** (**SPAs**) and Node.js applications become more
    popular, applications inevitably become more complex; having to manually arrange
    hundreds of modules in the correct order is impractical and error-prone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f04647ba-e067-422b-9d24-c1e37fe4bfee.png)'
  prefs: []
  type: TYPE_IMG
- en: The dependency tree for the Cordova npm package, where each node represents
    a discrete module
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, many of these scripts add variables to the global namespace, or
    extend the prototypes of existing objects (for example, `Object.prototype` or
    `Array.prototype`). Because they are usually not namespaced, the scripts can clash/interfere
    with each other, or with our code.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the increasing complexity of modern applications, developers started
    creating **package managers** to organize their modules. Moreover, standard formats
    began to appear so that modules could be shared with the wider community.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there are three major package managers—**npm**, **Bower**, and
    **y****arn**—and four major standards in defining JavaScript modules—**CommonJS**,
    **AMD**, **UMD**, and **ES6 modules**. Each format also has accompanying tools
    to enable them to work on browsers, such as **RequireJS**, **Browserify**, **Webpack**,
    **Rollup**, and **SystemJS**.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll give a quick overview of different types of
    package managers, modules, and their tools. At the end of this section, we'll
    look more specifically at ES6 modules, which we will use for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: The birth of Node.js modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using modules on the client was infeasible because an application can have hundreds
    of dependencies and sub-dependencies; having to download them all when someone
    visits the page is going to increase the **time-to-first-render** (**TTFR**),
    drastically impacting the user experience (UX). Therefore, JavaScript modules,
    as we know them today, began their ascent on servers with Node.js modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js, a single file corresponds to a single module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For instance, both of the preceding files—`greeter.js` and `main.js`—are each
    their own module.
  prefs: []
  type: TYPE_NORMAL
- en: Adoption of the CommonJS standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Node.js, modules are written in the CommonJS format, which provides two global
    objects, `require` and `exports`, that developers can use to keep their modules
    encapsulated. `require` is a function that allows the current module to import
    and use variables defined in other modules. `exports` is an object that allows
    a module to make certain variables publicly available to other modules that `require` it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define two functions, `helloWorld` and `internal`, in `greeter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By default, these two functions can only be used within the file (within the
    module). But, when we assign the `helloWorld` function to the `sayHello` property
    of `exports`, it makes the `helloWorld` function accessible to other modules that 
    `require` the `greeter` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we can `require` the greeter module in `main.js` and use
    its `sayHello` export to print a message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To `require` a module, you can either specify its name or its file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we run `main.js`, we get a message printed in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Fulfilling the encapsulation requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can export multiple constructs from a single module by adding them as properties
    to the `exports` object. Constructs that are not exported are not available outside
    the module because Node.js wraps its modules inside a **module wrapper**, which
    is simply a function that contains the module code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This fulfills the encapsulation requirement of modules; in other words, the
    module restricts direct access to certain properties and methods of the module.
    Note that this is a feature of Node.js, not CommonJS.
  prefs: []
  type: TYPE_NORMAL
- en: Standardizing module formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since CommonJS, multiple module formats have emerged for client-side applications,
    such as AMD and UMD. AMD, or *Asynchronous Module Definition*, is an early fork
    of the CommonJS format, and supports **asynchronous module loading**. This means
    modules that do not depend on each other can be loaded in parallel, partially
    alleviating the slow startup time that clients face if they use CommonJS on the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever there are multiple unofficial standards, someone will usually come
    up with a *new* standard that''s supposed to unify them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0298913-b74a-4ddf-aec5-dcc9d7210b65.png)'
  prefs: []
  type: TYPE_IMG
- en: From the XKCD comic titled "Standards" ([h](https://xkcd.com/927/)[ttps://xkcd.com/927/](https://xkcd.com/927/));
    used with permission under a Creative Commons Attribution-NonCommercial 2.5 License
    ([http://creativecommons.org/licenses/by-nc/2.5/](http://creativecommons.org/licenses/by-nc/2.5/))
  prefs: []
  type: TYPE_NORMAL
- en: This is what happened with UMD, or *Universal Module Definition*. UMD modules
    are compatible with both AMD and CommonJS, and this also exposes a global variable
    if you want to include it on your web page as a `<script>` tag. But, because it
    tries to be compatible with all formats, there's a lot of boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the task of unifying JavaScript module formats was taken on by the **Ecma
    International**, which standardized modules in the ECMAScript 2015 (ES6) version
    of JavaScript. This module format uses two keywords: `import` and `export`. The
    same `greeter` example would look like this with ES6 modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You'd still have two files—`greeter.js` and `main.js`; the only difference here
    is that `exports.sayHello = helloWorld;` is replaced by `export default helloWorld;`,
    and `const greeter = require('./greeter.js');` is replaced by `import greeter
    from "./greeter.js";`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, ES6 modules are **static**, meaning they cannot be changed at runtime.
    In other words, you cannot decide during runtime whether a module should be imported.
    The reason for this is to allow the modules to be analyzed and the dependency
    graph to be built beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and popular browsers are quickly adding support for ECMAScript 2015
    features, but currently none of them fully support modules.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the full compatibility table for ECMAScript features in the Kangax
    Compatibility Table at [kangax.github.io/compat-table/](http://kangax.github.io/compat-table/es6/).
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are tools that can convert ECMAScript 2015 modules into the universally
    supported CommonJS format. The most popular are **Babel** and **Traceur**. In
    this book, we will use Babel because it is the *de facto* standard.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that background on modules out of the way, let''s begin the development
    of our application by installing Node.js on our local machine. Just like the saying
    "Many roads lead to Rome", there are many ways to install Node.js on your machine.
    You can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://nodejs.org/](https://nodejs.org/en/download/) and download its
    source code (in the form of a `*.tar.gz` archive)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [https://nodejs.org/](https://nodejs.org/en/download/) and download an
    installer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    and download the Node version that's listed on your operating system's package
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the easiest way is to use **Node Version Manager** (**nvm**), which has
    the added benefit of allowing you to download and switch between different versions
    of Node. This is especially handy if you're working on different Node projects
    at the same time, each using a different version.
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular programs that manage the Node versions for you. `nvm`
    and `nave` manage Node versions per user/shell, which means different users on
    the same machine can use different versions of Node. There's also `n`, which manages
    the global/system-wide Node version. Lastly, `nodenv` can also be useful as it
    can automatically detect the correct version of Node to use for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Using nvm to install Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can install nvm using the shell script it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is never a good idea to run a shell script directly from the internet
    without first examining the content. Therefore, you should first go to [https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh)
    and check the commands that would be run before you actually run it.
  prefs: []
  type: TYPE_NORMAL
- en: This will clone the nvm repository to `~/.nvm` and adds a line to your profile
    (`~/.bash_profile`, `~/.zshrc`, `~/.profile`, or `~/.bashrc`) so that nvm will
    be loaded when your user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use nvm to install Node. First, let''s check the versions of Node
    that are available using the `nvm ls-remote` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It will come back with a huge list of every Node.js version, and we can install
    a specific version by running `nvm install <version>`, where version is the version
    number (for example, `6.11.1`) or the name of the long-term support (LTS) version (for
    example, `lts/boron`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to use the latest LTS version of Node. At the time of writing, that''s
    `8.11.4`, so we can run `nvm install 8.11.4`. Better still, we can use the shorthand
    `nvm install lts/*`, which will default to the latest LTS version of Node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that Node has been successfully installed by running `node -v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we installed Node, we also automatically installed the npm CLI, which
    is the package manager for Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Documenting Node versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should document which version of Node we are running our API server with.
    To do this with nvm, we simply have to define a `.nvmrc` file in the root directory
    of our project. Then, any developers working on the API will be able to use the
    right Node version by running `nvm use`. Therefore, create a new project directory
    and run `git init` to create a new Git repository. Once that''s done, create a
    new `.nvmrc` file that contains a single line that reads `8.11.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Starting projects with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Node.js projects, the settings and configurations are stored inside a file
    named `package.json`, located at the root of the repository. The npm CLI tool
    provides a `npm init` command, which will initiate a mini-wizard that helps you
    compose your `package.json` file. So, inside our project directory, run `npm init` to
    initiate the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wizard will ask you a series of questions, but also provides sensible defaults.
    Let''s go through each question one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'package name: We are happy with the default name of `hobnob` (derived from
    the directory name), so we can just press the Return key to continue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'version: We''re going to follow semantic versioning (semver) here and use major
    version 0(`0.y.z`) to indicate that our code base is under initial development,
    and that the API is not stable. Semver also recommends that our initial release
    be `0.1.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'description: A brief description of your project; if we make our application
    public on [npmjs.com](http://npmjs.com), this description will appear in the search
    results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'entry point: This should point to the root of the module, and is what is run
    when other modules require your module. We have not decided on the structure of
    our application yet, so just leave it at `index.js`, and we may change it later.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'test command: This will be run when we run `npm run test`. We will integrate
    with the Cucumber and Mocha testing frameworks later; for now, just leave it blank.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'git repository: Use the remote repository we created earlier, for example,
    `git@github.com:d4nyll/hobnob.git`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'keywords: These are comma-separated keywords that help others search for your
    package on [npmjs.com.](https://www.npmjs.com/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'author: Put your details here in the format of `FirstName LastName <e@ma.il>
    (http://web.site/)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'license: The license tells others how they can use our code. It should be one
    of the identifiers in the SPDX License List ([https://spdx.org/licenses/](https://spdx.org/licenses/)).
    For example, the MIT License would be `MIT`, and the GNU General Public License
    v3.0 would be `GPL-3.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two main types of open source licenses—**permissive** licenses focus
    on allowing others to do whatever they want with your code; while **copyleft**
    licenses promote sharing and require the sharing of derivative code under the
    same terms. If you're unsure which license to choose, check out [choosealicense.com](https://choosealicense.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve completed the wizard, it''ll show you a preview of the `package.json`
    file; press the Return key to confirm. You can also take a look at the newly-created `package.json`
    file to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `package.json` file contains information about your project, as well as
    a list of packages that your project depends on. Having a `package.json` file,
    it allows collaborators to quickly set up the project on their local environment—all
    they have to do is run `npm install`, and all the project's dependencies will
    be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Using yarn instead of npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`npm` is the default package manager, but Facebook, in collaboration with Exponent,
    Google, and Tilde, has since developed a better alternative, called `yarn`, which
    we will use instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '`yarn` ([https://yarnpkg.com/en/](https://yarnpkg.com/en/)) uses the same [https://www.npmjs.com/](https://www.npmjs.com/)
    registry as the `npm` CLI. Since they both just install packages inside `node_modules`
    directories and write to `package.json`, you can use `npm` and `yarn` interchangeably.
    The differences are in their methods for resolving and downloading dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Package version locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we specify our dependencies inside our `package.json` file, we can use
    symbols to indicate a range of acceptable versions. For example, `>version` means
    the installed version must be greater than a certain version, `~version` means
    approximately equivalent (which means it can be up to the next minor version),
    and `^version` means compatible (which usually means the highest version without
    a change in the major version). This means that given the same `package.json`
    file, it's likely that you'll install a different set of package versions than
    your colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: '`yarn`, by default, creates a **lock file**, `yarn.lock`. The lock file ensures
    that the exact version of every package is recorded, so that everyone who installs
    using the lock file will have exactly the same version of every package.'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm`, on the other hand, only made its lock files as defaults in version 5.0.0
    with `package-lock.json`. Prior to this, developers had to run `npm shrinkwrap` manually
    to generate a `npm-shrinkwrap.json` file—the predecessor to `package-lock.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Offline cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install a package with `yarn`, it will save a copy of it at `~/.yarn-cache`.
    So, the next time you need to install a package in one of your projects, `yarn`
    will check this cache and use the local copy if possible. This saves a round trip
    to the server each time and allows you to work offline.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install a package and its dependencies, `npm` installs them sequentially,
    whereas `yarn` installs them in parallel. This means installing with `yarn` is
    consistently faster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing yarn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many methods by which you can install `yarn`. The simplest one is
    to install it through npm (yes, this is quite ironic):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not recommended because the packages are not signed, which
    means you cannot be sure it came from an authentic source; this poses a security
    risk. Therefore, it is recommended to follow the official installation instructions
    outlined at [https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable).
    For a Ubuntu machine, we should run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Getting familiar with the yarn CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`yarn` has most of the functionality for the `npm` CLI. The following table
    compares the corresponding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Yarn 0.24.5** | **npm CLI 5.0.0** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn` | `npm` | Alias for `yarn install` |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn install` | `npm install` | Installs dependencies specified in `yarn.lock`
    and `package.json` |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn add <package>` | `npm install <package>` | Installs the package, adds
    it to the dependencies list, and generates lock files (prior to 5.0.0, npm CLI
    required a `--save` flag) |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn remove <package>` | `npm uninstall <package>` | Uninstalls the package
    |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn global add <package>` | `npm install <package> --global` | Installs
    a package globally |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn upgrade` | `rm -rf node_modules && npm install` | Upgrades all packages
    to the latest version, as allowed by `package.json` |'
  prefs: []
  type: TYPE_TB
- en: '| `yarn init` | `npm init` | Initializes the development of a package by following
    a short wizard |'
  prefs: []
  type: TYPE_TB
- en: 'Apart from the basics, `yarn` also has some non-essential, but otherwise neat,
    features that''ll help you in your workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yarn licenses ls`: Prints out, on the console, a list of packages, their URLs
    and their licenses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn licenses generate-disclaimer`: Generates a text file containing the licenses
    of all the dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn why`: Generates a dependency graph to figure out why a package was downloaded—for
    example, it might be a dependency of a dependency of our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yarn upgrade-interactive`: Provides an interactive wizard that allows you
    to selectively upgrade outdated packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get a full list of CLI commands at [https://yarnpkg.com/en/docs/cli/](https://yarnpkg.com/en/docs/cli/),
    or by running `yarn help` on your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: npm and yarn, together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`yarn` is an improvement on `npm`, in terms of speed, consistency, security,
    and the general aesthetics of its console output. This has, in turn, made `npm`
    better—`npm` v5.0.0 introduced the following changes, obtained from the official
    announcement on the npm blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm` will `--save` by default now. Additionally, `package-lock.json` will
    be automatically created unless an instance of `npm-shrinkwrap.json` exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package metadata, package download, and caching infrastructure have been replaced. The
    new cache is very fault-tolerant and supports concurrent access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `npm` while offline will no longer insist on retrying network requests.
    `npm` will now immediately fall back to the cache if possible, or fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to set up our project so that it can run ES6 code, specifically
    the ES6 modules feature. To demonstrate this, and also to show you how to debug
    your code, we're just going to create a simple HTTP server that always returns
    the string Hello, World!.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when we follow a TDD workflow, we should be writing our tests before
    we write our application code. However, for the purpose of demonstrating these
    tools, we will make a small exception here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js provides the HTTP module, which contains a `createServer()` method
    ([https://nodejs.org/api/http.html#http_http_createserver_requestlistener](https://nodejs.org/api/http.html#http_http_createserver_requestlistener))that
    allows you to provision HTTP servers. At the root of your project directory, create
    an `index.js` file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are able to use ES6 syntax (such as `const`) here because ES2015 support
    has been good since Version 6 of Node. But ES6 modules are still unsupported,
    even in the latest version of Node. Therefore, we are using CommonJS's `require`
    syntax instead.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will demonstrate how to convert our source code to
    be written with the ES6 modules feature, using Babel to transpile it back to the
    universally supported CommonJS syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To see the level of support for ES2015+ features in different versions of Node,
    go to [node.green](http://node.green/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done that, open up a terminal and run `node index.js`. This should
    have started a server on `localhost:8080`. Now, if we send a request to `localhost:8080`,
    for instance by using a web browser, it''ll return with the text `Hello, World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04a1fff3-90f6-4284-86a1-e8d24de232a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you get an `Error: listen EADDRINUSE :::8080` error, it means something
    else is using port `8080`; in that case, either terminate the process bound to
    port `8080`, or choose a different port instead by changing the number passed
    into `server.listen()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `node` process is currently running in the **foreground** and will continue
    to listen for further requests. To stop the `node` process (and thus our server),
    press Ctrl + C.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing Ctrl + C sends an **interrupt signal** (`SIGINT`) to the Node program,
    which handles it and terminates the server.
  prefs: []
  type: TYPE_NORMAL
- en: Our HTTP server in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break down our HTTP server code to see what''s really going on. First,
    we `require` the `http` package so we can access the HTTP module''s methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use the `createServer` method to create a server instance that listens
    to incoming requests. Inside it, we pass in a **request handler** function that
    takes a `req` and `res` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers use `req` and `res` as shorthands for "request" and "response"
    parameter names, but you can use any variable names you like.
  prefs: []
  type: TYPE_NORMAL
- en: The `req` parameter is an object containing information about the request, such
    as its origin IP, URL, protocol, body payload (if any), and so on. The `res` object
    provides methods that help you prepare the response message to send back to the
    client; for example, you can set the header, add a response body, specify the
    content type of the body, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run `res.end()`, it finishes the preparation of the response and sends
    it back to the client. Here, we disregard what the request was, and it simply
    returns with `Hello, World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created a server instance and configured its response, the
    last step is to give it a port and instruct it to listen for requests on that
    port.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Transpiling ES6 with Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been using the CommonJS `require` syntax for modules; let's change it
    to use the ES6 module syntax (using `import`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In your code, update the first line to use `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to run our server by executing `node index.js`, it will throw a `SyntaxError:
    Unexpected token import` error. This is because Node.js support for modules is
    still experimental, and not likely to be supported without the `--experimental-modules`
    flag until late 2018.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that for us to write our source code using ES6 modules, we need
    to add an extra step that will transpile the unsupported syntax into supported
    syntax. There are a few compilers/transpilers available for us to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Babel**: The most popular and de facto standard for JavaScript compilers/transpilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traceur**: Another compiler by Google.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The TypeScript compiler**: TypeScript is a superset of JavaScript that provides
    static typing. Since valid JavaScript is also valid TypeScript, the TypeScript
    compiler can also act as an ES6 to ES5 transpiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Closure compiler**: A compiler that optimizes your JavaScript by parsing
    and analyzing it, removing dead code, refactoring existing code, and minimizing
    the final results. It also warns the user of common mistakes. The Closure compiler
    supports the ES6 syntax, but transpiles everything down to ES5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whilst the TypeScript and Closure compilers are able to transpile ES6 to ES5,
    it is not their primary function; thus naturally, these features are of limited
    use here. Babel and Traceur are tools whose sole purpose is to transform the ES6/7/8/9
    and **ESNext** syntax to JavaScript that is supported by the environment, and
    so would be more suitable for our use. Of the two, Babel is, by far, the most
    popular and active, and will be the one we use in this project.
  prefs: []
  type: TYPE_NORMAL
- en: ESNext is a collective term for features that have been submitted by members
    of the community, but have not gone through Ecma's review process (the T39 Process),
    and thus have not been incorporated into the ECMAScript standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 5 stages to the T39 Process: Strawman (Stage 0), Proposal (Stage
    1), Draft (Stage 2), Candidate (Stage 3), and Finished (Stage 4). You can get
    a more detailed description of each stage by going to [https://tc39.github.io/process-document/](https://tc39.github.io/process-document/).'
  prefs: []
  type: TYPE_NORMAL
- en: Babel is a transpiler...and more!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Babel can transpile ES6/7/8/9 and ESNext syntax into syntax that works in the
    targeted environment. For example, let''s say we have a module that uses arrow
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want this to be available on the browser, Babel can transpile it to ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, if we are running Node v8.11.4, which natively supports arrow functions,
    it will leave the function unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from supporting new ECMAScript versions, it also supports commonly used
    syntax such as JSX (used by React) and Flow static type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Different faces of Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Babel is a suite of tools—it is both a command-line tool, and a polyfill, and
    the packages are split up into many parts, such as `@babel/cli`, `@babel/register`, `@babel/node`,
    and `@babel/core`, all of which allow you to run ESNext code.
  prefs: []
  type: TYPE_NORMAL
- en: So first, let's understand what the different parts of Babel actually are, and
    how we can use Babel in our application.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/cli'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Babel CLI is the most common (and easiest) way to run Babel. It gives you
    an executable (`babel`) which you can use on the terminal to transpile files and
    directories. It is available on [npmjs.com](http://npmjs.com), and so we can install
    it using yarn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '@babel/register'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@babel/cli` package allows you to transpile source code ahead of time;
    on the other hand, `@babel/register` transpiles it at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using @babel/register for tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@babel/register` is useful during testing, as it allows you to write ESNext
    inside your tests, as they will be transpiled down before the tests are run.'
  prefs: []
  type: TYPE_NORMAL
- en: The alternative is to transpile manually using the `babel` CLI, and perform
    the tests on the transpiled code. This is acceptable; however, the line numbers
    on the transpiled code will not match the ones in the source code, making it harder
    to identify the failing test(s). Furthermore, since there is likely to be more
    boilerplate code in the transpiled code, the test coverage statistics might not
    be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, using `@babel/register` is recommended for running tests written
    in ES6.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/node'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `@babel/register` hook can integrate with other tools such as `mocha` and `nyc` and
    acts as a middle step, `@babel/node` is a stand-in replacement for `node` and supports
    ESNext syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is provided for convenience, to help you get started. It's not meant to be
    used in production since, like `@babel/register`, it transpiles the source code
    at runtime, which is highly inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: '@babel/core'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@babel/cli`, `@babel/register`, `@babel/node`, and several other packages all
    depend on `@babel/core`, which as its name implies contains the core logic behind
    Babel. In addition, the `@babel/core` package exposes API methods that you can
    use inside your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '@babel/polyfill'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Newer versions of ECMAScript provide new and cleaner syntax, and Babel transpiles
    the new syntax down to older versions of ECMAScript. However, this is more difficult
    (if not impossible) to do in the same way if you're using newer JavaScript *APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you're using the new `fetch` API instead of `XMLHttpRequest`,
    Babel won't be able to transpile this down. For APIs, we must use a polyfill;
    luckily, Babel provides the `@babel/polyfill` package.
  prefs: []
  type: TYPE_NORMAL
- en: A polyfill is code that checks whether a feature is supported in the environment,
    and if not, provides methods that mimic the native implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the polyfill, you must first install it as a dependency (not a development
    dependency):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import the `@babel/polyfill` package at the top of your code and it''ll
    mutate existing global variables to polyfill methods that are not yet supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`@babel/polyfill` uses `core-js` as its underlying polyfill.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Babel CLI and polyfill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using the Babel CLI to transpile our code, while also adding the
    Babel polyfill in order to make use of newer JavaScript APIs. Therefore, while
    still inside your project directory, run the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We used the `--dev` flag when we ran `yarn add @babel/core @babel/cli`, and
    this is because we want to include them as **development dependencies**. Development
    dependencies may include build tools, test runners, documentation generators,
    linters, and anything else that are used during development, but not used by the
    application itself.
  prefs: []
  type: TYPE_NORMAL
- en: This is done so that if someone wants to use our package in their project, they
    can just `npm install` our package and its dependencies, without also downloading
    the development dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Using Babel CLI to transpile our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s use the Babel CLI to transpile our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command uses `npx`, a tool that was introduced with `npm` v5.2.0\.
    `npx` allows you to run binaries install locally (within your project's `node_modules`
    directory, as opposed to globally) using a very tidy syntax. Instead of typing
    `./node_modules/.bin/babel index.js -o compile.js`, you can shorten it to `npx
    babel index.js -o compile.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using npx to run the local `babel` executable, which will transpile
    our `index.js` file and output it as `compiled.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the two files, you''ll see that apart from formatting changes
    (such as whitespace), the two files should be identical. This is because the Babel
    CLI, by default, will simply copy files from one place to another. To give it
    functionality, we must add plugins and specify them in a configuration file. So
    next, let''s create that configuration file. At the root of the project directory,
    create a new file named `.babelrc` and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Plugins and presets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Plugins** tell Babel how to transform your code, and **presets** are predefined
    groups of plugins. For example, you have the `es2017` preset, which includes the
    plugins `syntax-trailing-function-commas` and `transform-async-to-generator`,
    which are required to support ECMAScript 2017 syntax. There''s also the `react` preset,
    which includes the `transform-react-jsx` plugin (among others) to allow Babel
    to understand JSX.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a plugin or preset, you can install it as a development dependency,
    and specify it in the `.babelrc`. For example, if I want to support ECMAScript
    2017 syntax, but also the `rest` and `spread` operators for objects (a ES2018
    feature), I could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And, add the setting into `.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The env preset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, in the previous approach, you have to manually keep track of which
    ECMAScript features you've used, and determine whether they are compatible with
    the version of Node.js you have installed on your machine. Babel provides a better
    alternative, the `env` preset, which is available as the `@babel/preset-env` package.
    This preset will use the kangax ECMAScript compatibility tables ([kangax.github.io/compat-table/](http://kangax.github.io/compat-table/))
    to determine which features are unsupported by your environment, and download
    the appropriate Babel plugins.
  prefs: []
  type: TYPE_NORMAL
- en: This is great for our use case, because we don't want to transpile everything
    into ES5, only the `import`/`export` module syntax. Using the `env` preset will
    ensure that only the minimum number of transformations are made to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if you go to the `npmjs.com` page for `@babel/preset-es2017` or similar
    packages, you''ll see that they have been deprecated in favor of the `@babel/preset-env`
    package. Therefore, we should remove the previous plugins and presets, and use
    the `env` preset instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, replace the content of our `.babelrc` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify a targeted environment, the `env` preset will default
    to using the latest official version of ECMAScript, not including stage-x proposals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API we are writing is intended to be run only on the server, using Node,
    so we should specify that in the configuration. We can specify the exact version
    of Node we want to support, but even better, we can ask Babel to detect it for
    us using the target option `"node": "current"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, replace `.babelrc` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we can continue writing in ES6\. When we want to run our program,
    we can simply transpile it using Babel, and run the compiled script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You should, once again, receive the `'Hello World!'` text as the response when
    you send a `GET` request to `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Separating source and distribution code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, the source code consists of many files, nested inside multiple directories.
    We can transpile each file and place them next to the corresponding source file,
    but this is not ideal as it is hard to separate the distribution code from the
    source. Therefore, it's preferable to separate the source and distribution code
    into two different directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s remove the existing `compiled.js`, and create two new directories
    called `src` and `dist`. Also, move the `index.js` file into the `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should build our project again, but this time supplying the `-d` flag
    to the Babel CLI, which will compile files in our `src` directory into an output
    directory. We should also remove our existing `dist` directory before we build
    to ensure no artifacts are left behind from the previous build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Importing the Babel polyfill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, inside the `src/index.js` file, import the polyfill at the top of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to use new JavaScript APIs, such as `fetch`. Again, transpile
    the modified source code by executing `rm -rf dist/ && npx babel src -d dist`.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidating commands with npm scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's troublesome to have to type `rm -rf dist/ && npx babel src -d dist` each
    time you want to build your project. Instead, we should use **npm scripts** to
    consolidate this command into a simpler one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `package.json` file, add a new `build` sub-property to the `scripts`
    property, and set it to a string representing the command we want to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of typing  `rm -rf dist/ && npx babel src -d dist`, you can just
    type `yarn run build`, or `npm run build`—much less cumbersome! By adding this
    script into `package.json`, it allows you to share this with other developers,
    so everyone can benefit from this convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a `serve` script, which will build our application and then
    run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When we integrate with testing frameworks and documentation tools in subsequent
    chapters, we will add even more scripts here.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring cross-platform compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, we should try to ensure our npm scripts work across multiple
    platforms. So, if we have a developer working on a Mac, and another on a Linux
    machine, the script would work for both of them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to remove the `dist` directory using `cmd` in Windows,
    you'd have to run `rd /s /q dist`; while using Ubuntu's default shell (Bash),
    you'll run `rm -rf dist`. To ensure our npm script will work everywhere, we can
    use a Node package called `rimraf` ([https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf)[).
    First, install it:](https://www.npmjs.com/package/rimraf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And now update our `build` script to use `rimraf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Automating development using nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, to see the final product, we have to run the `build` script after
    each time we modify our source code. While this is fine, it can be annoying and
    a time-waster. `nodemon` is a tool that monitors for changes in our code and automatically
    restarts the `node` process when a change is detected. This can speed up development
    and testing, as we no longer need to run the `build` and `serve` scripts manually.
    Furthermore, the API served from our machine will always be the most up-to-date
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a `watch` script that uses `nodemon` instead of `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This command instructs nodemon to watch for file changes in the `src` directory
    and, whenever one is detected, to execute `yarn run serve` and restart our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run `yarn run watch`, and make a small file change in `src/index.js` (for
    example, change the text returned in the response). Pay attention to the console
    and you''ll see nodemon detecting changes and restarting our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Linting with ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we should take care to maintain a consistent code style throughout
    our project. Code styles are subjective, stylistic choices that do not alter the
    function of the program, for example, whether to use spaces or tabs, or whether
    to use `camelCase` or `underscore_case` when naming variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a consistent code style is important for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes the code more readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When working with others, contributors may override each other''s style changes.
    For instance, contributor A may change all string literals to using single-quotes,
    and contributor B may change it back to double-quotes in a subsequent commit. This
    is a problem because:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time and effort are wasted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can lead to ill-feelings because no one likes their work being overwriten
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes become hard to review, and the pertinent changes may be submerged under
    the stylistic changes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a set of code style rules is defined, a **linter** can be used to enforce
    those rules. A linter is a static analysis tool that scans your code and identifies
    code styles that do not adhere to those rules, as well as identifying potential
    bugs that arise due to syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: '*ESLint* is an open source linter for JavaScript. To use it, you would first
    document your rules inside a configuration file named `.eslintrc`. It is designed
    to be pluggable, which means developers can override the default rules and compose
    their own set of code style rules. Any violations can also be given a severity
    level of warning or error. It also provides useful features such as the `--init`
    flag, which initiates a wizard to help you compose your configuration file, as
    well as the `--fix` flag, which automatically fixes any violations that do not
    require human intervention.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s install ESLint and run its initiation wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For this project, we are going to be using Airbnb''s JavaScript style guide,
    which you can find at [https://github.com/airbnb/javascript](https://github.com/airbnb/javascript).
    Therefore, use your arrow keys to select the Use a popular style guide option,
    and press the Return key. On the next question, select the Airbnb option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it''ll ask questions about React and the configuration format; select
    the No and JSON options, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, it will check whether we have the required dependencies installed,
    and if not, prompt us to install them. Select the Yes option here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the wizard, and you should now see an `.eslintrc.json` file
    at the root of your repository, which simply reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Linting our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run `eslint` on our `src/index.js` to discover problems with our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the instructions and fix those issues, or pass the `--fix` flag to have
    ESLint fix the issues for you automatically. At the end, you should end up with
    a file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Adding lint script to package.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we did with the `build`, `serve`, and `watch` npm scripts, we can add
    a `fix` and `lint` script into our `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run `yarn run lint` to lint our entire project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the ESLint extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we can run ESLint manually, it would be even better for developer experience
    if these errors were pointed out as we are developing. To do that, we can install
    an ESLint extension for your code editor or IDE. For example, the Visual Studio
    Code ESLint Extension will add red and yellow squiggly lines below any violations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f61e6395-1eaf-463d-ab3f-c3300fa10f2e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a lot more integrations available for editors and build tools; you
    can find a comprehensive list at [https://eslint.org/docs/user-guide/integrations](https://eslint.org/docs/user-guide/integrations).
  prefs: []
  type: TYPE_NORMAL
- en: Adding pre-commit hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, we're not quite finished yet. Many developers are careless and forgetful.
    Even with `eslint` installed and the extension configured, they may still forget
    to run the lint command before committing badly styled code. To help them, we
    can implement **Git hooks**, which are programs that are triggerred to run at
    defined points in Git's execution.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Git hooks are stored inside the `.git/hooks` directory. If you look
    inside the directory, you'll find many sample hooks with the `.sample` file extension.
    The one we are interested in is the `pre-commit` hook, which is executed after
    the `git commit` command is issued, but before the actual commit is made.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are written as a shell script. For the `pre-commit` hook, we can abort
    the commit by returning a non-zero exit code. Conveniently, when ESLint detects
    code style violations, it will exit with a status code of `1`; therefore, in our
    script, we can simply return the exit code returned by `eslint`. When writing
    a hook manually, you should take care to only use syntax that abides by the POSIX
    standard, because other developers may use a different type of shell from you.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if writing shell scripts manually sounds like too much work for you,
    there''s a tool called **Husky**, which hugely simplifies the process for us.
    Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Husky will insert its own Git hooks into our project. In these hooks, it will
    check our `package.json` for scripts with special names and run them. For instance,
    our `pre-commit` hook will check for a script named `precommit`. Therefore, to
    run our lint command with Husky, all we have to do is add a new npm script called
    `precommit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to commit any badly formatted code, it will throw an error and
    abort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Committing our code into Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finished bootstrapping our project by setting up an HTTP server and
    enabling ourselves to write in ES6\. So, let's actually commit this block of code
    into Git.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have created a new commit each time we added a new script,
    or integrated with a new tool, but because the bootstrapping of a project can
    be considered as one logical unit, we're committing all of that into one commit.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we are not going to be creating a `dev` branch just yet, as
    bootstrapping a project is not considered to be a "feature." Remember that branches
    are here to help us separate our commits by business domains; if branching provides
    no benefit for us, then it's better to be pragmatic, rather than dogmatic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `git status` to see which files we can track in our Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The list of files listed by the `git status` command includes the `node_modules/`
    and `dist/` directories, both of which do not constitute the core logic of our
    application. Furthermore, they can be regenerated from our source code—`node_modules/`
    from the `package.json` and `yarn.lock` files, and `dist/` from the `src/` directory.
    Moreover, the `node_modules/` directory can be very large, as it includes a copy
    of all third-party libraries we are depending on in our application. Therefore,
    let's make sure the `node_modules/` and `dist/` directories are not tracked in
    our Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using .gitignore to ignore files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git allows for a special `.gitignore` file that allows us to specify which
    files Git should ignore. So, create a `.gitignore` file at the project root directory,
    and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run `git status` again, `node_modules/` and `dist/` are gone from
    our list, and `.gitignore` is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the `node_modules/` and `dist/` directories, there will be many other
    files we'll eventually want Git to ignore; for example, a `yarn-error.log` is
    generated whenever `yarn` encounters an error. It is for our information only
    and should not be tracked on Git. While we can keep adding more and more lines
    to the `.gitignore` file as is required, many others working with Node.js have
    already worked together to compile a list of common files and directories that
    most projects should ignore; we can use that as a basis and modify it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    and replace our `.gitignore` file with the content of the `Node.gitignore` file;
    but remember to add the `dist/` entry back at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add everything to the staging area and commit them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of this chapter, we looked at the difference between CommonJS and
    ES6 modules, and settled on using the new ES6 module syntax, which uses the `import`
    and `export` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we installed Node on our machine using nvm, and got acquainted with the
    `npm` and `yarn` package managers. We then set up a simple HTTP server using the
    native `http` Node module. After that, we used Babel to transpile our ESNext code
    into a syntax supported by our local environment. We also set up `nodemon` to
    watch for changes in our code and restart the server whenever a change is detected.
    Lastly, we incorporated ESLint to spot problems in our code, and use a `pre-commit`
    Git hook to run the linter automatically before each commit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be following a **test-driven development** (**TDD**)
    approach to develop our API server, to provide functionalities for clients to
    **create, read, update, and delete** (**CRUD**) user objects on our database,
    using **ElasticSearch** as our data storage solution.
  prefs: []
  type: TYPE_NORMAL
- en: In general, each subsequent chapter will incorporate a new set of tools to the
    application. The book will focus first on the backend, server-side code, later
    moving on to frontend, client-side code, before rounding off the book by looking
    at implementing an automated deployment process.
  prefs: []
  type: TYPE_NORMAL
