- en: Chapter 7. Saving the Game's Progress
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。保存游戏进度
- en: '*Local storage is a new specification from HTML5\. It allows a website to store
    information in the browser locally and access the stored data later. This is a
    useful feature in game development because we can use it as a memory slot to save
    any game data locally in a web browser.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地存储是 HTML5 的新规范。它允许网站在浏览器中本地存储信息，并在以后访问存储的数据。这对于游戏开发来说是一个有用的功能，因为我们可以用它作为内存槽，在网页浏览器中本地保存任何游戏数据。*'
- en: We are going to add the feature of storing game data in the CSS3 card matching
    game we built in [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game
    in CSS3"), *Building a Card-matching Game in CSS3*. Besides storing and loading
    the game data, we will also notify the player when they break a record with a
    nice 3D ribbon using pure CSS3 styling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们在[第3章](ch03.html "第3章。使用 CSS3 制作卡片匹配游戏")中构建的 CSS3 卡片匹配游戏中添加存储游戏数据的功能。除了存储和加载游戏数据外，我们还将使用纯
    CSS3 样式通知玩家，当他们打破纪录时，会出现一个漂亮的 3D 丝带。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Storing data by using HTML5 local storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML5 本地存储存储数据
- en: Saving the object in the local storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地存储中保存对象
- en: Notifying players when they break a new record with a nice ribbon effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家打破新纪录时，通过漂亮的丝带效果通知他们
- en: Saving the entire game's progress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存整个游戏进度
- en: 'You may try the final game at: [http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接尝试最终游戏：[http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/).
- en: 'The following screenshot shows the final result we will create in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章我们将创建的最终结果：
- en: '![Saving the Game''s Progress](img/B04290_07_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![保存游戏进度](img/B04290_07_01.jpg)'
- en: So, let's get on with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Storing data using HTML5 local storage
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML5 本地存储存储数据
- en: Remember the CSS3 card matching game we made in [Chapter 3](ch03.html "Chapter 3. Building
    a Card-matching Game in CSS3"), *Building a Card-matching Game in CSS3*? Imagine
    now that we have published our game and players are trying their best to perform
    well in the game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第3章](ch03.html "第3章。使用 CSS3 制作卡片匹配游戏")中制作的 CSS3 卡片匹配游戏吗？想象一下，我们现在已经发布了我们的游戏，玩家们正在尽力在游戏中表现良好。
- en: We want to show the players whether they played better or worse than the last
    time. We will save the latest score and inform players whether they are better
    or not this time, by comparing the scores.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想显示玩家是否比上次玩得更好或更差。我们将保存最新的分数，并通过比较分数来通知玩家他们这次是否表现得更好。
- en: The reasons we might want to do this are because it gives the player a sense
    of pride when they perform better, and they may become addicted to our game to
    try to get higher scores, which is good for us.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要这样做的原因是，当玩家表现更好时，它会给玩家一种自豪感，他们可能会沉迷于我们的游戏，试图获得更高的分数，这对我们来说是有益的。
- en: Creating a game over dialog
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏结束对话框
- en: Before actually saving anything in the local storage, we need a game over screen.
    We made a few games in previous chapters. We made a Ping Pong game, the card matching
    game, the Untangle puzzle game, and a music game. In these games, we did not create
    any game over screen. Imagine now that we are playing the CSS3 card matching game
    that we built in [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game
    in CSS3"), *Building a Card-matching Game in CSS3*. We successfully match and
    remove all cards. Once we finish a game a screen pops up and shows the time we
    took to complete the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际将任何内容保存到本地存储之前，我们需要一个游戏结束屏幕。我们在前面的章节中制作了一些游戏。我们制作了乒乓球游戏、卡片匹配游戏、解谜游戏和音乐游戏。在这些游戏中，我们没有创建任何游戏结束屏幕。想象一下，我们现在正在玩我们在[第3章](ch03.html
    "第3章。使用 CSS3 制作卡片匹配游戏")中构建的 CSS3 卡片匹配游戏，*使用 CSS3 制作卡片匹配游戏*。我们成功匹配并移除了所有卡片。一旦完成游戏，屏幕就会弹出并显示完成游戏所需的时间。
- en: Time for action – creating a game over dialog with the elapsed played time
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建一个基于已玩时间的游戏结束对话框
- en: 'We will continue with the code from the card matching game we made in [Chapter
    3](ch03.html "Chapter 3. Building a Card-matching Game in CSS3"), *Building a
    Card-matching Game in CSS3*. Carry out the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在[第3章](ch03.html "第3章。使用 CSS3 制作卡片匹配游戏")中制作的卡片匹配游戏的代码，*使用 CSS3 制作卡片匹配游戏*。执行以下步骤：
- en: Open the CSS3 matching game folder as our working directory.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 CSS3 匹配游戏文件夹作为我们的工作目录。
- en: 'Download a background image from the following URL (we will use it as the background
    of the popup): [http://mak.la/book-assets](http://mak.la/book-assets)'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下URL下载背景图片（我们将将其用作弹出窗口的背景）：[http://mak.la/book-assets](http://mak.la/book-assets)
- en: Place the image in the `images` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片放在`images`文件夹中。
- en: Open `index.html` in any text editor.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何文本编辑器中打开`index.html`。
- en: 'We will need a font for the game over popup. Add the following font embedding
    CSS into the `head` section:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个字体用于游戏结束弹出窗口。将以下字体嵌入CSS添加到`head`部分：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before the `game` section, we add a `div` named `timer` to show the elapsed
    playing time. In addition, we add a new `popup` section containing the HTML markup
    of the pop-up dialog:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`game`部分之前，我们添加一个名为`timer`的`div`来显示经过的游戏时间。此外，我们添加一个新的`popup`部分，包含弹出对话框的HTML标记：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will now move on to the style sheet. As it is just for styling and not related
    to our logic yet, we can simply copy the `matchgame.css` file from `01-gameover-dialog`
    in the code example bundle.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将转到样式表。因为它只是用于样式，还没有与我们的逻辑相关联，所以我们可以简单地从代码示例包中的`01-gameover-dialog`复制`matchgame.css`文件。
- en: It is time to edit the game's logic part. Open the `matchgame.js` file in an
    editor.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候编辑游戏的逻辑部分了。在编辑器中打开`matchgame.js`文件。
- en: 'In the jQuery `ready` function, we need a variable to store the elapsed time
    of the game. Then, we create a timer to count the game every second as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery的`ready`函数中，我们需要一个变量来存储游戏的经过时间。然后，我们创建一个计时器来每秒计算游戏时间，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add a `countTimer` function that will be executed every second. It
    displays the elapsed seconds in the minutes and seconds format:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个`countTimer`函数，它将每秒执行一次。它以分钟和秒的格式显示经过的秒数：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `removeTookCards` function that we wrote earlier, add the following
    highlighted code that executes the game over logic after removing all cards:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前编写的`removeTookCards`函数中，添加以下高亮显示的代码，在移除所有卡片后执行游戏结束逻辑：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And last, we create the following `gameover` function. It stops the counting
    timer, displays the elapsed time in the game over popup, and finally shows the
    popup:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建以下`gameover`函数。它停止计时器，在游戏结束弹出窗口中显示经过时间，并最终显示弹出窗口：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, save all files and open the game in a browser. Try finishing the card matching
    game and the game over screen will popup, as shown in the following screenshot:![Time
    for action – creating a game over dialog with the elapsed played time](img/B04290_07_02.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存所有文件，并在浏览器中打开游戏。尝试完成卡片匹配游戏，游戏结束屏幕将弹出，如下面的截图所示：![行动时间 – 创建带有经过时间的游戏结束对话框](img/B04290_07_02.jpg)
- en: '*What just happened?*'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We used the CSS3 transition animation to show the game over popup. We benchmark
    the score by using the time the player utilized to finish the game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CSS3过渡动画来显示游戏结束弹出窗口。我们通过玩家完成游戏所用的时间来衡量分数。
- en: Counting time
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时
- en: We used the time interval to calculate elapsed time. We provide an interval,
    for instance, 1 second, and the browser executes our logic at the provided interval.
    Inside the logic, we count the elapsed seconds. We need to keep in mind that `setInterval`
    does not guarantee the execution of the logic precisely at the given time interval.
    It's an approximate value. If you need a more precise elapsed time, you may get
    the time stamp and subtract it from the start time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用时间间隔来计算经过时间。我们提供一个间隔，例如1秒，浏览器将在提供的间隔执行我们的逻辑。在逻辑内部，我们计算经过的秒数。我们需要记住，`setInterval`不能保证逻辑在给定的时间间隔精确执行。它是一个近似值。如果您需要更精确的经过时间，您可以从开始时间减去时间戳。
- en: Saving scores in the browser
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中保存分数
- en: Imagine now that we are going to display how well the player played last time.
    The game over screen includes the elapsed time as the last score alongside the
    current game score. Players can then see how well they do this time compared to
    last time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们现在将要显示玩家上次玩得有多好。游戏结束屏幕包括作为最后得分的经过时间以及当前游戏得分。玩家可以比较这次和上次的表现。
- en: Time for action – saving the game score
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 保存游戏分数
- en: 'First, we need to add a few markups in the `popup` section to display the last
    score. Add the following HTML in `popup-box` in `index.html`. The changed code
    is highlighted:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`popup`部分添加一些标记来显示最后得分。在`index.html`中的`popup-box`中添加以下HTML。更改的代码已高亮显示：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we open the `matchgame.js` to modify some game logic in the `gameover`
    function.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打开`matchgame.js`来修改`gameover`函数中的某些游戏逻辑。
- en: 'Add the following highlighted code in the `gameover` function. It loads the
    saved score from the local storage and displays it as the score last time. Then,
    we save the current score in the local storage:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `gameover` 函数中添加以下突出显示的代码。它从本地存储中加载保存的分数，并将其显示为上次的游戏分数。然后，我们将当前分数保存在本地存储中：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is now time to save all the files and test the game in the browser. When
    you finish the game for the first time, the last score should be `00:00`. Then,
    try to finish the game for the second time. The game over popup will show the
    elapsed time when you played the last time. The following screenshot shows the
    game over screen with the current and last score:![Time for action – saving the
    game score](img/B04290_07_03.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候保存所有文件并在浏览器中测试游戏了。当你第一次完成游戏时，最后得分应该是 `00:00`。然后，尝试第二次完成游戏。游戏结束弹窗将显示你上次玩游戏时经过的时间。以下截图显示了带有当前和上次得分的游戏结束界面：![操作时间
    – 保存游戏分数](img/B04290_07_03.jpg)
- en: '*What just happened?*'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just built a basic scoring system that compares a player's score with their
    last score.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个基本的计分系统，该系统比较玩家的分数和他们的上次分数。
- en: Storing and loading data with local storage
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地存储存储和加载数据
- en: 'We can store data by using the `setItem` function from the `localStorage` object
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `localStorage` 对象的 `setItem` 函数来存储数据，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following table shows the usage of the function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了该函数的用法：
- en: '| Argument | Definition | Description |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 定义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `key` | The key is the name of the record that we used to identify an entry
    | The key is a string and each record has a unique key. Writing a new value to
    an existing key overwrites the old value. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 键是用于识别条目的记录名称 | 键是一个字符串，每个记录都有一个唯一的键。向现有键写入新值将覆盖旧值。|'
- en: '| `value` | The value is any data that will be stored | This can be any data,
    but the final storage is in a string. We will discuss this shortly. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 值是要存储的数据 | 这可以是任何数据，但最终存储的是字符串。我们将在稍后讨论这一点。|'
- en: 'In our example, we save the game elapsed time as the score with the following
    code by using the key `last-elapsed-item`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用键 `last-elapsed-item` 通过以下代码将游戏经过的时间保存为分数：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Complementary to `setItem`, we get the stored data by using the `getItem` function
    in the following way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `setItem` 相辅相成，我们可以通过以下方式使用 `getItem` 函数获取存储的数据：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function returns the stored value of the given key. It returns `null` when
    trying to get a non-existent key. This can be used to check whether we have stored
    any data for a specific key.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回给定键的存储值。当尝试获取不存在的键时，它返回 `null`。这可以用来检查我们是否为特定键存储了任何数据。
- en: The local storage saves the string value
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地存储保存字符串值
- en: The local storage stores data in a key-value pair. The key and value are both
    strings. If we save numbers, Boolean, or any type other than a string, then the
    browser will convert the value into a string while saving. For objects and arrays,
    we will do our conversion using JSON in a later section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储以键值对的形式存储数据。键和值都是字符串。如果我们保存数字、布尔值或任何非字符串类型，则浏览器在保存时将值转换为字符串。在稍后的部分，我们将使用
    JSON 对对象和数组进行转换。
- en: Usually, problems occur when we load a saved value from the local storage. The
    loaded value is a string regardless of the type we are saving. We need to explicitly
    parse the value into the correct type before using it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们从本地存储中加载保存的值时会出现问题。无论我们保存的类型是什么，加载的值都是一个字符串。在使用之前，我们需要显式地将值解析为正确的类型。
- en: 'For example, if we save a floating number into the local storage, we need to
    use the `parseFloat` function when loading it. The following code snippet shows
    how we can use `parseFloat` to retrieve a stored floating number:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将浮点数保存到本地存储中，则在加载时需要使用 `parseFloat` 函数。以下代码片段显示了如何使用 `parseFloat` 来检索存储的浮点数：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, the manipulation may be incorrect if we forget
    to convert `gameScore` from a string to a float. For instance, if we increase
    `gameScore` by 1 without the `parseFloat` function, the result will be **13.2341**
    instead of **14.234**. So, be sure to convert the value from the local storage
    to its correct type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，如果我们忘记将 `gameScore` 从字符串转换为浮点数，则操作可能是不正确的。例如，如果我们不使用 `parseFloat`
    函数将 `gameScore` 增加 1，则结果将是 **13.2341** 而不是 **14.234**。因此，请确保将本地存储中的值转换为正确的类型。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Size limitations on local storage**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地存储的大小限制**'
- en: There is a size limitation on the data stored through `localStorage` for each
    domain. This size limitation may be slightly different in different browsers.
    Normally, the size limitation is 5 MB. If the limit is exceeded, then the browser
    throws a `QUOTA_EXCEEDED_ERR` exception when setting a key-value into `localStorage`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`localStorage`存储的数据在各个域上都有大小限制。这个大小限制在不同的浏览器中可能略有不同。通常，大小限制是5MB。如果超过限制，则在将键值设置到`localStorage`时，浏览器会抛出`QUOTA_EXCEEDED_ERR`异常。
- en: Treating the local storage object as an associative array
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地存储对象视为关联数组
- en: 'Besides using the `setItem` and `getItem` functions, we can treat the `localStorage`
    object as an associated array and access the stored entries by using square brackets.
    For instance, consider the following lines of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`setItem`和`getItem`函数外，我们还可以将`localStorage`对象视为关联数组，并使用方括号访问存储条目。例如，考虑以下代码行：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can replace the preceding block of code with the following one and access
    `localStorage` as an array:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码替换前面的代码块，并将`localStorage`作为数组访问：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Saving objects in the local storage
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地存储中保存对象
- en: Now, imagine that we are saving not only the score, but also the date and time
    when the ranking is created. We can either save two separate keys for the score
    and date time of playing, or pack the two values into one object and store it
    in the local storage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们不仅保存分数，还保存创建排名时的日期和时间。我们可以为得分和游戏时的日期时间保存两个单独的键，或者将两个值打包到一个对象中并存储在本地存储中。
- en: We will pack all the game data into one object and store it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有游戏数据打包到一个对象中并存储。
- en: Time for action – saving the time alongside the score
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 将时间与分数一起保存
- en: 'Carry out the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, open the `index.html` file from our CSS3 card matching game.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从我们的CSS3卡片匹配游戏中打开`index.html`文件。
- en: 'Replace the HTML markup with the last score, with the following HTML (it shows
    both scores and the date time in the game over popup):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTML标记替换为最后得分，使用以下HTML（它在游戏结束弹出窗口中显示得分和日期时间）：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The HTML markup is now ready. We will move on to the game logic. Open the `html5games.matchgame.js`
    file in a text editor.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML标记现在已准备好。我们将继续进行游戏逻辑。在文本编辑器中打开`html5games.matchgame.js`文件。
- en: 'We will modify the `gameover` function. Add the following highlighted code
    to the `gameover` function. It gets the current date and time when the game ends
    and packs a formatted date and time with elapsed time together in the local storage:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改`gameover`函数。将以下高亮代码添加到`gameover`函数中。它获取游戏结束时当前日期和时间，并将格式化的日期和时间与经过的时间一起打包到本地存储中：
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will save the files and open the game in a web browser.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保存文件并在网页浏览器中打开游戏。
- en: When we finish the game for the first time, we will get a screen similar to
    the following screenshot, which will show our game score and state that there
    are no previous records:![Time for action – saving the time alongside the score](img/B04290_07_04.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们第一次完成游戏时，我们将得到一个类似于以下截图的屏幕，它将显示我们的游戏得分和状态，表明没有之前的记录：![行动时间 – 将时间与分数一起保存](img/B04290_07_04.jpg)
- en: Now try reloading the page and play the game again. When we finish the game
    for the second time, the game over dialog will show our saved record. The following
    screenshot shows how it should look:![Time for action – saving the time alongside
    the score](img/B04290_07_05.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试重新加载页面并再次玩游戏。当我们第二次完成游戏时，游戏结束对话框将显示我们的保存记录。以下截图显示了它应该看起来像什么：![行动时间 – 将时间与分数一起保存](img/B04290_07_05.jpg)
- en: '*What just happened?*'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just used a `Date` object in JavaScript to get the current date and time
    when the game is over. In addition, we packed the game over date and time and
    the game elapsed time in one object and saved it in the local storage. The saved
    object is encoded in a JSON string. It will also load the last saved date and
    time and the game elapsed time from the storage and parse it back to the JavaScript
    object from a string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript中使用了`Date`对象来获取游戏结束时当前日期和时间。此外，我们将游戏结束的日期和时间以及游戏经过的时间打包到一个对象中，并将其保存在本地存储中。保存的对象被编码为JSON字符串。它还会从存储中加载最后保存的日期和时间以及游戏经过的时间，并将其从字符串解析回JavaScript对象。
- en: Getting the current date and time in JavaScript
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中获取当前日期和时间
- en: The `Date` object in JavaScript is used to work with the date and time. When
    we create an instance from the `Date` object, by default it stores the current
    date and time. We can get the string representation by using the `toLocaleString`
    method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`Date`对象用于处理日期和时间。当我们从`Date`对象创建一个实例时，默认情况下它存储当前日期和时间。我们可以通过使用`toLocaleString`方法来获取字符串表示形式。
- en: 'In addition to the string representation, we can manipulate each component
    in the date object. The following table lists some useful functions in the `Date`
    object to get the date and time:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串表示形式，我们还可以操作日期对象中的每个组件。以下表格列出了`Date`对象中一些获取日期和时间的有用函数：
- en: '| Function | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getFullYear` | Returns the year in four digits |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `getFullYear` | 返回四位数的年份 |'
- en: '| `getMonth` | Returns the month in an integer, starting from 0 (Jan is 0 and
    Dec is 11) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `getMonth` | 返回整数月份，从0开始（1月是0，12月是11）|'
- en: '| `getDate` | Returns the day of the month, starting from 1 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `getDate` | 返回月份中的天数，从1开始 |'
- en: '| `getDay` | Returns the day of the week, starting from 0 (Sunday is 0 and
    Saturday is 6) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `getDay` | 返回星期几，从0开始（星期天是0，星期六是6）|'
- en: '| `getHours` | Returns the hour, starting from 0 to 23 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `getHours` | 返回小时，从0到23 |'
- en: '| `getMinutes` | Returns the minutes |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `getMinutes` | 返回分钟 |'
- en: '| `getSeconds` | Returns the seconds |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `getSeconds` | 返回秒数 |'
- en: '| `getMilliseconds` | Returns the milliseconds in 3 digits |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `getMilliseconds` | 返回三位数的毫秒数 |'
- en: '| `getTime` | Returns the number of milliseconds since 1 January, 1970, 00:00
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `getTime` | 返回自1970年1月1日00:00以来的毫秒数 |'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Mozilla Developer Network provides a detailed reference on using the `Date`
    object at: [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla开发者网络提供了关于使用`Date`对象的详细参考，请参阅：[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date)。
- en: Using the native JSON to encode an object into a string
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生的JSON将对象编码为字符串
- en: We used JSON to represent the game level data in [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。使用Canvas和绘图API构建Untangle游戏") *使用Canvas和绘图API构建Untangle游戏*
    中使用了JSON来表示游戏关卡数据。
- en: 'JSON is an object notation format that is friendly for machines to parse and
    generate. In this example, we packed the final elapsed time and the date and time
    into an object. Then, we encoded the object into JSON. Modern web browsers come
    with native JSON support. We can easily encode any JavaScript object into JSON
    by using the `stringify` function as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种机器友好的对象表示法格式，易于解析和生成。在这个例子中，我们将最终经过的时间和日期时间打包到一个对象中。然后，我们将对象编码为JSON。现代网络浏览器都内置了对JSON的原生支持。我们可以通过使用以下`stringify`函数轻松地将任何JavaScript对象编码为JSON：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Normally, we only use the first parameter for the `stringify` function. This
    is the object that we are going to encode as a string. The following code snippet
    demonstrates the result of an encoded JavaScript object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只为`stringify`函数的第一个参数使用。这是我们打算编码为字符串的对象。以下代码片段演示了编码JavaScript对象的结果：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `stringify` method can parse objects with data structure into a string well.
    However, it cannot convert anything from an object into a string. For instance,
    it will return an error if we try to pass a DOM element into it. It will return
    the string representing the date if we pass a `Date` object. Alternatively, it
    will drop all method definitions of the parsing object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringify`方法可以很好地解析具有数据结构的对象到字符串。然而，它不能将任何对象转换为字符串。例如，如果我们尝试将DOM元素传递给它，它将返回一个错误。如果我们传递一个`Date`对象，它将返回表示日期的字符串。否则，它将丢弃解析对象的全部方法定义。'
- en: Loading a stored object from a JSON string
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从JSON字符串加载存储的对象
- en: The complete form of **JSON** is **JavaScript** **Object** **Notation**. From
    the name, we know that it uses the syntax from JavaScript to represent an object.
    Therefore, it is very easy to parse a JSON formatted string back to a JavaScript
    object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**的完整形式是**JavaScript** **对象** **表示法**。从名称中，我们知道它使用JavaScript的语法来表示对象。因此，将JSON格式的字符串解析回JavaScript对象非常容易。'
- en: 'The following code snippet shows how we can use the parse function in the JSON
    object:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何使用JSON对象中的解析函数：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can open the console in **Web Inspector** to test the JSON JavaScript functions.
    The following screenshot shows the result of running the code snippets we just
    discussed when encoding an object and parsing them:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**Web Inspector**中打开控制台来测试JSON JavaScript函数。以下截图显示了当我们对对象进行编码并解析时运行我们刚才讨论的代码片段的结果：
- en: '![Loading a stored object from a JSON string](img/B04290_07_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Loading a stored object from a JSON string](img/B04290_07_06.jpg)'
- en: Inspecting the local storage in a console window
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制台窗口中检查本地存储
- en: After we have saved something in the local storage, we may want to know what
    exactly is saved, before we write the loading part. We can inspect what we have
    saved by using the storage panel in the **Web Inspector**. It lists all the saved
    key-value pairs under the same domain. The following screenshot shows that we
    have the **last-score** key saved with value **{"savedTime":"23/2/2011 19:27:02","score":23}**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将某些内容保存到本地存储之后，我们可能想在编写加载部分之前知道确切保存了什么。我们可以通过使用**Web Inspector**中的存储面板来检查我们保存的内容。它列出了同一域名下的所有保存的键值对。以下截图显示我们有一个**last-score**键，其值为**{"savedTime":"23/2/2011
    19:27:02","score":23}**。
- en: 'The value is the result of the `JSON.stringify` function we used to encode
    the object into JSON. You may also try saving an object directly in the local
    storage:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该值是我们用来将对象编码为JSON的`JSON.stringify`函数的结果。您也可以尝试直接在本地存储中保存对象：
- en: '![Inspecting the local storage in a console window](img/B04290_07_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Inspecting the local storage in a console window](img/B04290_07_07.jpg)'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Besides `localStorage`, there are other storage approaches that were not discussed.
    **IndexedDB** is another option. Check the following URL to see more details on
    this: [https://developer.mozilla.org/en/IndexedDB](https://developer.mozilla.org/en/IndexedDB).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`localStorage`之外，还有其他未讨论的存储方法。**IndexedDB**是另一个选项。查看以下链接以获取更多详细信息：[https://developer.mozilla.org/en/IndexedDB](https://developer.mozilla.org/en/IndexedDB)。
- en: Notifying players when they break a new record with a nice ribbon effect
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当玩家打破新纪录时，通过漂亮的横幅效果通知玩家
- en: Imagine that we want to encourage players by informing them that they broke
    a new record compared to the last score. We want to show a ribbon with `New` `Record`
    text on it. Thanks to the new CSS3 properties, we can create a ribbon effect completely
    in CSS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想要通过通知玩家他们与上次得分相比打破了新纪录来鼓励他们。我们想在横幅上显示`New` `Record`文本。多亏了新的CSS3属性，我们可以在CSS中完全创建横幅效果。
- en: Time for action – creating a ribbon in CSS3
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Time for action – creating a ribbon in CSS3
- en: 'We will create a new record ribbon and display it when a player breaks their
    last score. So, carry out the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的纪录横幅，并在玩家打破上次得分时显示它。所以，执行以下步骤：
- en: First, open `index.html` where we will add the ribbon HTML markup.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`index.html`，我们将添加横幅HTML标记。
- en: 'Add the following highlighted HTML right after `popup-box` and before `popup-box-content`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`popup-box`之后和`popup-box-content`之前添加以下高亮的HTML代码：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we need to focus on the style sheet. The entire ribbon effect is done
    in CSS. Open the `matchgame.css` file in a text editor.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要关注样式表。整个横幅效果都是在CSS中完成的。在文本编辑器中打开`matchgame.css`文件。
- en: 'In the `popup-box` styling, we need to add a relative position to it. We do
    this as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`popup-box`的样式表中，我们需要给它添加一个相对定位。我们这样做如下：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we need to add the following styles that create the ribbon effect in
    the CSS file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在CSS文件中添加以下样式，以创建横幅效果：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Lastly, we need to modify the game over logic a little bit. Open the `html5games.matchgame.js`
    file and locate the `gameover` function.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要稍微修改一下游戏结束的逻辑。打开`html5games.matchgame.js`文件，定位到`gameover`函数。
- en: 'Add the following code to the `gameover` function, which compares the current
    score with the last score to determine the new record:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`gameover`函数中，该函数比较当前得分与最后得分以确定新纪录：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will test the game in a web browser. Try finishing a game slowly and then
    finish another game fast. When you break the last score, the game over popup shows
    a nice **NEW** **RECORD** ribbon, as shown in the following screenshot:![Time
    for action – creating a ribbon in CSS3](img/B04290_07_08.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在网页浏览器中测试这款游戏。尝试慢慢完成一个游戏，然后快速完成另一个游戏。当你打破最后得分时，游戏结束弹窗会显示一个漂亮的**NEW** **RECORD**横幅，如下面的截图所示：![Time
    for action – creating a ribbon in CSS3](img/B04290_07_08.jpg)
- en: '*What just happened?*'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just created a ribbon effect in a pure CSS3 style with some help from JavaScript
    to show and hide it. The ribbon is composed of a little triangle overlaid by a
    rectangle, as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用纯CSS3样式创建了一个带绶带效果，并借助JavaScript来显示和隐藏它。绶带由一个三角形和覆盖其上的矩形组成，如下面的截图所示：
- en: '![What just happened?](img/B04290_07_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_07_09.jpg)'
- en: 'Now, how can we create a triangle in CSS? We can create a triangle by setting
    both the width and height to `0` and drawing only one border. The size of the
    triangle is then decided by the border width. The following is the code for the
    triangle CSS we used in our new record ribbon:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在CSS中创建一个三角形？我们可以通过将宽度和高度都设置为`0`并只绘制一个边框来创建一个三角形。三角形的尺寸由边框宽度决定。以下是我们用于新记录绶带的三角形CSS代码：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following PVM Garage website provides a detailed explanation on pure CSS3
    ribbon usage:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下PVM Garage网站提供了关于纯CSS3绶带使用的详细说明：
- en: '[http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/](http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何仅使用CSS3创建深度和漂亮的3D绶带](http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/)'
- en: Have a go hero – saving and comparing only to the fastest time
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 只保存和比较最快的时间
- en: Each time the game finishes, it compares the last score with the current score.
    Then, it saves the current score. How about changing the code to save the highest
    score and show the new record ribbon when breaking the highest score?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游戏结束时，它会将最后得分与当前得分进行比较。然后，它保存当前得分。那么，将代码更改为保存最高分，并在打破最高分时显示新的记录绶带怎么样？
- en: Saving the entire game progress
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存整个游戏进度
- en: We have enhanced our CSS3 card matching game by adding a game over screen and
    storing the last game record. Imagine now that a player is mid-game and accidentally
    closes the web browser. Once the player opens the game again, the game starts
    from the beginning and the game that the player was playing is lost. With the
    local storage, we can encode the entire game's data into JSON and store it. In
    this way, players can resume their game later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加游戏结束屏幕和存储最后游戏记录来增强了我们的CSS3牌匹配游戏。想象一下，玩家正在游戏中，意外关闭了网络浏览器。一旦玩家再次打开游戏，游戏将从开始处重新开始，玩家正在玩的游戏就会丢失。使用本地存储，我们可以将整个游戏数据编码为JSON并存储起来。这样，玩家可以在以后继续他们的游戏。
- en: We are going to pack the game data into one object and save it into the local
    storage every second.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把游戏数据打包成一个对象，并每秒将其保存在本地存储中。
- en: Time for action – saving all essential game data in the local storage
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在本地存储中保存所有必要游戏数据
- en: 'We will continue work with our CSS3 card matching game:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的CSS3牌匹配游戏：
- en: Open the `matchgame.js` JavaScript file.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`matchgame.js`JavaScript文件。
- en: 'Add the following code at the top of the JavaScript file after declaring the
    `matchingGame` variable. This code creates an object named `savingObject` to save
    the array of the deck, the removed cards and the current elapsed time:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明`matchingGame`变量之后，在JavaScript文件顶部添加以下代码。此代码创建一个名为`savingObject`的对象来保存牌组数组、移除的牌和当前已过时间：
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the jQuery `ready` function, add the following highlighted code. It clones
    the order of the deck to the `savingObject`. In addition, it assigns an index
    to each card in the DOM data attribute:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery `ready`函数中，添加以下突出显示的代码。它将牌组的顺序克隆到`savingObject`中。此外，它还为DOM中的每张牌分配一个索引：
- en: '[PRE25]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have a `countTimer` function that executes every second. We add the following
    highlighted code in the `countTimer` function. It saves the current elapsed time
    in `savingObject` and also saves the object in the local storage:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个`countTimer`函数，每秒执行一次。我们在`countTimer`函数中添加以下突出显示的代码。它在`savingObject`中保存当前已过时间，并将对象保存在本地存储中：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The game removes cards when the player finds a matching pair. We replace the
    original `$(".card-removed").remove();` code with the following highlighted code
    in the `removeTookCards` function. It remembers which cards are removed in `savingObject`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家找到匹配的牌对时，游戏会移除牌。我们在`removeTookCards`函数中将原始的`$(".card-removed").remove();`代码替换为以下突出显示的代码。它在`savingObject`中记住哪些牌被移除：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have to remove the saved game data in the local storage when the game is
    over. Add the following code at the end of the `gameover` function:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏结束时，我们必须从本地存储中删除保存的游戏数据。在`gameover`函数的末尾添加以下代码：
- en: '[PRE28]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And last, we use a function to save `savingObject` in the local storage:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用一个函数将`savingObject`保存在本地存储中：
- en: '[PRE29]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have modified the code a lot and it is now time to test the game in a web
    browser. After the game runs, try clearing several matching cards. Then, open
    the storage panel in the **Web Inspector**. The local storage should contain an
    entry similar to the one shown in the following screenshot:![Time for action –
    saving all essential game data in the local storage](img/B04290_07_10.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经修改了很多代码，现在是时候在网页浏览器中测试游戏了。游戏运行后，尝试清除几对匹配的卡片。然后，打开**Web Inspector**中的存储面板。本地存储应包含类似于以下截图中的条目：![行动时间
    – 将所有必要游戏数据保存到本地存储](img/B04290_07_10.jpg)
- en: It is a record with a key `savingObject` and a value with a long string in a
    JSON format. The JSON string contains the shuffled deck, removed cards, and the
    current elapsed time
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个带有`savingObject`键和包含长字符串的JSON格式的值的记录。该JSON字符串包含洗好的牌组、移除的卡片和当前已过的时间
- en: '*What just happened?*'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have just entered all essential game data into an object named `savingObject`.
    This `savingObject` contains all the information that we need to recreate the
    game later. It includes the order of cards, removed cards, and the current elapsed
    time. We will implement the game resuming logic in the next section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有必要的游戏数据输入到一个名为`savingObject`的对象中。这个`savingObject`包含了我们稍后重新创建游戏所需的所有信息。它包括卡片的顺序、移除的卡片和当前已过的时间。我们将在下一节中实现游戏恢复逻辑。
- en: Lastly, we saved `savingObject` in `localStorage` each second. The object is
    encoded in JSON using the `stringify` function we used earlier in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们每秒将`savingObject`保存到`localStorage`中。该对象使用我们在本章前面使用的`stringify`函数进行编码。
- en: Removing a record from the local storage
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地存储中删除记录
- en: 'We need to remove the saved record when the game is over. Otherwise, the new
    game will not start. The local storage provides a `removeItem` function to remove
    a specific record. Here is how we use the function to remove the record with the
    given key:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，我们需要删除保存的记录。否则，新游戏将无法开始。本地存储提供了一个`removeItem`函数来删除特定的记录。以下是使用该函数删除具有给定键的记录的方法：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to remove all stored records, then you can use the `localStorage.clear()`
    function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除所有存储的记录，则可以使用`localStorage.clear()`函数。
- en: Cloning an array in JavaScript
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中克隆数组
- en: 'We cloned the shuffled deck in `savingObject`, so that we could use the order
    of the deck to recreate the cards when we resumed the game. However, we cannot
    copy an array by assigning the array to another variable. The following code fails
    to copy array `a` to array `b`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`savingObject`中克隆了洗好的牌组，这样我们就可以在游戏恢复时使用牌组的顺序来重新创建卡片。然而，我们不能通过将数组赋值给另一个变量来复制数组。以下代码未能将数组`a`复制到数组`b`中：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `slice` function provides an easy way to clone an array with only primitive
    types of elements, for example, an array of integers or an array of strings. We
    can clone an array with the `slice` function as long as it does not contain another
    array or object as an element. The following code successfully clones array `a`
    to `b`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`函数提供了一个简单的方法来克隆只包含原始类型元素的数组，例如整数数组或字符串数组。只要数组中不包含另一个数组或对象作为元素，我们就可以使用`slice`函数来克隆数组。以下代码成功地将数组`a`复制到`b`中：'
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `slice` function is normally used to create a new array by selecting a
    range of elements from an existing array. When using the `slice` function without
    any arguments, it clones the entire array. The Mozilla Developer Network provides
    details on the `slice` function at: [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`函数通常用于通过从现有数组中选择一系列元素来创建一个新数组。当使用不带任何参数的`slice`函数时，它会克隆整个数组。Mozilla开发者网络提供了关于`slice`函数的详细信息，请参阅：[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)。'
- en: Resuming the game progress
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复游戏进度
- en: We have saved the game progress, but we have not yet written the logic to resume
    the game. So, let's move on to the resuming part.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保存了游戏进度，但尚未编写恢复游戏的逻辑。所以，让我们继续到恢复部分。
- en: Time for action – resuming a game from the local storage
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 从本地存储恢复游戏
- en: 'Carry out the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `matchgame.js` JavaScript file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`matchgame.js`JavaScript文件。
- en: 'In the jQuery document `ready` function, we used the saved order of the deck
    in the previous game instead of shuffling a new deck. Add the following highlighted
    code in the jQuery `ready` function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jQuery文档的`ready`函数中，我们使用了上一局游戏中保存的牌组顺序，而不是重新洗牌。在jQuery的`ready`函数中添加以下高亮代码：
- en: '[PRE33]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Still in the jQuery document `ready` function, we append the following highlighted
    code to the end of the function. It removes any card that was marked as removed
    in the saved data. We also restore the saved elapsed time from the saved value:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在jQuery文档的`ready`函数中，我们将以下高亮代码添加到函数的末尾。它移除了在保存的数据中被标记为已删除的任何卡片。我们还从保存的值中恢复了保存的已过时间：
- en: '[PRE34]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we create the following function to retrieve `savingObject` from the
    local storage:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建以下函数来从本地存储中检索`savingObject`：
- en: '[PRE35]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save all the files and open the game in a web browser. Try playing the game
    by removing several matching cards. Then, close the browser window and open the
    game again. The game should resume from the state where we closed the window,
    as shown in the following screenshot:![Time for action – resuming a game from
    the local storage](img/B04290_07_11.jpg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在网络浏览器中打开游戏。尝试通过移除几对匹配的卡片来玩游戏。然后，关闭浏览器窗口并再次打开游戏。游戏应该从我们关闭窗口时的状态恢复，如下面的截图所示：![开始行动时间
    – 从本地存储恢复游戏](img/B04290_07_11.jpg)
- en: '*What just happened?*'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just finished the loading part of the game by parsing the saved JSON string
    of the entire game status.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过解析整个游戏状态的保存JSON字符串完成了游戏的加载部分。
- en: 'Then, we restored the elapsed time and the order of the deck from the loaded
    object, `savingObject`. Restoring these two properties is simply a case of variable
    assigning. The tricky part is recreating removing the card. In the game saving
    section, we assigned an index to each card''s DOM using a **custom** **data**
    **attribute** `data-card-index`. We stored the index of each removed card when
    saving the game, so we can know which cards are removed when loading the game.
    Then, we can remove these cards when the game sets up. The following code removes
    the cards in the jQuery game `ready` function:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从加载的对象`savingObject`中恢复了已过时间和牌组的顺序。恢复这两个属性只是变量赋值的问题。难点在于重新创建移除卡片的过程。在游戏保存部分，我们使用一个**自定义**的**数据**属性`data-card-index`为每个卡片的DOM分配了一个索引。我们在保存游戏时存储了每个被移除卡片的索引，这样我们就可以知道在加载游戏时哪些卡片被移除了。然后，当游戏设置时，我们可以移除这些卡片。以下代码在jQuery游戏的`ready`函数中移除卡片：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Tracking the storage changes with the storage event**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用存储事件跟踪存储变化**'
- en: 'Sometimes, we may want to listen to the changes in `localStorage`. We can do
    that by listening to the `storage` event. It is fired when anything is changed
    in `localStorage`. The following link from **Dive into HTML5** provides a detailed
    discussion on how we can use the event: [http://diveintohtml5.org/storage.html#storage-event](http://diveintohtml5.org/storage.html#storage-event).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要监听`localStorage`中的变化。我们可以通过监听`storage`事件来实现。当`localStorage`中的任何内容发生变化时，都会触发这个事件。以下来自**深入HTML5**的链接提供了关于如何使用该事件的详细讨论：[http://diveintohtml5.org/storage.html#storage-event](http://diveintohtml5.org/storage.html#storage-event)。
- en: Pop quiz – using local storage
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验 – 使用本地存储
- en: 'Q1\. Consider whether each of the following statements is true or not:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 考虑以下每个陈述是否正确：
- en: We can save and restore object data directly in the local storage.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接在本地存储中保存和恢复对象数据。
- en: We can save the data of an object in the local storage by encoding it into a
    string.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将对象编码成字符串来在本地存储中保存对象的数据。
- en: We can use `localStorage["hello"] = "world"` to save the value "world" with
    key "hello" in the local storage.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`localStorage["hello"] = "world"`来在本地存储中保存键为"hello"的值为"world"。
- en: Caching the game for offline access
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存游戏以实现离线访问
- en: We can enable an offline cache by using the AppCache Manifest document. After
    the page first loads from the Internet, its related files are cached in the device
    and the user can load the page and play the game even if the device is in offline
    mode, such as airplane mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用AppCache清单文档来启用离线缓存。当页面首次从互联网加载后，其相关文件将被缓存到设备中，用户即使在离线模式（如飞行模式）下也可以加载页面并玩游戏。
- en: Time for action – adding the AppCache Manifest
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动时间 – 添加AppCache清单
- en: 'Perform the following set of steps to take the game offline:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将游戏离线化：
- en: 'In the `index.html` file, we add a `manifest` attribute:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们添加一个`manifest`属性：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we create a file named `game.appcache` with the following content:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`game.appcache`的文件，内容如下：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In order to test the caching, we need to host the game online. Upload the project
    folder to a web server, then open the game and inspect the console, we should
    see messages about the browser downloading or using the AppCache resources, as
    shown in the following screenshot:![Time for action – adding the AppCache Manifest](img/B04290_07_12.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试缓存，我们需要将游戏在线托管。将项目文件夹上传到网络服务器，然后打开游戏并检查控制台，我们应该会看到浏览器下载或使用 AppCache 资源的消息，如下面的截图所示：![添加
    AppCache 清单的操作时间](img/B04290_07_12.jpg)
- en: '*What just happened?*'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just added an AppCache Manifest file to our `index.html` file. Now once the
    game is loaded, it works in offline and airplane mode.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将一个 AppCache 清单文件添加到了我们的 `index.html` 文件中。现在一旦游戏加载完成，它就可以在离线和飞行模式下工作。
- en: The AppCache file
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppCache 文件
- en: 'The AppCache file is a plain text file. It starts with `CACHE MANIFEST`. There
    are two sections: cache and network. We specify them by using a line with `CACHE:`
    and `NETWORK:` in the AppCache file. An optional fallback section can be provided
    for fallback assets for files that are not cached.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AppCache 文件是一个纯文本文件。它以 `CACHE MANIFEST` 开头。有两个部分：缓存和网络。我们通过在 AppCache 文件中使用带有
    `CACHE:` 和 `NETWORK:` 的行来指定它们。可以为未缓存的文件提供可选的回退部分，用于回退资源。
- en: In the cache section, we specify the file we want to cache, line by line. We
    need to specify each file explicitly. In the network section, we specify the file
    that should access the network if it is not listed in the cache section. If we
    don't specify files, the browser won't fetch non-cached files even if there is
    an Internet connection. Most of the time, a wildcard (`*`) fits and works perfectly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存部分，我们逐行指定我们想要缓存的文件。我们需要明确指定每个文件。在网络部分，我们指定如果文件未在缓存部分列出，则应该访问网络的文件。如果我们没有指定文件，即使有互联网连接，浏览器也不会获取非缓存的文件。大多数情况下，通配符（`*`）适用并且工作得很好。
- en: Any line that begins with `#` is a comment. We usually use one line of comment
    to specify the version of the cache file. The reason is that once the browser
    cached the assets, it won't update the cached files until the manifest file itself
    is changed. So the comment line can force the browser to update the cached resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以 `#` 开头的行都是注释。我们通常使用一行注释来指定缓存文件的版本。原因是浏览器一旦缓存了资源，它就不会更新缓存的文件，直到清单文件本身发生变化。因此，注释行可以强制浏览器更新缓存的资源。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'HTML5Rocks has the following article that provides more details on using the
    AppCache file, including handling the cached events with JavaScript. Check it
    out at: [http://www.html5rocks.com/en/tutorials/appcache/beginner/](http://www.html5rocks.com/en/tutorials/appcache/beginner/).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5Rocks 有以下文章提供了更多关于使用 AppCache 文件的信息，包括使用 JavaScript 处理缓存的事件。查看它：[http://www.html5rocks.com/en/tutorials/appcache/beginner/](http://www.html5rocks.com/en/tutorials/appcache/beginner/)。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about using the local storage to save the
    game data in a web browser. Specifically, we saved and retrieved basic data in
    the key-value pair local storage. We encoded an object into the JSON formatted
    string and parsed the string back to a JavaScript object. We saved the entire
    game progress, so the game can resume even if left mid-way. We also take the game
    offline by using AppCache. Visually, we created a nice 3D ribbon as a new record
    badge in pure CSS3 styling.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在网页浏览器中使用本地存储来保存游戏数据。具体来说，我们在键值对本地存储中保存和检索了基本数据。我们将对象编码为 JSON 格式的字符串，并将字符串解析回
    JavaScript 对象。我们保存了整个游戏进度，这样即使游戏进行到中途也能继续。我们还通过使用 AppCache 将游戏离线化。从视觉上看，我们使用纯
    CSS3 样式创建了一个漂亮的 3D 条带作为新的成就徽章。
- en: Now that you have learned about improving our previous games by using the local
    storage, you are ready to move on to the next chapter where you'll learn about
    an advanced feature named **WebSockets** that we can use to connect players together
    in a real-time interaction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了如何通过使用本地存储来改进我们之前的游戏，你准备好进入下一章了，在那里你将学习一个名为 **WebSockets** 的高级功能，我们可以使用它来实现玩家之间的实时交互。
