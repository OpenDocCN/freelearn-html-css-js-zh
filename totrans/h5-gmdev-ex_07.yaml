- en: Chapter 7. Saving the Game's Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Local storage is a new specification from HTML5\. It allows a website to store
    information in the browser locally and access the stored data later. This is a
    useful feature in game development because we can use it as a memory slot to save
    any game data locally in a web browser.*'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the feature of storing game data in the CSS3 card matching
    game we built in [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game
    in CSS3"), *Building a Card-matching Game in CSS3*. Besides storing and loading
    the game data, we will also notify the player when they break a record with a
    nice 3D ribbon using pure CSS3 styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data by using HTML5 local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the object in the local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying players when they break a new record with a nice ribbon effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the entire game's progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may try the final game at: [http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the final result we will create in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the Game''s Progress](img/B04290_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data using HTML5 local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the CSS3 card matching game we made in [Chapter 3](ch03.html "Chapter 3. Building
    a Card-matching Game in CSS3"), *Building a Card-matching Game in CSS3*? Imagine
    now that we have published our game and players are trying their best to perform
    well in the game.
  prefs: []
  type: TYPE_NORMAL
- en: We want to show the players whether they played better or worse than the last
    time. We will save the latest score and inform players whether they are better
    or not this time, by comparing the scores.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons we might want to do this are because it gives the player a sense
    of pride when they perform better, and they may become addicted to our game to
    try to get higher scores, which is good for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a game over dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before actually saving anything in the local storage, we need a game over screen.
    We made a few games in previous chapters. We made a Ping Pong game, the card matching
    game, the Untangle puzzle game, and a music game. In these games, we did not create
    any game over screen. Imagine now that we are playing the CSS3 card matching game
    that we built in [Chapter 3](ch03.html "Chapter 3. Building a Card-matching Game
    in CSS3"), *Building a Card-matching Game in CSS3*. We successfully match and
    remove all cards. Once we finish a game a screen pops up and shows the time we
    took to complete the game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a game over dialog with the elapsed played time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue with the code from the card matching game we made in [Chapter
    3](ch03.html "Chapter 3. Building a Card-matching Game in CSS3"), *Building a
    Card-matching Game in CSS3*. Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CSS3 matching game folder as our working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download a background image from the following URL (we will use it as the background
    of the popup): [http://mak.la/book-assets](http://mak.la/book-assets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the image in the `images` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `index.html` in any text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need a font for the game over popup. Add the following font embedding
    CSS into the `head` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before the `game` section, we add a `div` named `timer` to show the elapsed
    playing time. In addition, we add a new `popup` section containing the HTML markup
    of the pop-up dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now move on to the style sheet. As it is just for styling and not related
    to our logic yet, we can simply copy the `matchgame.css` file from `01-gameover-dialog`
    in the code example bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is time to edit the game's logic part. Open the `matchgame.js` file in an
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the jQuery `ready` function, we need a variable to store the elapsed time
    of the game. Then, we create a timer to count the game every second as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add a `countTimer` function that will be executed every second. It
    displays the elapsed seconds in the minutes and seconds format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `removeTookCards` function that we wrote earlier, add the following
    highlighted code that executes the game over logic after removing all cards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, we create the following `gameover` function. It stops the counting
    timer, displays the elapsed time in the game over popup, and finally shows the
    popup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, save all files and open the game in a browser. Try finishing the card matching
    game and the game over screen will popup, as shown in the following screenshot:![Time
    for action – creating a game over dialog with the elapsed played time](img/B04290_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the CSS3 transition animation to show the game over popup. We benchmark
    the score by using the time the player utilized to finish the game.
  prefs: []
  type: TYPE_NORMAL
- en: Counting time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the time interval to calculate elapsed time. We provide an interval,
    for instance, 1 second, and the browser executes our logic at the provided interval.
    Inside the logic, we count the elapsed seconds. We need to keep in mind that `setInterval`
    does not guarantee the execution of the logic precisely at the given time interval.
    It's an approximate value. If you need a more precise elapsed time, you may get
    the time stamp and subtract it from the start time.
  prefs: []
  type: TYPE_NORMAL
- en: Saving scores in the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine now that we are going to display how well the player played last time.
    The game over screen includes the elapsed time as the last score alongside the
    current game score. Players can then see how well they do this time compared to
    last time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving the game score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to add a few markups in the `popup` section to display the last
    score. Add the following HTML in `popup-box` in `index.html`. The changed code
    is highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we open the `matchgame.js` to modify some game logic in the `gameover`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted code in the `gameover` function. It loads the
    saved score from the local storage and displays it as the score last time. Then,
    we save the current score in the local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is now time to save all the files and test the game in the browser. When
    you finish the game for the first time, the last score should be `00:00`. Then,
    try to finish the game for the second time. The game over popup will show the
    elapsed time when you played the last time. The following screenshot shows the
    game over screen with the current and last score:![Time for action – saving the
    game score](img/B04290_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just built a basic scoring system that compares a player's score with their
    last score.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and loading data with local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can store data by using the `setItem` function from the `localStorage` object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the usage of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Definition | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | The key is the name of the record that we used to identify an entry
    | The key is a string and each record has a unique key. Writing a new value to
    an existing key overwrites the old value. |'
  prefs: []
  type: TYPE_TB
- en: '| `value` | The value is any data that will be stored | This can be any data,
    but the final storage is in a string. We will discuss this shortly. |'
  prefs: []
  type: TYPE_TB
- en: 'In our example, we save the game elapsed time as the score with the following
    code by using the key `last-elapsed-item`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Complementary to `setItem`, we get the stored data by using the `getItem` function
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The function returns the stored value of the given key. It returns `null` when
    trying to get a non-existent key. This can be used to check whether we have stored
    any data for a specific key.
  prefs: []
  type: TYPE_NORMAL
- en: The local storage saves the string value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The local storage stores data in a key-value pair. The key and value are both
    strings. If we save numbers, Boolean, or any type other than a string, then the
    browser will convert the value into a string while saving. For objects and arrays,
    we will do our conversion using JSON in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, problems occur when we load a saved value from the local storage. The
    loaded value is a string regardless of the type we are saving. We need to explicitly
    parse the value into the correct type before using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we save a floating number into the local storage, we need to
    use the `parseFloat` function when loading it. The following code snippet shows
    how we can use `parseFloat` to retrieve a stored floating number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the manipulation may be incorrect if we forget
    to convert `gameScore` from a string to a float. For instance, if we increase
    `gameScore` by 1 without the `parseFloat` function, the result will be **13.2341**
    instead of **14.234**. So, be sure to convert the value from the local storage
    to its correct type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Size limitations on local storage**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a size limitation on the data stored through `localStorage` for each
    domain. This size limitation may be slightly different in different browsers.
    Normally, the size limitation is 5 MB. If the limit is exceeded, then the browser
    throws a `QUOTA_EXCEEDED_ERR` exception when setting a key-value into `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Treating the local storage object as an associative array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides using the `setItem` and `getItem` functions, we can treat the `localStorage`
    object as an associated array and access the stored entries by using square brackets.
    For instance, consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace the preceding block of code with the following one and access
    `localStorage` as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Saving objects in the local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, imagine that we are saving not only the score, but also the date and time
    when the ranking is created. We can either save two separate keys for the score
    and date time of playing, or pack the two values into one object and store it
    in the local storage.
  prefs: []
  type: TYPE_NORMAL
- en: We will pack all the game data into one object and store it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving the time alongside the score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the `index.html` file from our CSS3 card matching game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the HTML markup with the last score, with the following HTML (it shows
    both scores and the date time in the game over popup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HTML markup is now ready. We will move on to the game logic. Open the `html5games.matchgame.js`
    file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will modify the `gameover` function. Add the following highlighted code
    to the `gameover` function. It gets the current date and time when the game ends
    and packs a formatted date and time with elapsed time together in the local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will save the files and open the game in a web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we finish the game for the first time, we will get a screen similar to
    the following screenshot, which will show our game score and state that there
    are no previous records:![Time for action – saving the time alongside the score](img/B04290_07_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now try reloading the page and play the game again. When we finish the game
    for the second time, the game over dialog will show our saved record. The following
    screenshot shows how it should look:![Time for action – saving the time alongside
    the score](img/B04290_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just used a `Date` object in JavaScript to get the current date and time
    when the game is over. In addition, we packed the game over date and time and
    the game elapsed time in one object and saved it in the local storage. The saved
    object is encoded in a JSON string. It will also load the last saved date and
    time and the game elapsed time from the storage and parse it back to the JavaScript
    object from a string.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the current date and time in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Date` object in JavaScript is used to work with the date and time. When
    we create an instance from the `Date` object, by default it stores the current
    date and time. We can get the string representation by using the `toLocaleString`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the string representation, we can manipulate each component
    in the date object. The following table lists some useful functions in the `Date`
    object to get the date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getFullYear` | Returns the year in four digits |'
  prefs: []
  type: TYPE_TB
- en: '| `getMonth` | Returns the month in an integer, starting from 0 (Jan is 0 and
    Dec is 11) |'
  prefs: []
  type: TYPE_TB
- en: '| `getDate` | Returns the day of the month, starting from 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `getDay` | Returns the day of the week, starting from 0 (Sunday is 0 and
    Saturday is 6) |'
  prefs: []
  type: TYPE_TB
- en: '| `getHours` | Returns the hour, starting from 0 to 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `getMinutes` | Returns the minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `getSeconds` | Returns the seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `getMilliseconds` | Returns the milliseconds in 3 digits |'
  prefs: []
  type: TYPE_TB
- en: '| `getTime` | Returns the number of milliseconds since 1 January, 1970, 00:00
    |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Mozilla Developer Network provides a detailed reference on using the `Date`
    object at: [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the native JSON to encode an object into a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used JSON to represent the game level data in [Chapter 4](ch04.html "Chapter 4. Building
    the Untangle Game with Canvas and the Drawing API"), *Building the Untangle Game
    with Canvas and the Drawing API*.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is an object notation format that is friendly for machines to parse and
    generate. In this example, we packed the final elapsed time and the date and time
    into an object. Then, we encoded the object into JSON. Modern web browsers come
    with native JSON support. We can easily encode any JavaScript object into JSON
    by using the `stringify` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we only use the first parameter for the `stringify` function. This
    is the object that we are going to encode as a string. The following code snippet
    demonstrates the result of an encoded JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stringify` method can parse objects with data structure into a string well.
    However, it cannot convert anything from an object into a string. For instance,
    it will return an error if we try to pass a DOM element into it. It will return
    the string representing the date if we pass a `Date` object. Alternatively, it
    will drop all method definitions of the parsing object.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a stored object from a JSON string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete form of **JSON** is **JavaScript** **Object** **Notation**. From
    the name, we know that it uses the syntax from JavaScript to represent an object.
    Therefore, it is very easy to parse a JSON formatted string back to a JavaScript
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can use the parse function in the JSON
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can open the console in **Web Inspector** to test the JSON JavaScript functions.
    The following screenshot shows the result of running the code snippets we just
    discussed when encoding an object and parsing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading a stored object from a JSON string](img/B04290_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting the local storage in a console window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have saved something in the local storage, we may want to know what
    exactly is saved, before we write the loading part. We can inspect what we have
    saved by using the storage panel in the **Web Inspector**. It lists all the saved
    key-value pairs under the same domain. The following screenshot shows that we
    have the **last-score** key saved with value **{"savedTime":"23/2/2011 19:27:02","score":23}**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value is the result of the `JSON.stringify` function we used to encode
    the object into JSON. You may also try saving an object directly in the local
    storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the local storage in a console window](img/B04290_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides `localStorage`, there are other storage approaches that were not discussed.
    **IndexedDB** is another option. Check the following URL to see more details on
    this: [https://developer.mozilla.org/en/IndexedDB](https://developer.mozilla.org/en/IndexedDB).'
  prefs: []
  type: TYPE_NORMAL
- en: Notifying players when they break a new record with a nice ribbon effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we want to encourage players by informing them that they broke
    a new record compared to the last score. We want to show a ribbon with `New` `Record`
    text on it. Thanks to the new CSS3 properties, we can create a ribbon effect completely
    in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a ribbon in CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new record ribbon and display it when a player breaks their
    last score. So, carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open `index.html` where we will add the ribbon HTML markup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted HTML right after `popup-box` and before `popup-box-content`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to focus on the style sheet. The entire ribbon effect is done
    in CSS. Open the `matchgame.css` file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `popup-box` styling, we need to add a relative position to it. We do
    this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add the following styles that create the ribbon effect in
    the CSS file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we need to modify the game over logic a little bit. Open the `html5games.matchgame.js`
    file and locate the `gameover` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `gameover` function, which compares the current
    score with the last score to determine the new record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will test the game in a web browser. Try finishing a game slowly and then
    finish another game fast. When you break the last score, the game over popup shows
    a nice **NEW** **RECORD** ribbon, as shown in the following screenshot:![Time
    for action – creating a ribbon in CSS3](img/B04290_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just created a ribbon effect in a pure CSS3 style with some help from JavaScript
    to show and hide it. The ribbon is composed of a little triangle overlaid by a
    rectangle, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, how can we create a triangle in CSS? We can create a triangle by setting
    both the width and height to `0` and drawing only one border. The size of the
    triangle is then decided by the border width. The following is the code for the
    triangle CSS we used in our new record ribbon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following PVM Garage website provides a detailed explanation on pure CSS3
    ribbon usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/](http://www.pvmgarage.com/2010/01/how-to-create-depth-and-nice-3d-ribbons-only-using-css3/)'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – saving and comparing only to the fastest time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time the game finishes, it compares the last score with the current score.
    Then, it saves the current score. How about changing the code to save the highest
    score and show the new record ribbon when breaking the highest score?
  prefs: []
  type: TYPE_NORMAL
- en: Saving the entire game progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have enhanced our CSS3 card matching game by adding a game over screen and
    storing the last game record. Imagine now that a player is mid-game and accidentally
    closes the web browser. Once the player opens the game again, the game starts
    from the beginning and the game that the player was playing is lost. With the
    local storage, we can encode the entire game's data into JSON and store it. In
    this way, players can resume their game later.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to pack the game data into one object and save it into the local
    storage every second.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – saving all essential game data in the local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue work with our CSS3 card matching game:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `matchgame.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code at the top of the JavaScript file after declaring the
    `matchingGame` variable. This code creates an object named `savingObject` to save
    the array of the deck, the removed cards and the current elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the jQuery `ready` function, add the following highlighted code. It clones
    the order of the deck to the `savingObject`. In addition, it assigns an index
    to each card in the DOM data attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a `countTimer` function that executes every second. We add the following
    highlighted code in the `countTimer` function. It saves the current elapsed time
    in `savingObject` and also saves the object in the local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The game removes cards when the player finds a matching pair. We replace the
    original `$(".card-removed").remove();` code with the following highlighted code
    in the `removeTookCards` function. It remembers which cards are removed in `savingObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to remove the saved game data in the local storage when the game is
    over. Add the following code at the end of the `gameover` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, we use a function to save `savingObject` in the local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have modified the code a lot and it is now time to test the game in a web
    browser. After the game runs, try clearing several matching cards. Then, open
    the storage panel in the **Web Inspector**. The local storage should contain an
    entry similar to the one shown in the following screenshot:![Time for action –
    saving all essential game data in the local storage](img/B04290_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a record with a key `savingObject` and a value with a long string in a
    JSON format. The JSON string contains the shuffled deck, removed cards, and the
    current elapsed time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just entered all essential game data into an object named `savingObject`.
    This `savingObject` contains all the information that we need to recreate the
    game later. It includes the order of cards, removed cards, and the current elapsed
    time. We will implement the game resuming logic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we saved `savingObject` in `localStorage` each second. The object is
    encoded in JSON using the `stringify` function we used earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a record from the local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to remove the saved record when the game is over. Otherwise, the new
    game will not start. The local storage provides a `removeItem` function to remove
    a specific record. Here is how we use the function to remove the record with the
    given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to remove all stored records, then you can use the `localStorage.clear()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning an array in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We cloned the shuffled deck in `savingObject`, so that we could use the order
    of the deck to recreate the cards when we resumed the game. However, we cannot
    copy an array by assigning the array to another variable. The following code fails
    to copy array `a` to array `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slice` function provides an easy way to clone an array with only primitive
    types of elements, for example, an array of integers or an array of strings. We
    can clone an array with the `slice` function as long as it does not contain another
    array or object as an element. The following code successfully clones array `a`
    to `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slice` function is normally used to create a new array by selecting a
    range of elements from an existing array. When using the `slice` function without
    any arguments, it clones the entire array. The Mozilla Developer Network provides
    details on the `slice` function at: [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice).'
  prefs: []
  type: TYPE_NORMAL
- en: Resuming the game progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have saved the game progress, but we have not yet written the logic to resume
    the game. So, let's move on to the resuming part.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – resuming a game from the local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `matchgame.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the jQuery document `ready` function, we used the saved order of the deck
    in the previous game instead of shuffling a new deck. Add the following highlighted
    code in the jQuery `ready` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the jQuery document `ready` function, we append the following highlighted
    code to the end of the function. It removes any card that was marked as removed
    in the saved data. We also restore the saved elapsed time from the saved value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create the following function to retrieve `savingObject` from the
    local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the files and open the game in a web browser. Try playing the game
    by removing several matching cards. Then, close the browser window and open the
    game again. The game should resume from the state where we closed the window,
    as shown in the following screenshot:![Time for action – resuming a game from
    the local storage](img/B04290_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just finished the loading part of the game by parsing the saved JSON string
    of the entire game status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we restored the elapsed time and the order of the deck from the loaded
    object, `savingObject`. Restoring these two properties is simply a case of variable
    assigning. The tricky part is recreating removing the card. In the game saving
    section, we assigned an index to each card''s DOM using a **custom** **data**
    **attribute** `data-card-index`. We stored the index of each removed card when
    saving the game, so we can know which cards are removed when loading the game.
    Then, we can remove these cards when the game sets up. The following code removes
    the cards in the jQuery game `ready` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tracking the storage changes with the storage event**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we may want to listen to the changes in `localStorage`. We can do
    that by listening to the `storage` event. It is fired when anything is changed
    in `localStorage`. The following link from **Dive into HTML5** provides a detailed
    discussion on how we can use the event: [http://diveintohtml5.org/storage.html#storage-event](http://diveintohtml5.org/storage.html#storage-event).'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – using local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Q1\. Consider whether each of the following statements is true or not:'
  prefs: []
  type: TYPE_NORMAL
- en: We can save and restore object data directly in the local storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can save the data of an object in the local storage by encoding it into a
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use `localStorage["hello"] = "world"` to save the value "world" with
    key "hello" in the local storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Caching the game for offline access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can enable an offline cache by using the AppCache Manifest document. After
    the page first loads from the Internet, its related files are cached in the device
    and the user can load the page and play the game even if the device is in offline
    mode, such as airplane mode.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the AppCache Manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following set of steps to take the game offline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `index.html` file, we add a `manifest` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we create a file named `game.appcache` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to test the caching, we need to host the game online. Upload the project
    folder to a web server, then open the game and inspect the console, we should
    see messages about the browser downloading or using the AppCache resources, as
    shown in the following screenshot:![Time for action – adding the AppCache Manifest](img/B04290_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just added an AppCache Manifest file to our `index.html` file. Now once the
    game is loaded, it works in offline and airplane mode.
  prefs: []
  type: TYPE_NORMAL
- en: The AppCache file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The AppCache file is a plain text file. It starts with `CACHE MANIFEST`. There
    are two sections: cache and network. We specify them by using a line with `CACHE:`
    and `NETWORK:` in the AppCache file. An optional fallback section can be provided
    for fallback assets for files that are not cached.'
  prefs: []
  type: TYPE_NORMAL
- en: In the cache section, we specify the file we want to cache, line by line. We
    need to specify each file explicitly. In the network section, we specify the file
    that should access the network if it is not listed in the cache section. If we
    don't specify files, the browser won't fetch non-cached files even if there is
    an Internet connection. Most of the time, a wildcard (`*`) fits and works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Any line that begins with `#` is a comment. We usually use one line of comment
    to specify the version of the cache file. The reason is that once the browser
    cached the assets, it won't update the cached files until the manifest file itself
    is changed. So the comment line can force the browser to update the cached resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTML5Rocks has the following article that provides more details on using the
    AppCache file, including handling the cached events with JavaScript. Check it
    out at: [http://www.html5rocks.com/en/tutorials/appcache/beginner/](http://www.html5rocks.com/en/tutorials/appcache/beginner/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about using the local storage to save the
    game data in a web browser. Specifically, we saved and retrieved basic data in
    the key-value pair local storage. We encoded an object into the JSON formatted
    string and parsed the string back to a JavaScript object. We saved the entire
    game progress, so the game can resume even if left mid-way. We also take the game
    offline by using AppCache. Visually, we created a nice 3D ribbon as a new record
    badge in pure CSS3 styling.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about improving our previous games by using the local
    storage, you are ready to move on to the next chapter where you'll learn about
    an advanced feature named **WebSockets** that we can use to connect players together
    in a real-time interaction.
  prefs: []
  type: TYPE_NORMAL
