- en: Chapter 6. Catalog Application and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we are creating a simple catalog application that allows you
    to enter in items for sale and assign them to a category. From an interface and
    functionality aspect, this will be similar to the previous applications we have
    created. The difference here is that we are going to explore creating our own
    API to create, read, update, and delete data from your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the basic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PHP to create an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the API and the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **API** is an **Application Programming Interface**, which is simply a way
    to make data stored in one place available to a remote application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our first problem with local storage? The data is stored on the device,
    which limits its usefulness in a number of ways. If we store the data separately
    from the device (on a server), we can allow multiple devices to access the data,
    we can limit and secure the data through authentication, and we can back up the
    entire data set for all our users.
  prefs: []
  type: TYPE_NORMAL
- en: When we store data separately from the application, we need a way to get to
    it and make changes. This is where the API comes in. In the last chapter, we used
    the Sencha.io API to store and retrieve data. In this chapter, we will explore
    how to create your own API.
  prefs: []
  type: TYPE_NORMAL
- en: The API is a set of code files written in a server-side language such as PHP,
    Ruby, ASP, or Perl. The JavaScript code sends data to these files as part of an
    HTTP request (`GET`, `POST`, `PUT`, or `DELETE`). In the case of Sencha Touch,
    this data is typically sent formatted either as JSON or XML. The server-side language
    will then parse the data and send it to the database as SQL statement. The database
    returns a result, which gets translated by the server-side language back into
    JSON and returned to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire process would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is an API?](img/8901OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s a lot of acronyms for a single paragraph, so let''s break this down
    into smaller pieces. Let''s assume that you want to add some new user data: a
    name, an email address, and a phone number. In its most basic form, we can use
    a browser URL to send this information as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212](http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would allow our server-side language (we will use PHP for this example)
    to grab the data we sent and process it correctly. This might look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note this is only an example; you would almost certainly want to filter
    and sanity check any incoming data. Since we are not going to cover all of PHP
    here, we will only talk about the server-side code in very general terms. It is
    not intended for actual use, just as a general idea of how things work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the PHP has our variables it can convert them into something our server-side
    database can understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This would pass the data from PHP to a database (like MySQL). The database
    then returns a result, which we can then loop through to create a new array that
    matches the format we need. We can then format the results as JSON and echo it
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As previously noted, this is a very raw general example and APIs can get very
    complex, very quickly. Fortunately for us, Sencha Touch handles some of this work
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using a remote API in Sencha Touch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using Sencha Touch, the JavaScript side of an API becomes a lot easier
    to manage. We can accomplish most of what we need using the store and a model.
    Following our previous example, we would create a model that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets up our simple model with a unique `id`, `name`, `email`, and `phone`
    fields. However, we can also add a `proxy` setting and `api` definition to this
    (right after we finish declaring the fields):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using a `scripttag` proxy. Later on in the chapter we
    are going to use a different proxy, called a `rest` proxy for the actual application.
    You should get a feel for the various types of proxies provided by Sencha Touch,
    and use the one that best suits your application and needs.
  prefs: []
  type: TYPE_NORMAL
- en: The `scripttag` proxy allows us to communicate with another domain (if the PHP
    and Sencha Touch code are running on the same domain, an `ajax` proxy should be
    used instead).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 2](ch02.html "Chapter 2. A Feed Reader"), *A Feed
    Reader*, this is due to the same origin policy, which prevents cross-domain attacks
    in JavaScript. If you would like to learn more about this origin policy, this
    Wikipedia article is a good place to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
  prefs: []
  type: TYPE_NORMAL
- en: The `url` property tells the model where to send information for creating, reading,
    updating, and destroying users (often referred to as **CRUD** functions).
  prefs: []
  type: TYPE_NORMAL
- en: The `reader` property tells the model where to look for the data when it gets
    back a JSON encoded list of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `api` section tells the model which URLs to use for each of our
    CRUD functions. This API setup allows us to do things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create a new user with all of our information and then call `save`. By calling
    `save`, the information is submitted to the `create` URL we set up previously
    in our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we didn''t send an ID. When we create a new user, the database
    will actually set the unique ID. A properly written API should return this value
    along with the rest of the user information if the transaction is successful.
    The JSON that comes back to us should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can then use this information for any post processing we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also save changes to an existing user, or delete the user by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also use the same proxy when we set up a user store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will let us create, read, update, and delete multiple users at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `api` section will be called when we load or sync the store, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `load()` on the store will contact `users.php` which should return a
    list of users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new user records to the store and calling `sync()` will contact `users.php`
    and save the new users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating existing user records in the store and calling `sync()` will contact
    `users.php`, and update the records for each user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing users from the store and calling `sync()` will contact `users.php`,
    and destroy the specified user records in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining a `proxy` setting on both the model and the store isn't strictly necessary.
    If your model has a `proxy` setting defined and your store does not, then the
    store will automatically use the model's `proxy`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using an API you didn't write, you would need to make sure that you
    are sending the data and requests in the correct format. Check the documentation
    for the API you are using to see if there are any additional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, we have been a bit vague on what is happening at the
    API end of things. This is because each API is a little different in terms of
    the data they expect, and the data they return.
  prefs: []
  type: TYPE_NORMAL
- en: Most publicly accessible APIs are fairly well documented, but it is also helpful
    to have a general idea of what goes into making an API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At their most basic, APIs perform three core functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive data from a remote source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect to and modify a database (or other data source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transmit data to the remote application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create your own API, you will need to account for each of these functions.
    You can create your API in any server-side language you want, as long as it can
    handle these three basic things. Let's take a high-level view at each of these
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you receive data from an application, you need to figure out what the user
    is asking for and how they are expecting the answer to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the standard Sencha Touch API requests for models and stores,
    the `create`, `read`, `update`, and `destroy` functions are triggered, causing
    requests to be transmitted to the URLs you specify in the proxy configuration,
    along with any relevant data for the transaction. You can also send additional
    data using the `params` configuration like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Your API will need to be set up to receive and translate the data and any extra
    parameters, so that it can decide what actions to take and what data to return.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you will need to do is determine if the variables are being
    sent as part of a `GET` or `POST` request. The server-side language you choose
    should have methods for dealing with either of these two transmission types.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, PHP can collect this data using `$_GET["variableName"]`
    and `$_POST["variableName"]`. Your chosen language will have similar functions.
    This data will also be encoded as JSON, so you will need to decode it before you
    can get to the individual pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Most server-side languages have functions for dealing with this. For example,
    PHP uses `json_decode($myJSONData)` to transform the JSON data into a PHP array.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is collected, it should be checked to make sure that it is something
    we expected. For example, if our API receives an `action` value as `read` and
    an `id` value as `DELETE * FROM users`, we might not want to send this on to our
    database. Most languages also have ways to validate data types and sanitize any
    potentially hostile values.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a store can often combine multiple requests into an array of data.
    Your code will need to check and see if the data being passed is an array or a
    single item, and deal with each appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have your variables and you understand what the user needs to accomplish,
    you will likely need to make a connection to your database to get or modify the
    data. For example, if you get an `action` value of `read` and an `id` value of
    `45`, you will likely want to query the database for any users with an `id` value
    of `45`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing this action will require knowledge of how the server-side language
    you are using connects to a database, and how your database accepts queries for
    information. You will need to consult the reference guides for your language and
    database to determine how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data back to the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have communicated with the database and you are ready to send information
    back to the application, you will need to encode it correctly in order for Sencha
    Touch to process it.
  prefs: []
  type: TYPE_NORMAL
- en: Something to keep in mind is that Sencha Touch expects to receive data encoded
    as JSON. Most server-side languages have functions for dealing with this. For
    example, PHP uses `json_encode($myArrayOfData)` to bundle up the information into
    a JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the JSON-encoded data, you can output it directly to the browser
    using something like PHP's `print` or `echo` functions.
  prefs: []
  type: TYPE_NORMAL
- en: More information on APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have some idea of how APIs function you can gather some specific
    data for the server-side language you want to use. For more specific information,
    take a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/](http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/)'
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will not be going through the entire build process of the
    application. Instead, we will be focusing mainly on the models, stores, and the
    basic API. The application itself is composed of a tabbed layout with two tabs.
    Each of our two tabs is a panel with a Card Layout, one for Items and one for
    Categories. In turn, these two panels have their own subpanels for listing, showing
    details, and editing (a list, a panel, and a form panel respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the basic application](img/8901OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can take a look at the application code to see how these components are
    laid out. The Main Tab Panel and the two Card Layout panels for Items and Categories
    are part of the `Main.js` file. The List, Details, and Edit panels are all separate
    views inside the `app/views` folder. We will come back to the views a bit later,
    but what we are really interested in for this chapter is the stores and models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the item model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model is where most of the interesting stuff is going on. In the model
    we will be using two new options: a `rest` proxy and model relations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This starts out in the same manner as our previous models, but we have a new
    configuration option called `uses`. This option is set to our other model, `CatHerder.model.Category`,
    and tells us that we will have a relationship between our `Item` model and our
    `Category` model.
  prefs: []
  type: TYPE_NORMAL
- en: Below our `fields`, we have another new option called `hasOne`. This option
    tells us that each `Item` is related to a single `Category`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the option `hasMany`. This would allow you to set several categories
    on an item. For the sake of simplicity, we will be going with `hasOne` for this
    example. To see some examples of `hasMany`, take a look at [http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hasOne` option includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The model we are relating to: `CatHerder.model.Category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `name` property we will reference to get the related information: `category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `primaryKey` property indicates the field that is part of our `Item` model,
    which we will use to match the `id` property set for our related model, `categoryID`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This configuration will let us use the fields in the `Category` model the same
    way as we would use any of the `Item` model's other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a new type of proxy called a `rest` proxy. Unlike the `scripttag`
    proxy we covered earlier, the `rest` proxy uses different types of HTTP requests
    to denote if we are creating, reading, updating, or deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different types of requests include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new record will be sent as a `POST` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data will be sent as a `GET` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an existing record will be sent as a `PUT` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting records will be sent as a `DELETE` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these request types will be sent to `api/item` for processing. We have
    done a bit of trickery here with the URLs to make them look a bit cleaner to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: RewriteRule and .htaccess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally we would point our model at a particular file as we did in the earlier
    `scripttag` proxy example. In that case we would have done something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to view a particular item, the URL looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://myapp.com/api/item.php?item=143](http://myapp.com/api/item.php?item=143)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with a little bit of configuration, we can change that so the URL
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://myapp.com/api/item/143](http://myapp.com/api/item/143)'
  prefs: []
  type: TYPE_NORMAL
- en: This is shorter and much easier to read. It just requires a `RewriteRule` directive
    and a `.htaccess` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.htaccess` file is used by the Apache web server to determine a number
    of options and configurations for the server you are using. These options can
    be set by creating or editing the `.htaccess` file in the `api` directory of your
    application. In this case, we will create one with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first line turns on the ability to rewrite a URL. This means that while
    the user's address bar shows one thing, we direct the request to a different file.
    As the previous comments state, the next block sends any requests for `item` to
    `item.php` and the next block sends requests for `category` to `category.php`.
    The `[L]` directive says that if a rule matches the currently requested URL, no
    more rules should be checked, as this is the last rule to match against. This
    is a very simple change that gives a more professional and friendly feel to an
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you would like to learn more about `.htaccess` and Apache, a good place to
    start is at [http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/](http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/).
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and close it. Now all of our different HTTP requests will be sent
    to `api/item` and `api/category`.
  prefs: []
  type: TYPE_NORMAL
- en: Our API will need to be able to distinguish the different HTTP request types
    in order to understand what to do with the data. We will get to how that works
    in a second, but first let's take a quick look at the store.
  prefs: []
  type: TYPE_NORMAL
- en: The item store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The item store is extremely simple for this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we don't declare a proxy, the store will automatically use the one we
    set on our model. Other than that, we simply require our model to give the store
    a `storeId` value and set `autoLoad` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the category model and store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our category model and store are just variations of our item model and store.
    The model uses `hasMany` instead of `hasOne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use `hasMany` because we are going to have multiple items in a single category.
    Other than that, the basic structure of the model is the same as our item model,
    using the `rest` proxy and contacting our PHP API at `/api/category`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `categoryStore` is also a virtual duplicate of the `itemStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As before we just extend the basic store component, declare which model we are
    using (`'CatHerder.model.Category'`), and give the store an ID we can reference
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these two pieces in place, it's time for a bit of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the store and the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating an API for your application, it's usually a good idea to begin
    with just a flat text file. This will let you test the read abilities of the store
    and help you better understand how the data will need to be formatted for your
    API.
  prefs: []
  type: TYPE_NORMAL
- en: For this test file, we are going to create a couple of very basic PHP files.
    These files will simply create a static array of data, encode it as JSON, and
    echo it back to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use any server-side language you would like; Sencha Touch doesn't care
    as long as it can accept and return JSON. If you'd like to use PHP for your server
    code, but need a place to get started, try [http://phpmaster.com/](http://phpmaster.com/).
    PHP Master has lots of tutorials for all levels of PHP programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the `item.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This file creates an array called `$test`. The `$test` array has three arrays
    nested inside of it, one for each of our items. These arrays each contain various
    fields such as `itemID`, `name`, `description`, `price`, `photoURL`, and `categoryID`.
    They also contain the category data as part of an additional nested array. We
    include the category data as part of the item data so that our stores can access
    it via the `hasOne` relationship without requiring an extra AJAX call per item
    to the server to load the category data.
  prefs: []
  type: TYPE_NORMAL
- en: When you write the final PHP code for your application, it will query a database
    to get this information for both the items and the categories. The PHP will then
    need to format it in just this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP formats an array in a similar fashion to Sencha Touch, where Sencha Touch
    uses `key: value`, and PHP uses `''key'' => value`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the PHP file takes our array and encodes it as JSON. We then
    use `echo` to send the data back to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do the exact same thing for our categories array in `category.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this case, we only have two categories, but we also include the
    items associated with each category. This lets us do a lot more with the data
    later on (such as showing the number of items in a category).
  prefs: []
  type: TYPE_NORMAL
- en: While these may look like large and messy arrays, the final PHP code is going
    to do most of the work for you. This is simply for testing and making sure you
    have the initial data formatting correct.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the store and the model](img/8901OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you load the application you can now see the two lists with our flat data.
    Let's take a quick look at the XTemplates we are using for this data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the XTemplates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen how the data is being sent to the application, we need
    to understand how we can use it in our XTemplates. In our list view, the `itemTpl`
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both our category and our item include field values for name. Since the item
    is our main piece of data here, we can refer to the item's name value as `{name}`.
    Since category is related to item (and our PHP passes back as a nested array within
    each item), we refer to the category name value as `category.name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our category list XTemplate uses a similar format to provide us with the category
    name, but it uses a slightly different method to get the number of items in each
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the category is our main piece of data here, name refers to the category
    name. We can get to any of the item properties by doing `item.propertyName`, but
    what we really want to know is the number of items in the category.
  prefs: []
  type: TYPE_NORMAL
- en: Remember in our PHP flat file we included the individual items as part of a
    nested array in our category. This nested array was called `items`. We can print
    the name of the first item by using `items[0].name` or the second item by using
    `items[1].name` and so on for each of the various items and properties. We can
    also use the JavaScript `length` property to find out how many individual items
    are in our `items` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this we need to use JavaScript code inline in our template.
    That''s why we use both curly braces and brackets: `{[function goes here]}`. When
    you''re using inline code in your template, you have to access the template variables
    via the `values` array rather than by name.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `values.items.length` returns the number of elements in the `items`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can see how the values are formatted by PHP and displayed in the
    XTemplate, let's take a look at how we work within a database to store and retrieve
    this data.
  prefs: []
  type: TYPE_NORMAL
- en: The API and the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with, we need to replace our flat PHP file with some new code. This
    code will have three basic tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide what kind of request is coming in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact the database and make the appropriate request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the data to be returned to the Sencha Touch application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that from this point on, we are looking at PHP code. While some
    of it looks similar to JavaScript, this code is completely separate from both
    JavaScript and Sencha Touch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These three basic functions will hold true no matter what language your API
    is written in, though the implementation will vary. In PHP our first task would
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we include our database setup file, which handles the basics of our connection
    between the database and our code. Next we use a special variable `$_SERVER['REQUEST_METHOD']`,
    which tells us whether the request was sent via `GET`, `POST`, `PUT`, or `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, and `DELETE` are known as **HTTP methods**, or **verbs**,
    and are used to represent a user''s interactions with the web server. To learn
    more about HTTP verbs, check out the RFC at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We use a `switch` statement (just like the one in JavaScript) to send the different
    requests out to different functions. Each function will contact the database and
    perform the request.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go too deeply into the details of the PHP code to do this,
    but we will take a look at the basic operations for our different requests.
  prefs: []
  type: TYPE_NORMAL
- en: The GET request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GET` request is used to read from the database and it has two basic uses
    in the API: get a single item or get a list of items. First we need to figure
    out if the request is for a single item or all the items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a REST API, a request for a single item would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mydomain.com/api/items/123](http://mydomain.com/api/items/123)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to send back a single item with an ID of 123\. However,
    if we get a request that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mydomain.com/api/items/](http://mydomain.com/api/items/)'
  prefs: []
  type: TYPE_NORMAL
- en: We just send back all the items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing our `doGet()` function needs to do is check the URL and
    see if we have some extra numbers at the end of our request URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line sets up our database so we can make requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have included setup files for the database in with the sample code for this
    chapter. For this application we are assuming a MySQL database, which is freely
    available. There is a `dbSetup.inc` file to handle the basic setup and configuration
    of the database, and a `setup.sql` file that can be imported into MySQL to set
    up the initial tables for the application. More information can be found at [http://dev.mysql.com/doc/](http://dev.mysql.com/doc/).
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the PHP code uses regular expression matching to check the
    URL that we received as part of our request (`$_SERVER['REQUEST_URI']`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular Expressions are an extremely powerful tool for matching strings, numbers,
    and characters. You can use it to find not just words or letters, but patterns
    within any string. For more information, go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/).'
  prefs: []
  type: TYPE_NORMAL
- en: If we get a match, it means that we are looking for a single item. We then take
    our single item and use it to send a request to MySQL for the relevant data. We
    grab the `row` data that gets returned from MySQL. We use the `categoryID` value
    in the `row` data to attach category data to row data using another function called
    `getCategory()`. The whole thing then gets passed to a function called `doJson()`
    for final formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `doJson()` function will be used in multiple places in our code. It simply
    takes an array, an option success value, and an optional message, and turns them
    into the JSON encoded format that Sencha Touch can process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in our `doGet()` function, we have taken care of the request for single
    item, and now we need to handle the request for all items. This means that in
    addition to our original `if` statement (that handled our request for one item)
    we need an `else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This one works a bit differently because we are getting back multiple results.
    This means we need to loop through our results (using `foreach`), and get them
    into a single array we can process using `json_encode()`. We also have to use
    our `getCategory()` function on each round of the loop to grab the `category`
    data and add it to each of our items.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have everything, we echo back the encoded array and exit. This will
    send the JSON back to our application for display in our XTemplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also included a few optional pieces that we can use later on: filters
    and start/limit. This will let us pass values for filters (as an array), and for
    start and limit as individual values. We can then pass these to MySQL and control
    the number of results we get back or filter the results by a particular column.
    It''s always a good idea to build this kind of flexibility into an API. It can
    really save you some time when you start adding new features to your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The POST request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `POST` request is where we will need to handle the creation of new items.
    The variables get passed to us as a `POST` request this time instead of as part
    of the URL (like our previous `GET` method).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using zero when sending a POST for new items**'
  prefs: []
  type: TYPE_NORMAL
- en: In our `item` model, we have set the `itemID` as our `id` property. This is
    the unique `id` for our data record. There is an old programming habit of setting
    the `id` to `0` when you want to create a new data record. However, if you set
    an `id` of `0` on your model, Sencha Touch sees that as a valid ID and determines
    that you are updating a record, which sends your request as a `PUT`, not a `POST`
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `doPost()` function needs to grab the data sent by the request and decode
    the JSON sent by Sencha Touch. Since we need to do this for our `doPut()` and
    `doDelete()` functions, we will create a separate function to do our decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In PHP, we can grab the raw data stream of the request with `file_get_contents('php://input')`.
    We can then decode this stream from JSON to an associative array `('key' => 'val')`
    using `json_decode()`. We simply return the associative array whenever the function
    gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new function gets called right at the top of our `doPost()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next we create the SQL statement that we will use to place the data into our
    database. Then we need to format our data so that it will correctly fit with our
    MySQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by looping through our data and creating a modified array that will
    work with the `execute()` command to combine the data with the `sql` statement
    and `insert` our new data record.
  prefs: []
  type: TYPE_NORMAL
- en: We then grab the unique ID for the new data row with `$db->lastInsertId()` and
    add it to our data array so we can pass it back to the Sencha Touch application.
    We do this with our `doJson()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Our `PUT` request follows a very similar format.
  prefs: []
  type: TYPE_NORMAL
- en: The PUT request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PUT` request is executed when we save an object in Sencha Touch that has
    a valid `id` property, in this case, an `itemID` value. When Sencha Touch sends
    a `save` request for this type of pre-existing object, it uses the `PUT` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our API function `doPut()` does the same basic thing as our `doPost()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since we already have the unique `itemID` we don't need to grab it from the
    database after we update the row. Other than that, the basic structure is the
    same. We simply type an `update` command instead of `insert` in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `DELETE` request is sent when we call `erase()` on our model record in Sencha
    Touch. In this case, our API only cares about the unique `itemID`, so we don't
    need to create a new array to use with our `execute()` statement. We still use
    `getJsonPayload()` to grab the data and after we execute, we echo the JSON encoded
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Back on the Sencha Touch side of things, you will need to reload the store in
    order to see the record removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Category side of the API works in exactly the same way as the Item part
    we just covered. You can look things over in the sample code for this chapter,
    but the logic is all the same. There is a `switch` statement at the top, which
    determines how the request was received. We then have the same basic functions
    set to respond to each type of request.
  prefs: []
  type: TYPE_NORMAL
- en: This simple repeatable structure can be used to generate a basic API for use
    with any application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need additional functionality in your API beyond the basic CRUD functions
    you can also use AJAX stores to send requests to an API file, where it can be
    processed appropriately. The API would need to perform the same basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the type of request either from the variables that are sent or the
    type of request being made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the request through the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode the necessary request into JSON and send it back to the Sencha Touch
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message should also be sent in the event of failure to help with debugging
    or offer the user some information to help fix the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we used a simple catalog application in order to build our
    own API. In addition we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up Sencha Model associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tricks using `.htaccess` and `mod_rewrite` to make prettier URLs for our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Ext.data.proxy.Rest` to communicate with an API via basic CRUD interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will use the data from several third party APIs to enhance
    our application.
  prefs: []
  type: TYPE_NORMAL
