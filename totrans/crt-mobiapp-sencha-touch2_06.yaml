- en: Chapter 6. Catalog Application and API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。目录应用程序和API
- en: In this chapter we are creating a simple catalog application that allows you
    to enter in items for sale and assign them to a category. From an interface and
    functionality aspect, this will be similar to the previous applications we have
    created. The difference here is that we are going to explore creating our own
    API to create, read, update, and delete data from your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个简单的目录应用程序，允许您输入待售项目并将它们分配到类别。从界面和功能角度来看，这将与之前我们创建的应用程序相似。这里的区别在于，我们将探索创建自己的API来从应用程序中创建、读取、更新和删除数据。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: What is an API?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是API？
- en: Creating the basic application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本应用程序
- en: Getting started with an API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用API
- en: Using PHP to create an API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHP创建API
- en: Connecting the API and the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接API和应用
- en: What is an API?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API？
- en: An **API** is an **Application Programming Interface**, which is simply a way
    to make data stored in one place available to a remote application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**（应用程序编程接口）是一种将存储在一个地方的数据提供给远程应用程序的简单方式。'
- en: Remember our first problem with local storage? The data is stored on the device,
    which limits its usefulness in a number of ways. If we store the data separately
    from the device (on a server), we can allow multiple devices to access the data,
    we can limit and secure the data through authentication, and we can back up the
    entire data set for all our users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们关于本地存储的第一个问题吗？数据存储在设备上，这限制了它在许多方面的有用性。如果我们将数据与设备分开存储（在服务器上），我们可以允许多个设备访问数据，我们可以通过身份验证限制和确保数据的安全，并且我们可以为所有用户备份整个数据集。
- en: When we store data separately from the application, we need a way to get to
    it and make changes. This is where the API comes in. In the last chapter, we used
    the Sencha.io API to store and retrieve data. In this chapter, we will explore
    how to create your own API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将数据与应用程序分开存储时，我们需要一种方法来访问它并对其进行更改。这就是API发挥作用的地方。在上一个章节中，我们使用了Sencha.io API来存储和检索数据。在本章中，我们将探讨如何创建自己的API。
- en: The API is a set of code files written in a server-side language such as PHP,
    Ruby, ASP, or Perl. The JavaScript code sends data to these files as part of an
    HTTP request (`GET`, `POST`, `PUT`, or `DELETE`). In the case of Sencha Touch,
    this data is typically sent formatted either as JSON or XML. The server-side language
    will then parse the data and send it to the database as SQL statement. The database
    returns a result, which gets translated by the server-side language back into
    JSON and returned to the browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: API是一组用服务器端语言（如PHP、Ruby、ASP或Perl）编写的代码文件。JavaScript代码将这些数据作为HTTP请求（`GET`、`POST`、`PUT`或`DELETE`）的一部分发送到这些文件。在Sencha
    Touch的情况下，这些数据通常以JSON或XML格式发送。然后服务器端语言将解析数据，将其作为SQL语句发送到数据库。数据库返回一个结果，该结果由服务器端语言转换回JSON，并返回到浏览器。
- en: 'The entire process would look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程看起来像这样：
- en: '![What is an API?](img/8901OS_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![什么是API？](img/8901OS_06_01.jpg)'
- en: 'That''s a lot of acronyms for a single paragraph, so let''s break this down
    into smaller pieces. Let''s assume that you want to add some new user data: a
    name, an email address, and a phone number. In its most basic form, we can use
    a browser URL to send this information as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一段落中有许多缩写，让我们将其分解成更小的部分。假设您想添加一些新的用户数据：姓名、电子邮件地址和电话号码。在其最基本的形式中，我们可以使用浏览器URL发送这些信息，如下所示：
- en: '[http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212](http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212](http://mydomain.com/myapifile.php?action=add&&name=john&&email=john@mydomain.com&&phone=555-1212)'
- en: 'This would allow our server-side language (we will use PHP for this example)
    to grab the data we sent and process it correctly. This might look something like
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们的服务器端语言（我们将使用PHP作为示例）获取我们发送的数据并正确处理它。这可能看起来像这样：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note this is only an example; you would almost certainly want to filter
    and sanity check any incoming data. Since we are not going to cover all of PHP
    here, we will only talk about the server-side code in very general terms. It is
    not intended for actual use, just as a general idea of how things work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是一个示例；您几乎肯定想要过滤和检查任何传入的数据。由于我们不会在这里涵盖所有PHP，我们将仅以非常通用的方式讨论服务器端代码。这不是实际使用，而是一个关于事物如何工作的通用概念。
- en: 'Now that the PHP has our variables it can convert them into something our server-side
    database can understand:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 PHP 已经有了我们的变量，它可以将其转换为服务器端数据库可以理解的内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would pass the data from PHP to a database (like MySQL). The database
    then returns a result, which we can then loop through to create a new array that
    matches the format we need. We can then format the results as JSON and echo it
    back:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将数据从 PHP 传递到数据库（如 MySQL）。然后数据库返回一个结果，我们可以遍历它以创建一个新的数组，该数组符合我们需要的格式。然后我们可以将结果格式化为
    JSON 并将其回显：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As previously noted, this is a very raw general example and APIs can get very
    complex, very quickly. Fortunately for us, Sencha Touch handles some of this work
    automatically.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是一个非常原始的通用示例，API 可能会非常复杂，而且会很快变得复杂。幸运的是，Sencha Touch 自动处理了一些这项工作。
- en: Using a remote API in Sencha Touch
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Sencha Touch 中使用远程 API
- en: 'When using Sencha Touch, the JavaScript side of an API becomes a lot easier
    to manage. We can accomplish most of what we need using the store and a model.
    Following our previous example, we would create a model that looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Sencha Touch 时，API 的 JavaScript 方面变得更容易管理。我们可以使用存储和模型完成我们需要的几乎所有事情。按照我们之前的例子，我们会创建一个看起来像这样的模型：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sets up our simple model with a unique `id`, `name`, `email`, and `phone`
    fields. However, we can also add a `proxy` setting and `api` definition to this
    (right after we finish declaring the fields):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了我们的简单模型，具有唯一的 `id`、`name`、`email` 和 `phone` 字段。然而，我们也可以向这个（在我们完成字段声明后）添加
    `proxy` 设置和 `api` 定义：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we are using a `scripttag` proxy. Later on in the chapter we
    are going to use a different proxy, called a `rest` proxy for the actual application.
    You should get a feel for the various types of proxies provided by Sencha Touch,
    and use the one that best suits your application and needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个 `scripttag` 代理。在章节的后面，我们将使用一个不同的代理，称为 `rest` 代理，用于实际的应用程序。你应该熟悉
    Sencha Touch 提供的各种代理类型，并使用最适合你应用程序和需求的一个。
- en: The `scripttag` proxy allows us to communicate with another domain (if the PHP
    and Sencha Touch code are running on the same domain, an `ajax` proxy should be
    used instead).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripttag` 代理允许我们与另一个域进行通信（如果 PHP 和 Sencha Touch 代码在同一个域上运行，则应使用 `ajax` 代理）。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As we mentioned in [Chapter 2](ch02.html "Chapter 2. A Feed Reader"), *A Feed
    Reader*, this is due to the same origin policy, which prevents cross-domain attacks
    in JavaScript. If you would like to learn more about this origin policy, this
    Wikipedia article is a good place to start:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [第 2 章](ch02.html "第 2 章。阅读器") 中提到的，*阅读器*，这是由于同源策略，它防止 JavaScript 中的跨域攻击。如果你想了解更多关于这个同源策略的信息，这个维基百科文章是一个很好的起点：
- en: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Same_origin_policy](http://en.wikipedia.org/wiki/Same_origin_policy)'
- en: The `url` property tells the model where to send information for creating, reading,
    updating, and destroying users (often referred to as **CRUD** functions).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`url` 属性告诉模型将信息发送到创建、读取、更新和删除用户的位置（通常称为 **CRUD** 函数）。'
- en: The `reader` property tells the model where to look for the data when it gets
    back a JSON encoded list of users.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader` 属性告诉模型在接收到一个 JSON 编码的用户列表时在哪里查找数据。'
- en: 'Finally, the `api` section tells the model which URLs to use for each of our
    CRUD functions. This API setup allows us to do things such as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`api` 部分告诉模型为我们的每个 CRUD 函数使用哪个 URL。这种 API 设置允许我们完成诸如：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create a new user with all of our information and then call `save`. By calling
    `save`, the information is submitted to the `create` URL we set up previously
    in our model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用所有信息创建一个新的用户，然后调用 `save`。通过调用 `save`，信息被提交到我们在模型中之前设置的 `create` URL。
- en: 'Notice that we didn''t send an ID. When we create a new user, the database
    will actually set the unique ID. A properly written API should return this value
    along with the rest of the user information if the transaction is successful.
    The JSON that comes back to us should look something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们没有发送一个 ID。当我们创建一个新用户时，数据库实际上会设置唯一的 ID。一个正确编写的 API 应该在交易成功时返回这个值以及用户信息的其余部分。返回给我们的
    JSON 应该看起来像这样：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can then use this information for any post processing we require.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些信息进行任何所需的后期处理。
- en: 'We can also save changes to an existing user, or delete the user by calling:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过调用以下方式保存现有用户的更改，或删除用户：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also use the same proxy when we set up a user store:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设置用户存储时也使用相同的代理：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will let us create, read, update, and delete multiple users at once.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够一次性创建、读取、更新和删除多个用户。
- en: 'The `api` section will be called when we load or sync the store, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载或同步商店时，将会调用 `api` 部分，如下所示：
- en: Calling `load()` on the store will contact `users.php` which should return a
    list of users
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商店上调用 `load()` 将会联系 `users.php`，它应该返回用户列表
- en: Adding new user records to the store and calling `sync()` will contact `users.php`
    and save the new users
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商店中添加新的用户记录并调用 `sync()` 将会联系 `users.php` 并保存新用户
- en: Updating existing user records in the store and calling `sync()` will contact
    `users.php`, and update the records for each user
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商店中更新现有用户记录并调用 `sync()` 将会联系 `users.php`，并更新每个用户记录
- en: Removing users from the store and calling `sync()` will contact `users.php`,
    and destroy the specified user records in the database
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从商店中删除用户并调用 `sync()` 将会联系 `users.php`，并在数据库中销毁指定的用户记录
- en: Tip
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Defining a `proxy` setting on both the model and the store isn't strictly necessary.
    If your model has a `proxy` setting defined and your store does not, then the
    store will automatically use the model's `proxy`.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模型和商店上定义 `proxy` 设置并不是严格必要的。如果你的模型有定义 `proxy` 设置而你的商店没有，那么商店将自动使用模型的 `proxy`。
- en: If you are using an API you didn't write, you would need to make sure that you
    are sending the data and requests in the correct format. Check the documentation
    for the API you are using to see if there are any additional requirements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是你没有编写的 API，你需要确保你发送的数据和请求是以正确的格式进行的。查看你所使用的 API 文档，以了解是否有任何额外的要求。
- en: As you may have noticed, we have been a bit vague on what is happening at the
    API end of things. This is because each API is a little different in terms of
    the data they expect, and the data they return.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们在 API 端的事情上有点含糊。这是因为每个 API 在期望的数据和返回的数据方面都有所不同。
- en: Most publicly accessible APIs are fairly well documented, but it is also helpful
    to have a general idea of what goes into making an API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公开可访问的 API 都有相当好的文档，但了解制作 API 的基本概念也是有帮助的。
- en: Creating your own API
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的 API
- en: 'At their most basic, APIs perform three core functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，API 执行三个核心功能：
- en: Receive data from a remote source
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程源接收数据
- en: Connect to and modify a database (or other data source)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到并修改数据库（或其他数据源）
- en: Transmit data to the remote application
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向远程应用程序发送数据
- en: When you create your own API, you will need to account for each of these functions.
    You can create your API in any server-side language you want, as long as it can
    handle these three basic things. Let's take a high-level view at each of these
    functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的 API 时，你需要考虑这些函数中的每一个。你可以使用任何你想要的服务器端语言来创建你的 API，只要它能处理这三个基本的事情。让我们从高层次的角度来看每个这些函数。
- en: Receiving data
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收数据
- en: When you receive data from an application, you need to figure out what the user
    is asking for and how they are expecting the answer to be returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从应用程序接收数据时，你需要弄清楚用户在询问什么，以及他们期望如何返回答案。
- en: 'When you use the standard Sencha Touch API requests for models and stores,
    the `create`, `read`, `update`, and `destroy` functions are triggered, causing
    requests to be transmitted to the URLs you specify in the proxy configuration,
    along with any relevant data for the transaction. You can also send additional
    data using the `params` configuration like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用标准的 Sencha Touch API 对模型和商店进行请求时，会触发 `create`、`read`、`update` 和 `destroy`
    函数，导致请求被发送到你在代理配置中指定的 URL，以及交易相关的任何数据。你也可以使用 `params` 配置发送额外的数据，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your API will need to be set up to receive and translate the data and any extra
    parameters, so that it can decide what actions to take and what data to return.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 API 需要设置好以接收和转换数据和任何额外的参数，以便它可以决定采取什么行动以及返回什么数据。
- en: The first thing you will need to do is determine if the variables are being
    sent as part of a `GET` or `POST` request. The server-side language you choose
    should have methods for dealing with either of these two transmission types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要做的是确定变量是否作为 `GET` 或 `POST` 请求的一部分发送。你选择的服务器端语言应该有处理这两种传输类型的方法。
- en: As mentioned before, PHP can collect this data using `$_GET["variableName"]`
    and `$_POST["variableName"]`. Your chosen language will have similar functions.
    This data will also be encoded as JSON, so you will need to decode it before you
    can get to the individual pieces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，PHP可以使用`$_GET["variableName"]`和`$_POST["variableName"]`来收集这些数据。你选择的语言将有类似的功能。这些数据也将被编码为JSON，因此在你能够获取到单个数据项之前，你需要对其进行解码。
- en: Most server-side languages have functions for dealing with this. For example,
    PHP uses `json_decode($myJSONData)` to transform the JSON data into a PHP array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务器端语言都有处理此问题的函数。例如，PHP使用`json_decode($myJSONData)`将JSON数据转换为PHP数组。
- en: Once the data is collected, it should be checked to make sure that it is something
    we expected. For example, if our API receives an `action` value as `read` and
    an `id` value as `DELETE * FROM users`, we might not want to send this on to our
    database. Most languages also have ways to validate data types and sanitize any
    potentially hostile values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集完毕后，应该检查以确保它是我们预期的。例如，如果我们的API接收到的`action`值为`read`，而`id`值为`DELETE * FROM
    users`，我们可能不希望将此发送到我们的数据库。大多数语言也有验证数据类型和清理任何潜在有害值的方法。
- en: Additionally, a store can often combine multiple requests into an array of data.
    Your code will need to check and see if the data being passed is an array or a
    single item, and deal with each appropriately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，存储可以经常将多个请求组合成数据数组。你的代码需要检查传递的数据是数组还是单个项目，并相应地处理。
- en: Communicating with the database
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与数据库通信
- en: Once you have your variables and you understand what the user needs to accomplish,
    you will likely need to make a connection to your database to get or modify the
    data. For example, if you get an `action` value of `read` and an `id` value of
    `45`, you will likely want to query the database for any users with an `id` value
    of `45`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了变量，并且理解了用户需要完成什么，你可能会需要连接到你的数据库以获取或修改数据。例如，如果你得到一个`action`值为`read`，而`id`值为`45`，你可能会想要查询数据库以获取任何`id`值为`45`的用户。
- en: Performing this action will require knowledge of how the server-side language
    you are using connects to a database, and how your database accepts queries for
    information. You will need to consult the reference guides for your language and
    database to determine how this is done.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作需要了解你使用的服务器端语言如何连接到数据库，以及你的数据库如何接受信息查询。你需要查阅你语言和数据库的参考指南，以确定如何完成此操作。
- en: Sending data back to the application
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据发送回应用程序
- en: Once you have communicated with the database and you are ready to send information
    back to the application, you will need to encode it correctly in order for Sencha
    Touch to process it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你与数据库进行了通信，并且准备将信息发送回应用程序，你需要正确地编码它，以便Sencha Touch能够处理它。
- en: Something to keep in mind is that Sencha Touch expects to receive data encoded
    as JSON. Most server-side languages have functions for dealing with this. For
    example, PHP uses `json_encode($myArrayOfData)` to bundle up the information into
    a JSON format.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Sencha Touch期望接收编码为JSON的数据。大多数服务器端语言都有处理这种数据的函数。例如，PHP使用`json_encode($myArrayOfData)`将信息捆绑成JSON格式。
- en: Once you have the JSON-encoded data, you can output it directly to the browser
    using something like PHP's `print` or `echo` functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了JSON编码的数据，你可以直接使用类似PHP的`print`或`echo`函数将其输出到浏览器。
- en: More information on APIs
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于API的更多信息
- en: 'Now that you have some idea of how APIs function you can gather some specific
    data for the server-side language you want to use. For more specific information,
    take a look at:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对API的工作方式有了些了解，你可以收集你想要使用的服务器端语言的特定数据。获取更具体的信息，请参阅：
- en: '[http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/](http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/](http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/)'
- en: Building the basic application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本应用程序
- en: For this chapter, we will not be going through the entire build process of the
    application. Instead, we will be focusing mainly on the models, stores, and the
    basic API. The application itself is composed of a tabbed layout with two tabs.
    Each of our two tabs is a panel with a Card Layout, one for Items and one for
    Categories. In turn, these two panels have their own subpanels for listing, showing
    details, and editing (a list, a panel, and a form panel respectively).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章，我们不会详细介绍整个应用程序的构建过程。相反，我们将主要关注模型、存储和基本API。应用程序本身由一个带有两个标签的标签布局组成。我们两个标签中的每一个都是一个带有卡片布局的面板，一个用于项目，一个用于类别。反过来，这两个面板都有自己的子面板，用于列出、显示详细信息和管理（分别是一个列表、一个面板和一个表单面板）。
- en: '![Building the basic application](img/8901OS_06_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![构建基本应用程序](img/8901OS_06_02.jpg)'
- en: You can take a look at the application code to see how these components are
    laid out. The Main Tab Panel and the two Card Layout panels for Items and Categories
    are part of the `Main.js` file. The List, Details, and Edit panels are all separate
    views inside the `app/views` folder. We will come back to the views a bit later,
    but what we are really interested in for this chapter is the stores and models.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看应用程序代码以了解这些组件是如何布局的。主选项卡面板和用于项目和类别的两个卡片布局面板都是`Main.js`文件的一部分。列表、详细信息和管理面板都是`app/views`文件夹内的独立视图。我们稍后会回到视图，但对我们这一章真正感兴趣的是存储和模型。
- en: Creating the item model
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目模型
- en: 'The model is where most of the interesting stuff is going on. In the model
    we will be using two new options: a `rest` proxy and model relations.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是大多数有趣事情发生的地方。在模型中，我们将使用两个新的选项：一个`rest`代理和模型关系。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This starts out in the same manner as our previous models, but we have a new
    configuration option called `uses`. This option is set to our other model, `CatHerder.model.Category`,
    and tells us that we will have a relationship between our `Item` model and our
    `Category` model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的先前模型以相同的方式开始，但我们有一个新的配置选项称为`uses`。此选项设置为我们的另一个模型`CatHerder.model.Category`，并告诉我们我们将有一个`Item`模型和`Category`模型之间的关系。
- en: Below our `fields`, we have another new option called `hasOne`. This option
    tells us that each `Item` is related to a single `Category`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`fields`下方，我们还有一个新的选项，称为`hasOne`。此选项告诉我们每个`Item`都与一个`Category`相关联。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the option `hasMany`. This would allow you to set several categories
    on an item. For the sake of simplicity, we will be going with `hasOne` for this
    example. To see some examples of `hasMany`, take a look at [http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`hasMany`选项。这将允许您为项目设置多个类别。为了简单起见，我们将在这个例子中使用`hasOne`。要查看`hasMany`的一些示例，请参阅[http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany](http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany)。
- en: 'The `hasOne` option includes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasOne`选项包括：'
- en: 'The model we are relating to: `CatHerder.model.Category`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要关联的模型：`CatHerder.model.Category`
- en: 'The `name` property we will reference to get the related information: `category`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将引用以获取相关信息的`name`属性：`category`
- en: The `primaryKey` property indicates the field that is part of our `Item` model,
    which we will use to match the `id` property set for our related model, `categoryID`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primaryKey`属性表示是`Item`模型的一部分的字段，我们将使用它来匹配为相关模型`categoryID`设置的`id`属性。'
- en: This configuration will let us use the fields in the `Category` model the same
    way as we would use any of the `Item` model's other attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将使我们能够以使用`Item`模型的其他属性相同的方式使用`Category`模型中的字段。
- en: We also have a new type of proxy called a `rest` proxy. Unlike the `scripttag`
    proxy we covered earlier, the `rest` proxy uses different types of HTTP requests
    to denote if we are creating, reading, updating, or deleting data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个新的代理类型，称为`rest`代理。与之前我们讨论的`scripttag`代理不同，`rest`代理使用不同类型的HTTP请求来表示我们是在创建、读取、更新还是删除数据。
- en: 'The different types of requests include:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的请求类型包括：
- en: Creating a new record will be sent as a `POST` request
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新记录将以`POST`请求发送
- en: Reading data will be sent as a `GET` request
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取数据将以`GET`请求发送
- en: Updating an existing record will be sent as a `PUT` request
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有记录将以`PUT`请求发送
- en: Deleting records will be sent as a `DELETE` request
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除记录将以`DELETE`请求发送
- en: Each of these request types will be sent to `api/item` for processing. We have
    done a bit of trickery here with the URLs to make them look a bit cleaner to the
    user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每种请求类型都将发送到 `api/item` 进行处理。我们在 URL 上做了一些技巧，使它们对用户看起来更干净。
- en: RewriteRule and .htaccess
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RewriteRule 和 .htaccess
- en: 'Normally we would point our model at a particular file as we did in the earlier
    `scripttag` proxy example. In that case we would have done something like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会在早期 `scripttag` 代理示例中指向特定的文件，就像这样：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we want to view a particular item, the URL looks like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要查看特定项目时，URL 看起来像这样：
- en: '[http://myapp.com/api/item.php?item=143](http://myapp.com/api/item.php?item=143)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://myapp.com/api/item.php?item=143](http://myapp.com/api/item.php?item=143)'
- en: 'However, with a little bit of configuration, we can change that so the URL
    would look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过一点配置，我们可以将其更改，使 URL 看起来像这样：
- en: '[http://myapp.com/api/item/143](http://myapp.com/api/item/143)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://myapp.com/api/item/143](http://myapp.com/api/item/143)'
- en: This is shorter and much easier to read. It just requires a `RewriteRule` directive
    and a `.htaccess` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这更简洁，也更易于阅读。只需一个 `RewriteRule` 指令和一个 `.htaccess` 文件即可。
- en: 'The `.htaccess` file is used by the Apache web server to determine a number
    of options and configurations for the server you are using. These options can
    be set by creating or editing the `.htaccess` file in the `api` directory of your
    application. In this case, we will create one with the following information:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`.htaccess` 文件由 Apache 网络服务器用于确定您所使用的服务器的一组选项和配置。这些选项可以通过在应用程序的 `api` 目录中创建或编辑
    `.htaccess` 文件来设置。在这种情况下，我们将创建一个包含以下信息的文件：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first line turns on the ability to rewrite a URL. This means that while
    the user's address bar shows one thing, we direct the request to a different file.
    As the previous comments state, the next block sends any requests for `item` to
    `item.php` and the next block sends requests for `category` to `category.php`.
    The `[L]` directive says that if a rule matches the currently requested URL, no
    more rules should be checked, as this is the last rule to match against. This
    is a very simple change that gives a more professional and friendly feel to an
    application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行启用了重写 URL 的功能。这意味着虽然用户的地址栏显示的是一件事，但我们将请求重定向到不同的文件。正如前面的注释所述，下一个块将任何对 `item`
    的请求发送到 `item.php`，下一个块将请求发送到 `category.php`。`[L]` 指令表示如果规则与当前请求的 URL 匹配，则不再检查更多规则，因为这将是最后一个匹配的规则。这是一个非常简单的更改，使应用程序看起来更加专业和友好。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more about `.htaccess` and Apache, a good place to
    start is at [http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/](http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 `.htaccess` 和 Apache 的信息，一个好的起点是 [http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/](http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/)。
- en: Save the file and close it. Now all of our different HTTP requests will be sent
    to `api/item` and `api/category`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并关闭它。现在，我们所有的不同 HTTP 请求都将发送到 `api/item` 和 `api/category`。
- en: Our API will need to be able to distinguish the different HTTP request types
    in order to understand what to do with the data. We will get to how that works
    in a second, but first let's take a quick look at the store.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们的 API 如何区分不同的 HTTP 请求类型以便理解如何处理数据，我们将在下一部分进行说明，但首先让我们快速看一下存储。
- en: The item store
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目存储
- en: 'The item store is extremely simple for this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，项目存储非常简单：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since we don't declare a proxy, the store will automatically use the one we
    set on our model. Other than that, we simply require our model to give the store
    a `storeId` value and set `autoLoad` to `true`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有声明代理，存储将自动使用我们在模型上设置的存储。除此之外，我们只需要求我们的模型给存储提供一个 `storeId` 值，并将 `autoLoad`
    设置为 `true`。
- en: Creating the category model and store
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建分类模型和存储
- en: 'Our category model and store are just variations of our item model and store.
    The model uses `hasMany` instead of `hasOne`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分类模型和存储只是我们项目模型和存储的变体。该模型使用 `hasMany` 而不是 `hasOne`：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use `hasMany` because we are going to have multiple items in a single category.
    Other than that, the basic structure of the model is the same as our item model,
    using the `rest` proxy and contacting our PHP API at `/api/category`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `hasMany` 是因为我们将在单个分类中拥有多个项目。除此之外，模型的基本结构与我们的项目模型相同，使用 `rest` 代理并联系我们的
    PHP API 在 `/api/category`。
- en: 'Our `categoryStore` is also a virtual duplicate of the `itemStore`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `categoryStore` 也是 `itemStore` 的虚拟副本：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As before we just extend the basic store component, declare which model we are
    using (`'CatHerder.model.Category'`), and give the store an ID we can reference
    later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只是扩展了基本存储组件，声明我们正在使用的模型(`'CatHerder.model.Category'`)，并给存储一个我们可以稍后引用的ID。
- en: Once we have these two pieces in place, it's time for a bit of testing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两部分，就到了进行一些测试的时候了。
- en: Testing the store and the model
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试存储和模型
- en: When creating an API for your application, it's usually a good idea to begin
    with just a flat text file. This will let you test the read abilities of the store
    and help you better understand how the data will need to be formatted for your
    API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当为您的应用程序创建API时，通常从只是一个平面文本文件开始是个好主意。这将让您测试存储的读取能力，并帮助您更好地理解数据将如何格式化以适应您的API。
- en: For this test file, we are going to create a couple of very basic PHP files.
    These files will simply create a static array of data, encode it as JSON, and
    echo it back to the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试文件，我们将创建几个非常基础的PHP文件。这些文件将简单地创建一个静态数据数组，将其编码为JSON，并将其回显到应用程序中。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use any server-side language you would like; Sencha Touch doesn't care
    as long as it can accept and return JSON. If you'd like to use PHP for your server
    code, but need a place to get started, try [http://phpmaster.com/](http://phpmaster.com/).
    PHP Master has lots of tutorials for all levels of PHP programmers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何您喜欢的服务器端语言；Sencha Touch并不关心，只要它能接受和返回JSON即可。如果您想使用PHP作为您的服务器代码，但需要一个起点，请尝试[http://phpmaster.com/](http://phpmaster.com/)。PHP
    Master为所有级别的PHP程序员提供了大量的教程。
- en: 'We will start with the `item.php` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`item.php`文件开始：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This file creates an array called `$test`. The `$test` array has three arrays
    nested inside of it, one for each of our items. These arrays each contain various
    fields such as `itemID`, `name`, `description`, `price`, `photoURL`, and `categoryID`.
    They also contain the category data as part of an additional nested array. We
    include the category data as part of the item data so that our stores can access
    it via the `hasOne` relationship without requiring an extra AJAX call per item
    to the server to load the category data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件创建了一个名为`$test`的数组。`$test`数组在其内部嵌套了三个数组，每个数组对应我们的一个项目。这些数组包含各种字段，如`itemID`、`name`、`description`、`price`、`photoURL`和`categoryID`。它们还包含作为附加嵌套数组一部分的类别数据。我们将类别数据包含在项目数据中，以便我们的存储可以通过`hasOne`关系访问它，而无需对每个项目进行额外的AJAX调用以从服务器加载类别数据。
- en: When you write the final PHP code for your application, it will query a database
    to get this information for both the items and the categories. The PHP will then
    need to format it in just this fashion.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为应用程序编写最终的PHP代码时，它将查询数据库以获取关于项目和类别的信息。然后PHP需要以这种格式格式化它。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'PHP formats an array in a similar fashion to Sencha Touch, where Sencha Touch
    uses `key: value`, and PHP uses `''key'' => value`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'PHP以类似于Sencha Touch的方式格式化数组，其中Sencha Touch使用`key: value`，而PHP使用`''key'' =>
    value`。'
- en: The last line of the PHP file takes our array and encodes it as JSON. We then
    use `echo` to send the data back to our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文件的最后一行将我们的数组编码为JSON。然后我们使用`echo`将数据发送回我们的应用程序。
- en: 'We do the exact same thing for our categories array in `category.php`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`category.php`中对类别数组做完全相同的事情：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that in this case, we only have two categories, but we also include the
    items associated with each category. This lets us do a lot more with the data
    later on (such as showing the number of items in a category).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们只有两个类别，但我们还包含了与每个类别关联的项目。这使得我们可以在稍后对数据进行更多操作（例如显示类别中的项目数量）。
- en: While these may look like large and messy arrays, the final PHP code is going
    to do most of the work for you. This is simply for testing and making sure you
    have the initial data formatting correct.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些可能看起来像大而杂乱的数组，但最终的PHP代码将为您做大部分工作。这只是为了测试并确保您已经正确地格式化了初始数据。
- en: '![Testing the store and the model](img/8901OS_06_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![测试存储和模型](img/8901OS_06_03.jpg)'
- en: When you load the application you can now see the two lists with our flat data.
    Let's take a quick look at the XTemplates we are using for this data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您加载应用程序时，现在您可以看到包含平面数据的两个列表。让我们快速看一下我们用于这些数据的XTemplates。
- en: Creating the XTemplates
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建XTemplates
- en: 'Now that we have seen how the data is being sent to the application, we need
    to understand how we can use it in our XTemplates. In our list view, the `itemTpl`
    looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了数据是如何发送到应用程序的，我们需要了解我们如何在XTemplates中使用它。在我们的列表视图中，`itemTpl`看起来像这样：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both our category and our item include field values for name. Since the item
    is our main piece of data here, we can refer to the item's name value as `{name}`.
    Since category is related to item (and our PHP passes back as a nested array within
    each item), we refer to the category name value as `category.name`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Our category list XTemplate uses a similar format to provide us with the category
    name, but it uses a slightly different method to get the number of items in each
    category:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the category is our main piece of data here, name refers to the category
    name. We can get to any of the item properties by doing `item.propertyName`, but
    what we really want to know is the number of items in the category.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Remember in our PHP flat file we included the individual items as part of a
    nested array in our category. This nested array was called `items`. We can print
    the name of the first item by using `items[0].name` or the second item by using
    `items[1].name` and so on for each of the various items and properties. We can
    also use the JavaScript `length` property to find out how many individual items
    are in our `items` array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this we need to use JavaScript code inline in our template.
    That''s why we use both curly braces and brackets: `{[function goes here]}`. When
    you''re using inline code in your template, you have to access the template variables
    via the `values` array rather than by name.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `values.items.length` returns the number of elements in the `items`
    array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can see how the values are formatted by PHP and displayed in the
    XTemplate, let's take a look at how we work within a database to store and retrieve
    this data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The API and the database
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with, we need to replace our flat PHP file with some new code. This
    code will have three basic tasks:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Decide what kind of request is coming in
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact the database and make the appropriate request
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the data to be returned to the Sencha Touch application
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that from this point on, we are looking at PHP code. While some
    of it looks similar to JavaScript, this code is completely separate from both
    JavaScript and Sencha Touch.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These three basic functions will hold true no matter what language your API
    is written in, though the implementation will vary. In PHP our first task would
    look something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we include our database setup file, which handles the basics of our connection
    between the database and our code. Next we use a special variable `$_SERVER['REQUEST_METHOD']`,
    which tells us whether the request was sent via `GET`, `POST`, `PUT`, or `DELETE`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, and `DELETE` are known as **HTTP methods**, or **verbs**,
    and are used to represent a user''s interactions with the web server. To learn
    more about HTTP verbs, check out the RFC at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We use a `switch` statement (just like the one in JavaScript) to send the different
    requests out to different functions. Each function will contact the database and
    perform the request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`switch`语句（就像JavaScript中的那样）将不同的请求发送到不同的函数。每个函数将联系数据库并执行请求。
- en: We are not going to go too deeply into the details of the PHP code to do this,
    but we will take a look at the basic operations for our different requests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入到执行此操作的PHP代码的细节，但我们将查看不同请求的基本操作。
- en: The GET request
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET请求
- en: 'The `GET` request is used to read from the database and it has two basic uses
    in the API: get a single item or get a list of items. First we need to figure
    out if the request is for a single item or all the items.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`请求用于从数据库中读取，并在API中有两种基本用途：获取单个项目或获取项目列表。首先我们需要确定请求是针对单个项目还是所有项目。'
- en: 'In a REST API, a request for a single item would look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API中，对单个项目的请求看起来是这样的：
- en: '[http://mydomain.com/api/items/123](http://mydomain.com/api/items/123)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mydomain.com/api/items/123](http://mydomain.com/api/items/123)'
- en: 'In this case, we want to send back a single item with an ID of 123\. However,
    if we get a request that looks like:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要返回一个ID为123的单个项目。然而，如果我们得到一个看起来像这样的请求：
- en: '[http://mydomain.com/api/items/](http://mydomain.com/api/items/)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mydomain.com/api/items/](http://mydomain.com/api/items/)'
- en: We just send back all the items in the database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将数据库中的所有项目发送回去。
- en: 'So, the first thing our `doGet()` function needs to do is check the URL and
    see if we have some extra numbers at the end of our request URL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`doGet()`函数首先需要检查URL，看看我们的请求URL的末尾是否有额外的数字：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line sets up our database so we can make requests.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置我们的数据库，以便我们可以进行请求。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have included setup files for the database in with the sample code for this
    chapter. For this application we are assuming a MySQL database, which is freely
    available. There is a `dbSetup.inc` file to handle the basic setup and configuration
    of the database, and a `setup.sql` file that can be imported into MySQL to set
    up the initial tables for the application. More information can be found at [http://dev.mysql.com/doc/](http://dev.mysql.com/doc/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将数据库的设置文件包含在本章的示例代码中。对于这个应用程序，我们假设使用MySQL数据库，它是免费可用的。有一个`dbSetup.inc`文件用于处理数据库的基本设置和配置，还有一个`setup.sql`文件，可以导入MySQL以设置应用程序的初始表。更多信息请访问[http://dev.mysql.com/doc/](http://dev.mysql.com/doc/).
- en: The next part of the PHP code uses regular expression matching to check the
    URL that we received as part of our request (`$_SERVER['REQUEST_URI']`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: PHP代码的下一部分使用正则表达式匹配来检查我们作为请求的一部分接收到的URL (`$_SERVER['REQUEST_URI']`)。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Regular Expressions are an extremely powerful tool for matching strings, numbers,
    and characters. You can use it to find not just words or letters, but patterns
    within any string. For more information, go to:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是匹配字符串、数字和字符的极其强大的工具。您可以使用它来查找不仅仅是单词或字母，还可以查找任何字符串中的模式。更多信息请访问：
- en: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/).'
- en: If we get a match, it means that we are looking for a single item. We then take
    our single item and use it to send a request to MySQL for the relevant data. We
    grab the `row` data that gets returned from MySQL. We use the `categoryID` value
    in the `row` data to attach category data to row data using another function called
    `getCategory()`. The whole thing then gets passed to a function called `doJson()`
    for final formatting.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到匹配，这意味着我们正在寻找单个项目。然后我们取我们的单个项目并使用它向MySQL发送请求以获取相关数据。我们获取MySQL返回的`row`数据。我们使用`row`数据中的`categoryID`值，通过另一个名为`getCategory()`的函数将分类数据附加到行数据上。然后整个数据传递给一个名为`doJson()`的函数进行最终格式化。
- en: 'This `doJson()` function will be used in multiple places in our code. It simply
    takes an array, an option success value, and an optional message, and turns them
    into the JSON encoded format that Sencha Touch can process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`doJson()`函数将在我们的代码的多个地方使用。它简单地将一个数组、一个成功值和一个可选的消息转换成Sencha Touch可以处理的JSON编码格式：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Back in our `doGet()` function, we have taken care of the request for single
    item, and now we need to handle the request for all items. This means that in
    addition to our original `if` statement (that handled our request for one item)
    we need an `else` statement:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`doGet()`函数中，我们已经处理了单个项目的请求，现在我们需要处理所有项目的请求。这意味着除了我们原来的`if`语句（处理我们的单个项目请求）之外，我们还需要一个`else`语句：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This one works a bit differently because we are getting back multiple results.
    This means we need to loop through our results (using `foreach`), and get them
    into a single array we can process using `json_encode()`. We also have to use
    our `getCategory()` function on each round of the loop to grab the `category`
    data and add it to each of our items.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的工作方式略有不同，因为我们正在获取多个结果。这意味着我们需要通过循环遍历我们的结果（使用 `foreach`），并将它们放入一个我们可以使用
    `json_encode()` 处理的单个数组中。我们还需要在循环的每一轮中使用我们的 `getCategory()` 函数来获取 `category` 数据并将其添加到我们的每个条目中。
- en: Once we have everything, we echo back the encoded array and exit. This will
    send the JSON back to our application for display in our XTemplate.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有这些，我们就回显编码后的数组并退出。这将发送 JSON 回到我们的应用程序，以便在 XTemplate 中显示。
- en: 'We have also included a few optional pieces that we can use later on: filters
    and start/limit. This will let us pass values for filters (as an array), and for
    start and limit as individual values. We can then pass these to MySQL and control
    the number of results we get back or filter the results by a particular column.
    It''s always a good idea to build this kind of flexibility into an API. It can
    really save you some time when you start adding new features to your application.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了一些可选的组件，我们可以在以后使用：过滤器以及起始/限制。这将允许我们传递过滤器的值（作为一个数组），以及起始和限制作为单独的值。然后我们可以将这些传递给
    MySQL，控制我们获取的结果数量或通过特定的列过滤结果。在 API 中构建这种灵活性总是一个好主意。当您开始向应用程序添加新功能时，这可以真正为您节省时间。
- en: The POST request
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST 请求
- en: The `POST` request is where we will need to handle the creation of new items.
    The variables get passed to us as a `POST` request this time instead of as part
    of the URL (like our previous `GET` method).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求是我们需要处理新项目创建的地方。这次变量作为 `POST` 请求传递给我们，而不是作为 URL 的一部分（如我们之前的 `GET`
    方法）。'
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Using zero when sending a POST for new items**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送 POST 请求时使用零为新项目**'
- en: In our `item` model, we have set the `itemID` as our `id` property. This is
    the unique `id` for our data record. There is an old programming habit of setting
    the `id` to `0` when you want to create a new data record. However, if you set
    an `id` of `0` on your model, Sencha Touch sees that as a valid ID and determines
    that you are updating a record, which sends your request as a `PUT`, not a `POST`
    request.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `item` 模型中，我们将 `itemID` 设置为我们的 `id` 属性。这是我们的数据记录的唯一 `id`。有一种旧的编程习惯，当你想要创建一个新的数据记录时，将
    `id` 设置为 `0`。然而，如果你在你的模型中将 `id` 设置为 `0`，Sencha Touch 会将其视为一个有效的 ID，并确定你正在更新一个记录，这将使你的请求作为一个
    `PUT` 请求，而不是 `POST` 请求。
- en: 'Our `doPost()` function needs to grab the data sent by the request and decode
    the JSON sent by Sencha Touch. Since we need to do this for our `doPut()` and
    `doDelete()` functions, we will create a separate function to do our decoding:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `doPost()` 函数需要获取请求发送的数据并解码 Sencha Touch 发送的 JSON。由于我们还需要在我们的 `doPut()`
    和 `doDelete()` 函数中这样做，我们将创建一个单独的函数来执行解码：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In PHP, we can grab the raw data stream of the request with `file_get_contents('php://input')`.
    We can then decode this stream from JSON to an associative array `('key' => 'val')`
    using `json_decode()`. We simply return the associative array whenever the function
    gets called.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，我们可以使用 `file_get_contents('php://input')` 获取请求的原始数据流。然后我们可以使用 `json_decode()`
    将此流从 JSON 解码为一个关联数组 `('key' => 'val')`。每当函数被调用时，我们简单地返回这个关联数组。
- en: 'This new function gets called right at the top of our `doPost()` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数在 `doPost()` 函数的顶部被调用：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next we create the SQL statement that we will use to place the data into our
    database. Then we need to format our data so that it will correctly fit with our
    MySQL statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建将用于将数据放入我们数据库的 SQL 语句。然后我们需要格式化我们的数据，以确保它能够正确地与我们的 MySQL 语句匹配。
- en: We do this by looping through our data and creating a modified array that will
    work with the `execute()` command to combine the data with the `sql` statement
    and `insert` our new data record.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是通过遍历我们的数据并创建一个修改后的数组，该数组将适用于 `execute()` 命令，将数据与 `sql` 语句结合并插入我们的新数据记录。
- en: We then grab the unique ID for the new data row with `$db->lastInsertId()` and
    add it to our data array so we can pass it back to the Sencha Touch application.
    We do this with our `doJson()` function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `$db->lastInsertId()` 获取新数据行的唯一 ID，并将其添加到我们的数据数组中，这样我们就可以通过 `doJson()`
    函数将其传递回 Sencha Touch 应用程序。我们就是这样做的。
- en: Our `PUT` request follows a very similar format.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PUT` 请求遵循一个非常相似的格式。
- en: The PUT request
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT 请求
- en: The `PUT` request is executed when we save an object in Sencha Touch that has
    a valid `id` property, in this case, an `itemID` value. When Sencha Touch sends
    a `save` request for this type of pre-existing object, it uses the `PUT` request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Our API function `doPut()` does the same basic thing as our `doPost()` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since we already have the unique `itemID` we don't need to grab it from the
    database after we update the row. Other than that, the basic structure is the
    same. We simply type an `update` command instead of `insert` in MySQL.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE request
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `DELETE` request is sent when we call `erase()` on our model record in Sencha
    Touch. In this case, our API only cares about the unique `itemID`, so we don't
    need to create a new array to use with our `execute()` statement. We still use
    `getJsonPayload()` to grab the data and after we execute, we echo the JSON encoded
    data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Back on the Sencha Touch side of things, you will need to reload the store in
    order to see the record removed from the list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the API
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Category side of the API works in exactly the same way as the Item part
    we just covered. You can look things over in the sample code for this chapter,
    but the logic is all the same. There is a `switch` statement at the top, which
    determines how the request was received. We then have the same basic functions
    set to respond to each type of request.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: This simple repeatable structure can be used to generate a basic API for use
    with any application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need additional functionality in your API beyond the basic CRUD functions
    you can also use AJAX stores to send requests to an API file, where it can be
    processed appropriately. The API would need to perform the same basic functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Determine the type of request either from the variables that are sent or the
    type of request being made
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the request through the database
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode the necessary request into JSON and send it back to the Sencha Touch
    application
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message should also be sent in the event of failure to help with debugging
    or offer the user some information to help fix the problem
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we used a simple catalog application in order to build our
    own API. In addition we covered:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: How to set up Sencha Model associations
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tricks using `.htaccess` and `mod_rewrite` to make prettier URLs for our API
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Ext.data.proxy.Rest` to communicate with an API via basic CRUD interactions
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will use the data from several third party APIs to enhance
    our application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
