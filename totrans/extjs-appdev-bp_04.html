<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Sencha Cmd"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Sencha Cmd</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Application Structure">Chapter 3</a>, <span class="emphasis"><em>Application Structure</em></span>, we described the nature of an Ext JS application as, essentially, a collection of HTML, JavaScript, and CSS. Just a web page. However, taking this point of view not only oversimplifies the issue, but it also means that your application won't reach its full potential; you'll be ignoring things like dependency management, code optimization, and many other matters that a high-quality application should incorporate.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Remember that application architecture, just like building architecture, isn't just about piecing together parts of a whole. It's about brick-and-mortar, the materials used in construction, and the methodology used to construct the final product.</p></div></div><p>Sencha Cmd can be<a id="id115" class="indexterm"/> an important part of architecting your project. It gives you a strong foundation, a smooth workflow, and a polished final product. In this chapter, we'll look at:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What Sencha Cmd actually is</li><li class="listitem" style="list-style-type: disc">Why Sencha Cmd is important in your development process</li><li class="listitem" style="list-style-type: disc">The way in which it helps you build an initial application template and then assists with adding new pieces of functionality</li><li class="listitem" style="list-style-type: disc">How it provides useful tools for the ongoing development process</li><li class="listitem" style="list-style-type: disc">The deployment process—producing optimized builds for various platforms and customizing the build process for more specific requirements</li></ul></div><p>At the end of the chapter, you will understand how and why an application built with Sencha Cmd is significantly easier to develop and deploy. You'll have a strong understanding of the various parts of Sencha Cmd and how to configure and augment it to fit your requirements.</p><div class="section" title="What is Sencha Cmd?"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>What is Sencha Cmd?</h1></div></div></div><p>In short, Sencha Cmd is an executable that provides a series of further commands to assist with your Sencha application development. Under the hood, it comprises a number of third-party utilities and <a id="id116" class="indexterm"/>scripts that combine to provide this functionality. Here are a few of the things it bundles in its installation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PhantomJS</strong></span>: This is used to<a id="id117" class="indexterm"/> manipulate web pages without using a browser interface</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>VCDIFF</strong></span>: This is a tool to<a id="id118" class="indexterm"/> work out the differences between a set of files</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Closure Compiler</strong></span>: This is a tool to<a id="id119" class="indexterm"/> optimize and minify the JavaScript code</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Jetty</strong></span>: This is a tool that provides <a id="id120" class="indexterm"/>a simple HTTP server</li></ul></div><p>All of this is tied together with some custom glue from Sencha, supported by Apache Ant—a build tool commonly used in the Java world.</p><p>The result is a complex yet powerfully customizable tool. The use of Ant allows almost all of the features of Sencha Cmd to be tweaked and extended, while Sencha's additions provide a straightforward command-line interface to this power.</p><p>For the application architect, Sencha Cmd provides a centralized workflow for your developers and a reproducible build process. It can speed up development time and provides a way to add customer- or business-specific deployment tasks to your team's toolset.</p></div></div>
<div class="section" title="Why is it important?"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Why is it important?</h1></div></div></div><p>While Ext JS was <a id="id121" class="indexterm"/>developed under the assumption that its users will most likely work with Sencha Cmd too, there's no hard and fast rule that dictates that it must be used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>We're not going to cover the installation of Sencha Cmd here. The latest installer is available on the<a id="id122" class="indexterm"/> Sencha website (<a class="ulink" href="http://www.sencha.com/">http://www.sencha.com/</a>) and should be a straightforward process.</p></div></div><p>In the next few pages, we'll create a small application without using Sencha Cmd and examine a couple of sticking points we'll hit on the way.</p><div class="section" title="The act of creation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>The act of creation</h2></div></div></div><p>One of these sticking points comes up straightaway. With Sencha Cmd, creating a new application is<a id="id123" class="indexterm"/> as easy as the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha -sdk ~/&lt;path-to-ext-sdk&gt; generate app MyApp ./my-app</strong></span>
</pre></div><p>Within seconds, Sencha Cmd creates a new directory called <code class="literal">my-app</code> containing the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The specified Ext JS SDK</li><li class="listitem" style="list-style-type: disc">An app directory containing model, controller, store, and view directories</li><li class="listitem" style="list-style-type: disc">The <code class="literal">app.js</code>, <code class="literal">app.json</code>, and <code class="literal">Application.js</code> files</li><li class="listitem" style="list-style-type: disc">The <code class="literal">index.html</code> file</li><li class="listitem" style="list-style-type: disc">The Bootstrap files</li><li class="listitem" style="list-style-type: disc">A sass directory with configuration files</li><li class="listitem" style="list-style-type: disc">The <code class="literal">.sencha</code> directory and a <code class="literal">build.xml</code></li></ul></div><p>Now, much of this is part of the Sencha Cmd support infrastructure that we can discard. We're going to have to manually create a lot of the preceding detailed items. Let's get started.</p><p>Let's create the application directory and copy the Ext JS SDK in here:</p><div class="mediaobject"><img src="graphics/5308OT_04_01.jpg" alt="The act of creation"/><div class="caption"><p>Bare-bones application directory</p></div></div><p>Next up is the <code class="literal">index.html</code> page. We can create a standard HTML5 page and need to hook up the JavaScript and HTML for Ext JS. In an application generated by Sencha Cmd, we'd have the Bootstrap files to help us here. They go through your application's dependency tree and autoload files accordingly. Without  Sencha Cmd, we have to include these files manually. So, we end up with the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;NoCMD&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="ext/build/packages/ext-theme-neptune/build/resources/ext-theme-neptune-all.css"&gt;
    &lt;script type="text/javascript" src="ext/build/ext-all.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="ext/build/packages/ext-theme-neptune/build/ext-theme-neptune.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="Application.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</pre></div><p>We can now begin<a id="id124" class="indexterm"/> to build our application, starting with a small "Hello World" that displays a message box:</p><div class="informalexample"><pre class="programlisting">// Application.js
Ext.application({
    name: 'NoCMD',
    launch: function() {
        Ext.Msg.alert('Welcome', 'To our Command-free application!');
    }
});</pre></div><p>Next step is to turn this into an MVVM application. Once we've built the directory structure by adding <code class="literal">app</code>, <code class="literal">app/model</code>, <code class="literal">app/store</code>, and <code class="literal">app/view</code>, we can add our first view. Remember that everything we've done so far would have been created with a single call to Sencha Cmd.</p><p>Here's the code for our view classes; the view model comes first:</p><div class="informalexample"><pre class="programlisting">Ext.define('NoCMD.view.main.MainModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.main',
    data: {
        introText: 'Welcome to the Command-free MVVM application!',
        buttonText: 'Click Me!'
    }
});</pre></div><p>This is entirely standard and is followed by the view itself:</p><div class="informalexample"><pre class="programlisting">Ext.define('NoCMD.view.main.Main', {
    extend: 'Ext.Panel',
    requires: ['NoCMD.view.main.MainModel', 'NoCMD.view.main.MainController'],
    viewModel: 'main',
    controller: 'main',
    items: [
        { xtype: 'component', bind: { html: '{introText}' } },
        { xtype: 'button', bind: { text: '{buttonText}', handler: 'onClickButton' } }
    ]
});</pre></div><p>Note that in<a id="id125" class="indexterm"/> comparison with our previous apps, we have to explicitly require the view model and view controller. We'll come back to this in a moment. Finally, here's the view controller:</p><div class="informalexample"><pre class="programlisting">Ext.define('NoCMD.view.main.MainController', {
    extend: 'Ext.app.ViewController',

    requires: [
        'Ext.MessageBox'
    ],

    alias: 'controller.main',

    onClickButton: function () {
        Ext.Msg.alert('Confirm', 'Are you sure?');
    }
});</pre></div><p>Let's go back to the <code class="literal">requires</code> option. When working with Sencha Cmd, the <code class="literal">viewModel</code> and controller configuration options are parsed as auto-dependencies. When we run the meta-command (or another command such as build that calls the meta-command), it compiles your code and produces Bootstrap files that tell Ext JS how to load your application.</p><p>Without Sencha Cmd, we have no autodependencies, so they must be specified explicitly with the <code class="literal">requires</code> option. That's another couple of lines of code that we could have avoided.</p><p>Not to mention the fact that all of these view-related files could have been generated with just one command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate view main.Main</strong></span>
</pre></div><p>We're already seeing how setting up our application and adding new features is simplified with Sencha Cmd. Let's look briefly at the other end of the process: deployment.</p><p>We want to ensure that our users have a production build as slim as possible to minimize download times. With Sencha Cmd, we can use the <code class="literal">build</code> command to create a set of files for deployment that<a id="id126" class="indexterm"/> meet our requirements. Sencha Cmd will parse our JavaScript files and metadata and create a minimized JS file that only contains the classes we're actually using in our application. It does this by examining the requirements that each class has and building a tree of dependencies that can be combined into a single download.</p><p>Without Sencha Cmd, where are we? Here are the steps we'll need to take on each production build:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make a list of all the files used by our application (including those in the Ext JS framework itself).</li><li class="listitem">Combine them together and then minimize them. Replace the JavaScript files we reference in <code class="literal">index.html</code> with this new file.</li></ol></div><p>Remember, this is only for JavaScript! Sencha Cmd can perform a similar process for CSS and compile the application's Sass files into a single download.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Ext JS uses <code class="literal">Ext.Loader</code>, a<a id="id127" class="indexterm"/> class that ensures the classes you require are loaded, and if not, requests the relevant files using Ajax and parses them—all on the fly. It also means that a file could be loaded from anywhere in your code that requires it—there's no single point of reference.</p></div></div><p>In truth, the nature of an Ext JS application is such that performing this kind of production optimization becomes a lengthy process and is prone to errors. In the rest of this chapter, we'll show how your builds and the rest of your workflow will become quicker, easily reproducible, and result in a higher-quality end product.</p></div></div>
<div class="section" title="Setting up your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Setting up your application</h1></div></div></div><p>Sencha Cmd supports an advanced concept described as workspaces. In complex projects, there may<a id="id128" class="indexterm"/> be the need for multiple pages or sections, in essence, applications within the larger app. Workspaces allow you to share common code (such<a id="id129" class="indexterm"/> as session management, custom UI components, and helper classes across these various subapplications). It also avoids the need to duplicate framework code (that is, the Ext JS source) across the subapps.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The Sencha Cmd<a id="id130" class="indexterm"/> documentation has detailed documentation on workspaces at <a class="ulink" href="http://docs.sencha.com/cmd/5.x/workspaces.html">http://docs.sencha.com/cmd/5.x/workspaces.html</a>.</p></div></div><p>Generating a workspace can be done with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate workspace ./my-workspace</strong></span>
</pre></div><p>This simply adds some configuration files for the workspace. The extra magic comes when you generate an application for this workspace:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha -sdk ~/&lt;path-to-sdk&gt;/ext generate app MyApp ./my-workspace/my-app</strong></span>
</pre></div><p>The key difference here is that the SDK will be held at the workspace root rather than the application root. So, the subapplications will all use the same SDK.</p><p>Alternatively, you can use Sencha Cmd to generate just an application, which we've already touched on:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha -sdk ~/&lt;path-to-sdk&gt;/ext generate app MyApp ./my-app</strong></span>
</pre></div><p>This will build on the standard application template we've used many times before.</p><p>While workspaces are a useful method to organize your code and promote code reuse, we're going to focus on single applications for the rest of the book. All the ideas we're discussing can be implemented on an application level without the distraction of a workspace.</p></div>
<div class="section" title="The generation game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>The generation game</h1></div></div></div><p>From here, we can quickly build<a id="id131" class="indexterm"/> out the skeleton of our application. The key MVVM classes are controllers, models, and views (with their associated view controllers and view models). Sencha Cmd can assist with quickly creating all of these classes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The generation of code using <a id="id132" class="indexterm"/>a command-line tool is often known as "scaffolding" and was popularized by Ruby On Rails. For more on the subject, refer<a id="id133" class="indexterm"/> to <a class="ulink" href="http://en.wikipedia.org/wiki/Scaffold_(programming)">http://en.wikipedia.org/wiki/Scaffold_(programming)</a>.</p></div></div><p>For controllers, it's simple:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate controller MyController</strong></span>
</pre></div><p>The preceding command produces:</p><div class="informalexample"><pre class="programlisting">// app/controller/MyController.js
Ext.define('MyApp.controller.MyController', {
    extend: 'Ext.app.Controller'
});</pre></div><p>Then, the model generator invoked looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate model MyModel fullName:string,age:int</strong></span>
</pre></div><p>
<code class="literal">MyModel</code> is the <a id="id134" class="indexterm"/>name of the model straightforward. The next parameters allow generation of fields in the model (provided as a comma-separated list of <code class="literal">name:type</code> field pairs). In this case, we're creating two fields: <code class="literal">fullName</code> of type string and <code class="literal">age</code> of type integer. This gives us the following code:</p><div class="informalexample"><pre class="programlisting">// app/model/MyModel.js
Ext.define('MyApp.model.MyModel', {
    extend: 'Ext.data.Model',
    fields: [
        { name: 'name', type: 'string' },
        { name: 'age', type: 'int' }
    ]
});</pre></div><p>Finally, there's the following view generator:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate view my.MyView</strong></span>
</pre></div><p>This creates a few files for us, as shown here:</p><div class="informalexample"><pre class="programlisting">// app/view/my/MyView.js
Ext.define("MyApp.view.my.MyView",{
    "extend": "Ext.panel.Panel",
    "controller": "my-myview",
    "viewModel": {
        "type": "my-myview"
    },
    "html": "Hello, World!!"
});

// app/view/my/MyViewController.js
Ext.define(MyApp.view.my.MyViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.my-myview'
});

// app/view/my/MyViewController.js
Ext.define('MyApp.view.my.MyViewModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.my-myview',
    data: {
        name: 'MyApp'
    }
});</pre></div><p>With this <a id="id135" class="indexterm"/>command, as we're creating multiple files, we have the opportunity to create a directory and corresponding namespace to contain them. In this case, we created the <code class="literal">my</code> directory at <code class="literal">app/view/my</code> for these three files.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Pay attention to the case of names of your models, views, and controllers here. Sencha Cmd doesn't do anything special to correct the case to keep with expected naming conventions. So, whatever you type will be directly carried over to the class.</p></div></div><p>There are two more commands we can run with generate: <code class="literal">theme</code> and <code class="literal">package</code>, but we'll cover these in more detail later in <a class="link" href="ch09.html" title="Chapter 9. A Shopping Application">Chapter 9</a>, <span class="emphasis"><em>A Shopping Application</em></span>, when we build a packaged component with a custom theme.</p></div>
<div class="section" title="Develop in style"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Develop in style</h1></div></div></div><p>Now that we're <a id="id136" class="indexterm"/>up and running with a Sencha Cmd-powered application, we can start to look at the ways Sencha <a id="id137" class="indexterm"/>Cmd can ease our ongoing development process. These range from generating application metadata to compiling theme files.</p><div class="section" title="Here to serve – a website"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Here to serve – a website</h2></div></div></div><p>A standard HTML web page can be run directly from your computer without requiring a web server. The browser just reads<a id="id138" class="indexterm"/> the files directly from your local drive. With the increasing popularity of JavaScript-based web applications, browsers have introduced a variety of security restrictions to prevent malicious sites from reading your local filesystem.</p><p>This causes issues with Ext JS because when developing, <code class="literal">Ext.Loader</code> will dynamically load and parse the JavaScript files your application depends on from your application directory.</p><p>The best way to solve this issue is to simply run your code through a web server as the browser normally expects. Fortunately, to avoid having to configure a full-blown web server on your development machine, Sencha Cmd gives you a simple way of starting up a lightweight server in the current directory. Simply run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha web start</strong></span>
</pre></div><p>You should get an output along these lines:</p><div class="mediaobject"><img src="graphics/5308OT_04_02.jpg" alt="Here to serve – a website"/></div><p>And sure enough, visit <code class="literal">http://localhost:1841</code> in your web browser and your application will be ready and waiting:</p><div class="mediaobject"><img src="graphics/5308OT_04_03.jpg" alt="Here to serve – a website"/></div><p>Note that we can <a id="id139" class="indexterm"/>override the port the server uses. In order to start it on port <code class="literal">1999</code>, we will issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha web -port 1999 start</strong></span>
</pre></div></div><div class="section" title="The Bootstrap process"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>The Bootstrap process</h2></div></div></div><p>Sencha Cmd's JavaScript compiler isn't just a way of concatenating and minifying. It understands your code<a id="id140" class="indexterm"/> and will process certain parts in order to simplify dependency management.</p><p>For example, a wildcard <code class="literal">requires</code> option such as <code class="literal">Ext.grid.*</code> will be expanded so that all of the files and classes under <code class="literal">Ext.grid</code> will be included. Certain configuration options, such as controller or ViewModel, will be converted into their full class reference. This is the Bootstrap process—the way in which dependency information is converted into a list of actual files to be loaded.</p><p>This metadata trickery comes with a small price. In certain situations, you need to refresh the Bootstrap data in order for Ext JS to load your application successfully. One way of doing this is to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha app refresh</strong></span>
</pre></div><p>This will quickly rebuild the files needed to Bootstrap your app. However, we can go one step further and kill two birds with one stone by running a development web server that refreshes the app when needed. It's as simple as running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha app watch</strong></span>
</pre></div><p>With this, we have the same web server functionality as web start combined with a process that watches for metadata changes and alterations to Sass files. It will automatically rebuild<a id="id141" class="indexterm"/> Bootstrap data and CSS when it detects a change.</p></div></div>
<div class="section" title="Care for the environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Care for the environment</h1></div></div></div><p>Sencha Cmd supports the concept of environments to allow different behavior depending on the stage of your workflow. We've already mentioned that Sencha Cmd leverages the power of the Ant build system to allow<a id="id142" class="indexterm"/> customization of the process. The different environments simply define variables that are consumed by Ant and passed into the build process to enable, disable, or amend a part of the build.</p><p>You can see the default build variables by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha ant .props</strong></span>
</pre></div><p>This produces something that includes the following code along with a million and one other variables:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INF] [echoproperties] app.output.js=app.js</strong></span>
<span class="strong"><strong>[INF] [echoproperties] app.output.js.compress=false</strong></span>
<span class="strong"><strong>[INF] [echoproperties] app.output.js.enable=true</strong></span>
<span class="strong"><strong>[INF] [echoproperties] app.output.js.optimize=false</strong></span>
</pre></div><p>Here the variable <code class="literal">app.output.js</code> has the value <code class="literal">app.js</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Note that build variables and configuration variables are two separate things. Configuration variables are used by Sencha Cmd as a whole, not just the build process. We'll only be discussing configuration variables, as they're most commonly used and provide the most "bang for your buck". We just don't have space to cover every variable.</p></div></div><p>We're going to take a closer look at environments now. They are used with the <code class="literal">app build</code> subcommand and give us a lot of power to customize our code for production.</p><div class="section" title="The final product"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>The final product</h2></div></div></div><p>When creating a <a id="id143" class="indexterm"/>production build, we want to make our code as lean as possible, removing logging, debugging, and making sure that we compress JavaScript and CSS and use all optimizations available. Let's look at the overrides for the product environment:</p><div class="informalexample"><pre class="programlisting">// Defined in .sencha/app/production.defaults.properties
build.options.logger=no
build.options.debug=false
build.compression.yui=1
build.optimize=true
enable.cache.manifest=true
enable.resource.compression=true
build.embedded.microloader.compressor=-closure</pre></div><p>Let's look at each option in turn, ignoring<a id="id144" class="indexterm"/> the comment on the first line:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Disable Ext JS framework logging.</li><li class="listitem">Tell the compiler to remove code designated as debug code.</li><li class="listitem">Use the YUI Compressor to minify the JavaScript code.</li><li class="listitem">Enable custom optimizations (such as removing the <code class="literal">requires</code> option) that are no longer needed when the dependency tree is already known. This can result in a slightly smaller code base.</li><li class="listitem">Generate an HTML cache manifest file. This instructs the browser to cache the application's <code class="literal">index.html</code> file to reduce network activity.</li><li class="listitem">Compress the CSS files and other resources.</li><li class="listitem">Compress the "microloader" JavaScript that boots our application.</li></ol></div><p>Along with the huge range of other configuration options, we have a mechanism to tailor our final build to suit our needs. For tracking production issues, you may wish to enable logging to the browser console, so you can toggle this option.</p><p>You could even create a custom environment that skips parts of the build for a quicker process. It's worth poring through the output that <code class="literal">sencha ant .props</code> creates in order to see where you can tailor the process for the needs of your team.</p></div></div>
<div class="section" title="Before the build"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Before the build</h1></div></div></div><p>Back in <a class="link" href="ch03.html" title="Chapter 3. Application Structure">Chapter 3</a>, <span class="emphasis"><em>Application Structure</em></span>, we touched on the <code class="literal">build.xml</code> file that Sencha Cmd generates as part of an<a id="id145" class="indexterm"/> application template. Now, we'll take a closer look to see how we can use this file to hook into the build process and leverage it for our own purposes.</p><p>We've already mentioned that Sencha Cmd uses Ant, an XML-based build system at its core. A key concept of Ant is that of "targets", a term that describes a bundle of tasks that perform a part of the build process from the Ant manual:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A target is a container of tasks that cooperate to reach a desired state during the build process."</em></span></p></blockquote></div><p>In our case, Sencha Cmd comes with a set of pre-existing targets that we can use to hook into various parts of the build process. The <code class="literal">build.xml</code> file contains stubs for these targets as well as some comments on what they do. We're going to hook into one of these and implement a task that will halt the build process if certain conditions are not met.</p><p>When we discussed the role of the architect, we speculated that there may be a requirement to<a id="id146" class="indexterm"/> enforce coding standards on the development team. We can use automated tools to make sure that best practice is used in a code base. Here, we'll use JSHint: a JavaScript code quality tool.</p><p>Ant is widely used and, as such, has many community-created additions. For JSHint, developer Phil Mander has created<a id="id147" class="indexterm"/> a task to use it in an Ant target. For more information, refer to <a class="ulink" href="https://github.com/philmander/ant-jshint">https://github.com/philmander/ant-jshint</a>.</p><p>To begin with, we need to<a id="id148" class="indexterm"/> download the Java JAR containing the new task at <a class="ulink" href="http://git.io/VSZvRQ">http://git.io/VSZvRQ</a>.</p><p>I simply placed it in the application root along with the <code class="literal">build.xml</code> file, but if you've got a lot of extra tasks, it's definitely worth creating a new directory.</p><p>We can now configure our <code class="literal">build.xml</code> file to use this new task as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;project name="MyApp" default=".help"&gt;

    &lt;import file="${basedir}/.sencha/app/build-impl.xml"/&gt;

    &lt;!-- Expose the new task using the ant-jshint jar file --&gt;
    &lt;taskdef name="jshint" classname="com.philmander.jshint.JsHintAntTask" 
        classpath="${basedir}/ant-jshint-0.3.6-SNAPSHOT-deps.jar" /&gt;

    &lt;!-- Hook into the before-init target --&gt;
    &lt;target name="-before-init"&gt;
        &lt;!-- JSHint is now fully exposed via XML --&gt;
        &lt;jshint dir="${basedir}/app" includes="**/*.js" globals="Ext:true" options="strict=false"&gt;
            &lt;!-- Output a report to a file called jshint.out --&gt;
            &lt;report type="plain" destFile="${basedir}/jshint.out" /&gt;
        &lt;/jshint&gt;
    &lt;/target&gt;
&lt;/project&gt;</pre></div><p>There are several steps to hook up this new task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add a <code class="literal">taskdef</code> element to make Ant aware of the <code class="literal">ant-jshint</code> task</li><li class="listitem" style="list-style-type: disc">Add the target element with a name <code class="literal">–before-build</code></li><li class="listitem" style="list-style-type: disc">Add a <code class="literal">jshint</code> element configured as per the documentation on GitHub</li></ul></div><p>There's only one really special thing to note about the way we've configured the JSHint task and that's the need to<a id="id149" class="indexterm"/> add Ext to the <code class="literal">globals</code> setting. As <code class="literal">ant-jshint</code> hasn't been told where the Ext JS framework is, we tell it to assume that a global variable called Ext is defined elsewhere.</p><p>We can now run <code class="literal">sencha app build</code> again and JSHint will parse through our code and check it against its rule set. If our code doesn't pass, the whole build will fail and a file called <code class="literal">jshint.out</code> will be created in the root of our application and will show the details of any JSHint errors and the lines on which they occurred.</p><p>With only ten minutes work, we've already created a low-friction method of ensuring buggy or low-quality code is less likely to reach production.</p><p>This is just one example of a prebuild check. You could also:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Run a test suite</li><li class="listitem" style="list-style-type: disc">Run code-complexity checks</li></ul></div><p>By preventing a build from being created if these checks don't pass, you're enforcing a standard way of working across the board and forcing developers to check all of the little things that go towards creating a quality product.</p></div>
<div class="section" title="Code complete"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Code complete</h1></div></div></div><p>Once our quality checks have passed, we want to look at deploying the application. Again, we have an <a id="id150" class="indexterm"/>opportunity to codify some practices to make sure your team performs the same actions time and time again.</p><p>Let's set out a typical process that represents a deployment to production:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Quality checks such as tests and coding standards.</li><li class="listitem">Minification and other optimization.</li><li class="listitem">Bump the application version number.</li><li class="listitem">Push to production server.</li></ol></div><p>Number one was taken care of by our <code class="literal">before-init</code> step. Minification and optimization is taken care of by Sencha Cmd's build-in tasks. We're left with three tasks that we'd like to complete before <a id="id151" class="indexterm"/>pushing to production, so we'll look at them in turn, but first, let's have a brief interlude and talk about Ant.</p><div class="section" title="An application for Ant"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>An application for Ant</h2></div></div></div><p>In effect, the next few pages are a tutorial for <a id="id152" class="indexterm"/>Ant, rather than Sencha Cmd or application architecture. There are many, many resources for Ant online and in print form, so why go over old ground?</p><p>Remember that this book isn't a list of facts and figures or code listings to type in line by line. It's supposed to get the brain thinking about the application from a top-down perspective and see how you can help your team build a strong product for your client.</p><p>An architect isn't just there to draw pictures of the house. They are there to make sure a beautiful house is built and the homeowner walks away happy.</p></div><div class="section" title="Version numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Version numbers</h2></div></div></div><p>Back to Ant. There are multiple reasons why you want to label an application with a build or version <a id="id153" class="indexterm"/>number—a key one is to let stakeholders know the version they're reviewing to see whether it contains the bug fixes they'd expect.</p><p>Versioning the application is a two-step process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate a new build number.</li><li class="listitem">Insert it in a JavaScript file for display on the UI.</li></ol></div><p>Ant provides a task to make step one fairly simple:</p><div class="informalexample"><pre class="programlisting">&lt;propertyfile  file="app.properties"&gt;
            &lt;entry key="build.number" type="int" operation="+" value="1"/&gt;
&lt;/propertyfile&gt;</pre></div><p>We use the <code class="literal">propertyfile</code> task to specify that a file called <code class="literal">app.properties</code> will contain an entry called <code class="literal">build.number</code>. Every time we run the task, it triggers an operation to increment <code class="literal">thisentry</code> by one as follows:</p><div class="informalexample"><pre class="programlisting">&lt;property file="app.properties"/&gt;
&lt;replace file="${build.classes.file}" token="{VERSION}" value="${build.number}"/&gt;</pre></div><p>Next, we read the <code class="literal">app.properties</code> file to understand how to use the property task, which makes<a id="id154" class="indexterm"/> the properties it contains available to further tasks.</p><p>Finally, we do a search and replace in the generated JS for a <code class="literal">{VERSION}</code> token and replace it with the <code class="literal">build.number</code> property. Let's see it as a full <code class="literal">build.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;project name="MyApp" default=".help"&gt;

    &lt;import file="${basedir}/.sencha/app/build-impl.xml"/&gt;
    
    &lt;target name="-after-page"&gt;
        &lt;propertyfile  file="app.properties"&gt;
            &lt;entry key="build.number" type="int" operation="+" value="1"/&gt;
        &lt;/propertyfile&gt;

        &lt;property file="app.properties"/&gt;
        &lt;replace file="${build.classes.file}" token="{VERSION}" value="${build.number}"/&gt;
    &lt;/target&gt;
&lt;/project&gt;</pre></div><p>Note that we're using the <code class="literal">after-page</code> target as a hook. This fires after Sencha Cmd has assembled all of the application's dependencies and created a single file to contain them. This is the file we do our search and replace on, which means that our original source files remain intact. You could have a JavaScript file such as this:</p><div class="informalexample"><pre class="programlisting">// app/Application.js
Ext.define('MyApp.Application', {
    extend: 'Ext.app.Application',
    name: MyApp',
    version: '{VERSION}'
});</pre></div><p>Also, the <code class="literal">{VERSION}</code> token would be replaced, enabling you to use the version number across your application, perhaps in a footer or an <span class="strong"><strong>About</strong></span> screen.</p></div><div class="section" title="From release to production"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>From release to production</h2></div></div></div><p>Our code is neat and tidy, we know what version we're releasing. The next step is to push it to a production server. We'll use<a id="id155" class="indexterm"/> SFTP to transfer files to a remote server:</p><div class="informalexample"><pre class="programlisting">&lt;target name="-after-build"&gt;
    &lt;input
        message="Please enter SFTP username:"
        addproperty="scp.user" /&gt;
    &lt;input
        message="Please enter SFTP password:"
        addproperty="scp.password" /&gt;
    &lt;scp remoteTodir="${scp.user}@sftp.mysite.com:/path/to/myapp/dir" password="${scp.password}"&gt;
        &lt;fileset dir="build/production"/&gt;
    &lt;/scp&gt;
&lt;/target&gt;</pre></div><p>We use the <code class="literal">afterbuild</code> target, which means that all other aspects of the build are complete and the final production files have been built. As it's a really bad idea to hardcode security credentials, we use the input task to request input from the user on the command line. The resulting input gets assigned to the property specified in <code class="literal">addproperty</code>.</p><p>The <code class="literal">scp</code> task's <code class="literal">remoteToDir</code> attribute should be customized according to your needs, but the <code class="literal">scp.username</code> and <code class="literal">scp.password</code> values will be filled with the previous user input. In the <code class="literal">fileset</code> task, we specify that the whole <code class="literal">build/production</code> directory will be pushed up to the remote server.</p><p>We've shown how we can leverage the power of Ant to hook into key aspects of the Sencha Cmd build process, converting error-prone manual tasks to automated ones that can be easily shared with your development team.</p></div></div>
<div class="section" title="The best of the rest"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>The best of the rest</h1></div></div></div><p>We've barely touched the surface of what Sencha Cmd can do. We're looking at Sencha Cmd from the perspective of a highly interested architect, but an architect needs a strong awareness of the full stack of tools available to their developers. Let's do a whistle-stop tour of some of the features that Ext JS developers can use to ease their work on the details of an application.</p><div class="section" title="Packages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Packages</h2></div></div></div><p>Packages are a way of reusing code between projects. Sencha Cmd and Ext JS recognize packages as fleshed <a id="id156" class="indexterm"/>out concepts in the Sencha ecosystem, so developers should be aware that they're available for use. The workspace concept, which we discussed earlier, assists with development of packages, but they can be consumed at the application level, providing a tidy bundle of CSS, JavaScript, and other resources for an app to consume from a local or remote source.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The Sencha documentation at <a class="ulink" href="http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html">http://docs.sencha.com/cmd/5.x/cmd_packages/cmd_creating_packages.html</a> provides instructions <a id="id157" class="indexterm"/>on creating packages.</p></div></div><p>At an enterprise level, packages are a key method to provide reusable logic and user interface elements that can be shared between teams. Code reuse is something that needs to be considered <a id="id158" class="indexterm"/>at an architectural level to avoid reinventing the wheel, so packages can be an important tool when looking at the bigger picture.</p></div><div class="section" title="Themes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Themes</h2></div></div></div><p>There are two approaches to working with CSS and images in Ext JS: first there's the full-blown theme <a id="id159" class="indexterm"/>option in which you create a package of images, Sass files, and JavaScript customization to build an entirely bespoke look and feel for your application. In many cases, some minor tweaks to the standard Ext JS components combined with some extra styles for your own UI elements are all that are needed. In this case, Sencha Cmd provides <code class="literal">sencha compass compile</code> to transform Sass files into CSS that is included in your app. Don't forget that <code class="literal">sencha app watch</code> also takes care of this step automatically.</p></div><div class="section" title="Compilations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Compilations</h2></div></div></div><p>Command's build process relies on a subcommand called compile, which is responsible for parsing the files that <a id="id160" class="indexterm"/>make up your application. This subcommand can be invoked independently and could be used to create a list of application dependencies that could be further processed by tools other than Sencha Cmd.</p><p>In the greater JavaScript ecosystem, there are a growing number of build tools (such as Grunt and Gulp) that your developers may be more familiar with. By using a small portion of Sencha Cmd's features, your team could continue to leverage these tools while working with the Ext JS framework.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Summary</h1></div></div></div><p>Standards and process are key responsibilities of a software architect and Sencha Cmd is an indispensable tool to help fulfill these responsibilities. We saw how it can touch all parts of the application lifecycle, from quickly getting up and running with a template to bolting on segments of a developing code base, to creating a final optimized product.</p><p>More than this, the various hooks with Sencha Cmd provides flexibility. It works with you and your team to help ease the development process and save time that would otherwise be wasted with manual tasks.</p><p>In the next few chapters, we'll look at how we can piece together everything we've learned so far about Ext JS application architecture and use some practical examples to further demonstrate how to build fantastic products for your clients.</p></div></body></html>