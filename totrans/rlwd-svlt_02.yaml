- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Styling and Theming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without styling, an `h1` element within a component will look the same as another
    `h1` element from another component. Svelte allows you to use **Cascading Style
    Sheets** (**CSS**), a language used for styling and formatting web content, to
    style your elements, giving them a different look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by talking about different ways to style a Svelte
    component. We will then see some examples, including integrating a popular CSS
    framework, **Tailwind CSS**, into Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we will talk about themes. When you have a set of styles consistently
    applied throughout Svelte components, you’ll see an overall styling theme in your
    components. We will talk about how to synchronize the styles across components,
    as well as how to let users of the components customize them.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have learned various methods of styling
    and will be comfortable in choosing the right approach and applying the right
    methods, depending on the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes sections on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ways to style a Svelte component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to style a Svelte component with Tailwind CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying themes to Svelte components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code used in this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Styling Svelte components in six different ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Svelte component, you have elements that define the structure and content.
    With styling, you can change the look and feel of the elements beyond the browser
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte components can be styled in six different ways. Let’s explore the different
    ways to apply a style to elements within a Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with the style attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you can add inline styles to an element with the `style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will turn the color of the text within `div` to blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `style` attribute in HTML elements, you can add multiple CSS
    styling declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of adding multiple CSS styling declarations in Svelte is the same
    as you would do in HTML. In the preceding snippet, we change the text within `div`
    to be blue in color and 2 rem in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `style` attribute is a string. You can form the `style` attribute
    with dynamic expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it gets messy when you have multiple CSS styling declarations within
    the `style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using style: directives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Svelte provides `style:` directives, which allow you to split the `style` attribute
    into several attributes, which is hopefully more readable after adding line breaks
    and indentations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `style:` directive follows the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS property name can be any CSS property, including CSS custom properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the name of the style matches the name of the value it depends on, then
    you can use the shorthand form of the `style:` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A style declared in the `style:` directive has higher priority than the `style`
    attribute. In the following example, the `h1` text color is red instead of blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Besides adding inline styles to style an element one by one, the next approach
    allows us to write CSS selectors to target multiple elements and style them together.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the <style> block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In each Svelte component, you can have one top-level `<``style>` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `<style>` block, you can have CSS rules, targeting elements within
    the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This approach is useful when you want to apply the same style across multiple
    elements within the component.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, would the CSS rule turn all the `div` elements in the
    document to blue?
  prefs: []
  type: TYPE_NORMAL
- en: No. The CSS rules within the `<style>` block are scoped to the component, meaning
    the CSS rules will only be applied to the elements within the component, and not
    `div` elsewhere in your application.
  prefs: []
  type: TYPE_NORMAL
- en: So you do not have to worry about the CSS rule inside the `<style>` block changing
    elements outside the component.
  prefs: []
  type: TYPE_NORMAL
- en: But, how does this work? How does Svelte make sure that the CSS rules only apply
    to the element within the same component?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore that.
  prefs: []
  type: TYPE_NORMAL
- en: How Svelte scopes CSS rules within a component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s digress for a bit to understand how Svelte makes sure that the CSS rules
    within a component are scoped.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Svelte compiles a component, the Svelte compiler goes through each CSS
    rule and attempts to match each element with the selector of the CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whenever an element matches the selector, the Svelte compiler will generate
    a CSS class name that is unique to the component and apply it to the element.
    At the same time, Svelte limits the scope of the elements being selected by the
    CSS rule by including a class selector of the generated class name in the selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transformation of the element and the CSS rule looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `"svelte-g5jdbb"` is the unique CSS class name that is generated by calculating
    the hash value of the CSS content. The hash value will be different when the CSS
    content changes. Since the Svelte compiler only applies the CSS class name to
    the elements within the component, it is unlikely that the style will be applied
    to other elements outside the component.
  prefs: []
  type: TYPE_NORMAL
- en: This transformation happens during compilation by default. There’s nothing additional
    that you need to do. The example here is more for illustration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that the CSS rules within the `<style>` block are scoped, when you want
    to apply styles to all of the elements of the same node name, using the CSS type
    selector for your CSS rule is sufficient most of the time. However, if you want
    to style only some of the elements, say only the second `div` element in the preceding
    example, you can add a `class` attribute to the second `div` element to differentiate
    between other `div` elements.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, adding a `class` attribute is our next way of styling our Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the class attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CSS class selector in CSS works the same way in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: When you add a `class` attribute to an element, you can target it using the
    CSS class selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we added the `highlight` class to the second `div`,
    and thus only the second `div` has a yellow background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `class` attribute can be a string or a dynamic expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can conditionally apply classes to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when the value of both `toHighlight` and `toBold`
    is `true`, the `class` attribute value evaluates to `"highlight bold"`. Thus,
    two classes, `highlight` and `bold`, are applied to the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of conditionally applying classes to an element based on a variable
    is so common that Svelte provides the `class:` directive to simplify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying the class attribute with the class: directive'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we conditionally applied the `highlight` class when
    the `toHighlight` variable was truthy, and `bold` when the `toBold` variable was
    truthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be simplified with the `class:` directive, where you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify the previous example with the `class:` directive, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `style:` attribute, you can further simplify to a `class:` directive
    shorthand if the name of the class is the same as the name of the variable for
    the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the condition for adding the `highlight` class is instead a variable named
    `highlight`, then the preceding example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting all of them together, in the following code example, the `div` element
    has a yellow background when the `highlight` variable is `true`, and a transparent
    background otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All the approaches of applying styles to an element that we’ve explored so far
    have the CSS declarations written within the Svelte component. However, it is
    possible to define styles outside of the Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: Applying styles from external CSS files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you add a style element to the HTML of your application, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could include external CSS files in the HTML of your application,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the CSS rules written in them are applied globally to all elements
    in the application, including elements within your Svelte component.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using build tools such as webpack, Rollup, or Vite to bundle your
    application, it is common to configure your build tools to import CSS files using
    the `import` statement, just like importing any JS files (some tools, such as
    Vite, even have been configured to allow importing CSS files such as any JS files
    by default!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Importing CSS Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Vite, when you name your CSS files ending with `.module.css`, the CSS file
    is considered a **CSS Modules** file. A CSS Module is a CSS file where all the
    class names defined within the file are locally scoped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This means that the CSS class names specified within a CSS Module will not conflict
    with any class names specified elsewhere, even with class names that have the
    same name.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the build tool will transform the class names within CSS Modules
    to something unique that is unlikely to have conflicts with any other names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how the CSS rules in the preceding CSS Modules
    would turn out after the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When importing a CSS Module from a JavaScript module, the CSS Module exports
    an object, containing the mapping of the original class name to the transformed
    class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the imported `styles` module is an object, and we
    can get the transformed class name, `'q3tu41d'`, through `styles.highlight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to use the transformed class name in your Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen six different ways of styling a Svelte component, but how do you
    choose when to use which one?
  prefs: []
  type: TYPE_NORMAL
- en: Choosing which method to style Svelte components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each method that we’ve seen so far has its pros and cons. Most of the time,
    choosing which method to style your Svelte component is up to personal preference
    and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of my personal preferences when choosing the method to style
    my Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '<style> block over inline styles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, I find that the style I am writing has less to do with the
    logic of showing the elements, and more with how the elements look. So, I find
    it clutters my flow of reading the component when having the styles in line along
    with the elements. I prefer to have all my styles in one place in the `<``style>`
    block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Controlling styles using the `style:` directive and the `class:` directive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the style property of an element is dependent on a variable, I would use
    the `style:` directive or the `class:` directive instead of the `style` attribute
    or the `class` attribute. I find this cleaner to read, as well as finding it a
    strong signal telling me that the style of the element is dynamic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When I am changing only one style property based on one variable, I would use
    the `style:` directive. However, when changing more than one style property with
    the same variable, I prefer declaring a CSS class to group all the styles together
    and controlling it via the `class:` directive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CSS Modules for reusing CSS declarations in multiple Svelte components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, there’s no built-in method in Svelte to share
    the same CSS declarations in multiple Svelte components. So, you might want to
    share the CSS declarations through CSS Modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, more often than not, when you need the same CSS declarations for elements
    across multiple Svelte components, you have a less-than-perfect component structure.
    It may be possible to abstract the elements out into a Svelte component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ve seen how we can define our own styles within and outside of a Svelte component;
    however, sometimes it’s much easier to adopt styles written by others, rather
    than designing our own styles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore using a popular CSS framework,
    Tailwind CSS, in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Svelte with Tailwind CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tailwind CSS is a utility-first CSS framework. It comes with predefined classes,
    such as `flex`, `pt-4`, and `text-center`, which you can use directly in your
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use Vite’s Svelte template as a base to set up Tailwind CSS.
    If you are not familiar with setting up Vite’s Svelte template, here are the quick
    steps to set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Vite setup tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Step into the `my-project-name` folder and install the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the dependencies are installed, you can start the development server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the Svelte project up and running, let’s look at what we need to do to
    set up Tailwind CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Tailwind CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tailwind CSS has come up with a `tailwindcss` CLI tool that has made the setup
    so much easier. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Tailwind CSS in a Svelte + Vite project, we first install the dependencies
    that are needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After `tailwindcss` is installed, run the command to generate `tailwind.config.js`
    and `postcss.config.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the location of where our Svelte components are in `tailwind.config.js`
    so that Tailwind CSS knows where to scan Svelte components for class names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `postcss.config.js` file keeps the configuration for PostCSS. The default
    configuration generated is good for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a CSS file in `./src/main.css` to add the Tailwind directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the newly created `./src/main.css` in the `./``src/main.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is similar to importing external CSS files, which we saw earlier on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Vite `dev` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You just created an `<h1>` element with two Tailwind CSS classes applied: `text-center`
    and `text-sky-400`. This will make the text in the `<h1>` element center-aligned
    and in a sky-blue color. As you use Tailwind CSS utility class names in your Svelte
    component, the style declarations for those classes are generated and replace
    the `@tailwind` `utilities` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tailwind CSS is able to extract class names from both the `class` attribute
    and the `class:` directive, allowing you to statically or conditionally apply
    the Tailwind CSS styles to the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Tailwind CSS comes with a lot of utility classes: you can learn more about
    Tailwind CSS at [https://tailwindcss.com/](https://tailwindcss.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Since Tailwind CSS classes are globally available, you can apply the same CSS
    classes to maintain the same look and feel across Svelte components within the
    same application. However, if you are doing so with your own style declarations,
    you may have to re-specify the same colors or dimensions in the style declarations
    across components to maintain the same look. Changing the value in the future
    would also be a problem, as we would have to search for usages by the value and
    update them.
  prefs: []
  type: TYPE_NORMAL
- en: CSS custom properties are a solution for this. They allow us to define a value
    in one place and then reference it in multiple other places. Let’s look at how
    we can use CSS custom properties in Svelte components.
  prefs: []
  type: TYPE_NORMAL
- en: Theming Svelte components with CSS custom properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a quick knowledge check on CSS custom properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define CSS custom properties like any other CSS properties, except that
    the name of the CSS custom property starts with two dashes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To reference the CSS custom property, use the `var()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'CSS custom properties cascade like any other CSS properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value of the `--text-color` CSS custom property for `<div>` elements is
    red, except for the `<div>` elements with a class named `foo`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The value of CSS custom properties is inherited from their parent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the value of `--text-color` for `<div>` in the preceding example is red,
    then without other CSS rules applied to `<span>`, the value of `--text-color`
    for `<span>` is also red.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Defining CSS custom properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify a set of dimensions and colors for the Svelte components, we can
    define them as CSS custom properties at the root component of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define the CSS custom property at the root element
    of the component, the `<div>` element. As a CSS custom property value inherits
    from a parent, the child elements and elements within the child components inherit
    the value from the `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: As we are defining the CSS custom property at the `<div>` element of the component,
    elements that are not the descendant of the `<div>` element will not be able to
    access the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead, you would like to define the variable for all elements, even elements
    that are not the descendant of the root element of our root component, you can
    define the CSS custom property at the root of the document using the `:``root`
    selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You do not need to use the `:global()` pseudo-selector for `:root`, as it will
    always refer to the root of the document, and never be scoped to the component.
  prefs: []
  type: TYPE_NORMAL
- en: The `:global()` pseudo-selector is used in CSS Modules to define styles that
    apply globally, outside the local module scope. In Svelte, when used within a
    component’s `<style>` block, it allows you to define CSS rules that won’t be scoped
    to the component, making them available and applicable to elements across the
    entire Svelte application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to defining the CSS custom properties in the `<style>` block,
    you can define them directly on the element itself through the `style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, doing so with the `style:` directive makes the code look
    tidier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference the value in the child component, you use the `var()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about using the CSS custom property is that we could dynamically
    change the value of the CSS custom property, and the element’s style referencing
    the CSS custom property will be updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can specify the value of `--text-color` of `<div>` to be `#222`
    or `#eee`, based on a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When the condition is `true`, the value of `var(--text-color)` is `#222`, and
    the value changes to `#eee` when the condition changes to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, CSS custom properties make it much easier to synchronize the
    style of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a real-world example of using CSS custom properties: creating
    a dark/light theme mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Example – implementing a dark/light theme mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dark mode is a color scheme where you have light-colored text on a dark-colored
    background. The idea behind dark mode is that it reduces the light coming from
    the screen while maintaining color contrast ratios so that the content is still
    readable. Less light coming from the device makes it more comfortable to read,
    especially in a low-light environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operating systems allow users to set their preference on whether to use
    a dark or light theme, and major browsers support a media query, `prefers-color-scheme`,
    to indicate a user’s system preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Before we start, let’s decide on the variables needed.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify things, we only change the background color and text color, so that
    would be `--background-color` and `--text-color`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that your application has other colors, such as accent colors,
    shadow colors, and border colors, which would need to have different colors for
    dark and light themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these colors are going to be applied everywhere, we are going to define
    that on the root element with the `:``root` pseudo-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our Svelte components, we will need to start setting the color of the
    text to use `var(--text-color)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it; the color of the text will be white when the system preference
    is on the dark theme, and black when it is on the light theme.
  prefs: []
  type: TYPE_NORMAL
- en: With the inheriting nature of CSS custom properties, the value of the CSS custom
    property will be determined by the closest parent element that has set the value.
  prefs: []
  type: TYPE_NORMAL
- en: This opens the door to allowing component users to specify the style of a component
    without having to override style declarations through CSS rules of higher specificity.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing users to change the styles of a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you style your component with CSS in the `<style>` block, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to modify the color of the `p` element from outside of the component,
    you’ll need to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`div :global(p)` selector to override the color; however, without knowing the
    implementation detail of the component, we do not know for sure whether our selector
    has a higher specificity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The element structure of** **the component**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To know which element’s color to override, we would have to know the element
    structure of the component and whether the element containing the text whose color
    we would like to change is a paragraph element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The CSS rules and element structure of a component should not be part of the
    component’s public API. Overriding the style of a component via a higher specificity
    CSS rule is not recommended. Small tweaks on the CSS rules or element structure
    will most likely break our CSS rule overrides.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A better approach is to expose a list of CSS custom properties that can be
    used to override the styles of the component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `var()` function accepts an optional second parameter, which is the fallback
    value if the variable name in the first parameter does not exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you use the component without defining `--text-color`, then the color of
    the paragraph will fall back to red.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The color of the paragraph in the following code snippet is red:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `"display:contents"` is to make sure that the extra `div` does not participate
    in the layout of the contents of `<``Component />`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we are specifying a fallback value whenever we are using the CSS custom properties,
    we may find ourselves repeating the fallback value a few more times. It would
    be a hassle if we are going to change the fallback value. Let’s see how we can
    align the fallback value.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning the fallback value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are using `var(--text-color, red)` across elements, you may quickly realize
    that we should also define a CSS custom property for the fallback value, lest
    we will be repeating the value multiple times, and it will potentially be troublesome
    to find and replace all of them in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define another CSS custom property, you will have to define it at the root
    element of your component. If the value is local to your component and its descendent
    components only, then you should not define the CSS custom property at the document
    root element via `:root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This approach, however, requires us to use `var(--fallback-color)` wherever
    we are using `var(--text-color)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly better approach is to define a new CSS custom property that will
    have the value of `--text-color` if defined, or red as a fallback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This way, the value of `var(--internal-text-color)` will always be defined,
    and it is more convenient to use just one CSS custom property for elements thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through six different methods to style a Svelte component.
    So, do you know which method you are going to use to style your Svelte component?
    You should now know to choose the approach that is best suited for the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how to use Tailwind CSS in a Svelte project. It takes some initial
    setup to get Tailwind up and running at the beginning, but CSS frameworks such
    as Tailwind CSS usually come with predefined CSS classes, and most of the time,
    you use a `class` attribute or the `class:` directive to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered how we can use the CSS custom property to theme Svelte components
    and how to allow component users to customize the style of a component. You can
    now create and share Svelte components while allowing others to have different
    styling than the default styles that you’ve created.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to manage the props and states of a
    Svelte component.
  prefs: []
  type: TYPE_NORMAL
