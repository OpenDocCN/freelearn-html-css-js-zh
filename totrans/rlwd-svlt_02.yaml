- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Implementing Styling and Theming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现样式和主题
- en: Without styling, an `h1` element within a component will look the same as another
    `h1` element from another component. Svelte allows you to use **Cascading Style
    Sheets** (**CSS**), a language used for styling and formatting web content, to
    style your elements, giving them a different look and feel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有样式的情况下，组件内的 `h1` 元素将与其他组件中的 `h1` 元素看起来相同。Svelte 允许您使用 **层叠样式表** (**CSS**)，这是一种用于样式化和格式化网页内容的语言，来设置您的元素样式，使它们具有不同的外观和感觉。
- en: In this chapter, we will start by talking about different ways to style a Svelte
    component. We will then see some examples, including integrating a popular CSS
    framework, **Tailwind CSS**, into Svelte.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论不同的 Svelte 组件样式设置方法。然后，我们将看到一些示例，包括将流行的 CSS 框架 **Tailwind CSS**
    集成到 Svelte 中。
- en: Following that, we will talk about themes. When you have a set of styles consistently
    applied throughout Svelte components, you’ll see an overall styling theme in your
    components. We will talk about how to synchronize the styles across components,
    as well as how to let users of the components customize them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论主题。当您在 Svelte 组件中一致地应用一组样式时，您将在组件中看到整体样式主题。我们将讨论如何跨组件同步样式，以及如何允许组件用户自定义样式。
- en: By the end of the chapter, you will have learned various methods of styling
    and will be comfortable in choosing the right approach and applying the right
    methods, depending on the scenario.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会各种样式设置方法，并能够根据场景选择合适的方案和适用正确的方法。
- en: 'This chapter includes sections on the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Ways to style a Svelte component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Svelte 组件样式的多种方法
- en: Ways to style a Svelte component with Tailwind CSS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tailwind CSS 设置 Svelte 组件样式的多种方法
- en: Applying themes to Svelte components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主题应用到 Svelte 组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code used in this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章使用的代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter02)。
- en: Styling Svelte components in six different ways
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以六种不同的方式设置 Svelte 组件的样式
- en: In a Svelte component, you have elements that define the structure and content.
    With styling, you can change the look and feel of the elements beyond the browser
    default.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 组件中，您有定义结构和内容的元素。通过样式设置，您可以改变元素的外观和感觉，超出浏览器的默认设置。
- en: Svelte components can be styled in six different ways. Let’s explore the different
    ways to apply a style to elements within a Svelte component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 组件可以通过六种不同的方式来设置样式。让我们来探索在 Svelte 组件内部应用样式的不同方法。
- en: Styling with the style attribute
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `style` 属性进行样式设置
- en: 'Firstly, you can add inline styles to an element with the `style` attribute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以通过 `style` 属性向元素添加内联样式：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding snippet will turn the color of the text within `div` to blue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将 `div` 内文本的颜色变为蓝色。
- en: 'Similar to the `style` attribute in HTML elements, you can add multiple CSS
    styling declarations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTML 元素中的 `style` 属性类似，您可以在 `style` 属性中添加多个 CSS 样式声明：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The syntax of adding multiple CSS styling declarations in Svelte is the same
    as you would do in HTML. In the preceding snippet, we change the text within `div`
    to be blue in color and 2 rem in size.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 中添加多个 CSS 样式声明的语法与在 HTML 中做的方式相同。在前面的代码片段中，我们将 `div` 内的文本颜色改为蓝色，并设置为
    2 rem 大小。
- en: 'The value of the `style` attribute is a string. You can form the `style` attribute
    with dynamic expressions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 属性的值是一个字符串。您可以使用动态表达式来构建 `style` 属性：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes it gets messy when you have multiple CSS styling declarations within
    the `style` attribute:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 `style` 属性中拥有多个 CSS 样式声明时，有时会变得杂乱无章：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using style: directives'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `style:` 指令
- en: 'Svelte provides `style:` directives, which allow you to split the `style` attribute
    into several attributes, which is hopefully more readable after adding line breaks
    and indentations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 提供了 `style:` 指令，允许您将 `style` 属性拆分为多个属性，在添加换行和缩进后，这可能会使代码更易于阅读：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `style:` directive follows the following syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`style:` 指令遵循以下语法：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The CSS property name can be any CSS property, including CSS custom properties:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 属性名称可以是任何 CSS 属性，包括 CSS 自定义属性：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And if the name of the style matches the name of the value it depends on, then
    you can use the shorthand form of the `style:` directive:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样式名称与它所依赖的值名称相匹配，那么您可以使用 `style:` 指令的简写形式：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A style declared in the `style:` directive has higher priority than the `style`
    attribute. In the following example, the `h1` text color is red instead of blue:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `style:` 指令中声明的样式具有比 `style` 属性更高的优先级。在下面的例子中，`h1` 文本颜色是红色而不是蓝色：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Besides adding inline styles to style an element one by one, the next approach
    allows us to write CSS selectors to target multiple elements and style them together.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了逐个为元素添加内联样式来样式化元素外，接下来的方法允许我们编写 CSS 选择器来针对多个元素并将它们一起样式化。
- en: Adding the <style> block
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `<style>` 块
- en: In each Svelte component, you can have one top-level `<``style>` block.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 Svelte 组件中，你可以有一个顶级 `<style>` 块。
- en: 'Within the `<style>` block, you can have CSS rules, targeting elements within
    the component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<style>` 块内，你可以有 CSS 规则，针对组件内的元素：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach is useful when you want to apply the same style across multiple
    elements within the component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在组件内的多个元素上应用相同的样式时，这种方法很有用。
- en: In the preceding code, would the CSS rule turn all the `div` elements in the
    document to blue?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，CSS 规则会将文档中的所有 `div` 元素都变成蓝色吗？
- en: No. The CSS rules within the `<style>` block are scoped to the component, meaning
    the CSS rules will only be applied to the elements within the component, and not
    `div` elsewhere in your application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不。`<style>` 块内的 CSS 规则的作用域限定在组件内，这意味着 CSS 规则只会应用于组件内的元素，而不会应用于应用中的其他地方的 `div`
    元素。
- en: So you do not have to worry about the CSS rule inside the `<style>` block changing
    elements outside the component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你不必担心 `<style>` 块内的 CSS 规则会改变组件外的元素。
- en: But, how does this work? How does Svelte make sure that the CSS rules only apply
    to the element within the same component?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是如何工作的？Svelte 如何确保 CSS 规则只应用于同一组件内的元素？
- en: Let’s explore that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下。
- en: How Svelte scopes CSS rules within a component
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Svelte 如何作用域组件内的 CSS 规则
- en: Let’s digress for a bit to understand how Svelte makes sure that the CSS rules
    within a component are scoped.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微偏离一下，来理解 Svelte 如何确保组件内的 CSS 规则是作用域限定的。
- en: 'When Svelte compiles a component, the Svelte compiler goes through each CSS
    rule and attempts to match each element with the selector of the CSS rule:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Svelte 编译一个组件时，Svelte 编译器会遍历每个 CSS 规则，并尝试将每个元素与 CSS 规则的选择器匹配：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whenever an element matches the selector, the Svelte compiler will generate
    a CSS class name that is unique to the component and apply it to the element.
    At the same time, Svelte limits the scope of the elements being selected by the
    CSS rule by including a class selector of the generated class name in the selector.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素匹配选择器时，Svelte 编译器将为组件生成一个唯一的 CSS 类名并将其应用于该元素。同时，Svelte 通过在选择器中包含生成的类名的类选择器来限制被
    CSS 规则选择的元素的作用域。
- en: 'The transformation of the element and the CSS rule looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元素和 CSS 规则的转换看起来像这样：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `"svelte-g5jdbb"` is the unique CSS class name that is generated by calculating
    the hash value of the CSS content. The hash value will be different when the CSS
    content changes. Since the Svelte compiler only applies the CSS class name to
    the elements within the component, it is unlikely that the style will be applied
    to other elements outside the component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`"svelte-g5jdbb"` 是由计算 CSS 内容的哈希值生成的唯一 CSS 类名。当 CSS 内容发生变化时，哈希值也会不同。由于 Svelte
    编译器只将 CSS 类名应用于组件内的元素，因此不太可能将样式应用于组件外的其他元素。
- en: This transformation happens during compilation by default. There’s nothing additional
    that you need to do. The example here is more for illustration purposes only.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换默认发生在编译过程中。你不需要做任何额外的事情。这里的例子只是为了说明目的。
- en: Knowing that the CSS rules within the `<style>` block are scoped, when you want
    to apply styles to all of the elements of the same node name, using the CSS type
    selector for your CSS rule is sufficient most of the time. However, if you want
    to style only some of the elements, say only the second `div` element in the preceding
    example, you can add a `class` attribute to the second `div` element to differentiate
    between other `div` elements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 `<style>` 块内的 CSS 规则是作用域限定的，当你想要将样式应用于具有相同节点名的所有元素时，使用 CSS 类型选择器作为你的 CSS
    规则通常就足够了。然而，如果你只想样式化某些元素，比如在上一个例子中只样式化第二个 `div` 元素，你可以在第二个 `div` 元素上添加一个 `class`
    属性来区分其他 `div` 元素。
- en: And yes, adding a `class` attribute is our next way of styling our Svelte component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，添加一个 `class` 属性是我们样式化 Svelte 组件的另一种方式。
- en: Adding the class attribute
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `class` 属性
- en: The CSS class selector in CSS works the same way in Svelte.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 类选择器在 Svelte 中的工作方式与在 CSS 中相同。
- en: When you add a `class` attribute to an element, you can target it using the
    CSS class selector.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向元素添加 `class` 属性时，你可以使用 CSS 类选择器来定位它。
- en: 'In the following example, we added the `highlight` class to the second `div`,
    and thus only the second `div` has a yellow background:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将 `highlight` 类添加到了第二个 `div` 元素上，因此只有第二个 `div` 元素具有黄色背景：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value of the `class` attribute can be a string or a dynamic expression.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 属性的值可以是字符串或动态表达式。'
- en: 'You can conditionally apply classes to the element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以条件性地将类应用到元素上：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, when the value of both `toHighlight` and `toBold`
    is `true`, the `class` attribute value evaluates to `"highlight bold"`. Thus,
    two classes, `highlight` and `bold`, are applied to the `div` element.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当 `toHighlight` 和 `toBold` 的值都为 `true` 时，`class` 属性的值计算为 `"highlight
    bold"`。因此，两个类，`highlight` 和 `bold`，被应用到 `div` 元素上。
- en: This pattern of conditionally applying classes to an element based on a variable
    is so common that Svelte provides the `class:` directive to simplify it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种根据变量条件性地将类应用到元素上的模式非常常见，因此 Svelte 提供了 `class:` 指令来简化它。
- en: 'Simplifying the class attribute with the class: directive'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '使用 class: 指令简化类属性'
- en: In the previous example, we conditionally applied the `highlight` class when
    the `toHighlight` variable was truthy, and `bold` when the `toBold` variable was
    truthy.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们当 `toHighlight` 变量为真值时条件性地应用了 `highlight` 类，当 `toBold` 变量为真值时应用了 `bold`
    类。
- en: 'This can be simplified with the `class:` directive, where you have the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 `class:` 指令来简化，如下所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To simplify the previous example with the `class:` directive, we have the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `class:` 指令简化前面的示例，我们得到以下代码：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just like the `style:` attribute, you can further simplify to a `class:` directive
    shorthand if the name of the class is the same as the name of the variable for
    the condition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `style:` 属性一样，如果类的名称与条件变量的名称相同，你可以进一步简化为 `class:` 指令的缩写形式。
- en: 'If the condition for adding the `highlight` class is instead a variable named
    `highlight`, then the preceding example can be rewritten as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加 `highlight` 类的条件是一个名为 `highlight` 的变量，那么前面的示例可以重写如下：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Putting all of them together, in the following code example, the `div` element
    has a yellow background when the `highlight` variable is `true`, and a transparent
    background otherwise:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，在下面的代码示例中，当 `highlight` 变量值为 `true` 时，`div` 元素具有黄色背景，否则具有透明背景：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All the approaches of applying styles to an element that we’ve explored so far
    have the CSS declarations written within the Svelte component. However, it is
    possible to define styles outside of the Svelte component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的所有将样式应用到元素的方法都涉及在 Svelte 组件内编写 CSS 声明。然而，可以在 Svelte 组件外部定义样式。
- en: Applying styles from external CSS files
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从外部 CSS 文件应用样式
- en: 'Let’s say you add a style element to the HTML of your application, like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你向应用程序的 HTML 中添加了一个样式元素，如下所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, you could include external CSS files in the HTML of your application,
    like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在应用程序的 HTML 中包含外部 CSS 文件，如下所示：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In both cases, the CSS rules written in them are applied globally to all elements
    in the application, including elements within your Svelte component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，它们中编写的 CSS 规则被应用到应用程序中的所有元素上，包括 Svelte 组件内的元素。
- en: 'If you are using build tools such as webpack, Rollup, or Vite to bundle your
    application, it is common to configure your build tools to import CSS files using
    the `import` statement, just like importing any JS files (some tools, such as
    Vite, even have been configured to allow importing CSS files such as any JS files
    by default!):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用构建工具，如 webpack、Rollup 或 Vite 来打包你的应用程序，通常需要配置你的构建工具以使用 `import` 语句导入
    CSS 文件，就像导入任何 JS 文件一样（一些工具，如 Vite，甚至默认配置为允许像导入 JS 文件一样导入 CSS 文件！）：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Importing CSS Modules
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 CSS 模块
- en: 'In Vite, when you name your CSS files ending with `.module.css`, the CSS file
    is considered a **CSS Modules** file. A CSS Module is a CSS file where all the
    class names defined within the file are locally scoped:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vite 中，当你将 CSS 文件命名为以 `.module.css` 结尾时，该 CSS 文件被视为 **CSS 模块** 文件。CSS 模块是一个
    CSS 文件，其中定义的所有类名都具有局部作用域：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that the CSS class names specified within a CSS Module will not conflict
    with any class names specified elsewhere, even with class names that have the
    same name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 CSS 模块中指定的 CSS 类名不会与任何其他地方指定的类名冲突，即使是与相同名称的类名也不会。
- en: This is because the build tool will transform the class names within CSS Modules
    to something unique that is unlikely to have conflicts with any other names.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为构建工具会将 CSS 模块中的类名转换成独特的东西，这不太可能与任何其他名称冲突。
- en: 'The following is an example of how the CSS rules in the preceding CSS Modules
    would turn out after the build:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明前面的 CSS 模块在构建后 CSS 规则将如何呈现：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When importing a CSS Module from a JavaScript module, the CSS Module exports
    an object, containing the mapping of the original class name to the transformed
    class name:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 JavaScript 模块导入 CSS 模块时，CSS 模块导出一个对象，其中包含原始类名到转换后类名的映射：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding snippet, the imported `styles` module is an object, and we
    can get the transformed class name, `'q3tu41d'`, through `styles.highlight`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，导入的 `styles` 模块是一个对象，我们可以通过 `styles.highlight` 获取转换后的类名，即 `'q3tu41d'`。
- en: 'This allows you to use the transformed class name in your Svelte component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在 Svelte 组件中使用转换后的类名：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve seen six different ways of styling a Svelte component, but how do you
    choose when to use which one?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了六种不同的方式来设置 Svelte 组件的样式，但你是如何选择何时使用哪一种方式的呢？
- en: Choosing which method to style Svelte components
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择为 Svelte 组件设置样式的技巧：
- en: Each method that we’ve seen so far has its pros and cons. Most of the time,
    choosing which method to style your Svelte component is up to personal preference
    and convenience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的每种方法都有其优缺点。大多数时候，选择哪种方法来设置 Svelte 组件的样式取决于个人偏好和便利性。
- en: 'Here are some of my personal preferences when choosing the method to style
    my Svelte component:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择为我的 Svelte 组件设置样式的技巧时，以下是我的一些个人偏好：
- en: '<style> block over inline styles:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<style>` 块与内联样式：'
- en: Most of the time, I find that the style I am writing has less to do with the
    logic of showing the elements, and more with how the elements look. So, I find
    it clutters my flow of reading the component when having the styles in line along
    with the elements. I prefer to have all my styles in one place in the `<``style>`
    block.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数时候，我发现我编写的样式与显示元素的逻辑关系不大，而更多的是关于元素的外观。因此，当样式与元素一起内联时，我发现这会干扰我阅读组件的流程。我更喜欢将所有样式放在
    `<style>` 块的一个地方。
- en: 'Controlling styles using the `style:` directive and the `class:` directive:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `style:` 指令和 `class:` 指令控制样式：
- en: When the style property of an element is dependent on a variable, I would use
    the `style:` directive or the `class:` directive instead of the `style` attribute
    or the `class` attribute. I find this cleaner to read, as well as finding it a
    strong signal telling me that the style of the element is dynamic.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当元素的样式属性依赖于一个变量时，我会使用 `style:` 指令或 `class:` 指令而不是 `style` 属性或 `class` 属性。我发现这更易于阅读，同时也发现这是一个强烈的信号，告诉我元素的样式是动态的。
- en: When I am changing only one style property based on one variable, I would use
    the `style:` directive. However, when changing more than one style property with
    the same variable, I prefer declaring a CSS class to group all the styles together
    and controlling it via the `class:` directive.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我仅基于一个变量更改一个样式属性时，我会使用 `style:` 指令。然而，当使用同一个变量更改多个样式属性时，我更倾向于声明一个 CSS 类来将所有样式组合在一起，并通过
    `class:` 指令来控制它。
- en: 'CSS Modules for reusing CSS declarations in multiple Svelte components:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个 Svelte 组件中重用 CSS 声明的 CSS 模块：
- en: At the time of writing this book, there’s no built-in method in Svelte to share
    the same CSS declarations in multiple Svelte components. So, you might want to
    share the CSS declarations through CSS Modules.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本书时，Svelte 中没有内置方法来在多个 Svelte 组件中共享相同的 CSS 声明。因此，你可能希望通过 CSS 模块来共享 CSS 声明。
- en: However, more often than not, when you need the same CSS declarations for elements
    across multiple Svelte components, you have a less-than-perfect component structure.
    It may be possible to abstract the elements out into a Svelte component.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，更常见的情况是，当你需要在多个 Svelte 组件中为元素使用相同的 CSS 声明时，你可能会遇到一个不太完美的组件结构。可能可以将元素抽象成一个
    Svelte 组件。
- en: We’ve seen how we can define our own styles within and outside of a Svelte component;
    however, sometimes it’s much easier to adopt styles written by others, rather
    than designing our own styles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在 Svelte 组件内部和外部定义自己的样式；然而，有时采用他人编写的样式比设计自己的样式要容易得多。
- en: In the next section, we are going to explore using a popular CSS framework,
    Tailwind CSS, in Svelte.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在 Svelte 中使用流行的 CSS 框架 Tailwind CSS。
- en: Styling Svelte with Tailwind CSS
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tailwind CSS 样式化 Svelte
- en: 'Tailwind CSS is a utility-first CSS framework. It comes with predefined classes,
    such as `flex`, `pt-4`, and `text-center`, which you can use directly in your
    markup:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 是一个以实用类为首要的 CSS 框架。它包含预定义的类，如 `flex`、`pt-4` 和 `text-center`，你可以在你的标记中直接使用这些类：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are going to use Vite’s Svelte template as a base to set up Tailwind CSS.
    If you are not familiar with setting up Vite’s Svelte template, here are the quick
    steps to set it up:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Vite 的 Svelte 模板作为基础来设置 Tailwind CSS。如果你不熟悉设置 Vite 的 Svelte 模板，以下是一些快速设置步骤：
- en: 'Run the Vite setup tool:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Vite 设置工具：
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Step into the `my-project-name` folder and install the dependencies:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `my-project-name` 文件夹并安装依赖项：
- en: '[PRE27]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the dependencies are installed, you can start the development server:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，你可以启动开发服务器：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the Svelte project up and running, let’s look at what we need to do to
    set up Tailwind CSS.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Svelte 项目运行起来，让我们看看我们需要做什么来设置 Tailwind CSS。
- en: Setting up Tailwind CSS
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Tailwind CSS
- en: 'Tailwind CSS has come up with a `tailwindcss` CLI tool that has made the setup
    so much easier. Follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 提供了一个 `tailwindcss` CLI 工具，使得设置变得更加简单。按照以下步骤操作：
- en: 'To set up Tailwind CSS in a Svelte + Vite project, we first install the dependencies
    that are needed:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Svelte + Vite 项目中设置 Tailwind CSS，我们首先安装所需的依赖项：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After `tailwindcss` is installed, run the command to generate `tailwind.config.js`
    and `postcss.config.js`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完 `tailwindcss` 后，运行命令以生成 `tailwind.config.js` 和 `postcss.config.js`：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Specify the location of where our Svelte components are in `tailwind.config.js`
    so that Tailwind CSS knows where to scan Svelte components for class names:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tailwind.config.js` 中指定我们的 Svelte 组件的位置，以便 Tailwind CSS 知道在哪里扫描 Svelte 组件以获取类名：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `postcss.config.js` file keeps the configuration for PostCSS. The default
    configuration generated is good for now.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`postcss.config.js` 文件保存了 PostCSS 的配置。默认生成的配置目前是好的。'
- en: 'Create a CSS file in `./src/main.css` to add the Tailwind directives:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `./src/main.css` 中创建一个 CSS 文件以添加 Tailwind 指令：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Import the newly created `./src/main.css` in the `./``src/main.js` file:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `./src/main.js` 文件中导入新创建的 `./src/main.css`：
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is similar to importing external CSS files, which we saw earlier on.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与之前看到的导入外部 CSS 文件类似。
- en: 'Start the Vite `dev` server:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Vite `dev` 服务器：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You just created an `<h1>` element with two Tailwind CSS classes applied: `text-center`
    and `text-sky-400`. This will make the text in the `<h1>` element center-aligned
    and in a sky-blue color. As you use Tailwind CSS utility class names in your Svelte
    component, the style declarations for those classes are generated and replace
    the `@tailwind` `utilities` directive.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个带有两个 Tailwind CSS 类 `<h1>` 元素：`text-center` 和 `text-sky-400`。这将使 `<h1>`
    元素中的文本居中对齐，并呈现天蓝色。当你使用 Tailwind CSS 实用类名称在你的 Svelte 组件中时，这些类的样式声明会被生成并替换掉 `@tailwind`
    `utilities` 指令。
- en: 'Tailwind CSS is able to extract class names from both the `class` attribute
    and the `class:` directive, allowing you to statically or conditionally apply
    the Tailwind CSS styles to the elements:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 能够从 `class` 属性和 `class:` 指令中提取类名，允许你静态或条件性地将 Tailwind CSS 样式应用到元素上：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Tailwind CSS comes with a lot of utility classes: you can learn more about
    Tailwind CSS at [https://tailwindcss.com/](https://tailwindcss.com/).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 包含了许多实用类：你可以在 [https://tailwindcss.com/](https://tailwindcss.com/)
    上了解更多关于 Tailwind CSS 的信息。
- en: Since Tailwind CSS classes are globally available, you can apply the same CSS
    classes to maintain the same look and feel across Svelte components within the
    same application. However, if you are doing so with your own style declarations,
    you may have to re-specify the same colors or dimensions in the style declarations
    across components to maintain the same look. Changing the value in the future
    would also be a problem, as we would have to search for usages by the value and
    update them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Tailwind CSS 类是全局可用的，因此你可以将相同的 CSS 类应用到同一应用程序内的 Svelte 组件上，以保持相同的视觉和感觉。然而，如果你使用自己的样式声明这样做，你可能必须在组件之间重新指定相同的颜色或尺寸以保持相同的视觉。将来更改值也会成为问题，因为我们必须通过值搜索用法并更新它们。
- en: CSS custom properties are a solution for this. They allow us to define a value
    in one place and then reference it in multiple other places. Let’s look at how
    we can use CSS custom properties in Svelte components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 自定义属性是解决这个问题的方案。它们允许我们在一个地方定义一个值，然后在其他多个地方引用它。让我们看看我们如何在 Svelte 组件中使用 CSS
    自定义属性。
- en: Theming Svelte components with CSS custom properties
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CSS 自定义属性为主题化 Svelte 组件
- en: 'Let’s take a quick knowledge check on CSS custom properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 CSS 自定义属性进行快速知识检查：
- en: 'You define CSS custom properties like any other CSS properties, except that
    the name of the CSS custom property starts with two dashes:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以像定义其他 CSS 属性一样定义 CSS 自定义属性，只是 CSS 自定义属性的名称以两个短横线开头：
- en: '[PRE36]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To reference the CSS custom property, use the `var()` function:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要引用 CSS 自定义属性，请使用 `var()` 函数：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'CSS custom properties cascade like any other CSS properties:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 自定义属性像任何其他 CSS 属性一样具有级联性：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The value of the `--text-color` CSS custom property for `<div>` elements is
    red, except for the `<div>` elements with a class named `foo`.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<div>` 元素的 `--text-color` CSS 自定义属性的值是红色，除了具有名为 `foo` 的类的 `<div>` 元素。'
- en: 'The value of CSS custom properties is inherited from their parent:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 自定义属性的值从其父元素继承：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the value of `--text-color` for `<div>` in the preceding example is red,
    then without other CSS rules applied to `<span>`, the value of `--text-color`
    for `<span>` is also red.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果前一个示例中 `<div>` 的 `--text-color` 值是红色，那么如果没有其他 CSS 规则应用到 `<span>` 上，`<span>`
    的 `--text-color` 值也是红色。
- en: Defining CSS custom properties
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 CSS 自定义属性
- en: 'To specify a set of dimensions and colors for the Svelte components, we can
    define them as CSS custom properties at the root component of our application:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Svelte 组件指定一组尺寸和颜色，我们可以在应用程序的根组件中定义它们作为 CSS 自定义属性：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, we define the CSS custom property at the root element
    of the component, the `<div>` element. As a CSS custom property value inherits
    from a parent, the child elements and elements within the child components inherit
    the value from the `<``div>` element.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们在组件的根元素（`<div>` 元素）处定义了 CSS 自定义属性。由于 CSS 自定义属性值从父元素继承，子元素和子组件内的元素从
    `<div>` 元素继承值。
- en: As we are defining the CSS custom property at the `<div>` element of the component,
    elements that are not the descendant of the `<div>` element will not be able to
    access the value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在定义组件 `<div>` 元素的 CSS 自定义属性，因此不是 `<div>` 元素子代元素的元素将无法访问该值。
- en: 'If, instead, you would like to define the variable for all elements, even elements
    that are not the descendant of the root element of our root component, you can
    define the CSS custom property at the root of the document using the `:``root`
    selector:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为所有元素定义变量，即使是那些不是根组件根元素的子代元素，你可以在文档的根处使用 `:root` 选择器来定义 CSS 自定义属性：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You do not need to use the `:global()` pseudo-selector for `:root`, as it will
    always refer to the root of the document, and never be scoped to the component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `:root`，你不需要使用 `:global()` 伪选择器，因为它始终指向文档的根，并且永远不会作用域到组件。
- en: The `:global()` pseudo-selector is used in CSS Modules to define styles that
    apply globally, outside the local module scope. In Svelte, when used within a
    component’s `<style>` block, it allows you to define CSS rules that won’t be scoped
    to the component, making them available and applicable to elements across the
    entire Svelte application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSS Modules 中，`:global()` 伪选择器用于定义全局样式，这些样式适用于局部模块作用域之外。在 Svelte 中，当在组件的 `<style>`
    块中使用时，它允许你定义不会作用域到组件的 CSS 规则，使它们在整个 Svelte 应用程序中的元素可用并适用。
- en: 'As an alternative to defining the CSS custom properties in the `<style>` block,
    you can define them directly on the element itself through the `style` attribute:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在`<style>`块中定义CSS自定义属性的替代方案，你可以通过`style`属性直接在元素本身上定义它们：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you may recall, doing so with the `style:` directive makes the code look
    tidier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，使用`style:`指令这样做可以使代码看起来更整洁：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To reference the value in the child component, you use the `var()` function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在子组件中引用该值，你使用`var()`函数：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The great thing about using the CSS custom property is that we could dynamically
    change the value of the CSS custom property, and the element’s style referencing
    the CSS custom property will be updated automatically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS自定义属性的优点在于，我们可以动态地更改CSS自定义属性的值，引用该CSS自定义属性的元素样式将自动更新。
- en: 'For example, I can specify the value of `--text-color` of `<div>` to be `#222`
    or `#eee`, based on a condition:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以根据条件指定`<div>`的`--text-color`值为`#222`或`#eee`：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the condition is `true`, the value of `var(--text-color)` is `#222`, and
    the value changes to `#eee` when the condition changes to `false`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为`true`时，`var(--text-color)`的值为`#222`，当条件变为`false`时，值变为`#eee`。
- en: As you can see, CSS custom properties make it much easier to synchronize the
    style of elements.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，CSS自定义属性使得同步元素样式变得容易得多。
- en: 'Now, let’s look at a real-world example of using CSS custom properties: creating
    a dark/light theme mode.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用CSS自定义属性的实际情况：创建深色/浅色主题模式。
- en: Example – implementing a dark/light theme mode
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 实现深色/浅色主题模式
- en: Dark mode is a color scheme where you have light-colored text on a dark-colored
    background. The idea behind dark mode is that it reduces the light coming from
    the screen while maintaining color contrast ratios so that the content is still
    readable. Less light coming from the device makes it more comfortable to read,
    especially in a low-light environment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 深色模式是一种颜色方案，其中文本颜色较浅，背景颜色较深。深色模式背后的理念是在保持颜色对比度比率的条件下减少屏幕发出的光线，从而使内容仍然可读。来自设备的较少光线使得阅读更加舒适，尤其是在低光环境中。
- en: 'Most operating systems allow users to set their preference on whether to use
    a dark or light theme, and major browsers support a media query, `prefers-color-scheme`,
    to indicate a user’s system preference:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统允许用户设置是否使用深色或浅色主题的偏好，并且主要浏览器支持`prefers-color-scheme`媒体查询来指示用户的系统偏好：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Before we start, let’s decide on the variables needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们确定所需的变量。
- en: To simplify things, we only change the background color and text color, so that
    would be `--background-color` and `--text-color`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们只更改背景色和文本色，因此将是`--background-color`和`--text-color`。
- en: It is possible that your application has other colors, such as accent colors,
    shadow colors, and border colors, which would need to have different colors for
    dark and light themes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的应用程序还有其他颜色，例如强调色、阴影色和边框色，这些颜色在深色和浅色主题中需要不同的颜色。
- en: 'Since these colors are going to be applied everywhere, we are going to define
    that on the root element with the `:``root` pseudo-class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些颜色将被应用到各个地方，我们将在根元素上使用`:root`伪类来定义它们：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, in our Svelte components, we will need to start setting the color of the
    text to use `var(--text-color)`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的Svelte组件中，我们需要开始设置文本颜色以使用`var(--text-color)`：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And that’s it; the color of the text will be white when the system preference
    is on the dark theme, and black when it is on the light theme.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；当系统偏好设置为深色主题时，文本颜色将是白色，当设置为浅色主题时，文本颜色将是黑色。
- en: With the inheriting nature of CSS custom properties, the value of the CSS custom
    property will be determined by the closest parent element that has set the value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS自定义属性的继承特性，CSS自定义属性的值将由设置了该值的最近父元素确定。
- en: This opens the door to allowing component users to specify the style of a component
    without having to override style declarations through CSS rules of higher specificity.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这为允许组件用户指定组件样式而无需通过更高特异性的CSS规则覆盖样式声明打开了大门。
- en: Allowing users to change the styles of a component
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 允许用户更改组件的样式
- en: 'Let’s say you style your component with CSS in the `<style>` block, like so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用CSS在`<style>`块中为组件设置样式，如下所示：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you want to modify the color of the `p` element from outside of the component,
    you’ll need to know the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从组件外部修改`p`元素的色彩，你需要了解以下内容：
- en: '`div :global(p)` selector to override the color; however, without knowing the
    implementation detail of the component, we do not know for sure whether our selector
    has a higher specificity:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`div :global(p)`选择器来覆盖颜色；然而，由于我们不知道组件的实现细节，我们无法确定我们的选择器是否具有更高的特定性：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**The element structure of** **the component**:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件的元素结构**：'
- en: To know which element’s color to override, we would have to know the element
    structure of the component and whether the element containing the text whose color
    we would like to change is a paragraph element.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要知道要覆盖哪个元素的色彩，我们需要了解组件的元素结构，以及我们想要更改颜色的文本所在的元素是否是段落元素。
- en: The CSS rules and element structure of a component should not be part of the
    component’s public API. Overriding the style of a component via a higher specificity
    CSS rule is not recommended. Small tweaks on the CSS rules or element structure
    will most likely break our CSS rule overrides.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件的CSS规则和元素结构不应成为组件的公共API的一部分。通过具有更高特定性的CSS规则覆盖组件的样式是不推荐的。对CSS规则或元素结构的小幅调整很可能会破坏我们的CSS规则覆盖。
- en: 'A better approach is to expose a list of CSS custom properties that can be
    used to override the styles of the component:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种更好的方法是公开一个CSS自定义属性的列表，这些属性可以用来覆盖组件的样式：
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `var()` function accepts an optional second parameter, which is the fallback
    value if the variable name in the first parameter does not exist.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`var()`函数接受一个可选的第二个参数，它是如果第一个参数中的变量名不存在时的后备值。'
- en: If you use the component without defining `--text-color`, then the color of
    the paragraph will fall back to red.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用组件而没有定义`--text-color`，那么段落的颜色将回退到红色。
- en: 'The color of the paragraph in the following code snippet is red:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下代码片段中，段落的颜色是红色：
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, `"display:contents"` is to make sure that the extra `div` does not participate
    in the layout of the contents of `<``Component />`.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`"display:contents"`是为了确保额外的`div`不参与`<Component />`内容的布局。
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we are specifying a fallback value whenever we are using the CSS custom properties,
    we may find ourselves repeating the fallback value a few more times. It would
    be a hassle if we are going to change the fallback value. Let’s see how we can
    align the fallback value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在使用CSS自定义属性时指定后备值，我们可能会发现自己在重复后备值几次。如果我们打算更改后备值，这将变得麻烦。让我们看看我们如何对齐后备值。
- en: Aligning the fallback value
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐后备值
- en: If we are using `var(--text-color, red)` across elements, you may quickly realize
    that we should also define a CSS custom property for the fallback value, lest
    we will be repeating the value multiple times, and it will potentially be troublesome
    to find and replace all of them in the future.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在多个元素中使用`var(--text-color, red)`，你可能会很快意识到我们也应该定义一个CSS自定义属性作为后备值，以免我们重复多次使用该值，将来可能难以找到并替换所有这些值。
- en: 'To define another CSS custom property, you will have to define it at the root
    element of your component. If the value is local to your component and its descendent
    components only, then you should not define the CSS custom property at the document
    root element via `:root`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义另一个CSS自定义属性，你必须在组件的根元素上定义它。如果该值仅限于你的组件及其子组件，那么你不应该在文档根元素上通过`:root`定义CSS自定义属性：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This approach, however, requires us to use `var(--fallback-color)` wherever
    we are using `var(--text-color)`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法要求我们在使用`var(--text-color)`的任何地方都使用`var(--fallback-color)`。
- en: 'A slightly better approach is to define a new CSS custom property that will
    have the value of `--text-color` if defined, or red as a fallback:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微更好的方法是定义一个新的CSS自定义属性，如果已定义，则其值为`--text-color`，否则为红色作为后备：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This way, the value of `var(--internal-text-color)` will always be defined,
    and it is more convenient to use just one CSS custom property for elements thereafter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`var(--internal-text-color)`的值将始终被定义，并且使用单个CSS自定义属性对后续元素进行操作更为方便。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through six different methods to style a Svelte component.
    So, do you know which method you are going to use to style your Svelte component?
    You should now know to choose the approach that is best suited for the scenario.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了六种不同的方法来样式化Svelte组件。那么，你知道你打算使用哪种方法来样式化你的Svelte组件吗？你现在应该知道选择最适合场景的方法。
- en: We then saw how to use Tailwind CSS in a Svelte project. It takes some initial
    setup to get Tailwind up and running at the beginning, but CSS frameworks such
    as Tailwind CSS usually come with predefined CSS classes, and most of the time,
    you use a `class` attribute or the `class:` directive to apply them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了如何在 Svelte 项目中使用 Tailwind CSS。在开始时，需要一些初始设置来让 Tailwind CSS 启动并运行，但像 Tailwind
    CSS 这样的 CSS 框架通常自带预定义的 CSS 类，大多数情况下，你使用 `class` 属性或 `class:` 指令来应用它们。
- en: Finally, we covered how we can use the CSS custom property to theme Svelte components
    and how to allow component users to customize the style of a component. You can
    now create and share Svelte components while allowing others to have different
    styling than the default styles that you’ve created.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何使用 CSS 自定义属性来为主题 Svelte 组件，以及如何允许组件用户自定义组件的样式。现在，你可以在允许他人使用不同于你创建的默认样式的条件下创建和分享
    Svelte 组件。
- en: In the next chapter, we will look at how to manage the props and states of a
    Svelte component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何管理 Svelte 组件的 props 和 states。
