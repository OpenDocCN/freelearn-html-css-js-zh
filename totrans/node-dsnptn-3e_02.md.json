["```js\nconst myModule = (() => {\n  const privateFoo = () => {}\n  const privateBar = []\n  const exported = {\n    publicFoo: () => {},\n    publicBar: () => {}\n  }\n  return exported\n})**()** // once the parenthesis here are parsed, the function\n     // will be invoked\nconsole.log(myModule)\nconsole.log(myModule.privateFoo, myModule.privateBar) \n```", "```js\n{ publicFoo: [Function: publicFoo],\n  publicBar: [Function: publicBar] }\nundefined undefined \n```", "```js\nfunction loadModule (filename, module, require) {\n  const wrappedSrc =\n    `(function (module, exports, require) {\n      ${fs.readFileSync(filename, 'utf8')}\n    })(module, module.exports, require)`\n  eval(wrappedSrc)\n} \n```", "```js\nfunction require (moduleName) {\n  console.log(`Require invoked for module: ${moduleName}`)\n  const id = require.resolve(moduleName)                   // (1)\n  if (require.cache[id]) {                                 // (2)\n    return require.cache[id].exports\n  }\n  // module metadata\n  const module = {                                         // (3)\n    exports: {},\n    id\n  }\n  // Update the cache\n  require.cache[id] = module                               // (4)\n  // load the module\n  loadModule(id, module, require)                          // (5)\n  // return exported variables\n  return module.exports                                    // (6)\n}\nrequire.cache = {}\nrequire.resolve = (moduleName) => {\n  /* resolve a full module id from the moduleName */\n} \n```", "```js\n// load another dependency\nconst dependency = require('./anotherModule')\n// a private function\nfunction log() {\n  console.log(`Well done ${dependency.username}`)\n}\n// the API to be exported for public use\nmodule.exports.run = () => {\n  log()\n} \n```", "```js\nexports.hello = () => {\n  console.log('Hello')\n} \n```", "```js\nexports = () => {\n  console.log('Hello')\n} \n```", "```js\nmodule.exports = () => {\n  console.log('Hello')\n} \n```", "```js\nsetTimeout(() => {\n  module.exports = function() {...}\n}, 100) \n```", "```js\nmyApp\n├── foo.js\n└── node_modules\n    ├── depA\n    │   └── index.js\n    ├── depB\n    │   ├── bar.js\n    │   └── node_modules\n    │       └── depA\n    │           └── index.js\n    └── depC\n        ├── foobar.js\n        └── node_modules\n            └── depA\n                └── index.js \n```", "```js\n    exports.loaded = false\n    const b = require('./b')\n    module.exports = {\n      b,\n      loaded: true // overrides the previous export\n    } \n    ```", "```js\n    exports.loaded = false\n    const a = require('./a')\n    module.exports = {\n      a,\n      loaded: true\n    } \n    ```", "```js\nconst a = require('./a')\nconst b = require('./b')\nconsole.log('a ->', JSON.stringify(a, null, 2))\nconsole.log('b ->', JSON.stringify(b, null, 2)) \n```", "```js\na -> {\n  \"b\": {\n    \"a\": {\n      \"loaded\": false\n    },\n    \"loaded\": true\n  },\n  \"loaded\": true\n}\nb -> {\n  \"a\": {\n    \"loaded\": false\n  },\n  \"loaded\": true\n} \n```", "```js\n// file logger.js\nexports.info = (message) => {\n  console.log(`info: ${message}`)\n}\nexports.verbose = (message) => {\n  console.log(`verbose: ${message}`)\n} \n```", "```js\n// file main.js\nconst logger = require('./logger')\nlogger.info('This is an informational message')\nlogger.verbose('This is a verbose message') \n```", "```js\n// file logger.js\nmodule.exports = (message) => {\n  console.log(`info: ${message}`)\n} \n```", "```js\nmodule.exports.verbose = (message) => {\n  console.log(`verbose: ${message}`)\n} \n```", "```js\n// file main.js\nconst logger = require('./logger')\nlogger('This is an informational message')\nlogger.verbose('This is a verbose message') \n```", "```js\nclass Logger {\n  constructor (name) {\n    this.name = name\n  }\n  log (message) {\n    console.log(`[${this.name}] ${message}`)\n  }\n  info (message) {\n    this.log(`info: ${message}`)\n  }\n  verbose (message) {\n    this.log(`verbose: ${message}`)\n  }\n}\nmodule.exports = Logger \n```", "```js\n// file main.js\nconst Logger = require('./logger')\nconst dbLogger = new Logger('DB')\ndbLogger.info('This is an informational message')\nconst accessLogger = new Logger('ACCESS')\naccessLogger.verbose('This is a verbose message') \n```", "```js\n// file logger.js\nclass Logger {\n  constructor (name) {\n    this.count = 0\n    this.name = name\n  }\n  log (message) {\n    this.count++\n    console.log('[' + this.name + '] ' + message)\n  }\n}\nmodule.exports = new Logger('DEFAULT') \n```", "```js\n// main.js\nconst logger = require('./logger')\nlogger.log('This is an informational message') \n```", "```js\nconst customLogger = new logger.constructor('CUSTOM')\ncustomLogger.log('This is an informational message') \n```", "```js\n// file patcher.js\n// ./logger is another module\nrequire('./logger').customMessage = function () {\n  console.log('This is a new functionality')\n} \n```", "```js\n// file main.js\nrequire('./patcher')\nconst logger = require('./logger')\nlogger.customMessage() \n```", "```js\nif (condition) {\n  import module1 from 'module1'\n} else {\n  import module2 from 'module2'\n} \n```", "```js\nlet module = null\nif (condition) {\n  module = require('module1')\n} else {\n  module = require('module2')\n} \n```", "```js\n// logger.js\n// exports a function as `log`\nexport function log (message) {\n  console.log(message)\n}\n// exports a constant as `DEFAULT_LEVEL`\nexport const DEFAULT_LEVEL = 'info'\n// exports an object as `LEVELS`\nexport const LEVELS = {\n  error: 0,\n  debug: 1,\n  warn: 2,\n  data: 3,\n  info: 4,\n  verbose: 5\n}\n// exports a class as `Logger`\nexport class Logger {\n  constructor (name) {\n    this.name = name\n  }\n  log (message) {\n    console.log(`[${this.name}] ${message}`)\n  }\n} \n```", "```js\nimport * as loggerModule from './logger.js'\nconsole.log(loggerModule) \n```", "```js\n[Module] {\n  DEFAULT_LEVEL: 'info',\n  LEVELS: { error: 0, debug: 1, warn: 2, data: 3, info: 4,\n    verbose: 5 },\n  Logger: [Function: Logger],\n  log: [Function: log]\n} \n```", "```js\nimport { log } from './logger.js'\nlog('Hello World') \n```", "```js\nimport { log, Logger } from './logger.js'\nlog('Hello World')\nconst logger = new Logger('DEFAULT')\nlogger.log('Hello world') \n```", "```js\nimport { log } from './logger.js'\nconst log = console.log \n```", "```js\nSyntaxError: Identifier 'log' has already been declared \n```", "```js\nimport { log as log2 } from './logger.js'\nconst log = console.log\nlog('message from log')\nlog2('message from log2') \n```", "```js\n// logger.js\nexport default class Logger {\n  constructor (name) {\n    this.name = name\n  }\n  log (message) {\n    console.log(`[${this.name}] ${message}`)\n  }\n} \n```", "```js\n// main.js\nimport MyLogger from './logger.js'\nconst logger = new MyLogger('info')\nlogger.log('Hello World') \n```", "```js\n// showDefault.js\nimport * as loggerModule from './logger.js'\nconsole.log(loggerModule) \n```", "```js\n[Module] { default: [Function: Logger] } \n```", "```js\nimport { default } from './logger.js' \n```", "```js\n// logger.js\nexport default function log (message) {\n  console.log(message)\n}\nexport function info (message) {\n  log(`info: ${message}`)\n} \n```", "```js\nimport mylog, { info } from './logger.js' \n```", "```js\n// strings-el.js\nexport const HELLO = 'Γεια σου κόσμε'\n// strings-en.js\nexport const HELLO = 'Hello World'\n// strings-es.js\nexport const HELLO = 'Hola mundo'\n// strings-it.js\nexport const HELLO = 'Ciao mondo'\n// strings-pl.js\nexport const HELLO = 'Witaj świecie' \n```", "```js\n// main.js\nconst SUPPORTED_LANGUAGES = ['el', 'en', 'es', 'it', 'pl']   // (1)\nconst selectedLanguage = process.argv[2]                     // (2)\nif (!SUPPORTED_LANGUAGES.includes(selectedLanguage)) {       // (3)\n  console.error('The specified language is not supported')\n  process.exit(1)\n}\nconst translationModule = `./strings-${selectedLanguage}.js` // (4)\n**import****(translationModule)**                                    // (5)\n  .then((**strings**) => {                                       // (6)\n    console.log(strings.HELLO)\n  }) \n```", "```js\nnode main.js it \n```", "```js\n// counter.js\nexport let count = 0\nexport function increment () {\n  count++\n} \n```", "```js\n// main.js\nimport { count, increment } from './counter.js'\nconsole.log(count) // prints 0\nincrement()\nconsole.log(count) // prints 1\ncount++ // TypeError: Assignment to constant variable! \n```", "```js\n// a.js\nimport * as bModule from './b.js'\nexport let loaded = false\nexport const b = bModule\nloaded = true\n// b.js\nimport * as aModule from './a.js'\nexport let loaded = false\nexport const a = aModule\nloaded = true \n```", "```js\n// main.js\nimport * as a from './a.js'\nimport * as b from './b.js'\nconsole.log('a ->', a)\nconsole.log('b ->', b) \n```", "```js\na -> <ref *1> [Module] {\n  b: [Module] { a: [Circular *1], loaded: true },\n  loaded: true\n}\nb -> <ref *1> [Module] {\n  a: [Module] { b: [Circular *1], loaded: true },\n  loaded: true\n} \n```", "```js\n// mock-read-file.js\nimport fs from 'fs'                                        // (1)\nconst originalReadFile = fs.readFile                       // (2)\nlet mockedResponse = null\nfunction mockedReadFile (path, cb) {                       // (3)\n  setImmediate(() => {\n    cb(null, mockedResponse)\n  })\n}\nexport function mockEnable (respondWith) {                 // (4)\n  mockedResponse = respondWith\n  fs.readFile = mockedReadFile\n}\nexport function mockDisable () {                           // (5)\n  fs.readFile = originalReadFile\n} \n```", "```js\n// main.js\nimport fs from 'fs'                                          // (1)\nimport { mockEnable, mockDisable } from './mock-read-file.js'\nmockEnable(Buffer.from('Hello World'))                       // (2)\nfs.readFile('fake-path', (err, data) => {                    // (3)\n  if (err) {\n    console.error(err)\n    process.exit(1)\n  }\n  console.log(data.toString()) // 'Hello World'\n})\nmockDisable() \n```", "```js\nimport * as fs from 'fs' // then use fs.readFile \n```", "```js\nimport { readFile } from 'fs' \n```", "```js\nimport fs, { readFileSync } from 'fs'\nimport { syncBuiltinESMExports } from 'module'\nfs.readFileSync = () => Buffer.from('Hello, ESM')\nsyncBuiltinESMExports()\nconsole.log(fs.readFileSync === readFileSync) // true \n```", "```js\nconsole.log(exports) // ReferenceError: exports is not defined\nconsole.log(module) // ReferenceError: module is not defined\nconsole.log(__filename) // ReferenceError: __filename is not defined\nconsole.log(__dirname) // ReferenceError: __dirname is not defined \n```", "```js\nimport { fileURLToPath } from 'url'\nimport { dirname } from 'path'\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename) \n```", "```js\nimport { createRequire } from 'module'\nconst require = createRequire(import.meta.url) \n```", "```js\n// this.js - ESM\nconsole.log(this) // undefined\n// this.cjs – CommonJS\nconsole.log(this === exports) // true \n```", "```js\nimport packageMain from 'commonjs-package' // Works\nimport { method } from 'commonjs-package'  // Errors \n```", "```js\nimport data from './data.json' \n```", "```js\nimport { createRequire } from 'module'\nconst require = createRequire(import.meta.url)\nconst data = require('./data.json')\nconsole.log(data) \n```"]