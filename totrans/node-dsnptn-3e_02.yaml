- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Module System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 1*, *The Node.js Platform*, we briefly introduced the importance
    of modules in Node.js. We discussed how modules play a fundamental role in defining
    some of the pillars of the Node.js philosophy and its programming experience.
    But what do we actually mean when we talk about modules and why are they so important?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In generic terms, modules are the bricks for structuring non-trivial applications.
    Modules allow you to divide the codebase into small units that can be developed
    and tested independently. Modules are also the main mechanism to enforce information
    hiding by keeping private all the functions and variables that are not explicitly
    marked to be exported.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'If you come from other languages, you have probably seen similar concepts being
    referred to with different names: **package** (Java, Go, PHP, Rust, or Dart),
    **assembly** (.NET), **library** (Ruby), or **unit** (Pascal dialects). The terminology
    is not perfectly interchangeable because every language or ecosystem comes with
    its own unique characteristics, but there is a significant overlap between these
    concepts.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly enough, Node.js currently comes with two different module systems:
    **CommonJS** (**CJS**) and **ECMAScript modules** (**ESM** or **ES modules**).
    In this chapter, we will discuss why there are two alternatives, we will learn
    about their pros and cons, and, finally, we will analyze several common patterns
    that are relevant when using or writing Node.js modules. By the end of this chapter,
    you should be able to make pragmatic choices about how to use modules effectively
    and how to write your own custom modules.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Getting a good grasp of Node.js' module systems and module patterns is very
    important as we will rely on this knowledge in all the other chapters of this
    book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, these are the main topics we will be discussing throughout this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Why modules are necessary and the different module systems available in Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CommonJS internals and module patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ES modules (ESM) in Node.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences and interoperability between CommonJS and ESM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with why we need modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The need for modules
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good module system should help with addressing some fundamental needs of software
    engineering:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*Having a way to split the codebase into multiple files*. This helps with keeping
    the code more organized, making it easier to understand but also helps with developing
    and testing various pieces of functionality independently from each other.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Allowing code reuse across different projects*. A module can, in fact, implement
    a generic feature that can be useful for different projects. Organizing such functionality
    within a module can make it easier to bring it into the different projects that
    may want to use it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Encapsulation* (or *information hiding*). It is generally a good idea to hide
    implementation complexity and only expose simple interfaces with clear responsibilities.
    Most module systems allow to selectively keep the *private* part of the code hidden,
    while exposing a *public* interface, such as functions, classes, or objects that
    are meant to be used by the consumers of the module.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing dependencies*. A good module system should make it easy for module
    developers to build on top of existing modules, including third-party ones. A
    module system should also make it easy for module users to import the chain of
    dependencies that are necessary for a given module to run (transient dependencies).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to clarify the distinction between *a module* and *a module
    system*. We can define a module as the actual unit of software, while a module
    system is the syntax and the tooling that allows us to define modules and to use
    them within our projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Module systems in JavaScript and Node.js
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all programming languages come with a built-in module system, and JavaScript
    had been lacking this feature for a long time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the browser landscape, it is possible to split the codebase into multiple
    files and then import them by using different `<script>` tags. For many years,
    this approach was good enough to build simple interactive websites, and JavaScript
    developers managed to get things done without having a fully-fledged module system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Only when JavaScript browser applications became more complicated and frameworks
    like *jQuery*, *Backbone*, and *AngularJS* took over the ecosystem, the JavaScript
    community came up with several initiatives aimed at defining a module system that
    could be effectively adopted within JavaScript projects. The most successful ones
    were **asynchronous module definition** (**AMD**), popularized by RequireJS ([nodejsdp.link/requirejs](http://nodejsdp.link/requirejs)),
    and later **Universal Module Definition** (**UMD** – [nodejsdp.link/umd](http://nodejsdp.link/umd)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: When Node.js was created, it was conceived as a server runtime for JavaScript
    with direct access to the underlying filesystem so there was a unique opportunity
    to introduce a different way to manage modules. The idea was not to rely on HTML
    `<script>` tags and resources accessible through URLs. Instead, the choice was
    to rely purely on JavaScript files available on the local filesystem. For its
    module system, Node.js came up with an implementation of the *CommonJS* specification
    (sometimes also referred to as *CJS*, [nodejsdp.link/commonjs](http://nodejsdp.link/commonjs)),
    which was designed to provide a module system for JavaScript in browserless environments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS has been the dominant module system in Node.js since its inception
    and it has become very prominent also in the browser landscape thanks to *module
    bundlers* like Browserify ([nodejsdp.link/browserify](http://nodejsdp.link/browserify))
    and webpack ([nodejsdp.link/webpack](http://nodejsdp.link/webpack)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2015, with the release of *ECMAScript 6* (also called *ECMAScript 2015*
    or *ES2015*), there was finally an official proposal for a standard module system:
    *ESM* or *ECMAScript modules*. ESM brings a lot of innovation in the JavaScript
    ecosystem and, among other things, it tries to bridge the gap between how modules are
    managed on browsers and servers.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 defined only the formal specification for ESM in terms of syntax
    and semantics, but it didn't provide any implementation details. It took different
    browser companies and the Node.js community several years to come up with solid
    implementations of the specification. Node.js ships with stable support for ESM
    starting from version 13.2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the general feeling is that ESM is going to become the
    de facto way to manage JavaScript modules in both the browser and the server landscape.
    The reality today, though, is that the majority of projects are still heavily
    relying on CommonJS and it will take some time for ESM to catch up and eventually
    become the dominant standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: To provide a comprehensive overview of module-related patterns in Node.js, in
    the first part of this chapter, we will discuss them in the context of CommonJS,
    and then, in the second part of the chapter, we will revisit our learnings using
    ESM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to make you comfortable with both module systems,
    but in the rest of the book, we will only be using ESM for our code examples.
    The idea is to encourage you to leverage ESM as much as possible so that your
    code will be more future-proof.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If you are reading this chapter a few years after its publication, you are probably
    not too worried about CommonJS, and you might want to jump straight into the ESM
    part. This is probably fine, but we still encourage you to go through the entire
    chapter, because understanding CommonJS and its characteristics will certainly
    be beneficial in helping you to understand ESM and its strengths in much more
    depth.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The module system and its patterns
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said, modules are the bricks for structuring non-trivial applications
    and the main mechanism to enforce information hiding by keeping private all the
    functions and variables that are not explicitly marked to be exported.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Before getting into the specifics of CommonJS, let's discuss a generic pattern
    that helps with information hiding and that we will be using for building a simple
    module system, which is the **revealing module pattern**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The revealing module pattern
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the bigger problems with JavaScript in the browser is the lack of namespacing. Every
    script runs in the global scope; therefore, internal application code or third-party
    dependencies can pollute the scope while exposing their own pieces of functionality.
    This can be extremely harmful. Imagine, for instance, that a third-party library
    instantiates a global variable called `utils`. If any other library, or the application
    code itself, accidentally overrides or alters `utils`, the code that relies on
    it will likely crash in some unpredictable way. Unpredictable side effects can
    also happen if other libraries or the application code accidentally invoke a function
    of another library meant for internal use only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在浏览器中的一个较大问题是缺乏命名空间。每个脚本都在全局作用域中运行；因此，内部应用程序代码或第三方依赖项可能会污染作用域，同时暴露它们自己的功能片段。这可能会非常有害。例如，想象一下，一个第三方库实例化了一个名为
    `utils` 的全局变量。如果任何其他库或应用程序代码意外地覆盖或修改了 `utils`，依赖于它的代码可能会以某种不可预测的方式崩溃。如果其他库或应用程序代码意外地调用了仅用于内部使用的另一个库的函数，也可能发生不可预测的副作用。
- en: In short, relying on the global scope is a very risky business, especially as
    your application grows and you have to rely more and more on functionality implemented
    by other individuals.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，依赖于全局作用域是非常危险的，尤其是在你的应用程序增长并越来越多地依赖于其他个人实现的功能时。
- en: 'A popular technique to solve this class of problems is called the *revealing
    module pattern*, and it looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这类问题的一个流行技术被称为**揭示模块模式**，其形式如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This pattern leverages a self-invoking function. This type of function is sometimes
    also referred to as **Immediately Invoked Function Expression** (**IIFE**) and
    it is used to create a private scope, exporting only the parts that are meant
    to be public.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式利用了自调用函数。这种类型的函数有时也被称为**立即执行函数表达式**（**IIFE**），它用于创建一个私有作用域，仅导出那些打算公开的部分。
- en: In JavaScript, variables created inside a function are not accessible from the
    outer scope (outside the function). Functions can use the `return` statement to
    selectively propagate information to the outer scope.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数内部创建的变量不能从外部作用域（函数外部）访问。函数可以使用 `return` 语句有选择性地将信息传播到外部作用域。
- en: This pattern is essentially exploiting these properties to keep the private
    information hidden and export only a public-facing API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式本质上是在利用这些属性来隐藏私有信息，并仅导出面向公众的 API。
- en: In the preceding code, the `myModule` variable contains only the exported API,
    while the rest of the module content is practically inaccessible from outside.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`myModule` 变量只包含导出的 API，而模块的其他内容实际上从外部几乎无法访问。
- en: 'The `log` statement is going to print something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 语句将打印出类似以下内容：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This demonstrates that only the `exported` properties are directly accessible
    from `myModule`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明只有 `exported` 属性可以直接从 `myModule` 访问。
- en: As we will see in a moment, the idea behind this pattern is used as a base for
    the CommonJS module system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，这种模式背后的思想被用作 CommonJS 模块系统的基础。
- en: CommonJS modules
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS 模块
- en: CommonJS is the first module system originally built into Node.js. Node.js'
    CommonJS implementation respects the CommonJS specification, with the addition
    of some custom extensions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 是最初内置到 Node.js 中的第一个模块系统。Node.js 的 CommonJS 实现遵循 CommonJS 规范，并增加了一些自定义扩展。
- en: 'Let''s summarize two of the main concepts of the CommonJS specification:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 CommonJS 规范的两个主要概念：
- en: '`require` is a function that allows you to import a module from the local filesystem'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require` 是一个函数，允许你从本地文件系统中导入一个模块'
- en: '`exports` and `module.exports` are special variables that can be used to export
    public functionality from the current module'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports` 和 `module.exports` 是特殊的变量，可以用来从当前模块导出公共功能。'
- en: This information is sufficient for now; we will learn more details and some
    of the nuances of the CommonJS specification in the next few sections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这些信息已经足够了；我们将在接下来的几节中学习更多关于 CommonJS 规范的细节和一些细微差别。
- en: A homemade module loader
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个自制的模块加载器
- en: To understand how CommonJS works in Node.js, let's build a similar system from
    scratch. The code that follows creates a function that mimics a subset of the
    functionality of the original `require()` function of Node.js.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 CommonJS 在 Node.js 中的工作方式，让我们从头开始构建一个类似的系统。下面的代码创建了一个函数，它模拟了 Node.js 原始
    `require()` 函数的一部分功能。
- en: 'Let''s start by creating a function that loads the content of a module, wraps
    it into a private scope, and evaluates it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The source code of a module is essentially wrapped into a function, as it was
    for the revealing module pattern. The difference here is that we pass a list of
    variables to the module, in particular, `module`, `exports`, and `require`. Make
    a note of how the `exports` argument of the wrapping function is initialized with
    the content of `module.exports`, as we will talk about this later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Another important detail to mention is that we are using `readFileSync` to read
    the module's content. While it is generally not recommended to use the synchronous
    version of the filesystem APIs, here it makes sense to do so. The reason for that
    is that loading modules in CommonJS are deliberately synchronous operations. This
    approach makes sure that, if we are importing multiple modules, they (and their
    dependencies) are loaded in the right order. We will talk more about this aspect
    later in the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that this is only an example, and you will rarely need to evaluate
    some source code in a real application. Features such as `eval()` or the functions
    of the `vm` module ([nodejsdp.link/vm](http://nodejsdp.link/vm)) can be easily
    used in the wrong way or with the wrong input, thus opening a system to code injection
    attacks. They should always be used with extreme care or avoided altogether.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the `require()` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous function simulates the behavior of the original `require()` function
    of Node.js, which is used to load a module. Of course, this is just for educational
    purposes and does not accurately or completely reflect the internal behavior of
    the real `require()` function, but it's great to understand the internals of the
    Node.js module system, including how a module is defined and loaded.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'What our homemade module system does is explained as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A module name is accepted as input, and the very first thing that we do is resolve
    the full path of the module, which we call `id`. This task is delegated to `require.resolve()`,
    which implements a specific resolving algorithm (we will talk about it later).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the module has already been loaded in the past, it should be available in the
    cache. If this is the case, we just return it immediately.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the module has never been loaded before, we set up the environment for the
    first load. In particular, we create a `module` object that contains an `exports` property
    initialized with an empty object literal. This object will be populated by the
    code of the module to export its public API.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the first load, the `module` object is cached.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module source code is read from its file and the code is evaluated, as we
    saw before. We provide the module with the `module` object that we just created,
    and a reference to the `require()` function. The module exports its public API
    by manipulating or replacing the `module.exports` object.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the content of `module.exports`, which represents the public API of the module,
    is returned to the caller.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, there is nothing magical behind the workings of the Node.js module
    system. The trick is all in the wrapper we create around a module's source code
    and the artificial environment in which we run it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Defining a module
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By looking at how our custom `require()` function works, we should now be able
    to understand how to define a module. The following code gives us an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The essential concept to remember is that everything inside a module is private
    unless it's assigned to the `module.exports` variable. The content of this variable
    is then cached and returned when the module is loaded using `require()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: module.exports versus exports
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many developers who are not yet familiar with Node.js, a common source of
    confusion is the difference between using `exports` and `module.exports` to expose
    a public API. The code of our custom `require()` function should again clear any
    doubt. The `exports` variable is just a reference to the initial value of `module.exports`.
    We have seen that such a value is essentially a simple object literal created
    before the module is loaded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can only attach new properties to the object referenced
    by the `exports` variable, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Reassigning the `exports` variable doesn''t have any effect, because it doesn''t
    change the content of `module.exports`. It will only reassign the variable itself.
    The following code is therefore wrong:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to export something other than an object literal, such as a function,
    an instance, or even a string, we have to reassign `module.exports` as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The require function is synchronous
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very important detail that we should take into account is that our homemade `require()` function
    is synchronous. In fact, it returns the module contents using a simple direct
    style, and no callback is required. This is true for the original Node.js `require()` function
    too. As a consequence, any assignment to `module.exports` must be synchronous
    as well. For example, the following code is incorrect and it will cause trouble:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The synchronous nature of `require()` has important repercussions on the way
    we define modules, as it limits us to mostly using synchronous code during the definition
    of a module. This is one of the most important reasons why the core Node.js libraries
    offer synchronous APIs as an alternative to most of the asynchronous ones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: If we need some asynchronous initialization steps for a module, we can always
    define and export an uninitialized module that is initialized asynchronously at
    a later time. The problem with this approach, though, is that loading such a module
    using `require()` does not guarantee that it's ready to be used. In *Chapter 11*,
    *Advanced Recipes*, we will analyze this problem in detail and present some patterns
    to solve this issue elegantly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of curiosity, you might want to know that in its early days, Node.js
    used to have an asynchronous version of `require()`, but it was soon removed because
    it was overcomplicating a functionality that was actually only meant to be used
    at initialization time and where asynchronous I/O brings more complexities than
    advantages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The resolving algorithm
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *dependency hell* describes a situation whereby two or more dependencies
    of a program in turn depend on a shared dependency, but require different incompatible
    versions. Node.js solves this problem elegantly by loading a different version
    of a module depending on where the module is loaded from. All the merits of this
    feature go to the way Node.js package managers (such as npm or yarn) organize
    the dependencies of the application, and also to the resolving algorithm used
    in the `require()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now give a quick overview of this algorithm. As we saw, the `resolve()` function
    takes a module name (which we will call `moduleName`) as input and it returns
    the full path of the module. This path is then used to load its code and also
    to identify the module uniquely. The resolving algorithm can be divided into the
    following three major branches:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**File modules**: If `moduleName` starts with `/`, it is already considered
    an absolute path to the module and it''s returned as it is. If it starts with `./`,
    then `moduleName` is considered a relative path, which is calculated starting
    from the directory of the requiring module.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core modules**: If `moduleName` is not prefixed with `/` or `./`, the algorithm
    will first try to search within the core Node.js modules.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package modules**: If no core module is found matching `moduleName`, then
    the search continues by looking for a matching module in the first `node_modules` directory
    that is found navigating up in the directory structure starting from the requiring
    module. The algorithm continues to search for a match by looking into the next `node_modules` directory
    up in the directory tree, until it reaches the root of the filesystem.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For file and package modules, both files and directories can match `moduleName`.
    In particular, the algorithm will try to match the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`<moduleName>.js`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<moduleName>/index.js`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory/file specified in the `main` property of `<moduleName>/package.json`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete, formal documentation of the resolving algorithm can be found at
    [nodejsdp.link/resolve](http://nodejsdp.link/resolve).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The `node_modules` directory is actually where the package managers install
    the dependencies of each package. This means that, based on the algorithm we just
    described, each package can have its own private dependencies. For example, consider
    the following directory structure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, `myApp`, `depB`, and `depC` all depend on `depA`.
    However, they all have their own private version of the dependency! Following
    the rules of the resolving algorithm, using `require(''depA'')` will load a different
    file depending on the module that requires it, for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Calling `require('depA')` from `/myApp/foo.js` will load `/myApp/node_modules/depA/index.js`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `require('depA')` from `/myApp/node_modules/depB/bar.js` will load `/myApp/node_modules/depB/node_modules/depA/index.js`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `require('depA')` from `/myApp/node_modules/depC/foobar.js` will load `/myApp/node_modules/depC/node_modules/depA/index.js`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resolving algorithm is the core part behind the robustness of the Node.js
    dependency management, and it makes it possible to have hundreds or even thousands
    of packages in an application without having collisions or problems of version
    compatibility.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The resolving algorithm is applied transparently for us when we invoke `require()`.
    However, if needed, it can still be used directly by any module by simply invoking `require.resolve()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The module cache
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each module is only loaded and evaluated the first time it is required, since
    any subsequent call of `require()` will simply return the cached version. This
    should be clear by looking at the code of our homemade `require()` function. Caching
    is crucial for performance, but it also has some important functional implications:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: It makes it possible to have cycles within module dependencies
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It guarantees, to some extent, that the same instance is always returned when
    requiring the same module from within a given package
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module cache is exposed via the `require.cache` variable, so it is possible
    to directly access it if needed. A common use case is to invalidate any cached
    module by deleting the relative key in the `require.cache` variable, a practice
    that can be useful during testing but very dangerous if applied in normal circumstances.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many consider circular dependencies an intrinsic design issue, but it is something
    that might actually happen in a real project, so it's useful for us to know at
    least how this works with CommonJS. If we look again at our homemade `require()` function,
    we immediately get a glimpse of how this might work and what its caveats are.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s walk together through an example to see how CommonJS behaves when
    dealing with circular dependencies. Let''s suppose we have the scenario represented
    in *Figure 2.1*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: An example of circular dependency'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'A module called `main.js` requires `a.js` and `b.js`. In turn, `a.js` requires
    `b.js`. But `b.js` relies on `a.js` as well! It''s obvious that we have a circular
    dependency here as module `a.js` requires module `b.js` and module `b.js` requires
    module `a.js`. Let''s have a look at the code of these two modules:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Module `a.js`:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Module `b.js`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s see how these modules are required by `main.js`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run `main.js`, we will see the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This result reveals the caveats of circular dependencies with CommonJS, that
    is, different parts of our application will have a different view of what is exported
    by module `a.js` and module `b.js`, depending on the order in which those dependencies
    are loaded. While both the modules are completely initialized as soon as they
    are required from the module `main.js`, the `a.js` module will be incomplete when
    it is loaded from `b.js`. In particular, its state will be the one that it reached
    the moment `b.js` was required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand in more detail what happens behind the scenes, let''s
    analyze step by step how the different modules are interpreted and how their local
    scope changes along the way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15729_02_02.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: A visual representation of how a dependency loop is managed in
    Node.js'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The processing starts in `main.js`, which immediately requires `a.js`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing that module `a.js` does is set an exported value called `loaded`
    to `false`
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, module `a.js` requires module `b.js`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like `a.js`, the first thing that module `b.js` does is set an exported value
    called `loaded` to `false`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, `b.js` requires `a.js` (cycle)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since `a.js` has already been traversed, its currently exported value is immediately
    copied into the scope of module `b.js`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module `b.js` finally changes the `loaded` value to `true`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that `b.js` has been fully executed, the control returns to `a.js,` which
    now holds a copy of the current state of module `b.js` in its own scope
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step of module `a.js` is to set its `loaded` value to `true`
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module `a.js` is now completely executed and the control returns to `main.js`,
    which now has a copy of the current state of module `a.js` in its internal scope
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`main.js` requires `b.js`, which is immediately loaded from cache'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current state of module `b.js` is copied into the scope of module `main.js`
    where we can finally see the complete picture of what the state of every module
    is
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we said, the issue here is that module `b.js` has a partial view of module
    `a.js`, and this partial view gets propagated over when `b.js` is required in
    `main.js`. This behavior should spark an intuition which can be confirmed if we
    swap the order in which the two modules are required in `main.js`. If you actually
    try this, you will see that this time it will be the `a.js` module that will receive
    an incomplete version of `b.js`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We understand now that this can become quite a fuzzy business if we lose control
    of which module is loaded first, which can happen quite easily if the project
    is big enough.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will see how ESM can deal with circular dependencies
    in a more effective way. Meanwhile, if you are using CommonJS, be very careful
    about this behavior and the way it can affect your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss some patterns to define modules in Node.js.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Module definition patterns
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module system, besides being a mechanism for loading dependencies, is also
    a tool for defining APIs. Like any other problem related to API design, the main
    factor to consider is the balance between private and public functionality. The
    aim is to maximize information hiding and API usability, while balancing these
    with other software qualities, such as *extensibility* and *code reuse*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will analyze some of the most popular patterns for defining
    modules in Node.js, such as named exports, exporting functions, classes and instances,
    and monkey patching. Each one has its own balance of information hiding, extensibility,
    and code reuse.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Named exports
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most basic method for exposing a public API is using **named exports**,
    which involves assigning the values we want to make public to properties of the
    object referenced by `exports` (or `module.exports`). In this way, the resulting
    exported object becomes a container or namespace for a set of related functionalities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a module implementing this pattern:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The exported functions are then available as properties of the loaded module,
    as shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Most of the Node.js core modules use this pattern. However, the CommonJS specification
    only allows the use of the `exports` variable to expose public members. Therefore,
    the named exports pattern is the only one that is really compatible with the CommonJS
    specification. The use of `module.exports` is an extension provided by Node.js
    to support a broader range of module definition patterns, which we are going to
    see next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a function
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most popular module definition patterns consists of reassigning
    the whole `module.exports` variable to a function. The main strength of this pattern
    is the fact that it allows you to expose only a single functionality, which provides
    a clear entry point for the module, making it simpler to understand and use; it
    also honors the principle of *small surface* area very well. This way of defining
    modules is also known in the community as the **substack pattern**, after one
    of its most prolific adopters, James Halliday (nickname substack – [https://github.com/substack](https://github.com/substack)).
    Have a look at this pattern in the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A possible extension of this pattern is using the exported function as a namespace
    for other public APIs. This is a very powerful combination because it still gives
    the module the clarity of a single entry point (the main exported function) and
    at the same time it allows us to expose other functionalities that have secondary
    or more advanced use cases. The following code shows us how to extend the module
    we defined previously by using the exported function as a namespace:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code demonstrates how to use the module that we just defined:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Even though exporting just a function might seem like a limitation, in reality,
    it''s a perfect way to put the emphasis on a single functionality, the most important
    one for the module, while giving less visibility to secondary or internal aspects,
    which are instead exposed as properties of the exported function itself. The modularity
    of Node.js heavily encourages the adoption of the **single-responsibility principle** (**SRP**):
    every module should have responsibility over a single functionality and that responsibility
    should be entirely encapsulated by the module.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a class
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A module that exports a class is a specialization of a module that exports
    a function. The difference is that with this new pattern we allow the user to
    create new instances using the constructor, but we also give them the ability
    to extend its prototype and forge new classes. The following is an example of
    this pattern:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, we can use the preceding module as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Exporting a class still provides a single entry point for the module, but compared
    to the substack pattern, it exposes a lot more of the module internals. On the
    other hand, it allows much more power when it comes to extending its functionality.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Exporting an instance
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can leverage the caching mechanism of `require()` to easily define stateful instances
    created from a constructor or a factory, which can be shared across different
    modules. The following code shows an example of this pattern:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This newly defined module can then be used as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because the module is cached, every module that requires the `logger` module
    will actually always retrieve the same instance of the object, thus sharing its
    state. This pattern is very much like creating a **singleton**. However, it does
    not guarantee the uniqueness of the instance across the entire application, as
    it happens in the traditional singleton pattern. When analyzing the resolving
    algorithm, we have seen that a module might be installed multiple times inside
    the dependency tree of an application. This results in multiple instances of the
    same logical module, all running in the context of the same Node.js application.
    We will analyze the Singleton pattern and its caveats in more detail in *Chapter
    7*, *Creational Design Patterns*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting detail of this pattern is that it does not preclude the opportunity
    to create new instances, even if we are not explicitly exporting the class. In
    fact, we can rely on the `constructor` property of the exported instance to construct
    a new instance of the same type:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, by using `logger.constructor()`, we can instantiate new `Logger`
    objects. Note that this technique must be used with caution or avoided altogether.
    Consider that, if the module author decided not to export the class explicitly,
    they probably wanted to keep this class private.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Modifying other modules or the global scope
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A module can even export nothing. This can seem a bit out of place; however,
    we should not forget that a module can modify the global scope and any object
    in it, including other modules in the cache. Please note that these are in general
    considered bad practices, but since this pattern can be useful and safe under
    some circumstances (for example, for testing) and it's sometimes used in real-life
    projects, it's worth knowing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We said that a module can modify other modules or objects in the global scope;
    well, this is called **monkey patching**. It generally refers to the practice
    of modifying the existing objects at runtime to change or extend their behavior
    or to apply temporary fixes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows us how we can add a new function to another module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using our new `patcher` module is as easy as writing the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The technique described here can be very dangerous to use. The main concern
    is that having a module that modifies the global namespace or other modules is
    an operation with *side effects*. In other words, it affects the state of entities
    outside their scope, which can have consequences that aren't easily predictable,
    especially when multiple modules interact with the same entities. Imagine having
    two different modules trying to set the same global variable, or modifying the
    same property of the same module. The effects can be unpredictable (which module
    wins?), but most importantly it would have repercussions on the entire application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: So, again use this technique with care and make sure you understand all the
    possible side effects while doing so.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If you want a real-life example of how this can be useful, have a look at `nock`
    ([nodejsdp.link/nock](http://nodejsdp.link/nock)), a module that allows you to
    mock HTTP responses in your tests. The way `nock` works is by monkey patching
    the Node.js `http` module and by changing its behavior so that it will provide
    the mocked response rather than issuing a real HTTP request. This allows our unit
    test to run without hitting the actual production HTTP endpoints, something that's
    very convenient when writing tests for code that relies on third-party APIs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a quite complete understanding of CommonJS and
    some of the patterns that are generally used with it. In the next section, we
    will explore ECMAScript modules, also known as ESM.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'ESM: ECMAScript modules'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript modules (also known as ES modules or ESM) were introduced as part
    of the ECMAScript 2015 specification with the goal to give JavaScript an official
    module system suitable for different execution environments. The ESM specification
    tries to retain some good ideas from previous existing module systems like CommonJS
    and AMD. The syntax is very simple and compact. There is support for cyclic dependencies
    and the possibility to load modules asynchronously.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The most important differentiator between ESM and CommonJS is that ES modules
    are *static*, which means that imports are described at the top level of every
    module and outside any control flow statement. Also, the name of the imported
    modules cannot be dynamically generated at runtime using expressions, only constant
    strings are allowed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following code wouldn''t be valid when using ES modules:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'While in CommonJS, it is perfectly fine to write something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At a first glance, this characteristic of ESM might seem an unnecessary limitation,
    but in reality, having static imports opens up a number of interesting scenarios
    that are not practical with the dynamic nature of CommonJS. For instance, static
    imports allow the static analysis of the dependency tree, which allows optimizations
    such as dead code elimination (tree shaking) and more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Using ESM in Node.js
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js will consider every `.js` file to be written using the CommonJS syntax
    by default; therefore, if we use the ESM syntax inside a `.js` file, the interpreter
    will simply throw an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to tell the Node.js interpreter to consider a given
    module as an ES module rather than a CommonJS module:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Give the module file the extension `.mjs`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add to the nearest parent `package.json` a field called "`type"` with a value
    of `"module"`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the rest of this book and in the code examples provided, we will
    keep using the `.js` extension to keep the code more easily accessible to most
    text editors, so if you are copying and pasting examples straight from the book,
    make sure that you also create a `package.json` file with the `"type":"module"`
    entry.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the ESM syntax.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Named exports and imports
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ESM allows us to export functionality from a module through the `export` keyword.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that ESM uses the singular word `export` as opposed to the plural (`exports`
    and `module.exports`) used by CommonJS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In an ES module, everything is private by default and only exported entities
    are publicly accessible from other modules.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export` keyword can be used in front of the entities that we want to make
    available to the module users. Let''s see an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to import entities from a module we can use the `import` keyword.
    The syntax is quite flexible, and it allows us to import one or more entities
    and even to rename imports. Let''s see some examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we are using the `*` syntax (also called **namespace import**)
    to import all the members of the module and assign them to the local `loggerModule`
    variable. This example will output something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, all the entities exported in our module are now accessible in
    the `loggerModule` namespace. For instance, we could refer to the `log()` function
    through `loggerModule.log`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to note that, as opposed to CommonJS, with ESM we have to
    specify the file extension of the imported modules. With CommonJS we can use either
    `./logger` or `./logger.js`, with ESM we are forced to use `./logger.js`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using a large module, most often we don''t want to import all of
    its functionality, but only one or few entities from it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to import more than one entity, this is how we would do that:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we use this type of `import` statement, the entities are imported into
    the current scope, so there is a risk of a name clash. The following code, for
    example, would not work:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we try to execute the preceding snippet, the interpreter fails with the
    following error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In situations like this one, we can resolve the clash by renaming the imported
    entity with the `as` keyword:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach can be particularly useful when the clash is generated by importing
    two entities with the same name from different modules, and therefore changing
    the original names is outside the consumer's control.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Default exports and imports
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One widely used feature of CommonJS is the ability to export a single unnamed
    entity through the assignment of `module.exports`. We saw that this is very convenient
    as it encourages module developers to follow the single-responsibility principle
    and expose only one clear interface. With ESM, we can do something similar through
    what''s called a **default export**. A default export makes use of the `export
    default` keywords and it looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the name `Logger` is ignored, and the entity exported is registered
    under the name `default`. This exported name is handled in a special way, and
    it can be imported as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The difference with named ESM imports is that here, since the default export
    is considered unnamed, we can import it and at the same time assign it a local
    name of our choice. In this example, we can replace `MyLogger` with anything else
    that makes sense in our context. This is very similar to what we do with CommonJS
    modules. Note also that we don't have to wrap the import name around brackets
    or use the `as` keyword when renaming.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, a default export is equivalent to a named export with `default`
    as the name. We can easily verify this statement by running the following snippet
    of code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When executed, the previous code will print something like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One thing that we cannot do, though, is import the default entity explicitly.
    In fact, something like the following will fail:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The execution will fail with a `SyntaxError: Unexpected reserved word` error.
    This happens because the `default` keyword cannot be used as a variable name.
    It is valid as an object attribute, so in the previous example, it is okay to
    use `loggerModule.default`, but we can''t have a variable named `default` directly
    in the scope.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Mixed exports
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to mix named exports and a default export within an ES module.
    Let''s have a look at an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code is exporting the `log()` function as a default export and
    a named export for a function called `info()`. Note that `info()` can reference
    `log()` internally. It would not be possible to replace the call to `log()` with
    `default()` to do that, as it would be a syntax error (Unexpected token `default`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to import both the default export and one or more named exports,
    we can do it using the following format:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, we are importing the default export from `logger.js`
    as `mylog` and also the named export `info`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now discuss some key details and differences between the default export
    and named exports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Named exports are explicit. Having predetermined names allows IDEs to support
    the developer with automatic imports, autocomplete, and refactoring tools. For
    instance, if we type `writeFileSync`, the editor might automatically add `import
    { writeFileSync } from 'fs'` at the beginning of the current file. Default exports,
    on the contrary, make all these things more complicated as a given functionality
    could have different names in different files, so it's harder to make inferences
    on which module might provide a given functionality based only on a given name.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default export is a convenient mechanism to communicate what is the single
    most important functionality for a module. Also, from the perspective of the user,
    it can be easier to import the obvious piece of functionality without having to
    know the exact name of the binding.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some circumstances, default exports might make it harder to apply dead code
    elimination (tree shaking). For example, a module could provide only a default
    export, which is an object where all the functionality is exposed as properties
    of such an object. When we import this default object, most module bundlers will
    consider the entire object being used and they won't be able to eliminate any
    unused code from the exported functionality.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it is generally considered good practice to stick with named
    exports, especially when you want to expose more than one functionality, and only use
    default exports if it's one clear functionality you want to export.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: This is not a hard rule and there are notable exceptions to this suggestion.
    For instance, all Node.js core modules have both a default export and a number
    of named exports. Also, React ([nodejsdp.link/react](http://nodejsdp.link/react))
    uses mixed exports.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Consider carefully what the best approach for your specific module is and what
    you want the developer experience to be for the users of your module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Module identifiers
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Module identifiers** (also called *module specifiers*) are the different
    types of values that we can use in our `import` statements to specify the location
    of the module we want to load.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have seen only relative paths, but there are several other possibilities
    and some nuances to keep in mind. Let''s list all the possibilities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '*Relative specifiers* like `./logger.js` or `../logger.js`. They are used to
    refer to a path relative to the location of the importing file.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Absolute specifiers* like `file:///opt/nodejs/config.js`. They refer directly
    and explicitly to a full path. Note that this is the only way with ESM to refer
    to an absolute path for a module, using a `/` or a `//` prefix won''t work. This
    is a significant difference with CommonJS.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bare specifiers* are identifiers like `fastify` or `http`, and they represent
    modules available in the `node_modules` folder and generally installed through
    a package manager (such as npm) or available as core Node.js modules.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deep import specifiers* like `fastify/lib/logger.js`, which refer to a path
    within a package in `node_modules` (`fastify`, in this case).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In browser environments, it is possible to import modules directly by specifying
    the module URL, for instance, [https://unpkg.com/lodash](https://unpkg.com/lodash).
    This feature is not supported by Node.js.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Async imports
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen in the previous section, the `import` statement is static and
    therefore subject to two important limitations:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: A module identifier cannot be constructed at runtime
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module imports are declared at the top level of every file and they cannot be
    nested within control flow statements
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some use cases when these limitations can become a little bit too
    restrictive. Imagine, for instance, if we have to import a specific translation
    module for the current user language, or a variation of a module that depends
    on the user's operating system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Also, what if we want to load a given module, which might be particularly heavy,
    only if the user is accessing the piece of functionality that requires that module?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To allow us to overcome these limitations ES modules provides *async imports*
    (also called *dynamic imports*).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Async imports can be performed at runtime using the special `import()` operator.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The `import()` operator is syntactically equivalent to a function that takes
    a module identifier as an argument and it returns a promise that resolves to a
    module object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about promises in *Chapter 5*, *Asynchronous Control Flow
    Patterns with Promises and Async/Await*, so don't worry too much about understanding
    all the nuances of the specific promise syntax for now.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The module identifier can be any module identifier supported by static imports
    as discussed in the previous section. Now, let's see how to use dynamic imports
    with a simple example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We want to build a command line application that can print "Hello World" in
    different languages. In the future, we will probably want to support many more
    phrases and languages, so it makes sense to have one file with the translations
    of all the user-facing strings for each supported language.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some example modules for some of the languages we want to support:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let''s create the main script that takes a language code from the command
    line and prints "Hello World" in the selected language:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个主脚本，它从命令行接收一个语言代码，并以所选语言打印“Hello World”：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first part of the script is quite simple. What we do there is:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一个部分相当简单。我们在那里做的事情是：
- en: Define a list of supported languages.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个支持的语言列表。
- en: Read the selected language from the first argument passed in the command line.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行传入的第一个参数中读取所选语言。
- en: Finally, we handle the case where the selected language is not supported.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理所选语言不受支持的情况。
- en: 'The second part of the code is where we actually use dynamic imports:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二部分是我们实际使用动态导入的地方：
- en: First of all, we dynamically build the name of the module we want to import
    based on the selected language. Note that the module name needs to be a relative
    path to the module file, that's why we are prepending `./` to the filename.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们根据选定的语言动态构建我们想要导入的模块的名称。注意，模块名称需要是模块文件的相对路径，这就是为什么我们在文件名前添加`./`的原因。
- en: We use the `import()` operator to trigger the dynamic import of the module.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`import()`运算符来触发模块的动态导入。
- en: The dynamic import happens asynchronously, so we can use the `.then()` hook
    on the returned promise to get notified when the module is ready to be used. The
    function passed to `then()` will be executed when the module is fully loaded and
    `strings` will be the module namespace imported dynamically. After that, we can
    access `strings.HELLO` and print its value to the console.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态导入是异步发生的，因此我们可以使用返回的promise上的`.then()`钩子来通知模块何时准备好使用。传递给`then()`的函数将在模块完全加载后执行，`strings`将是动态导入的模块命名空间。之后，我们可以访问`strings.HELLO`并将其值打印到控制台。
- en: 'Now we can execute this script like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样执行这个脚本：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And we should see *Ciao mondo* being printed to our console.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到*Ciao mondo*被打印到我们的控制台。
- en: Module loading in depth
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块加载深入探讨
- en: To understand how ESM actually works and how it can deal effectively with circular
    dependencies, we have to deep dive a little bit more into how JavaScript code
    is parsed and evaluated when using ES modules.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解ESM（ECMAScript模块）实际上是如何工作的以及它如何有效地处理循环依赖，我们必须更深入地了解在使用ES模块时JavaScript代码是如何被解析和评估的。
- en: In this section, we will learn how ECMAScript modules are loaded, we will present
    the idea of read-only live bindings, and, finally, we will discuss an example
    with circular dependencies.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何加载ECMAScript模块，我们将介绍只读活绑定（readonly live bindings）的概念，最后，我们将讨论一个具有循环依赖的例子。
- en: Loading phases
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载阶段
- en: The goal of the interpreter is to build a graph of all the necessary modules
    (a **dependency graph**).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的目标是构建所有必要模块的图（一个**依赖图**）。
- en: In generic terms, a **dependency graph** can be defined as a **directed graph**
    ([nodejsdp.link/directed-graph](http://nodejsdp.link/directed-graph)) representing
    the dependencies of a group of objects. In the context of this section, when we
    refer to a dependency graph, we want to indicate the dependency relationship between
    ECMAScript modules. As we will see, using a dependency graph allows us to determine
    the order in which all the necessary modules should be loaded in a given project.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用术语中，**依赖图**可以被定义为表示一组对象依赖关系的**有向图**（[nodejsdp.link/directed-graph](http://nodejsdp.link/directed-graph)）。在本节中，当我们提到依赖图时，我们想要表明ECMAScript模块之间的依赖关系。正如我们将看到的，使用依赖图允许我们确定在给定项目中所有必要模块应该加载的顺序。
- en: Essentially, the dependency graph is needed by the interpreter to figure out
    how modules depend on each other and in what order the code needs to be executed.
    When the `node` interpreter is launched, it gets passed some code to execute,
    generally in the form of a JavaScript file. This file is the starting point for
    the dependency resolution, and it is called the **entry point**. From the entry
    point, the interpreter will find and follow all the `import` statements recursively
    in a depth-first fashion, until all the necessary code is explored and then evaluated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，依赖图是解释器用来确定模块之间如何相互依赖以及代码需要执行的顺序的。当`node`解释器启动时，它被传递一些要执行的代码，通常是JavaScript文件的形式。这个文件是依赖解析的起点，被称为**入口点**。从入口点开始，解释器将以深度优先的方式递归地找到并跟随所有的`import`语句，直到所有必要的代码都被探索和评估。
- en: 'More specifically, this process happens in three separate phases:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这个过程分为三个独立阶段：
- en: '**Phase 1 - Construction (or parsing)**: Find all the imports and recursively
    load the content of every module from the respective file.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段 - 构建（或解析）**：找到所有导入，并递归地加载每个模块从相应文件的内容。'
- en: '**Phase 2 - Instantiation**: For every exported entity, keep a named reference
    in memory, but don''t assign any value just yet. Also, references are created
    for all the `import` and `export` statements tracking the dependency relationship
    between them (**linking**). No JavaScript code has been executed at this stage.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段 - 实例化**：对于每个导出实体，在内存中保留一个命名引用，但暂时不分配任何值。此外，为所有`import`和`export`语句创建引用，跟踪它们之间的依赖关系（**链接**）。在此阶段尚未执行任何JavaScript代码。'
- en: '**Phase 3 - Evaluation**: Node.js finally executes the code so that all the
    previously instantiated entities can get an actual value. Now running the code
    from the entry point is possible because all the blanks have been filled.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段 - 评估**：Node.js最终执行代码，以便所有之前实例化的实体都可以获得实际值。现在可以从入口点运行代码，因为所有空白都已经填满。'
- en: In simple terms, we could say that Phase 1 is about finding all the dots, Phase
    2 connects those creating paths, and, finally, Phase 3 walks through the paths
    in the right order.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以这样说，第一阶段是关于找到所有点，第二阶段是连接这些点以创建路径，最后，第三阶段按照正确的顺序遍历这些路径。
- en: At first glance, this approach doesn't seem very different from what CommonJS
    does, but there's a fundamental difference. Due to its dynamic nature, CommonJS
    will execute all the files while the dependency graph is explored. We have seen
    that every time a new `require` statement is found, all the previous code has
    already been executed. This is why you can use `require` even within `if` statements
    or loops, and construct module identifiers from variables.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这种方法似乎与CommonJS没有太大区别，但实际上有一个根本的区别。由于它的动态性，CommonJS会在探索依赖图时执行所有文件。我们已经看到，每次发现新的`require`语句时，所有之前的代码都已经执行。这就是为什么你可以在`if`语句或循环中使用`require`，并从变量中构造模块标识符的原因。
- en: In ESM, these three phases are totally separate from each other, no code can
    be executed until the dependency graph has been fully built, and therefore module
    imports and exports have to be static.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESM中，这三个阶段完全相互独立，没有代码可以在完全构建依赖图之前执行，因此模块导入和导出必须是静态的。
- en: Read-only live bindings
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读的实时绑定
- en: Another fundamental characteristic of ES modules, which helps with cyclic dependencies,
    is the idea that imported modules are effectively *read-only live bindings* to
    their exported values.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ES模块的另一个基本特征，有助于解决循环依赖，是这样一个想法：导入的模块对其导出值是有效的*只读实时绑定*。
- en: 'Let''s clarify what this means with a simple example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来澄清这意味着什么：
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This module exports two values: a simple integer counter called `count` and
    an `increment` function that increases the counter by one.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块导出两个值：一个简单的整数计数器，称为`count`，以及一个`increment`函数，该函数将计数器增加一。
- en: 'Let''s now write some code that uses this module:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一些使用此模块的代码：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What we can see in this code is that we can read the value of `count` at any
    time and change it using the `increment()` function, but as soon as we try to
    mutate the `count` variable directly, we get an error as if we were trying to
    mutate a `const` binding.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以看到我们可以在任何时候读取`count`的值，并使用`increment()`函数来更改它，但当我们尝试直接修改`count`变量时，我们会得到一个错误，就像我们试图修改一个`const`绑定一样。
- en: This proves that when an entity is imported in the scope, the binding to its
    original value cannot be changed (*read-only binding*) unless the bound value
    changes within the scope of the original module itself (*live binding*), which
    is outside the direct control of the consumer code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了当一个实体在作用域中被导入时，其原始值的绑定不能被更改（*只读绑定*），除非在原始模块的作用域内更改绑定值（*实时绑定*），这超出了消费者代码的直接控制。
- en: This approach is fundamentally different from CommonJS. In fact, in CommonJS,
    the entire `exports` object is copied (shallow copy) when required from a module.
    This means that, if the value of primitive variables like numbers or string is
    changed at a later time, the requiring module won't be able to see those changes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与CommonJS在本质上不同。事实上，在CommonJS中，当从模块中请求时，整个`exports`对象被复制（浅复制）。这意味着，如果原始变量（如数字或字符串）的值在以后被更改，请求模块将无法看到这些更改。
- en: Circular dependency resolution
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环依赖解决
- en: 'Now to close the circle, let''s reimplement the circular dependency example
    we saw in the *CommonJS modules* section using the ESM syntax:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_03.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: An example scenario with circular dependencies'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the modules `a.js` and `b.js` first:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And now let''s see how to import those two modules in our `main.js` file (the
    entry point):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that this time we are not using `JSON.stringify` because that will fail
    with a `TypeError: Converting circular structure to JSON`, since there''s an actual
    circular reference between `a.js` and `b.js`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run `main.js`, we will see the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The interesting bit here is that the modules `a.js` and `b.js` have a complete
    picture of each other, unlike what would happen with CommonJS, where they would
    only hold partial information of each other. We can see that because all the `loaded`
    values are set to `true`. Also, `b` within `a` is an actual reference to the same
    `b` instance available in the current scope, and the same goes for `a` within
    `b`. That's the reason why we cannot use `JSON.stringify()` to serialize these
    modules. Finally, if we swap the order of the imports for the modules `a.js` and
    `b.js`, the final outcome does not change, which is another important difference
    in comparison with how CommonJS works
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: It's worth spending some more time observing what happens in the three phases
    of the module resolution (parsing, instantiation, and evaluation) for this specific
    example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 1: Parsing'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During the parsing phase, the code is explored starting from the entry point
    (`main.js`). The interpreter looks only for `import` statements to find all the
    necessary modules and to load the source code from the module files. The dependency
    graph is explored in a depth-first fashion, and every module is visited only once.
    This way the interpreter builds a view of the dependencies that looks like a tree
    structure, as shown in *Figure 2.4*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-steps.png](img/B15729_02_04.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Parsing of cyclic dependencies with ESM'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the example in *Figure 2.4*, let''s discuss the various steps of the
    parsing phase:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: From `main.js`, the first import found leads us straight into `a.js`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `a.js` we find an import pointing to `b.js`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `b.js`, we also have an import back to `a.js` (our cycle), but since `a.js`
    has already been visited, this path is not explored again.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, the exploration starts to wind back: `b.js` doesn''t have other
    imports, so we go back to `a.js`; `a.js` doesn''t have other `import` statements
    so we go back to `main.js`. Here we find another import pointing to `b.js`, but
    again this module has been explored already, so this path is ignored.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, our depth-first visit of the dependency graph has been completed
    and we have a linear view of the modules, as shown in *Figure 2.5*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-result.png](img/B15729_02_05.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: A linear view of the module graph where cycles have been removed'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: This particular view is quite simple. In more realistic scenarios with a lot
    more modules, the view will look more like a tree structure.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase 2: Instantiation'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the instantiation phase, the interpreter walks the tree view obtained from
    the previous phase from the bottom to the top. For every module, the interpreter
    will look for all the exported properties first and build out a map of the exported
    names in memory:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-exports.png](img/B15729_02_06.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A visual representation of the instantiation phase'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.6* describes the order in which every module is instantiated:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter starts from `b.js` and discovers that the module exports `loaded`
    and `a`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the interpreter moves to `a.js`, which exports `loaded` and `b`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it moves to `main.js`, which does not export any functionality.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that, in this phase, the exports map keeps track of the exported names
    only; their associated values are considered uninitialized for now.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this sequence of steps, the interpreter will do another pass to link
    the exported names to the modules importing them, as shown in *Figure 2.7*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-imports.png](img/B15729_02_07.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Linking exports with imports across modules'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe what we see in *Figure 2.7* through the following steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Module `b.js` will link the exports from `a.js`, referring to them as `aModule`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In turn, `a.js` will link to all the exports from `b.js`, referring to them
    as `bModule`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `main.js` will import all the exports in `b.js`, referring to them
    as `b`; similarly, it will import everything from `a.js`, referring to them as
    `a`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, it's important to note that all the values are still uninitialized. In
    this phase, we are only linking references to values that will be available at
    the end of the next phase.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Phase 3: Evaluation'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last step is the evaluation phase. In this phase, all the code in every
    file is finally executed. The execution order is again bottom-up respecting the
    post-order depth-first visit of our original dependency graph. With this approach,
    `main.js` is the last file to be executed. This way, we can be sure that all the
    exported values have been initialized before we start executing our main business
    logic:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-evaluation.png](img/B15729_02_08.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: A visual representation of the evaluation phase'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Following along from the diagram in *Figure 2.8*, this is what happens:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The execution starts from `b.js` and the first line to be evaluated initializes
    the `loaded` export to `false` for the module.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, here the exported property `a` gets evaluated. This time, it will
    be evaluated to a reference to the module object representing module `a.js`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the `loaded` property gets changed to `true`. At this point, we
    have fully evaluated the state of the exports for module `b.js`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the execution moves to `a.js`. Again, we start by setting `loaded` to `false`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the `b` export is evaluated to a reference to module `b.js`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `loaded` property is changed to `true`. Now we have finally evaluated
    all the exports for `a.js` as well.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all these steps, the code in `main.js` can be executed, and at this point,
    all the exported properties are fully evaluated. Since imported modules are tracked
    as references, we can be sure every module has an up-to-date picture of the other
    modules, even in the presence of circular dependencies.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Modifying other modules
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw that entities imported through ES modules are *read-only live bindings*,
    and therefore we cannot reassign them from an external module.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There's a caveat, though. It is true that we can't change the bindings of the
    default export or named exports of an existing module from another module, but,
    if one of these bindings is an object, we can still mutate the object itself by
    reassigning some of the object properties.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'This caveat can give us enough freedom to alter the behavior of other modules.
    To demonstrate this idea, let''s write a module that can alter the behavior of
    the core `fs` module so that it prevents the module from accessing the filesystem
    and returns mocked data instead. This kind of module is something that could be
    useful while writing tests for a component that relies on the filesystem:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s review the preceding code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is import the default export of the `fs` module. We will
    get back to this in a second, for now, just keep in mind that the default export
    of the `fs` module is an object that contains a collection of functions that allows
    us to interact with the filesystem.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to replace the `readFile()` function with a mock implementation. Before
    doing that, we save a reference to the original implementation. We also declare
    a `mockedResponse` value that we will be using later.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function `mockedReadFile()` is the actual mocked implementation that we
    want to use to replace the original implementation. This function invokes the
    callback with the current value of `mockedResponse`. Note that this is a simplified
    implementation; the real function accepts an optional `options` argument before
    the callback argument and is able to handle different types of encoding.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exported `mockEnable()` function can be used to activate the mocked functionality.
    The original implementation will be swapped with the mocked one. The mocked implementation
    will return the same value passed here through the `respondWith` argument.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the exported `mockDisable()` function can be used to restore the original
    implementation of the `fs.readFile()` function.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s see a simple example that uses this module:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s discuss step by step what happens in this example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we do is import the default export of the `fs` module.
    Again, note that we are importing specifically the default export exactly as we
    did in our `mock-read-file.js` module, but more on this later.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we enable the mock functionality. We want, for every file read, to simulate
    that the file contains the string "Hello World."
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we read a file using a fake path. This code will print "Hello World"
    as it will be using the mocked version of the `readFile()` function. Note that,
    after calling this function, we restore the original implementation by calling
    `mockDisable()`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach works, but it is very fragile. In fact, there are a number of
    ways in which this may not work.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `mock-read-file.js` side, we could have tried the two following imports
    for the `fs` module:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: or
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both of them are valid imports because the `fs` module exports all the filesystem
    functions as named exports (other than a default export which is an object with
    the same collection of functions as attributes).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain issues with the preceding two `import` statements:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: We would get a read-only live binding into the `readFile()` function, and therefore,
    we would be unable to mutate it from an external module. If we try these approaches,
    we will get an error when trying to reassign `readFile()`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another issue is on the consumer side within our `main.js`, where we could use
    these two alternative import styles as well. In this case, we won't end up using
    the mocked functionality, and therefore the code will trigger an error while trying
    to read a nonexistent file.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason why using one of the two `import` statements mentioned above would
    not work is because our mocking utility is altering only the copy of the `readFile()`
    function that is registered inside the object exported as the default export,
    but not the one available as a named export at the top level of the module.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: This particular example shows us how monkey patching could be much more complicated
    and unreliable in the context of ESM. For this reason, testing frameworks such
    as Jest ([nodejsdp.link/jest](http://nodejsdp.link/jest)) provide special functionalities
    to be able to mock ES modules more reliably ([nodejsdp.link/jest-mock](http://nodejsdp.link/jest-mock)).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Another approach that can be used to mock modules is to rely on the hooks available
    in a special Node.js core module called `module` ([nodejsdp.link/module-doc](http://nodejsdp.link/module-doc)).
    One simple library that takes advantage of this module is `mocku` ([nodejsdp.link/mocku](http://nodejsdp.link/mocku)).
    Check out its source code if you are curious.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use the `syncBuiltinESMExports()` function from the `module`
    package. When this function is invoked, the value of the properties in the default
    exports object gets mapped again into the equivalent named exports, effectively
    allowing us to propagate any external change applied to the module functionality
    even to named exports:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We could use this to make our small filesystem mocking utility a little bit
    more flexible by invoking the `syncBuiltinESMExports()` function after we enable
    the mock or after we restore the original functionality.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Note that `syncBuiltinESMExports()` works only for built-in Node.js modules
    like the `fs` module in our example.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our exploration of ESM. At this point, we should be able to appreciate
    how ESM works, how it loads modules, and how it deals with cyclic dependencies.
    To close this chapter, we are now ready to discuss some key differences and some
    interesting interoperability techniques between CommonJS and ECMAScript modules.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: ESM and CommonJS differences and interoperability
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already mentioned several important differences between ESM and CommonJS,
    such as having to explicitly specify file extensions in imports with ESM, while
    file extensions are totally optional with the CommonJS `require` function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Let's close this chapter by discussing some other important differences between
    ESM and CommonJS and how the two module systems can work together when necessary.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ESM runs in strict mode
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES modules run implicitly in strict mode. This means that we don't have to explicitly
    add the `"use strict"` statements at the beginning of every file. Strict mode
    cannot be disabled; therefore, we cannot use undeclared variables or the `with`
    statement or have other features that are only available in non-strict mode, but
    this is definitely a good thing, as strict mode is a safer execution mode.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious to find out more about the differences between the two modes,
    you can check out a very detailed article on MDN Web Docs ([https://nodejsdp.link/strict-mode](https://nodejsdp.link/strict-mode)).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Missing references in ESM
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ESM, some important CommonJS references are not defined. These include `require`,
    `exports`, `module.exports`, `__filename`, and `__dirname`. If we try to use any
    of them within an ES module, since it also runs in strict mode, we will get a
    `ReferenceError`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We already discussed at length the meaning of `exports` and `module` in CommonJS;
    `__filename` and `__dirname` represent the absolute path to the current module
    file and the absolute path to its parent folder. Those special variables can be
    very useful when we need to build a path relative to the current file.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'In ESM, it is possible to get a reference to the current file URL by using
    the special object `import.meta`. Specifically, `import.meta.url` is a reference
    to the current module file in a format similar to `file:///path/to/current_module.js`.
    This value can be used to reconstruct `__filename` and `__dirname` in the form
    of absolute paths:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ESM 中，可以使用特殊对象 `import.meta` 来获取当前文件 URL 的引用。具体来说，`import.meta.url` 是对当前模块文件的引用，其格式类似于
    `file:///path/to/current_module.js`。此值可以用来以绝对路径的形式重建 `__filename` 和 `__dirname`：
- en: '[PRE57]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is also possible to recreate the `require()` function as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以按照以下方式重新创建 `require()` 函数：
- en: '[PRE58]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now we can use `require()` to import functionality coming from CommonJS modules
    in the context of ES modules.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `require()` 在 ES 模块的上下文中导入来自 CommonJS 模块的功能。
- en: Another interesting difference is the behavior of the `this` keyword.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的不同之处在于 `this` 关键字的行怍。
- en: 'In the global scope of an ES module, `this` is `undefined`, while in CommonJS,
    `this` is a reference to `exports`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES 模块的全局作用域中，`this` 是 `undefined`，而在 CommonJS 中，`this` 是对 `exports` 的引用：
- en: '[PRE59]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Interoperability
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互操作性
- en: 'We discussed in the previous section how to import CommonJS modules in ESM
    by using the `module.createRequire` function. It is also possible to import CommonJS
    modules from ESM by using the standard `import` syntax. This is only limited to
    default exports, though:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何使用 `module.createRequire` 函数在 ESM 中导入 CommonJS 模块。也可以使用标准的 `import`
    语法从 ESM 中导入 CommonJS 模块。但这仅限于默认导出：
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Unfortunately, it is not possible to import ES modules from CommonJS modules.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，从 CommonJS 模块中导入 ES 模块是不可能的。
- en: 'Also, ESM cannot import JSON files directly as modules, a feature that is used
    quite frequently with CommonJS. The following `import` statement will fail:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ESM 不能直接将 JSON 文件作为模块导入，这是 CommonJS 中常用的一项功能。以下 `import` 语句将失败：
- en: '[PRE61]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It will produce a `TypeError` (`Unknown file extension: .json`).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '它将产生一个 `TypeError` (`Unknown file extension: .json`)。'
- en: 'To overcome this limitation, we can use again the `module.createRequire` utility:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一限制，我们可以再次使用 `module.createRequire` 工具：
- en: '[PRE62]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is ongoing work to support JSON modules natively even in ESM, so we may
    not need to rely on `createRequire()` in the near future for this functionality.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 目前正在进行支持 JSON 模块原生功能的工作，即使在 ESM 中，因此我们可能不久后就不需要依赖 `createRequire()` 来实现这一功能。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored in depth what modules are, why they are useful,
    and why we need a module system. We also learned about the history of modules
    in JavaScript and about the two module systems available today in Node.js, namely
    CommonJS and ESM. We also explored some common patterns that are useful when creating
    modules or when using third-party modules.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了模块是什么，为什么它们有用，以及为什么我们需要模块系统。我们还了解了 JavaScript 中模块的历史，以及今天在 Node.js
    中可用的两种模块系统，即 CommonJS 和 ESM。我们还探讨了在创建模块或使用第三方模块时一些有用的常见模式。
- en: You should now be comfortable with understanding and writing code that takes
    advantage of the features of both CommonJS and ESM.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够舒适地理解和编写利用 CommonJS 和 ESM 特性的代码。
- en: In the rest of the book, we will rely mostly on ES modules, but you should now
    be equipped to be flexible with your choices and be able to deal with CommonJS
    effectively if necessary.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将主要依赖 ES 模块，但你现在应该能够灵活地做出选择，并在必要时有效地处理 CommonJS。
- en: In the next chapter, we will start to explore the idea of asynchronous programming
    with JavaScript, and we will examine callbacks, events, and their patterns in
    depth.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨使用 JavaScript 进行异步编程的概念，并深入探讨回调、事件及其模式。
