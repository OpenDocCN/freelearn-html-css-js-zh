- en: Chapter 1. Creating Your First 3D Scene with Three.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用Three.js创建您的第一个3D场景
- en: 'Modern browsers are slowly getting more powerful features that can be accessed
    directly from JavaScript. You can easily add video and audio with the new HTML5
    tags and create interactive components through the use of the HTML5 canvas. Together
    with HTML5, modern browsers also started supporting WebGL. With WebGL, you can
    directly make use of the processing resources of your graphics card and create
    high-performance 2D and 3D computer graphics. Programming WebGL directly from
    JavaScript to create and animate 3D scenes is a very complex and error-prone process.
    Three.js is a library that makes this a lot easier. The following list shows some
    of the things that Three.js makes easy:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器正逐渐获得更多可以直接通过JavaScript访问的功能。您可以使用新的HTML5标签轻松添加视频和音频，并通过使用HTML5画布创建交互式组件。与现代浏览器一起，HTML5也开始支持WebGL。使用WebGL，您可以直接利用显卡的处理资源，创建高性能的2D和3D计算机图形。直接从JavaScript编程WebGL以创建和动画化3D场景是一个非常复杂且容易出错的流程。Three.js是一个库，它使这个过程变得容易得多。以下列表显示了Three.js使哪些事情变得简单：
- en: Creating simple and complex 3D geometries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单和复杂的3D几何体
- en: Animating and moving objects through a 3D scene
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过3D场景动画和移动对象
- en: Applying textures and materials to your objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纹理和材质应用到您的对象上
- en: Making use of different light sources to illuminate the scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用不同的光源照亮场景
- en: Loading objects from 3D-modeling software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从3D建模软件加载对象
- en: Adding advanced postprocessing effects to your 3D scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的3D场景添加高级后处理效果
- en: Working with your own custom shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的自定义着色器
- en: Creating point clouds
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建点云
- en: 'With a couple of lines of JavaScript, you can create anything, from simple
    3D models to photorealistic real-time scenes, as shown in the following screenshot
    (see it yourself by opening [http://www.vill.ee/eye/](http://www.vill.ee/eye/)
    in your browser):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行JavaScript代码，您就可以创建任何东西，从简单的3D模型到逼真的实时场景，如下面的截图所示（您可以在浏览器中打开[http://www.vill.ee/eye/](http://www.vill.ee/eye/)自行查看）：
- en: '![Creating Your First 3D Scene with Three.js](img/2215OS_01_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用Three.js创建您的第一个3D场景](img/2215OS_01_01.jpg)'
- en: 'In this chapter, we''ll directly dive into Three.js and create a couple of
    examples that show you how Three.js works, and which you can use to play around
    with. We won''t dive into all the technical details yet; that''s something you''ll
    learn in the following chapters. In this chapter, we''ll cover the following points:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接深入探讨Three.js，并创建一些示例，向您展示Three.js的工作原理，以及您可以用来进行实验的内容。我们不会立即深入所有技术细节；这些内容将在后续章节中学习。在本章中，我们将涵盖以下要点：
- en: Tools required to work with Three.js
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Three.js所需工具
- en: Downloading the source code and examples used in this book
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载本书中使用的源代码和示例
- en: Creating your first Three.js scene
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个Three.js场景
- en: Improving the first scene with materials, lights, and animations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过材质、灯光和动画改进第一个场景
- en: Introducing a couple of helper libraries for statistics and controlling the
    scene
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些用于统计和场景控制的辅助库
- en: We'll start this book with a short introduction to Three.js and then quickly
    move on to the first examples and code samples. Before we get started, let's quickly
    look at the most important browsers out there and their support for WebGL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个简短的Three.js介绍开始这本书，然后快速进入第一个示例和代码示例。在我们开始之前，让我们快速查看目前最重要的浏览器及其对WebGL的支持。
- en: 'At the time of writing this, WebGL works with the following desktop browsers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，WebGL与以下桌面浏览器兼容：
- en: '| Browser | Support |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | 支持 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mozilla Firefox | This browser has supported WebGL since version 4.0. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Mozilla Firefox | 该浏览器自版本4.0开始支持WebGL。|'
- en: '| Google Chrome | This browser has supported WebGL since version 9. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Google Chrome | 该浏览器自版本9开始支持WebGL。|'
- en: '| Safari | Safari Version 5.1 and newer installed on Mac OS X Mountain Lion,
    Lion, or Snow Leopard supports WebGL. Make sure you enable WebGL in Safari. You
    can do this by going to **Preferences** &#124; **Advanced** and checking **Show
    develop menu in menu bar**. After that, go to **Develop** &#124; **Enable WebGL**.
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Safari | 安装在Mac OS X Mountain Lion、Lion或Snow Leopard上的Safari版本5.1及更高版本支持WebGL。请确保您已启用Safari中的WebGL。您可以通过转到**首选项**
    &#124; **高级**并勾选**在菜单栏中显示开发菜单**来完成此操作。之后，转到**开发** &#124; **启用WebGL**。|'
- en: '| Opera | This browser has supported WebGL since version 12.00\. You still
    have to enable this by opening **opera:config** and setting the values of **WebGL**
    and **Enable Hardware Acceleration** to `1`. After that, restart the browser.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Opera | 自 12.00 版本起，此浏览器已支持 WebGL。您仍然需要通过打开 **opera:config** 并将 **WebGL**
    和 **Enable Hardware Acceleration** 的值设置为 `1` 来启用此功能。之后，重新启动浏览器。|'
- en: '| Internet Explorer | Internet Explorer was for a long time the only major
    player that didn''t support WebGL. Starting with IE11, Microsoft has added WebGL
    support. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer | Internet Explorer 一直是有史以来唯一一个不支持 WebGL 的重要浏览器。从 IE11
    开始，微软添加了对 WebGL 的支持。|'
- en: Basically, Three.js runs on any of the modern browsers except older versions
    of IE. So, if you want to use an older version of IE, you've got to take an additional
    step. For IE 10 and older, there is the *iewebgl* plugin, which you can get from
    [https://github.com/iewebgl/iewebgl](https://github.com/iewebgl/iewebgl). This
    plugin is installed inside IE 10 and older versions and enables WebGL support
    for those browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Three.js 在除旧版 IE 之外的所有现代浏览器上运行。因此，如果您想使用旧版 IE，您必须采取额外步骤。对于 IE 10 和更早版本，有一个
    *iewebgl* 插件，您可以从 [https://github.com/iewebgl/iewebgl](https://github.com/iewebgl/iewebgl)
    获取。此插件安装在 IE 10 和更早版本中，并为这些浏览器启用 WebGL 支持。
- en: 'It is also possible to run Three.js on mobile devices; the support for WebGL
    and the performance you''ll get will vary, but both are quickly improving:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 三.js 也可能在移动设备上运行；对 WebGL 的支持和您将获得的表现将有所不同，但两者都在迅速提高：
- en: '| Device | Support |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | 支持 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Android | The native browser for Android doesn''t have WebGL support and
    is generally also lacking in support for modern HTML5 features. If you want to
    use WebGL on Android, you can use the latest Chrome, Firefox, or Opera mobile
    versions. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Android | Android 的原生浏览器没有 WebGL 支持，并且通常也缺乏对现代 HTML5 功能的支持。如果您想在 Android
    上使用 WebGL，您可以使用最新的 Chrome、Firefox 或 Opera 移动版本。|'
- en: '| IOS | With IOS 8, there is also support for WebGL on IOS devices. IOS Safari
    version 8 has great WebGL support. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| iOS | 在 iOS 8 中，iOS 设备也支持 WebGL。iOS Safari 版本 8 对 WebGL 有很好的支持。|'
- en: '| Windows mobile | Windows mobile supports WebGL since version 8.1. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Windows mobile | Windows mobile 自 8.1 版本起支持 WebGL。|'
- en: With WebGL, you can create interactive 3D visualizations that run very well
    on desktops and on mobile devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebGL，您可以在桌面和移动设备上创建运行良好的交互式 3D 可视化。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this book, we'll focus mostly on the WebGL-based renderer provided by Three.js.
    There is, however, also a CSS 3D-based renderer, which provides an easy API to
    create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach
    is that this standard is supported on almost all mobile and desktop browsers and
    allows you to render HTML elements in a 3D space. We'll show how to use the CSS
    3D browser in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and the Point
    Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要关注由 Three.js 提供的基于 WebGL 的渲染器。然而，还有一个基于 CSS 3D 的渲染器，它提供了一个简单的 API
    来创建基于 CSS 3D 的 3D 场景。使用基于 CSS 3D 的方法的一个大优点是，这个标准几乎在所有移动和桌面浏览器上都得到支持，并允许你在 3D 空间中渲染
    HTML 元素。我们将在 [第 7 章](ch07.html "第 7 章。粒子、精灵和点云")，*粒子、精灵和点云* 中展示如何使用 CSS 3D 浏览器。
- en: 'In this first chapter, you''ll directly create your first 3D scene and will
    be able to run this in any of the previously mentioned browsers. We won''t introduce
    too many complex Three.js features yet, but at the end of this chapter, you''ll
    have created the Three.js scene you can see in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将直接创建您的第一个 3D 场景，并能够在之前提到的任何浏览器中运行它。我们不会介绍太多复杂的 Three.js 功能，但在本章结束时，您将创建您可以在以下屏幕截图中看到的
    Three.js 场景。
- en: '![Creating Your First 3D Scene with Three.js](img/2215OS_01_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Three.js 创建您的第一个 3D 场景](img/2215OS_01_02.jpg)'
- en: For this first scene, you'll learn about the basics of Three.js and also create
    your first animation. Before you start your work on this example, in the next
    couple of sections, we'll first look at the tools you need to easily work with
    Three.js and how you can download the examples shown in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个场景，您将了解 Three.js 的基础知识，并创建您的第一个动画。在您开始此示例的工作之前，在接下来的几个部分中，我们将首先查看您需要轻松使用
    Three.js 的工具，以及您如何下载本书中展示的示例。
- en: Requirements to use Three.js
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Three.js 的要求
- en: 'Three.js is a JavaScript library, so all you need to create Three.js WebGL
    applications is a text editor and one of the supported browsers to render the
    results. I would like to recommend two JavaScript editors, which I''ve started
    using exclusively over the last couple of years:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js是一个JavaScript库，因此你只需要一个文本编辑器和其中一个支持的浏览器来渲染结果。我想推荐两个JavaScript编辑器，我在过去几年里开始专门使用它们：
- en: '**WebStorm**: This editor from the JetBrains guides has great support for editing
    JavaScript. It supports code completion, automatic deployment, and JavaScript
    debugging directly from the editor. Besides this, WebStorm has excellent GitHub
    (and other version control systems) support. You can download a trial edition
    from [http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebStorm**：来自JetBrains的这款编辑器对编辑JavaScript提供了极大的支持。它支持代码补全、自动部署和直接从编辑器中进行JavaScript调试。除此之外，WebStorm对GitHub（和其他版本控制系统）有极好的支持。你可以从[http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)下载试用版。'
- en: '**Notepad++**: Notepad++ is a general-purpose editor that supports code highlighting
    for a wide range of programming languages. It can easily lay out and format JavaScript.
    Note that Notepad++ is only for Windows. You can download Notepad++ from [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Notepad++**：Notepad++是一个通用编辑器，支持广泛编程语言的代码高亮。它可以轻松地布局和格式化JavaScript。请注意，Notepad++仅适用于Windows。你可以从[http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)下载Notepad++。'
- en: '**Sublime Text Editor**: Sublime is a great editor that has a very good support
    to edit JavaScript. Besides this, it provides many very helpful selections (such
    as multiple-line select) and edit options that, once you get used to them, provide
    a really good JavaScript-editing environment. Sublime can also be tested for free
    and can be downloaded from [http://www.sublimetext.com/](http://www.sublimetext.com/).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sublime Text编辑器**：Sublime是一个非常棒的编辑器，它对编辑JavaScript提供了非常好的支持。除此之外，它提供了许多非常有用的选择（如多行选择）和编辑选项，一旦你习惯了它们，就能提供一个真正优秀的JavaScript编辑环境。Sublime也可以免费试用，可以从[http://www.sublimetext.com/](http://www.sublimetext.com/)下载。'
- en: Even if you don't use any of these editors, there are a lot of editors available,
    open source and commercial, which you can use to edit JavaScript and create your
    Three.js projects. An interesting project you might want to look at is [http://c9.io](http://c9.io).
    This is a cloud-based JavaScript editor that can be connected to a GitHub account.
    This way, you can directly access all the source code and examples from this book
    and experiment with them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不使用这些编辑器，也有很多可用的编辑器，开源和商业的都有，你可以使用它们来编辑JavaScript并创建你的Three.js项目。你可能想看看的一个有趣的项目是[http://c9.io](http://c9.io)。这是一个基于云的JavaScript编辑器，可以连接到GitHub账户。这样，你可以直接访问这本书中的所有源代码和示例，并对其进行实验。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Besides these text-based editors that you can use to edit and experiment with
    the sources from this book, Three.js currently also provides an online editor
    itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些你可以用来编辑和实验本书源代码的文本编辑器之外，Three.js目前也提供了一个在线编辑器。
- en: With this editor, which you can find at [http://threejs.org/editor/](http://threejs.org/editor/),
    you can create Three.js scenes using a graphical approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个编辑器，你可以在这里找到[http://threejs.org/editor/](http://threejs.org/editor/)，你可以通过图形化的方法创建Three.js场景。
- en: I mentioned that most modern web browsers support WebGL and can be used to run
    Three.js examples. I usually run my code in Chrome. The reason is that most often,
    Chrome has the best support and performance for WebGL and it has a really great
    JavaScript debugger. With this debugger, which is shown in the following screenshot,
    you can quickly pinpoint problems, for instance, using breakpoints and console
    output. This is exemplified in the following screenshot. Throughout this book,
    I'll give you pointers on debugger usage and other debugging tips and tricks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，大多数现代网络浏览器都支持WebGL，并且可以用来运行Three.js示例。我通常在Chrome中运行我的代码。原因是Chrome通常对WebGL的支持和性能最好，它还有一个非常出色的JavaScript调试器。使用这个调试器，你可以快速定位问题，例如，使用断点和控制台输出。这将在下面的屏幕截图中进行说明。在整个这本书中，我会给你一些调试器使用和其他调试技巧的提示。
- en: '![Requirements to use Three.js](img/2215OS_01_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用Three.js的要求](img/2215OS_01_03.jpg)'
- en: That's enough for an introduction to Three.js for now; let's get the source
    code and start with the first scene.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于Three.js的介绍就到这里；让我们获取源代码，并从第一个场景开始。
- en: Getting the source code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'All the code for this book can be accessed from GitHub ([https://github.com/](https://github.com/)).
    GitHub is an online Git-based repository that you can use to store, access, and
    version source code. There are a couple of ways that you can get the sources for
    yourself:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以从GitHub([https://github.com/](https://github.com/))访问。GitHub是一个基于Git的在线仓库，您可以使用它来存储、访问和版本控制源代码。您有几种方法可以获取自己的源代码：
- en: Clone the Git repository
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆Git仓库
- en: Download and extract the archive
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并提取存档
- en: In the following two paragraphs, we'll explore these options in a bit more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两段中，我们将更详细地探讨这些选项。
- en: Using Git to clone the repository
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Git克隆仓库
- en: Git is an open source distributed version control system that I used to create
    and version all the examples in this book. For this, I used GitHub, a free, online
    Git repository. You can browse this repository by [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个开源的分布式版本控制系统，我使用它来创建和版本控制本书中的所有示例。为此，我使用了GitHub，这是一个免费的在线Git仓库。您可以通过[https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)浏览此仓库。
- en: 'To get all the examples, you can clone this repository using the `git` command-line
    tool. To do this, you first need to download a Git client for your operating system.
    For most modern operating systems, a client can be downloaded from [http://git-scm.com](http://git-scm.com),
    or you can use the one provided by GitHub itself (for Mac and Windows). After
    installing Git, you can use this to get a *clone* of this book''s repository.
    Open a command prompt and go to the directory where you want to download the sources.
    In that directory, run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有示例，您可以使用`git`命令行工具克隆此仓库。为此，您首先需要为您的操作系统下载一个Git客户端。对于大多数现代操作系统，您可以从[http://git-scm.com](http://git-scm.com)下载客户端，或者您可以使用GitHub本身提供的客户端（适用于Mac和Windows）。安装Git后，您可以使用它来获取本书仓库的*克隆*版本。打开命令提示符并转到您想要下载源文件的目录。在该目录中，运行以下命令：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will start downloading all the examples, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始下载所有示例，如下面的截图所示：
- en: '![Using Git to clone the repository](img/2215OS_01_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用Git克隆仓库](img/2215OS_01_04.jpg)'
- en: The `learning-three.js` directory will now contain all the examples that are
    used throughout this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`learning-three.js`目录现在将包含本书中使用的所有示例。'
- en: Downloading and extracting the archive
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载并提取存档
- en: 'If you don''t want to use Git to download the sources directly from GitHub,
    you can also download an archive. Open [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)
    in a browser and click on the **Download ZIP** button on the right-hand side,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用Git直接从GitHub下载源文件，您也可以下载一个存档。在浏览器中打开[https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)，然后点击右侧的**下载ZIP**按钮，如下所示：
- en: '![Downloading and extracting the archive](img/2215OS_01_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![下载并提取存档](img/2215OS_01_05.jpg)'
- en: Extract this to a directory of your choice, and you'll have all the examples
    available.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到您选择的目录中，您将拥有所有可用的示例。
- en: Testing the examples
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试示例
- en: Now that you've downloaded or cloned the source code, let's do a quick check
    to see whether everything is working and make you familiar with the directory
    structure. The code and examples are organized per chapter. There are two different
    ways of viewing examples. You can either open the extracted or cloned folder in
    a browser directly and look at and run a specific example, or you can install
    a local web server. This first approach will work for most of the basic examples,
    but when we start loading external resources, such as models or texture images,
    just opening the HTML file isn't enough. In this case, we need a local web server
    to make sure the external resources are loaded correctly. In the following section,
    we explain a couple of different ways you can set up a simple local web server
    for testing. If you can't set up a local web server but use Chrome or Firefox,
    we also provide an explanation on how to disable certain security features so
    that you can even test without a local web server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经下载或克隆了源代码，让我们快速检查一切是否正常工作，并让您熟悉目录结构。代码和示例按章节组织。查看示例有两种不同的方式。您可以直接在浏览器中打开提取或克隆的文件夹，查看和运行特定的示例，或者您可以安装一个本地网络服务器。第一种方法适用于大多数基本示例，但当我们开始加载外部资源，如模型或纹理图像时，仅仅打开
    HTML 文件是不够的。在这种情况下，我们需要一个本地网络服务器来确保外部资源被正确加载。在下一节中，我们将解释几种不同的方法，您可以设置一个简单的本地网络服务器进行测试。如果您无法设置本地网络服务器但使用
    Chrome 或 Firefox，我们还提供了如何禁用某些安全功能的说明，这样您甚至可以在没有本地网络服务器的情况下进行测试。
- en: Setting up a local web server is very easy depending on what you've already
    got installed. In here, we list a couple of examples on how to do this. There
    are many different ways to do this depending on what you've already got installed
    on your system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您已经安装的软件，设置本地网络服务器非常简单。在这里，我们列出了一些如何进行此操作的示例。根据您系统上已安装的软件，有多种不同的方法可以做到这一点。
- en: Python-based web servers should work on most Unix/Mac systems
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于 Python 的网络服务器应在大多数 Unix/Mac 系统上工作
- en: 'Most Unix/Linux/Mac systems already have Python installed. On those systems,
    you can very easily start a local web server:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Unix/Linux/Mac 系统已经安装了 Python。在这些系统上，您可以非常容易地启动一个本地网络服务器：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do this in the directory where you checked out / downloaded the source code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在您检出/下载源代码的目录中执行此操作。
- en: Npm-based web server if you've worked with Node.js
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果您使用过 Node.js，那么基于 npm 的网络服务器是一个不错的选择
- en: 'If you''ve already done some work with Node.js, there is good chance you''ve
    got npm installed. With npm, you have two simple options to set up a quick local
    web server for testing. The first options uses the `http-server` module, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用过 Node.js 做了一些工作，那么您很可能已经安装了 npm。使用 npm，您有两个简单的选项来快速设置一个用于测试的本地网络服务器。第一个选项使用
    `http-server` 模块，如下所示：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can also use the `simple-http-server` option, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用 `simple-http-server` 选项，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A disadvantage of this second approach, however, is that it doesn't automatically
    show directory listings, whereas the first approach does.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二种方法的缺点是它不会自动显示目录列表，而第一种方法会。
- en: Portable version Mongoose for Mac and/or Windows
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适用于 Mac 和/或 Windows 的便携式 Mongoose 版本
- en: If you haven't got Python or npm installed, there is a simple, portable web
    server, named Mongoose, that you can use. First, download the binaries for your
    specific platform from [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list).
    If you are using Windows, copy it to the directory containing the examples and
    double-click on the executable to start a web browser serving the directory it
    is started in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装 Python 或 npm，有一个简单、便携的网络服务器，名为 Mongoose，您可以使用。首先，从 [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list)
    下载您特定平台的二进制文件。如果您使用 Windows，将其复制到包含示例的目录中，然后双击可执行文件以启动一个在启动目录中提供服务的网络浏览器。
- en: 'For other operating systems, you must also copy the executable to the target
    directory, but instead of double-clicking on the executable, you have to launch
    it from the command line. In both cases, a local web server will be started on
    port `8080`. The following screenshot encapsulates the discussion in this paragraph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，您也必须将可执行文件复制到目标目录，但您需要从命令行启动它，而不是双击可执行文件。在两种情况下，都会在端口 `8080` 上启动一个本地网络服务器。以下截图概括了本段落的讨论内容：
- en: '![Portable version Mongoose for Mac and/or Windows](img/2215OS_01_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![适用于 Mac 和/或 Windows 的便携式 Mongoose 版本](img/2215OS_01_06.jpg)'
- en: By just clicking on a chapter, we can show and access all the examples for that
    specific chapter. If I discuss an example in this book, I'll refer to the specific
    name and folder so that you can directly test and play around with the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只需点击一个章节，我们就可以展示和访问该特定章节的所有示例。如果我在这本书中讨论一个示例，我会引用具体的名称和文件夹，这样你就可以直接测试并玩转代码。
- en: Disabling security exceptions in Firefox and Chrome
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Firefox和Chrome中禁用安全异常
- en: 'If you use Chrome to run the examples, there is a way to disable some security
    settings so that you can use Chrome to view the examples without requiring a web
    server. To do this, you have to start Chrome in the following way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Chrome运行示例，有一种方法可以禁用一些安全设置，这样你就可以使用Chrome查看示例，而无需Web服务器。为此，你必须以以下方式启动Chrome：
- en: 'For Windows, you call the following:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows系统，你可以调用以下命令：
- en: '[PRE4]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On Linux, do the following:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，请执行以下操作：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And on Mac OS, you disable the settings by starting Chrome like this:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS上，你可以通过以下方式启动Chrome来禁用设置：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you start Chrome this way, you can access all the examples directly from
    the local filesystem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式启动Chrome后，你可以直接从本地文件系统中访问所有示例。
- en: 'For Firefox users, we need to take a couple of different steps. Open Firefox
    and, in the URL bar, type `about:config`. This is what you''ll see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Firefox用户，我们需要采取几个不同的步骤。打开Firefox，在URL栏中输入`about:config`。这就是你会看到的内容：
- en: '![Disabling security exceptions in Firefox and Chrome](img/2215OS_01_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![在Firefox和Chrome中禁用安全异常](img/2215OS_01_07.jpg)'
- en: 'On this screen, click on the **I''ll be careful, I promise!** button. This
    will show you all the available properties you can use to fine-tune Firefox. In
    the search box on this screen, type in `security.fileuri.strict_origin_policy`
    and change its value to `false` just as we did in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，点击**我会小心，我保证**按钮。这将显示你可以用来微调Firefox的所有可用属性。在这个屏幕上的搜索框中，输入`security.fileuri.strict_origin_policy`并将它的值更改为`false`，就像我们在以下截图中所做的那样：
- en: '![Disabling security exceptions in Firefox and Chrome](img/2215OS_01_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![在Firefox和Chrome中禁用安全异常](img/2215OS_01_08.jpg)'
- en: At this point, you can also use Firefox to directly run the examples provided
    in this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你也可以使用Firefox直接运行这本书提供的示例。
- en: Now that you've either got a web server installed, or disabled the necessary
    security settings, it is time to start creating our first Three.js scene.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了Web服务器或者禁用了必要的安全设置，是时候开始创建我们的第一个Three.js场景了。
- en: Creating the HTML skeleton
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML骨架
- en: 'The first thing we need to do is create an empty skeleton page that we can
    use as the base for all our examples, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个空白的骨架页面，我们可以将其用作所有示例的基础，如下所示：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.packtpub.com](http://www.packtpub.com)下载你购买的所有Packt Publishing书籍的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: As you can see from this listing, the skeleton is a very simple HTML page, with
    only a couple of elements. In the `<head>` element, we load the external JavaScript
    libraries that we'll use for the examples. For all the examples, we'll at least
    need to load the Three.js library, `three.js`. In the `<head>` element, we also
    add a couple of lines of CSS. These style elements remove any scrollbars when
    we create a full-page Three.js scene. In the `<body>` element of this page, you
    can see a single `<div>` element. When we write our Three.js code, we'll point
    the output of the Three.js renderer to that element. At the bottom of this page,
    you can already see a bit of JavaScript. By assigning the `init` function to the
    `window.onload` property, we make sure that this function gets called when the
    HTML document has finished loading. In the `init` function, we'll insert all the
    Three.js specific JavaScript.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个列表显示，框架是一个非常简单的 HTML 页面，只有几个元素。在 `<head>` 元素中，我们加载了我们将用于示例的外部 JavaScript
    库。对于所有示例，我们至少需要加载 Three.js 库，`three.js`。在 `<head>` 元素中，我们还添加了几行 CSS。这些样式元素在创建全页
    Three.js 场景时移除了任何滚动条。在这个页面的 `<body>` 元素中，你可以看到一个单独的 `<div>` 元素。当我们编写 Three.js
    代码时，我们将 Three.js 渲染器的输出指向该元素。在页面底部，你已经开始看到一些 JavaScript 代码。通过将 `init` 函数分配给 `window.onload`
    属性，我们确保当 HTML 文档加载完成时调用此函数。在 `init` 函数中，我们将插入所有 Three.js 特定的 JavaScript。
- en: 'Three.js comes in two versions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 有两个版本：
- en: '**Three.min.js**: This is the library you''d normally use when deploying Three.js
    sites on the Internet. This is a minified version of Three.js, created using **UglifyJS**,
    which is a quarter size of the normal Three.js library. All the examples and code
    used in this book are based on Three.js **r69**, which was released in October
    2014.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.min.js**：这是你在将 Three.js 网站部署到互联网上时通常会使用的库。这是使用 **UglifyJS** 创建的 Three.js
    的精简版本，其大小是正常 Three.js 库的四分之一。本书中使用的所有示例和代码都是基于 2014 年 10 月发布的 Three.js **r69**
    版本。'
- en: '**Three.js**: This is the normal Three.js library. We use this library in our
    examples since it makes debugging much easier when you can read and understand
    the Three.js source code.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.js**：这是正常的 Three.js 库。我们在示例中使用这个库，因为它使得当你能够阅读和理解 Three.js 源代码时，调试变得容易得多。'
- en: If we view this page in our browser, the results aren't very shocking. As you'd
    expect, all you see is an empty page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看这个页面，结果并不令人震惊。正如你所预期的，你看到的是一个空白的页面。
- en: In the next section, you'll learn how to add the first couple of 3D objects
    and render those to the `<div>` element we defined in our HTML skeleton.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，你将学习如何添加前几个 3D 对象，并将它们渲染到我们在 HTML 框架中定义的 `<div>` 元素中。
- en: Rendering and viewing a 3D object
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和查看 3D 对象
- en: 'In this step, you''ll create your first scene and add a couple of objects and
    a camera. Our first example will contain the following objects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，你将创建你的第一个场景，并添加一些对象和相机。我们的第一个例子将包含以下对象：
- en: '| Object | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 描述 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Plane` | This is a two-dimensional rectangle that serves as our ground area.
    In the second screenshot of this chapter, this is rendered as the gray rectangle
    in the middle of the scene. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Plane` | 这是一个二维矩形，作为我们的地面区域。在本章的第二张截图，这个矩形被渲染为场景中间的灰色矩形。|'
- en: '| `Cube` | This is a three-dimensional cube, which we''ll render in red. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Cube` | 这是一个三维立方体，我们将用红色渲染它。|'
- en: '| `Sphere` | This is a three-dimensional sphere, which we''ll render in blue.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Sphere` | 这是一个三维球体，我们将用蓝色渲染它。|'
- en: '| `Camera` | The camera determines what you''ll see in the output. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Camera` | 相机决定了你将在输出中看到什么。|'
- en: '| `Axes` | These are the *x*, *y*, and *z* axes. This is a helpful debugging
    tool to see where the objects are rendered in 3D space. The *x* axis is colored
    red, the *y* axis is colored green, and the *z* axis is colored blue. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Axes` | 这些是 *x*、*y* 和 *z* 轴。这是一个有用的调试工具，可以查看对象在 3D 空间中的渲染位置。*x* 轴是红色，*y*
    轴是绿色，*z* 轴是蓝色。|'
- en: 'I''ll first show you how this looks in code (the source with comments can be
    found in `chapter-01/02-first-scene.html`), and then I''ll explain what''s happening:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先会向你展示它在代码中的样子（带有注释的源代码可以在 `chapter-01/02-first-scene.html` 中找到），然后我会解释正在发生的事情：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we open this example in the browser, we see something that resembles what
    we''re aiming at (see the screenshot at the beginning of this chapter), but it
    is still a long way off, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开这个示例，我们看到的是我们想要达到的效果（参见本章开头的截图），但它仍然还有很长的路要走，如下所示：
- en: '![Rendering and viewing a 3D object](img/2215OS_01_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![渲染和查看 3D 对象](img/2215OS_01_09.jpg)'
- en: 'Before we start making this more beautiful, I''ll first walk you through the
    code a step at a time so that you understand what the code does:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使这个场景更加美观之前，我会一步一步地带你了解代码，这样你就能理解代码的功能：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the top of the example, we define `scene`, `camera`, and `renderer`. The
    `scene` object is a container that is used to store and keep track of all the
    objects we want to render and all the lights we want to use. Without a `THREE.Scene`
    object, Three.js isn't able to render anything. More information on the `THREE.Scene`
    object can be found in the next chapter. The sphere and the cube we want to render
    will be added to scene later on in the example. In this first fragment, we also
    create a `camera` object. The `camera` object defines what we'll see when we render
    a scene. In [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a
    Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, you learn
    more about the arguments you can pass in to the `camera` object. Next we define
    `renderer`. The `renderer` object is responsible for calculating what the `scene`
    object will look like in the browser based on the `camera` object's angle. We
    create `WebGLRenderer` that uses your graphics card to render the scene in this
    example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的顶部，我们定义了`scene`、`camera`和`renderer`。`scene`对象是一个容器，用于存储和跟踪我们想要渲染的所有对象以及我们想要使用的所有灯光。没有`THREE.Scene`对象，Three.js无法渲染任何内容。关于`THREE.Scene`对象的更多信息可以在下一章找到。我们想要渲染的球体和立方体将在示例的后面部分添加到场景中。在这个第一个片段中，我们还创建了一个`camera`对象。`camera`对象定义了当我们渲染一个场景时我们会看到什么。在[第二章](ch02.html
    "第二章。构成Three.js场景的基本组件")中，*构成Three.js场景的基本组件*，你将了解更多关于可以传递给`camera`对象的参数。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you look through the source code and the documentation of Three.js (which
    you can find at [http://threejs.org/](http://threejs.org/)), you'll notice that
    there are different renderers available besides the WebGL-based one. There is
    a canvas-based renderer and even an SVG-based one. Even though they work and can
    render simple scenes, I wouldn't recommend using them. They're very CPU-intensive
    and lack features such as good material support and shadows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Three.js的源代码和文档（你可以在[http://threejs.org/](http://threejs.org/)找到），你会注意到除了基于WebGL的渲染器之外，还有不同的渲染器可用。有一个基于画布的渲染器，甚至还有一个基于SVG的渲染器。尽管它们可以工作并且可以渲染简单的场景，但我不会推荐使用它们。它们非常占用CPU资源，并且缺乏如良好的材质支持和阴影等特性。
- en: Here, we set the background color of `renderer` to almost white (`new THREE.Color(0XEEEEEE)`)
    with the `setClearColor` function and tell `renderer` how large the scene needs
    to be rendered using the `setSize` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`setClearColor`函数将`renderer`的背景颜色设置为几乎白色（`new THREE.Color(0XEEEEEE)`），并使用`setSize`函数告诉`renderer`场景需要渲染的大小。
- en: 'So far, we''ve got a basic empty scene, a renderer, and a camera. There is,
    however, nothing yet to render. The following code adds the helper axes and the
    plane:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经得到了一个基本的空场景、一个渲染器和一台相机。然而，目前还没有东西可以渲染。以下代码添加了辅助轴和平面：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we create an `axes` object and use the `scene.add` function
    to add these axes to our scene. Next, we create the plane. This is done in two
    steps. First, we define what the plane looks like using the new `THREE.PlaneGeometry(60,20)`
    code. In this case, it has a width of `60` and a height of `20`. We also need
    to tell Three.js what this plane looks like (for example, its color and its transparency).
    In Three.js, we do this by creating a material object. For this first example,
    we'll create a basic material (`THREE.MeshBasicMaterial`) with the color `0xcccccc`.
    Next, we combine these two into a `Mesh` object with the name `plane`. Before
    we add `plane` to the scene, we need to put it in the correct position; we do
    this by first rotating it 90 degrees around the x axis, and next, we define its
    position in the scene using the position properties. If you're already interested
    in the details of this, look at the `06-mesh-properties.html` example from the
    code folder of [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up
    a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, which shows
    and explains rotation and positioning. We then need to do is add `plane` to `scene`,
    just like we did with `axes`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个`axes`对象，并使用`scene.add`函数将这些轴添加到场景中。接下来，我们创建平面。这分为两个步骤。首先，我们使用新的`THREE.PlaneGeometry(60,20)`代码定义平面的外观。在这种情况下，它的宽度为`60`，高度为`20`。我们还需要告诉Three.js这个平面的外观（例如，其颜色和透明度）。在Three.js中，我们通过创建一个材质对象来实现这一点。对于这个第一个例子，我们将创建一个基本材质（`THREE.MeshBasicMaterial`），颜色为`0xcccccc`。接下来，我们将这两个元素组合成一个名为`plane`的`Mesh`对象。在我们将`plane`添加到场景之前，我们需要将其放置在正确的位置；我们通过首先围绕x轴旋转90度来实现这一点，然后使用位置属性定义其在场景中的位置。如果您已经对这一细节感兴趣，请查看[第2章](ch02.html
    "第2章. 构成Three.js场景的基本组件")代码文件夹中的`06-mesh-properties.html`示例，*构成Three.js场景的基本组件*，它展示了旋转和定位的说明。然后我们需要做的就是将`plane`添加到`scene`中，就像我们添加`axes`一样。
- en: 'The `cube` and `sphere` objects are added in the same manner, but with the
    `wireframe` property set to `true`, which tells Three.js to render a wireframe
    and not a solid object. Now, let''s move on to the final part of this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`cube`和`sphere`对象以相同的方式添加，但将`wireframe`属性设置为`true`，这告诉Three.js渲染一个线框而不是一个实体对象。现在，让我们继续这个示例的最后一部分：'
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, all the elements we want to render are added to the scene at
    the correct positions. I've already mentioned that the camera defines what will
    be rendered. In this piece of code, we position the camera using the `x`, `y`,
    and `z` position attributes to hover above our scene. To make sure the camera
    is looking at our objects, we use the `lookAt` function to point it at the center
    of our scene, which is located at position (0, 0, 0) by default. All that is left
    to do is append the output from the renderer to the `<div>` element of our HTML
    skeleton. We use standard JavaScript to select the correct output element and
    append it to our `div` element with the `appendChild` function. Finally, we tell
    `renderer` to render `scene` using the `camera` object provided.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们想要渲染的所有元素都已添加到场景的正确位置。我已经提到，相机定义了将要渲染的内容。在这段代码中，我们使用`x`、`y`和`z`位置属性定位相机，使其悬停在场景上方。为了确保相机正在注视我们的对象，我们使用`lookAt`函数将其指向场景的中心，默认位置为(0,
    0, 0)。接下来要做的就是将渲染器的输出追加到我们的HTML骨架的`<div>`元素中。我们使用标准的JavaScript选择正确的输出元素，并使用`appendChild`函数将其追加到我们的`div`元素中。最后，我们告诉`renderer`使用提供的`camera`对象来渲染`scene`。
- en: In the next couple of sections, we'll make this scene more pretty by adding
    lights, shadows, more materials, and even animations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过添加灯光、阴影、更多材质甚至动画来使这个场景更加美观。
- en: Adding materials, lights, and shadows
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加材质、灯光和阴影
- en: 'Adding new materials and lights in Three.js is very simple and is done in pretty
    much the same way as we explained in the previous section. We start by adding
    a light source to the scene (for the complete source look at `03-materials-light.html`),
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中添加新的材质和灯光非常简单，基本上与我们在上一节中解释的方式相同。我们首先向场景添加一个光源（完整的源代码请查看`03-materials-light.html`），如下所示：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`THREE.SpotLight` illuminates our scene from its position (`spotLight.position.set(
    -40, 60, -10 )`). If we render the scene this time, however, you won''t see any
    difference from the previous one. The reason is that different materials respond
    differently to light. The basic material we used in the previous example (`THREE.MeshBasicMaterial`)
    doesn''t do anything with the light sources in the scene. They just render the
    object in the specified color. So, we have to change the materials for `plane`,
    `sphere`, and `cube` to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight`从其位置（`spotLight.position.set( -40, 60, -10 )`）照亮我们的场景。然而，如果我们这次渲染场景，你将看不到与前一个版本有任何不同。原因是不同的材质对光线的反应不同。我们在上一个例子中使用的基材（`THREE.MeshBasicMaterial`）对场景中的光源没有任何作用。它们只是以指定的颜色渲染对象。因此，我们必须将`plane`、`sphere`和`cube`的材质更改为以下内容：'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this piece of code, we changed the materials for our objects to `MeshLambertMaterial`.
    This material and `MeshPhongMaterial` are the materials Three.js provides that
    take light sources into account when rendered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将对象的材质更改为`MeshLambertMaterial`。这种材质和`MeshPhongMaterial`是Three.js提供的材质，在渲染时会考虑光源。
- en: 'The result, shown in the following screenshot, however, still isn''t what we''re
    looking for:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示的结果，然而，仍然不是我们想要的：
- en: '![Adding materials, lights, and shadows](img/2215OS_01_10.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![添加材质、灯光和阴影](img/2215OS_01_10.jpg)'
- en: We're getting there, and cube and sphere are looking a lot better. What is still
    missing, though, are the shadows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近目标，立方体和球体看起来好多了。不过，仍然缺少的是阴影。
- en: 'Rendering shadows takes a lot of computing power, and for that reason, shadows
    are disabled by default in Three.js. Enabling them, though, is very easy. For
    shadows, we have to change the source in a couple of places, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染阴影需要大量的计算能力，因此，在Three.js中默认禁用了阴影。但是，启用它们非常简单。对于阴影，我们需要在几个地方更改源，如下所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first change we need to make is tell `renderer` that we want shadows. You
    do this by setting the `shadowMapEnabled` property to `true`. If you look at the
    result from this change, you won''t notice anything different yet. That is because
    we need to explicitly define which objects cast shadows and which objects receive
    shadows. In our example, we want the sphere and the cube to cast shadows on the
    ground plane. You do this by setting the corresponding properties on those objects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是告诉`renderer`我们想要阴影。你可以通过将`shadowMapEnabled`属性设置为`true`来完成此操作。如果你查看这个更改的结果，你不会注意到任何不同。这是因为我们需要明确定义哪些对象产生阴影，哪些对象接收阴影。在我们的例子中，我们希望球体和立方体在地面平面上产生阴影。你可以通过设置这些对象上的相应属性来完成此操作：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, there is just one more thing to do to get the shadows. We need to define
    which light sources in our scene will cause shadows. Not all the lights can cast
    shadows, and you''ll learn more about that in the next chapter, but `THREE.SpotLight`,
    which we used in this example, can. We only need to set the correct property,
    as shown in the following line of code, and the shadows will finally be rendered:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需再完成一件事就可以得到阴影。我们需要定义场景中哪些光源将产生阴影。并非所有的光源都能产生阴影，你将在下一章中了解更多关于这一点，但我们在本例中使用的`THREE.SpotLight`可以。我们只需要设置正确的属性，如下面的代码行所示，阴影最终将被渲染：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And with this, we get a scene complete with shadows from our light source,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们得到了一个包含来自光源的阴影的场景，如下所示：
- en: '![Adding materials, lights, and shadows](img/2215OS_01_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![添加材质、灯光和阴影](img/2215OS_01_11.jpg)'
- en: The last feature that we'll add to this first scene is some simple animation.
    In [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, you'll learn more advanced animation options.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到这个第一个场景的最后一个特性是一些简单的动画。在[第9章](ch09.html "第9章。动画和移动相机")，*动画和移动相机*中，你将了解更高级的动画选项。
- en: Expanding your first scene with animations
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过动画扩展你的第一个场景
- en: If we want to animate the scene, the first thing that we need to do is find
    some way to re-render the scene at a specific interval. Before HTML5 and the related
    JavaScript APIs came along, the way to do this was using the `setInterval(function,interval)`
    function. With `setInterval`, we could specify a function that, for instance,
    would be called every 100 milliseconds. The problem with this function is that
    it doesn't take into account what is happening in the browser. If you were browsing
    another tab, this function would still be fired every couple of milliseconds.
    Besides that, `setInterval` isn't synchronized with the redrawing of the screen.
    This can lead to higher CPU usage and bad performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要对场景进行动画处理，首先需要做的事情是找到一种方法在特定的时间间隔重新渲染场景。在HTML5和相关JavaScript API出现之前，实现这一点的办法是使用`setInterval(function,interval)`函数。使用`setInterval`，我们可以指定一个函数，例如，每100毫秒被调用一次。这个函数的问题在于它没有考虑到浏览器中的情况。如果你在浏览另一个标签页，这个函数仍然会每隔几毫秒被触发。除此之外，`setInterval`与屏幕的重绘不同步。这可能导致CPU使用率增加和性能下降。
- en: Introducing requestAnimationFrame
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍requestAnimationFrame
- en: 'Modern browsers luckily have a solution for that with the `requestAnimationFrame`
    function. With `requestAnimationFrame`, you can specify a function that is called
    at an interval defined by the browser. You do any drawing you need to do in the
    supplied function, and the browser will make sure it is painted as smoothly and
    efficiently as possible. Using this is really simple (the complete source can
    be found in the `04-materials-light-animation.html` file), you just create a function
    that handles the rendering:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现代浏览器通过`requestAnimationFrame`函数为这个问题提供了一个解决方案。使用`requestAnimationFrame`，你可以指定一个在浏览器定义的间隔被调用的函数。你可以在提供的函数中做任何需要的绘图，浏览器将确保尽可能平滑和高效地绘制。使用它非常简单（完整的源代码可以在`04-materials-light-animation.html`文件中找到），你只需要创建一个处理渲染的函数：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this `renderScene` function, we call `requestAnimationFrame` again, to keep
    the animation going. The only thing we need to change in the code is that instead
    of calling `renderer.render` after we''ve created the complete scene, we call
    the `renderScene` function once to kick off the animation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`renderScene`函数中，我们再次调用`requestAnimationFrame`以保持动画的进行。在代码中我们需要更改的唯一一件事是，在我们创建完整的场景之后，不是调用`renderer.render`，而是调用一次`renderScene`函数来启动动画：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run this, you won't see any changes yet compared to the previous example
    because we haven't animated anything yet. Before we add the animation, though,
    I want to introduce a small helper library that gives us information about the
    frame rate the animation is running at. This library, from the same author as
    Three.js, renders a small graph that shows us the frames per second we're getting
    for this animation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，与之前的例子相比，你不会看到任何变化，因为我们还没有添加动画。不过，在我们添加动画之前，我想介绍一个小型的辅助库，它可以给我们提供关于动画运行帧率的详细信息。这个库与Three.js的作者相同，它渲染一个小型图表，显示我们为这个动画获得的每秒帧数。
- en: 'To add these statistics, we first need to include the library in the `<head>`
    element of the HTML, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些统计信息，我们首先需要在HTML的`<head>`元素中包含库，如下所示：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we add a `<div>` element that will be used as output for the statistics
    graph, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加一个`<div>`元素，它将被用作统计图输出的，如下所示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only thing left to do is initialize the statistics and add them to this
    `<div>` element, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事是初始化统计信息并将它们添加到这个`<div>`元素中，如下所示：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This function initializes the statistics. The interesting part is the `setMode`
    function. If we set it to `0`, we''ll measure frames per second (fps), and if
    we set this to `1`, we can measure rendering time. For this example, we''re interested
    in fps, so `0` it is. At the beginning of our `init()` function, we''ll call this
    function, and we''ve got `stats` enabled, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数初始化统计信息。有趣的部分是`setMode`函数。如果我们将其设置为`0`，我们将测量每秒帧数（fps），如果我们将其设置为`1`，我们可以测量渲染时间。对于这个例子，我们感兴趣的是fps，所以是`0`。在`init()`函数的开始，我们将调用这个函数，并且我们启用了`stats`，如下所示：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The only thing left to do is tell the `stats` object when we're in a new rendering
    cycle. We do this by adding a call to the `stats.update` function in our `renderScene`
    function, as follows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事是告诉`stats`对象我们在新的渲染周期中。我们通过在`renderScene`函数中添加对`stats.update`函数的调用来实现这一点，如下所示。
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run the code with these additions, you''ll see the statistics in the
    upper-left corner, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行带有这些添加的代码，你将在屏幕的左上角看到统计信息，如下面的截图所示：
- en: '![Introducing requestAnimationFrame](img/2215OS_01_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![介绍requestAnimationFrame](img/2215OS_01_12.jpg)'
- en: Animating the cube
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画立方体
- en: 'With `requestAnimationFrame` and the statistics configured, we''ve got a place
    to put our animation code. In this section, we''ll expand the `renderScene` function
    with code that will rotate our red cube around all of its axes. Let''s start by
    showing you the code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requestAnimationFrame`和配置好的统计信息，我们有一个地方可以放置我们的动画代码。在本节中，我们将通过添加代码来扩展`renderScene`函数，使我们的红色立方体在其所有轴上旋转。让我们先看看代码：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That looks simple, right? What we do is that we increase the `rotation` property
    of each of the axes with 0.02 every time the `renderScene` function is called,
    which shows up as a cube smoothly rotating around all if its axes. Bouncing the
    blue ball isn't much harder.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，对吧？我们做的是，每次调用`renderScene`函数时，我们将每个轴的`rotation`属性增加0.02，这看起来就像立方体在其所有轴上平滑旋转。弹跳蓝色球体并不难。
- en: Bouncing the ball
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹跳球体
- en: 'To bounce the ball, we once again add a couple of lines of code to our `renderScene`
    function, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弹跳球体，我们再次在`renderScene`函数中添加几行代码，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the cube, we changed the `rotation` property; for the sphere, we''re going
    to change its `position` property in the scene. We want the sphere to bounce from
    one point in the scene to another with a nice, smooth curve. This is shown in
    the following figure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于立方体，我们更改了`rotation`属性；对于球体，我们将更改场景中其`position`属性。我们希望球体以一个漂亮的、平滑的曲线从场景中的一个点到另一个点弹跳。这如图所示：
- en: '![Bouncing the ball](img/2215OS_01_13.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![弹跳球体](img/2215OS_01_13.jpg)'
- en: 'For this, we need to change its position on the *x* axis and its position on
    the *y* axis. The `Math.cos` and `Math.sin` functions help us in creating a smooth
    trajectory using the step variable. I won''t go into the details of how this works
    here. For now, all you need to know is that `step+=0.04` defines the speed of
    the bouncing sphere. In [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    we''ll look in much more detail how these functions can be used for animation,
    and I''ll explain everything. Here''s how the ball looks in the middle of a bounce:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要更改其在*x*轴上的位置和其在*y*轴上的位置。`Math.cos`和`Math.sin`函数帮助我们使用步进变量创建平滑的轨迹。我不会在这里详细介绍它是如何工作的。现在，你需要知道的是，`step+=0.04`定义了弹跳球体的速度。在[第8章](ch08.html
    "第8章。创建和加载高级网格和几何体")，*创建和加载高级网格和几何体*中，我们将更详细地探讨这些函数如何用于动画，并且我会解释一切。以下是球体在弹跳中间的样子：
- en: '![Bouncing the ball](img/2215OS_01_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![弹跳球体](img/2215OS_01_14.jpg)'
- en: Before wrapping up this chapter, I want to add one more element to our basic
    scene. When working with 3D scenes, animations, colors, and properties like that,
    it often requires a bit of experimenting to get the correct color or speed. It
    would be very easy if you could just have a simple GUI that allows you to change
    these kinds of properties on the fly. Luckily, there is!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想在我们的基本场景中添加一个额外的元素。当与3D场景、动画、颜色和属性等工作时，通常需要一些实验来得到正确的颜色或速度。如果能够有一个简单的GUI，允许你即时更改这些属性，那就太容易了。幸运的是，有这样的工具！
- en: Using dat.GUI to make experimenting easier
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dat.GUI使实验更容易
- en: 'A couple of employees from Google created a library called **dat.GUI** (you
    can find the documentation online at [http://code.google.com/p/dat-gui/](http://code.google.com/p/dat-gui/)),
    which allows you to very easily create a simple user interface component that
    can change variables in your code. In this last part of this chapter, we''ll use
    dat.GUI to add a user interface to our example that allows us to change the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 几位谷歌员工创建了一个名为 **dat.GUI** 的库（你可以在[http://code.google.com/p/dat-gui/](http://code.google.com/p/dat-gui/)上找到在线文档），它允许你非常容易地创建一个简单的用户界面组件，可以更改代码中的变量。在本章的最后部分，我们将使用dat.GUI为我们的示例添加一个用户界面，允许我们更改以下内容：
- en: Control the speed of the bouncing ball
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制弹跳球体的速度
- en: Control the rotation of the cube
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制立方体的旋转
- en: 'Just like we had to do for the statistics, we first add this library to the
    `<head>` element of our HTML page, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们必须为统计信息做的那样，我们首先将这个库添加到我们的HTML页面的`<head>`元素中，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next thing we need to configure is a JavaScript object that will hold the
    properties we want to change using dat.GUI. In the main part of our JavaScript
    code, we add the following JavaScript object, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要配置的是，一个JavaScript对象将包含我们想要使用dat.GUI更改的属性。在我们的JavaScript代码的主体部分，我们添加以下JavaScript对象，如下所示：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this JavaScript object, we define two properties—`this.rotationSpeed` and
    `this.bouncingSpeed`—and their default values. Next, we pass this object into
    a new dat.GUI object and define the range for these two properties, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个JavaScript对象中，我们定义了两个属性——`this.rotationSpeed`和`this.bouncingSpeed`——以及它们的默认值。接下来，我们将这个对象传递给一个新的dat.GUI对象，并定义这两个属性的取值范围，如下所示：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `rotationSpeed` and `bouncingSpeed` properties are both set to a range
    of `0` to `0.5`. All we need to do now is make sure that in our `renderScene`
    loop, we reference these two properties directly so that when we make changes
    through the dat.GUI user interface, it immediately affects the rotation and bounce
    speed of our objects, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotationSpeed`和`bouncingSpeed`属性都被设置为`0`到`0.5`的范围。我们现在需要确保在我们的`renderScene`循环中直接引用这两个属性，这样当我们通过dat.GUI用户界面进行更改时，它将立即影响我们对象的旋转和弹跳速度，如下所示：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when you run this example (`05-control-gui.html`), you''ll see a simple
    user interface that you can use to control the bouncing and rotation speeds. A
    screenshot of the bouncing ball and the rotating cube is shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行这个示例（`05-control-gui.html`）时，你会看到一个简单的用户界面，你可以使用它来控制弹跳和旋转速度。以下是弹跳球和旋转立方体的截图：
- en: '![Using dat.GUI to make experimenting easier](img/2215OS_01_15.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用dat.GUI简化实验](img/2215OS_01_15.jpg)'
- en: If you've looked at the examples in your browser, you might have noticed that
    when you change the size of your browser, the scene doesn't automatically scale.
    In the next section, we'll add this as a final feature for this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经查看过浏览器中的示例，你可能已经注意到，当你改变浏览器的大小，场景不会自动缩放。在下一节中，我们将添加这个作为本章的最后一个特性。
- en: Automatically resize the output when browser size changes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当浏览器大小改变时自动调整输出大小
- en: 'Changing the camera when the browser is resized can be done pretty simply.
    The first thing we need to do is register an event listener like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器大小改变时更改相机可以非常简单地进行。我们首先需要做的是注册一个像这样的事件监听器：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, whenever the browser window is resized, the `onResize` function, which
    we''ll specify next, is called. In this `onResize` function, we need to update
    the camera and renderer, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当浏览器窗口大小改变时，我们将调用的`onResize`函数，如下所示。在这个`onResize`函数中，我们需要更新相机和渲染器，如下所示：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the camera, we need to update the `aspect` property, which holds the aspect
    ratio of the screen, and for the `renderer`, we need to change its size. The final
    step is to move the variable definitions for `camera`, `renderer`, and `scene`
    outside of the `init()` function so that we can access them from different functions
    (like the `onResize` function), as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相机，我们需要更新`aspect`属性，它包含屏幕的宽高比，而对于`renderer`，我们需要改变其大小。最后一步是将`camera`、`renderer`和`scene`的变量定义移出`init()`函数之外，这样我们就可以从不同的函数（如`onResize`函数）中访问它们，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To see this effect in action, open the `06-screen-size-change.html` example
    and resize your browser window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果的实际应用，请打开`06-screen-size-change.html`示例并调整浏览器窗口的大小。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's it for the first chapter. In this chapter, we showed you how to set up
    your development environment, how to get the code, and how to get started with
    the examples provided with this book. You further learned that to render a scene
    with Three.js, you first have to create a `THREE.Scene` object, add a camera,
    a light, and the objects that you want to render. We also showed you how you can
    expand this basic scene by adding shadows and animations. Lastly, we added a couple
    of helper libraries. We used dat.GUI, which allows you to quickly create control
    user interfaces, and we added `stats.js`, which provided feedback on the frame
    rate at which your scene is rendered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一章的全部内容。在本章中，我们向您展示了如何设置您的开发环境，如何获取代码，以及如何开始使用本书提供的示例。您还进一步了解到，要使用Three.js渲染场景，您首先必须创建一个`THREE.Scene`对象，添加一个相机、一个光源以及您想要渲染的对象。我们还向您展示了如何通过添加阴影和动画来扩展这个基本场景。最后，我们添加了几个辅助库。我们使用了dat.GUI，它允许您快速创建控制用户界面，我们还添加了`stats.js`，它提供了关于场景渲染帧率的反馈。
- en: In the next chapter, we'll expand on the example we created here. You'll learn
    more about the most important building blocks that you can use in Three.js.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展这里创建的示例。你将了解更多关于你可以用于Three.js的最重要的构建块。
