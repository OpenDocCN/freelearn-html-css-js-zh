- en: Chapter 1. Creating Your First 3D Scene with Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern browsers are slowly getting more powerful features that can be accessed
    directly from JavaScript. You can easily add video and audio with the new HTML5
    tags and create interactive components through the use of the HTML5 canvas. Together
    with HTML5, modern browsers also started supporting WebGL. With WebGL, you can
    directly make use of the processing resources of your graphics card and create
    high-performance 2D and 3D computer graphics. Programming WebGL directly from
    JavaScript to create and animate 3D scenes is a very complex and error-prone process.
    Three.js is a library that makes this a lot easier. The following list shows some
    of the things that Three.js makes easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple and complex 3D geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating and moving objects through a 3D scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying textures and materials to your objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of different light sources to illuminate the scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading objects from 3D-modeling software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding advanced postprocessing effects to your 3D scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with your own custom shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating point clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With a couple of lines of JavaScript, you can create anything, from simple
    3D models to photorealistic real-time scenes, as shown in the following screenshot
    (see it yourself by opening [http://www.vill.ee/eye/](http://www.vill.ee/eye/)
    in your browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Your First 3D Scene with Three.js](img/2215OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we''ll directly dive into Three.js and create a couple of
    examples that show you how Three.js works, and which you can use to play around
    with. We won''t dive into all the technical details yet; that''s something you''ll
    learn in the following chapters. In this chapter, we''ll cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Tools required to work with Three.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the source code and examples used in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Three.js scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the first scene with materials, lights, and animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a couple of helper libraries for statistics and controlling the
    scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start this book with a short introduction to Three.js and then quickly
    move on to the first examples and code samples. Before we get started, let's quickly
    look at the most important browsers out there and their support for WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this, WebGL works with the following desktop browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Support |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mozilla Firefox | This browser has supported WebGL since version 4.0. |'
  prefs: []
  type: TYPE_TB
- en: '| Google Chrome | This browser has supported WebGL since version 9. |'
  prefs: []
  type: TYPE_TB
- en: '| Safari | Safari Version 5.1 and newer installed on Mac OS X Mountain Lion,
    Lion, or Snow Leopard supports WebGL. Make sure you enable WebGL in Safari. You
    can do this by going to **Preferences** &#124; **Advanced** and checking **Show
    develop menu in menu bar**. After that, go to **Develop** &#124; **Enable WebGL**.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Opera | This browser has supported WebGL since version 12.00\. You still
    have to enable this by opening **opera:config** and setting the values of **WebGL**
    and **Enable Hardware Acceleration** to `1`. After that, restart the browser.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Internet Explorer | Internet Explorer was for a long time the only major
    player that didn''t support WebGL. Starting with IE11, Microsoft has added WebGL
    support. |'
  prefs: []
  type: TYPE_TB
- en: Basically, Three.js runs on any of the modern browsers except older versions
    of IE. So, if you want to use an older version of IE, you've got to take an additional
    step. For IE 10 and older, there is the *iewebgl* plugin, which you can get from
    [https://github.com/iewebgl/iewebgl](https://github.com/iewebgl/iewebgl). This
    plugin is installed inside IE 10 and older versions and enables WebGL support
    for those browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to run Three.js on mobile devices; the support for WebGL
    and the performance you''ll get will vary, but both are quickly improving:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Device | Support |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Android | The native browser for Android doesn''t have WebGL support and
    is generally also lacking in support for modern HTML5 features. If you want to
    use WebGL on Android, you can use the latest Chrome, Firefox, or Opera mobile
    versions. |'
  prefs: []
  type: TYPE_TB
- en: '| IOS | With IOS 8, there is also support for WebGL on IOS devices. IOS Safari
    version 8 has great WebGL support. |'
  prefs: []
  type: TYPE_TB
- en: '| Windows mobile | Windows mobile supports WebGL since version 8.1. |'
  prefs: []
  type: TYPE_TB
- en: With WebGL, you can create interactive 3D visualizations that run very well
    on desktops and on mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, we'll focus mostly on the WebGL-based renderer provided by Three.js.
    There is, however, also a CSS 3D-based renderer, which provides an easy API to
    create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach
    is that this standard is supported on almost all mobile and desktop browsers and
    allows you to render HTML elements in a 3D space. We'll show how to use the CSS
    3D browser in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and the Point
    Cloud"), *Particles, Sprites, and the Point Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first chapter, you''ll directly create your first 3D scene and will
    be able to run this in any of the previously mentioned browsers. We won''t introduce
    too many complex Three.js features yet, but at the end of this chapter, you''ll
    have created the Three.js scene you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Your First 3D Scene with Three.js](img/2215OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this first scene, you'll learn about the basics of Three.js and also create
    your first animation. Before you start your work on this example, in the next
    couple of sections, we'll first look at the tools you need to easily work with
    Three.js and how you can download the examples shown in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements to use Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js is a JavaScript library, so all you need to create Three.js WebGL
    applications is a text editor and one of the supported browsers to render the
    results. I would like to recommend two JavaScript editors, which I''ve started
    using exclusively over the last couple of years:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebStorm**: This editor from the JetBrains guides has great support for editing
    JavaScript. It supports code completion, automatic deployment, and JavaScript
    debugging directly from the editor. Besides this, WebStorm has excellent GitHub
    (and other version control systems) support. You can download a trial edition
    from [http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notepad++**: Notepad++ is a general-purpose editor that supports code highlighting
    for a wide range of programming languages. It can easily lay out and format JavaScript.
    Note that Notepad++ is only for Windows. You can download Notepad++ from [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text Editor**: Sublime is a great editor that has a very good support
    to edit JavaScript. Besides this, it provides many very helpful selections (such
    as multiple-line select) and edit options that, once you get used to them, provide
    a really good JavaScript-editing environment. Sublime can also be tested for free
    and can be downloaded from [http://www.sublimetext.com/](http://www.sublimetext.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you don't use any of these editors, there are a lot of editors available,
    open source and commercial, which you can use to edit JavaScript and create your
    Three.js projects. An interesting project you might want to look at is [http://c9.io](http://c9.io).
    This is a cloud-based JavaScript editor that can be connected to a GitHub account.
    This way, you can directly access all the source code and examples from this book
    and experiment with them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides these text-based editors that you can use to edit and experiment with
    the sources from this book, Three.js currently also provides an online editor
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: With this editor, which you can find at [http://threejs.org/editor/](http://threejs.org/editor/),
    you can create Three.js scenes using a graphical approach.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned that most modern web browsers support WebGL and can be used to run
    Three.js examples. I usually run my code in Chrome. The reason is that most often,
    Chrome has the best support and performance for WebGL and it has a really great
    JavaScript debugger. With this debugger, which is shown in the following screenshot,
    you can quickly pinpoint problems, for instance, using breakpoints and console
    output. This is exemplified in the following screenshot. Throughout this book,
    I'll give you pointers on debugger usage and other debugging tips and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements to use Three.js](img/2215OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's enough for an introduction to Three.js for now; let's get the source
    code and start with the first scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code for this book can be accessed from GitHub ([https://github.com/](https://github.com/)).
    GitHub is an online Git-based repository that you can use to store, access, and
    version source code. There are a couple of ways that you can get the sources for
    yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and extract the archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following two paragraphs, we'll explore these options in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git to clone the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git is an open source distributed version control system that I used to create
    and version all the examples in this book. For this, I used GitHub, a free, online
    Git repository. You can browse this repository by [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get all the examples, you can clone this repository using the `git` command-line
    tool. To do this, you first need to download a Git client for your operating system.
    For most modern operating systems, a client can be downloaded from [http://git-scm.com](http://git-scm.com),
    or you can use the one provided by GitHub itself (for Mac and Windows). After
    installing Git, you can use this to get a *clone* of this book''s repository.
    Open a command prompt and go to the directory where you want to download the sources.
    In that directory, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start downloading all the examples, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Git to clone the repository](img/2215OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `learning-three.js` directory will now contain all the examples that are
    used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and extracting the archive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don''t want to use Git to download the sources directly from GitHub,
    you can also download an archive. Open [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)
    in a browser and click on the **Download ZIP** button on the right-hand side,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading and extracting the archive](img/2215OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extract this to a directory of your choice, and you'll have all the examples
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've downloaded or cloned the source code, let's do a quick check
    to see whether everything is working and make you familiar with the directory
    structure. The code and examples are organized per chapter. There are two different
    ways of viewing examples. You can either open the extracted or cloned folder in
    a browser directly and look at and run a specific example, or you can install
    a local web server. This first approach will work for most of the basic examples,
    but when we start loading external resources, such as models or texture images,
    just opening the HTML file isn't enough. In this case, we need a local web server
    to make sure the external resources are loaded correctly. In the following section,
    we explain a couple of different ways you can set up a simple local web server
    for testing. If you can't set up a local web server but use Chrome or Firefox,
    we also provide an explanation on how to disable certain security features so
    that you can even test without a local web server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a local web server is very easy depending on what you've already
    got installed. In here, we list a couple of examples on how to do this. There
    are many different ways to do this depending on what you've already got installed
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Python-based web servers should work on most Unix/Mac systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most Unix/Linux/Mac systems already have Python installed. On those systems,
    you can very easily start a local web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Do this in the directory where you checked out / downloaded the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Npm-based web server if you've worked with Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''ve already done some work with Node.js, there is good chance you''ve
    got npm installed. With npm, you have two simple options to set up a quick local
    web server for testing. The first options uses the `http-server` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the `simple-http-server` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A disadvantage of this second approach, however, is that it doesn't automatically
    show directory listings, whereas the first approach does.
  prefs: []
  type: TYPE_NORMAL
- en: Portable version Mongoose for Mac and/or Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you haven't got Python or npm installed, there is a simple, portable web
    server, named Mongoose, that you can use. First, download the binaries for your
    specific platform from [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list).
    If you are using Windows, copy it to the directory containing the examples and
    double-click on the executable to start a web browser serving the directory it
    is started in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other operating systems, you must also copy the executable to the target
    directory, but instead of double-clicking on the executable, you have to launch
    it from the command line. In both cases, a local web server will be started on
    port `8080`. The following screenshot encapsulates the discussion in this paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Portable version Mongoose for Mac and/or Windows](img/2215OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By just clicking on a chapter, we can show and access all the examples for that
    specific chapter. If I discuss an example in this book, I'll refer to the specific
    name and folder so that you can directly test and play around with the code.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling security exceptions in Firefox and Chrome
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use Chrome to run the examples, there is a way to disable some security
    settings so that you can use Chrome to view the examples without requiring a web
    server. To do this, you have to start Chrome in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, you call the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On Linux, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And on Mac OS, you disable the settings by starting Chrome like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you start Chrome this way, you can access all the examples directly from
    the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Firefox users, we need to take a couple of different steps. Open Firefox
    and, in the URL bar, type `about:config`. This is what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disabling security exceptions in Firefox and Chrome](img/2215OS_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On this screen, click on the **I''ll be careful, I promise!** button. This
    will show you all the available properties you can use to fine-tune Firefox. In
    the search box on this screen, type in `security.fileuri.strict_origin_policy`
    and change its value to `false` just as we did in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disabling security exceptions in Firefox and Chrome](img/2215OS_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, you can also use Firefox to directly run the examples provided
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've either got a web server installed, or disabled the necessary
    security settings, it is time to start creating our first Three.js scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTML skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create an empty skeleton page that we can
    use as the base for all our examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this listing, the skeleton is a very simple HTML page, with
    only a couple of elements. In the `<head>` element, we load the external JavaScript
    libraries that we'll use for the examples. For all the examples, we'll at least
    need to load the Three.js library, `three.js`. In the `<head>` element, we also
    add a couple of lines of CSS. These style elements remove any scrollbars when
    we create a full-page Three.js scene. In the `<body>` element of this page, you
    can see a single `<div>` element. When we write our Three.js code, we'll point
    the output of the Three.js renderer to that element. At the bottom of this page,
    you can already see a bit of JavaScript. By assigning the `init` function to the
    `window.onload` property, we make sure that this function gets called when the
    HTML document has finished loading. In the `init` function, we'll insert all the
    Three.js specific JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js comes in two versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Three.min.js**: This is the library you''d normally use when deploying Three.js
    sites on the Internet. This is a minified version of Three.js, created using **UglifyJS**,
    which is a quarter size of the normal Three.js library. All the examples and code
    used in this book are based on Three.js **r69**, which was released in October
    2014.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three.js**: This is the normal Three.js library. We use this library in our
    examples since it makes debugging much easier when you can read and understand
    the Three.js source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we view this page in our browser, the results aren't very shocking. As you'd
    expect, all you see is an empty page.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn how to add the first couple of 3D objects
    and render those to the `<div>` element we defined in our HTML skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering and viewing a 3D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, you''ll create your first scene and add a couple of objects and
    a camera. Our first example will contain the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Plane` | This is a two-dimensional rectangle that serves as our ground area.
    In the second screenshot of this chapter, this is rendered as the gray rectangle
    in the middle of the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `Cube` | This is a three-dimensional cube, which we''ll render in red. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sphere` | This is a three-dimensional sphere, which we''ll render in blue.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Camera` | The camera determines what you''ll see in the output. |'
  prefs: []
  type: TYPE_TB
- en: '| `Axes` | These are the *x*, *y*, and *z* axes. This is a helpful debugging
    tool to see where the objects are rendered in 3D space. The *x* axis is colored
    red, the *y* axis is colored green, and the *z* axis is colored blue. |'
  prefs: []
  type: TYPE_TB
- en: 'I''ll first show you how this looks in code (the source with comments can be
    found in `chapter-01/02-first-scene.html`), and then I''ll explain what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open this example in the browser, we see something that resembles what
    we''re aiming at (see the screenshot at the beginning of this chapter), but it
    is still a long way off, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering and viewing a 3D object](img/2215OS_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we start making this more beautiful, I''ll first walk you through the
    code a step at a time so that you understand what the code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the example, we define `scene`, `camera`, and `renderer`. The
    `scene` object is a container that is used to store and keep track of all the
    objects we want to render and all the lights we want to use. Without a `THREE.Scene`
    object, Three.js isn't able to render anything. More information on the `THREE.Scene`
    object can be found in the next chapter. The sphere and the cube we want to render
    will be added to scene later on in the example. In this first fragment, we also
    create a `camera` object. The `camera` object defines what we'll see when we render
    a scene. In [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a
    Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, you learn
    more about the arguments you can pass in to the `camera` object. Next we define
    `renderer`. The `renderer` object is responsible for calculating what the `scene`
    object will look like in the browser based on the `camera` object's angle. We
    create `WebGLRenderer` that uses your graphics card to render the scene in this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look through the source code and the documentation of Three.js (which
    you can find at [http://threejs.org/](http://threejs.org/)), you'll notice that
    there are different renderers available besides the WebGL-based one. There is
    a canvas-based renderer and even an SVG-based one. Even though they work and can
    render simple scenes, I wouldn't recommend using them. They're very CPU-intensive
    and lack features such as good material support and shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we set the background color of `renderer` to almost white (`new THREE.Color(0XEEEEEE)`)
    with the `setClearColor` function and tell `renderer` how large the scene needs
    to be rendered using the `setSize` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve got a basic empty scene, a renderer, and a camera. There is,
    however, nothing yet to render. The following code adds the helper axes and the
    plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we create an `axes` object and use the `scene.add` function
    to add these axes to our scene. Next, we create the plane. This is done in two
    steps. First, we define what the plane looks like using the new `THREE.PlaneGeometry(60,20)`
    code. In this case, it has a width of `60` and a height of `20`. We also need
    to tell Three.js what this plane looks like (for example, its color and its transparency).
    In Three.js, we do this by creating a material object. For this first example,
    we'll create a basic material (`THREE.MeshBasicMaterial`) with the color `0xcccccc`.
    Next, we combine these two into a `Mesh` object with the name `plane`. Before
    we add `plane` to the scene, we need to put it in the correct position; we do
    this by first rotating it 90 degrees around the x axis, and next, we define its
    position in the scene using the position properties. If you're already interested
    in the details of this, look at the `06-mesh-properties.html` example from the
    code folder of [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up
    a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, which shows
    and explains rotation and positioning. We then need to do is add `plane` to `scene`,
    just like we did with `axes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cube` and `sphere` objects are added in the same manner, but with the
    `wireframe` property set to `true`, which tells Three.js to render a wireframe
    and not a solid object. Now, let''s move on to the final part of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all the elements we want to render are added to the scene at
    the correct positions. I've already mentioned that the camera defines what will
    be rendered. In this piece of code, we position the camera using the `x`, `y`,
    and `z` position attributes to hover above our scene. To make sure the camera
    is looking at our objects, we use the `lookAt` function to point it at the center
    of our scene, which is located at position (0, 0, 0) by default. All that is left
    to do is append the output from the renderer to the `<div>` element of our HTML
    skeleton. We use standard JavaScript to select the correct output element and
    append it to our `div` element with the `appendChild` function. Finally, we tell
    `renderer` to render `scene` using the `camera` object provided.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, we'll make this scene more pretty by adding
    lights, shadows, more materials, and even animations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding materials, lights, and shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding new materials and lights in Three.js is very simple and is done in pretty
    much the same way as we explained in the previous section. We start by adding
    a light source to the scene (for the complete source look at `03-materials-light.html`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`THREE.SpotLight` illuminates our scene from its position (`spotLight.position.set(
    -40, 60, -10 )`). If we render the scene this time, however, you won''t see any
    difference from the previous one. The reason is that different materials respond
    differently to light. The basic material we used in the previous example (`THREE.MeshBasicMaterial`)
    doesn''t do anything with the light sources in the scene. They just render the
    object in the specified color. So, we have to change the materials for `plane`,
    `sphere`, and `cube` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we changed the materials for our objects to `MeshLambertMaterial`.
    This material and `MeshPhongMaterial` are the materials Three.js provides that
    take light sources into account when rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result, shown in the following screenshot, however, still isn''t what we''re
    looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding materials, lights, and shadows](img/2215OS_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're getting there, and cube and sphere are looking a lot better. What is still
    missing, though, are the shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering shadows takes a lot of computing power, and for that reason, shadows
    are disabled by default in Three.js. Enabling them, though, is very easy. For
    shadows, we have to change the source in a couple of places, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change we need to make is tell `renderer` that we want shadows. You
    do this by setting the `shadowMapEnabled` property to `true`. If you look at the
    result from this change, you won''t notice anything different yet. That is because
    we need to explicitly define which objects cast shadows and which objects receive
    shadows. In our example, we want the sphere and the cube to cast shadows on the
    ground plane. You do this by setting the corresponding properties on those objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is just one more thing to do to get the shadows. We need to define
    which light sources in our scene will cause shadows. Not all the lights can cast
    shadows, and you''ll learn more about that in the next chapter, but `THREE.SpotLight`,
    which we used in this example, can. We only need to set the correct property,
    as shown in the following line of code, and the shadows will finally be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, we get a scene complete with shadows from our light source,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding materials, lights, and shadows](img/2215OS_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last feature that we'll add to this first scene is some simple animation.
    In [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, you'll learn more advanced animation options.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding your first scene with animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to animate the scene, the first thing that we need to do is find
    some way to re-render the scene at a specific interval. Before HTML5 and the related
    JavaScript APIs came along, the way to do this was using the `setInterval(function,interval)`
    function. With `setInterval`, we could specify a function that, for instance,
    would be called every 100 milliseconds. The problem with this function is that
    it doesn't take into account what is happening in the browser. If you were browsing
    another tab, this function would still be fired every couple of milliseconds.
    Besides that, `setInterval` isn't synchronized with the redrawing of the screen.
    This can lead to higher CPU usage and bad performance.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing requestAnimationFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern browsers luckily have a solution for that with the `requestAnimationFrame`
    function. With `requestAnimationFrame`, you can specify a function that is called
    at an interval defined by the browser. You do any drawing you need to do in the
    supplied function, and the browser will make sure it is painted as smoothly and
    efficiently as possible. Using this is really simple (the complete source can
    be found in the `04-materials-light-animation.html` file), you just create a function
    that handles the rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `renderScene` function, we call `requestAnimationFrame` again, to keep
    the animation going. The only thing we need to change in the code is that instead
    of calling `renderer.render` after we''ve created the complete scene, we call
    the `renderScene` function once to kick off the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you run this, you won't see any changes yet compared to the previous example
    because we haven't animated anything yet. Before we add the animation, though,
    I want to introduce a small helper library that gives us information about the
    frame rate the animation is running at. This library, from the same author as
    Three.js, renders a small graph that shows us the frames per second we're getting
    for this animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add these statistics, we first need to include the library in the `<head>`
    element of the HTML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add a `<div>` element that will be used as output for the statistics
    graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left to do is initialize the statistics and add them to this
    `<div>` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This function initializes the statistics. The interesting part is the `setMode`
    function. If we set it to `0`, we''ll measure frames per second (fps), and if
    we set this to `1`, we can measure rendering time. For this example, we''re interested
    in fps, so `0` it is. At the beginning of our `init()` function, we''ll call this
    function, and we''ve got `stats` enabled, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left to do is tell the `stats` object when we're in a new rendering
    cycle. We do this by adding a call to the `stats.update` function in our `renderScene`
    function, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code with these additions, you''ll see the statistics in the
    upper-left corner, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing requestAnimationFrame](img/2215OS_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Animating the cube
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `requestAnimationFrame` and the statistics configured, we''ve got a place
    to put our animation code. In this section, we''ll expand the `renderScene` function
    with code that will rotate our red cube around all of its axes. Let''s start by
    showing you the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That looks simple, right? What we do is that we increase the `rotation` property
    of each of the axes with 0.02 every time the `renderScene` function is called,
    which shows up as a cube smoothly rotating around all if its axes. Bouncing the
    blue ball isn't much harder.
  prefs: []
  type: TYPE_NORMAL
- en: Bouncing the ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bounce the ball, we once again add a couple of lines of code to our `renderScene`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the cube, we changed the `rotation` property; for the sphere, we''re going
    to change its `position` property in the scene. We want the sphere to bounce from
    one point in the scene to another with a nice, smooth curve. This is shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bouncing the ball](img/2215OS_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this, we need to change its position on the *x* axis and its position on
    the *y* axis. The `Math.cos` and `Math.sin` functions help us in creating a smooth
    trajectory using the step variable. I won''t go into the details of how this works
    here. For now, all you need to know is that `step+=0.04` defines the speed of
    the bouncing sphere. In [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    we''ll look in much more detail how these functions can be used for animation,
    and I''ll explain everything. Here''s how the ball looks in the middle of a bounce:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bouncing the ball](img/2215OS_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before wrapping up this chapter, I want to add one more element to our basic
    scene. When working with 3D scenes, animations, colors, and properties like that,
    it often requires a bit of experimenting to get the correct color or speed. It
    would be very easy if you could just have a simple GUI that allows you to change
    these kinds of properties on the fly. Luckily, there is!
  prefs: []
  type: TYPE_NORMAL
- en: Using dat.GUI to make experimenting easier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A couple of employees from Google created a library called **dat.GUI** (you
    can find the documentation online at [http://code.google.com/p/dat-gui/](http://code.google.com/p/dat-gui/)),
    which allows you to very easily create a simple user interface component that
    can change variables in your code. In this last part of this chapter, we''ll use
    dat.GUI to add a user interface to our example that allows us to change the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Control the speed of the bouncing ball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the rotation of the cube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like we had to do for the statistics, we first add this library to the
    `<head>` element of our HTML page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to configure is a JavaScript object that will hold the
    properties we want to change using dat.GUI. In the main part of our JavaScript
    code, we add the following JavaScript object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this JavaScript object, we define two properties—`this.rotationSpeed` and
    `this.bouncingSpeed`—and their default values. Next, we pass this object into
    a new dat.GUI object and define the range for these two properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotationSpeed` and `bouncingSpeed` properties are both set to a range
    of `0` to `0.5`. All we need to do now is make sure that in our `renderScene`
    loop, we reference these two properties directly so that when we make changes
    through the dat.GUI user interface, it immediately affects the rotation and bounce
    speed of our objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run this example (`05-control-gui.html`), you''ll see a simple
    user interface that you can use to control the bouncing and rotation speeds. A
    screenshot of the bouncing ball and the rotating cube is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using dat.GUI to make experimenting easier](img/2215OS_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you've looked at the examples in your browser, you might have noticed that
    when you change the size of your browser, the scene doesn't automatically scale.
    In the next section, we'll add this as a final feature for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically resize the output when browser size changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changing the camera when the browser is resized can be done pretty simply.
    The first thing we need to do is register an event listener like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever the browser window is resized, the `onResize` function, which
    we''ll specify next, is called. In this `onResize` function, we need to update
    the camera and renderer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the camera, we need to update the `aspect` property, which holds the aspect
    ratio of the screen, and for the `renderer`, we need to change its size. The final
    step is to move the variable definitions for `camera`, `renderer`, and `scene`
    outside of the `init()` function so that we can access them from different functions
    (like the `onResize` function), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To see this effect in action, open the `06-screen-size-change.html` example
    and resize your browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it for the first chapter. In this chapter, we showed you how to set up
    your development environment, how to get the code, and how to get started with
    the examples provided with this book. You further learned that to render a scene
    with Three.js, you first have to create a `THREE.Scene` object, add a camera,
    a light, and the objects that you want to render. We also showed you how you can
    expand this basic scene by adding shadows and animations. Lastly, we added a couple
    of helper libraries. We used dat.GUI, which allows you to quickly create control
    user interfaces, and we added `stats.js`, which provided feedback on the frame
    rate at which your scene is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll expand on the example we created here. You'll learn
    more about the most important building blocks that you can use in Three.js.
  prefs: []
  type: TYPE_NORMAL
