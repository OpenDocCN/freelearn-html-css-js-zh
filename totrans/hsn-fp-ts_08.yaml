- en: Immutability, Optics, and Laziness
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性、光学和惰性
- en: In the preceding chapters, we learned the most fundamental functional programming
    techniques and patterns, including some of the most commonly known algebraic data
    types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了最基础的函数式编程技术和模式，包括一些最著名的代数数据类型。
- en: 'In this chapter, we are going to learn about a number of additional functional
    programming techniques and patterns, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习许多额外的函数式编程技术和模式，包括以下内容：
- en: Immutability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Optics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光学
- en: Lenses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头
- en: Prims
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prim
- en: Lazy evaluation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估
- en: Once more, we will try to build everything from scratch, trying to avoid the
    use of third-party libraries. Our goal is to take a look at the internal implementation
    of some of these techniques and patterns so we can fully understand how they work.
    Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从头开始构建一切，尽量避免使用第三方库。我们的目标是查看这些技术和模式的一些内部实现，以便我们完全理解它们是如何工作的。让我们开始吧！
- en: Immutability
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'In this section, we are going to learn about immutable data structures. An
    immutable data structure is an object that doesn''t allow us to change its value.
    The easiest way to implement an immutable data structure in TypeScript is to use
    classes and the `readonly` keyword:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于不可变数据结构的内容。不可变数据结构是一个不允许我们更改其值的对象。在 TypeScript 中实现不可变数据结构的最简单方法就是使用类和
    `readonly` 关键字：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet declares a class named `Person`. The class has two
    public properties, named `name` and `age`. These two properties have been flagged
    as `readonly`. As we can see in the code snippet, when we try to update the values
    of the class properties, a compilation error is thrown.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为 `Person` 的类。该类有两个公共属性，分别命名为 `name` 和 `age`。这两个属性已被标记为 `readonly`。正如代码片段所示，当我们尝试更新类的属性值时，会抛出一个编译错误。
- en: 'The `readonly` properties can make our code more secure because it protects
    us from state mutations. For example, if we pass some immutable objects to a function
    as its arguments, the function will not be able to mutate the original objects.
    This means that our function will be more likely to be a pure function. However,
    not everything is good about immutable objects. Working with immutable objects
    can sometimes feel very tedious and verbose, particularly when we wish to generate
    a new state. Let''s take a look at an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 属性可以使我们的代码更安全，因为它可以保护我们免受状态突变的影响。例如，如果我们将一些不可变对象作为参数传递给一个函数，该函数将无法修改原始对象。这意味着我们的函数更有可能是一个纯函数。然而，不可变对象并非全是优点。处理不可变对象有时可能会感到非常繁琐和冗长，尤其是当我们希望生成一个新的状态时。让我们来看一个例子：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet declares three classes named `Street`, `Address`,
    and `Company`. All the properties in the three classes are `readonly`, which means
    that the classes are immutable. We can create a new instance of the `Company`
    class as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了三个名为 `Street`、`Address` 和 `Company` 的类。这三个类中的所有属性都是 `readonly`，这意味着这些类是不可变的。我们可以创建一个新的
    `Company` 类实例，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we say that an object is immutable, it means that we cannot change the
    original object, but it doesn''t mean that we don''t want to create derivative
    versions of it. For example, if we try to create a new version of a `Company`
    by transforming its street name into upper case, we will get an error, as shown
    in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个对象是不可变的，这意味着我们无法更改原始对象，但这并不意味着我们不希望创建其衍生版本。例如，如果我们尝试通过将街道名称转换为上标来创建一个新的
    `Company` 版本，我们将得到一个错误，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we might need to generate a new version with an uppercase street name.
    We can generate an updated version of the `Company` instance by creating a new
    `Company` instance. To create a new copy, we need to copy all the properties from
    the original instance into a new instance and use new values for the properties
    that we wish to mutate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能需要生成一个带有大写街道名称的新版本。我们可以通过创建一个新的 `Company` 实例来生成 `Company` 实例的更新版本。为了创建一个新的副本，我们需要将原始实例的所有属性复制到一个新实例中，并使用新的值来替换我们希望修改的属性：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Immutable data structures can help us to implement pure functions and make our
    code free of side effects. Mutating external variables is one of the most common
    causes of side effects, and using immutable data structures can help us to prevent
    such a mutation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构可以帮助我们实现纯函数，并使我们的代码无副作用。修改外部变量是副作用最常见的原因之一，而使用不可变数据结构可以帮助我们防止这种修改。
- en: Please note that you can refer to [Chapter 1](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml),
    *Functional Programming Fundamentals*, to learn more about side effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以参考 [第1章](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml)，*函数式编程基础*，以了解更多关于副作用的信息。
- en: 'However, as we can see in the previous code snippet, immutable data structures
    also have a negative side: they can lead to verbose and tedious code. The good
    news is that the minds behind the functional programming paradigm have found a
    solution to this problem known as **optics**. We are going to learn about optics
    in the following section.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们可以在之前的代码片段中看到的那样，不可变数据结构也有其负面影响：它们可能导致冗长且繁琐的代码。好消息是，函数式编程范式的背后人士已经找到了一种解决方案，称为
    **光学**。我们将在下一节中学习光学。
- en: Optics
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光学
- en: Optics is a functional programming concept that can help us to reduce the amount
    of code that we need to write and make operations more readable. The benefits
    of using optics are particularly noticeable when we are working with immutable
    data structures. All optics are a way to get and set properties in an object.
    In fact, we can think about optics as an alternative to getters and setters in
    object-oriented programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 光学是函数式编程的一个概念，可以帮助我们减少需要编写的代码量，并使操作更易于阅读。使用光学的好处在我们处理不可变数据结构时尤为明显。所有光学都是获取和设置对象属性的一种方式。实际上，我们可以将光学视为面向对象编程中获取器和设置器的替代品。
- en: Optics can be categorized into two main groups—**lenses** and **prisms**. As
    we learned in [Chapter 7](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml), *Category
    Theory*, algebraic data types can be defined in terms of sum and product types.
    A lens is used to work with product types (for example, tuples and objects) and
    a prism is used to work with sum types (for example, discriminated unions). During
    the remainder of this section, we are going to focus on the use of lenses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 光学可以分为两大类——**镜头**和**棱镜**。正如我们在 [第7章](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml)，*范畴论*
    中学到的，代数数据类型可以用和类型和积类型来定义。镜头用于处理积类型（例如，元组和对象），棱镜用于处理和类型（例如，区分联合）。在本节的剩余部分，我们将重点关注镜头的使用。
- en: Lenses
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜头
- en: 'A lens is just a pair of functions that allow us to get and set a value in
    an object. The interface of a lens could be declared as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头只是一对函数，允许我们在对象中获取和设置值。镜头的接口可以声明如下：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the previous code snippet, the lens generic interface declares
    two methods. The `get` method can be used to get the value of a property of type
    `T2` in an object of type `T1`. The `set` method can be used for the value of
    a property with type `T2` in an object of type `T1`. The following code snippet
    implements the `Lens` interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的代码片段中可以看到的，镜头泛型接口声明了两个方法。`get` 方法可以用来获取类型为 `T2` 的对象中属性值。`set` 方法可以用来设置类型为
    `T2` 的对象中的属性值。以下代码片段实现了 `Lens` 接口：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding implementation of the `Lens` interface is named `streetLens` and
    it allows us to set the value of a property with the `Street` type in an object
    of type `Object`. We can use the `streetLens` object to get the `Street` instance
    in an `Address` instance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的 `Lens` 接口被命名为 `streetLens`，它允许我们在 `Object` 类型的对象中设置 `Street` 类型的属性值。我们可以使用
    `streetLens` 对象来获取 `Address` 实例中的 `Street` 实例：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the `Lens` implementation to set the `Street` instance in the
    `Address` instance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `Lens` 实现来设置 `Address` 实例中的 `Street` 实例：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is important to note that the `set` method updates the `Street` instance
    and returns a new `Address` instance, as opposed to mutating the original `Address`
    instance. Now that we know the basics of how lenses work, we are going to take
    a look at some of the properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`set` 方法更新 `Street` 实例并返回一个新的 `Address` 实例，而不是修改原始的 `Address` 实例。现在我们知道了镜头如何工作的基础知识，我们将看看一些属性。
- en: 'One of the main characteristics of lenses is that they can be composed. As
    we learned in the preceding chapters, function composition is one of the main
    techniques in functional programming, and lenses are just functions, so they can
    be composed in a very similar way. The following code snippet declares a higher-order
    function that allows us to compose two lenses:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头的一个主要特征是它们可以被组合。正如我们在前面的章节中学到的，函数组合是函数式编程的主要技术之一，而镜头只是函数，因此它们可以以非常相似的方式组合。以下代码片段声明了一个高阶函数，允许我们组合两个镜头：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have declared a higher-order function that allows us to compose
    lenses, we are going to compose two lenses named `streetLens` and `nameLens`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了一个允许我们组合透镜的高阶函数，我们将组合两个名为 `streetLens` 和 `nameLens` 的透镜：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The return of the `composeLens` function creates a new lens named `streetName`.
    The new lens can be used to get the name of a `Street` instance within an `Address`
    instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`composeLens` 函数的返回值创建了一个名为 `streetName` 的新透镜。这个新透镜可以用来获取 `Address` 实例中 `Street`
    实例的名称：'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The lens can also be used to create a new `Address` instance with an updated `Street`
    name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 透镜还可以用来创建一个带有更新后的 `Street` 名称的新 `Address` 实例：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Many functional programming libraries also implement a function that allows
    us to map a given property in an object to a new value using a lens. The function
    is sometimes named `over`, but we are going to name it `overLens` to be clearer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数式编程库也实现了一个函数，允许我们使用透镜将对象中的给定属性映射到新值。这个函数有时被命名为 `over`，但我们将将其命名为 `overLens`
    以便更清晰：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding function takes a lens as its first argument, a mapping function
    as its second argument, and an object as its third argument. The function uses
    the lens to focus and update one of the properties of the objects using the mapping
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将其第一个参数作为透镜，第二个参数作为映射函数，第三个参数作为对象。该函数使用透镜通过映射函数聚焦和更新对象的某个属性：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, generating new versions of immutable objects using lenses can
    be much less verbose and tedious than using standard property accessors and class
    constructors. Now that we know the basics about lenses, we are going to implement
    some lenses again. The previous implementation was simplified to facilitate understanding.
    This time however, we are going to implement lenses in a way that is closer to
    the implementation of some popular libraries such as Ramda.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用透镜生成不可变对象的新版本，比使用标准属性访问器和类构造函数要简洁得多。现在我们了解了透镜的基础知识，我们将再次实现一些透镜。之前的实现被简化以方便理解。然而，这次我们将以更接近一些流行库（如
    Ramda）的实现方式来实现透镜。
- en: 'This time, we are going to declare two functions that are used as a getter
    and a setter. The function that is used as a getter is going to implement an interface
    named `Prop`. On the other hand, the function used as a setter is going to implement
    an interface named `Assoc`. The signature of the `Prop` and `Assoc` interfaces
    appears as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将声明两个函数，用作获取器和设置器。用作获取器的函数将实现一个名为 `Prop` 的接口。另一方面，用作设置器的函数将实现一个名为 `Assoc`
    的接口。`Prop` 和 `Assoc` 接口的签名如下所示：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code snippet declares functions that implement the `Prop` and `Assoc` interfaces.
    Both implementations are used to access a property named `street` in an object
    of type `Address`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了实现 `Prop` 和 `Assoc` 接口的函数。这两个实现都用于访问类型为 `Address` 的对象中的 `street` 属性：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One of the main differences in the new implementation is that we are going
    to declare a higher-order function named `lens`, and we are going to use it to
    generate a lens instance. The `lens` function takes two functions, a getter and
    a setter, which implement the `Prop` and `Assoc` interfaces accordingly. The lens
    function then returns an implementation of the `Lens` interface:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 新实现中的一个主要区别是我们将声明一个高阶函数，命名为 `lens`，并使用它来生成透镜实例。`lens` 函数接受两个函数，一个获取器和一个设置器，它们分别实现了
    `Prop` 和 `Assoc` 接口。然后，透镜函数返回 `Lens` 接口的实现：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we can invoke the `lens` function using the getter function, `propStreet`, 
    and the setter function, `assocStreet`, that we declared previously:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用之前声明的获取器函数 `propStreet` 和设置器函数 `assocStreet` 来调用 `lens` 函数：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another significant difference is that the new implementation uses two more
    functions, named `view` and `set`, as the getter and setter respectively. Both
    the `view` and `set` functions take a lens instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的区别是，新的实现使用了两个额外的函数，分别命名为 `view` 和 `set`，作为获取器和设置器。`view` 和 `set` 函数都接受一个透镜实例：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding functions use the lens `get` and `set` methods internally. However,
    we will use the `view` and `set` functions instead. The following code snippet
    demonstrates how to use the `view` function to get the `Street` instance within
    an `Address` instance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数在内部使用透镜的 `get` 和 `set` 方法。然而，我们将使用 `view` 和 `set` 函数。以下代码片段演示了如何使用 `view`
    函数获取 `Address` 实例中的 `Street` 实例：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code snippet demonstrates how to use the set function to set
    the value of the `Street` instance within an `Address` instance:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用`set`函数在`Address`实例中设置`Street`实例的值：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we have learned the basics regarding lenses. In the following
    section, we are going to learn about another kind of functional optic, known as
    **prisms**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了有关透镜的基础知识。在下一节中，我们将学习另一种功能光学元件，称为**棱镜**。
- en: Prisms
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 棱镜
- en: Prisms are almost identical to lenses. We can think about a prism as a kind
    of lens that allows us to get and set an optional property in an object. The most
    significant difference between lenses and prisms is that prisms can work with
    optional types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 棱镜几乎与透镜相同。我们可以将棱镜视为一种透镜，它允许我们在对象中获取和设置可选属性。透镜和棱镜之间最显著的区别是棱镜可以与可选类型一起工作。
- en: 'The following code snippet declares the `Prism` interface. As we can see, the
    `Prism` interface is very similar to the `Lens` interface. However, the `get`
    method returns an optional type, `Maybe<T>`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了`Prism`接口。正如我们所见，`Prism`接口与`Lens`接口非常相似。然而，`get`方法返回一个可选类型`Maybe<T>`：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just like lenses, prisms can be composed. The following code snippet declares
    a higher-order function that allows us to compose two prisms:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像透镜一样，棱镜也可以组合。以下代码片段声明了一个高阶函数，允许我们组合两个棱镜：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding function takes two prisms, `ab` with type `Prism<A, B>`, and `bc`
    with type `Prism<B, C>`, and returns the composition of both prisms with type `Prism<A,
    C>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数接受两个棱镜，`ab`类型为`Prism<A, B>`，和`bc`类型为`Prism<B, C>`，并返回两个棱镜的组合，类型为`Prism<A,
    C>`。
- en: 'Prisms also allow us to implement a function that allows us to map a property
    given an object and a prism. The function is usually named `over` in real-world
    libraries but, just as we did in the section about lenses, we are going to name
    it `overPrism` for clarity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 棱镜还允许我们实现一个函数，该函数可以将对象和棱镜给出的属性进行映射。在现实世界的库中，该函数通常命名为`over`，但就像我们在关于透镜的章节中所做的那样，我们将为了清晰起见将其命名为`overPrism`：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, we have declared the main building blocks required
    to work with prisms, including the `Prism` interface and the `composePrism` and
    `overPrism` functions. In the following section, we are going to demonstrate how
    to use a `prism` named `firstCharacterPrism` to focus on the first character of
    an optional string. The code snippet also declares a `prism` to access the `street`
    property in an `Address` instance and the `name` property in a `Street` instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了与棱镜一起工作的主要构建块，包括`Prism`接口和`composePrism`以及`overPrism`函数。在下一节中，我们将演示如何使用名为`firstCharacterPrism`的棱镜来关注可选字符串的第一个字符。代码片段还声明了一个棱镜来访问`Address`实例中的`street`属性和`Street`实例中的`name`属性。
- en: 'The `composePrism` is then used to compose the three `firstCharacterPrism`,
    `streetPrism`, and `namePrism` prisms into a new prism named `streetNameFirstCharater`.
    Finally, the `overPrism` function is used to map the value selected by `streetNameFirstCharacter`
    using the `R.toUpper` function. The result is a new instance of `Address` that contains
    a new instance of `Street` with a capitalized name. If the name is `null`, the
    new `Street` instance will contain `null` as its `name`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`composePrism`将三个`firstCharacterPrism`、`streetPrism`和`namePrism`棱镜组合成一个新的棱镜，命名为`streetNameFirstCharater`。最后，使用`overPrism`函数使用`R.toUpper`函数映射由`streetNameFirstCharacter`选定的值。结果是包含一个具有大写名称的新`Street`实例的新的`Address`实例。如果名称为`null`，新的`Street`实例将包含`null`作为其`name`：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Prisms are also useful when we want to work with other kinds of optional types,
    such as discriminated unions like the `Either` type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要处理其他类型的可选类型时，棱镜也非常有用，例如像`Either`类型这样的区分联合：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code snippet declares an optional type named `Either` and a type
    named `Domicile`, which uses the `Either` type to declare the union of two types.
    The code snippet also declares a `prism` named `addressPrism` that allows us to
    get or set the property `address` in an object of type `Domicile`. The property
    `address` can either be a `string` or an `Address` instance, and the `addressPrism`
    can handle both cases, as demonstrated by the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个名为`Either`的可选类型和一个名为`Domicile`的类型，它使用`Either`类型来声明两种类型的联合。代码片段还声明了一个名为`addressPrism`的棱镜，允许我们在类型为`Domicile`的对象中获取或设置`address`属性。属性`address`可以是`string`或`Address`实例，`addressPrism`可以处理这两种情况，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, we should understand the main characteristics of both lenses
    and prisms. In this chapter, we have created our own implementations of lenses
    and prisms because our main goal was to understand how they work. However, using
    a custom implementation is not recommended for professional software development
    projects. In [Chapter 10](35e51290-b4e7-44e8-bc7f-b9fbbe3bc94c.xhtml), *Real-World
    Functional Programming*, we will learn how to use production-ready optics with
    Ramda.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该理解透镜和棱镜的主要特性。在本章中，我们创建了透镜和棱镜的自己的实现，因为我们的主要目标是理解它们是如何工作的。然而，对于专业的软件开发项目来说，不建议使用自定义实现。在[第
    10 章](35e51290-b4e7-44e8-bc7f-b9fbbe3bc94c.xhtml)，*现实世界函数式编程*中，我们将学习如何使用 Ramda
    的生产就绪透镜。
- en: In the following section, we are going to learn about lazy evaluation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习懒加载（lazy evaluation）。
- en: Laziness
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Lazy evaluation is a technique or pattern that delays the evaluation of an expression
    until its value is needed. We are going to take a look at an example that doesn't
    use lazy evaluation first so that we can compare it with one that uses lazy evaluation
    later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是一种技术或模式，它将表达式的评估延迟到其值需要的时候。我们将首先查看一个不使用懒加载的例子，以便我们可以在稍后将其与使用懒加载的例子进行比较。
- en: 'The following code snippet declares an interface named `Dog` and an array of
    `Dog` that contains ten items. The `Dog` instances have two properties, named
    `size` and `name`. The code snippet also declares two functions, named `isLarge`
    and `isOld`. The `isLarge` function is used to find the `Dog` instances, with
    their `size` being equal to `"L"`. The `isOld` function is used to find the `Dog`
    instances with an `age` greater than `5`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `Dog` 的接口和一个包含十个 `Dog` 实例的数组。`Dog` 实例有两个属性，分别命名为 `size` 和 `name`。代码片段还声明了两个函数，分别命名为
    `isLarge` 和 `isOld`。`isLarge` 函数用于查找 `size` 等于 `"L"` 的 `Dog` 实例。`isOld` 函数用于查找年龄大于
    `5` 的 `Dog` 实例：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code snippet uses the array methods, `filter` and `find`. The
    `filter` method iterates all the elements in the `dogs` array. The result of filtering
    all the `Dog` instances using the `isLarge` function is a new array with five
    elements (all the elements with a `size` equal to `"L"`). We then use the `find`
    method to search a `Dog` instance in the new array using the `isOld` function.
    The `find` method iterates two items before the first item with an `age` greater
    than `5` is found. The final result is that we need to iterate 12 items before
    we can find an item that matches both the `isLarge` and `isOld` constraints.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段使用了数组方法 `filter` 和 `find`。`filter` 方法遍历 `dogs` 数组中的所有元素。使用 `isLarge` 函数过滤所有
    `Dog` 实例的结果是一个包含五个元素的新数组（所有 `size` 等于 `"L"` 的元素）。然后我们使用 `find` 方法通过 `isOld` 函数在新数组中搜索
    `Dog` 实例。`find` 方法在找到第一个年龄大于 `5` 的元素之前迭代了两个项目。最终结果是，我们需要迭代 12 个项目才能找到一个同时符合 `isLarge`
    和 `isOld` 约束条件的项目。
- en: Lazy evaluation is a technique that delays the execution of some operations
    until they can no longer be delayed. Lazy evaluation can sometimes lead to performance
    gains.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是一种技术，它将某些操作的执行延迟到它们不能再延迟的时候。懒加载有时可以带来性能提升。
- en: 'The following code snippet implements a function named `filter` and a function
    named `find`. Both functions are the equivalent of the array `filter` and `find`
    methods respectively. However, the `filter` function uses a generator (`function*`)
    and the `find` function uses a `for ... of` statement, which is used to iterate
    the items returned by the iterator created by the preceding generator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个名为 `filter` 的函数和一个名为 `find` 的函数。这两个函数分别与数组的 `filter` 和 `find` 方法等价。然而，`filter`
    函数使用生成器（`function*`），而 `find` 函数使用 `for ... of` 语句，该语句用于迭代由前面的生成器创建的迭代器返回的项目：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please remember that using iterators requires the compilation setting `downlevelIteration`
    to be true in the `tsconfig.json` file. Please refer to [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml),* Mastering
    Asynchronous* *Programming*, if you need additional help with generators.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用迭代器需要在 `tsconfig.json` 文件中将编译设置 `downlevelIteration` 设置为 true。如果您需要关于生成器的额外帮助，请参阅[第
    3 章](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml)，*精通异步编程*。
- en: 'The code snippet uses the `compose` function from Ramda to compose the return
    of `find(isOld)` and `filter(isLarge)`. The result is a new function named `findLargeOldDog`.
    We can use this function to find the `Dog` instances in the `dogs` array that
    matches both the `isLarge` and `isOld` constraints:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段使用了 Ramda 库中的 `compose` 函数来组合 `find(isOld)` 和 `filter(isLarge)` 的返回值。结果是一个名为
    `findLargeOldDog` 的新函数。我们可以使用这个函数来查找 `dogs` 数组中同时满足 `isLarge` 和 `isOld` 约束的 `Dog`
    实例：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result of this function is identical to the result of the example that didn't
    use lazy evaluation. However, this example only iterates four items instead of
    twelve. This is the case because when we execute the filter function, filtering
    doesn't take place. We delay its evaluation by returning an iterator. The evaluation
    is delayed until the iterator's `next` method is invoked by the `for ... of` statement.
    The find function iterates one item at a time and invokes both the `isOld` and `isLarge` functions,
    one item at a time. When the iterator returns the fourth item, it matches both
    the `isLarge` and `isOld` constraints and no more items need to be iterated. The
    lazy evaluated version is therefore much more efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果与未使用惰性评估的示例结果相同。然而，这个示例只迭代了四个项目，而不是十二个。这是因为当我们执行过滤函数时，过滤不会立即发生。我们通过返回一个迭代器来延迟其评估。评估将延迟到迭代器的
    `next` 方法被 `for ... of` 语句调用时。`find` 函数逐个迭代项目，并逐个调用 `isOld` 和 `isLarge` 函数。当迭代器返回第四个项目时，它同时满足
    `isLarge` 和 `isOld` 约束，因此不需要再迭代其他项目。因此，惰性评估版本要高效得多。
- en: In the preceding example, we have used generators and iterators to implement
    lazy evaluation, but this is not the only way to implement lazy evaluation. Lazy
    evaluation can be implemented using several JavaScript APIs, such as proxies or
    promises.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了生成器和迭代器来实现惰性评估，但这并不是实现惰性评估的唯一方法。惰性评估可以使用多个 JavaScript API 实现，例如代理或承诺。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how we can leverage functional programming
    techniques, such as lazy evaluation and immutability, to prevent some potential
    issues. We have also learned how to use optics to be able to work with immutable
    objects in a less verbose and tedious way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用函数式编程技术，如惰性评估和不可变性，来防止一些潜在问题。我们还学习了如何使用光学方法以更简洁、更不繁琐的方式处理不可变对象。
- en: In the next chapter, we are going to learn about **Functional Reactive Programming**
    (**FRP**). We will learn what reactive programming is and how it is connected
    to functional programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习关于**函数式响应式编程**（**FRP**）的内容。我们将了解响应式编程是什么，以及它与函数式编程之间的联系。
