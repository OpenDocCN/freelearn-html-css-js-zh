- en: Immutability, Optics, and Laziness
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we learned the most fundamental functional programming
    techniques and patterns, including some of the most commonly known algebraic data
    types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about a number of additional functional
    programming techniques and patterns, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lenses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prims
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once more, we will try to build everything from scratch, trying to avoid the
    use of third-party libraries. Our goal is to take a look at the internal implementation
    of some of these techniques and patterns so we can fully understand how they work.
    Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to learn about immutable data structures. An
    immutable data structure is an object that doesn''t allow us to change its value.
    The easiest way to implement an immutable data structure in TypeScript is to use
    classes and the `readonly` keyword:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code snippet declares a class named `Person`. The class has two
    public properties, named `name` and `age`. These two properties have been flagged
    as `readonly`. As we can see in the code snippet, when we try to update the values
    of the class properties, a compilation error is thrown.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readonly` properties can make our code more secure because it protects
    us from state mutations. For example, if we pass some immutable objects to a function
    as its arguments, the function will not be able to mutate the original objects.
    This means that our function will be more likely to be a pure function. However,
    not everything is good about immutable objects. Working with immutable objects
    can sometimes feel very tedious and verbose, particularly when we wish to generate
    a new state. Let''s take a look at an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet declares three classes named `Street`, `Address`,
    and `Company`. All the properties in the three classes are `readonly`, which means
    that the classes are immutable. We can create a new instance of the `Company`
    class as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we say that an object is immutable, it means that we cannot change the
    original object, but it doesn''t mean that we don''t want to create derivative
    versions of it. For example, if we try to create a new version of a `Company`
    by transforming its street name into upper case, we will get an error, as shown
    in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we might need to generate a new version with an uppercase street name.
    We can generate an updated version of the `Company` instance by creating a new
    `Company` instance. To create a new copy, we need to copy all the properties from
    the original instance into a new instance and use new values for the properties
    that we wish to mutate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Immutable data structures can help us to implement pure functions and make our
    code free of side effects. Mutating external variables is one of the most common
    causes of side effects, and using immutable data structures can help us to prevent
    such a mutation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can refer to [Chapter 1](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml),
    *Functional Programming Fundamentals*, to learn more about side effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as we can see in the previous code snippet, immutable data structures
    also have a negative side: they can lead to verbose and tedious code. The good
    news is that the minds behind the functional programming paradigm have found a
    solution to this problem known as **optics**. We are going to learn about optics
    in the following section.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Optics
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optics is a functional programming concept that can help us to reduce the amount
    of code that we need to write and make operations more readable. The benefits
    of using optics are particularly noticeable when we are working with immutable
    data structures. All optics are a way to get and set properties in an object.
    In fact, we can think about optics as an alternative to getters and setters in
    object-oriented programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Optics can be categorized into two main groups—**lenses** and **prisms**. As
    we learned in [Chapter 7](ca940a3c-ec71-4a5c-bb96-41dfe38228de.xhtml), *Category
    Theory*, algebraic data types can be defined in terms of sum and product types.
    A lens is used to work with product types (for example, tuples and objects) and
    a prism is used to work with sum types (for example, discriminated unions). During
    the remainder of this section, we are going to focus on the use of lenses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Lenses
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lens is just a pair of functions that allow us to get and set a value in
    an object. The interface of a lens could be declared as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the previous code snippet, the lens generic interface declares
    two methods. The `get` method can be used to get the value of a property of type
    `T2` in an object of type `T1`. The `set` method can be used for the value of
    a property with type `T2` in an object of type `T1`. The following code snippet
    implements the `Lens` interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding implementation of the `Lens` interface is named `streetLens` and
    it allows us to set the value of a property with the `Street` type in an object
    of type `Object`. We can use the `streetLens` object to get the `Street` instance
    in an `Address` instance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use the `Lens` implementation to set the `Street` instance in the
    `Address` instance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is important to note that the `set` method updates the `Street` instance
    and returns a new `Address` instance, as opposed to mutating the original `Address`
    instance. Now that we know the basics of how lenses work, we are going to take
    a look at some of the properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main characteristics of lenses is that they can be composed. As
    we learned in the preceding chapters, function composition is one of the main
    techniques in functional programming, and lenses are just functions, so they can
    be composed in a very similar way. The following code snippet declares a higher-order
    function that allows us to compose two lenses:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have declared a higher-order function that allows us to compose
    lenses, we are going to compose two lenses named `streetLens` and `nameLens`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The return of the `composeLens` function creates a new lens named `streetName`.
    The new lens can be used to get the name of a `Street` instance within an `Address`
    instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The lens can also be used to create a new `Address` instance with an updated `Street`
    name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Many functional programming libraries also implement a function that allows
    us to map a given property in an object to a new value using a lens. The function
    is sometimes named `over`, but we are going to name it `overLens` to be clearer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding function takes a lens as its first argument, a mapping function
    as its second argument, and an object as its third argument. The function uses
    the lens to focus and update one of the properties of the objects using the mapping
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, generating new versions of immutable objects using lenses can
    be much less verbose and tedious than using standard property accessors and class
    constructors. Now that we know the basics about lenses, we are going to implement
    some lenses again. The previous implementation was simplified to facilitate understanding.
    This time however, we are going to implement lenses in a way that is closer to
    the implementation of some popular libraries such as Ramda.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we are going to declare two functions that are used as a getter
    and a setter. The function that is used as a getter is going to implement an interface
    named `Prop`. On the other hand, the function used as a setter is going to implement
    an interface named `Assoc`. The signature of the `Prop` and `Assoc` interfaces
    appears as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code snippet declares functions that implement the `Prop` and `Assoc` interfaces.
    Both implementations are used to access a property named `street` in an object
    of type `Address`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'One of the main differences in the new implementation is that we are going
    to declare a higher-order function named `lens`, and we are going to use it to
    generate a lens instance. The `lens` function takes two functions, a getter and
    a setter, which implement the `Prop` and `Assoc` interfaces accordingly. The lens
    function then returns an implementation of the `Lens` interface:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we can invoke the `lens` function using the getter function, `propStreet`, 
    and the setter function, `assocStreet`, that we declared previously:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another significant difference is that the new implementation uses two more
    functions, named `view` and `set`, as the getter and setter respectively. Both
    the `view` and `set` functions take a lens instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding functions use the lens `get` and `set` methods internally. However,
    we will use the `view` and `set` functions instead. The following code snippet
    demonstrates how to use the `view` function to get the `Street` instance within
    an `Address` instance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code snippet demonstrates how to use the set function to set
    the value of the `Street` instance within an `Address` instance:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we have learned the basics regarding lenses. In the following
    section, we are going to learn about another kind of functional optic, known as
    **prisms**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Prisms
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prisms are almost identical to lenses. We can think about a prism as a kind
    of lens that allows us to get and set an optional property in an object. The most
    significant difference between lenses and prisms is that prisms can work with
    optional types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares the `Prism` interface. As we can see, the
    `Prism` interface is very similar to the `Lens` interface. However, the `get`
    method returns an optional type, `Maybe<T>`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just like lenses, prisms can be composed. The following code snippet declares
    a higher-order function that allows us to compose two prisms:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding function takes two prisms, `ab` with type `Prism<A, B>`, and `bc`
    with type `Prism<B, C>`, and returns the composition of both prisms with type `Prism<A,
    C>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Prisms also allow us to implement a function that allows us to map a property
    given an object and a prism. The function is usually named `over` in real-world
    libraries but, just as we did in the section about lenses, we are going to name
    it `overPrism` for clarity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, we have declared the main building blocks required
    to work with prisms, including the `Prism` interface and the `composePrism` and
    `overPrism` functions. In the following section, we are going to demonstrate how
    to use a `prism` named `firstCharacterPrism` to focus on the first character of
    an optional string. The code snippet also declares a `prism` to access the `street`
    property in an `Address` instance and the `name` property in a `Street` instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The `composePrism` is then used to compose the three `firstCharacterPrism`,
    `streetPrism`, and `namePrism` prisms into a new prism named `streetNameFirstCharater`.
    Finally, the `overPrism` function is used to map the value selected by `streetNameFirstCharacter`
    using the `R.toUpper` function. The result is a new instance of `Address` that contains
    a new instance of `Street` with a capitalized name. If the name is `null`, the
    new `Street` instance will contain `null` as its `name`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Prisms are also useful when we want to work with other kinds of optional types,
    such as discriminated unions like the `Either` type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code snippet declares an optional type named `Either` and a type
    named `Domicile`, which uses the `Either` type to declare the union of two types.
    The code snippet also declares a `prism` named `addressPrism` that allows us to
    get or set the property `address` in an object of type `Domicile`. The property
    `address` can either be a `string` or an `Address` instance, and the `addressPrism`
    can handle both cases, as demonstrated by the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, we should understand the main characteristics of both lenses
    and prisms. In this chapter, we have created our own implementations of lenses
    and prisms because our main goal was to understand how they work. However, using
    a custom implementation is not recommended for professional software development
    projects. In [Chapter 10](35e51290-b4e7-44e8-bc7f-b9fbbe3bc94c.xhtml), *Real-World
    Functional Programming*, we will learn how to use production-ready optics with
    Ramda.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to learn about lazy evaluation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Laziness
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation is a technique or pattern that delays the evaluation of an expression
    until its value is needed. We are going to take a look at an example that doesn't
    use lazy evaluation first so that we can compare it with one that uses lazy evaluation
    later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares an interface named `Dog` and an array of
    `Dog` that contains ten items. The `Dog` instances have two properties, named
    `size` and `name`. The code snippet also declares two functions, named `isLarge`
    and `isOld`. The `isLarge` function is used to find the `Dog` instances, with
    their `size` being equal to `"L"`. The `isOld` function is used to find the `Dog`
    instances with an `age` greater than `5`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code snippet uses the array methods, `filter` and `find`. The
    `filter` method iterates all the elements in the `dogs` array. The result of filtering
    all the `Dog` instances using the `isLarge` function is a new array with five
    elements (all the elements with a `size` equal to `"L"`). We then use the `find`
    method to search a `Dog` instance in the new array using the `isOld` function.
    The `find` method iterates two items before the first item with an `age` greater
    than `5` is found. The final result is that we need to iterate 12 items before
    we can find an item that matches both the `isLarge` and `isOld` constraints.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is a technique that delays the execution of some operations
    until they can no longer be delayed. Lazy evaluation can sometimes lead to performance
    gains.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet implements a function named `filter` and a function
    named `find`. Both functions are the equivalent of the array `filter` and `find`
    methods respectively. However, the `filter` function uses a generator (`function*`)
    and the `find` function uses a `for ... of` statement, which is used to iterate
    the items returned by the iterator created by the preceding generator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please remember that using iterators requires the compilation setting `downlevelIteration`
    to be true in the `tsconfig.json` file. Please refer to [Chapter 3](3e1c3d5e-9b0a-417c-9d73-366fbd7432d6.xhtml),* Mastering
    Asynchronous* *Programming*, if you need additional help with generators.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet uses the `compose` function from Ramda to compose the return
    of `find(isOld)` and `filter(isLarge)`. The result is a new function named `findLargeOldDog`.
    We can use this function to find the `Dog` instances in the `dogs` array that
    matches both the `isLarge` and `isOld` constraints:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段使用了 Ramda 库中的 `compose` 函数来组合 `find(isOld)` 和 `filter(isLarge)` 的返回值。结果是一个名为
    `findLargeOldDog` 的新函数。我们可以使用这个函数来查找 `dogs` 数组中同时满足 `isLarge` 和 `isOld` 约束的 `Dog`
    实例：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result of this function is identical to the result of the example that didn't
    use lazy evaluation. However, this example only iterates four items instead of
    twelve. This is the case because when we execute the filter function, filtering
    doesn't take place. We delay its evaluation by returning an iterator. The evaluation
    is delayed until the iterator's `next` method is invoked by the `for ... of` statement.
    The find function iterates one item at a time and invokes both the `isOld` and `isLarge` functions,
    one item at a time. When the iterator returns the fourth item, it matches both
    the `isLarge` and `isOld` constraints and no more items need to be iterated. The
    lazy evaluated version is therefore much more efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果与未使用惰性评估的示例结果相同。然而，这个示例只迭代了四个项目，而不是十二个。这是因为当我们执行过滤函数时，过滤不会立即发生。我们通过返回一个迭代器来延迟其评估。评估将延迟到迭代器的
    `next` 方法被 `for ... of` 语句调用时。`find` 函数逐个迭代项目，并逐个调用 `isOld` 和 `isLarge` 函数。当迭代器返回第四个项目时，它同时满足
    `isLarge` 和 `isOld` 约束，因此不需要再迭代其他项目。因此，惰性评估版本要高效得多。
- en: In the preceding example, we have used generators and iterators to implement
    lazy evaluation, but this is not the only way to implement lazy evaluation. Lazy
    evaluation can be implemented using several JavaScript APIs, such as proxies or
    promises.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了生成器和迭代器来实现惰性评估，但这并不是实现惰性评估的唯一方法。惰性评估可以使用多个 JavaScript API 实现，例如代理或承诺。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how we can leverage functional programming
    techniques, such as lazy evaluation and immutability, to prevent some potential
    issues. We have also learned how to use optics to be able to work with immutable
    objects in a less verbose and tedious way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用函数式编程技术，如惰性评估和不可变性，来防止一些潜在问题。我们还学习了如何使用光学方法以更简洁、更不繁琐的方式处理不可变对象。
- en: In the next chapter, we are going to learn about **Functional Reactive Programming**
    (**FRP**). We will learn what reactive programming is and how it is connected
    to functional programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习关于**函数式响应式编程**（**FRP**）的内容。我们将了解响应式编程是什么，以及它与函数式编程之间的联系。
